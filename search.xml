<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AtomicInteger原理分析</title>
    <url>/2018/07/04/AtomicInteger%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>AtomicInteger通俗的讲就是:对某个内存值拷贝一个副本,<br>某个线程若读到这个副本,则对其进行计算,输出结果,在写入<br>内存时,再次取出内存值与该副本比较,若副本与内存值相同<br>则把新的值写入内存.</p>
<p>较为官方的解释:通过CAS(AtomicInteger)实现,</p>
<h2 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h2><p>CAS有三个操作数,内存值V,旧的预期值A,要修改的新值B.当且仅当预期值A和<br>内存值V相同时,将内存值V修改为B,否则什么都不做.</p>
<h3 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题:"></a>两个问题:</h3><h3 id="1"><a href="#1" class="headerlink" title="(1)"></a>(1)</h3><p> CAS算法仍然可能出现冲突,例如A,B两个线程,A已经进入写内存但未完成<br>，此时A读取到的副本且读取成功，AB两个线程同时进入写内存操作，必然会造<br>成冲突。 CAS算法本质并非完全无锁，而是把获得锁和释放锁推迟至CPU原语实<br>现，相当于尽可能的缩小了锁的范围；直接互斥地实现系统状态的改变，它的使<br>用基本思想是copy-on-write——在修改完对象的副本之后再用CAS操作将副本<br>替换为正本。 </p>
<h3 id="2"><a href="#2" class="headerlink" title="(2)"></a>(2)</h3><p>ABA问题，若其中一个线程修改A-&gt;B-&gt;A，另外一个线程仍然读取到A，虽然值是<br>预期值，但并不能说明该内存值没有变化。</p>
]]></content>
      <tags>
        <tag>AtomicInteger</tag>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS防火墙设置与端口开放的方法</title>
    <url>/2018/04/23/CentOS%E9%98%B2%E7%81%AB%E5%A2%99%E8%AE%BE%E7%BD%AE%E4%B8%8E%E7%AB%AF%E5%8F%A3%E5%BC%80%E6%94%BE%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<pre><code>Centos升级到7后,内置的防火墙已经从iptables变成了firewalld,所以,端口
的开启还是要从两种情况来说明的,即iptables和firewalld.
更多内容请参考Rehat官网</code></pre><h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><pre><code>开启防火墙(重启后永久有效) : chkconfig iptables on

关闭防火墙(重启后永久有效) : chkconfig iptables off

开启防火墙(即时生效,重启后失效) : service iptables start

关闭防火墙(即时生效,重启后失效) : service iptables stop

重启防火墙 :service iptables restartd

查看打开的端口
/etc/init.d/iptables status

打开某个端口(以8080为例)

(1) 开启端口

iptables -A INPUT -p tcp --dport 8080 -j ACCEPT

(2)保存并重启防火墙

/etc/rc.d/init.d/iptables save
/etc/init.d/iptables restart

打开49152~65534之间的端口

iptables -A INPUT -p tcp --dport 49152:65534 -j ACCEPT

同样,这里需要对设置进行保存,并重启防火墙.

其他打开方式

我们还可以通过修改/etc/sysconfig/iptables文件方式开启端口,如下

vi /etc/sysconfig/iptables

然后再文件中增加一行

-A RH-Firewall-1-INPUT -m state -state NEW -m tcp -p tcp -dport 8080 -j ACCEPT

参数说明:

-A 参数就看成是添加一条规则
-p 指定是什么协议,我们常用的tcp协议,当然也有udp,例如53端口的DNS
-dport 就是目标端口,当数据从外部进入服务器为目标端口
-sport 数据从服务器出去,则为数据源端口使用
-j 就是指定是ACCEPT -接收或者DROP不接收</code></pre><h3 id="firewalld"><a href="#firewalld" class="headerlink" title="firewalld"></a>firewalld</h3><pre><code>Centos7默认安装了firewalld,如果没有安装的话,可以使用
yum install firewalld firewalld-config进行安装.

1启动防火墙

systemctl start firewalld

2 禁用防火墙

systemctl stop firewalld

3 设置开机启动

systemctl enable firewalld

4 停止并禁用开机启动

systemctl disable firewalld

5 重启防火墙

firewall-cmd --reload

6 查看状态

systemctl status firewalld或者 firewall-cmd --state

7查看版本

firewall-cmd --version

8查看帮助

firewall-cmd --help

9查看区域信息

firewall-cmd --get-active-zones

10查看指定接口所属区域信息

firewall-cmd --get-zone-of-interface=eth0

11 拒绝所有包

firewall-cmd --panic-on

12 取消拒绝状态

firewall-cmd --panic-off

13 查看是否拒绝

firewall-cmd --query-panic

14将接口添加到区域(默认接口都在public)

firewall-cmd --zone=public --add-interface=eth0(永久生效再加上 --permanent 然后reload防火墙)

15 设置默认接口区域

firewall-cmd --set-default-zone=public(立即生效,无需重启)

16 更新防火墙规则

firewall-cmd --reload或firewall-cmd --complete-reload(两
者的区别就是第一个无需断开连接,就是firewalld特性之一动态
添加规则,第二个需要断开连接,类似重启服务)

17 查看指定区域所有打开的端口  

firewall-cmd --zone=public --list-ports

18指定区域打开端口(记得重启防火墙)

firewall-comd --zone=public --add-port=80/tcp(永久生效再加上 --permanent)

说明:
-zone 作用域
-add-port=8080/tcp 添加端口,格式为:端口/通讯协议
-permanent #永久生效,没有此参数重启后失效

参考文章：
http://havee.me/linux/2015-01/using-firewalls-on-centos-7.html</code></pre>]]></content>
      <tags>
        <tag>linux</tag>
        <tag>CentOS</tag>
        <tag>防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title> AtomicInteger类的理解与使用</title>
    <url>/2018/07/04/AtomicInteger%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>引用:<a href="https://blog.csdn.net/u012734441/article/details/51619751" target="_blank" rel="noopener">https://blog.csdn.net/u012734441/article/details/51619751</a></p>
<p>首先看两段代码，一段是Integer的，一段是AtomicInteger的，为以下：</p>
<pre><code>public class Sample1 {

    private static Integer count = 0;

    synchronized public static void increment() {
        count++;
    }

}</code></pre><p>以下是AtomicInteger的：</p>
<pre><code>public class Sample2 {

    private static AtomicInteger count = new AtomicInteger(0);

    public static void increment() {
        count.getAndIncrement();
    }

}</code></pre><p>对比发现:使用Integer时必须加上synchronized保证不会出现并发线程同时<br>访问的情况,而AtomicInteger中却不用加上synchronized,在这里AtomicInteger<br>是提供原子操作的.</p>
<p>AtomicInteger是一个提供原子操作的Integer类，通过线程安全的方式操作加减。</p>
<p>AtomicInteger使用场景</p>
<p>AtomicInteger提供原子操作来进行Integer的使用，因此十分适合高并发情况下的使用。</p>
<p>AtomicInteger源码部分讲解</p>
<pre><code>public class AtomicInteger extends Number implements java.io.Serializable {
    private static final long serialVersionUID = 6214790243416807050L;

    // setup to use Unsafe.compareAndSwapInt for updates
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long valueOffset;

    static {
        try{
            valueOffset = unsafe.objectFieldOffset
                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));
        } catch (Exception e) {
            throw new Error(ex);
        }
    }
    private volatile int value;

}</code></pre><p>以上为AtomicInteger中的部分源码，在这里说下其中的value，<br>这里value使用了volatile关键字，volatile在这里可以做到的<br>作用是使得多个线程可以共享变量，但是问题在于使用volatile将<br>使得VM优化失去作用，导致效率较低，所以要在必要的时候使用，<br>因此AtomicInteger类不要随意使用，要在使用场景下使用。</p>
<h2 id="AtomicInteger实例使用"><a href="#AtomicInteger实例使用" class="headerlink" title="AtomicInteger实例使用"></a>AtomicInteger实例使用</h2><p>以下就是在多线程情况下，使用AtomicInteger的一个实例，这段代码是借用IT宅中的一段代码。</p>
<p> public class AtomicTest {</p>
<pre><code>static long randomTime() {
    return (long) (Math.random() * 1000);
}

public static void main(String[] args) {
    // 阻塞队列，能容纳100个文件
    final BlockingQueue&lt;File&gt; queue = new LinkedBlockingQueue&lt;File&gt;(100);
    // 线程池
    final ExecutorService exec = Executors.newFixedThreadPool(5);
    final File root = new File(&quot;D:\\ISO&quot;);
    // 完成标志
    final File exitFile = new File(&quot;&quot;);
    // 原子整型，读个数
    // AtomicInteger可以在并发情况下达到原子化更新，避免使用了synchronized，而且性能非常高。
    final AtomicInteger rc = new AtomicInteger();
    // 原子整型，写个数
    final AtomicInteger wc = new AtomicInteger();
    // 读线程
    Runnable read = new Runnable() {
        public void run() {
            scanFile(root);
            scanFile(exitFile);
        }

        public void scanFile(File file) {
            if (file.isDirectory()) {
                File[] files = file.listFiles(new FileFilter() {
                    public boolean accept(File pathname) {
                        return pathname.isDirectory() || pathname.getPath().endsWith(&quot;.iso&quot;);
                    }
                });
                for (File one : files)
             scanFile(one);
            } else {
                try {
                    // 原子整型的incrementAndGet方法，以原子方式将当前值加 1，返回更新的值
                    int index = rc.incrementAndGet();
                    System.out.println(&quot;Read0: &quot; + index + &quot; &quot; + file.getPath());
                    // 添加到阻塞队列中
                    queue.put(file);
                } catch (InterruptedException e) {

                }
            }
        }
    };
    // submit方法提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。
    exec.submit(read);

    // 四个写线程
    for (int index = 0; index &lt; 4; index++) {
        // write thread
        final int num = index;
        Runnable write = new Runnable() {
            String threadName = &quot;Write&quot; + num;

            public void run() {
                while (true) {
                    try {
                        Thread.sleep(randomTime());
                        // 原子整型的incrementAndGet方法，以原子方式将当前值加 1，返回更新的值
                        int index = wc.incrementAndGet();
                        // 获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）。
                        File file = queue.take();
                        // 队列已经无对象
                        if (file == exitFile) {
                            // 再次添加&quot;标志&quot;，以让其他线程正常退出
                            queue.put(exitFile);
                            break;
                                      }
                                                        System.out.println(threadName + &quot;: &quot; + index + &quot; &quot; + file.getPath());
                                                    } catch (InterruptedException e) {
                                                    }
                                                }
                                            }

                                        };
                                        exec.submit(write);
                                    }
                                    exec.shutdown();
                                }

                            }</code></pre><h2 id="AtomicInteger使用总结"><a href="#AtomicInteger使用总结" class="headerlink" title="AtomicInteger使用总结"></a>AtomicInteger使用总结</h2><p>AtomicInteger是在使用非阻塞算法实现并发控制，在一些高并发程序中非常适合，但并不能每一种场景都适合，不同场景要使用使用不同的数值类。</p>
]]></content>
      <tags>
        <tag>AtomicInteger</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>DevOps简介</title>
    <url>/2019/12/02/DevOps%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/liufei1983/p/7152013.html" target="_blank" rel="noopener">摘抄自</a></p>
<h1 id="DevOps简介"><a href="#DevOps简介" class="headerlink" title="DevOps简介"></a>DevOps简介</h1><p>DevOps是一个完整的面向IT运维的工作流，以IT自动化以及持续集成（CI）、持续部署（CD）为基础，来优化开发、测试、系统运维等多有环节。</p>
<h1 id="DevOps的概念"><a href="#DevOps的概念" class="headerlink" title="DevOps的概念"></a>DevOps的概念</h1><p>DevOps一词的来自于Development和Operations的组合，突出重视软件开发人员和运维人员的沟通合作，通过自动化流程来使得软件构建、测试、发布更加快捷、频繁和可靠。</p>
<p><img src="devops.png" alt=""><br>DevOps是为了填补开发端和运维端之间的信息鸿沟，改善团队之间的协作关系。不过需要澄清的一点是，从开发到运维，中间还有测试环节。DevOps其实包含了三个部分：开发、测试和运维。</p>
<p><img src="dev2.png" alt=""><br>换句话说，DevOps希望做到的是软件产品交付过程中IT工具链的打通，使得各个团队减少时间损耗，更加高效地协同工作。专家们总结出了下面这个DevOps能力图，良好的闭环可以大大增加整体的产出。<br><img src="dev3.png" alt=""></p>
<h1 id="历史变革"><a href="#历史变革" class="headerlink" title="历史变革"></a>历史变革</h1><p>由上所述，相信大家对DevOps有了一定的了解。但是除了触及工具链之外，作为文化和技术的方法论，DevOps还需要公司在组织文化上的变革。回顾软件行业的研发模式，可以发现大致有三个阶段：瀑布式开发、敏捷开发、DevOps。</p>
<p>DevOps早在九年前就有人提出来，但是，为什么这两年才开始受到越来越多的企业重视和实践呢？因为DevOps的发展是独木不成林的，现在有越来越多的技术支撑。微服务架构理念、容器技术使得DevOps的实施变得更加容易，计算能力提升和云环境的发展使得快速开发的产品可以立刻获得更广泛的使用。</p>
<p>好处是什么？</p>
<p>DevOps的一个巨大好处就是可以高效交付，这也正好是它的初衷。Puppet和DevOps Research and Assessment (DORA) 主办了2016年DevOps调查报告，根据全球4600位各IT公司的技术工作者的提交数据统计，得出高效公司平均每年可以完成1460次部署。</p>
<p>与低效组织相比，高效组织的部署频繁200倍，产品投入使用速度快2555倍，服务恢复速度快24倍。在工作内容的时间分配上，低效者要多花22%的时间用在为规划好或者重复工作上，而高效者却可以多花29%的时间用在新的工作上。所以这里的高效不仅仅指公司产出的效率提高，还指员工的工作质量得到提升。</p>
<p>DevOps另外一个好处就是会改善公司组织文化、提高员工的参与感。员工们变得更高效，也更有满足和成就感；调查显示高效员工的雇员净推荐值（eNPS:employee Net Promoter Score）更高，即对公司更加认同。</p>
<p>快速部署同时提高IT稳定性。这难道不矛盾吗？</p>
<p>快速的部署其实可以帮助更快地发现问题，产品被更快地交付到用户手中，团队可以更快地得到用户的反馈，从而进行更快地响应。而且，DevOps小步快跑的形式带来的变化是比较小的，出现问题的偏差每次都不会太大，修复起来也会相对容易一些。</p>
<p><img src="dev4.png" alt=""></p>
<p>因此，认为速度就意味着危险是一种偏见。此外，滞后软件服务的发布也并不一定会完全地避免问题，在竞争日益激烈的IT行业，这反而可能错失了软件的发布时机</p>
<h1 id="为什么DevOps会兴起？"><a href="#为什么DevOps会兴起？" class="headerlink" title="为什么DevOps会兴起？"></a>为什么DevOps会兴起？</h1><h2 id="条件成熟：技术配套发展"><a href="#条件成熟：技术配套发展" class="headerlink" title="条件成熟：技术配套发展"></a>条件成熟：技术配套发展</h2><p>技术的发展使得DevOps有了更多的配合。早期时，大家虽然意识到了这个问题的，但是苦于当时没有完善丰富的技术工具，是一种“理想很丰满，但是现实很骨感”的情况。DevOps的实现可以基于新兴的容器技术；也可以在自动化运维工具Puppet、SaltStack、Ansible之后的延伸；还可以构建在传统的Cloud Foundry、OpenShift等PaaS厂商之上。</p>
<h2 id="来自市场的外部需求：这世界变化太快"><a href="#来自市场的外部需求：这世界变化太快" class="headerlink" title="来自市场的外部需求：这世界变化太快"></a>来自市场的外部需求：这世界变化太快</h2><p>IT行业已经越来越与市场的经济发展紧密挂钩，专家们认为IT将会有支持中心变成利润驱动中心。事实上，这个变化已经开始了，这不仅体现在Google、苹果这些大企业中，而且也发生在传统行业中，比如出租车业务中的Uber、酒店连锁行业中的Airbnb、图书经销商Amazon等等。能否让公司的IT配套方案及时跟上市场需求的步伐，在今天显得至关重要。</p>
<p>DevOps 2016年度报告给出了一个运维成本的计算公式：<br>停机费用成本 = 部署频率 * 版本迭代失败概率 * 平均修复时间 * 断电的金钱损失</p>
<p>来自团队的内在动力：工程师也需要</p>
<p>对于工程师而言，他们也是DevOps的受益者。微软资深工程师Scott Hanselman说过“对于开发者而言，最有力的工具就是自动化工具”（The most powerful tool we have as developers is automation）。</p>
<p>工具链的打通使得开发者们在交付软件时可以完成生产环境的构建、测试和运行；正如Amazon的VP兼CTO Werner Vogels那句让人印象深刻的话：“谁开发谁运行”。（You build it, you run it）</p>
<h2 id="实现DevOps需要什么？"><a href="#实现DevOps需要什么？" class="headerlink" title="实现DevOps需要什么？"></a>实现DevOps需要什么？</h2><h2 id="硬性要求：工具上的准备"><a href="#硬性要求：工具上的准备" class="headerlink" title="硬性要求：工具上的准备"></a>硬性要求：工具上的准备</h2><p>上文提到了工具链的打通，那么工具自然就需要做好准备。现将工具类型及对应的不完全列举整理如下：</p>
<ul>
<li><p>代码管理（SCM）：GitHub、GitLab、BitBucket、SubVersion</p>
</li>
<li><p>构建工具：Ant、Gradle、maven</p>
</li>
<li><p>自动部署：Capistrano、CodeDeploy</p>
</li>
<li><p>持续集成（CI）：Bamboo、Hudson、Jenkins</p>
</li>
<li><p>配置管理：Ansible、Chef、Puppet、SaltStack、ScriptRock GuardRail</p>
</li>
<li><p>容器：Docker、LXC、第三方厂商如AWS</p>
</li>
<li><p>编排：Kubernetes、Core、Apache Mesos、DC/OS</p>
</li>
<li><p>服务注册与发现：Zookeeper、etcd、Consul</p>
</li>
<li><p>脚本语言：python、ruby、shell</p>
</li>
<li><p>日志管理：ELK、Logentries</p>
</li>
<li><p>系统监控：Datadog、Graphite、Icinga、Nagios</p>
</li>
<li><p>性能监控：AppDynamics、New Relic、Splunk</p>
</li>
<li><p>压力测试：JMeter、Blaze Meter、loader.io</p>
</li>
<li><p>预警：PagerDuty、pingdom、厂商自带如AWS SNS</p>
</li>
<li><p>HTTP加速器：Varnish</p>
</li>
<li><p>消息总线：ActiveMQ、SQS</p>
</li>
<li><p>应用服务器：Tomcat、JBoss</p>
</li>
<li><p>Web服务器：Apache、Nginx、IIS</p>
</li>
<li><p>数据库：MySQL、Oracle、PostgreSQL等关系型数据库；cassandra、mongoDB、redis等NoSQL数据库</p>
</li>
<li><p>项目管理（PM）：Jira、Asana、Taiga、Trello、Basecamp、Pivotal Tracker<br>在工具的选择上，需要结合公司业务需求和技术团队情况而定。（注：更多关于工具的详细介绍可以参见此文：51 Best DevOps Tools for #DevOps Engineers）</p>
</li>
</ul>
<h2 id="软性需求：文化和人"><a href="#软性需求：文化和人" class="headerlink" title="软性需求：文化和人"></a>软性需求：文化和人</h2><p>DevOps成功与否，公司组织是否利于协作是关键。开发人员和运维人员可以良好沟通互相学习，从而拥有高生产力。并且协作也存在于业务人员与开发人员之间。</p>
<p>出席了2016年伦敦企业级DevOps峰会的ITV公司在2012年就开始落地DevOps，其通用平台主管Clark在接受了InfoQ的采访，在谈及成功时表示，业务人员非常清楚他们希望在最小化可行产品中实现什么，工程师们就按需交付，不做多余工作。</p>
<p>这样，工程师们使用通用的平台（即打通的工具链）得到更好的一致性和更高的质量。此外，DevOps对工程师个人的要求也提高了，很多专家也认为招募到优秀的人才也是一个挑战。</p>
<h2 id="DevOps的采用现状"><a href="#DevOps的采用现状" class="headerlink" title="DevOps的采用现状"></a>DevOps的采用现状</h2><h3 id="哪些公司在用？"><a href="#哪些公司在用？" class="headerlink" title="哪些公司在用？"></a>哪些公司在用？</h3><p>DevOps正在增长，尤其是在大企业中：调查发现，DevOps的接受度有了显著提高。74%的受访者已经接受了DevOps，而去年这一比例为66%。目前，在81%的大企业开始接受DevOps，中小企业的接受度仅为70%。<br>那么具体而言都有些公司在采用DevOps呢？Adobe、Amazon、Apple、Airbnb、Ebay、Etsy、Facebook、LinkedIn、Netflix、NASA、Starbucks、Target（泛欧实时全额自动清算系统）、Walmart、Sony等等。</p>
<h3 id="他们怎么实施的？"><a href="#他们怎么实施的？" class="headerlink" title="他们怎么实施的？"></a>他们怎么实施的？</h3><p>首先，大企业正在自下而上接受DevOps，其中业务单位或部门（31%）以及项目和团队（29%）已经实施DevOps。不过，只有21%的大企业在整个公司范围内采用了DevOps。 </p>
<p>其次，在工具层面上，DevOps工具的用量大幅激增。Chef和Puppet依然是最常用的DevOps工具，使用率均为32%。Docker是年增长率最快的工具，用量增长一倍以上。Ansible的用量也有显著增加，使用率从10%翻倍至20%。</p>
]]></content>
      <categories>
        <category>开发模式</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>开发模式，摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title>Git配置多个SSH-Key</title>
    <url>/2019/09/02/Git%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>当有多个git账号时，比如：</p>
<p>a. 一个gitee，用于公司内部的工作开发；<br>b. 一个github，用于自己进行一些开发活动；</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ol>
<li><p>生成一个公司用的SSH-Key</p>
<p>$ ssh-keygen -t rsa -C ‘xxxxx@company.com’ -f ~/.ssh/gitee_id_rsa</p>
</li>
<li><p>生成一个github用的SSH-Key</p>
<p>$ ssh-keygen -t rsa -C ‘xxxxx@qq.com’ -f ~/.ssh/github_id_rsa</p>
</li>
<li><p>在 ~/.ssh 目录下新建一个config文件，添加如下内容（其中Host和HostName填写git服务器的域名，IdentityFile指定私钥的路径）</p>
<h1 id="gitee"><a href="#gitee" class="headerlink" title="gitee"></a>gitee</h1><p>Host gitee.com<br>HostName gitee.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/gitee_id_rsa</p>
<h1 id="github"><a href="#github" class="headerlink" title="github"></a>github</h1><p>Host github.com<br>HostName github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/github_id_rsa</p>
<p>4.用ssh命令分别测试</p>
<p>$ ssh -T <a href="mailto:git@gitee.com">git@gitee.com</a><br>$ ssh -T <a href="mailto:git@github.com">git@github.com</a></p>
</li>
</ol>
<p><a href="https://gitee.com/help/articles/4229#article-header0" target="_blank" rel="noopener">参考</a>  </p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ IDEA开发快捷键(IDEA tool Keyboard shutcuts)</title>
    <url>/2018/07/04/IntelliJ-IDEA%E5%BC%80%E5%8F%91%E5%BF%AB%E6%8D%B7%E9%94%AE-IDEA-tool-Keyboard-shutcuts/</url>
    <content><![CDATA[<p>IDEA tool Keyboard shutcuts：</p>
<table>
<thead>
<tr>
<th align="left">Action</th>
<th align="left">Mac OSX</th>
<th align="left">Win/Linux</th>
</tr>
</thead>
<tbody><tr>
<td align="left">注释代码(//)</td>
<td align="left">Cmd + /</td>
<td align="left">Ctrl + /</td>
</tr>
<tr>
<td align="left">注释代码(/**/)</td>
<td align="left">Cmd + Option + /</td>
<td align="left">Ctrl + Shift + /</td>
</tr>
<tr>
<td align="left">格式化代码</td>
<td align="left">Cmd + Option + L</td>
<td align="left">Ctrl + Alt + L</td>
</tr>
<tr>
<td align="left">清除无效包引用</td>
<td align="left">Option + Control + O</td>
<td align="left">Alt + Ctrl + O</td>
</tr>
<tr>
<td align="left">查找</td>
<td align="left">Cmd + F</td>
<td align="left">Ctrl + F</td>
</tr>
<tr>
<td align="left">查找+替换</td>
<td align="left">Cmd + R</td>
<td align="left">Ctrl + R</td>
</tr>
<tr>
<td align="left">上下移动代码</td>
<td align="left">Option + Shift + Up/Down</td>
<td align="left">Alt + Shift + Up/Down</td>
</tr>
<tr>
<td align="left">删除行</td>
<td align="left">Cmd + Delete</td>
<td align="left">Ctrl + Y</td>
</tr>
<tr>
<td align="left">扩大缩小选中范围</td>
<td align="left">Option + Up/Down</td>
<td align="left">Ctrl + W/Ctrl + Shift + W</td>
</tr>
<tr>
<td align="left">快捷生成结构体</td>
<td align="left">Cmd + Option + T</td>
<td align="left">Ctrl + Alt + T</td>
</tr>
<tr>
<td align="left">快捷覆写方法</td>
<td align="left">Cmd + O</td>
<td align="left">Ctrl + O</td>
</tr>
<tr>
<td align="left">快捷定位到行首/尾</td>
<td align="left">Cmd + Left/Right</td>
<td align="left">Ctrl + Left/Right</td>
</tr>
<tr>
<td align="left">折叠展开代码块</td>
<td align="left">Cmd + Plus,Minus</td>
<td align="left">Ctrl + Plus/Minus</td>
</tr>
<tr>
<td align="left">折叠展开全部代码块</td>
<td align="left">Cmd + Shift + Plus,Minus</td>
<td align="left">Ctrl + Shift + Plus,Minus</td>
</tr>
<tr>
<td align="left">文件方法结构</td>
<td align="left">Cmd + F12</td>
<td align="left">Ctrl + F12</td>
</tr>
<tr>
<td align="left">查找调用的位置</td>
<td align="left">Ctrl + Option + H</td>
<td align="left">Ctrl + Alt + H</td>
</tr>
<tr>
<td align="left">大小写转换</td>
<td align="left">Cmd + Shift + U</td>
<td align="left">Ctrl + Shift + U</td>
</tr>
<tr>
<td align="left">找到使用</td>
<td align="left">Alt+F7</td>
<td align="left">Alt+F7</td>
</tr>
<tr>
<td align="left">显示使用</td>
<td align="left">Ctrl+Alt+F7</td>
<td align="left">Ctrl+Alt+F7</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>idea</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>Filter、FilterChain、FilterConfig 介绍</title>
    <url>/2019/09/06/Filter%E3%80%81FilterChain%E3%80%81FilterConfig-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="一、Filter-的基本工作原理"><a href="#一、Filter-的基本工作原理" class="headerlink" title="一、Filter 的基本工作原理"></a>一、Filter 的基本工作原理</h1><ul>
<li><p>1、Filter 程序是一个实现了特殊接口的 Java 类，与 Servlet 类似，也是由 Servlet 容器进行调用和执行的。</p>
</li>
<li><p>2、当在 web.xml 注册了一个 Filter 来对某个 Servlet 程序进行拦截处理时，它可以决定是否将请求继续传递给 Servlet 程序，以及对请求和响应消息是否进行修改。</p>
</li>
<li><p>3、当 Servlet 容器开始调用某个 Servlet 程序时，如果发现已经注册了一个 Filter 程序来对该 Servlet 进行拦截，那么容器不再直接调用 Servlet 的 service 方法，而是调用 Filter 的 doFilter 方法，再由 doFilter 方法决定是否去激活 service 方法。</p>
</li>
<li><p>4、但在 Filter.doFilter 方法中不能直接调用 Servlet 的 service 方法，而是调用 FilterChain.doFilter 方法来激活目标 Servlet 的 service 方法，FilterChain 对象是通过 Filter.doFilter 方法的参数传递进来的。</p>
</li>
<li><p>5、只要在 Filter.doFilter 方法中调用 FilterChain.doFilter 方法的语句前后增加某些程序代码，这样就可以在 Servlet 进行响应前后实现某些特殊功能。</p>
</li>
<li><p>6、如果在 Filter.doFilter 方法中没有调用 FilterChain.doFilter 方法，则目标 Servlet 的 service 方法不会被执行，这样通过 Filter 就可以阻止某些非法的访问请求。<br><img src="/images/Filter%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt=""></p>
<h1 id="二、Filter-链"><a href="#二、Filter-链" class="headerlink" title="二、Filter 链"></a>二、Filter 链</h1></li>
<li><p>1、在一个 Web 应用程序中可以注册多个 Filter 程序，每个 Filter 程序都可以对一个或一组 Servlet 程序进行拦截。如果有多个 Filter 程序都可以对某个 Servlet 程序的访问过程进行拦截，当针对该 Servlet 的访问请求到达时，Web 容器将把这多个 Filter 程序组合成一个 Filter 链（也叫过滤器链）。</p>
</li>
<li><p>2、Filter 链中的各个 Filter 的拦截顺序与它们在 web.xml 文件中的映射顺序一致，上一个 Filter.doFilter 方法中调用 FilterChain.doFilter 方法将激活下一个 Filter的doFilter 方法，最后一个 Filter.doFilter 方法中调用的 FilterChain.doFilter 方法将激活目标 Servlet的service 方法。</p>
</li>
<li><p>3、只要 Filter 链中任意一个 Filter 没有调用 FilterChain.doFilter 方法，则目标 Servlet 的 service 方法都不会被执行。</p>
</li>
</ul>
<h1 id="三、Filter-接口"><a href="#三、Filter-接口" class="headerlink" title="三、Filter 接口"></a>三、Filter 接口</h1><p>一个 Filter 程序就是一个 Java 类，这个类必须实现 Filter 接口。javax.servlet.Filter 接口中定义了三个方法：init、doFilter、destory。</p>
<h2 id="1、init-方法"><a href="#1、init-方法" class="headerlink" title="1、init 方法"></a>1、init 方法</h2><ul>
<li><p>在 Web 应用程序启动时，Web 服务器（Web 容器）将根据其 web.xml 文件的配置信息来创建每个注册的 Filter 的实例对象，并将其保存在内存中。</p>
</li>
<li><p>Web 容器创建 Filter 的实例对象后，将立即调用该 Filter 对象的 init 方法。init 方法在 Filter 生命周期中仅被执行一次，Web 容器在调用 init 方法时，会传递一个包含 Filter 的配置和运行环境信息的 FilterConfig 对象。</p>
</li>
</ul>
<pre><code>public voic init(FilterConfig filterConfig) throws ServletException</code></pre><ul>
<li>开发人员可以在 init 方法中完成与构造方法类似的初始化功能，要注意的是：如果初始化代码要使用到 FilterConfig 对象，这些代码只能在 init 方法中编写，而不能在构造方法中编写（尚未调用 init 方法，即并没有创建 FilterConfig 对象，要使用它则必然出错）。</li>
</ul>
<h2 id="2、doFilter-方法"><a href="#2、doFilter-方法" class="headerlink" title="2、doFilter 方法"></a>2、doFilter 方法</h2><p>当一个 Filter 对象能够拦截访问请求时，Servlet 容器将调用 Filter 对象的 doFilter 方法。</p>
<pre><code>public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws java.io.IOException.ServletException</code></pre><p>其中，参数 request 和 response 为 Web 容器或 Filter 链中上一个 Filter 传递过来的请求和响应对象；参数 chain 为代表当前 Filter 链的对象。</p>
<h2 id="3、destroy-方法"><a href="#3、destroy-方法" class="headerlink" title="3、destroy 方法"></a>3、destroy 方法</h2><p>该方法在 Web 容器卸载 Filter 对象之前被调用，也仅执行一次。可以完成与 init 方法相反的功能，释放被该 Filter 对象打开的资源，例如：关闭数据库连接和 IO 流。</p>
<h1 id="四、FilterChain-接口"><a href="#四、FilterChain-接口" class="headerlink" title="四、FilterChain 接口"></a>四、FilterChain 接口</h1><p>该接口用于定义一个 Filter 链的对象应该对外提供的方法，这个接口只定义了一个 doFilter 方法。</p>
<p>public void doFilter(ServletRequest request, ServletResponse response) throws java.io.IOException.ServletException</p>
<p>FilterChain 接口的 doFilter 方法用于通知 Web 容器把请求交给 Filter 链中的下一个 Filter 去处理，如果当前调用此方法的 Filter 对象是Filter 链中的最后一个 Filter，那么将把请求交给目标 Servlet 程序去处理。</p>
<h1 id="五、FilterConfig-接口"><a href="#五、FilterConfig-接口" class="headerlink" title="五、FilterConfig 接口"></a>五、FilterConfig 接口</h1><h2 id="1、与普通的-Servlet-程序一样，Filter-程序也很可能需要访问-Servlet-容器。Servlet-规范将代表-ServletContext-对象和-Filter-的配置参数信息都封装到一个称为-FilterConfig-的对象中。"><a href="#1、与普通的-Servlet-程序一样，Filter-程序也很可能需要访问-Servlet-容器。Servlet-规范将代表-ServletContext-对象和-Filter-的配置参数信息都封装到一个称为-FilterConfig-的对象中。" class="headerlink" title="1、与普通的 Servlet 程序一样，Filter 程序也很可能需要访问 Servlet 容器。Servlet 规范将代表 ServletContext 对象和 Filter 的配置参数信息都封装到一个称为 FilterConfig 的对象中。"></a>1、与普通的 Servlet 程序一样，Filter 程序也很可能需要访问 Servlet 容器。Servlet 规范将代表 ServletContext 对象和 Filter 的配置参数信息都封装到一个称为 FilterConfig 的对象中。</h2><h2 id="2、FilterConfig-接口则用于定义-FilterConfig-对象应该对外提供的方法，以便在-Filter-程序中可以调用这些方法来获取-ServletContext-对象，以及获取在-web-xml-文件中为-Filter-设置的友好名称和初始化参数。"><a href="#2、FilterConfig-接口则用于定义-FilterConfig-对象应该对外提供的方法，以便在-Filter-程序中可以调用这些方法来获取-ServletContext-对象，以及获取在-web-xml-文件中为-Filter-设置的友好名称和初始化参数。" class="headerlink" title="2、FilterConfig 接口则用于定义 FilterConfig 对象应该对外提供的方法，以便在 Filter 程序中可以调用这些方法来获取 ServletContext 对象，以及获取在 web.xml 文件中为 Filter 设置的友好名称和初始化参数。"></a>2、FilterConfig 接口则用于定义 FilterConfig 对象应该对外提供的方法，以便在 Filter 程序中可以调用这些方法来获取 ServletContext 对象，以及获取在 web.xml 文件中为 Filter 设置的友好名称和初始化参数。</h2><h2 id="3、FilterConfig接口定义的各个方法："><a href="#3、FilterConfig接口定义的各个方法：" class="headerlink" title="3、FilterConfig接口定义的各个方法："></a>3、FilterConfig接口定义的各个方法：</h2><ul>
<li><p>getFilterName 方法，返回 <filter-name> 元素的设置值。</p>
</li>
<li><p>getServletContext 方法，返回 FilterConfig 对象中所包装的 ServletContext 对象的引用。</p>
</li>
<li><p>getInitParameter 方法，用于返回在 web.xml 文件中为 Filter 所设置的某个名称的初始化的参数值。</p>
</li>
<li><p>getInitParameterNames 方法，返回一个 Enumeration 集合对象。</p>
</li>
</ul>
<h1 id="六、Filter-的注册与映射"><a href="#六、Filter-的注册与映射" class="headerlink" title="六、Filter 的注册与映射"></a>六、Filter 的注册与映射</h1><h2 id="1、注册-Filter"><a href="#1、注册-Filter" class="headerlink" title="1、注册 Filter"></a>1、注册 Filter</h2><p>一个 <filter> 元素用于注册一个 Filter。其中，<filter-name> 元素是必需的，<filter-class> 元素也是必需的，<init-param> 元素是可选的，可以有多个 &lt; init-param&gt; 元素。</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;FirstFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;GB2312&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;</code></pre><h2 id="2、映射-Filter"><a href="#2、映射-Filter" class="headerlink" title="2、映射 Filter"></a>2、映射 Filter</h2><pre><code>&lt;filter-mapping&gt; 元素用于设置一个 Filter 所负责拦截的资源。一个 Filter 拦截的资源可以通过两种方式来指定：资源的访问请求路径和 Servlet 名称。</code></pre><h3 id="第一种：指定资源的访问路径"><a href="#第一种：指定资源的访问路径" class="headerlink" title="第一种：指定资源的访问路径"></a>第一种：指定资源的访问路径</h3><pre><code>&lt;filter-mapping&gt;
    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre><p><url-pattern> 元素中的访问路径的设置方式遵循 Servlet 的 URL 映射规范。</p>
<ul>
<li><p>/*：表示拦截所有的访问请求。</p>
</li>
<li><p>/filter/*：表示拦截 filter 目录下的所有访问请求，如：<a href="http://localhost:8888/testFilter_001/filter/xxxxxx" target="_blank" rel="noopener">http://localhost:8888/testFilter_001/filter/xxxxxx</a> 。</p>
</li>
<li><p>/test.html：表示拦截根目录下以 test.html 为资源名的访问请求，访问链接只会是：<a href="http://localhost:8888/test.html。" target="_blank" rel="noopener">http://localhost:8888/test.html。</a></p>
</li>
</ul>
<h3 id="第二种：指定-Servlet-的名称"><a href="#第二种：指定-Servlet-的名称" class="headerlink" title="第二种：指定 Servlet 的名称"></a>第二种：指定 Servlet 的名称</h3><pre><code>&lt;filter-mapping&gt;
    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;
    &lt;servlet-name&gt;default&gt;&lt;/servlet-name&gt;
    &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;
    &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
&lt;/filter-mapping&gt;</code></pre><p>（1）、<servlet-name> 元素与 <url-pattern> 元素是二选一的关系，其值是某个 Servlet 在 web.xml 文件中的注册名称。<br>（2）、<dispatcher> 元素的设置值有 4 种：REQUEST、INCLUDE、FORWARD、ERROR，分别对应 Servlet 容器调用资源的 4 种方式：</p>
<ul>
<li>通过正常的访问请求调用；</li>
<li>通过 RequestDispatcher.include 方法调用；</li>
<li>通过 RequestDispatcher.forward 方法调用；</li>
<li>作为错误响应资源调用。<br>如果没有设置 <dispatcher> 子元素，则等效于 REQUEST 的情况。也可以设置多个 <dispatcher> 子元素，用于指定 Filter 对资源的多种调用方式都进行拦截。</li>
</ul>
<h1 id="七、Filter-程序示例"><a href="#七、Filter-程序示例" class="headerlink" title="七、Filter 程序示例"></a>七、Filter 程序示例</h1><p>FitstFilter.java</p>
<pre><code>import java.io.IOException;
import java.io.PrintWriter;
import java.util.Enumeration;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;

public class FirstFilter implements Filter {
    private FilterConfig filterConfig = null;
    String paramValue = null;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        this.filterConfig = filterConfig;
        paramValue = filterConfig.getInitParameter(&quot;encoding&quot;);
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response,
            FilterChain chain) throws IOException, ServletException {
        System.out.println(&quot;begin headers-------------------&quot;);
        Enumeration&lt;?&gt; headerNames = ((HttpServletRequest)request).getHeaderNames();

        while(headerNames.hasMoreElements()) {
            String headerName = (String)headerNames.nextElement();
            System.out.println(headerName + &quot;: &quot; + ((HttpServletRequest)request).getHeader(headerName));
        }
        System.out.println(&quot;end headers-------------------&quot;);

        //在调用目标前写入响应内容
        response.setContentType(&quot;text/html; charset=gb2312&quot;);
        PrintWriter out = response.getWriter();
        out.println(&quot;IP地址为：&quot; + request.getRemoteHost() + &quot;&lt;br&gt;&quot;);

        chain.doFilter(request, response);

        //在目标返回后写入响应内容
        out.println(&quot;&lt;br&gt;名称为encoding的初始化参数的值为：&quot; + paramValue);
        out.println(&quot;&lt;br&gt;当前Web程序的真实路径为：&quot; + filterConfig.getServletContext().getRealPath(&quot;/&quot;));

        //out.println(&quot;&lt;br&gt;修改了test.html文件！&quot;);
    }

    @Override
    public void destroy() {
        this.filterConfig = null;
    }
}</code></pre><p>web.xml</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;FirstFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
    &lt;param-name&gt;encoding&lt;/param-name&gt;
    &lt;param-value&gt;GB2312&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre><p>test.html（位于WebContent路径的filter目录中）</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
这就是test.html页面的原始内容！
&lt;/body&gt;
&lt;/html&gt;</code></pre><p><a href="https://my.oschina.net/u/1171518/blog/265467" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>filter</tag>
      </tags>
  </entry>
  <entry>
    <title>Intellij IDEA如何配置JDK</title>
    <url>/2019/08/28/Intellij-IDEA%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEJDK/</url>
    <content><![CDATA[<p>command + ; // 快捷键打开配置</p>
<p>Configure  –&gt; Project Defaults  –&gt;  Project Structure </p>
<p>点击Project选项卡，配置相应jdk</p>
]]></content>
      <tags>
        <tag>Intellij IDEA</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客备份</title>
    <url>/2018/05/05/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<h2 id="参考：https-www-jianshu-com-p-57b5a384f234"><a href="#参考：https-www-jianshu-com-p-57b5a384f234" class="headerlink" title="参考：https://www.jianshu.com/p/57b5a384f234"></a>参考：<a href="https://www.jianshu.com/p/57b5a384f234" target="_blank" rel="noopener">https://www.jianshu.com/p/57b5a384f234</a></h2><p>遇到的坑</p>
<pre><code>CNAME必须放在source目录中不然会导致页面无法访问404

注意千万不要合并主干否则......你懂的</code></pre>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP与JavaScript</title>
    <url>/2019/09/04/JSP%E4%B8%8EJavaScript/</url>
    <content><![CDATA[<p>某日在洗手间偶遇某大牛,聊起JSP,大牛曰:”JSP 哦知道,JavaScript”<br>我竟无言以对!在此记录一下JSP与JavaScript的区别</p>
<h1 id="首先下结论-雷锋与雷锋塔的区别"><a href="#首先下结论-雷锋与雷锋塔的区别" class="headerlink" title="首先下结论 雷锋与雷锋塔的区别"></a>首先下结论 雷锋与雷锋塔的区别</h1><h2 id="JSP是什么"><a href="#JSP是什么" class="headerlink" title="JSP是什么"></a>JSP是什么</h2><p>SUN首先发展出SERVLET，其功能比较强劲，体系设计也很先进，只是，它输出HTML语句还是采用了老的CGI方式，是一句一句输出，所以，编写和修改HTML非常不方便。 后来SUN推出了类似于ASP的镶嵌型的JSP，把JSP TAG镶嵌到HTML语句中，这样，就大大简化和方便了网页的设计和修改。</p>
<p>JSP全名为Java Server Pages，其根本是一个简化的Servlet设计，他实现了Html语法中的java扩张（以 &lt;%, %&gt;形式）。JSP与Servlet一样，是在服务器端执行的。通常返回给客户端的就是一个HTML文本，因此客户端只要有浏览器就能浏览。Web服务器在遇到访问JSP网页的请求时，首先执行其中的程序段，然后将执行结果连同JSP文件中的HTML代码一起返回给客户端。插入的Java程序段可以操作数据库、重新定向网页等，以实现建立动态网页所需要的功能。</p>
<p>JSP页面由HTML代码和嵌入其中的Java代码所组成。服务器在页面被客户端请求以后对这些Java代码进行处理，然后将生成的HTML页面返回给客户端的浏览器。Java Servlet是JSP的技术基础，而且大型的Web应用程序的开发需要Java Servlet和JSP配合才能完成。JSP具备了Java技术的简单易用，完全的面向对象，具有平台无关性且安全可靠，主要面向因特网的所有特点。</p>
<p>jsp 要先翻译，注意是翻译成servlet才能执行：<br>比如 test.jsp 要变成 test_jsp.java 然后编译成 test_jsp.class<br>而 test_jsp.java 本身就是一个servlet.<br>所以 jsp只是servlet的一个变种，方便书写html内容才出现的。</p>
<pre><code>servlet的运行机制和Applet类似，只不过它运行在服务器端。一个servlet是javax.servlet包中HttpServlet类的子类，由支持servlet的服务器完成该子类的对象，即servlet的初始化。

扩展阅读0：jsp转化为servlet的过程：

http://www.w3cschool.cc/jsp/jsp-architecture.html

扩展阅读1：servlet版的Helloworld（需要装tomcat,我通常使用XAMPP集成的tomcat）

http://blog.163.com/adoom_2010/blog/static/1820326362011710102719527/

扩展阅读2：servlet程序中的各部分的作用、调用顺序

http://wenku.baidu.com/link?url=U2B6Gx_C1X702ppIFJdXR23MyY85lZzJeneIDZSFCuA3bZ-ynwDFx9oYm4pNcpa4ZjmlUPnkrtwkHg0skxdo3mqOY-IAvXzzYqaCOc7DVmW</code></pre><h2 id="JavaScript是什么"><a href="#JavaScript是什么" class="headerlink" title="JavaScript是什么"></a>JavaScript是什么</h2><p>Java Script 是一种基于对象的客户端脚本语言。主要目的是为了解决服务器端语言，比如Perl，遗留的速度问题，为客户提供更流畅的浏览效果。JS可以直接嵌入到html代码中进行解析执行，非常简单易学，可以产生很多动态的效果。</p>
<h2 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h2><p>简单地说——JS是在客户端执行的，需要浏览器支持Javascript。JSP是在服务器端执行的，需要服务器上部署支持Servlet的服务器程序。JS代码是能够直接从服务器上download得到，对外是可见的，jsp(和翻译后的servlet)代码是对外不可见的。</p>
<p>JS与JavaScript相比：虽然JavaScript可以在客户端动态生成HTML，但是很难与服务器交互，因此不能提供复杂的服务，比如访问数据库和图像处理等等。JSP在HTML中用&lt;%%&gt;里面实现。JS在html中用<Script></Script>实现</p>
<p><a href="https://zh.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">参考1</a><br><a href="https://zh.wikipedia.org/wiki/JSP" target="_blank" rel="noopener">参考2</a><br><a href="https://blog.csdn.net/a2806005024/article/details/28265503" target="_blank" rel="noopener">参考3</a></p>
]]></content>
      <categories>
        <category>笑话</category>
      </categories>
      <tags>
        <tag>JSP</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/2020/03/29/JVM/</url>
    <content><![CDATA[<h1 id="第一讲-初识JVM"><a href="#第一讲-初识JVM" class="headerlink" title="第一讲 初识JVM"></a>第一讲 初识JVM</h1><h2 id="JVM概念"><a href="#JVM概念" class="headerlink" title="JVM概念"></a>JVM概念</h2><p><img src="1585469351029.jpg" alt=""></p>
<h2 id="JVM发展历史"><a href="#JVM发展历史" class="headerlink" title="JVM发展历史"></a>JVM发展历史</h2><p><img src="WeChat59fc87098feb0906afe9f7c2ff0cfda4.png" alt=""><br><img src="1585469738770.jpg" alt=""><br><img src="1585469850194.jpg" alt=""><br><img src="1585469974766.jpg" alt=""></p>
<h2 id="JVM种类"><a href="#JVM种类" class="headerlink" title="JVM种类"></a>JVM种类</h2><p><img src="1585470188832.jpg" alt=""><br><img src="1585470274411.jpg" alt=""></p>
<h2 id="JAVA语言规范"><a href="#JAVA语言规范" class="headerlink" title="JAVA语言规范"></a>JAVA语言规范</h2><ul>
<li>语法</li>
<li>变量</li>
<li>类型</li>
<li>文法</li>
</ul>
<p><img src="1585471088237.jpg" alt=""><br><img src="1585471162424.jpg" alt=""><br><img src="1585471242571.jpg" alt=""><br><img src="1585472002039.jpg" alt=""><br><img src="1585472131986.jpg" alt=""></p>
<h2 id="JVM规范"><a href="#JVM规范" class="headerlink" title="JVM规范"></a>JVM规范</h2><ul>
<li>Class文件类型</li>
<li>运行时数据</li>
<li>帧栈</li>
<li>虚拟机的启动</li>
<li>虚拟机的指令集</li>
</ul>
<p><img src="1585472274370.jpg" alt=""></p>
<p>Class 文件格式<br>数字的内部表示和存储<br>Byte  -128 to 127 (-27 to 27 - 1)<br>returnAddress 数据类型定义<br>指向操作码的指针。不对应Java数据类型，不能在运行时修改。Finally实现需要<br>定义PC<br>堆<br>栈<br>方法区</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存模型</title>
    <url>/2020/05/29/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><img src="JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="千字不如一图"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Javac原理</title>
    <url>/2019/09/25/Javac%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>从Sun Javac的代码来看，编译过程大致可以分为3个过程:</p>
<ol>
<li>解析与填充符号表过程。</li>
<li>插入式注解处理器的注解处理过程。</li>
<li>分析与字节码生成过程。<br><img src="j.jpg" alt=""><br>Javac编译动作的入口是com.sun.tools.javac.main.JavaCompiler类，上述3个过程的代码逻辑集中在这个类的compile()和compile2()方法中，整个编译最关键的处理就由图中标注的8个方法来完成，下面我们具体看一下这8个方法实现了什么功能。<br><img src="f.jpg" alt=""></li>
</ol>
<h1 id="解析与填充符号表"><a href="#解析与填充符号表" class="headerlink" title="解析与填充符号表"></a>解析与填充符号表</h1><p>解析步骤由上图中的parseFiles（）方法（过程1.1）完成，解析步骤包括了经典程序编译原理中的词法分析和语法分析两个过程。</p>
<h2 id="词法、语法分析"><a href="#词法、语法分析" class="headerlink" title="词法、语法分析"></a>词法、语法分析</h2><p>词法分析是<strong>将源代码的字符流转变为标记（Token）集合</strong>，<strong>单个字符</strong>是<strong>程序编写过程</strong>的最小元素，而<strong>标记</strong>则是<strong>编译过程</strong>的最小元素，关键字、变量名、字面量、运算符都可以成为标记，如“int a=b+2”这句代码包含了6个标记，分别是int、a、=、b、+、2，虽然关键字int由3个字符构成，但是它只是一个Token，不可再拆分。在Javac的源码中，词法分析过程由com.sun.tools.javac.parser.Scanner类来实现。</p>
<p>语法分析是<strong>根据Token序列构造抽象语法树的过程</strong>，抽象语法树（Abstract Syntax Tree,AST）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构（Construct），例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。</p>
<p>在Javac的源码中，语法分析过程由com.sun.tools.javac.parser.Parser类实现，这个阶段产出的抽象语法树由com.sun.tools.javac.tree.JCTree类表示，<strong>经过这个步骤之后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在抽象语法树之上</strong>。</p>
<h2 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h2><p>完成了语法分析和词法分析之后，下一步就是填充符号表的过程，也就是enterTrees（）方法（过程1.2）所做的事情。符号表（Symbol Table）<strong>是由一组符号地址和符号信息构成的表格</strong>，可以把它想象成哈希表中K-V值对的形式（实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等）。符号表中所登记的信息在编译的不同阶段都要用到<br>。<strong>在语义分析中，符号表所登记的内容将用于语义检查</strong>（如检查一个名字的使用和原先的说明是否一致）和<strong>产生中间代码</strong>。在目标代码生成阶段，当对符号名进行地址分配时，<strong>符号表是地址分配的依据。</strong></p>
<p>在Javac源代码中，填充符号表的过程由com.sun.tools.javac.comp.Enter类实现，此过程的出口是一个待处理列表（To Do List），包含了每一个编译单元的抽象语法树的顶级节点，以及package-info.java（如果存在的话）的顶级节点。</p>
<h1 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h1><p>在Javac源码中，<em>插入</em>式注解处理器的<em>初始化</em>过程是在<br>initPorcessAnnotations（）方法中完成的，而它的<em>执行过程</em>则是在processAnnotations（）方法中完成的，<br>这个方法判断是否还有新的注解处理器需要执行，如果有的话，通过com.sun.tools.javac.processing.JavacProcessingEnvironment类的doProcessing（）方法生成一个新的JavaCompiler对象对编译的后续步骤进行处理。</p>
<p>在JDK 1.5之后，Java语言提供了对注解（Annotation）的支持，这些注解与普通的Java代码一样，是在运行期间发挥作用的。在JDK 1.6中实现了JSR-269规范JSR-269：Pluggable Annotations Processing API（插入式注解处理API）。提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，我们可以把它看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round，也就是第一张图中的回环过程。 有了编译器注解处理的标准API后，我们的代码才有可能干涉编译器的行为，由于语法树中的任意元素，甚至包括代码注释都可以在插件之中访问到，所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间。只要有足够的创意，程序员可以使用插入式注解处理器来实现许多原本只能在编码中完成的事情。</p>
<p>我们知道编译器在把Java程序源码编译为字节码的时候，会对Java程序源码做各方面的检查校验。这些校验主要以程序“写得对不对”为出发点，虽然也有各种WARNING的信息，但总体来讲还是较少去校验程序“写得好不好”。有鉴于此，业界出现了许多针对程序“写得好不好”的辅助校验工具，如CheckStyle、FindBug、Klocwork等。这些代码校验工具有一些是基于Java的源码进行校验，还有一些是通过扫描字节码来完成。我们将会使用注解处理器API来编写一款拥有自己编码风格的校验工具：NameCheckProcessor。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>要通过注解处理器API实现一个编译器插件，首先需要了解这组API的一些基本知识。我们实现注解处理器的代码需要继承抽象类javax.annotation.processing.AbstractProcessor，这个抽象类中只有一个必须覆盖的abstract方法：“process（）”，它是Javac编译器在执行注解处理器代码时要调用的过程，我们可以从这个方法的第一个参数“annotations”中获取到此注解处理器所要处理的注解集合，从第二个参数“roundEnv”中访问到当前这个Round中的语法树节点，每个语法树节点在这里表示为一个Element。在JDK 1.6新增的javax.lang.model包中定义了16类Element，包括了Java代码中最常用的元素，如：“包（PACKAGE）、枚举（ENUM）、类（CLASS）、注解（ANNOTATION_TYPE）、接口（INTERFACE）、枚举值（ENUM_CONSTANT）、字段（FIELD）、参数（PARAMETER）、本地变量（LOCAL_VARIABLE）、异常（EXCEPTION_PARAMETER）、方法（METHOD）、构造函数（CONSTRUCTOR）、静态语句块（STATIC_INIT，即static{}块）、实例语句块（INSTANCE_INIT，即{}块）、参数化类型（TYPE_PARAMETER，既泛型尖括号内的类型）和未定义的其他语法树节点（OTHER）”。除了process（）方法的传入参数之外，还有一个很常用的实例变量“processingEnv”，它是AbstractProcessor中的一个protected变量，在注解处理器初始化的时候（init（）方法执行的时候）创建，继承了AbstractProcessor的注解处理器代码可以直接访问到它。它代表了注解处理器框架提供的一个上下文环境，要创建新的代码、向编译器输出信息、获取其他工具类等都需要用到这个实例变量。注解处理器除了process（）方法及其参数之外，还有两个可以配合使用的Annotations：@SupportedAnnotationTypes和@SupportedSourceVersion，前者代表了这个注解处理器对哪些注解感兴趣，可以使用星号“*”作为通配符代表对所有的注解都感兴趣，后者指出这个注解处理器可以处理哪些版本的Java代码。</p>
<p>每一个注解处理器在运行的时候都是单例的，如果不需要改变或生成语法树的内容，process（）方法就可以返回一个值为false的布尔值，通知编译器这个Round中的代码未发生变化，无须构造新的JavaCompiler实例，在这次实战的注解处理器中只对程序命名进行检查，不需要改变语法树的内容，因此process（）方法的返回值都是false。</p>
<pre><code>import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import java.util.Set;

//可以用&quot;*&quot;表示支持所有Annotations
@SupportedAnnotationTypes(&quot;*&quot;)
//只支持JDK 1.6的Java代码
@SupportedSourceVersion(SourceVersion.RELEASE_6)
public class NameCheckProcessor extends AbstractProcessor {
    private NameChecker nameChecker;
    /**
     * 初始化名称检查插件
     */
    @Override
    public void init(ProcessingEnvironment processingEnv){
        super.init(processingEnv);
        nameChecker = new NameChecker(processingEnv);
    }
    /**
     * 对输入的语法树的各个节点进行名称检查
     */
    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; annotations,RoundEnvironment roundEnv){
        if (!roundEnv.processingOver()) {
            for (Element element:roundEnv.getRootElements())
            nameChecker.checkNames(element);
        }
        return false;
    }
}
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.*;
import javax.lang.model.util.ElementScanner6;
import javax.tools.Diagnostic;
import java.util.EnumSet;

public class NameChecker {
    private final Messager messager;
    NameCheckScanner nameCheckScanner = new NameCheckScanner();

    NameChecker(ProcessingEnvironment processsingEnv) {
        this.messager = processsingEnv.getMessager();
    }

    /**
     * 对Java程序命名进行检查,根据《Java语言规范(第3版)》第6.8节的要求,Java程序命名应当符合下列格式：
     * &lt;p/&gt;
     * &lt;ul&gt;
     * &lt;li&gt;类或接口：符合驼式命名法,首字母大写。
     * &lt;li&gt;方法：符合驼式命名法,首字母小写。
     * &lt;li&gt;字段：
     * &lt;ul&gt;
     * &lt;li&gt;类、实例变量：符合驼式命名法,首字母小写。
     * &lt;li&gt;常量：要求全部大写。
     * &lt;/ul&gt;
     * &lt;/ul&gt;
     */
    public void checkNames(Element element) {
        nameCheckScanner.scan(element);
    }
    /**
     * 名称检查器实现类,继承了JDK 1.6中新提供的ElementScanner6&lt;br&gt;
     * 将会以Visitor模式访问抽象语法树中的元素
     */
    private class NameCheckScanner extends ElementScanner6&lt;Void, Void&gt; {
        /**
         * 此方法用于检查Java类
         */
        @Override
        public Void visitType(TypeElement e, Void p) {
            scan(e.getTypeParameters(), p);
            checkCamelCase(e, true);
            super.visitType(e, p);
            return null;
        }
        /**
         * 检查方法命名是否合法
         */
        @Override
        public Void visitExecutable(ExecutableElement e, Void p) {
            if (e.getKind() == ElementKind.METHOD) {
                Name name = e.getSimpleName();
                if
                        (name.contentEquals(e.getEnclosingElement().getSimpleName()))
                    messager.printMessage(Diagnostic.Kind.WARNING, &quot;一个普通方法&apos;&quot; + name + &quot;&apos;不应当与类名重复,避免与构造函数产生混淆&quot;, e);
                checkCamelCase(e, false);
            }
            super.visitExecutable(e, p);
            return null;
        }
        /**
         * 检查变量命名是否合法
         */
        @Override
        public Void visitVariable(VariableElement e, Void p) {
            //如果这个Variable是枚举或常量,则按大写命名检查,否则按照驼式命名法规则检查
            if (e.getKind() == ElementKind.ENUM_CONSTANT || e.getConstantValue() != null || heuristicallyConstant(e))
                checkAllCaps(e);
            else
                checkCamelCase(e, false);
            return null;
        }

        /**
         * 判断一个变量是否是常量
         */
        private boolean heuristicallyConstant(VariableElement e) {
            if (e.getEnclosingElement().getKind() == ElementKind.INTERFACE)
                return true;
            else if (e.getKind() == ElementKind.FIELD &amp;&amp; e.getModifiers().containsAll(EnumSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)))
                return true;
            else {
                return false;
            }
        }

        /**
         * 检查传入的Element是否符合驼式命名法,如果不符合,则输出警告信息
         */
        private void checkCamelCase(Element e, boolean initialCaps) {
            String name = e.getSimpleName().toString();
            boolean previousUpper = false;
            boolean conventional = true;
            int firstCodePoint = name.codePointAt(0);
            if (Character.isUpperCase(firstCodePoint)) {
                previousUpper = true;
                if (!initialCaps) {
                    messager.printMessage(Diagnostic.Kind.WARNING, &quot;名称&apos;&quot; + name + &quot;&apos;应当以小写字母开头&quot;, e);
                    return;
                }
            } else if (Character.isLowerCase(firstCodePoint)) {
                if (initialCaps) {
                    messager.printMessage(Diagnostic.Kind.WARNING, &quot;名称&apos;&quot; + name + &quot;&apos;应当以大写字母开头&quot;, e);
                    return;
                }
            } else
                conventional = false;
            if (conventional) {
                int cp = firstCodePoint;
                for (int i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) {
                    cp = name.codePointAt(i);
                    if (Character.isUpperCase(cp)) {
                        if (previousUpper) {
                            conventional = false;
                            break;
                        }
                        previousUpper = true;
                    } else
                        previousUpper = false;
                }
            }
            if (!conventional)
                messager.printMessage(Diagnostic.Kind.WARNING, &quot;名称&apos;&quot; + name + &quot;&apos;应当符合驼式命名法(Camel Case Names)&quot;, e);
        }

        /**
         * 大写命名检查,要求第一个字母必须是大写的英文字母,其余部分可以是下划线或大写字母
         */
        private void checkAllCaps(Element e) {
            String name = e.getSimpleName().toString();
            boolean conventional = true;
            int firstCodePoint = name.codePointAt(0);
            if (!Character.isUpperCase(firstCodePoint))
                conventional = false;
            else {
                boolean previousUnderscore = false;
                int cp = firstCodePoint;
                for (int i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) {
                    cp = name.codePointAt(i);
                    if (cp == (int) &apos;_&apos;) {
                        if (previousUnderscore) {
                            conventional = false;
                            break;
                        }
                        previousUnderscore = true;
                    } else {
                        previousUnderscore = false;
                        if (!Character.isUpperCase(cp) &amp;&amp; !Character.isDigit(cp)) {
                            conventional = false;
                            break;
                        }
                    }
                }
            }
            if (!conventional)
                messager.printMessage(Diagnostic.Kind.WARNING, &quot;常量&apos;&quot; + name + &quot;&apos;应当全部以大写字母或下划线命名,并且以字母开头&quot;, e);
        }
    }
}</code></pre><p>我们可以通过Javac命令的“-processor”参数来执行编译时需要附带的注解处理器，如果有多个注解处理器的话，用逗号分隔。还可以使用-XprintRounds和-XprintProcessorInfo参数来查看注解处理器运作的详细信息，javac -processor <strong>*.NameCheckProcessor *</strong>/test.java</p>
<pre><code>test.java：3：警告：名称&quot;test&quot;应当符合驼式命名法（Camel Case Names）
public class test{
^
test.java：5：警告：名称&quot;colors&quot;应当以大写字母开头
enum colors{
^
test.java：6：警告：常量&quot;red&quot;应当全部以大写字母或下划线命名，并且以字母开头
red,blue,green；
^
test.java：6：警告：常量&quot;blue&quot;应当全部以大写字母或下划线命名，并且以字母开头
red,blue,green；
^
test.java：6：警告：常量&quot;green&quot;应当全部以大写字母或下划线命名，并且以字母开头
red,blue,green；
^
test.java：9：警告：常量&quot;_FORTY_TWO&quot;应当全部以大写字母或下划线命名，并且以字母开头
static final int_FORTY_TWO=42；
^
test.java：11：警告：名称&quot;NOT_A_CONSTANT&quot;应当以小写字母开头
public static int NOT_A_CONSTANT=_FORTY_TWO；
^
test.java：13：警告：名称&quot;Test&quot;应当以小写字母开头
protected void Test（）{
^
test.java：17：警告：名称&quot;NOTcamelCASEmethodNAME&quot;应当以小写字母开头
public void NOTcamelCASEmethodNAME（）{
^</code></pre><p>NameCheckProcessor的例子只演示了JSR-269嵌入式注解处理器API中的一部分功能，基于这组API支持的项目还有用于校验Hibernate标签使用正确性的Hibernate Validator Annotation Processorm自动为字段生成getter和setter方法的Project Lombok.</p>
<h1 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h1><p>语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。Javac的编译过程中，语义分析过程分为标注检查以及数据及控制流分析两个步骤，分别由上图中所示的attribute（）和flow（）方法（分别对应过程3.1和过程3.2）完成。</p>
<h2 id="标注检查"><a href="#标注检查" class="headerlink" title="标注检查"></a>标注检查</h2><p>标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。在标注检查步骤中，还有一个重要的动作称为常量折叠，如果我们在代码中写了如下定义：int a=1+2；那么在语法树上仍然能看到字面量“1”、“2”以及操作符“+”，但是在经过常量折叠之后，它们将会被折叠为字面量“3”，由于编译期间进行了常量折叠，所以在代码里面定义“a=1+2”比起直接定义“a=3”，并不会增加程序运行期哪怕仅仅一个CPU指令的运算量。</p>
<h2 id="数据及控制流分析"><a href="#数据及控制流分析" class="headerlink" title="数据及控制流分析"></a>数据及控制流分析</h2><p>在Javac的源码中，数据及控制流分析的入口是图中的flow（）方法（对应过程3.2），具体操作由com.sun.tools.javac.comp.Flow类来完成。</p>
<p>数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只有在编译期或运行期才能进行。</p>
<pre><code>//方法一带有final修饰
public void foo（final int arg）{
final int var=0；
//do something
}
//方法二没有final修饰
public void foo（int arg）{
int var=0；
//do something
}</code></pre><p>在这两个foo（）方法中，第一种方法的参数和局部变量定义使用了final修饰符，而第二种方法则没有，在代码编写时程序肯定会受到final修饰符的影响，不能再改变arg和var变量的值，但是这两段代码编译出来的Class文件是没有任何一点区别的，局部变量与字段（实例变量、类变量）是有区别的，它在常量池中没有CONSTANT_Fieldref_info的符号引用，自然就没有访问标志（Access_Flags）的信息，甚至可能连名称都不会保留下来（取决于编译时的选项），自然在Class文件中不可能知道一个局部变量是不是声明为final了。因此，将局部变量声明为final，对运行期是没有影响的，变量的不变性仅仅由编译器在编译期间保障。</p>
<h2 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h2><p>在Javac的源码中，解语法糖的过程由desugar（）方法触发，在com.sun.tools.javac.comp.TransTypes类和com.sun.tools.javac.comp.Lower类中完成。</p>
<p>语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说，使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p>
<p>Java中最常用的语法糖主要是的泛型擦除（泛型并不一定都是语法糖实现，如C#的泛型就是直接由CLR支持的）、变长参数、自动装箱/拆箱,条件编译等，虚拟机运行时不支持这些语法，它们在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖。</p>
<h1 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h1><p>字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面由com.sun.tools.javac.jvm.Gen类来完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。</p>
<p>例如，实例构造器＜init＞（）方法和类构造器＜clinit＞（）方法就是在这个阶段添加到语法树之中的（注意，这里的实例构造器并不是指默认构造函数，如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、访问性（public、protected或private）与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成），这两个构造器的产生过程实际上是一个代码收敛的过程，编译器会把语句块（对于实例构造器而言是“{}”块，对于类构造器而言是“static{}”块）、变量初始化（实例变量和类变量）、调用父类的实例构造器等操作收敛到＜init＞（）和＜clinit＞（）方法之中，并且保证一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行，上面所述的动作由Gen.normalizeDefs（）方法来实现。除了生成构造器以外，还有其他的一些代码替换工作用于优化程序的实现逻辑，如把字符串的加操作替换为StringBuffer或StringBuilder的append（）操作等。</p>
<p>完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交给com.sun.tools.javac.jvm.ClassWriter类，由这个类的writeClass（）方法输出字节码，生成最终的Class文件，到此为止整个编译过程宣告结束。</p>
<p><a href="https://www.cnblogs.com/wade-luffy/p/6050331.html" target="_blank" rel="noopener">摘自</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin</title>
    <url>/2018/04/20/Kotlin/</url>
    <content><![CDATA[<h2 id="引用-https-baike-baidu-com-item-Kotlin-1133714-fr-aladdin"><a href="#引用-https-baike-baidu-com-item-Kotlin-1133714-fr-aladdin" class="headerlink" title="引用: https://baike.baidu.com/item/Kotlin/1133714?fr=aladdin"></a>引用: <a href="https://baike.baidu.com/item/Kotlin/1133714?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/Kotlin/1133714?fr=aladdin</a></h2><pre><code>Kotlin 是一个用于现代多平台应用的静态编程语言,有JetBrains开
发.

Kotlin可以编译称为Java字节码,也可以编译成JavaScript,方便在没有
JVM的设备上运行.

Kotlin已正式成为Android官方支持开发语言.</code></pre><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><pre><code>JetBrains,作为广受欢迎的java IDE intelliJ的提供商,在Apache许可
下已经开源其Kotlin编程语言.</code></pre><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><pre><code>创建一种兼容java的语言

让它比java更安全,能够静态检测常见的陷阱.如:引用空指针
让它比java更简洁,通过支持variable type inference,higher-order
function(closures),extension functions,mixins and first-class
delegation等实现.

让它比最成熟的竞争对手Scala语言更加简洁.</code></pre><h2 id="开发源代码"><a href="#开发源代码" class="headerlink" title="开发源代码"></a>开发源代码</h2><pre><code>其基础编译器(他们将其改为kompiler---开创了一系列以K字打头的用语
---甚至连 contributors这类词他们也用改成了kontributors)可以被独立
出来并嵌入到Maven Ant或Gradle工具链中,这使得在IDE中开发的代码能够
利用已有的机制来构建,从而尽可能的减少了在新环境中使用所受的干预,哪
怕与那些没有安装Kotlin插件的开发人员一起合作项目也没有问题.

The Intellij Kotlin插件扩展了Java编译器使得Kotlin代码能够得以编写 
编译和调试.除此之外,关于基本的Java集合,已经有编写好的帮助函数,可以
更顺畅地衔接在java8中出现的集合扩展.

有两篇文章对Kotlin与Java以及Scala分别进行了比较,对各自特性和异同进
行了对比.即便Scala可能还是更为强大些,Kotlin还是尝试提供比java更好
的函数 模式匹配 空指针预防和泛型.该语言同时支持特征(traits)和模式匹配

Kotlin插件在当前版本的IntelliJ和Eclipse中均已能使用.

Kotlin,类似Xtend一样,旨在提供一种更好的java而非重建整个新平台.这两种
语言都向下编译为字节码(虽然Xtend是首先转换成相应的java代码,再让java
编译器完成繁重的工作),而且两者都引入了函数和扩展函数(在某个有限范围
内静态地增加一个新方法到某个已有类型的能力).Xtend是基于Eclipse的,而
Kotlin是基于IntelliJ的,两者都提供无界面构建.能够首先演变到其他IDE的语
言有可能成为最后的赢家.</code></pre>]]></content>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Laravel学习笔记</title>
    <url>/2019/02/22/Laravel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="阅读文档官方文档-本文以5-7为例"><a href="#阅读文档官方文档-本文以5-7为例" class="headerlink" title="阅读文档官方文档(本文以5.7为例)"></a>阅读文档官方文档(本文以5.7为例)</h2><p><a href="'https://laravel.com/docs/5.7'">Laravel文档</a></p>
<h2 id="安装环境-Laravel-Homestead"><a href="#安装环境-Laravel-Homestead" class="headerlink" title="安装环境(Laravel Homestead)"></a>安装环境(Laravel Homestead)</h2><p><a href="https://laravel.com/docs/5.7/homestead" target="_blank" rel="noopener">Laravel Homestead文档</a></p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合框架</title>
    <url>/2020/04/11/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h1><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><pre><code>ArrayList
    排列有序，可重复
    底层使用数组
    速度快，增删慢，getter()和setter()快
    线程不安全
    当容量不够，ArrayList是当前容量*1.5+1
Vector
    排列有序，可重复
    底层使用数组
    速度快，增删慢
    线程安全，效率低
    当容量不够，默认扩张一倍容量
LinkedList
    排列有序，可重复
    底层使用双向循环链表数据结构
    查询速度慢，增删快，add（）和remove（）方法快
    线程不安全</code></pre><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><pre><code>HashSet
    排列无序，不可重复
    底层使用hash表实现
    存取速度快
    内部是HashMap
TreeSet
    排列无序，不可重复
    底层使用二叉树实现
    排序存储
    内部是TreeMap的SortedSet
LinkedHashSet
    采用Hash表存储，并用双向链表记录插入顺序
    内部是LinkedHashMap</code></pre><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><pre><code>在两端出入的List，所以也可以用数组或链表来实现</code></pre><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><pre><code>键不可重复，值可重复
底层hash表
线程不安全
允许key值为null，值为null</code></pre><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><pre><code>键不可重复，值可重复
底层Hash表
线程安全
键和值都不可为null</code></pre><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><pre><code>键不可重复，值可重复
底层二叉树</code></pre><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.png" alt=""></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合，面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础题</title>
    <url>/2020/04/19/Java%E5%9F%BA%E7%A1%80%E9%A2%98/</url>
    <content><![CDATA[<h1 id="1-以下哪个是finalize-方法的正确形式？"><a href="#1-以下哪个是finalize-方法的正确形式？" class="headerlink" title="1.以下哪个是finalize()方法的正确形式？"></a>1.以下哪个是finalize()方法的正确形式？</h1><pre><code>A.protected void finalize() throws Throwable
B.final finalize()
C.public final finalize()
D.private boolean finalize()
答案：A</code></pre><h1 id="2-如果finalize（）方法抛出一个运行时异常，以下哪个描述正确？"><a href="#2-如果finalize（）方法抛出一个运行时异常，以下哪个描述正确？" class="headerlink" title="2.如果finalize（）方法抛出一个运行时异常，以下哪个描述正确？"></a>2.如果finalize（）方法抛出一个运行时异常，以下哪个描述正确？</h1><pre><code>A.正在运行的应用程序系统崩溃
B.此异常被忽略，并且该异常对象被垃圾回收器回收
C.此异常被忽略，但是该异常对象未被垃圾回收期回收
D.此异常导致JVM崩溃
答案：B
答案解析：finalize()方法只是用于清除对象，而不是实际的销毁对象，因此对该方法的调用不会引起系统崩溃，该方法抛出的异常也会作为废弃对象被垃圾回收期回收</code></pre><h1 id="3-如何释放掉一个对象占据的内存空间？"><a href="#3-如何释放掉一个对象占据的内存空间？" class="headerlink" title="3.如何释放掉一个对象占据的内存空间？"></a>3.如何释放掉一个对象占据的内存空间？</h1><pre><code>A.调用free()方法
B.调用System.gc()方法
C.赋值给该对象的引用为null
D.程序员无法明确强制垃圾回收器运行
答案：D</code></pre><h1 id="4-给出以下代码："><a href="#4-给出以下代码：" class="headerlink" title="4.给出以下代码："></a>4.给出以下代码：</h1><pre><code>1.public class Example {
2. public static void main(String[] args) {
3.  String s = &quot;abcd&quot;;
4.  Integer x = new Integer(3);
5.  String s2 = s + 4;
6.  s2 = null;
7.  s = null;
8. }
9.}
改程序运行到第几行变量S2引用的对象符合垃圾回收器回收条件？
A.第7行
B.不存在
C.第6行
D.直到main线程结束，S2应用的对象才可能被回收
答案：C</code></pre><h1 id="5-以下代码运行到关键点处，有多少对象符合垃圾回收的条件？"><a href="#5-以下代码运行到关键点处，有多少对象符合垃圾回收的条件？" class="headerlink" title="5.以下代码运行到关键点处，有多少对象符合垃圾回收的条件？"></a>5.以下代码运行到关键点处，有多少对象符合垃圾回收的条件？</h1><pre><code>public class Example {
 public static void main(String[] args) {
  String name;
  String newName = &quot;Nick&quot;;
  newName = &quot;Jason&quot;;
  name = &quot;Frieda&quot;;
  String newestName = name;
  name = null;
  // 关键点
 }
}
A.0个
B.1个
C.2个
D.3个
答案：B</code></pre><h1 id="6-以下哪些是有关垃圾回收器的正确描述？"><a href="#6-以下哪些是有关垃圾回收器的正确描述？" class="headerlink" title="6.以下哪些是有关垃圾回收器的正确描述？"></a>6.以下哪些是有关垃圾回收器的正确描述？</h1><pre><code>A.程序员可以在制定时间调用垃圾回收器释放内存
B.垃圾回收器可以保证Java程序不会产生内存溢出
C.程序员可以制定垃圾回收器回收对象
D.对象的finalize()方法在对象被垃圾回收器回收之前获得调用
答案：C、D
答案解析：通过通配符*号引入的两个不同包中存在同名的类，当代码中不加包名直接使用时，会产生编译错误，使用时需要提供完整包路径</code></pre><h1 id="7-拥有下列哪些引用类型的对象在虚拟机内存足够的情况下不会被垃圾回收机制回收？"><a href="#7-拥有下列哪些引用类型的对象在虚拟机内存足够的情况下不会被垃圾回收机制回收？" class="headerlink" title="7.拥有下列哪些引用类型的对象在虚拟机内存足够的情况下不会被垃圾回收机制回收？"></a>7.拥有下列哪些引用类型的对象在虚拟机内存足够的情况下不会被垃圾回收机制回收？</h1><pre><code>A.强引用
B.软引用
C.弱引用
D.虚引用
答案：A、B</code></pre><h1 id="8-finalize和C-的-destructors有何差异"><a href="#8-finalize和C-的-destructors有何差异" class="headerlink" title="8.finalize和C++ 的 destructors有何差异?"></a>8.finalize和C++ 的 destructors有何差异?</h1><pre><code>答案：Java内部具有“内存使用回收” 的机制， 虽然它也提供了类似 (C++ 的) destructors的 finalize()，每个对象都可以使用这个方法 method，但必须冒著破坏原先回收机制的危险。所以建议尽量避免使用finalize()，不妨考虑多使用引用队列来释出资源会好一些。</code></pre><h1 id="9-Java语言中异常的分类是哪项？"><a href="#9-Java语言中异常的分类是哪项？" class="headerlink" title="9.Java语言中异常的分类是哪项？"></a>9.Java语言中异常的分类是哪项？</h1><pre><code>A.运行时异常和异常
B.受检异常和非受检异常
C.错误和异常
D.错误和运行时异常
答案：C</code></pre><h1 id="10-所有异常的父类是哪项？"><a href="#10-所有异常的父类是哪项？" class="headerlink" title="10.所有异常的父类是哪项？"></a>10.所有异常的父类是哪项？</h1><pre><code>A.Throwable
B.Error
C.RuntimeException
D.Exception
答案：A</code></pre><h1 id="11-下列属于非受检异常（运行时异常）的是哪项？"><a href="#11-下列属于非受检异常（运行时异常）的是哪项？" class="headerlink" title="11.下列属于非受检异常（运行时异常）的是哪项？"></a>11.下列属于非受检异常（运行时异常）的是哪项？</h1><pre><code>A.SQLException
B.IOException
C.NullPointerException
D.OutOfMemoryError
答案：C</code></pre><h1 id="12-假设有自定义异常类ServiceException-那么抛出该异常的语句正确的是哪项？"><a href="#12-假设有自定义异常类ServiceException-那么抛出该异常的语句正确的是哪项？" class="headerlink" title="12.假设有自定义异常类ServiceException,那么抛出该异常的语句正确的是哪项？"></a>12.假设有自定义异常类ServiceException,那么抛出该异常的语句正确的是哪项？</h1><pre><code>A.raise ServiceException
B.throw new ServiceException()
C.throw ServiceException
D.throws ServiceException
答案：B</code></pre><h1 id="13-在方法声明中，说明该方法可能会抛出的异常列表时使用哪个关键字？"><a href="#13-在方法声明中，说明该方法可能会抛出的异常列表时使用哪个关键字？" class="headerlink" title="13.在方法声明中，说明该方法可能会抛出的异常列表时使用哪个关键字？"></a>13.在方法声明中，说明该方法可能会抛出的异常列表时使用哪个关键字？</h1><pre><code>A.throw 
B.catch
C.finally
D.throws
答案：D</code></pre><h1 id="14-现有代码："><a href="#14-现有代码：" class="headerlink" title="14.现有代码："></a>14.现有代码：</h1><pre><code>public class Example {
 public static void main(String[] args) {
  try {
   System.out.print(Integer.parseInt(&quot;forty&quot;));   
  } catch (RuntimeException e) {
   System.out.println(&quot;Runtime&quot;);
  }catch (NumberFormatException e) {
   System.out.println(&quot;Number&quot;);
  }
 }
}
执行结果是什么？
A.输出Number
B.输出Runtime
C.输出40
D.编译失败
答案：D
答案解析：NumberFormatException是RuntimeException的子类，因此两个catch块位置应该交换才能正确处理异常</code></pre><h1 id="15-现有代码如下："><a href="#15-现有代码如下：" class="headerlink" title="15.现有代码如下："></a>15.现有代码如下：</h1><pre><code>public class Example {

 void topGo() {
  try {
   middleGo();
  } catch (Exception e) {
   System.out.println(&quot;catch&quot;);
  }
 }

 void middleGo() throws Exception {
  go();
  System.out.println(&quot;late middle&quot;);
 }

 void go() throws Exception {
  throw new Exception();
 }

 public static void main(String[] args) {
  Example example = new Example();
  example.topGo();
 }
}
该代码的执行结果是？
A.输出late middle
B.输出catch
C.输出late middle catch
D.输出catch late middle
答案：B</code></pre><h1 id="16-如下代码执行后的输出结果是？"><a href="#16-如下代码执行后的输出结果是？" class="headerlink" title="16.如下代码执行后的输出结果是？"></a>16.如下代码执行后的输出结果是？</h1><pre><code>public class Example {
 public static void main(String[] args) {
  try {
   throw new Exception();
  } catch (Exception e) {
   try {
    throw new Exception();
   } catch (Exception e2) {
    System.out.println(&quot;inner&quot;);
   }
   System.out.println(&quot;middle&quot;);
  }
  System.out.println(&quot;out&quot;);
 }
}
A.inner outer
B.middle outer
C.inner middle outer
D.编译失败
答案：C</code></pre><h1 id="17-现有如下代码："><a href="#17-现有如下代码：" class="headerlink" title="17.现有如下代码："></a>17.现有如下代码：</h1><pre><code>public class Example extends Utils{
 public static void main(String[] args) {
  try {
   System.out.println(new Example().getInt(&quot;42&quot;));
  } catch (NumberFormatException e) {
   System.out.println(&quot;NFExc&quot;);
  }
 } 
 int getInt(String arg) throws NumberFormatException{
  return Integer.parseInt(arg);
 }
}

class Utils {
 int getInt(String arg) {
  return 42;
 }
}
该代码执行的结果是？
A.NFExc
B.42.0
C.42NFExc
D.编译失败
答案：B
答案解析：Utils中的getInt方法没有抛出异常，而子类Example中的getInt抛出了运行时异常，这是符合方法覆盖的抛出异常特性规范的，因为运行时异常并不会强制要求方法调用代码捕获处理</code></pre><h1 id="18-现有如下代码："><a href="#18-现有如下代码：" class="headerlink" title="18.现有如下代码："></a>18.现有如下代码：</h1><pre><code>public class Example extends Utils{
 public static void main(String[] args) {
  try {
   System.out.println(new Example().getInt(&quot;42&quot;));
  } catch (NumberFormatException e) {
   System.out.println(&quot;NFExc&quot;);
  }
 } 
 int getInt(String arg) throws Exception{
  return Integer.parseInt(arg);
 }
}

class Utils {
 int getInt(String arg) {
  return 42;
 }
}
该代码执行的结果是？
A.NFExc
B.42.0
C.42NFExc
D.编译失败
答案：D
答案解析：子类抛出的异常不符合方法覆盖的异常列表要求，因此编译失败（见上题）</code></pre><h1 id="19-现有如下代码："><a href="#19-现有如下代码：" class="headerlink" title="19.现有如下代码："></a>19.现有如下代码：</h1><pre><code>public class Example {
 public static void main(String[] args) {// a
  new Example().topGo();
 }

 void topGo() {// b
  middleGo();
 }

 void middleGo() {// c
  go();
  System.out.println(&quot;late middle&quot;);
 }

 void go() {// d
  throw new Exception();
 }
}
为了使代码能够编译通过，需要在哪个地方加入声明throws Exception?
A.d
B.c和d
C.b、c和d
D.a、b、c和d
答案：D</code></pre><h1 id="20-下面代码的执行结果是？"><a href="#20-下面代码的执行结果是？" class="headerlink" title="20.下面代码的执行结果是？"></a>20.下面代码的执行结果是？</h1><pre><code>class Example extends Utils {
 public static void main(String[] args) {
  try {
   System.out.print(new Example().getlnt(&quot;42&quot;));
  } catch (Exception e) {
   System.out.println(&quot;Exc&quot;);
  }
 }

 int getlnt(String arg) throws Exception {
  return Integer.parseInt(arg);
 }
}

class Utils {
 int getlnt() {
  return 42;
 }
}
A.NFExc
B.42.0
C.42NFExc
D.编译失败
答案：B
答案解析：本题没有实现方法覆盖</code></pre><h1 id="21-关于异常处理，说法错误的是？"><a href="#21-关于异常处理，说法错误的是？" class="headerlink" title="21.关于异常处理，说法错误的是？"></a>21.关于异常处理，说法错误的是？</h1><pre><code>A.try⋯catch⋯finally结构中，必须有try语句块，catch语句块和finally语句块不是必须的，但至少要两者取其一
B.在异常处理中，若try中的代码可能产生多种异常则可以对应多个catch语句，若catch中的参数类型有父类子类关系，此时应该将子类放在后面，父类放在前面
C.一个方法可以抛出多个异常，方法的返回值也能够是异常
D.Throwable是所有异常的超类
答案：B
答案解析：若catch中的参数类型有父类子类关系，此时应该将子类放在前面，父类放在后面</code></pre><h1 id="22-以下关于Error和Exception类的描述正确的是？"><a href="#22-以下关于Error和Exception类的描述正确的是？" class="headerlink" title="22.以下关于Error和Exception类的描述正确的是？"></a>22.以下关于Error和Exception类的描述正确的是？</h1><pre><code>A.Error类和Exception类都是Throwable类的子类
B.Error类是一个final类，而Exception类是一个非final类
C.Exception类是一个final类，而Error类是一个非final类
D.Error类和Exception类都实现了Throwable接口
答案：A</code></pre><h1 id="23-请问以下哪个是声明一个方法抛出异常的正确形式？"><a href="#23-请问以下哪个是声明一个方法抛出异常的正确形式？" class="headerlink" title="23.请问以下哪个是声明一个方法抛出异常的正确形式？"></a>23.请问以下哪个是声明一个方法抛出异常的正确形式？</h1><pre><code>A.void m() throws IOException{}
B.void m() throw IOException
C.void m(){} throws IOException
D.void m(void) throw IOException{}
答案：A</code></pre><h1 id="24-请问以下哪些关于try⋯catch⋯finally结构中的finally语句的描述是正确的？"><a href="#24-请问以下哪些关于try⋯catch⋯finally结构中的finally语句的描述是正确的？" class="headerlink" title="24.请问以下哪些关于try⋯catch⋯finally结构中的finally语句的描述是正确的？"></a>24.请问以下哪些关于try⋯catch⋯finally结构中的finally语句的描述是正确的？</h1><pre><code>A.只有当一个catch语句获得执行后，finally语句才获得执行
B.只有当catch语句未获得执行时，finally语句才获得执行
C.如果有finally语句，return语句将在finally语句执行完毕后才会返回
D.只有当异常抛出时，finally语句才获得执行
答案：C</code></pre><h1 id="25-请问以下代码的直接执行结果是？"><a href="#25-请问以下代码的直接执行结果是？" class="headerlink" title="25.请问以下代码的直接执行结果是？"></a>25.请问以下代码的直接执行结果是？</h1><pre><code>class Example{
 public static void main(String[] args) {
  try {
   System.out.println(args[0]);
   System.out.println(&quot;I&apos;m nomal&quot;);
   if (true)
    return;
  } catch (Exception ex) {
   System.out.println(&quot;I&apos;m exception&quot;);
   if (true)
    return;
  } finally {
   System.out.println(&quot;I&apos;m finally.&quot;);
  }

  System.out.println(&quot;Out of try.&quot;);
 }
｝
A.I&apos;m exception
I&apos;m finally.
B.代码不能编译通过，因为最后一条语句位于return后，不可到达
C.代码编译通过，但运行时输出异常信息
D.I&apos;m nomal
I&apos;m finally.
答案：A</code></pre><h1 id="26-关于以下代码，说法正确的是？"><a href="#26-关于以下代码，说法正确的是？" class="headerlink" title="26.关于以下代码，说法正确的是？"></a>26.关于以下代码，说法正确的是？</h1><pre><code>class Example{
 public static void main(String[] args) throws IOException {
  if (args[0] == &quot;hello&quot;) {
   throw new IOException();
  }
 }
}
A.代码编译成功
B.代码编译失败，因为main()方法是入口方法，不能抛出异常
C.代码编译失败，因为IOException异常是系统异常，不能由应用程序抛出
D.代码编译失败，因为字符串应该用equals方法判定一致性
答案：A</code></pre><h1 id="27-关于以下代码，说法正确的是？"><a href="#27-关于以下代码，说法正确的是？" class="headerlink" title="27.关于以下代码，说法正确的是？"></a>27.关于以下代码，说法正确的是？</h1><pre><code>class Example {
 public static void main(String[] args) throws IOException {
  System.out.println(&quot;Before Try&quot;);
  try {
  } catch (java.io.IOException e) {
   System.out.println(&quot;Inside Catch&quot;);
  }
  System.out.println(&quot;At the End&quot;);
 }
}
A.代码编译失败，因为无异常抛出
B.代码编译失败，因为未导入IOException异常类
C.输出Before Try
At the End
D.输出Inside Catch
At the End
答案：A</code></pre><h1 id="28-关于以下代码，说法正确的是？"><a href="#28-关于以下代码，说法正确的是？" class="headerlink" title="28.关于以下代码，说法正确的是？"></a>28.关于以下代码，说法正确的是？</h1><pre><code>class Example {
 public static void main(String[] args) throws IOException {
  System.out.println(&quot;Before Try&quot;);
  try {
  } catch (Throwable e) {
   System.out.println(&quot;Inside Catch&quot;);
  }
  System.out.println(&quot;At the End&quot;);
 }
}
A.代码编译失败，因为无异常抛出
B.代码编译失败，因为未导入IOException异常类
C.输出Before Try
At the End
D.输出Inside Catch
At the End
答案：C</code></pre><h1 id="29-给出以下代码："><a href="#29-给出以下代码：" class="headerlink" title="29.给出以下代码："></a>29.给出以下代码：</h1><pre><code>class Example {
 public static void main(String[] args) throws IOException {
  try {
   methodA();   
  } catch (IOException e) {
   System.out.println(&quot;caught IOException&quot;);
  }catch (Exception e) {
   System.out.println(&quot;caught Exception&quot;);
  }
 }
}
如果methodA()方法抛出一个IOException异常，则该程序的运行结果是什么？
A.无内容输出
B.代码编译失败
C.输出caught IOException
D.输出caught Exception
答案：C</code></pre><h1 id="30-下列代码的运行结果是？"><a href="#30-下列代码的运行结果是？" class="headerlink" title="30.下列代码的运行结果是？"></a>30.下列代码的运行结果是？</h1><pre><code>class Example {
 public static void main(String[] args) throws IOException {
  try {
   return;
  } finally{

   System.out.println(&quot;Finally&quot;);
  }
 }
}
A.无内容输出
B.输出Finally
C.代码编译失败
D.输出异常信息
答案：B</code></pre><h1 id="31-给出以下代码，执行结果是？"><a href="#31-给出以下代码，执行结果是？" class="headerlink" title="31.给出以下代码，执行结果是？"></a>31.给出以下代码，执行结果是？</h1><pre><code>class Example {
 public static void main(String[] args) throws IOException {
  aMethod();
 }

 static void aMethod(){
  try {
   System.out.println(&quot;Try&quot;);
   return;
  } catch (Exception e) {
   System.out.println(&quot;Catch&quot;);
  }finally{
   System.out.println(&quot;Finally&quot;);
  }
 }
}
A.代码编译成功，但运行期间抛出异常
B.代码便以失败，因为return语句错误
C.输出Try和Finally
D.输出Try
答案：C</code></pre><h1 id="32-以下代码中，如果test-方法抛出一个NullPointException异常时，打印输出什么内容？"><a href="#32-以下代码中，如果test-方法抛出一个NullPointException异常时，打印输出什么内容？" class="headerlink" title="32.以下代码中，如果test()方法抛出一个NullPointException异常时，打印输出什么内容？"></a>32.以下代码中，如果test()方法抛出一个NullPointException异常时，打印输出什么内容？</h1><pre><code>class Example {
 public static void main(String[] args) throws IOException {
  try {
   test();
   System.out.println(&quot;Message1&quot;);
  } catch (ArrayIndexOutOfBoundsException e) {
   System.out.println(&quot;Message2&quot;);
  }finally{
   System.out.println(&quot;Message3&quot;);
  }
 }
}
A.打印输出Message1
B.打印输出Message2
C.打印输出Message3
D.以上都不对
答案：C</code></pre><h1 id="33-以下代码执行结果是什么？"><a href="#33-以下代码执行结果是什么？" class="headerlink" title="33.以下代码执行结果是什么？"></a>33.以下代码执行结果是什么？</h1><pre><code>class Example {
 public static String output = &quot;&quot;;
 public static void foo(int i) {
  try {
   if (i == 1) {
    throw new Exception();
   }
   output += &quot;1&quot;;
  } catch (Exception e) {
   output += &quot;2&quot;;
   return;
  } finally {
   output += &quot;3&quot;;
  }
  output += &quot;4&quot;;
 }

 public static void main(String[] args) throws IOException {
  foo(0);
  foo(1);
  System.out.println(output);
 }
}
A.无内容输出
B.代码编译失败
C.输出13423
D.输出14323
答案：C</code></pre><h1 id="34-以下代码执行结果是？"><a href="#34-以下代码执行结果是？" class="headerlink" title="34.以下代码执行结果是？"></a>34.以下代码执行结果是？</h1><pre><code>public abstract class Example extends Base {
 public abstract void method();
}

class Base {
 public Base() throws IOException {
  throw new IOException();
 }
}
A.代码编译失败，因为非抽象类不能被扩展为抽象类
B.代码编译失败，因为必须提供一个可以抛出或可以不抛出IOException异常的构造器
C.代码编译失败，以in为必须提供一个可以抛出IOException异常或其子类的构造器
D.代码编译成功
答案：C</code></pre><h1 id="35-关于以下代码正确的说法是："><a href="#35-关于以下代码正确的说法是：" class="headerlink" title="35.关于以下代码正确的说法是："></a>35.关于以下代码正确的说法是：</h1><pre><code>public class Example {
int x = 0;

 public Example(int inVal) throws Exception {
if (inVal != this.x) {
 throw new Exception(&quot;Invalid input&quot;);
}
 }

public static void main(String[] args) {
 Example t = new Example(4);
 }
}
A.代码在第1行编译错误
B.代码在第4行编译错误
C.代码在第6行编译错误
D.代码在第11行编译错误
答案：D</code></pre><h1 id="36-关于try⋯catch⋯finally结构，描述正确的是些？"><a href="#36-关于try⋯catch⋯finally结构，描述正确的是些？" class="headerlink" title="36.关于try⋯catch⋯finally结构，描述正确的是些？"></a>36.关于try⋯catch⋯finally结构，描述正确的是些？</h1><pre><code>A.可以有多个catch
B.只能有一个catch
C.可以没有catch
D.finally必须有
答案：A、C</code></pre><h1 id="37-当fragile-方法抛出一个IllegalArgumentException异常时，下列代码的运行结果是什么？"><a href="#37-当fragile-方法抛出一个IllegalArgumentException异常时，下列代码的运行结果是什么？" class="headerlink" title="37.当fragile()方法抛出一个IllegalArgumentException异常时，下列代码的运行结果是什么？"></a>37.当fragile()方法抛出一个IllegalArgumentException异常时，下列代码的运行结果是什么？</h1><pre><code>public static void main(String[] args) throws IOException {
  try {
   fragile();
  } catch (NullPointerException e) {
   System.out.println(&quot;NullPointerException thrown&quot;);
  } catch (Exception e) {
   System.out.println(&quot;Exception thrown&quot;);
  } finally {
   System.out.println(&quot;Done with exceptions&quot;);
  }
  System.out.println(&quot;myMethod is done&quot;);
 }
｝
A.输出NullPointerException thrown
B.输出Exception thrown
C.输出Done with Exception
D.输出myMethod is done
答案：B、C、D</code></pre><h1 id="38-现有如下代码："><a href="#38-现有如下代码：" class="headerlink" title="38.现有如下代码："></a>38.现有如下代码：</h1><pre><code>public class Example { 
 public static void main(String[] args) {
  try {
   int x=Integer.parseInt(&quot;42a&quot;);
   //插入代码处
   System.out.println(&quot;oops&quot;);
  }
 }
}
在插入代码处插入哪些语句可以在运行后输出oops？
A. } catch (IllegalArgumentException e) {
B.} catch (IllegalStateException c) {
C. } catch (NumbelFormatException n) {
D.} catch (ClassCastException c) {
答案：A、C</code></pre><h1 id="39-下列代码的执行结果是？"><a href="#39-下列代码的执行结果是？" class="headerlink" title="39.下列代码的执行结果是？"></a>39.下列代码的执行结果是？</h1><pre><code>class Example {
 public static void main(String[] args) throws IOException {
  int i = 1, j = 1;
  try {
   i++;
   j--;
   if (i == j) {
    j++;
   }
  } catch (ArithmeticException e) {
   System.out.println(0);
  } catch (ArrayIndexOutOfBoundsException e) {
   System.out.println(1);
  } catch (Exception e) {
   System.out.println(2);
  } finally {
   System.out.println(3);
  }
  System.out.println(4);
 }
}
A.输出1
B.输出2
C.输出3
D.输出4
答案：C、D</code></pre><h1 id="40-下列代码的执行结果是？"><a href="#40-下列代码的执行结果是？" class="headerlink" title="40.下列代码的执行结果是？"></a>40.下列代码的执行结果是？</h1><pre><code>class Example {
 public static void main(String[] args) throws IOException {
  int i = 1, j = 1;
  try {
   i++;
   j--;
   if (i/j &gt; 1) {
    j++;
   }
  } catch (ArithmeticException e) {
   System.out.println(0);
  } catch (ArrayIndexOutOfBoundsException e) {
   System.out.println(1);
  } catch (Exception e) {
   System.out.println(2);
  } finally {
   System.out.println(3);
  }
  System.out.println(4);
 }
}
A.输出0
B.输出2
C.输出3
D.输出4
答案：A、C、D</code></pre><h1 id="41-现有如下代码："><a href="#41-现有如下代码：" class="headerlink" title="41.现有如下代码："></a>41.现有如下代码：</h1><pre><code>public class Example { 
 public static void main(String[] args) {
  try {
   System.out.println(&quot;before&quot;);
   doRisyThing();
   System.out.println(&quot;after&quot;);
  } catch (Exception e) {
   System.out.println(&quot;catch&quot;);
  }
  System.out.println(&quot;done&quot;);
 }

 public static void doRisyThing() throws Exception{
  //this code returns unless it throws an Exception
 }
}
该代码可能的执行结果有哪些？
A.before catch
B.before after done
C.before catch done
D.before after catch
答案：B、C</code></pre><h1 id="42-以下有关java-lang-Exception异常类的正确描述有？"><a href="#42-以下有关java-lang-Exception异常类的正确描述有？" class="headerlink" title="42.以下有关java.lang.Exception异常类的正确描述有？"></a>42.以下有关java.lang.Exception异常类的正确描述有？</h1><pre><code>A.该类是一个公共类
B.该类是Throwable类的子类
C.该类实现了Throwable接口
D.该类可以序列化
答案：A、B、D</code></pre><h1 id="43-给出以下代码："><a href="#43-给出以下代码：" class="headerlink" title="43.给出以下代码："></a>43.给出以下代码：</h1><pre><code>1. public void aMethod(){  
2.  
3.  if(Condition){
4.   
5.  }
6.  
7. }
当if条件表达式为true时，插入哪些语句可以抛出MyException异常？
A.在第4行插入throws new MyException();
B.在第4行插入throw new MyException();
C.在第6行插入throw new MyException();
D.在第1行插入throws MyException
答案：B、D</code></pre><h1 id="44-以下哪些是catch语句能够捕获处理的异常？"><a href="#44-以下哪些是catch语句能够捕获处理的异常？" class="headerlink" title="44.以下哪些是catch语句能够捕获处理的异常？"></a>44.以下哪些是catch语句能够捕获处理的异常？</h1><pre><code>A.Throwable
B.Error
C.Exception
D.String
答案：A、B、C
Error也是可以被catch捕获的</code></pre><h1 id="45-以下哪些描述是正确的？"><a href="#45-以下哪些描述是正确的？" class="headerlink" title="45.以下哪些描述是正确的？"></a>45.以下哪些描述是正确的？</h1><pre><code>A.try语句块后必须至少存在一个catch语句块
B.try语句块后可以存在不限数量的finally语句块
C.try语句块后必须至少存在一个catch语句块或finally语句块
D.如果catch和finally语句块同时存在，则catch语句块必须位于finally语句块前
答案：C、D</code></pre><h1 id="46-下列代码的执行结果是？"><a href="#46-下列代码的执行结果是？" class="headerlink" title="46.下列代码的执行结果是？"></a>46.下列代码的执行结果是？</h1><pre><code>class Example {

 private void method1() throws Exception {
  throw new RuntimeException();
 }

 public void method2() {
  try {
   method1();
  } catch (RuntimeException e) {
   System.out.println(&quot;Caught Runtime Exception&quot;);
  } catch (Exception e) {
   System.out.println(&quot;Caught Exception&quot;);
  }
 }

 public static void main(String[] args) throws IOException {
  Example a = new Example();
  a.method2();
 }
}
A.代码编译失败
B.输出Caught Runtime Exception
C.输出Caught Exception
D.输出Caught Runtime Exception和Caught Exception
答案：B</code></pre><h1 id="47-以下代码的输出结果是什么？选择所有的正确答案。"><a href="#47-以下代码的输出结果是什么？选择所有的正确答案。" class="headerlink" title="47.以下代码的输出结果是什么？选择所有的正确答案。"></a>47.以下代码的输出结果是什么？选择所有的正确答案。</h1><pre><code>class Example {
 public static void main(String[] args) throws IOException {
  for (int i = 0; i &lt; 10; i++) {

   try {
    try {
     if (i % 3 == 0)
      throw new Exception(&quot;E0&quot;);
     System.out.println(i);
    } catch (Exception inner) {
     i *= 2;
     if (i % 3 == 0)
      throw new Exception(&quot;E1&quot;);
    } finally {
     ++i;
    }
   } catch (Exception outer) {
    i += 3;
   } finally {
    --i;
   }
  }
 }
}
A.4.0
B.5.0
C.6.0
D.7.0
答案：A、B</code></pre><h1 id="48-Java中异常的分类"><a href="#48-Java中异常的分类" class="headerlink" title="48.Java中异常的分类"></a>48.Java中异常的分类</h1><pre><code>答案：
java.lang.Throwable
|-- Error错误：JVM内部的严重问题。无法恢复。程序人员不用处理。
|--Exception异常：普通的问题。通过合理的处理，程序还可以回到正常执行流程。要求编程人员要进行处理。
|--RuntimeException:也叫非受检异常(unchecked exception).这类异常是编程人员的逻辑问题。应该承担责任。Java编译器不进行强制要求处理。 也就是说，这类异常再程序中，可以进行处理，也可以不处理。
|--非RuntimeException:也叫受检异常(checked exception).这类异常是由一些外部的偶然因素所引起的。Java编译器强制要求处理。也就是说，程序必须进行对这类异常进行处理。</code></pre><h1 id="49-给出常见的RuntimeException"><a href="#49-给出常见的RuntimeException" class="headerlink" title="49.给出常见的RuntimeException"></a>49.给出常见的RuntimeException</h1><pre><code>答案：
常见的运行时异常有如下这些ArithmeticException, ArrayStoreException, BufferOverflowException, BufferUnderflowException, CannotRedoException, CannotUndoException, ClassCastException, CMMException, ConcurrentModificationException, DOMException, EmptyStackException, IllegalArgumentException, IllegalMonitorStateException, IllegalPathStateException, IllegalStateException, ImagingOpException, IndexOutOfBoundsException, MissingResourceException, NegativeArraySizeException, NoSuchElementException, NullPointerException, ProfileDataException, ProviderException, RasterFormatException, SecurityException, SystemException, UndeclaredThrowableException, UnmodifiableSetException, UnsupportedOperationException</code></pre><h1 id="50-error和exception有什么区别"><a href="#50-error和exception有什么区别" class="headerlink" title="50.error和exception有什么区别"></a>50.error和exception有什么区别</h1><pre><code>答案：
error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况
exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况</code></pre><h1 id="51-以下代码的执行结果是？"><a href="#51-以下代码的执行结果是？" class="headerlink" title="51.以下代码的执行结果是？"></a>51.以下代码的执行结果是？</h1><pre><code>public static int fun() {
  int result = 5;
  try {
   result = result / 0;
   return result;
  } catch (Exception e) {
   System.out.println(&quot;Exception&quot;);
   result = -1;
   return result;
  } finally {
   result = 10;
   System.out.println(&quot;i am in finally&quot;);
  }
 }

 public static void main(String[] args) {
  int x=fun();
  System.out.println(x);

 }

答案：
Exception
I am in finally
-1</code></pre><h1 id="52-以下代码的执行结果是？"><a href="#52-以下代码的执行结果是？" class="headerlink" title="52.以下代码的执行结果是？"></a>52.以下代码的执行结果是？</h1><pre><code>public class Example {
 public static StringBuffer fun() {

  StringBuffer result = new StringBuffer(&quot;Hello&quot;);
  Integer i = new Integer(5);
  try {
   if (true)
    throw new RuntimeException();
   return result;
  } catch (Exception e) {
   System.out.println(&quot;Exception&quot;);
   result.append(&quot; World&quot;);
   return result;
  } finally {
   result.append(&quot; Java&quot;);
   System.out.println(&quot;i am in finally&quot;);
  }
 }

 public static void main(String[] args) {
  StringBuffer x = fun();
  System.out.println(x);

 }

答案：
Exception
i am in finally
Hello World Java</code></pre><h1 id="53-什么时候用assert"><a href="#53-什么时候用assert" class="headerlink" title="53.什么时候用assert?"></a>53.什么时候用assert?</h1><pre><code>答案：
断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为 true。如果表达式计算为 false，那么系统会报告一个 Assertionerror。它用于调试目的：

assert(a &gt; 0); // throws anAssertionerror if a &lt;= 0

断言可以有两种形式：

assert Expression1 ;

assert Expression1 :Expression2 ;

  Expression1 应该总是产生一个布尔值。

  Expression2 可以是得出一个值的任意表达式。这个值用于生成显示更多调试信息的 String 消息。

  断言在默认情况下是禁用的。要在编译时启用断言，需要使用 source 1.4 标记：

  javac -source 1.4 Test.java

  要在运行时启用断言，可使用 -enableassertions 或者 -ea 标记。

  要在运行时选择禁用断言，可使用 -da 或者 -disableassertions 标记。

  要系统类中启用断言，可使用 -esa 或者 -dsa 标记。还可以在包的基础上启用或者禁用断言。

 可以在预计正常情况下不会到达的任何位置上放置断言。断言可以用于验证传递给私有方法的参数。不过，断言不应该用于验证传递给公有方法的参数，因为不管是否启用了断言，公有方法都必须检查其参数。不过，既可以在公有方法中，也可以在非公有方法中利用断言测试后置条件。另外，断言不应该以任何方式改变程序的状态。</code></pre><h1 id="54-给我一个你最常见到的runtime-exception"><a href="#54-给我一个你最常见到的runtime-exception" class="headerlink" title="54.给我一个你最常见到的runtime exception"></a>54.给我一个你最常见到的runtime exception</h1><pre><code>答案：
常见的运行时异常有如下这些ArithmeticException, ArrayStoreException, BufferOverflowException, BufferUnderflowException, CannotRedoException, CannotUndoException, ClassCastException, CMMException, ConcurrentModificationException, DOMException, EmptyStackException, IllegalArgumentException, IllegalMonitorStateException, IllegalPathStateException, IllegalStateException, ImagingOpException, IndexOutOfBoundsException, MissingResourceException, NegativeArraySizeException, NoSuchElementException, NullPointerException, ProfileDataException, ProviderException, RasterFormatException, SecurityException, SystemException, UndeclaredThrowableException, UnmodifiableSetException, UnsupportedOperationException</code></pre><h1 id="55-谈谈final-finally-finalize的区别"><a href="#55-谈谈final-finally-finalize的区别" class="headerlink" title="55.谈谈final, finally, finalize的区别"></a>55.谈谈final, finally, finalize的区别</h1><pre><code>答案：
final—修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载
finally—再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）
finalize—方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的</code></pre><h1 id="56-下列说法错误的是？"><a href="#56-下列说法错误的是？" class="headerlink" title="56.下列说法错误的是？"></a>56.下列说法错误的是？</h1><pre><code>A.Object类是所有Java类的顶层类，即类继承树的根。
B.如果一个类没有使用extends关键字扩展任何类，则编译器自动将创建的类视为Object类的子类
C.Object类中提供了equals()方法来判定本对象和其他对象中的内容是否一致
D.Object中提供的clone默认为浅克隆
答案：C
equals方法默认和==一致</code></pre><h1 id="57-定义在Object类上的hashCode-方法的返回值类型是什么？"><a href="#57-定义在Object类上的hashCode-方法的返回值类型是什么？" class="headerlink" title="57.定义在Object类上的hashCode()方法的返回值类型是什么？"></a>57.定义在Object类上的hashCode()方法的返回值类型是什么？</h1><pre><code>A.char
B.long
C.int
D.float
答案：C</code></pre><h1 id="58-关于集合中对象的equals-和hashCode-规定说法错误的是？"><a href="#58-关于集合中对象的equals-和hashCode-规定说法错误的是？" class="headerlink" title="58.关于集合中对象的equals()和hashCode()规定说法错误的是？"></a>58.关于集合中对象的equals()和hashCode()规定说法错误的是？</h1><pre><code>A.如果两个对象相同，那么他们的hashCode值需要一致
B.如果两个对象的hashCode值一致，他们的equals方法不一定返回true
C.equals方法默认和==判定一致
D.Java中hashCode就是对象的内存地址
答案：D
Java中hashCode不是内存地址，但是可以一定程度上代表地址特诊</code></pre><h1 id="59-以下代码执行结果是什么？"><a href="#59-以下代码执行结果是什么？" class="headerlink" title="59.以下代码执行结果是什么？"></a>59.以下代码执行结果是什么？</h1><pre><code>class Person {
 static void sayHello() {
  System.out.println(&quot;HelloWorld!&quot;);
 }
}

public class Example {
 public static void main(String[] args) {
  ((Person) null).sayHello();
 }
}
A.编译失败
B.编译成功，运行时产生NullPointerException
C.输出HelloWorld!
D.输出空白字符串
答案：C
null能够被造型撑任何类型，而sayHello方法是静态方法，不依赖实例调用</code></pre><h1 id="60-下列代码执行结果是："><a href="#60-下列代码执行结果是：" class="headerlink" title="60.下列代码执行结果是："></a>60.下列代码执行结果是：</h1><pre><code>class RectObject {
 public int x;
 public int y;

 public RectObject(int x, int y) {
  this.x = x;
  this.y = y;
 }

 @Override
 public int hashCode() {
  final int prime = 31;
  int result = 1;
  result = prime * result + x;
  result = prime * result + y;
  return result;
 }

 @Override
 public boolean equals(Object obj) {
  if (this == obj)
   return true;
  if (obj == null)
   return false;
  if (getClass() != obj.getClass())
   return false;
  final RectObject other = (RectObject) obj;
  if (x != other.x) {
   return false;
  }
  if (y != other.y) {
   return false;
  }
  return true;
 }
}

public class Example {
 public static void main(String[] args) {
  HashSet&lt;RectObject&gt; set = new HashSet&lt;RectObject&gt;();
  RectObject r1 = new RectObject(3, 3);
  RectObject r2 = new RectObject(5, 5);
  RectObject r3 = new RectObject(3, 3);
  set.add(r1);
  set.add(r2);
  set.add(r3);
  set.add(r1);
  System.out.println(&quot;size:&quot; + set.size());
 }
}
A.size:1
B.size:2
C.size:3
D.size:4
答案：B
因为我们重写了RectObject类的hashCode方法，只要RectObject对象的x,y属性值相等那么他的hashCode值也是相等的，所以先比较hashCode的值，r1和r2对象的x,y属性值不等，所以他们的hashCode不相同的，所以r2对象可以放进去，但是r3对象的x,y属性值和r1对象的属性值相同的，所以hashCode是相等的，这时候在比较r1和r3的equals方法，因为他么两的x,y值是相等的，所以r1,r3对象是相等的，所以r3不能放进去了，同样最后再添加一个r1也是没有没有添加进去的，所以set集合中只有一个r1和r2这两个对象</code></pre><h1 id="61-以下代码的执行结果是？"><a href="#61-以下代码的执行结果是？" class="headerlink" title="61.以下代码的执行结果是？"></a>61.以下代码的执行结果是？</h1><pre><code>class RectObject {
 public int x;
 public int y;

 public RectObject(int x, int y) {
  this.x = x;
  this.y = y;
 }


 @Override
 public boolean equals(Object obj) {
  if (this == obj)
   return true;
  if (obj == null)
   return false;
  if (getClass() != obj.getClass())
   return false;
  final RectObject other = (RectObject) obj;
  if (x != other.x) {
   return false;
  }
  if (y != other.y) {
   return false;
  }
  return true;
 }
}

public class Example {
 public static void main(String[] args) {
  HashSet&lt;RectObject&gt; set = new HashSet&lt;RectObject&gt;();
  RectObject r1 = new RectObject(3, 3);
  RectObject r2 = new RectObject(5, 5);
  RectObject r3 = new RectObject(3, 3);
  set.add(r1);
  set.add(r2);
  set.add(r3);
  set.add(r1);
  System.out.println(&quot;size:&quot; + set.size());
 }
}
A.size:1
B.size:2
C.size:3
D.size:4
答案：C
首先判断r1对象和r2对象的hashCode，因为Object中的hashCode方法返回的是对象本地内存地址的换算结果，不同的实例对象的hashCode是不相同的，同样因为r3和r1的hashCode也是不相等的，但是r1==r1的，所以最后set集合中只有r1,r2,r3这三个对象，所以大小是3</code></pre><h1 id="62-以下代码执行结果是？"><a href="#62-以下代码执行结果是？" class="headerlink" title="62.以下代码执行结果是？"></a>62.以下代码执行结果是？</h1><pre><code>class RectObject {
 public int x;
 public int y;

 public RectObject(int x, int y) {
  this.x = x;
  this.y = y;
 }


 @Override
 public boolean equals(Object obj) {
  return false;
 }
}

public class Example {
 public static void main(String[] args) {
  HashSet&lt;RectObject&gt; set = new HashSet&lt;RectObject&gt;();
  RectObject r1 = new RectObject(3, 3);
  RectObject r2 = new RectObject(5, 5);
  RectObject r3 = new RectObject(3, 3);
  set.add(r1);
  set.add(r2);
  set.add(r3);
  set.add(r1);
  System.out.println(&quot;size:&quot; + set.size());
 }
}
A.size:1
B.size:2
C.size:3
D.size:4
答案：C
首先是判断hashCode是否相等，不相等的话，直接跳过，相等的话，然后再来比较这两个对象是否相等或者这两个对象的equals方法，因为是进行的或操作，所以只要有一个成立即可，那这里我们就可以解释了，其实上面的那个集合的大小是3,因为最后的一个r1没有放进去，以为r1==r1返回true的，所以没有放进去了。所以集合的大小是3，如果我们将hashCode方法设置成始终返回false的话，这个集合就是4了。</code></pre><h1 id="63-以下代码执行结果是？"><a href="#63-以下代码执行结果是？" class="headerlink" title="63.以下代码执行结果是？"></a>63.以下代码执行结果是？</h1><pre><code>class RectObject {
 public int x;
 public int y;

 public RectObject(int x, int y) {
  this.x = x;
  this.y = y;
 }

 @Override
 public int hashCode() {
  // TODO Auto-generated method stub
  return (int)System.nanoTime();
 }

 @Override
 public boolean equals(Object obj) {
  return false;
 }
}

public class Example {
 public static void main(String[] args) {
  HashSet&lt;RectObject&gt; set = new HashSet&lt;RectObject&gt;();
  RectObject r1 = new RectObject(3, 3);
  RectObject r2 = new RectObject(5, 5);
  RectObject r3 = new RectObject(3, 3);
  set.add(r1);
  set.add(r2);
  set.add(r3);
  set.add(r1);
  System.out.println(&quot;size:&quot; + set.size());
 }
}
A.size:1
B.size:2
C.size:3
D.size:4
答案：D
见上题</code></pre><h1 id="64-下列关于Math类说法错误的是"><a href="#64-下列关于Math类说法错误的是" class="headerlink" title="64.下列关于Math类说法错误的是"></a>64.下列关于Math类说法错误的是</h1><pre><code>A.java.lang.Math类是final类，因此不能被其他类继承
B.java.lang.Math类的构造器是私有的，即声明为private，不能实例化一个Math类的对象
C.java.lang.Math类上定义的所有常量和方法均是public和static的，因此可以直接通过类名调用
D.min()和max()方法的参数之一，如果是NaN值，则方法将返回另一个参数值
答案：D
min()和max()方法的参数之一，如果是NaN值，则方法的返回值就为NaN</code></pre><h1 id="65-以下哪个方法是Math类中定义的？"><a href="#65-以下哪个方法是Math类中定义的？" class="headerlink" title="65.以下哪个方法是Math类中定义的？"></a>65.以下哪个方法是Math类中定义的？</h1><pre><code>A.absolute()
B.log()
C.cosine()
D.sine()
答案：B
在Math类中对应的正确方法应为abs()\cos()\sin()</code></pre><h1 id="66-定义在Math类上的round-double-d-方法的返回值类型是什么？"><a href="#66-定义在Math类上的round-double-d-方法的返回值类型是什么？" class="headerlink" title="66.定义在Math类上的round(double d)方法的返回值类型是什么？"></a>66.定义在Math类上的round(double d)方法的返回值类型是什么？</h1><pre><code>A.char
B.int
C.long
D.double
答案：C
round方法用于获取一个四舍五入的整数</code></pre><h1 id="67-以下哪个方法用于计算平方根？"><a href="#67-以下哪个方法用于计算平方根？" class="headerlink" title="67.以下哪个方法用于计算平方根？"></a>67.以下哪个方法用于计算平方根？</h1><pre><code>A.squareRoot()
B.sqrt()
C.root()
D.sqr()
答案：B</code></pre><h1 id="68-调用Math-random-方法最有可能输出以下哪些结果？"><a href="#68-调用Math-random-方法最有可能输出以下哪些结果？" class="headerlink" title="68.调用Math.random()方法最有可能输出以下哪些结果？"></a>68.调用Math.random()方法最有可能输出以下哪些结果？</h1><pre><code>A.-0.12和0.56E3
B.0.12和1.1E1
C.-23.45和0.0
D.0.356和0.03
答案：D
random()方法返回值的取值范围在0.0..1.0之间</code></pre><h1 id="69-以下代码的输出结果是什么？"><a href="#69-以下代码的输出结果是什么？" class="headerlink" title="69.以下代码的输出结果是什么？"></a>69.以下代码的输出结果是什么？</h1><pre><code>public class Example {
 public static void main(String[] args) {
  System.out.println(Math.round(Float.MAX_VALUE));
 }
}
A.输出Integer.MAX_VALUE
B.输出一个最接近Float.MAX_VALUE的整数
C.编译失败
D.运行时输出异常信息
答案：A
Math.round(Float.MAX_VALUE)的返回值为Integer.MAX_VALUE，Math.round(Double.MAX_VALUE)的返回值为Long.MAX_VALUE（真实计算结果超过返回值范围）</code></pre><h1 id="70-以下代码的运行结果是什么？"><a href="#70-以下代码的运行结果是什么？" class="headerlink" title="70.以下代码的运行结果是什么？"></a>70.以下代码的运行结果是什么？</h1><pre><code>public class Example {
 public static void main(String[] args) {
  System.out.println(Math.min(0.0, -0.0));
 }
}
A.代码编译失败
B.输出0.0
C.输出-0.0
D.代码编译成功，但运行时输出异常信息
答案：C
浮点数的取值范围内存在正负0.0</code></pre><h1 id="71-以下代码的执行结果是？"><a href="#71-以下代码的执行结果是？" class="headerlink" title="71.以下代码的执行结果是？"></a>71.以下代码的执行结果是？</h1><pre><code>public class Example {
 public static void main(String[] args) {
  System.out.println(Math.min(0.0, -0.0));
 }
}
A.输出4
B.输出5
C.输出6 
D.输出9
答案：D
比2.3大的最接近整数是3，因此ceil(2.3f)=3.0，因为2.7的四舍五入的值为3.0，所以round(2.7)=3.0，最终打印输出等于9</code></pre><h1 id="72-以下代码的运行结果是什么？"><a href="#72-以下代码的运行结果是什么？" class="headerlink" title="72.以下代码的运行结果是什么？"></a>72.以下代码的运行结果是什么？</h1><pre><code>public class Example {
 public static void main(String[] args) {
  double d1 = -0.5;
  System.out.println(&quot;Ceil d1=&quot; + Math.ceil(d1));
  System.out.println(&quot;Floor d1=&quot; + Math.floor(d1));
 }
}

A.输出Ceil d1=-0.0 Floor d1=-1.0
B.输出Ceil d1=0.0 Floor d1=-1.0
C.输出Ceil d1=-0.0 Floor d1=-0.0
D.输出Ceil d1=0.0 Floor d1=0.0
答案：A</code></pre><h1 id="73-给出以下代码，为了结果输出-12-0，方法method-d-应为以下哪个方法？"><a href="#73-给出以下代码，为了结果输出-12-0，方法method-d-应为以下哪个方法？" class="headerlink" title="73.给出以下代码，为了结果输出-12.0，方法method(d)应为以下哪个方法？"></a>73.给出以下代码，为了结果输出-12.0，方法method(d)应为以下哪个方法？</h1><pre><code>public class Example {
 public static void main(String[] args) {
  double d = -11.1;
  double d1 = method(d);
  System.out.println(d1);
 }
}
A.floor()
B.ceil()
C.round()
D.abs()
答案：A</code></pre><h1 id="74-给出以下代码，请问在程序的第6行插入那条语句，改程序可依次打印输出11、10、9？"><a href="#74-给出以下代码，请问在程序的第6行插入那条语句，改程序可依次打印输出11、10、9？" class="headerlink" title="74.给出以下代码，请问在程序的第6行插入那条语句，改程序可依次打印输出11、10、9？"></a>74.给出以下代码，请问在程序的第6行插入那条语句，改程序可依次打印输出11、10、9？</h1><pre><code>1.public class Example {
2. public static void main(String[] args) {
3.  double x[] = { 10.2, 9.1, 8.7 };
4.  int i[] = new int[3];
5.  for (int a = 0; a &lt; x.length; a++) {
6.
7.   System.out.println(i[a]);
8.  }
9. }
10.}
A.i[1] = ((int)Math.min(x[a]));
B.i[1] = ((int)Math.max(x[a]));
C.i[1] = ((int)Math.ceil(x[a]));
D.i[1] = ((int)Math.floor(x[a]));
答案：C</code></pre><h1 id="75-以下代码执行结果是？"><a href="#75-以下代码执行结果是？" class="headerlink" title="75.以下代码执行结果是？"></a>75.以下代码执行结果是？</h1><pre><code>public class Example {
 public static void main(String[] args) {
  System.out.println(Math.min(Float.NaN, Float.POSITIVE_INFINITY));
 }
}
A.输出NaN
B.打印输出Infinity
C.运行时异常，因为NaN不是有效的参数
D.运行时异常，因为Infinity不是有效的参数
答案：A
min()和max()方法的参数之一，如果是NaN值，则方法的返回值就为NaN</code></pre><h1 id="76-以下代码的执行结果是？"><a href="#76-以下代码的执行结果是？" class="headerlink" title="76.以下代码的执行结果是？"></a>76.以下代码的执行结果是？</h1><pre><code>public class Example{
  public static void main(String s[]){
   String str=”123”;
String str_=new String(“123”);
String  _str=”123”;
   System.out.println(str==_str);
System.out.println(str==str_);
} 
}

A.输出true true
B.输出false false
C.输出true false
D.输出false true
答案：C
字符串创建的时候可以使用常量池</code></pre><h1 id="77-public-class-Example"><a href="#77-public-class-Example" class="headerlink" title="77.public class Example {"></a>77.public class Example {</h1><pre><code> public static void main(String[] args) {
  Integer i = 100;
  Integer j = 100;
  System.out.println(i == j);
  i = 300;
  j = 300;
  System.out.println(i == j);
 }
}
A.输出true true
B.输出false false
C.输出true false
D.输出false true
答案：C
128以内的数进行自动包装时使用池操作</code></pre><h1 id="78-以下哪个不是基本类型的包装类？"><a href="#78-以下哪个不是基本类型的包装类？" class="headerlink" title="78.以下哪个不是基本类型的包装类？"></a>78.以下哪个不是基本类型的包装类？</h1><pre><code>A.Char
B.Integer
C.Boolean
D.float
答案：A</code></pre><h1 id="79-以下说法正确的是？"><a href="#79-以下说法正确的是？" class="headerlink" title="79.以下说法正确的是？"></a>79.以下说法正确的是？</h1><pre><code>A.Void类是Class类的子类
B.Float类是Double类的子类
C.Double类是Wrapper类的子类
D.Integer类是Number类的子类
答案：D</code></pre><h1 id="80-定义在Integer类上的哪些方法用于将一个Integer对象转换为一个基本数据int类型？"><a href="#80-定义在Integer类上的哪些方法用于将一个Integer对象转换为一个基本数据int类型？" class="headerlink" title="80.定义在Integer类上的哪些方法用于将一个Integer对象转换为一个基本数据int类型？"></a>80.定义在Integer类上的哪些方法用于将一个Integer对象转换为一个基本数据int类型？</h1><pre><code>A.valueOf（）
B.intValue（）
C.getInt（）
D.getInteger（）
答案：B</code></pre><h1 id="81-一下代码的执行结果是什么？"><a href="#81-一下代码的执行结果是什么？" class="headerlink" title="81.一下代码的执行结果是什么？"></a>81.一下代码的执行结果是什么？</h1><pre><code>public class Example {
 public static void main(String[] args) {
  String val = null;
  int x = Integer.parseInt(val);
  System.out.println(x);
 }
}
A.输出0
B.输出null
C.输出NumberFormatException异常
D.无内容输出
答案：C</code></pre><h1 id="82-由于Java中存在字符串对象池，因此采用下面方法创建的两个字符串变量，他们指向的是同一个字符串对象：String-str1-”asddsg”-String-str2-”asddsg”"><a href="#82-由于Java中存在字符串对象池，因此采用下面方法创建的两个字符串变量，他们指向的是同一个字符串对象：String-str1-”asddsg”-String-str2-”asddsg”" class="headerlink" title="82.由于Java中存在字符串对象池，因此采用下面方法创建的两个字符串变量，他们指向的是同一个字符串对象：String str1=”asddsg”;String str2=”asddsg”"></a>82.由于Java中存在字符串对象池，因此采用下面方法创建的两个字符串变量，他们指向的是同一个字符串对象：String str1=”asddsg”;String str2=”asddsg”</h1><pre><code>A.调用字符串上定义的改变字符串内容的方法，返回值都是一个新字符串，而原有字符串内容不变
B.调用replace（char oldChar,char newChar）方法时，当参数oldChar和newChar一致时，返回一个和源对象内容一致的新字符串
C.String的equals方法用于判定两个字符串内容是否一致
D.调用toUpperCase()和toLowerCase()方法，当为进行大小写转换时，返回源字符串对象
答案：B
调用replace（char oldChar,char newChar）方法时，当参数oldChar和newChar一致时，返回源字符串对象</code></pre><h1 id="83-以下说法错误的是？"><a href="#83-以下说法错误的是？" class="headerlink" title="83.以下说法错误的是？"></a>83.以下说法错误的是？</h1><pre><code>A.String中的append方法用于在源字符串后追加内容
B.StringBuffer中的append方法用于在源字符串后追加内容
C.StringBuffer是一个缓冲区，器内容可变
D.String中的concat方法用于字符串串联
答案：A
String中没有append方法</code></pre><h1 id="84-以下哪些有关通过子类来扩展String类功能的描述是正确的？"><a href="#84-以下哪些有关通过子类来扩展String类功能的描述是正确的？" class="headerlink" title="84.以下哪些有关通过子类来扩展String类功能的描述是正确的？"></a>84.以下哪些有关通过子类来扩展String类功能的描述是正确的？</h1><pre><code>A.无法子类化，因为String类是一个final类
B.可以子类化，通过覆盖String类中的方法实现功能扩展
C.无法子类化，因为String类是一个抽象类
D.可以子类化，但是只能覆盖Object类中声明的方法，因为String类中定义的其他方法否是final的
答案：A</code></pre><h1 id="85-嗲用以下哪个方法会导致字符串被改变？"><a href="#85-嗲用以下哪个方法会导致字符串被改变？" class="headerlink" title="85.嗲用以下哪个方法会导致字符串被改变？"></a>85.嗲用以下哪个方法会导致字符串被改变？</h1><pre><code>A.concat()
B.toUpperCase()
C.replace()
D.没有改变字符串的方法可以调用
答案：D</code></pre><h1 id="86-如何获取一个String类实例S包含的字符个数？"><a href="#86-如何获取一个String类实例S包含的字符个数？" class="headerlink" title="86.如何获取一个String类实例S包含的字符个数？"></a>86.如何获取一个String类实例S包含的字符个数？</h1><pre><code>A.s.size
B.s.length
C.s.size()
D.s.length()
答案：D</code></pre><h1 id="87-以下代码执行结果是？"><a href="#87-以下代码执行结果是？" class="headerlink" title="87.以下代码执行结果是？"></a>87.以下代码执行结果是？</h1><pre><code>public class Example {
 public static void main(String[] args) {
  System.out.println(&quot;string&quot;.endsWith(&quot;&quot;));
 }
}
A.输出true
B.输出false
C.编译失败
D.运行时输出异常信息
答案：A</code></pre><h1 id="88-有String-s-“Metallica”-请问以下哪个语句可以打印输出ica？"><a href="#88-有String-s-“Metallica”-请问以下哪个语句可以打印输出ica？" class="headerlink" title="88.有String s = “Metallica”;请问以下哪个语句可以打印输出ica？"></a>88.有String s = “Metallica”;请问以下哪个语句可以打印输出ica？</h1><pre><code>A.System.out.println(s.substring(7));
B.System.out.println(s.substring(6));
C.System.out.println(s.substring(6，8));
D.System.out.println(s.substring(7，9));
答案：B</code></pre><h1 id="89-以下那些关于String类的描述是正确的？"><a href="#89-以下那些关于String类的描述是正确的？" class="headerlink" title="89.以下那些关于String类的描述是正确的？"></a>89.以下那些关于String类的描述是正确的？</h1><pre><code>A.该类是一个final类
B.该类是一个public类
C.该类可以序列化
D.该类有一个一StringBuffer实例作为参数的构造器
答案：A、B、C、D</code></pre><h1 id="90-以下哪些是String类中定义的方法？"><a href="#90-以下哪些是String类中定义的方法？" class="headerlink" title="90.以下哪些是String类中定义的方法？"></a>90.以下哪些是String类中定义的方法？</h1><pre><code>A.length（）
B.toUpper()
C.toString()
D.equals()
答案：A、C、D</code></pre><h1 id="91-以下哪些关于封装类的描述是正确的？"><a href="#91-以下哪些关于封装类的描述是正确的？" class="headerlink" title="91.以下哪些关于封装类的描述是正确的？"></a>91.以下哪些关于封装类的描述是正确的？</h1><pre><code>A.封装类都是public类
B.封装类均可序列化
C.封装类均是final类
D.封装类都是java.lang.Number类的子类
答案：A、B、C</code></pre><h1 id="92-请问以下哪些方法是定义在Object类上的，请选择所有正确答案"><a href="#92-请问以下哪些方法是定义在Object类上的，请选择所有正确答案" class="headerlink" title="92.请问以下哪些方法是定义在Object类上的，请选择所有正确答案"></a>92.请问以下哪些方法是定义在Object类上的，请选择所有正确答案</h1><pre><code>A.toString()
B.equals(Object o)
C.println()
D.wait()
答案：A、B、D</code></pre><h1 id="93-请问以下哪些描述是正确的？请选择所有正确答案"><a href="#93-请问以下哪些描述是正确的？请选择所有正确答案" class="headerlink" title="93.请问以下哪些描述是正确的？请选择所有正确答案"></a>93.请问以下哪些描述是正确的？请选择所有正确答案</h1><pre><code>A.Class类是Object类的超类
B.Object类是一个final类
C.Class类可用于装载其他类
D.ClassLoader类可用于装载其他类
答案：C、D</code></pre><h1 id="94-给出以下代码，请问以下哪些定义在Math类上的方法可以使表达式结果为true"><a href="#94-给出以下代码，请问以下哪些定义在Math类上的方法可以使表达式结果为true" class="headerlink" title="94.给出以下代码，请问以下哪些定义在Math类上的方法可以使表达式结果为true?"></a>94.给出以下代码，请问以下哪些定义在Math类上的方法可以使表达式结果为true?</h1><pre><code>Method(-4.4) == -4
A.round()
B.trunc()
C.floor()
D.ceil()
答案：A、D</code></pre><h1 id="95-下面这条语句一共创建了多少个对象：String-s-”a”-”b”-”c”-”d”"><a href="#95-下面这条语句一共创建了多少个对象：String-s-”a”-”b”-”c”-”d”" class="headerlink" title="95.下面这条语句一共创建了多少个对象：String s=”a”+”b”+”c”+”d”;"></a>95.下面这条语句一共创建了多少个对象：String s=”a”+”b”+”c”+”d”;</h1><pre><code>一个字符串对象和一个指向这个对象的引用
对于如下代码：

Strings1 = &quot;a&quot;;

Strings2 = s1 + &quot;b&quot;;

Strings3 = &quot;a&quot; + &quot;b&quot;;

System.out.println(s2== &quot;ab&quot;);

System.out.println(s3== &quot;ab&quot;);
答案：
第一条语句打印的结果为false，第二条语句打印的结果为true，这说明javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。

题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串，所以，上面的代码应该只创建了一个String对象和一个指向该对象的饮用。写如下两行代码，

               String s = &quot;a&quot; +&quot;b&quot; + &quot;c&quot; + &quot;d&quot;;

               System.out.println(s ==&quot;abcd&quot;);  最终打印的结果应该为true。</code></pre><h1 id="96-以下代码的执行结果是？"><a href="#96-以下代码的执行结果是？" class="headerlink" title="96.以下代码的执行结果是？"></a>96.以下代码的执行结果是？</h1><pre><code>class ShadowClone implements Cloneable {

 private int a;
 private int[] b;

 @Override
 public Object clone() {
  ShadowClone sc = null;
  try {
   sc = (ShadowClone) super.clone();
  } catch (CloneNotSupportedException e) {
   e.printStackTrace();
  }
  return sc;
 }

 public int getA() {
  return a;
 }

 public void setA(int a) {
  this.a = a;
 }

 public int[] getB() {
  return b;
 }

 public void setB(int[] b) {
  this.b = b;
 }
}

public class Example {
 public static void main(String[] args) {
  ShadowClone c1 = new ShadowClone();
  c1.setA(100);
  c1.setB(new int[] { 1000 });
  System.out.println(&quot;克隆前c1:  a=&quot; + c1.getA() + &quot; b[0]=&quot; + c1.getB()[0]);
  ShadowClone c2 = (ShadowClone) c1.clone();
  c2.setA(50);
  int[] a = c2.getB();
  a[0] = 5;
  c2.setB(a);
  System.out.println(&quot;克隆后c1:  a=&quot; + c1.getA() + &quot; b[0]=&quot; + c1.getB()[0]);
  System.out.println(&quot;克隆后c2:  a=&quot; + c2.getA() + &quot; b[0]=&quot; + c2.getB()[0]);
 }
}

答案：
克隆前c1:  a=100 b[0]=1000
克隆后c1:  a=100 b[0]=5
克隆后c2:  a=50 b[0]=5

Java中Object类提供的克隆方法默认为浅克隆，因此克隆后的引用属性和原始对象中的引用属性引用了同一对象，对克隆对象中引用数据的变更就直接反映到原始对象中</code></pre><h1 id="97-以下代码的执行结果是？"><a href="#97-以下代码的执行结果是？" class="headerlink" title="97.以下代码的执行结果是？"></a>97.以下代码的执行结果是？</h1><pre><code>class DeepClone implements Cloneable {

 private int a;
 private int[] b;

 @Override
 public Object clone() {
  DeepClone sc = null;
  try {
   sc = (DeepClone) super.clone();
   int[] t = sc.getB();
   int[] b1 = new int[t.length];
   for (int i = 0; i &lt; b1.length; i++) {
    b1[i] = t[i];
   }
   sc.setB(b1);
  } catch (CloneNotSupportedException e) {
   e.printStackTrace();
  }
  return sc;
 }

 public int getA() {
  return a;
 }

 public void setA(int a) {
  this.a = a;
 }

 public int[] getB() {
  return b;
 }

 public void setB(int[] b) {
  this.b = b;
 }
}

public class Example {
 public static void main(String[] args) {
  DeepClone c1 = new DeepClone();
  c1.setA(100);
  c1.setB(new int[] { 1000 });
  System.out.println(&quot;克隆前c1:  a=&quot; + c1.getA() + &quot; b[0]=&quot; + c1.getB()[0]);
  DeepClone c2 = (DeepClone) c1.clone();
  c2.setA(50);
  int[] a = c2.getB();
  a[0] = 5;
  c2.setB(a);
  System.out.println(&quot;克隆后c1:  a=&quot; + c1.getA() + &quot; b[0]=&quot; + c1.getB()[0]);
  System.out.println(&quot;克隆后c2:  a=&quot; + c2.getA() + &quot; b[0]=&quot; + c2.getB()[0]);
 }
}

答案：
克隆前c1:  a=100 b[0]=1000
克隆后c1:  a=100 b[0]=1000
克隆后c2:  a=50 b[0]=5


自定义的深度克隆</code></pre><h1 id="98-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对"><a href="#98-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对" class="headerlink" title="98.两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对"></a>98.两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对</h1><pre><code>答案：

不对，有相同的hash code</code></pre><h1 id="99-覆盖equals-方法时需要注意的设计原则有哪些？"><a href="#99-覆盖equals-方法时需要注意的设计原则有哪些？" class="headerlink" title="99.覆盖equals()方法时需要注意的设计原则有哪些？"></a>99.覆盖equals()方法时需要注意的设计原则有哪些？</h1><pre><code>答案：

对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。
反射性：x.equals(x)必须返回是“true”。
类推性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。
一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。
任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。 </code></pre><h1 id="100-equals方法和-的区别"><a href="#100-equals方法和-的区别" class="headerlink" title="100.equals方法和==的区别"></a>100.equals方法和==的区别</h1><pre><code>答案：
1.基本数据类型，也称原始数据类型。byte,short,char,int,long,float,double,boolean
  他们之间的比较，应用双等号（==）,比较的是他们的值。
2.复合数据类型(类)
  当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地 址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。
  对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（==）进行比较的，所以比较后的结果跟双等号（==）的结果相同。 </code></pre><h1 id="101-String、StringBuffer、StringBuilder有什么区别？"><a href="#101-String、StringBuffer、StringBuilder有什么区别？" class="headerlink" title="101.String、StringBuffer、StringBuilder有什么区别？"></a>101.String、StringBuffer、StringBuilder有什么区别？</h1><pre><code>答案：
String类表示内容不可改变的字符串。
而StringBuffer类表示内容可以被修改的字符串。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。
另外，String实现了equals方法，new String(“abc”).equals(new String(“abc”)的结果为true,
而StringBuffer没有实现equals方法，所以，new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为false。
StringBuffer和StringBuilder类都表示内容可以被修改的字符串，StringBuilder是线程不安全的，运行效率高，如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用StringBuilder。
如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用StringBuffer。</code></pre>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode</title>
    <url>/2018/05/31/LeetCode/</url>
    <content><![CDATA[<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p>
<p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p>
<p>示例:</p>
<pre><code>给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]</code></pre><p>分析:</p>
<pre><code>思路一：暴力解法，两次for循环，遍历所有可能，这也是容易想到的方法，时间复杂度O(n^2),空间复杂度O(1); 
思路二：利用哈希表，每次存储target减去当前数的差值(key)，当前值的下标(value)，当再碰到这个值时，即找到了符合要求的值。时间复杂度O(n),空间复杂度O(n);</code></pre><p>代码:</p>
<p>1:</p>
<pre><code>//思路一暴力解法
public int[] twoSum(int[] nums, int target) {
        // write your code here
        int[] a = new int[2];
        for (int i = 0; i &lt; nums.length - 1; i++){

            // 注意j等于i + 1;若j = 1则循环顺序不对
            for (int j = i + 1; j &lt; nums.length; j++ ){
                if (nums[i] + nums[j] == target){

                    a[0] = i;
                    a[1] = j;
                    break;
                }
            }
        }
        return a;
    }</code></pre><p>2:         </p>
<pre><code>//思路二利用哈希表
public int[] twoSum(int[] nums, int target) {

        int[] a = new int[2];
        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();

        for (int i = 0; i &lt; nums.length; i++){

            if (map.containsKey(nums[i])){

                a[0] = map.get(nums[i]);
                a[1] = i;
                return a;
            }
            map.put(target - nums[i], i);
        }

        return a;
}</code></pre><h2 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h2><p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p>
<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>示例：</p>
<pre><code>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
输出：7 -&gt; 0 -&gt; 8
原因：342 + 465 = 807</code></pre><h3 id="结题思路"><a href="#结题思路" class="headerlink" title="结题思路"></a>结题思路</h3><p>方法: 初等数学</p>
<p>我们是有变量来跟踪进位,并从包含最低有效位的表头开始模拟逐位相加的过程.</p>
<p><img src="https://leetcode-cn.com/problems/add-two-numbers/Figures/2/2_add_two_numbers.svg" alt="示例图片">    </p>
<p>如图所示,对两数相加方法的可视化:342 + 465 = 807,每个节点都包含一个数字,并且数字按位逆序存储.</p>
<p>算法</p>
<p>就像你在纸上计算两个数字的和那样,我们首先从最低有效位也就是列表l1和l2的表头开始相加.由于每位数字都应当处于<br>0…9的范围内,我们计算两个数字的和时可能会出现”溢出”.例如:5+7 = 12.在这种情况下,我们会将当前位的数值设<br>置为2,并将进位carry = 1带入下一次迭代.进位carry必定是0或者1,这是因为两个数字相加(考虑到进位)可能出现的<br>的最大和为9+ 9+1=19   </p>
<p>伪代码如下:</p>
<ul>
<li>将x设为节点p的值.如果p已经到达l1的末尾,则将其设置为0.</li>
<li>将y设为节点q的值,如果q已经到达l2的末尾,则将其设置为0.</li>
<li>设定sum = x + y + carry.</li>
<li>更新进位的值,carry = sum/10.</li>
<li>创建一个数值为(sum mod 10) 的新节点,并将其设置为当前节点的下一个节点,然后将当前节点<br> 前进到下一个节点.</li>
<li>同时,将p和q前进到下一个节点.</li>
<li>检查carry = 1是否成立,如果成立,则向返回列表追加一个含有数字1的新节点.</li>
<li>返回哑节点的下一个节点.</li>
</ul>
<p>请注意我们使用哑节点来简化代码.如果没有哑节点,则必须编写额外的条件语句来初始化表头的值.</p>
<p>请特别注意以下的情况:</p>
<table>
<thead>
<tr>
<th align="left">测试用例</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">l1 = [0,1] l2 = [0,1,2]</td>
<td align="left">当一个列表比另一个列表长时</td>
</tr>
<tr>
<td align="left">l1 = [] l2 = [0,1]</td>
<td align="left">当一个列表为空时,即出现空列表</td>
</tr>
<tr>
<td align="left">l1 = [9,9] l2 = [1]</td>
<td align="left">求和运算最后可能出现额外的进位,这一点很容易被遗忘</td>
</tr>
</tbody></table>
<p>复杂度分析</p>
<ul>
<li><p>时间复杂度: O(max(m,n)),假设m和n分别表示l1和l2的长度,上面的算法最多重复max(m,n)次.</p>
</li>
<li><p>空间复杂度: O(max(m,n)),新列表的长度最多为max(m,n) + 1.</p>
</li>
</ul>
<p>拓展</p>
<p>如果链表中的数字不是按逆序存储的呢?例如:<br>(3-&gt;4-&gt;2) + (4-&gt;6-&gt;5) = 8-&gt;0-&gt;7 </p>
<h3 id="代码-java"><a href="#代码-java" class="headerlink" title="代码(java)"></a>代码(java)</h3><pre><code>/**
 * Definition for singly-linked list.
 * public class ListNode {
 *      int val;
 *      LsitNode next;
 *      ListNode (int x) { val = x;}
 * }     
 */
 class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);
        ListNode p = l1, q = l2, curr = dummyHead;
        int carry =0; //进位
        while (p != null || q != null) {
            int x = (p != null) ? p.val : 0;
            int y = (q != null) ? q.val : 0;
            int sum = x + y + carry;
            carry = sum/10;
            curr.next = new listNode(sum%10);
            curr = curr.next;
            if(p != null) p=p.next;
            if(q != null) q=q.next;
        }
        if(carry&gt;0) {
            curr.next = new ListNode(carry);
        }
        return dummyHead.next;
    }

 }</code></pre>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Learn Linux</title>
    <url>/2018/04/20/Learn-Linux/</url>
    <content><![CDATA[<h1 id="学习Linux问题与总结"><a href="#学习Linux问题与总结" class="headerlink" title="学习Linux问题与总结"></a>学习Linux问题与总结</h1><h2 id="1-如何打开Ubuntu命令行工具"><a href="#1-如何打开Ubuntu命令行工具" class="headerlink" title="1 如何打开Ubuntu命令行工具"></a>1 如何打开Ubuntu命令行工具</h2><ul>
<li><p>按快捷键,Ctrl+Alt+F2/F3/F4/F5/F6,后面的F2到6是或者的意思</p>
</li>
<li><p>然后会进入命令行的登录界面,这时候需要输入用户名和密码.</p>
</li>
<li><p>密码是不可见的,输入后直接回车即可</p>
</li>
</ul>
<h2 id="2-如何关闭Ubuntu命令行工具-即切换到桌面"><a href="#2-如何关闭Ubuntu命令行工具-即切换到桌面" class="headerlink" title="2 如何关闭Ubuntu命令行工具(即切换到桌面)"></a>2 如何关闭Ubuntu命令行工具(即切换到桌面)</h2><ul>
<li>按快捷键,Ctrl+Alt+F7</li>
</ul>
<h2 id="3-Ubuntu下查看IP"><a href="#3-Ubuntu下查看IP" class="headerlink" title="3 Ubuntu下查看IP"></a>3 Ubuntu下查看IP</h2><ul>
<li>ifconfig -a</li>
</ul>
<h2 id="4-使用locale查看系统当前编码"><a href="#4-使用locale查看系统当前编码" class="headerlink" title="4 使用locale查看系统当前编码"></a>4 使用locale查看系统当前编码</h2><h2 id="5-Ubuntu设置root用户初始密码"><a href="#5-Ubuntu设置root用户初始密码" class="headerlink" title="5 Ubuntu设置root用户初始密码"></a>5 Ubuntu设置root用户初始密码</h2><h3 id="安装ubuntu成功后-都是普通用户权限-并没有最高root权限"><a href="#安装ubuntu成功后-都是普通用户权限-并没有最高root权限" class="headerlink" title="安装ubuntu成功后,都是普通用户权限,并没有最高root权限"></a>安装ubuntu成功后,都是普通用户权限,并没有最高root权限</h3><pre><code>如果需要root权限的时候,通常都会在命令前面加上sudo.有时
候感觉很麻烦...

我们一般使用su命令来直接切换到root用户的,但是如果没有设
置root初始密码,就会抛出su : Authentication failure这样的
问题.所以我们只要给root用户设置一个初始密码就好了.

输入sudo passwd命令,输入一般用户密码并设定root用户密码.
设定root密码成功后,输入su命令,并输入刚才设定的root密码,
就可以切换成root 了.提示符$代表一般用户,提示符#代表root用户</code></pre><ul>
<li>总结 sudo passwd 设置初始root用户密码</li>
</ul>
<h2 id="6-查看所有用户组"><a href="#6-查看所有用户组" class="headerlink" title="6 查看所有用户组"></a>6 查看所有用户组</h2><pre><code>$cat /etc/group
ssl-cert:x:110:postgres
最前面一个字段ssl-cert是用户组名,最后一个字段postgres是用户名</code></pre><h2 id="7-查看所有用户"><a href="#7-查看所有用户" class="headerlink" title="7 查看所有用户"></a>7 查看所有用户</h2><pre><code>$sudo cat /etc/shadow
postgres:$6$m8anDHdE$FDY4j0CdAbgeLOM90EH1xCW/IMqHEZwM87sepyHHjUYccdmFOCVaFealGTd2zGBVfDV.AR9CWTlGz0Sw/JivL1:15910:0:99999:7:::  
postgres是用户名</code></pre><h2 id="8-远程连接Linux-Ubuntu配置SSH服务-端口22"><a href="#8-远程连接Linux-Ubuntu配置SSH服务-端口22" class="headerlink" title="8 远程连接Linux(Ubuntu配置SSH服务)端口22"></a>8 远程连接Linux(Ubuntu配置SSH服务)端口22</h2><pre><code>安装OpenSSH
Ubuntu缺省没有安装SSH Server,使用一下命令安装:

sudo apt-get install openssh-server openssh-client

不过Ubuntu缺省已经安装了ssh client.

配置完成后重启:

sudo /etc/init.d/ssh restart

windows客户端用putty连接命令shell模式</code></pre><h2 id="9-如何查看Linux系统版本信息"><a href="#9-如何查看Linux系统版本信息" class="headerlink" title="9 如何查看Linux系统版本信息"></a>9 如何查看Linux系统版本信息</h2><h3 id="查看Linux内核版本命令-两种方式"><a href="#查看Linux内核版本命令-两种方式" class="headerlink" title="查看Linux内核版本命令(两种方式)"></a>查看Linux内核版本命令(两种方式)</h3><ul>
<li><p>cat /proc/version </p>
</li>
<li><p>uname -a</p>
</li>
</ul>
<h3 id="查看Linux系统版本命令-3种方式"><a href="#查看Linux系统版本命令-3种方式" class="headerlink" title="查看Linux系统版本命令(3种方式)"></a>查看Linux系统版本命令(3种方式)</h3><ul>
<li><p>lsb_release -a </p>
<p>这个命令适用于所有的Linux发行版,包括ReHat SUSE Debian…等发行版</p>
</li>
<li><p>cat /etc/redhat-release,</p>
<p>这种方式只适合Redhat系的Linux</p>
</li>
<li><p>cat /etc/issue</p>
<p>这种方式适用于所有的Linux发行版</p>
</li>
</ul>
<h2 id="10-ubuntu-安装-上传下载工具lrzsz"><a href="#10-ubuntu-安装-上传下载工具lrzsz" class="headerlink" title="10 ubuntu 安装 上传下载工具lrzsz"></a>10 ubuntu 安装 上传下载工具lrzsz</h2><pre><code>apt-get install lrzsz y</code></pre><h2 id="11-Linux中运行-sh-Shell脚本-文件"><a href="#11-Linux中运行-sh-Shell脚本-文件" class="headerlink" title="11 Linux中运行.sh(Shell脚本)文件"></a>11 Linux中运行.sh(Shell脚本)文件</h2><pre><code>有两种方法:

1 直接./加文件名.sh,如运行hello.sh为./hello.sh[hello.sh必须有x权限]

2 直接sh加上文件名.sh,如运行hello.sh为sh hello.sh[hello.sh]可以没有x权限]

步骤

1 cd到.sh文件所在目录

2 给.sh文件添加x执行权限,已hello.sh文件为例
chmod u+x hello.sh

3 执行 ./hello.sh 或者 sh hello.sh

备注 绝对路径执行*.sh以hello.sh 为例

./home/test/shell/hello.sh ,可以这样运行时因为当前登录用户是root,当前路径
是在/下,.代表当前路径.

/home/test/shll/hello.sh,此路径为真实绝对路径,但此方法运行的条件是该用户对
hello.sh拥有执行权限,即已执行chmod u+x hello.sh

sh/home/test/shell/hello.sh,用sh命令执行shell脚本不需要该用户拥有hello.sh的执行
权限即可执行.</code></pre><h2 id="12-zip-或unzip的安装和使用"><a href="#12-zip-或unzip的安装和使用" class="headerlink" title="12 zip 或unzip的安装和使用"></a>12 zip 或unzip的安装和使用</h2><pre><code>Linux系统没有自带的压缩解压缩工具;需要我们自己安装;当用到zip或者unzip如果没有安装
就会出现unzip:Command Not Found 或 zip:Command Not Found;

1 apt-get安装:
apt-get install zip

2 yum安装
yum install -y unzip zip</code></pre><h2 id="13-虚拟机中CentOS无法上网-connect-network-is-unreachable"><a href="#13-虚拟机中CentOS无法上网-connect-network-is-unreachable" class="headerlink" title="13 虚拟机中CentOS无法上网(connect:network is unreachable)"></a>13 虚拟机中CentOS无法上网(connect:network is unreachable)</h2><pre><code>表现:ping时提示connet network is unreachable

原因: ifconfig发现网卡没有分配IP地址,考虑是DHCP的问题.

临时解决方案: sudo dhclient,发现可以上网,重启又没有IP了,

一劳永逸解决方案: 修改etc目录下网卡配置信息
vim /etc/sysconfig/network-scripts/ifcfg-[网络设备名]
发现最后一行的ONBOOT选项竟然是no,将其改为yes,然后就正常了.</code></pre><h2 id="14-重启系统-reboot-init-6"><a href="#14-重启系统-reboot-init-6" class="headerlink" title="14 重启系统 reboot init 6"></a>14 重启系统 reboot init 6</h2><h2 id="15-关机"><a href="#15-关机" class="headerlink" title="15 关机"></a>15 关机</h2><pre><code>halt 立刻关机

poweroff 立刻关机

shutdown -h now 立刻关机(root用户使用)

shutdown -h 10 10分钟后自动关机

如果是通过shutdown命令设置关机的话,可以用shutdown -c命令取消重启

推荐使用shutdown命令</code></pre><h2 id="16-centOS安装lrzsz"><a href="#16-centOS安装lrzsz" class="headerlink" title="16 centOS安装lrzsz"></a>16 centOS安装lrzsz</h2><pre><code>yum install lrzsz</code></pre>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下tar.gz,tar,bz2,zip等压缩与解压缩总结</title>
    <url>/2018/04/28/Linux%E4%B8%8Btar-gz-tar-bz2-zip%E7%AD%89%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="tar命令基本用法"><a href="#tar命令基本用法" class="headerlink" title="tar命令基本用法:"></a>tar命令基本用法:</h2><p>tar命令的选项有很多(用man tar可以查看到),常用的就下面几个</p>
<ul>
<li><p>tar -cf all.tar *.jpg</p>
<p>  这条命令是将所有.jpg的文件打成一个名为all.tar的包.-c是表示</p>
<p>  生成新的包,-f指定包的文件名.</p>
</li>
<li><p>tar -rf all.tar *.gif</p>
<p>  这条命令是将所有.gif的文件增加到all.tar的包里面去.-r是表示增</p>
<p>  加文件的意思.</p>
</li>
<li><p>tar -uf all.tar logo.gif</p>
<p>  更新原来all.tar中logo.gif文件,-u是表示更新文件的意思</p>
</li>
<li><p>tar -tf all.tar    </p>
<p>  列出all.tar中的所有文件,-u表示更新文件的意思</p>
</li>
<li><p>tar -xf all.tar    </p>
<p>  解出all.tar中的所有文件,-x是解开文件的意思</p>
</li>
</ul>
<p>以上就是tar的最基本的用法,为了方便用户在打包解包的同时可以压缩或解压<br>文件,tar提供了一种特殊的功能.就是tar可以在打包或解包的同时调用其他的<br>压缩程序,比如调用gzip bzip2等.</p>
<h2 id="1-tar调用gzip"><a href="#1-tar调用gzip" class="headerlink" title="1)tar调用gzip"></a>1)tar调用gzip</h2><p>gzip是GNU组织开发的一个压缩程序,.gz结尾的文件是gzip压缩的结果.与gzip相对</p>
<p>的解压程序是gunzip.tar中使用-z这个参数来调用gzip</p>
<ul>
<li><h1 id="tar-czf-all-tar-gz-jpg"><a href="#tar-czf-all-tar-gz-jpg" class="headerlink" title="tar -czf all.tar.gz *.jpg"></a>tar -czf all.tar.gz *.jpg</h1></li>
</ul>
<p>将所有.jpg的文件打成一个tar包,并将其用gzip压缩,生成一个gzip压缩过的包,<br>包名为all.tar.gz</p>
<ul>
<li><h1 id="tar-xzf-all-tar-gz"><a href="#tar-xzf-all-tar-gz" class="headerlink" title="tar -xzf all.tar.gz"></a>tar -xzf all.tar.gz</h1></li>
</ul>
<p>解压包</p>
<h2 id="2-tar调用bzip2"><a href="#2-tar调用bzip2" class="headerlink" title="2) tar调用bzip2"></a>2) tar调用bzip2</h2><p>bzip2是一个压缩能力更强的压缩程序,.bz2结尾的文件是bzip压缩的结果.</p>
<p>与bzip相对的解压程序是bunzip2.tar中使用-j这个参数来调用gzip.</p>
<ul>
<li><h1 id="tar-cjf-all-tar-bz2-jpg"><a href="#tar-cjf-all-tar-bz2-jpg" class="headerlink" title="tar -cjf all.tar.bz2 *.jpg"></a>tar -cjf all.tar.bz2 *.jpg</h1></li>
</ul>
<p>这条命令是将所有.jpg的文件打成一个tar包,并且将其用bzip2压缩,生成一个<br>bzip2相对的压缩</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>tar</tag>
        <tag>压缩</tag>
        <tag>解压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2018/07/27/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="日常操作命令"><a href="#日常操作命令" class="headerlink" title="日常操作命令"></a>日常操作命令</h1><h2 id="查看当前所在的工作目录的全路径pwd"><a href="#查看当前所在的工作目录的全路径pwd" class="headerlink" title="查看当前所在的工作目录的全路径pwd"></a>查看当前所在的工作目录的全路径pwd</h2><pre><code>[root@localhost ~]# pwd
/root</code></pre><h2 id="查看当前系统的时间date"><a href="#查看当前系统的时间date" class="headerlink" title="查看当前系统的时间date"></a>查看当前系统的时间date</h2><pre><code>[root@localhost ~]# date +%Y-%m-%d

date +%Y-%m-%d --date=&quot;-1 day&quot; #加减也可以 month | year

date -s &quot;2016-07-28 16:12:00&quot; ## 修改时间</code></pre><h2 id="查看有谁在线-哪些人登陆了服务器"><a href="#查看有谁在线-哪些人登陆了服务器" class="headerlink" title="查看有谁在线(哪些人登陆了服务器)"></a>查看有谁在线(哪些人登陆了服务器)</h2><pre><code>who 查看当前在线

last 查看最近的登陆历史记录</code></pre><h2 id="关机-重启"><a href="#关机-重启" class="headerlink" title="关机/重启"></a>关机/重启</h2><pre><code>关机(必须用root用户)
shutdown -h now ## 立刻关机
shutdown -h +10 ## 10分钟以后关机
shutdown -h 12:00:00 ## 12点整的时候关机
halt #  等于立刻关机

重启
shutdown -r now
reboot # 等于立刻重启</code></pre><h2 id="清屏"><a href="#清屏" class="headerlink" title="清屏"></a>清屏</h2><pre><code>clear ## 或者用快捷键 Ctrl + 1</code></pre><h2 id="退出当前进程"><a href="#退出当前进程" class="headerlink" title="退出当前进程"></a>退出当前进程</h2><pre><code>Ctrl + c  ##有些程序也可以用q键退出</code></pre><h2 id="挂起当前进程"><a href="#挂起当前进程" class="headerlink" title="挂起当前进程"></a>挂起当前进程</h2><pre><code>Ctrl + z ## 进程会挂起到后台
bg jobid ## 进程在后台继续执行
fg jobid ## 让进程回到前台</code></pre><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><pre><code>相当于Java中System.out.println(userName)
a=&quot;test&quot;
echo a ## a
echo $a ## test</code></pre><h1 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h1><h2 id="查看目录信息"><a href="#查看目录信息" class="headerlink" title="查看目录信息"></a>查看目录信息</h2><pre><code>ls / ## 查看根目录下的子节点(文件夹和文件)信息
ls -al ## -a是显示隐藏文件 -l是以更详细的列表形式显示
ls -l ## 有一个别名: ll 可以直接使用ll&lt;是两个L&gt;</code></pre><h2 id="切换工作目录"><a href="#切换工作目录" class="headerlink" title="切换工作目录"></a>切换工作目录</h2><pre><code>cd ~ ##切换都用户主目录
cd - ##切换上次所在的目录
cd 什么都不带,则回到用户的主目录</code></pre><h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><pre><code>mkdir aaa ## 这是相对路径的写法
mkdir /data ## 这是绝对路径的写法
mkdir -p aaa/bbb/ccc ## 级联创建目录</code></pre><h2 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h2><pre><code>rmdir aaa ##可以删除空目录
rm -r aaa ## 可以把aaa整个文件夹及其中的所有子节点全部删除
rm -rf aaa ## 强制删除aaa</code></pre><h2 id="修改文件夹名称"><a href="#修改文件夹名称" class="headerlink" title="修改文件夹名称"></a>修改文件夹名称</h2><pre><code>mv aaa boy
mv本质上是移动
mv install.log aaa/ 将当前目录下的install.log移动到aaa文件夹中去

rename 可以用来批量更改文件名
[root@localhost aaa]# ll
total 0
-rw-r--r--. 1 root root 0 Jul 28 17:33 1.txt
-rw-r--r--. 1 root root 0 Jul 28 17:33 2.txt
-rw-r--r--. 1 root root 0 Jul 28 17:33 3.txt
[root@localhost aaa]# rename .txt .txt.bak *
[root@localhost aaa]# ll
total 0
-rw-r--r--. 1 root root 0 Jul 28 17:33 1.txt.bak
-rw-r--r--. 1 root root 0 Jul 28 17:33 2.txt.bak
-rw-r--r--. 1 root root 0 Jul 28 17:33 3.txt.bak</code></pre>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux简介</title>
    <url>/2018/04/24/Linux%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<pre><code>Linux内核最初是由芬兰人李纳斯.托瓦兹(Linux Torvalds)在赫尔辛基上大学时出于个人爱好而编写的.
Linux是一套免费使用和自由传播的类Unix操作系统.是一个基于POSIX和UNIX的多用户 多任务 支持多线
程和多CPU的操作系统.

Linux能运行主要的UNIX工具软件 应用程序和网络协议.它支持32位和64位硬件.Linux继承了Unix以网络
为核心的设计思想,是一个性能稳定的多用户网络操作系统.</code></pre><h2 id="Linux的发行版本"><a href="#Linux的发行版本" class="headerlink" title="Linux的发行版本"></a>Linux的发行版本</h2><pre><code>Linux的发行版本简单说就是讲Linux内核与应用软件做一个打包.
目前市面上比较知名的发行版有:</code></pre><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><h3 id="ReaHat"><a href="#ReaHat" class="headerlink" title="ReaHat"></a>ReaHat</h3><h3 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h3><h3 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a>Debian</h3><h3 id="Fefora"><a href="#Fefora" class="headerlink" title="Fefora"></a>Fefora</h3><h3 id="SuSE"><a href="#SuSE" class="headerlink" title="SuSE"></a>SuSE</h3><h3 id="OpenSUSE"><a href="#OpenSUSE" class="headerlink" title="OpenSUSE"></a>OpenSUSE</h3><h3 id="Arch-Linux"><a href="#Arch-Linux" class="headerlink" title="Arch Linux"></a>Arch Linux</h3><h3 id="SolusOS"><a href="#SolusOS" class="headerlink" title="SolusOS"></a>SolusOS</h3><h2 id="Linux-系统启动过程"><a href="#Linux-系统启动过程" class="headerlink" title="Linux 系统启动过程"></a>Linux 系统启动过程</h2><p>Linux系统的启动的启动过程分为5个阶段</p>
<ul>
<li><p>内核的引导</p>
</li>
<li><p>运行init</p>
</li>
<li><p>系统初始化</p>
</li>
<li><p>建立终端</p>
</li>
<li><p>用户登录系统</p>
<p>  init 程序的类型</p>
<ul>
<li><p>SysV:init,CentOS5之前,配置文件: /etc/initab.</p>
</li>
<li><p>Upstart:init,CentOS6,配置文件: /etc/inittab,/etc/init/*.conf.</p>
</li>
<li><p>Systemd: systemd,CenOS 7配置文件: /user/lib/systemd/system  /etc/systemd/system</p>
</li>
</ul>
</li>
</ul>
<h2 id="内核引导"><a href="#内核引导" class="headerlink" title="内核引导"></a>内核引导</h2><p>当计算机打开电源后,首先是BIOS开机自检,按照BIOS中设置的启动设备(通常是硬盘)来启动.<br>操作系统接管硬件以后,首先读入/boot目录下的内核文件</p>
<p>操作系统 —–&gt; boot —&gt;</p>
<h2 id="运行init"><a href="#运行init" class="headerlink" title="运行init"></a>运行init</h2><p>init进程是系统所有进程的起点,你可以把它比拟成系统所有进程的老祖宗,没有这个进程,系统<br>中任何进程都不会启动.<br>init程序首先需要读取配置文件 /etc/inittab.</p>
<p>操作系统 —–&gt; boot —&gt; init进程 —&gt;运行级别</p>
<p>Linux系统有七个运行级别</p>
<ul>
<li><p>0 : 系统停机状态,系统默认运行级别不能设为0,否则不能正常启动</p>
</li>
<li><p>1 : 单用户工作状态,root权限,用于系统维护,禁止远程登录</p>
</li>
<li><p>2 : 多用户状态(没有NFS)</p>
</li>
<li><p>3 : 完全的多用户状态,登录后进入控制台命令行模式</p>
</li>
<li><p>4 : 系统未使用,保留</p>
</li>
<li><p>5 : X11控制台,登录后进入图形GUI模式</p>
</li>
<li><p>6 : 系统正常关闭并重启,默认运行级别不能设为6,否则不能正常启动</p>
</li>
</ul>
<h2 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h2><p>在init的配置文件中有这么一行: si:sysinit:/etc/rc.d/rc.sysint 它调用执行了</p>
<p>/etc/rc.d/rc.sysinit 它调用执行了/etc/rc.d/rc.sysinit,而rc.sysinit是一个bash</p>
<p>shell 的脚本 ,它主要是完成一些系统初始化的工作,rc.sysinit是每一个运行级别都</p>
<p>要首先运行的重要脚本.</p>
<p>它主要完成的工作有:激活交换区,检查磁盘,加载硬件模块以及其他一些需要优先执行</p>
<p>任务.</p>
<p>15:5:wait:/etc/rc.d/rc 5</p>
<p>这一行表示以5为参数运行/etc/rc.d/rc, /etc/rc.d/rc是一个shell脚本,它接收5作为参数</p>
<p>,去执行/etc/rc.d/rc5.d/目录下的所有的rc启用脚本,/etc/rc.d/rc5.d/目录中的这些启动</p>
<p>脚本实际上都是一些连接文件,而不是真正的rc启动脚本,真正的rc启动脚本实际上都是放在</p>
<p>/etc/rc.d/init.d/目录下</p>
<p>而这些rc启动脚本有着类似的用法,它们一般能接受start stop restart status等参数.</p>
<p>/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的连接文件,用于以S开头的启动脚本</p>
<p>,将以start参数来运行. 而如果发现存在相应的脚本也存在K打头的连接,而且已经处于运</p>
<p>行状态了(以/var/lock/subsys/下的文件为标志),则将首先以stop为参数停止这些已经启动</p>
<p>了的守护进程,然后再重新运行.</p>
<p>这样做是为了保证当init改变运行级别时,所有相关的守护进程将重启.</p>
<p>至于在每个运行级别中将运行哪些守护进程,用户可以通过chkconfig或setup中的</p>
<p>“System Services”来自行设定.</p>
<p>操作系统 —&gt; /boot —&gt; init进程 —&gt; 运行级别 —&gt; /etc/init.d</p>
<h2 id="建立终端"><a href="#建立终端" class="headerlink" title="建立终端"></a>建立终端</h2><p>rc执行完毕后,返回init.这时基本系统环境已经设置好了,各种守护进程也已经启动了.</p>
<p>init接下来会打开6个终端,以便用户登录系统.在inittab中的以下6行就是定义了6个终</p>
<p>端:</p>
<p>1:2345:respawn:/sbin/mingetty tty1</p>
<p>2:2345:respawn:/sbin/mingetty tty2</p>
<p>3:2345:respawn:/sbin/mingetty tty3</p>
<p>4:2345:respawn:/sbin/mingetty tty4</p>
<p>5:2345:respawn:/sbin/mingetty tty5</p>
<p>6:2345:respawn:/sbin/mingetty tty6</p>
<p>从上面可以看出在2 3 4 5的运行级别中都将以 respawn 方式运行mingetty程序能打开终端</p>
<p>设置模式.同时它会显示一个文本登录界面,这个界面就是我们经常看到的登录界面,在这个等</p>
<p>录界面中会提示用户输入用户名,而用户输入的用户名将作为参数传给login程序来验证用户的</p>
<p>身份</p>
<h2 id="用户登录系统"><a href="#用户登录系统" class="headerlink" title="用户登录系统"></a>用户登录系统</h2><p>一般来说,用户的登录方式有三种:</p>
<ul>
<li><p>1 命令行登录</p>
</li>
<li><p>2 ssh登录</p>
</li>
<li><p>3 图形界面登录</p>
</li>
</ul>
<p>操作系统 –&gt; /boot –&gt; init进程 –&gt; 运行级别 –&gt; /etc/init.d –&gt; 用户登录</p>
<p>对于运行级别为5的图形方式用户来说,他们的登录是通过一个图形化的登录界面.登录</p>
<p>成功后可以直接进入 KDE 或 Gnome 等窗口管理器 </p>
<p>而本文主要讲的是文本登录:当我们看到mingetty的登录界面时,我们就可以输入用户名</p>
<p>和密码来登录系统了.</p>
<p>Linux的账号验证程序是login,login会接收mingetty传来的用户名作为用户名参数.</p>
<p>然后login会对用户名进行分析:如果用户名不是root,且存在/etc/nologin文件,login</p>
<p>将输出nologin文件的内容,然后退出.</p>
<p>这通常用来系统维护时防止非root用户登录.只有/etc/securetty中登记了的终端才允许</p>
<p>root用户登录,如果不存在这个文件,则root用户可以在任何终端上登录.</p>
<p>/etc/usetty文件用于对用户作出附加访问限制,如果不存在这个文件,则没有其他限制</p>
<h2 id="图形模式与文字模式的切换方式"><a href="#图形模式与文字模式的切换方式" class="headerlink" title="图形模式与文字模式的切换方式"></a>图形模式与文字模式的切换方式</h2><p>Linux预设提供了六个命令 窗口终端机让我们来登录.</p>
<p>默认我们登录的就是第一个窗口,也就是tty1,这六个窗口分别为 tt1,tt2,tt3…tt6,<br>你可以按下</p>
<p>Ctrl + Alt + F1 ~ F6</p>
<p>来切换它们</p>
<p>如果你安装了图形界面,默认情况下是进入图形界面的,此时你就可以按Ctrl+Alt+F1~F6来<br>进入其中一个命令窗口界面.当你进入命令窗口界面后再返回图形界面只要按下</p>
<p>Ctrl + Alt + F7就回来了</p>
<p>如果你用的vmware虚拟机,命令窗口切换的快捷键位Alt+Space+F1~F6.如果你在图形界面下</p>
<p>请按Alt+Shift+Ctrl+F1~F6切换至命令窗口.</p>
<p>操作系统 –&gt; /boot –&gt; init进程 –&gt; 运行级别 –&gt; /etc/init.d<br>                                                        |<br>                                                        |<br>                                       login shell &lt;–用户登录</p>
<h2 id="Linux-关机"><a href="#Linux-关机" class="headerlink" title="Linux 关机"></a>Linux 关机</h2><p>在Linux领域内大多用再服务器上,很少遇到关机的操作,毕竟服务器上跑一个服务时永无止境的,<br>除非特殊情况下,不得已才会关机.</p>
<p>正确的关机流程为 : sync &gt; shutdown &gt; reboot &gt; halt</p>
<p>关机指令为 : shutdown,你可以man shutdown来看一下邦之文档.</p>
<ul>
<li><p>sync 将数据由内存同步到硬盘中</p>
</li>
<li><p>shutdown 关机指令,你可以man shutdown来看一文档</p>
</li>
<li><p>shutdown -h 10  10分钟后关机</p>
</li>
<li><p>shutdown -h now 立马关机</p>
</li>
<li><p>shutdown -h 20:25 系统会在今天20:25关机</p>
</li>
<li><p>shutdown -h +10 十分钟后关机</p>
</li>
<li><p>shutdown -r now 立马重启</p>
</li>
<li><p>shutdown -r +10 十分钟后重启</p>
</li>
<li><p>reboot 重启,等同于 shutdown -r now</p>
</li>
<li><p>halt 关闭系统,等同于 shutdown -h now 和 poweroff</p>
</li>
</ul>
<p>最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。<br>关机的命令有 shutdown –h now halt poweroff 和 init 0 , 重启系统的命令有 shutdown –r now reboot init 6。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac中node卸载与安装</title>
    <url>/2019/08/23/Mac%E4%B8%ADnode%E5%8D%B8%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>在终端依次输入以下命令</p>
<pre><code>sudo npm uninstall npm -g

 sudo rm -rf /usr/local/lib/node /usr/local/lib/node_modules /var/db/receipts/org.nodejs.*

 sudo rm -rf /usr/local/include/node /Users/$USER/.npm

 sudo rm /usr/local/bin/node

 sudo rm /usr/local/share/man/man1/node.1

 sudo rm /usr/local/lib/dtrace/node.d</code></pre><h2 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h2><pre><code>node -v  //not found

npm -v //not found</code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>brew search node
brew install node</code></pre><h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><pre><code>Error: The `brew link` step did not complete successfully
The formula built, but is not symlinked into /usr/local
Could not symlink share/doc/node/lldb_commands.py
Target /usr/local/share/doc/node/lldb_commands.py
already exists. You may want to remove it:
  rm &apos;/usr/local/share/doc/node/lldb_commands.py&apos;

To force the link and overwrite all conflicting files:
  brew link --overwrite node

To list all files that would be deleted:
  brew link --overwrite --dry-run node</code></pre><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><pre><code>rm &apos;/usr/local/share/doc/node/lldb_commands.py&apos;

brew link --overwrite node</code></pre>]]></content>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
        <tag>brew</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac配置多个Java版本</title>
    <url>/2019/08/28/Mac%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAJava%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="一-安装最新版的Java"><a href="#一-安装最新版的Java" class="headerlink" title="一. 安装最新版的Java"></a>一. 安装最新版的Java</h2><pre><code># 如何没有安装 brew cask。请执行    $ brew tap caskroom/versions
$ brew cask install java</code></pre><h2 id="二-安装其他版本的Java"><a href="#二-安装其他版本的Java" class="headerlink" title="二.安装其他版本的Java"></a>二.安装其他版本的Java</h2><pre><code>如果你需要安装其他的jdk(JDK 7 或者 JDK 6)，可以使用homebrew-cask-versions：
$ brew search java
$ brew cask install java6      # 使用cask安装其他的工具</code></pre><h2 id="三-查看本地安装的Java-Home"><a href="#三-查看本地安装的Java-Home" class="headerlink" title="三.查看本地安装的Java Home"></a>三.查看本地安装的Java Home</h2><pre><code>$ /usr/libexec/java_home -V #查看本地安装的java版本</code></pre><h2 id="四-切换java版本【手动修改环境变量】"><a href="#四-切换java版本【手动修改环境变量】" class="headerlink" title="四.切换java版本【手动修改环境变量】"></a>四.切换java版本【手动修改环境变量】</h2><pre><code>那问题来了，当你运行java或者 Java 程序时使用的是哪个 JDK 呢？在 OS X 下，java也就是/usr/bin/java在默认情况下指向的是已经安装的最新版本。但是你可以设置环境变量JAVA_HOME来更改其指向：

# 查看当前的java版本
$ java -version          
java version &quot;1.8.0_60&quot;
Java(TM) SE Runtime Environment (build 1.8.0_60-b27)
Java HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode)

# 切换版本，可切换为第三步的本地java home中的任意一个。
$ export JAVA_HOME=/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home java -version  
java version &quot;1.6.0_65&quot;
Java(TM) SE Runtime Environment (build 1.6.0_65-b14-466.1-11M4716)
Java HotSpot(TM) 64-Bit Server VM (build 20.65-b04-466.1, mixed mode)</code></pre><h2 id="五-配置命令自动切换"><a href="#五-配置命令自动切换" class="headerlink" title="五.配置命令自动切换"></a>五.配置命令自动切换</h2><p>修改系统环境变量：</p>
<p>在<del>/.bash_profile（如果是Zsh，修改</del>/.zshrc）文件中添加如下内容：</p>
<pre><code># JDK 6  
export JAVA_6_HOME=&quot;/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home&quot;
# JDK 8
export JAVA_8_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home&quot;

export JAVA_HOME=$JAVA_8_HOME #默认JDK 8

#alias命令动态切换JDK版本  
alias jdk6=&quot;export JAVA_HOME=$JAVA_6_HOME&quot;    
alias jdk8=&quot;export JAVA_HOME=$JAVA_8_HOME&quot;  </code></pre><p>更新配置：</p>
<pre><code>$ source ~/.bash_profile #Zsh应改为 source ~/.zshrc</code></pre><p>切换java版本：</p>
<pre><code>$ jdk6    #使用jdk6
$ java -version 
    java version &quot;1.6.0_65&quot;
    Java(TM) SE Runtime Environment (build 1.6.0_65-b14-468)
    Java HotSpot(TM) 64-Bit Server VM (build 20.65-b04-468, mixed mode)

$ jdk8    #使用jdk8
$ java -version 
    java version &quot;1.8.0_101&quot;
    Java(TM) SE Runtime Environment (build 1.8.0_101-b13)
    Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)

说明：Mac系统的环境变量，加载顺序为：
/etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc</code></pre><p><a href="https://segmentfault.com/a/1190000013131276" target="_blank" rel="noopener">参考1</a><br><a href="https://www.kancloud.cn/kancloud/ocds-guide-to-setting-up-mac" target="_blank" rel="noopener">参考2</a></p>
]]></content>
      <tags>
        <tag>java jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 下locate命令使用问题WARNING: The locate database (/var/db/locate.database) does not exist</title>
    <url>/2019/09/11/Mac-%E4%B8%8Blocate%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98WARNING-The-locate-database-var-db-locate-database-does-not-exist/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><img src="locate.png" alt=""></p>
<p>根据提示使用 </p>
<p>sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.locate.plist<br> 并没有生效。</p>
<p>需要执行</p>
<p>sudo /usr/libexec/locate.updatedb 进行库更新。</p>
<p><a href="https://www.cnblogs.com/b-ruce/p/5911048.html" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title>Lombok 看这篇就够了  </title>
    <url>/2019/09/12/Lombok-%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/</url>
    <content><![CDATA[<h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p><a href="https://projectlombok.org" target="_blank" rel="noopener">官网</a><br>官网解释:</p>
<p>Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.<br>Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.</p>
<h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>减少代码量,省去写geter,setter等</p>
<h1 id="when"><a href="#when" class="headerlink" title="when"></a>when</h1><h2 id="添加下依赖"><a href="#添加下依赖" class="headerlink" title="添加下依赖:"></a>添加下依赖:</h2><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;version&gt;1.16.8&lt;/version&gt;
&lt;/dependency&gt;</code></pre><p>那么Lombok是做什么的呢？其实很简单，一个最简单的例子就是它能够实现通过添加注解，能够自动生成一些方法。比如这样的类:</p>
<pre><code>@Getter
class Test{
    private String value;
}</code></pre><p>我们用Lombok提供的@Getter来注解这个类，这个类在编译的时候就会变成:</p>
<pre><code>class Test{
    private String value;
    public String getValue(){
        return this.value;
    }
}</code></pre><p>当然Lombok也提供了很多其他的注解，这只是其中一个最典型的例子。其他的用法网上的资料已经很多了，这里就不啰嗦。<br>看上去是很方便的一个功能，尤其是在很多项目里有很多bean，每次都要手写或自动生成setter getter方法，搞得代码很长而且没有啥意义，因此这个对简化代码的强迫症们还是很有吸引力的。<br>但是，我们发现这个包跟一般的包有很大区别，绝大多数java包都工作在运行时，比如spring提供的那种注解，通过在运行时用反射来实现业务逻辑。Lombok这个东西工作却在编译期，在运行时是无法通过反射获取到这个注解的。<br>而且由于他相当于是在编译期对代码进行了修改，因此从直观上看，源代码甚至是语法有问题的。<br>一个更直接的体现就是，普通的包在引用之后一般的IDE都能够自动识别语法，但是Lombok的这些注解，一般的IDE都无法自动识别，比如我们上面的Test类，如果我们在其他地方这么调用了一下:</p>
<pre><code>Test test=new Test();
test.getValue();</code></pre><p>IDE的自动语法检查就会报错，说找不到这个getValue方法。因此如果要使用Lombok的话还需要配合安装相应的插件，防止IDE的自动检查报错。<br>因此，可以说这个东西的设计初衷比较美好，但是用起来比较麻烦，而且破坏了代码的完整性，很多项目组(包括我自己)都不高兴用。但是他的实现原理却还是比较好玩的，随便搜了搜发现网上最多也只提到了他修改了抽象语法树，虽说从感性上可以理解，但是还是想自己手敲一敲真正去实现一下。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>翻了翻现有的资料，再加上自己的一些猜想，Lombok的基本流程应该基本是这样：</p>
<ul>
<li>定义编译期的注解</li>
<li>利用JSR269 api(Pluggable Annotation Processing API )创建编译期的注解处理器</li>
<li>利用tools.jar的javac api处理AST(抽象语法树)</li>
<li>将功能注册进jar包</li>
</ul>
<h2 id="手撸Getter"><a href="#手撸Getter" class="headerlink" title="手撸Getter"></a>手撸Getter</h2><p>由于比较习惯用maven，我这里就用maven构建一下项目，修改下当前的pom.xml文件如下：</p>
<pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;com.mythsman.test&lt;/groupId&gt;
    &lt;artifactId&gt;getter&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;name&gt;test&lt;/name&gt;
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.sun&lt;/groupId&gt;
            &lt;artifactId&gt;tools&lt;/artifactId&gt;
            &lt;version&gt;1.8&lt;/version&gt;
            &lt;scope&gt;system&lt;/scope&gt;
            &lt;systemPath&gt;${java.home}/../lib/tools.jar&lt;/systemPath&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.1&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;</code></pre><p>主要定义了下项目名，除了默认依赖的junit之外(其实并没有用)，这里添加了tools.jar包。这个包实在jdk的lib下面，因此scope是system，由于${java.home}变量表示的是jre的位置，因此还要根据这个位置找到实际的tools.jar的路径并写在systemPath里。<br>由于防止在写代码的时候用到java8的一些语法，这里配置了下编译插件使其支持java8。</p>
<h3 id="创建Getter注解"><a href="#创建Getter注解" class="headerlink" title="创建Getter注解"></a>创建Getter注解</h3><p>定义注解Getter.java:</p>
<pre><code>package com.mythsman.test;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.SOURCE)
public @interface Getter {
}</code></pre><p>这里的Target我选择了ElementType.TYPE表示是对类的注解，Retention选择了RententionPolicy.SOURCE，表示这个注解只在编译期起作用，在运行时将不存在。这个比较简单，稍微复杂点的是对这个注解的处理机制。像spring那种注解是通过反射来获得注解对应的元素并实现业务逻辑，但是我们显然不希望在使用Lombok这种功能的时候还要编写其他的调用代码，况且用反射也获取不到编译期才存在的注解。<br>幸运的是Java早已支持了JSR269的规范，允许在编译时指定一个processor类来对编译阶段的注解进行干预，下面就来解决下这个处理器。</p>
<h3 id="创建Getter注解的处理器"><a href="#创建Getter注解的处理器" class="headerlink" title="创建Getter注解的处理器"></a>创建Getter注解的处理器</h3><p>基本框架</p>
<p>自定义的处理器需要继承AbstractProcessor这个类，基本的框架大体应当如下:</p>
<pre><code>package com.mythsman.test;
import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.TypeElement;
import java.util.Set;
@SupportedAnnotationTypes(&quot;com.mythsman.test.Getter&quot;)
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class GetterProcessor extends AbstractProcessor {
    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
    }
    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
        return true;
    }
}</code></pre><p>需要定义两个注解，一个表示该处理器需要处理的注解，另外一个表示该处理器支持的源码版本。然后需要着重实现两个方法，init跟process。init的主要用途是通过ProcessingEnvironment来获取编译阶段的一些环境信息;process主要是实现具体逻辑的地方，也就是对AST进行处理的地方。</p>
<p>具体怎么做呢？</p>
<p>init方法<br>首先我们要重写下init方法，从环境里提取一些关键的类:</p>
<pre><code>private Messager messager;
private JavacTrees trees;
private TreeMaker treeMaker;
private Names names;
@Override
public synchronized void init(ProcessingEnvironment processingEnv) {
    super.init(processingEnv);
    this.messager = processingEnv.getMessager();
    this.trees = JavacTrees.instance(processingEnv);
    Context context = ((JavacProcessingEnvironment) processingEnv).getContext();
    this.treeMaker = TreeMaker.instance(context);
    this.names = Names.instance(context);
}</code></pre><p>我们提取了四个主要的类:</p>
<ul>
<li>Messager主要是用来在编译期打log用的</li>
<li>JavacTrees提供了待处理的抽象语法树</li>
<li>TreeMaker封装了创建AST节点的一些方法</li>
<li>Names提供了创建标识符的方法</li>
</ul>
<p>process方法<br>process方法的逻辑比较简单，但是由于这里的api对于我们来说比较陌生，因此写起来还是费了不少劲的：</p>
<pre><code>@Override
public synchronized boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
    Set&lt;? extends Element&gt; set = roundEnv.getElementsAnnotatedWith(Getter.class);
    set.forEach(element -&gt; {
        JCTree jcTree = trees.getTree(element);
        jcTree.accept(new TreeTranslator() {
            @Override
            public void visitClassDef(JCTree.JCClassDecl jcClassDecl) {
                List&lt;JCTree.JCVariableDecl&gt; jcVariableDeclList = List.nil();
                for (JCTree tree : jcClassDecl.defs) {
                    if (tree.getKind().equals(Tree.Kind.VARIABLE)) {
                        JCTree.JCVariableDecl jcVariableDecl = (JCTree.JCVariableDecl) tree;
                        jcVariableDeclList = jcVariableDeclList.append(jcVariableDecl);
                    }
                }
                jcVariableDeclList.forEach(jcVariableDecl -&gt; {
                    messager.printMessage(Diagnostic.Kind.NOTE, jcVariableDecl.getName() + &quot; has been processed&quot;);
                    jcClassDecl.defs = jcClassDecl.defs.prepend(makeGetterMethodDecl(jcVariableDecl));
                });
                super.visitClassDef(jcClassDecl);
            }
        });
    });
    return true;
}</code></pre><p>步骤大概是下面这样：</p>
<ol>
<li>利用roundEnv的getElementsAnnotatedWith方法过滤出被Getter这个注解标记的类，并存入set</li>
<li>遍历这个set里的每一个元素，并生成jCTree这个语法树</li>
<li>创建一个TreeTranslator，并重写其中的visitClassDef方法，这个方法处理遍历语法树得到的类定义部分jcClassDecl<ul>
<li>创建一个jcVariableDeclList保存类的成员变量</li>
<li>遍历jcTree的所有成员(包括成员变量和成员函数和构造函数)，过滤出其中的成员变量，并添加进jcVariableDeclList</li>
<li>将jcVariableDeclList的所有变量转换成需要添加的getter方法，并添加进jcClassDecl的成员中</li>
<li>调用默认的遍历方法遍历处理后的jcClassDecl</li>
</ul>
</li>
<li>利用上面的TreeTranslator去处理jcTree</li>
</ol>
<p>接下来再实现makeGetterMethodDecl方法:</p>
<pre><code>private JCTree.JCMethodDecl makeGetterMethodDecl(JCTree.JCVariableDecl jcVariableDecl) {
    ListBuffer&lt;JCTree.JCStatement&gt; statements = new ListBuffer&lt;&gt;();
    statements.append(treeMaker.Return(treeMaker.Select(treeMaker.Ident(names.fromString(&quot;this&quot;)), jcVariableDecl.getName())));
    JCTree.JCBlock body = treeMaker.Block(0, statements.toList());
    return treeMaker.MethodDef(treeMaker.Modifiers(Flags.PUBLIC), getNewMethodName(jcVariableDecl.getName()), jcVariableDecl.vartype, List.nil(), List.nil(), List.nil(), body, null);
}
private Name getNewMethodName(Name name) {
    String s = name.toString();
    return names.fromString(&quot;get&quot; + s.substring(0, 1).toUpperCase() + s.substring(1, name.length()));
}</code></pre><p>逻辑就是读取变量的定义，并创建对应的Getter方法，并试图用驼峰命名法。</p>
<p>整体上难点还是集中在api的使用上，还有一些细微的注意点:<br>首先，messager的printMessage方法在打印log的时候会自动过滤重复的log信息。<br>其次，这里的list并不是java.util里面的list，而是一个自定义的list，这个list的用法比较坑爹，他采用的是这样的方式:</p>
<pre><code>package com.sun.tools.javac.util;
public class List&lt;A&gt; extends AbstractCollection&lt;A&gt; implements java.util.List&lt;A&gt; {
    public A head;
    public List&lt;A&gt; tail;

    //...

    List(A var1, List&lt;A&gt; var2) {
        this.tail = var2;
        this.head = var1;
    }

    public List&lt;A&gt; prepend(A var1) {
        return new List(var1, this);
    }

    public static &lt;A&gt; List&lt;A&gt; of(A var0) {
        return new List(var0, nil());
    }

    public List&lt;A&gt; append(A var1) {
        return of(var1).prependList(this);
    }

    public static &lt;A&gt; List&lt;A&gt; nil() {
        return EMPTY_LIST;
    }
    //...
}</code></pre><p>挺有趣的，用这种叫cons而不是list的数据结构，添加元素的时候就把自己赋给自己的tail,新来的元素放进head。不过需要注意的是这个东西不支持链式调用，prepend之后还要将新值赋给自己。<br>而且这里在创建getter方法的时候还要把参数写全写对了，尤其是添加this指针的这种用法。</p>
<p>测试类<br>上面基本就是所有功能代码了，接下来我们要写一个类来测试一下(App.java)：</p>
<pre><code>package com.mythsman.test;
@Getter
public class App {
    private String value;
    private String value2;
    public App(String value) {
        this.value = value;
    }
    public static void main(String[] args) {
        App app = new App(&quot;it works&quot;);
        System.out.println(app.getValue());
    }
}</code></pre><p>不过，先不要急着构建，构建了肯定会失败，因为这原则上应该是两个项目。Getter.java是注解类没问题，但是GetterProcessor.java是处理器，App.java需要在编译期调用这个处理器，因此这两个东西是不能一起编译的，正确的编译方法应该是类似下面这样，写成compile.sh脚本就是：</p>
<pre><code>#!/usr/bin/env bash
if [ -d classes ]; then
    rm -rf classes;
fi
mkdir classes
javac -cp $JAVA_HOME/lib/tools.jar com/mythsman/test/Getter* -d classes/
javac -cp classes -d classes -processor com.mythsman.test.GetterProcessor com/mythsman/test/App.java
javap -p classes com/mythsman/test/App.class
java -cp classes com.mythsman.test.App</code></pre><p>其实是五个步骤:</p>
<ol>
<li>创建保存class文件的文件夹</li>
<li>导入tools.jar，编译processor并输出</li>
<li>编译App.java，并使用javac的-processor参数指定编译阶段的处理器GetterProcessor</li>
<li>用javap显示编译后的App.class文件(非必须，方便看结果)</li>
<li>执行测试类    </li>
</ol>
<p>好了，进入项目的根目录，当前的目录结构应该是这样的:</p>
<p>.<br>├── pom.xml<br>├── src<br>│   ├── main<br>│   │   ├── java<br>│   │   │   ├── com<br>│   │   │   │   └── mythsman<br>│   │   │   │       └── test<br>│   │   │   │           ├── App.java<br>│   │   │   │           ├── Getter.java<br>│   │   │   │           └── GetterProcessor.java<br>│   │   │   └── compile.sh</p>
<p>调用compile.sh，输出如下:</p>
<pre><code>Note: value has been processed
Note: value2 has been processed
Compiled from &quot;App.java&quot;
public class com.mythsman.test.App {
  private java.lang.String value;
  private java.lang.String value2;
  public java.lang.String getValue2();
  public java.lang.String getValue();
  public com.mythsman.test.App(java.lang.String);
  public static void main(java.lang.String[]);
}
it works</code></pre><p>Note行就是在GetterProcessor类里通过messager打印的log，中间的是javap反编译的结果，最后一行表示测试调用成功。</p>
<h3 id="Maven构建并打包"><a href="#Maven构建并打包" class="headerlink" title="Maven构建并打包"></a>Maven构建并打包</h3><p>上面的测试部分其实是为了测试而测试，其实这应当是两个项目，一个是processor项目，这个项目应当被打成一个jar包，供调用者使用；另一个项目是app项目，这个项目是专门使用jar包的，他并不希望添加任何额外编译参数，就跟lombok的用法一样。<br>简单来说，就是我们希望把processor打成一个包，并且在使用时不需要添加额外参数。<br>那么如何在调用的时候不用加参数呢，其实我们知道java在编译的时候会去资源文件夹下读一个META-INF文件夹，这个文件夹下面除了MANIFEST.MF文件之外，还可以添加一个services文件夹，我们可以在这个文件夹下创建一个文件，文件名是javax.annotation.processing.Processor，文件内容是com.mythsman.test.GetterProcessor。<br>我们知道maven在编译前会先拷贝资源文件夹，然后当他在编译时候发现了资源文件夹下的META-INF/serivces文件夹时，他就会读取里面的文件，并将文件名所代表的接口用文件内容表示的类来实现。这就相当于做了-processor参数该做的事了。<br>当然这个文件我们并不希望调用者去写，而是希望在processor项目里集成，调用的时候能直接继承META-INF。</p>
<p>好了，我们先删除App.java和compile.sh，添加下META-INF文件夹，当前目录结构应该是这样的：</p>
<p>.<br>├── pom.xml<br>├── src<br>│   └── main<br>│       ├── java<br>│       │   └── com<br>│       │       └── mythsman<br>│       │           └── test<br>│       │               ├── Getter.java<br>│       │               └── GetterProcessor.java<br>│       └── resources<br>│           └── META-INF<br>│               └── services<br>│                   └── javax.annotation.processing.Processor</p>
<p>当然，我们还不能编译，因为processor项目并不需要把自己添加为processor(况且自己还没编译呢怎么调用自己)。。。完了，好像死循环了，自己在编译的时候不能添加services文件夹，但是又需要打的包里有services文件夹，这该怎么搞呢？<br>其实很简单，配置一下maven的插件就行，打开pom.xml,在project/build/标签里添加下面的配置:</p>
<pre><code>&lt;build&gt;
   &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;excludes&gt;
                &lt;exclude&gt;META-INF/**/*&lt;/exclude&gt;
            &lt;/excludes&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.6&lt;/version&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;id&gt;process-META&lt;/id&gt;
                    &lt;phase&gt;prepare-package&lt;/phase&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;copy-resources&lt;/goal&gt;
                    &lt;/goals&gt;
                    &lt;configuration&gt;
                        &lt;outputDirectory&gt;target/classes&lt;/outputDirectory&gt;
                        &lt;resources&gt;
                            &lt;resource&gt;
                                &lt;directory&gt;${basedir}/src/main/resources/&lt;/directory&gt;
                                &lt;includes&gt;
                                    &lt;include&gt;**/*&lt;/include&gt;
                                &lt;/includes&gt;
                            &lt;/resource&gt;
                        &lt;/resources&gt;
                    &lt;/configuration&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
        ...
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre><p>我们知道maven构建的第一步就是调用maven-resources-plugin插件的resources命令，将resources文件夹复制到target/classes中，那么我们配置一下resources标签，过滤掉META-INF文件夹，这样在编译的时候就不会找到services的配置了。然后我们在打包前(prepare-package生命周期)再利用maven-resources-plugin插件的copy-resources命令把services文件夹重新拷贝过来不就好了么。<br>这样配置好了，就可以直接执行mvn clean install打包提交到本地私服:</p>
<pre><code>myths@pc:~/Desktop/test$ mvn clean install
[INFO] Scanning for projects...
[INFO] 
[INFO] ------------------------------------------------------------------------
[INFO] Building test 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ getter ---
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ getter ---
[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.
[INFO] Copying 0 resource
[INFO] 
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ getter ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 2 source files to /home/myths/Desktop/test/target/classes
[INFO] 
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ getter ---
[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory /home/myths/Desktop/test/src/test/resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ getter ---
[INFO] No sources to compile
[INFO] 
[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ getter ---
[INFO] No tests to run.
[INFO] 
[INFO] --- maven-resources-plugin:2.6:copy-resources (process-META) @ getter ---
[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.
[INFO] Copying 1 resource
[INFO] 
[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ getter ---
[INFO] Building jar: /home/myths/Desktop/test/target/getter-1.0-SNAPSHOT.jar
[INFO] 
[INFO] --- maven-install-plugin:2.4:install (default-install) @ getter ---
[INFO] Installing /home/myths/Desktop/test/target/getter-1.0-SNAPSHOT.jar to /home/myths/.m2/repository/com/mythsman/test/getter/1.0-SNAPSHOT/getter-1.0-SNAPSHOT.jar
[INFO] Installing /home/myths/Desktop/test/pom.xml to /home/myths/.m2/repository/com/mythsman/test/getter/1.0-SNAPSHOT/getter-1.0-SNAPSHOT.pom
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 3.017 s
[INFO] Finished at: 2017-12-19T19:57:04+08:00
[INFO] Final Memory: 16M/201M
[INFO] ------------------------------------------------------------------------</code></pre><p>可以看到这里的process-META作用生效。</p>
<p>调用jar包测试</p>
<p>重新创建一个测试项目app：</p>
<p>.<br>├── pom.xml<br>└── src<br>    └── main<br>        └── java<br>            └── com<br>                └── mythsman<br>                    └── test<br>                        └── App.java</p>
<p>pom.xml:</p>
<pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;com.mythsman.test&lt;/groupId&gt;
    &lt;artifactId&gt;app&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;name&gt;main&lt;/name&gt;
    &lt;url&gt;http://maven.apache.org&lt;/url&gt;
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.mythsman.test&lt;/groupId&gt;
            &lt;artifactId&gt;getter&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.1&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;</code></pre><p>App.java:</p>
<pre><code>package com.mythsman.test;
@Getter
public class App {
    private String value;
    private String value2;
    public App(String value) {
        this.value = value;
    }
    public static void main(String[] args) {
        App app = new App(&quot;it works&quot;);
        System.out.println(app.getValue());
    }
}</code></pre><p>编译并执行:</p>
<p>mvn clean compile &amp;&amp; java -cp target/classes com.mythsman.test.App</p>
<p>最后就会在构建成功后打印”it works”。</p>
<p><a href="https://zhuanlan.zhihu.com/p/32779910" target="_blank" rel="noopener">参考</a><br><a href="https://yq.aliyun.com/articles/59972" target="_blank" rel="noopener">参考</a><br><a href="https://juejin.im/entry/5a390ba76fb9a0451e3fed7c" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <categories>
        <category>Lombok</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>java</tag>
        <tag>lombok</tag>
        <tag>plugin</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL InnoDB MRR 优化  </title>
    <url>/2019/08/19/MySQL-InnoDB-MRR-%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>MRR 是 Multi-Range Read 的简写，目的是减少磁盘随机访问，将随机访问转化为较为顺序的访问。适用于 range/ref/eq_ref 类型的查询。</p>
<h2 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h2><ol>
<li><p>在二级索引查找后，根据得到的主键到聚簇索引找出需要的数据。</p>
</li>
<li><p>二级索引查找得到的主键的顺序是不确定的，因为二级索引的顺序与聚簇索引的顺序不一定一致；</p>
</li>
<li><p>如果没有 MRR，那么在聚簇索引查找时就可能出现乱序读取数据页，这对于机械硬盘是及其不友好的。</p>
</li>
<li><p>MRR 的优化方式：</p>
<ul>
<li>将查找到的二级索引键值放在一个缓存中；</li>
<li>将缓存中的键值按照 主键 进行排序；</li>
<li>根据排序后的主键去聚簇索引访问实际的数据文件。</li>
</ul>
</li>
<li><p>当优化器使用了 MRR 时，执行计划的 Extra 列会出现 “Using MRR” 。</p>
</li>
<li><p>如果查询使用的二级索引的顺序本身与结果集的顺序一致，那么使用 MRR 后需要对得到的结果集进行排序。</p>
</li>
</ol>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>使用 MRR 还可以减少缓冲池中页被替换的次数，批量处理对键值的查询操作。</p>
<p>可以使用命令 select @@optimizer_switch; 查看是否开启了 MRR：</p>
<pre><code>index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=off,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on,use_invisible_indexes=off,skip_scan=on</code></pre><p>mrr_cost_based=on 表示是否通过 cost based 的方式来选择使用 MRR 。</p>
<p>用 set @@optimizer_switch=’mrr=on/off’; 命令开启或关闭 MRR 。</p>
<p>select @@read_rnd_buffer_size ; 参数用来控制键值的缓冲区大小，默认 256K，当大于该参数值时，执行器根据主键对已缓存的数据进行排序，然后再通过主键取得行数据。</p>
]]></content>
  </entry>
  <entry>
    <title>Spring Boot 核心注解</title>
    <url>/2019/09/25/Spring-Boot-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p>我看你上面写了熟悉 Spring Boot，那你能讲下为什么我们要用 Spring Boot 吗？</p>
<h1 id="下面我列几个最常见的三个回答："><a href="#下面我列几个最常见的三个回答：" class="headerlink" title="下面我列几个最常见的三个回答："></a>下面我列几个最常见的三个回答：</h1><h2 id="A：Spring-Boot-最主要是不用-XML-配置，可以用-Java-来配置-bean，省去了许多配置文件。"><a href="#A：Spring-Boot-最主要是不用-XML-配置，可以用-Java-来配置-bean，省去了许多配置文件。" class="headerlink" title="A：Spring Boot 最主要是不用 XML 配置，可以用 Java 来配置 bean，省去了许多配置文件。"></a>A：Spring Boot 最主要是不用 XML 配置，可以用 Java 来配置 bean，省去了许多配置文件。</h2><p>我又问：Spring 本身就可以用 Java 配置代替 XML 配置，和 Spring Boot 有什么关系呢？</p>
<p>然后对方就吱吱唔唔了……</p>
<h2 id="B：Spring-Boot-我们用来做-Spring-Cloud-微服务。"><a href="#B：Spring-Boot-我们用来做-Spring-Cloud-微服务。" class="headerlink" title="B：Spring Boot 我们用来做 Spring Cloud 微服务。"></a>B：Spring Boot 我们用来做 Spring Cloud 微服务。</h2><p>我又问：微服务和 Spring Boot 有什么关系？不用 Spring Boot 行不行？</p>
<p>然后对方就吱吱唔唔了……</p>
<h2 id="C：Spring-Boot-可以打-jar-包部署，内部集成了Tomcat。"><a href="#C：Spring-Boot-可以打-jar-包部署，内部集成了Tomcat。" class="headerlink" title="C：Spring Boot 可以打 jar 包部署，内部集成了Tomcat。"></a>C：Spring Boot 可以打 jar 包部署，内部集成了Tomcat。</h2><p>这个确实是 Spring Boot 的特色，但是我还是觉得没有答到关键点上。</p>
<p>然后我继续问，如果不考虑打 jar 包部署呢，然后就没然后了……</p>
<h1 id="为什么我们要用-Spring-Boot，显然上面三个求职者没有答到关键点上，Spring-Boot-最重要的功能是：自动配置。"><a href="#为什么我们要用-Spring-Boot，显然上面三个求职者没有答到关键点上，Spring-Boot-最重要的功能是：自动配置。" class="headerlink" title="为什么我们要用 Spring Boot，显然上面三个求职者没有答到关键点上，Spring Boot 最重要的功能是：自动配置。"></a>为什么我们要用 Spring Boot，显然上面三个求职者没有答到关键点上，Spring Boot 最重要的功能是：自动配置。</h1><h2 id="为什么说是自动配置？"><a href="#为什么说是自动配置？" class="headerlink" title="为什么说是自动配置？"></a>为什么说是自动配置？</h2><p>Spring Boot 的开启注解是：@SpringBootApplication，其实它就是由下面三个注解组成的：</p>
<pre><code>@Configuration
@ComponentScan
@EnableAutoConfiguration</code></pre><p>上面三个注解，前面两个都是 Spring 自带的，和 Spring Boot 无关，所以说上面的回答的不是在点上。</p>
<p>所以说 Spring Boot 最最核心的就是这个 <strong>@EnableAutoConfiguration</strong> 注解了，它能根据类路径下的 jar 包和配置动态加载配置和注入bean。</p>
<p>举个例子，比如我在 lib 下放一个 druid 连接池的 jar 包，然后在 application.yml 文件配置 druid 相关的参数，Spring Boot 就能够自动配置所有我们需要的东西，如果我把 jar 包拿掉或者把参数去掉，那 Spring Boot 就不会自动配置。</p>
<p>这样我们就能把许多功能做成公共的自动配置的启动器（starters），其实 druid 连接池就是这么做的，它提供了针对 Spring Boot 的启动器：druid-spring-boot-starter。</p>
<p>有了这个自动配置的启动器，我们就能非常简单的使用它，</p>
<p>先添加 jar 包依赖：</p>
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
   &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
   &lt;version&gt;1.1.10&lt;/version&gt;
&lt;/dependency&gt;    </code></pre><p>再添加相关参数：</p>
<pre><code>spring.datasource.url= 
spring.datasource.username=
spring.datasource.password=
……</code></pre><p>如果是传统的项目，我们要自己手动写一大堆的配置，而且还不灵活，有了这个启动器，我们就可以做到简单集成。具体大家可以看 druid-spring-boot-starter 是怎么实现的。</p>
<p>所以，这才是 Spring Boot 的核心，这才是我们为什么使用 Spring Boot 的原因。如果答不到这个关键点，那真没有掌握到 Spring Boot 的核心所在。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL创建用户与授权  </title>
    <url>/2019/09/12/MySQL%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E4%B8%8E%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<h1 id="一-创建用户"><a href="#一-创建用户" class="headerlink" title="一. 创建用户"></a>一. 创建用户</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><pre><code>CREATE USER &apos;username&apos;@&apos;host&apos; IDENTIFIED BY &apos;password&apos;;</code></pre><h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><ul>
<li>username：你将创建的用户名</li>
<li>host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%</li>
<li>password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</li>
</ul>
<h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><pre><code>CREATE USER &apos;dog&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;;
CREATE USER &apos;pig&apos;@&apos;192.168.1.101_&apos; IDENDIFIED BY &apos;123456&apos;;
CREATE USER &apos;pig&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;
CREATE USER &apos;pig&apos;@&apos;%&apos; IDENTIFIED BY &apos;&apos;;
CREATE USER &apos;pig&apos;@&apos;%&apos;;</code></pre><h1 id="二-授权"><a href="#二-授权" class="headerlink" title="二. 授权:"></a>二. 授权:</h1><h2 id="命令-1"><a href="#命令-1" class="headerlink" title="命令:"></a>命令:</h2><pre><code>GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos;</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h2><ul>
<li>privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL</li>
<li>databasename：数据库名</li>
<li>tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<em>表示，如</em>.*</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h2><pre><code>GRANT SELECT, INSERT ON test.user TO &apos;pig&apos;@&apos;%&apos;;
GRANT ALL ON *.* TO &apos;pig&apos;@&apos;%&apos;;</code></pre><p>注意:<br>用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:</p>
<pre><code>GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos; WITH GRANT OPTION;</code></pre><h1 id="三-设置与更改用户密码"><a href="#三-设置与更改用户密码" class="headerlink" title="三.设置与更改用户密码"></a>三.设置与更改用户密码</h1><p>   命令:</p>
<pre><code>SET PASSWORD FOR &apos;username&apos;@&apos;host&apos; = PASSWORD(&apos;newpassword&apos;);</code></pre><p> 如果是当前登陆用户用:</p>
<pre><code>SET PASSWORD = PASSWORD(&quot;newpassword&quot;);</code></pre><p>例子:</p>
<pre><code>SET PASSWORD FOR &apos;pig&apos;@&apos;%&apos; = PASSWORD(&quot;123456&quot;);</code></pre><h1 id="四-撤销用户权限"><a href="#四-撤销用户权限" class="headerlink" title="四. 撤销用户权限"></a>四. 撤销用户权限</h1><p>命令:</p>
<pre><code>REVOKE privilege ON databasename.tablename FROM &apos;username&apos;@&apos;host&apos;;</code></pre><p>说明:<br>privilege, databasename, tablename：同授权部分</p>
<p>例子:</p>
<pre><code>REVOKE SELECT ON *.* FROM &apos;pig&apos;@&apos;%&apos;;</code></pre><p>注意:</p>
<p>假如你在给用户‘pig’@’%’授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO ‘pig’@’%’，则在使用REVOKE SELECT ON <em>.</em> FROM ‘pig’@’%’;命令并不能撤销该用户对test数据库中user表的SELECT 操作。相反，如果授权使用的是GRANT SELECT ON <em>.</em> TO ‘pig’@’%’;则REVOKE SELECT ON test.user FROM ‘pig’@’%’;命令也不能撤销该用户对test数据库中user表的Select权限。</p>
<p>具体信息可以用命令SHOW GRANTS FOR ‘pig’@’%’; 查看。</p>
<h1 id="五-删除用户"><a href="#五-删除用户" class="headerlink" title="五.删除用户"></a>五.删除用户</h1><pre><code>DROP USER &apos;username&apos;@&apos;host&apos;;</code></pre><p><a href="https://www.jianshu.com/p/d7b9c468f20d" target="_blank" rel="noopener">摘抄自</a></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring基础知识</title>
    <url>/2019/09/02/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="Spring简介"><a href="#Spring简介" class="headerlink" title="Spring简介"></a>Spring简介</h1><p>Spring框架由Rod Johnson开发，2004年发布了Spring框架的第一版。Spring是一个从实际开发中抽取出来的框架，因此它完成了大量开发中的通用步骤，留给开发者的仅仅是与特定应用相关的部分，从而大大提高了企业应用的开发效率。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>低侵入式设计，代码的污染极低</li>
<li>独立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once，Run Anywhere的承诺。</li>
<li>Spring的IoC容器降低了业务对象替换的复杂性，提高了组件之间的解耦。</li>
<li>Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式管理，从而提供了更好的复用。</li>
<li>Spring的ORM和DAO提供了与第三方持久层框架的良好整合，并简化了底层的数据库访问。</li>
<li>Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部。</li>
</ul>
<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/673670c9a34075831373b711cb8f21b7.png" alt=""></p>
<h1 id="Spring的核心机制"><a href="#Spring的核心机制" class="headerlink" title="Spring的核心机制"></a>Spring的核心机制</h1><h2 id="管理Bean"><a href="#管理Bean" class="headerlink" title="管理Bean"></a>管理Bean</h2><p>程序主要是通过Spring容器来访问容器中的Bean，ApplicationContext是Spring容器最常用的接口，该接口有如下两个实现类：</p>
<ul>
<li><p>ClassPathXmlApplicationContext: 从类加载路径下搜索配置文件，并根据配置文件来创建Spring容器。</p>
</li>
<li><p>FileSystemXmlApplicationContext: 从文件系统的相对路径或绝对路径下去搜索配置文件，并根据配置文件来创建Spring容器。</p>
</li>
</ul>
<pre><code>public class BeanTest{
    public static void main(String args[]) throws Exception{
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
        Person p = ctx.getBean(&quot;person&quot;, Person.class);
        p.say();
    }
}</code></pre><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>Spring框架的核心功能有两个：</p>
<ul>
<li><p>Spring容器作为超级大工厂，负责创建、管理所有的Java对象，这些Java对象被称为Bean。</p>
</li>
<li><p>Spring容器管理容器中Bean之间的依赖关系，Spring使用一种被称为”依赖注入”的方式来管理Bean之间的依赖关系。</p>
</li>
</ul>
<p>使用依赖注入，不仅可以为Bean注入普通的属性值，还可以注入其他Bean的引用。依赖注入是一种优秀的解耦方式，其可以让Bean以配置文件组织在一起，而不是以硬编码的方式耦合在一起。</p>
<h3 id="理解依赖注入"><a href="#理解依赖注入" class="headerlink" title="理解依赖注入"></a>理解依赖注入</h3><p>Rod Johnson是第一个高度重视以配置文件来管理Java实例的协作关系的人，他给这种方式起了一个名字：控制反转（Inverse of Control，IoC）。后来Martine Fowler为这种方式起了另一个名称：依赖注入（Dependency Injection），因此不管是依赖注入，还是控制反转，其含义完全相同。当某个Java对象（调用者）需要调用另一个Java对象（被依赖对象）的方法时，在传统模式下通常有两种做法：</p>
<ol>
<li><p>原始做法: 调用者<strong>主动</strong>创建被依赖对象，然后再调用被依赖对象的方法。</p>
</li>
<li><p>简单工厂模式: 调用者先找到被依赖对象的工厂，然后主动通过工厂去获取被依赖对象，最后再调用被依赖对象的方法。</p>
</li>
</ol>
<p>注意上面的<strong>主动</strong>二字，这必然会导致调用者与被依赖对象实现类的硬编码耦合，非常不利于项目升级的维护。使用Spring框架之后，调用者无需主动获取被依赖对象，调用者只要被动接受Spring容器为调用者的成员变量赋值即可，由此可见，使用Spring后，调用者获取被依赖对象的方式由原来的主动获取，变成了被动接受——所以Rod Johnson称之为控制反转。</p>
<p>另外从Spring容器的角度来看，Spring容器负责将被依赖对象赋值给调用者的成员变量——相当于为调用者注入它依赖的实例，因此Martine Fowler称之为依赖注入。</p>
<h3 id="设值注入"><a href="#设值注入" class="headerlink" title="设值注入"></a>设值注入</h3><p>设值注入是指IoC容器通过成员变量的setter方法来注入被依赖对象。这种注入方式简单、直观，因而在Spring的依赖注入里大量使用。</p>
<h3 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h3><p>利用构造器来设置依赖关系的方式，被称为构造注入。通俗来说，就是驱动Spring在底层以反射方式执行带指定参数的构造器，当执行带参数的构造器时，就可利用构造器参数对成员变量执行初始化——这就是构造注入的本质。</p>
<h3 id="两种注入方式的对比"><a href="#两种注入方式的对比" class="headerlink" title="两种注入方式的对比"></a>两种注入方式的对比</h3><p>设值注入有如下优点：</p>
<ul>
<li><p>与传统的JavaBean的写法更相似，程序开发人员更容易理解、接受。通过setter方法设定依赖关系显得更加直观、自然。</p>
</li>
<li><p>对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。Spring在创建Bean实例时，需要同时实例化其依赖的全部实例，因而导致性能下降。而使用设值注入，则能避免这些问题。</p>
</li>
<li><p>尤其在某些成员变量可选的情况下，多参数的构造器更加笨重。</p>
</li>
</ul>
<p>构造注入优势如下：</p>
<ul>
<li><p>构造注入可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入。</p>
</li>
<li><p>对于依赖关系无需变化的Bean，构造注入更有用处。因为没有setter方法，所有的依赖关系全部在构造器内设定，无须担心后续的代码对依赖关系产生破坏。</p>
</li>
<li><p>依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系，对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则。</p>
</li>
</ul>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>建议采用设值注入为主，构造注入为辅的注入策略。对于依赖关系无须变化的注入，尽量采用构造注入；而其他依赖关系的注入，则考虑采用设值注入。</p>
<h2 id="Spring容器中的Bean"><a href="#Spring容器中的Bean" class="headerlink" title="Spring容器中的Bean"></a>Spring容器中的Bean</h2><h3 id="IoC的本质"><a href="#IoC的本质" class="headerlink" title="IoC的本质"></a>IoC的本质</h3><p>对于开发者来说，开发者使用Spring框架主要是做两件事：①开发Bean；②配置Bean。对于Spring框架来说，它要做的就是根据配置文件来创建Bean实例，并调用Bean实例的方法完成”依赖注入”——这就是所谓IoC的本质。</p>
<h3 id="容器中Bean的作用域"><a href="#容器中Bean的作用域" class="headerlink" title="容器中Bean的作用域"></a>容器中Bean的作用域</h3><p>当通过Spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下五种作用域：</p>
<ol>
<li><p>singleton: 单例模式，在整个Spring IoC容器中，singleton作用域的Bean将只生成一个实例。</p>
</li>
<li><p>prototype: 每次通过容器的getBean()方法获取prototype作用域的Bean时，都将产生一个新的Bean实例。</p>
</li>
<li><p>request: 对于一次HTTP请求，request作用域的Bean将只生成一个实例，这意味着，在同一次HTTP请求内，程序每次请求该Bean，得到的总是同一个实例。只有在Web应用中使用Spring时，该作用域才真正有效。</p>
</li>
<li><p>session：该作用域将 bean 的定义限制为 HTTP 会话。 只在web-aware Spring ApplicationContext的上下文中有效。</p>
</li>
<li><p>global session: 每个全局的HTTP Session对应一个Bean实例。在典型的情况下，仅在使用portlet context的时候有效，同样只在Web应用中有效。</p>
</li>
</ol>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果不指定Bean的作用域，Spring默认使用singleton作用域。prototype作用域的Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成果，就可以重复使用。因此，应该尽量避免将Bean设置成prototype作用域。</p>
<h2 id="使用自动装配注入合作者Bean"><a href="#使用自动装配注入合作者Bean" class="headerlink" title="使用自动装配注入合作者Bean"></a>使用自动装配注入合作者Bean</h2><p> Spring能自动装配Bean与Bean之间的依赖关系，即无须使用ref显式指定依赖Bean，而是由Spring容器检查XML配置文件内容，根据某种规则，为调用者Bean注入被依赖的Bean。</p>
<p> Spring自动装配可通过<beans/>元素的default-autowire属性指定，该属性对配置文件中所有的Bean起作用；也可通过对<bean/>元素的autowire属性指定，该属性只对该Bean起作用。</p>
<p> autowire和default-autowire可以接受如下值：</p>
<ul>
<li><p>no: 不使用自动装配。Bean依赖必须通过ref元素定义。这是默认配置，在较大的部署环境中不鼓励改变这个配置，显式配置合作者能够得到更清晰的依赖关系。</p>
</li>
<li><p>byName: 根据setter方法名进行自动装配。Spring容器查找容器中全部Bean，找出其id与setter方法名去掉set前缀，并小写首字母后同名的Bean来完成注入。如果没有找到匹配的Bean实例，则Spring不会进行任何注入。</p>
</li>
<li><p>byType 根据setter方法的形参类型来自动装配。Spring容器查找容器中的全部Bean，如果正好有一个Bean类型与setter方法的形参类型匹配，就自动注入这个Bean；如果找到多个这样的Bean，就抛出一个异常；如果没有找到这样的Bean，则什么都不会发生，setter方法不会被调用</p>
</li>
<li><p>constructor: 与byType类似，区别是用于自动匹配构造器的参数。如果容器不能恰好找到一个与构造器参数类型匹配的Bean，则会抛出一个异常。</p>
</li>
<li><p>autodetect: Spring容器根据Bean内部结构，自行决定使用constructor或byType策略。如果找到一个默认的构造函数，那么就会应用byType策略。</p>
</li>
</ul>
<p>当一个Bean既使用自动装配依赖，又使用ref显式指定依赖时，则显式指定的依赖覆盖自动装配依赖；对于大型的应用，不鼓励使用自动装配。虽然使用自动装配可减少配置文件的工作量，但大大将死了依赖关系的清晰性和透明性。依赖关系的装配依赖于源文件的属性名和属性类型，导致Bean与Bean之间的耦合降低到代码层次，不利于高层次解耦。</p>
<pre><code>&lt;!--通过设置可以将Bean排除在自动装配之外--&gt;
&lt;bean id=&quot;&quot; autowire-candidate=&quot;false&quot;/&gt;

&lt;!--除此之外，还可以在beans元素中指定，支持模式字符串，如下所有以abc结尾的Bean都被排除在自动装配之外--&gt;
&lt;beans default-autowire-candidates=&quot;*abc&quot;/&gt;</code></pre><h1 id="创建Bean的3种方式"><a href="#创建Bean的3种方式" class="headerlink" title="创建Bean的3种方式"></a>创建Bean的3种方式</h1><h2 id="使用构造器创建Bean实例"><a href="#使用构造器创建Bean实例" class="headerlink" title="使用构造器创建Bean实例"></a>使用构造器创建Bean实例</h2><p>使用构造器来创建Bean实例是最常见的情况，如果不采用构造注入，Spring底层会调用Bean类的无参数构造器来创建实例，因此要求该Bean类提供无参数的构造器。</p>
<p>采用默认的构造器创建Bean实例，Spring对Bean实例的所有属性执行默认初始化，即所有的基本类型的值初始化为0或false；所有的引用类型的值初始化为null。</p>
<h2 id="使用静态工厂方法创建Bean"><a href="#使用静态工厂方法创建Bean" class="headerlink" title="使用静态工厂方法创建Bean"></a>使用静态工厂方法创建Bean</h2><p>使用静态工厂方法创建Bean实例时，class属性也必须指定，但此时class属性并不是指定Bean实例的实现类，而是静态工厂类，Spring通过该属性知道由哪个工厂类来创建Bean实例。</p>
<p>除此之外，还需要使用factory-method属性来指定静态工厂方法，Spring将调用静态工厂方法返回一个Bean实例，一旦获得了指定Bean实例，Spring后面的处理步骤与采用普通方法创建Bean实例完全一样。如果静态工厂方法需要参数，则使用&lt;constructor-arg…/&gt;元素指定静态工厂方法的参数。</p>
<h2 id="调用实例工厂方法创建Bean"><a href="#调用实例工厂方法创建Bean" class="headerlink" title="调用实例工厂方法创建Bean"></a>调用实例工厂方法创建Bean</h2><p>实例工厂方法与静态工厂方法只有一个不同：调用静态工厂方法只需使用工厂类即可，而调用实例工厂方法则需要工厂实例。使用实例工厂方法时，配置Bean实例的&lt;bean…/&gt;元素无须class属性，配置实例工厂方法使用factory-bean指定工厂实例。<br>采用实例工厂方法创建Bean的&lt;bean…/&gt;元素时需要指定如下两个属性：</p>
<ul>
<li>factory-bean: 该属性的值为工厂Bean的id。</li>
<li>factory-method: 该属性指定实例工厂的工厂方法。</li>
</ul>
<p>若调用实例工厂方法时需要传入参数，则使用&lt;constructor-arg…/&gt;元素确定参数值。</p>
<h1 id="协调作用域不同步的Bean"><a href="#协调作用域不同步的Bean" class="headerlink" title="协调作用域不同步的Bean"></a>协调作用域不同步的Bean</h1><p>当singleton作用域的Bean依赖于prototype作用域的Bean时，会产生不同步的现象，原因是因为当Spring容器初始化时，容器会预初始化容器中所有的singleton Bean，由于singleton Bean依赖于prototype Bean，因此Spring在初始化singleton Bean之前，会先创建prototypeBean——然后才创建singleton Bean，接下里将prototype Bean注入singleton Bean。<br>解决不同步的方法有两种：</p>
<ul>
<li><p>放弃依赖注入: singleton作用域的Bean每次需要prototype作用域的Bean时，主动向容器请求新的Bean实例，即可保证每次注入的prototype Bean实例都是最新的实例。</p>
</li>
<li><p>利用方法注入: 方法注入通常使用lookup方法注入，使用lookup方法注入可以让Spring容器重写容器中Bean的抽象或具体方法，返回查找容器中其他Bean的结果，被查找的Bean通常是一个non-singleton Bean。Spring通过使用JDK动态代理或cglib库修改客户端的二进制码，从而实现上述要求。</p>
</li>
</ul>
<p><strong>注意</strong></p>
<p><strong>Spring会采用运行时动态增强的方式来实现&lt;lookup-method…/&gt;元素所指定的抽象方法，如果目标抽象类实现过接口，Spring会采用JDK动态代理来实现该抽象类，并为之实现抽象方法；如果目标抽象类没有实现过接口，Spring会采用cglib实现该抽象类，并为之实现抽象方法。Spring4.0的spring-core-xxx.jar包中已经集成了cglib类库。</strong></p>
<h1 id="两种后处理器"><a href="#两种后处理器" class="headerlink" title="两种后处理器"></a>两种后处理器</h1><p>Spring提供了两种常用的后处理器：</p>
<ul>
<li><p>Bean后处理器: 这种后处理器会对容器中Bean进行后处理，对Bean进行额外加强。</p>
</li>
<li><p>容器后处理器: 这种后处理器会对IoC容器进行后处理，用于增强容器功能。</p>
</li>
</ul>
<h2 id="Bean后处理器"><a href="#Bean后处理器" class="headerlink" title="Bean后处理器"></a>Bean后处理器</h2><p>Bean后处理器是一种特殊的Bean，这种特殊的Bean并不对外提供服务，它甚至可以无须id属性，它主要负责对容器中的其他Bean执行后处理，例如为容器中的目标Bean生成代理等，这种Bean称为Bean后处理器。Bean后处理器会在Bean实例创建成功之后，对Bean实例进行进一步的增强处理。Bean后处理器必须实现BeanPostProcessor接口，同时必须实现该接口的两个方法。</p>
<ul>
<li><p>Object postProcessBeforeInitialization(Object bean, String name) throws BeansException: 该方法的第一个参数是系统即将进行后处理的Bean实例，第二个参数是该Bean的配置id</p>
</li>
<li><p>Object postProcessAfternitialization(Object bean, String name) throws BeansException: 该方法的第一个参数是系统即将进行后处理的Bean实例，第二个参数是该Bean的配置id</p>
</li>
</ul>
<p>容器中一旦注册了Bean后处理器，Bean后处理器就会自动启动，在容器中每个Bean创建时自动工作，Bean后处理器两个方法的回调时机如下图：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/07/e8970a58f831cd7613b680ef0541e7c7.jpg" alt=""><br>注意一点，如果使用BeanFactory作为Spring容器，则必须手动注册Bean后处理器，程序必须获取Bean后处理器实例，然后手动注册。</p>
<pre><code>BeanPostProcessor bp = (BeanPostProcessor)beanFactory.getBean(&quot;bp&quot;);
beanFactory.addBeanPostProcessor(bp);
Person p = (Person)beanFactory.getBean(&quot;person&quot;);</code></pre><h2 id="容器后处理器"><a href="#容器后处理器" class="headerlink" title="容器后处理器"></a>容器后处理器</h2><p>Bean后处理器负责处理容器中的所有Bean实例，而容器后处理器则负责处理容器本身。容器后处理器必须实现BeanFactoryPostProcessor接口，并实现该接口的一个方法postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)实现该方法的方法体就是对Spring容器进行的处理，这种处理可以对Spring容器进行自定义扩展，当然也可以对Spring容器不进行任何处理。</p>
<p>类似于BeanPostProcessor，ApplicationContext可自动检测到容器中的容器后处理器，并且自动注册容器后处理器。但若使用BeanFactory作为Spring容器，则必须手动调用该容器后处理器来处理BeanFactory容器。</p>
<h1 id="Spring的”零配置”支持"><a href="#Spring的”零配置”支持" class="headerlink" title="Spring的”零配置”支持"></a>Spring的”零配置”支持</h1><h2 id="搜索Bean类"><a href="#搜索Bean类" class="headerlink" title="搜索Bean类"></a>搜索Bean类</h2><p>Spring提供如下几个Annotation来标注Spring Bean：</p>
<ul>
<li><p>@Component: 标注一个普通的Spring Bean类</p>
</li>
<li><p>@Controller: 标注一个控制器组件类</p>
</li>
<li><p>@Service: 标注一个业务逻辑组件类</p>
</li>
<li><p>@Repository: 标注一个DAO组件类</p>
</li>
</ul>
<p>在Spring配置文件中做如下配置，指定自动扫描的包：</p>
<p>&lt;context:component-scan base-package=”edu.shu.spring.domain”/&gt;</p>
<h2 id="使用-Resource配置依赖"><a href="#使用-Resource配置依赖" class="headerlink" title="使用@Resource配置依赖"></a>使用@Resource配置依赖</h2><p>@Resource位于javax.annotation包下，是来自JavaEE规范的一个Annotation，Spring直接借鉴了该Annotation，通过使用该Annotation为目标Bean指定协作者Bean。使用@Resource与&lt;property…/&gt;元素的ref属性有相同的效果。<br>@Resource不仅可以修饰setter方法，也可以直接修饰实例变量，如果使用@Resource修饰实例变量将会更加简单，此时Spring将会直接使用JavaEE规范的Field注入，此时连setter方法都可以不要。</p>
<h2 id="使用-PostConstruct和-PreDestroy定制生命周期行为"><a href="#使用-PostConstruct和-PreDestroy定制生命周期行为" class="headerlink" title="使用@PostConstruct和@PreDestroy定制生命周期行为"></a>使用@PostConstruct和@PreDestroy定制生命周期行为</h2><p>@PostConstruct和@PreDestroy同样位于javax.annotation包下，也是来自JavaEE规范的两个Annotation，Spring直接借鉴了它们，用于定制Spring容器中Bean的生命周期行为。它们都用于修饰方法，无须任何属性。其中前者修饰的方法时Bean的初始化方法；而后者修饰的方法时Bean销毁之前的方法。</p>
<h2 id="Spring4-0增强的自动装配和精确装配"><a href="#Spring4-0增强的自动装配和精确装配" class="headerlink" title="Spring4.0增强的自动装配和精确装配"></a>Spring4.0增强的自动装配和精确装配</h2><p>Spring提供了@Autowired注解来指定自动装配，@Autowired可以修饰setter方法、普通方法、实例变量和构造器等。当使用@Autowired标注setter方法时，默认采用byType自动装配策略。在这种策略下，符合自动装配类型的候选Bean实例常常有多个，这个时候就可能引起异常，为了实现精确的自动装配，Spring提供了@Qualifier注解，通过使用@Qualifier，允许根据Bean的id来执行自动装配。</p>
<h1 id="Spring的AOP"><a href="#Spring的AOP" class="headerlink" title="Spring的AOP"></a>Spring的AOP</h1><h2 id="为什么需要AOP"><a href="#为什么需要AOP" class="headerlink" title="为什么需要AOP"></a>为什么需要AOP</h2><p>AOP（Aspect Orient Programming）也就是面向切面编程，作为面向对象编程的一种补充，已经成为一种比较成熟的编程方式。其实AOP问世的时间并不太长，AOP和OOP互为补充，面向切面编程将程序运行过程分解成各个切面。</p>
<p>AOP专门用于处理系统中分布于各个模块（不同方法）中的交叉关注点的问题，在JavaEE应用中，常常通过AOP来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等，AOP已经成为一种非常常用的解决方案。</p>
<h2 id="使用AspectJ实现AOP"><a href="#使用AspectJ实现AOP" class="headerlink" title="使用AspectJ实现AOP"></a>使用AspectJ实现AOP</h2><p>AspectJ是一个基于Java语言的AOP框架，提供了强大的AOP功能，其他很多AOP框架都借鉴或采纳其中的一些思想。其主要包括两个部分：一个部分定义了如何表达、定义AOP编程中的语法规范，通过这套语法规范，可以方便地用AOP来解决Java语言中存在的交叉关注点的问题；另一个部分是工具部分，包括编译、调试工具等。</p>
<h2 id="AOP分类"><a href="#AOP分类" class="headerlink" title="AOP分类"></a>AOP分类</h2><p>AOP实现可分为两类：</p>
<h3 id="静态AOP实现-AOP框架在编译阶段对程序进行修改，即实现对目标类的增强，生成静态的AOP代理类，以AspectJ为代表。"><a href="#静态AOP实现-AOP框架在编译阶段对程序进行修改，即实现对目标类的增强，生成静态的AOP代理类，以AspectJ为代表。" class="headerlink" title="静态AOP实现: AOP框架在编译阶段对程序进行修改，即实现对目标类的增强，生成静态的AOP代理类，以AspectJ为代表。"></a>静态AOP实现: AOP框架在编译阶段对程序进行修改，即实现对目标类的增强，生成静态的AOP代理类，以AspectJ为代表。</h3><h3 id="动态AOP实现-AOP框架在运行阶段动态生成AOP代理，以实现对目标对象的增强，以Spring-AOP为代表。"><a href="#动态AOP实现-AOP框架在运行阶段动态生成AOP代理，以实现对目标对象的增强，以Spring-AOP为代表。" class="headerlink" title="动态AOP实现: AOP框架在运行阶段动态生成AOP代理，以实现对目标对象的增强，以Spring AOP为代表。"></a>动态AOP实现: AOP框架在运行阶段动态生成AOP代理，以实现对目标对象的增强，以Spring AOP为代表。</h3><p>一般来说，静态AOP实现具有较好的性能，但需要使用特殊的编译器。动态AOP实现是纯Java实现，因此无须特殊的编译器，但是通常性能略差。</p>
<h2 id="AOP的基本概念"><a href="#AOP的基本概念" class="headerlink" title="AOP的基本概念"></a>AOP的基本概念</h2><p>关于面向切面编程的一些术语：</p>
<ul>
<li><p>切面（Aspect）: 切面用于组织多个Advice，Advice放在切面中定义。</p>
</li>
<li><p>连接点（Joinpoint）: 程序执行过程中明确的点，如方法的调用，或者异常的抛出。在Spring AOP中，连接点总是方法的调用。</p>
</li>
<li><p>增强处理（Advice）: AOP框架在特定的切入点执行的增强处理。处理有”around”、”before”和”after”等类型</p>
</li>
<li><p>切入点（Pointcut）: 可以插入增强处理的连接点。简而言之，当某个连接点满足指定要求时，该连接点将被添加增强处理，该连接点也就变成了切入点。</p>
</li>
</ul>
<h2 id="Spring的AOP支持"><a href="#Spring的AOP支持" class="headerlink" title="Spring的AOP支持"></a>Spring的AOP支持</h2><p>Spring中的AOP代理由Spring的IoC容器负责生成、管理，其依赖关系也由IoC容器负责管理。<br>为了在应用中使用@AspectJ支持，Spring需要添加三个库：</p>
<ul>
<li><p>aspectjweaver.jar</p>
</li>
<li><p>aspectjrt.jar</p>
</li>
<li><p>aopalliance.jar</p>
</li>
</ul>
<p>并在Spring配置文件中做如下配置：</p>
<pre><code>&lt;!--启动@AspectJ支持--&gt;
&lt;aop:aspectj-autoproxy/&gt;

&lt;!--指定自动搜索Bean组件、自动搜索切面类--&gt;
&lt;context:component-scan base-package=&quot;edu.shu.sprint.service&quot;&gt;
    &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.aspectj.lang.annotation.Aspect&quot;/&gt;
&lt;/context:component-scan&gt;</code></pre><p><a href="http://codepub.cn/2015/06/21/Basic-knowledge-summary-of-Spring/" target="_blank" rel="noopener">来源</a></p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>My New Post</title>
    <url>/2018/04/20/My-New-Post/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Ubuntu Linux下安装软件方法</title>
    <url>/2018/04/20/Ubuntu-Linux%E4%B8%8B%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="引用-https-www-linuxidc-com-Linux-2015-01-111216-htm"><a href="#引用-https-www-linuxidc-com-Linux-2015-01-111216-htm" class="headerlink" title="引用: https://www.linuxidc.com/Linux/2015-01/111216.htm"></a>引用: <a href="https://www.linuxidc.com/Linux/2015-01/111216.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2015-01/111216.htm</a></h2><pre><code>Linux系统中,软件通常以源代码或者编译包的形式提供.

(1)源代码需要编译为二进制的机器码才能够使用,安装比较
耗时,不过您可以自行调节编译选项,决定需要的功能或组
件,或者针对硬件平台做一些优化.

(2)预编译的软件包,通常是由软件的发布者进行编译,您只要
将软件拷贝到系统中就可以了.考虑到预编译软件包的适用性
,预编译软件通常不会针对某种硬件平台优化.它所包含的功能
和组件也是通用的组合.</code></pre><h2 id="1-deb包的安装方式"><a href="#1-deb包的安装方式" class="headerlink" title="1 deb包的安装方式"></a>1 deb包的安装方式</h2><pre><code>deb是debian系Linux的包管理方式,Ubuntu是属于debian系的
Linux发行版,所以默认支持这种软件安装方式,当下载到一个
deb格式的软件后,在终端输入这个命令就能安装:

sudo dpkg -i *.deb

或者直接双击安装.</code></pre><h2 id="2-编译安装方式"><a href="#2-编译安装方式" class="headerlink" title="2 编译安装方式"></a>2 编译安装方式</h2><pre><code>(小贴士: 使用编译安装前,需要建立编译环境,使用一下命令建立
基本的编译环境: sudo apt-get install bulid-essential)

在Linux的世界,有很多软件只提供了源代码给你,需要你自己进行
编译安装,一般开源的软件都会使用tar.gz压缩档来进行发布,当然
还有其他的形式,拿到源代码的压缩文档,把它解压缩到/tmp目录下
,进入/tmp/软件目录,然后执行下三个命令:</code></pre><ul>
<li><p>1 ./configure</p>
</li>
<li><p>2 make </p>
</li>
<li><p>3 sudo make install</p>
<p>在第一步./configure时可能会提示说某某软件找不到,例如提示”libgnome”<br>这个开发包找不到,那就把libgnome这个关键词copy,然后打开新立得软件管<br>理器,在里面搜索libgnome这个关键词,就会找到libgnome相关的项目,把前<br>面有个ubuntu符号的libgnome包(注意:同样需要安装dev包,但可以不装doc<br>包)全部安装,通过这个方法把./configure过程中缺失的开发包全部装上就<br>ok了,第一步顺利通过,第二三步基本问题不大.</p>
</li>
</ul>
<h2 id="3-apt-get安装方法"><a href="#3-apt-get安装方法" class="headerlink" title="3 apt-get安装方法"></a>3 apt-get安装方法</h2><pre><code>ubuntu世界有许多软件源,在系统安装篇已经介绍过如何添加源,apt-get的基本
软件安装命令是:

sudo apt-get install 软件名</code></pre><h2 id="4-新立得软件包管理"><a href="#4-新立得软件包管理" class="headerlink" title="4 新立得软件包管理"></a>4 新立得软件包管理</h2><pre><code>打开: 系统 --系统管理--新立得软件包管理,这个工具其实跟apt一样,可以搜索
,下载,安装ubuntu源里的软件,具体安装方式很简单,看看界面应该会懂,就不详细
介绍了.</code></pre><h2 id="5-二进制包的安装方式"><a href="#5-二进制包的安装方式" class="headerlink" title="5 二进制包的安装方式"></a>5 二进制包的安装方式</h2><pre><code>有不少开源的商业软件都会采用这种方式发布Linux软件,例如google earth,拿到
二进制软件后,把它放到/tmp目录,在终端下进入安装目录,在安装目录下执行:

./软件名

然后按照一步步提示,就能安装该软件.例如安装realplayer播放器:你直接到官网
http://www.real.com/linux 下载RealPayer的安装包,安装包是.bin格式,用如下
命令安装:

chomd +x RealPlayer11GOLD.bin

./RealPlayer11GOLD.bin</code></pre><h2 id="6-rpm包的安装方式"><a href="#6-rpm包的安装方式" class="headerlink" title="6 rpm包的安装方式"></a>6 rpm包的安装方式</h2><pre><code>rpm 包是deb包最常见的一种管理方式,但ubuntu同样可以使用rpm的软件资源.首先
我们安装一个rpm转deb的软件

sudo apt-get install alien

然后就可以对rpm格式的软件转换成deb格式了:

alien -d *.rpm

然后就可以用deb的安装方式进行软件安装.也可以不需转换而直接对rpm包进行安装:

alien -i *.rpm

更多的alien使用方法可以用-h参数查看相应说明文档.</code></pre><h2 id="7-其他安装方式"><a href="#7-其他安装方式" class="headerlink" title="7 其他安装方式"></a>7 其他安装方式</h2><pre><code>其他安装方式一般还有脚本安装方式,这类软件,你会在安装目录下发现类似后缀名的文件
,如: .sh .py .run等的,有的甚至连后缀名都没有,直接一个INSTALL文件,对于这种软件,
可以尝试以下几种方式安装:
最简单的就是直接在软件目录下输入: ./软件名*(注意有一个*号,那是一般可以通配所有
后缀名)
或者: sh 软件名.sh
或者: python软件名.py

TIP:如以上方法均无法安装软件,可以参考软件源代码下面的README文档.</code></pre>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL · 特性分析 · 到底是谁执行了FTWRL</title>
    <url>/2020/04/28/MySQL-%C2%B7-%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90-%C2%B7-%E5%88%B0%E5%BA%95%E6%98%AF%E8%B0%81%E6%89%A7%E8%A1%8C%E4%BA%86FTWL/</url>
    <content><![CDATA[<h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><pre><code>FTWRL是flush table with read lock的简称。
该命令主要用于保证备份一致性备份 
全局读锁(lock_global_read_lock) 会导致所有的更新操作被堵塞
全局COMMIT锁(make_global_read_lock_block_commit) 会导致所有的活跃事务无法提交
FLUSH TABLES WITH READ LOCK执行后整个系统会一直处于只读状态，直到显示执行UNLOCK TABLES。这点请切记。</code></pre><h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><p><img src="tmp.png" alt=""></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring常见问题总结</title>
    <url>/2020/04/10/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>Spring常见问题总结</p>
<p><a href="https://mp.weixin.qq.com/s/wcK2qsZxKDJTLIGqEIyaNg" target="_blank" rel="noopener">引用自</a></p>
<h1 id="1-什么是-Spring-框架"><a href="#1-什么是-Spring-框架" class="headerlink" title="1 什么是 Spring 框架?"></a>1 什么是 Spring 框架?</h1><p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。</p>
<h1 id="2-Spring-官网列出的-Spring-的-6-个特征"><a href="#2-Spring-官网列出的-Spring-的-6-个特征" class="headerlink" title="2 Spring 官网列出的 Spring 的 6 个特征:"></a>2 Spring 官网列出的 Spring 的 6 个特征:</h1><p>  核心技术 ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。<br>  测试 ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。<br>  数据访问 ：事务，DAO支持，JDBC，ORM，编组XML。<br>  Web支持 : Spring MVC和Spring WebFlux Web框架。<br>  集成 ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。<br>  语言 ：Kotlin，Groovy，动态语言。</p>
<h1 id="3-列举一些重要的Spring模块？"><a href="#3-列举一些重要的Spring模块？" class="headerlink" title="3 列举一些重要的Spring模块？"></a>3 列举一些重要的Spring模块？</h1><p>  Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。<br>  Spring Aspects ：该模块为与AspectJ的集成提供支持。<br>  Spring AOP ：提供了面向切面的编程实现。<br>  Spring JDBC : Java数据库连接。<br>  Spring JMS ：Java消息服务。<br>  Spring ORM : 用于支持Hibernate等ORM工具。<br>  Spring Web : 为创建Web应用程序提供支持。<br>  Spring Test : 提供了对 JUnit 和 TestNG 测试的支持。</p>
<h1 id="4-RestController-vs-Controller"><a href="#4-RestController-vs-Controller" class="headerlink" title="4 @RestController vs @Controller"></a>4 @RestController vs @Controller</h1><p>  Controller 返回一个页面<br>    对应于前后端不分离的情况。<br>    如果你需要在Spring4之前开发 RESTful Web服务的话，你需要使用@Controller 并结合@ResponseBody注解，也就是说@Controller +@ResponseBody= @RestController（Spring 4 之后新加的注解）。<br>  @RestController 返回JSON 或 XML 形式数据<br>    前后端分离</p>
<h1 id="5-谈谈自己对于-Spring-IoC-和-AOP-的理解"><a href="#5-谈谈自己对于-Spring-IoC-和-AOP-的理解" class="headerlink" title="5 谈谈自己对于 Spring IoC 和 AOP 的理解"></a>5 谈谈自己对于 Spring IoC 和 AOP 的理解</h1><p>  IoC（Inverse of Control:控制反转）是一种设计思想<br>  将原本在程序中手动创建对象的控制权，交由Spring框架来管理<br>  IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。<br>   IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。<br>  AOP(Aspect-Oriented Programming:面向切面编程<br>  事务处理、日志管理、权限控制<br>  减少系统的重复代码，降低模块间的耦合度<br>  Spring AOP就是基于动态代理的<br>    如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib ，这时候Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理</p>
<h1 id="6-Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#6-Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="6 Spring AOP 和 AspectJ AOP 有什么区别？"></a>6 Spring AOP 和 AspectJ AOP 有什么区别？</h1><p>  Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。<br>  Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。<br>  Spring AOP 已经集成了 AspectJ<br>  AspectJ 相比于 Spring AOP 功能更加强大<br>  Spring AOP 相对来说更简单，<br>  切面比较少，那么两者性能差异不大<br>  当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p>
<h1 id="7-Spring-中的-bean-的作用域有哪些"><a href="#7-Spring-中的-bean-的作用域有哪些" class="headerlink" title="7 Spring 中的 bean 的作用域有哪些?"></a>7 Spring 中的 bean 的作用域有哪些?</h1><p>  singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。<br>  prototype : 每次请求都会创建一个新的 bean 实例。<br>  request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。<br>  session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。<br>  global-session：全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</p>
<h1 id="8-Spring-中的单例-bean-的线程安全问题了解吗？"><a href="#8-Spring-中的单例-bean-的线程安全问题了解吗？" class="headerlink" title="8 Spring 中的单例 bean 的线程安全问题了解吗？"></a>8 Spring 中的单例 bean 的线程安全问题了解吗？</h1><p>  当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题<br>  在Bean对象中尽量避免定义可变的成员变量（不太现实）。<br>  在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</p>
<h1 id="9-Spring-中的-bean-生命周期"><a href="#9-Spring-中的-bean-生命周期" class="headerlink" title="9 Spring 中的 bean 生命周期?"></a>9 Spring 中的 bean 生命周期?</h1><p>  Bean 容器找到配置文件中 Spring Bean 的定义。<br>  Bean 容器利用 Java Reflection API 创建一个Bean的实例。<br>  如果涉及到一些属性值 利用 set()方法设置一些属性值。<br>  如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入Bean的名字。<br>  如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。<br>  如果Bean实现了 BeanFactoryAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoade r对象的实例。<br>  与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。<br>  如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法<br>  如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。<br>  如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。<br>  如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法<br>  当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。<br>  当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</p>
<h1 id="10-说说自己对于-Spring-MVC-了解"><a href="#10-说说自己对于-Spring-MVC-了解" class="headerlink" title="10 说说自己对于 Spring MVC 了解?"></a>10 说说自己对于 Spring MVC 了解?</h1><p>  Model1 时代<br>    整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作<br>    ①将控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；<br>    ②前端和后端相互依赖，难以进行测试并且开发效率极低；<br>  Model2 时代即JavaWeb MVC<br>    “Java Bean(Model)+ JSP（View,）+Servlet（Controller）<br>    重复造轮子<br>    应运而生比如Struts2但是 Struts2 比较笨重<br>    Spring MVC 使用更加简单和方便<br>    开发效率更高，并且 Spring MVC 运行速度更快。<br>  SpringMVC 工作原理</p>
<p>  流程说明（重要）：<br>    1：客户端（浏览器）发送请求，直接请求到 DispatcherServlet。<br>    2： DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。<br>    3： 解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。<br>    4：HandlerAdapter 会根据 Handler来调用真正的处理器开处理请求，并处理相应的业务逻辑。<br>    5： 处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。<br>    6： ViewResolver 会根据逻辑 View 查找实际的 View。<br>    7：DispaterServlet 把返回的 Model 传给 View（视图渲染）。<br>    8：把 View 返回给请求者（浏览器）</p>
<h1 id="11-Spring-框架中用到了哪些设计模式？"><a href="#11-Spring-框架中用到了哪些设计模式？" class="headerlink" title="11 Spring 框架中用到了哪些设计模式？"></a>11 Spring 框架中用到了哪些设计模式？</h1><p>  工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。<br>  代理设计模式 : Spring AOP 功能的实现。<br>  单例设计模式 : Spring 中的 Bean 默认都是单例的。<br>  模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。<br>  包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。<br>  观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。<br>  适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。</p>
<h1 id="12-Component-和-Bean-的区别是什么？"><a href="#12-Component-和-Bean-的区别是什么？" class="headerlink" title="12 @Component 和 @Bean 的区别是什么？"></a>12 @Component 和 @Bean 的区别是什么？</h1><p>  作用对象不同: @Component 注解作用于类，而@Bean注解作用于方法。<br>  @Component通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了Spring这是某个类的示例，当我需要用它的时候还给我。<br>  @Bean 注解比 Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。</p>
<h1 id="13-将一个类声明为Spring的-bean-的注解有哪些"><a href="#13-将一个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="13 将一个类声明为Spring的 bean 的注解有哪些?"></a>13 将一个类声明为Spring的 bean 的注解有哪些?</h1><p>  使用 @Autowired 注解自动装配 bean<br>  @Component ：通用的注解，可标注任意类为 Spring 组件。如果一个Bean不知道属于哪个层，可以使用@Component 注解标注。<br>  @Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。<br>  @Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。<br>  @Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</p>
<h1 id="14-Spring-管理事务的方式有几种？"><a href="#14-Spring-管理事务的方式有几种？" class="headerlink" title="14 Spring 管理事务的方式有几种？"></a>14 Spring 管理事务的方式有几种？</h1><p>  编程式事务，在代码中硬编码。(不推荐使用)<br>  声明式事务，在配置文件中配置（推荐使用）<br>    基于XML的声明式事务<br>    基于注解的声明式事务</p>
<h1 id="15-Spring-事务中的隔离级别有哪几种"><a href="#15-Spring-事务中的隔离级别有哪几种" class="headerlink" title="15 Spring 事务中的隔离级别有哪几种?"></a>15 Spring 事务中的隔离级别有哪几种?</h1><p>  TransactionDefinition.ISOLATION_DEFAULT<br>    使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.<br>  TransactionDefinition.ISOLATION_READ_UNCOMMITTED<br>    最低的隔离级别，允许读取尚未提交的数据变更<br>    可能会导致脏读、幻读或不可重复读<br>  TransactionDefinition.ISOLATION_READ_COMMITTED<br>    允许读取并发事务已经提交的数据<br>    可以阻止脏读，但是幻读或不可重复读仍有可能发生<br>  TransactionDefinition.ISOLATION_REPEATABLE_READ<br>    对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改<br>    可以阻止脏读和不可重复读，但幻读仍有可能发生。<br>  TransactionDefinition.ISOLATION_SERIALIZABLE<br>    最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，<br>    该级别可以防止脏读、不可重复读以及幻读<br>    严重影响程序的性能。通常情况下也不会用到该级别。</p>
<h1 id="16-Spring-事务中哪几种事务传播行为"><a href="#16-Spring-事务中哪几种事务传播行为" class="headerlink" title="16 Spring 事务中哪几种事务传播行为?"></a>16 Spring 事务中哪几种事务传播行为?</h1><p>  支持当前事务的情况：<br>    TransactionDefinition.PROPAGATION_REQUIRED<br>        如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。<br>    TransactionDefinition.PROPAGATION_SUPPORTS<br>        如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。<br>    TransactionDefinition.PROPAGATION_MANDATORY<br>        如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）<br>  不支持当前事务的情况：<br>    TransactionDefinition.PROPAGATION_REQUIRES_NEW<br>        创建一个新的事务，如果当前存在事务，则把当前事务挂起。<br>    TransactionDefinition.PROPAGATION_NOT_SUPPORTED<br>         以非事务方式运行，如果当前存在事务，则把当前事务挂起。<br>    TransactionDefinition.PROPAGATION_NEVER<br>        以非事务方式运行，如果当前存在事务，则抛出异常。<br>  其他情况：<br>    TransactionDefinition.PROPAGATION_NESTED<br>        如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</p>
<h1 id="17-Transactional-rollbackFor-Exception-class-注解了解吗？"><a href="#17-Transactional-rollbackFor-Exception-class-注解了解吗？" class="headerlink" title="17 @Transactional(rollbackFor = Exception.class)注解了解吗？"></a>17 @Transactional(rollbackFor = Exception.class)注解了解吗？</h1><p>  Exception分为运行时异常RuntimeException和非运行时异常<br>  Transactional<br>    如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚<br>    不配置rollbackFor属性，事物只会在遇到RuntimeException的时候才会回滚<br>    加上rollbackFor=Exception.class,可以让事物在遇到非运行时异常时也回滚。</p>
<h1 id="18-如何使用JPA在数据库中非持久化一个字段？"><a href="#18-如何使用JPA在数据库中非持久化一个字段？" class="headerlink" title="18 如何使用JPA在数据库中非持久化一个字段？"></a>18 如何使用JPA在数据库中非持久化一个字段？</h1><p>  static 修饰<br>  final 修饰<br>  transient 修饰<br>  @Transient 注解修饰</p>
<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.png" alt="">  </p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 远程连接22端口</title>
    <url>/2018/04/23/Ubuntu-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A522%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="安装OpenSSH"><a href="#安装OpenSSH" class="headerlink" title="安装OpenSSH"></a>安装OpenSSH</h2><h3 id="Ubuntu缺省没有安装SSH-Server-使用以下命令安装"><a href="#Ubuntu缺省没有安装SSH-Server-使用以下命令安装" class="headerlink" title="Ubuntu缺省没有安装SSH Server,使用以下命令安装:"></a>Ubuntu缺省没有安装SSH Server,使用以下命令安装:</h3><h3 id="sudo-apt-get-install-openssh-server-openssh-client"><a href="#sudo-apt-get-install-openssh-server-openssh-client" class="headerlink" title="sudo apt-get install openssh-server openssh-client"></a>sudo apt-get install openssh-server openssh-client</h3><h3 id="配置完成后重启命令"><a href="#配置完成后重启命令" class="headerlink" title="配置完成后重启命令"></a>配置完成后重启命令</h3><h3 id="sudo-etc-init-d-ssh-restart"><a href="#sudo-etc-init-d-ssh-restart" class="headerlink" title="sudo /etc/init.d/ssh restart"></a>sudo /etc/init.d/ssh restart</h3>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title> WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! </title>
    <url>/2018/05/11/WARNING-REMOTE-HOST-IDENTIFICATION-HAS-CHANGED/</url>
    <content><![CDATA[<h2 id="参考-https-blog-csdn-net-nahancy-article-details-51052127"><a href="#参考-https-blog-csdn-net-nahancy-article-details-51052127" class="headerlink" title="参考: https://blog.csdn.net/nahancy/article/details/51052127"></a>参考: <a href="https://blog.csdn.net/nahancy/article/details/51052127" target="_blank" rel="noopener">https://blog.csdn.net/nahancy/article/details/51052127</a></h2><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>On branch master<br>nothing to commit, working tree clean<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!<br>Someone could be eavesdropping on you right now (man-in-the-middle attack)!<br>It is also possible that a host key has just been changed.<br>The fingerprint for the DSA key sent by the remote host is<br>SHA256:br9IjFspm1vxR3iA35FWE+4VTyz1hYVLIE2t1/CeyWQ.<br>Please contact your system administrator.<br>Add correct host key in /Users/xiongzixu/.ssh/known_hosts to get rid of this message.<br>Offending RSA key in /Users/xiongzixu/.ssh/known_hosts:1<br>DSA host key for github.com has changed and you have requested strict checking.<br>Host key verification failed.<br>fatal: Could not read from remote repository.</p>
<p>Please make sure you have the correct access rights<br>and the repository exists.</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因:"></a>原因:</h2><p>找了好久发现有篇文章里面提到.ssh/known_hosts文件,原来known_hosts是记录远程主机的公钥的文件，<br>之前更新了系统，而保存的公钥还是未重装系统的系统公钥，在ssh链接的时候首先会验证公钥，如果公钥不对，<br>那么就会报错</p>
<h2 id="解决方案-3种"><a href="#解决方案-3种" class="headerlink" title="解决方案(3种):"></a>解决方案(3种):</h2><ul>
<li><p>1: 使用shh-keygen 命令（强烈建议使用此方法）</p>
<p>   比如我们要将172.16.152.209的公钥信息清除，使用命令（请自己将172.16.152.209替换成自己的IP或域名）：</p>
</li>
<li><p>2: 将known_hosts文件中的与登录错误的IP的公钥删除即可，下图就是我的218机子的公钥（实则是之前系统的公钥），然后将其删除，再ssh 登录 great 登录成功了。     </p>
</li>
</ul>
<p><img src="https://img-blog.csdn.net/20160403214246747?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<ul>
<li>3: 将known_hosts文件中的内容清空即可，但不建议使用此方法，里面还保存有其他机子的公钥。 </li>
</ul>
]]></content>
      <categories>
        <category>异常处理</category>
      </categories>
  </entry>
  <entry>
    <title>Vagrant基本用法</title>
    <url>/2018/09/11/Vagrant%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="官网-https-www-vagrantup-com"><a href="#官网-https-www-vagrantup-com" class="headerlink" title="官网: https://www.vagrantup.com/"></a>官网: <a href="https://www.vagrantup.com/" target="_blank" rel="noopener">https://www.vagrantup.com/</a></h2><h1 id="intro-介绍"><a href="#intro-介绍" class="headerlink" title="intro 介绍"></a>intro 介绍</h1><h2 id="what-is-vagrant-流浪汉是什么"><a href="#what-is-vagrant-流浪汉是什么" class="headerlink" title="what is vagrant (流浪汉是什么)"></a>what is vagrant (流浪汉是什么)</h2><h3 id="Introduction-to-Vagrant-流浪汉简介"><a href="#Introduction-to-Vagrant-流浪汉简介" class="headerlink" title="Introduction to Vagrant (流浪汉简介)"></a>Introduction to Vagrant (流浪汉简介)</h3><pre><code>Vagrant is a tool for building and managing virtual machine
environments in a single workflow. With an easy-to-use workflow
and focus on automaiton, Vagrant lowers development setup time,
increases production parity,and makes the &quot;works on my machine&quot;
excuse a relic of the past.

if you are already familiar with the basics of Vagrant, the 
documentation provides a better reference build for all available
features and internals.

Vagrant是一种在单个工作流程中构建和管理虚拟环境的工具.通过易于使用的工
作流程并专注于自动化,Vagrant降低了开发环境的设置时间,提高了生产平价,
并使&quot;在我的假期上工作&quot;称为过去的遗留物.

如果您已经熟悉Vagrant的基础知识,那么该文档可为所有可用功能和内部提供
更好的参考构建.</code></pre><h3 id="why-Vagrant-为什么选择Vagrant"><a href="#why-Vagrant-为什么选择Vagrant" class="headerlink" title="why Vagrant (为什么选择Vagrant)"></a>why Vagrant (为什么选择Vagrant)</h3><pre><code>vagrant provides easy to configure,reproducible,and portable
work environments built on top of industry-standard technology
and controlled by a single consistent workflow to help maximize 
the productivity and flexibility of you and your team.

To achieve its magic,Vagrant stands on the shoulders of giants.
Machines are provisioned on top of VirtualBox,VMware,AWS,or any
other provider,Then,Industry-standard providioning tools such
as shell scripts,Chef,or Puppet,can automatically install and
configure software on the virtual machine.

Vagrant 提供易于配置,可重复和便携的工作环境,基于行和标准技术构建,并由单一
一致的工作流程控制,以帮助您和您的团队最大限度地提高生成力和灵魂性.

为了实现其魔力,Vagrant站在巨人的肩膀上.在VirtualBox,VMware,AWS或
任何其他提供商之上配置计算机.然后,行业标准配置工具(如shell脚本,Chef或
Puppet)可以在虚拟机上自动安装和配置软件.</code></pre><h3 id="For-Developers-对于开发者"><a href="#For-Developers-对于开发者" class="headerlink" title="For Developers (对于开发者)"></a>For Developers (对于开发者)</h3><pre><code>if you are a developer,Vagarnt will isolate dependencies and
their configuration within a single disposable,consistent 
environment,without sacrificing any of the tools you are
used to working with(editors,browsers,debuggers,etc.).Once
you or someone else creates a single Vagrantfile,you just 
need to vagrant up and everything is installed and configured
for you to work .Other members of your team create their
development environments form the same configuration,so 
whether you are working on Linux,Mac OSX,or Windows,all
your team members are running code in the same environment
,against the same dependencies,al configured the same way.
Say goodbye to &quot;works on my machine&quot;bugs.

如果您是一位开发人员,Vagrant将在一个一致的环境中隔离依赖及其配置,
而不会牺牲您习惯使用的任何工具(编辑器,浏览器,调试器等).一旦您或其他人
创建了单个Vagrant文件,您只需要运行vagrant up命令安装并配置所有内容
即可使用.团队的其他成员使用相同的配置创建他们的开发环境,因此无论您是在
Linux,Mac OS X还是Windows上工作,您的所有团队成员都在同一环境中运行
代码,针对相同的依赖项,所有组件都配置相同办法.告别&quot;在我的机器上工作&quot;的
错误.</code></pre><h3 id="For-Operators-对于运维"><a href="#For-Operators-对于运维" class="headerlink" title="For Operators (对于运维)"></a>For Operators (对于运维)</h3><pre><code>if you are an operations engineer or DevOps engineer,Vagrant
gives you a disposable environment and consisitent workflow
for developing and testing infrastructure management scripts.
you can quickly test things like shell scripts,Chef cookbooks,
Puppet modules,and more using local virtualization such as 
VirtualBox or VMware.Then,with the same configuration,you can
test these scripts on remote clouds such as AWS or RackSpace 
with the same workflow.Ditch your custom scripts to recycle
EC2 instances,stop juggling SSH prompts to various machines,
and start using Vagrant to bring sanity to your life.

如果你是运维工程师或者开发运维工程师,Vagrant为您提供一次性环境和一致的
工作流程,用于开发和测试基础架构管理脚本.您可以使用VirtualBox或VMware
等本地虚拟化快速测试shell脚本,Chef cookbook,Puppet模块等内容.然后
,使用相同的配置,您可以使用相同的工作流在远程云(如AWS或RackSpace)上测试
这些脚本.抛弃自定义脚本以回收EC2实例,停止将SSH提示传递给各种计算机,并
开始使用Vagrant为您的生活带来理智.</code></pre><h3 id="For-Designers-对于设计"><a href="#For-Designers-对于设计" class="headerlink" title="For Designers(对于设计)"></a>For Designers(对于设计)</h3><pre><code>If you are a designer,Vagrant will automatically set everything
up that is required for that web app in order for you to focus
on doing what you do best:design.Once a developer configures
Vagrant,you do not need to worry about how to get that app running
ever again.No more bothering other developers to help you fix
your environment so you can test designs.Just check out the code
,vagrant up,and start designing.

如果你是个设计师,Vagrant 将自动设置该web应用程序所需的所有内容,以便你
集中精力做你最擅长的事情:设计.当开发人员配置了一次Vagrant,你再也不用
担心怎样去运行应用程序.不必再打扰其他开发人员来帮助你修复环境,因此你能
测试你的设计.仅打出单词,vagrant up ,就可以开始设计了.</code></pre><h3 id="For-Everyone-对于任何人"><a href="#For-Everyone-对于任何人" class="headerlink" title="For Everyone(对于任何人)"></a>For Everyone(对于任何人)</h3><pre><code>Vagrant is designed for erveyone as the easiest and fastest
way to create a virtualized environment!

Vagrant 的设计对任何人来说都是最简单最快速的获取虚拟环境的方式.</code></pre><h2 id="Vagrant-vs-Other-Software-Vagrant-与其他软件的对比"><a href="#Vagrant-vs-Other-Software-Vagrant-与其他软件的对比" class="headerlink" title="Vagrant vs. Other Software (Vagrant 与其他软件的对比)"></a>Vagrant vs. Other Software (Vagrant 与其他软件的对比)</h2><pre><code>Vagrant is not the only tool to manage virtual machines
and development environments.This section compares Vagrant
to these other software choices.

Vagrant 不是唯一管理虚拟机和开发环境的工具,本节将比较Vagrant与其他
软件以便选择.

Due to the bias of the comparisons,we attempt to only use
facts.If you find something that is invalid or out of date
in the comparisons,please open an issue and we&apos;ll address
it as soon as possible.

由于比较的偏颇,我们试图只用事实说话,在比较中假如你发现了无效的或者过期
的内容,请开启一个issue,我们将尽可能的处理它.

Use the navigation on the left to read comparisons of Vagrant
versus similar software.

使用左侧导航栏去阅读Vagrant与相似软件的比较</code></pre><h3 id="CLI-Tools"><a href="#CLI-Tools" class="headerlink" title="CLI Tools"></a>CLI Tools</h3><h4 id="Vagrant-vs-CLI-Tools"><a href="#Vagrant-vs-CLI-Tools" class="headerlink" title="Vagrant vs CLI Tools"></a>Vagrant vs CLI Tools</h4><pre><code>Virtualization software like VirtualBox and VMware come with
command line utilities for managing the lifecycle of machines
on their platform.Many people make use of these utilties for 
managing the lifecycle of machines on their platform.Many people
make use of these utilities to write their own automation.
Vagrant actually uses many of these utilties internally.

虚拟化软件如VirtualBox和VMware,带有命令行工具来管理平台上的机器的生命
周期.许多人使用这些工具来写他们自己的自动化程序.Vagrant实际上在内部用了
很多这样的工具.

The difference between these CLI tool and Vagrant is that 
Vagrant builds on top of these utilties in a number of ways 
while still providing a consistent workflow.Vagrant supports
multiple provisioners to setup the machine,automatic SSH setup,
creating HTTP tunnels into your development environment,and more.
All of these can be configured using a single simple configuration
file.

这些CLI工具与Vagrant的区别在于,Vagrant以多种方式在这些实用程序之上
构建,同时仍然提供一致的工作流.Vagrant 支持多种同步文件夹类型,设置机器
的多个提供程序 自动SSH设置 创建多开发环境中的HTTP隧道等.所有这些都可以
使用一个简单的配置文件来配置.

Vagrant still has a number of improvements over manual scripting
even if you ignore all the higher-level features Vagrant provides.
The command-line utilities provided by vitualization software
often change each version or have subtle bugs with workarounds.
Vagrant automatically detects the version,uses the correct flags,
can work around known issues.So if you&apos;re using one version
of VirtualBox and a co-worker is using a different version,
Vagrant will still work consistently.

Vagrant在手动脚本方面仍有许多改进.即使你忽略了流浪汉提供的所有高级特征.
虚拟化软件提供的命令行工具经常改变每个版本或有变通方法的细微错误.
流浪汉自动检测版本,使用正确的标志,能围绕已知问题工作.
因此假如你使用一个版本的VirtualBox而另一个同事使用不同的版本,Vagrant
仍然可以一致工作.

For highly-specifil workflows that don&apos;t change often.it can
still be beneficial to maintain custom scripts .Vagrant is 
tageted at building development environments but some 
advanced users still use the ClI tools underneath to do 
other manual things.

对于不经常改变的高度特定的工作流,维护自定义脚本仍然是有益的.Vagrant
的目标是构建开发环境,但是一些高级用户仍然使用下面的CLI工具来完成
其他手动操作.</code></pre><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><h4 id="Vagrant-vs-Docker"><a href="#Vagrant-vs-Docker" class="headerlink" title="Vagrant vs. Docker"></a>Vagrant vs. Docker</h4><pre><code>Vagrant is a tool focused on providing a consistent
development environment workflow across multiple 
operating systems.Docker is a container management
that can consistently run sofeware as long as a 
containerization system exists.

Vagrant是一个专注于跨多个操作系统提供一致的开发环境工作流的工具.
Docker是一种容器管理,只要存在容器化系统,就可以始终如一地运行软件.

Containers are generally more lightweight than virtual
machines,so starting and stopping containers is extremely
fast. Most common development machines don&apos;t have a 
containerization system built-in, and Docker uses a 
virtual machine with Linux installed to provide that.

容器一般比虚拟机更轻量级,因此开启或停止容器是非常快的.大多数常见的
开发及其没有内置化的容器系统,Doker使用安装了Linux的虚拟机来提供这
一点.

Currently,Docker lacks support for certain operating
systems(such as BSD).if you target deployment is one
of these operating systems,Docker will not provide 
the same prodution parity as tool like Vagrant.Vagrant 
will allow you to run a Windows development environment
on Mac or Linux,as well.

目前,Docker缺乏对某些操作系统(如:BSD)的支持.如果你的目标是部署
这些操作系统之一,那么Docker不会像Vagrant一样提供相同的一致产品.
Vagrant允许你在Mac或Linux上运行Windows开发环境.

For microservice heavy environments,Docker can be attractive
because you can easily start a single Docker VM and start
many containers above that very quickly.This is a good use
case for Docker.Vagrant can do this as well with the Docker
provider.A primary benefit for Vagrant is a consistent
workflow but there are many cases where a pure-Docker
workflow does make sense.

Both Vagrant and Docker have a vast library of 
community-contributed &quot;images&quot;or&quot;boxes&quot;to choose from.

对于微服务繁重的环境,Docker可能很有吸引力,因为您可以单个Docker
VM 并快速启动多个容器.这是Docker的一个很好的用例.Vagrant也可以
使用Docker提供程序执行此操作.Vagrant的主要好处是一致的工作流程,
但在很多情况下,纯Docker工作流程确实有意义.

Vagrant和Docker都拥有庞大的社区贡献&quot;图像&quot;或&quot;盒子&quot;库供您选择.</code></pre><h3 id="Terraform"><a href="#Terraform" class="headerlink" title="Terraform"></a>Terraform</h3><h4 id="Vagrant-vs-Terraform"><a href="#Vagrant-vs-Terraform" class="headerlink" title="Vagrant vs. Terraform"></a>Vagrant vs. Terraform</h4>]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>vagrant</tag>
      </tags>
  </entry>
  <entry>
    <title>git回滚已经PUSH的内容</title>
    <url>/2019/08/09/git%E5%9B%9E%E6%BB%9A%E5%B7%B2%E7%BB%8FPUSH%E7%9A%84%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<p>git status </p>
<p>git log</p>
<p>git reset –hard 21e5af0fd58a456caa2727934e0aaf00</p>
<p>git push origin 分支 –force </p>
<p><a href="https://blog.csdn.net/guozhaohui628/article/details/78922946" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <tags>
        <tag>git</tag>
        <tag>回滚</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo插入图片</title>
    <url>/2019/09/06/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<ul>
<li><p>当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。</p>
<p><img src="/images/image.jpg" alt=""></p>
</li>
<li><p>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。</p>
</li>
</ul>
<pre><code>post_asset_folder: true</code></pre><p>将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。</p>
<pre><code>_posts/post_name/image.jpg
1
![](image.jpg)</code></pre><p>[参考] (<a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/" target="_blank" rel="noopener">https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/</a>)</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hex 编码</title>
    <url>/2019/08/27/hex-%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>编码</tag>
        <tag>hex</tag>
        <tag>16进制</tag>
      </tags>
  </entry>
  <entry>
    <title>gpg是什么  </title>
    <url>/2019/09/28/gpg%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h1 id="GPG简介"><a href="#GPG简介" class="headerlink" title="GPG简介"></a>GPG简介</h1><p>　　GPG是GNU Privacy Guard的缩写，它是一种基于密钥的加密方式，使用了一对密钥对消息进行加密和解密，来保证消息的安全传输。<br>　　GPG有许多用途，主要用于文件加密。yum安装软件包的时候会使用gpg来验证。</p>
<h2 id="1、大多数的linux发行版都默认包含了gpg"><a href="#1、大多数的linux发行版都默认包含了gpg" class="headerlink" title="1、大多数的linux发行版都默认包含了gpg"></a>1、大多数的linux发行版都默认包含了gpg</h2><pre><code># gpg --version</code></pre><h2 id="2、gpg常用命令"><a href="#2、gpg常用命令" class="headerlink" title="2、gpg常用命令"></a>2、gpg常用命令</h2><pre><code>创建密钥 $ gpg --gen-key

查看公钥 $ gpg --list-key

查看私钥 $ gpg --list-secret-key

公钥删除 $ gpg --delete-keys 标识名

私钥删除 $ gpg --delete-secret-keys 标识名

公钥导出 $ gpg --export 标识名 &gt; 导出文件名（多以gpg,asc为文件后缀）

私钥导出 $ gpg --export-secret-key 标识名 &gt; 导出文件名（多以asc为文件后缀）

密钥导入 $ gpg --import 密钥文件

加密文件 $ gpg --recipient 标识名 --encrypt 文件名

解密文件 $ gpg --output 新文件名 --decrypt 加密文件名

修改密钥 $ gpg --edit-key 标识名</code></pre><h2 id="3、gpg加密和ssh加密的区别"><a href="#3、gpg加密和ssh加密的区别" class="headerlink" title="3、gpg加密和ssh加密的区别"></a>3、gpg加密和ssh加密的区别</h2><p>ssh加密是专们为远程登录和其他网络服务，如ftp 提供安全的一个软件<br>gpg是用来加密文件的</p>
]]></content>
      <categories>
        <category>gpg</category>
      </categories>
      <tags>
        <tag>gpg</tag>
      </tags>
  </entry>
  <entry>
    <title>hhkb配置Mac</title>
    <url>/2018/05/07/hhkb%E9%85%8D%E7%BD%AEMac/</url>
    <content><![CDATA[<h2 id="引用https-www-douban-com-note-657191565"><a href="#引用https-www-douban-com-note-657191565" class="headerlink" title="引用https://www.douban.com/note/657191565/"></a>引用<a href="https://www.douban.com/note/657191565/" target="_blank" rel="noopener">https://www.douban.com/note/657191565/</a></h2><p>Pro2,总共有60个 按键</p>
<p>方向键为</p>
<p>上: Fn + [</p>
<p>下: Fn + /</p>
<p>左: Fn + ;</p>
<p>右: Fn + ‘</p>
<p>光标移动的快捷键就和Mac系统一致:</p>
<p>上一行: ctrl+p</p>
<p>下一行: ctrl+n</p>
<p>跳到行首: ctrl+a</p>
]]></content>
      <tags>
        <tag>键盘</tag>
        <tag>hhkb</tag>
      </tags>
  </entry>
  <entry>
    <title>idea突然有些字母不显示</title>
    <url>/2019/09/03/idea%E7%AA%81%E7%84%B6%E6%9C%89%E4%BA%9B%E5%AD%97%E6%AF%8D%E4%B8%8D%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="https://img-blog.csdn.net/20171031204114987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUGV0ZXJzaHVzaGVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>解决方案：更换idea字体，点击apply按钮即可正常显示<br><img src="https://liuyanzhao.com/wp-content/uploads/2018/10/WX20181011-211337@2x.png" alt=""></p>
<p><a href="https://blog.csdn.net/Petershusheng/article/details/78407839" target="_blank" rel="noopener">参考1</a></p>
<p><a href="https://liuyanzhao.com/8867.html" target="_blank" rel="noopener">参考2</a></p>
]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>homestead 安装PHP mongo 扩展</title>
    <url>/2018/12/17/homestead-%E5%AE%89%E8%A3%85PHP-mongo-%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h1 id="解决痛点-homestead多个PHP版本-某个版本安装mongo扩展"><a href="#解决痛点-homestead多个PHP版本-某个版本安装mongo扩展" class="headerlink" title="解决痛点: homestead多个PHP版本,某个版本安装mongo扩展"></a>解决痛点: homestead多个PHP版本,某个版本安装mongo扩展</h1><h2 id="1-进入虚拟机"><a href="#1-进入虚拟机" class="headerlink" title="1. 进入虚拟机"></a>1. 进入虚拟机</h2><pre><code>vagrant ssh</code></pre><h2 id="2-切换到管理员"><a href="#2-切换到管理员" class="headerlink" title="2. 切换到管理员"></a>2. 切换到管理员</h2><pre><code>sudo su     </code></pre><h2 id="3-查看PHP版本路径"><a href="#3-查看PHP版本路径" class="headerlink" title="3. 查看PHP版本路径"></a>3. 查看PHP版本路径</h2><pre><code>// 选择你要安装的PHP版本(我是PHP5.6)
php --ini 
或
find / -name php.ini
返回
/etc/php/7.1/cli/php.ini
/etc/php/7.1/fpm/php.ini
/etc/php/7.2/cli/php.ini
/etc/php/7.2/fpm/php.ini
/etc/php/7.0/cli/php.ini
/etc/php/7.0/fpm/php.ini
/etc/php/5.6/cli/php.ini
/etc/php/5.6/fpm/php.ini</code></pre><h2 id="4-进入工作目录-这个随意-我习惯进入-etc-php-5-6"><a href="#4-进入工作目录-这个随意-我习惯进入-etc-php-5-6" class="headerlink" title="4. 进入工作目录(这个随意,我习惯进入/etc/php/5.6)"></a>4. 进入工作目录(这个随意,我习惯进入/etc/php/5.6)</h2><pre><code>cd /etc/php/5.6</code></pre><h2 id="5-下载php-mongo扩展"><a href="#5-下载php-mongo扩展" class="headerlink" title="5.下载php mongo扩展"></a>5.下载php mongo扩展</h2><pre><code>git clone https://github.com/mongodb/mongo-php-driver-legacy.git</code></pre><h2 id="6-进入下载的目录"><a href="#6-进入下载的目录" class="headerlink" title="6. 进入下载的目录"></a>6. 进入下载的目录</h2><pre><code>cd mongo-php-driver-legacy/</code></pre><h2 id="7-选择对应的扩展"><a href="#7-选择对应的扩展" class="headerlink" title="7. 选择对应的扩展"></a>7. 选择对应的扩展</h2><pre><code>// 参考文档
https://docs.mongodb.com/ecosystem/drivers/php/#drivers

git branch -a

git checkout v1.6</code></pre><h2 id="8-编译PHP的mongo扩展"><a href="#8-编译PHP的mongo扩展" class="headerlink" title="8. 编译PHP的mongo扩展"></a>8. 编译PHP的mongo扩展</h2><pre><code>//（不同php版本的情况下phpize版本不同）
/usr/bin/phpize5.6 

//（这里边也需要根据情况指定php-config的版本，且和phpize的版本保持一致。）
./configure --with-php-config=/usr/bin/php-config5.6 

make &amp;&amp; make install </code></pre><ul>
<li>编译完成后，mongo的php扩展在module目录中，它的文件名是mongo.so*</li>
</ul>
<h2 id="9-查看php的extension-dir"><a href="#9-查看php的extension-dir" class="headerlink" title="9. 查看php的extension_dir"></a>9. 查看php的extension_dir</h2><pre><code>/usr/bin/php5.6 -i|grep extension_dir

返回 extension_dir =&gt; /usr/lib/php/20131226 =&gt; /usr/lib/php/20131226</code></pre><ul>
<li>这说明php的扩展目录是/usr/lib/php/20131226</li>
<li>或者你用phpinfo()输出一个页面，在里面找extension_dir也可以找到*</li>
</ul>
<h2 id="10-把mongo-so扩展模块移入php扩展目录中"><a href="#10-把mongo-so扩展模块移入php扩展目录中" class="headerlink" title="10. 把mongo.so扩展模块移入php扩展目录中"></a>10. 把mongo.so扩展模块移入php扩展目录中</h2><pre><code>mv ./module/mongo.so /usr/lib/php/20131226  </code></pre><ul>
<li>注意，前提要求当前工作目录是在刚才编译的mongo-php-driver-legacy目录中</li>
</ul>
<h2 id="11-添加php配置文件的ini文件"><a href="#11-添加php配置文件的ini文件" class="headerlink" title="11. 添加php配置文件的ini文件"></a>11. 添加php配置文件的ini文件</h2><pre><code>sudo touch /etc/php/5.6/fpm/conf.d/20-mongo.ini</code></pre><h2 id="12-使用vi编辑器写入如下内容"><a href="#12-使用vi编辑器写入如下内容" class="headerlink" title="12. 使用vi编辑器写入如下内容"></a>12. 使用vi编辑器写入如下内容</h2><pre><code>vim /etc/php/5.6/fpm/conf.d/20-mongo.ini

extension=mongo.so</code></pre><ul>
<li>记得使用vi编辑器时使用：wq命令保存</li>
</ul>
<h2 id="13-重启PHP"><a href="#13-重启PHP" class="headerlink" title="13. 重启PHP"></a>13. 重启PHP</h2><pre><code>service php5.6-fpm restart</code></pre>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>homestead</tag>
        <tag>mongo</tag>
        <tag>php扩展</tag>
      </tags>
  </entry>
  <entry>
    <title>idea将普通Java项目改为Maven项目</title>
    <url>/2019/09/04/idea%E5%B0%86%E6%99%AE%E9%80%9AJava%E9%A1%B9%E7%9B%AE%E6%94%B9%E4%B8%BAMaven%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="方式-1"><a href="#方式-1" class="headerlink" title="方式 1"></a>方式 1</h1><p>1 在项目右键 Add Framework Support</p>
<p>2 选择maven</p>
<h1 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h1><p>1.右键工程文件，新建文件pom.xml，并填写好内容。</p>
<p>2.在pom.xml 文件上右键 Add as Maven Project。</p>
<p>3.idea自己导入maven。</p>
<h1 id="怎么在pom-xml中添加项目中libs下的jar呢，而不是从本地仓库中添加？"><a href="#怎么在pom-xml中添加项目中libs下的jar呢，而不是从本地仓库中添加？" class="headerlink" title="怎么在pom.xml中添加项目中libs下的jar呢，而不是从本地仓库中添加？"></a>怎么在pom.xml中添加项目中libs下的jar呢，而不是从本地仓库中添加？</h1><p>1、首先将要添加的jar包复制到项目中的libs文件夹下</p>
<p>2、然后在pom.xml中添加如下代码：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;htmlunit&lt;/groupId&gt;
    &lt;artifactId&gt;htmlunit&lt;/artifactId&gt;
    &lt;version&gt;2.21-OSGi&lt;/version&gt;
    &lt;scope&gt;system&lt;/scope&gt;
    &lt;systemPath&gt;${project.basedir}/libs/htmlunit-2.21-OSGi.jar&lt;/systemPath&gt;
&lt;/dependency&gt;</code></pre><p>注意scope元素和systemPath元素，其中systemPath元素指定的就是jar包在项目中的路径。<br>注意libs文件夹下的这个jar包不需要Add to Build Path</p>
<p><a href="https://blog.csdn.net/zhengxiangwen/article/details/50734565" target="_blank" rel="noopener">参考1</a><br><a href="https://blog.csdn.net/lcgoing/article/details/86928738" target="_blank" rel="noopener">参考2</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title> java.io.EOFException</title>
    <url>/2019/09/06/java-io-EOFException/</url>
    <content><![CDATA[<p>Caused by: java.io.EOFException: Can not read response from server. Expected to read 4 bytes, read 0 bytes before connection was unexpectedly lost.</p>
<p>启动ssm项目报上述错误,查了一堆答案</p>
<p>有说改 jdbc配置的,有说改数据库的<br>顺便还改了下数据库</p>
<pre><code>show variables like  &apos;wait_timeout&apos;;

show global variables like  &apos;%wait%&apos;;        

set wait_timeout=86400;</code></pre><p>问题都没有解决</p>
<p>最终解决方案:</p>
<p>可能是防火墙,翻墙软件等造成的</p>
]]></content>
      <categories>
        <category>exception</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>java 内存模型与volatile关键字</title>
    <url>/2020/04/27/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8Evolatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p><a href="https://xzh20121116.github.io/post/VPO1pZnCC/" target="_blank" rel="noopener">摘自</a></p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="what（是什么）"><a href="#what（是什么）" class="headerlink" title="what（是什么）"></a>what（是什么）</h2><p>一种抽象概念，是一种规则，描述了Java线程间通信的访问方式。<br>规定了主内存，工作内存（线程本地内存）之间通行的规则。<br>所有线程都可以访问（读取）主内存的资源，然后将主内存的资源拷贝到自己的工作内存，修改时先修改自己的工作内存，然后将工作内存的资源拷贝到主内存，所有线程都不可直接对主内存进行写入。他们只能直接操作自己的工作内存。</p>
<pre><code>1 一个线程加锁前必须将主内存中的值刷新到自己的工作内存
2 一个线程解锁前必须将自己工作内存中的值刷新到主内存
3 加解锁必须是同一个锁</code></pre><h2 id="主内存与工作内存之间的关系8种"><a href="#主内存与工作内存之间的关系8种" class="headerlink" title="主内存与工作内存之间的关系8种"></a>主内存与工作内存之间的关系8种</h2><pre><code>1 lock 作用于主内存 即保证资源被一个线程独享
2 unlock 作用于主内存 释放一个资源
3 read 作用于主内存 将一个资源从主内存传输到工作内存
4 load 作用于工作内存 将读取的资源加载到工作内存
5 use 工作内存 使用资源以用于显示，传递等
6 assign 工作内存 赋值 将从控制引擎得到的值赋值给工作内存
7 store 工作内存 将赋值的值写入存储到工作内存
8 write 主内存 将存储的值 刷新到主内存</code></pre><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><pre><code>原子性 一个操作是不可中断的，即多个线程操作时，一个线程的操作也是不可被打断的，直到操作完成。
可见性 对主内存的修改，其他线程都能第一时间看到,多线程有问题
有序性 理想状态是一条一条执行的，但因重排序（指令重拍的存在）顾不是有序的</code></pre><h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><h2 id="保证了两大特性"><a href="#保证了两大特性" class="headerlink" title="保证了两大特性"></a>保证了两大特性</h2><pre><code>有序性
可见性</code></pre><h2 id="有序性原理"><a href="#有序性原理" class="headerlink" title="有序性原理"></a>有序性原理</h2><p>当操作由volatile修饰的变量时，jvm会向控制器发送一条带有lock前缀的指令，该指令实际上就形成了一个内存屏障，有效隔离了变量前及变量后的操作，防止了指令重排序。从而实现了有序性</p>
<h2 id="可见性原理"><a href="#可见性原理" class="headerlink" title="可见性原理"></a>可见性原理</h2><p>lock指令保证了工作内存变量值得有效性，即其他工作内存变量值得无效性。</p>
<h1 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h1><p><img src="java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E3%80%81volatile%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt=""></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>learning-hexo</title>
    <url>/2018/03/29/learning-hexo/</url>
    <content><![CDATA[<h2 id="this-is-a-test"><a href="#this-is-a-test" class="headerlink" title="this is a test"></a>this is a test</h2><ul>
<li>test</li>
</ul>
<h2 id="chapter-1"><a href="#chapter-1" class="headerlink" title="chapter 1"></a>chapter 1</h2><h2 id="chapter-2"><a href="#chapter-2" class="headerlink" title="chapter 2"></a>chapter 2</h2>]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>java 面试</title>
    <url>/2020/02/01/java-%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p><a href="https://www.javanav.com/interview/93b0069472fd479393006c0e73043fc4.html" target="_blank" rel="noopener">摘自</a></p>
<h1 id="基础与语法"><a href="#基础与语法" class="headerlink" title="基础与语法"></a>基础与语法</h1><h2 id="1-jdk-jre-区别"><a href="#1-jdk-jre-区别" class="headerlink" title="1 jdk jre 区别"></a>1 jdk jre 区别</h2><p>JRE：Java Runtime Environment（ java 运行时环境）。即java程序的运行时环境，包含了 java 虚拟机，java基础类库。</p>
<p>JDK：Java Development Kit（ java 开发工具包）。即java语言编写的程序所需的开发工具包。JDK 包含了 JRE，同时还包括 java 源码的编译器 javac、监控工具 jconsole、分析工具 jvisualvm等。</p>
<h2 id="2-和equals的区别是什么"><a href="#2-和equals的区别是什么" class="headerlink" title="2 ==和equals的区别是什么?"></a>2 ==和equals的区别是什么?</h2><p> == 的作用：</p>
<ul>
<li><p>基本类型：比较值是否相等</p>
</li>
<li><p>引用类型：比较内存地址值是否相等</p>
<p>equals() 的作用:<br>引用类型：默认情况下比较的是内存地址是否相等。可以按照需求逻辑，重写对象的equals（）方法（重写 equals() 方法，一般须重写 hashCode() 方法）。</p>
</li>
</ul>
<h2 id="3-基本类型和包装类对象使用-和-equals进行比较的结果？"><a href="#3-基本类型和包装类对象使用-和-equals进行比较的结果？" class="headerlink" title="3 基本类型和包装类对象使用 == 和 equals进行比较的结果？"></a>3 基本类型和包装类对象使用 == 和 equals进行比较的结果？</h2><p>1、值不同，使用 ＝＝ 和 equals() 比较都返回 false</p>
<p>2、值相同</p>
<p>使用 ＝＝ 比较：</p>
<ul>
<li>基本类型 － 基本类型、基本类型 － 包装对象返回 true</li>
<li>包装对象 － 包装对象返回 false</li>
<li>缓存中取的包装对象比较返回 true（原因是 JVM 缓存部分基本类型常用的包装类对象，如 Integer -128 ~ 127 是被缓存的）</li>
</ul>
<pre><code>Integer i1 = 100;
Integer i2 = 100;
Integer i3 = 200;
Integer i4 = 200;

System.out.println(i1==i2); //打印true
System.out.println(i3==i4); //打印false </code></pre><p>使用 equals() 比较</p>
<ul>
<li>包装对象－基本类型返回 true</li>
<li>包装对象－包装对象返回 true</li>
</ul>
<p>3、不同类型的对象对比，返回 false</p>
<p>JDK1.8，实验代码</p>
<pre><code>byte b1 = 127;
Byte b2 = new Byte(&quot;127&quot;);
Byte b3 = new Byte(&quot;127&quot;);
System.out.println(&quot;Byte 基本类型和包装对象使用 == 比较 : &quot; + (b1 == b2));
System.out.println(&quot;Byte 基本类型和包装对象使用 equals 比较 : &quot; + b2.equals(b1));
System.out.println(&quot;Byte 包装对象和包装对象使用 == 比较 : &quot; + (b2 == b3));
System.out.println(&quot;Byte 包装对象和包装对象使用 equals 比较 : &quot; + b2.equals(b3));
System.out.println();

short s1 = 12;
Short s2 = new Short(&quot;12&quot;);
Short s3 = new Short(&quot;12&quot;);
System.out.println(&quot;Short 基本类型和包装对象使用 == 比较 : &quot; + (s1 == s2));
System.out.println(&quot;Short 基本类型和包装对象使用 equals 比较 : &quot; + s2.equals(s1));
System.out.println(&quot;Short 包装对象和包装对象使用 == 比较 : &quot; + (s2 == s3));
System.out.println(&quot;Short 包装对象和包装对象使用 equals 比较 : &quot; + s2.equals(s3));
System.out.println();

char c1 = &apos;A&apos;;
Character c2 = new Character(&apos;A&apos;);
Character c3 = new Character(&apos;A&apos;);
System.out.println(&quot;Character 基本类型和包装对象使用 == 比较 : &quot; + (c1 == c2));
System.out.println(&quot;Character 基本类型和包装对象使用 equals 比较 : &quot; + c2.equals(c1));
System.out.println(&quot;Character 包装对象和包装对象使用 == 比较 : &quot; + (c2 == c3));
System.out.println(&quot;Character 包装对象和包装对象使用 equals 比较 : &quot; + c2.equals(c3));
System.out.println();

int i1 = 10000;
Integer i2 = new Integer(10000);
Integer i3 = new Integer(10000);
System.out.println(&quot;Integer 基本类型和包装对象使用 == 比较 : &quot; + (i1 == i2));
System.out.println(&quot;Integer 基本类型和包装对象使用 equals 比较 : &quot; + i2.equals(i1));
System.out.println(&quot;Integer 包装对象和包装对象使用 == 比较 : &quot; + (i2 == i3));
System.out.println(&quot;Integer 包装对象和包装对象使用 equals 比较 : &quot; + i2.equals(i3));
System.out.println();

long l1 = 1000000000000000L;
Long l2 = new Long(&quot;1000000000000000&quot;);
Long l3 = new Long(&quot;1000000000000000&quot;);
System.out.println(&quot;Long 基本类型和包装对象使用 == 比较 : &quot; + (l1 == l2));
System.out.println(&quot;Long 基本类型和包装对象使用 equals 比较 : &quot; + l2.equals(l1));
System.out.println(&quot;Long 包装对象和包装对象使用 == 比较 : &quot; + (l2 == l3));
System.out.println(&quot;Long 包装对象和包装对象使用 equals 比较 : &quot; + l2.equals(l3));
System.out.println();

float f1 = 10000.111F;
Float f2 = new Float(&quot;10000.111&quot;);
Float f3 = new Float(&quot;10000.111&quot;);
System.out.println(&quot;Float 基本类型和包装对象使用 == 比较 : &quot; + (f1 == f2));
System.out.println(&quot;Float 基本类型和包装对象使用 equals 比较 : &quot; + f2.equals(f1));
System.out.println(&quot;Float 包装对象和包装对象使用 == 比较 : &quot; + (f2 == f3));
System.out.println(&quot;Float 包装对象和包装对象使用 equals 比较 : &quot; + f2.equals(f3));
System.out.println();

double d1 = 10000.111;
Double d2 = new Double(&quot;10000.111&quot;);
Double d3 = new Double(&quot;10000.111&quot;);
System.out.println(&quot;Double 基本类型和包装对象使用 == 比较 : &quot; + (d1 == d2));
System.out.println(&quot;Double 基本类型和包装对象使用 equals 比较 : &quot; + d2.equals(d1));
System.out.println(&quot;Double 包装对象和包装对象使用 == 比较 : &quot; + (d2 == d3));
System.out.println(&quot;Double 包装对象和包装对象使用 equals 比较 : &quot; + d2.equals(d3));
System.out.println();

boolean bl1 = true;
Boolean bl2 = new Boolean(&quot;true&quot;);
Boolean bl3 = new Boolean(&quot;true&quot;);
System.out.println(&quot;Boolean 基本类型和包装对象使用 == 比较 : &quot; + (bl1 == bl2));
System.out.println(&quot;Boolean 基本类型和包装对象使用 equals 比较 : &quot; + bl2.equals(bl1));
System.out.println(&quot;Boolean 包装对象和包装对象使用 == 比较 : &quot; + (bl2 == bl3));
System.out.println(&quot;Boolean 包装对象和包装对象使用 equals 比较 : &quot; + bl2.equals(bl3));</code></pre><p>运行结果</p>
<pre><code>Byte 基本类型和包装对象使用 == 比较 : true
Byte 基本类型和包装对象使用 equals 比较 : true
Byte 包装对象和包装对象使用 == 比较 : false
Byte 包装对象和包装对象使用 equals 比较 : true

Short 基本类型和包装对象使用 == 比较 : true
Short 基本类型和包装对象使用 equals 比较 : true
Short 包装对象和包装对象使用 == 比较 : false
Short 包装对象和包装对象使用 equals 比较 : true

Character 基本类型和包装对象使用 == 比较 : true
Character 基本类型和包装对象使用 equals 比较 : true
Character 包装对象和包装对象使用 == 比较 : false
Character 包装对象和包装对象使用 equals 比较 : true

Integer 基本类型和包装对象使用 == 比较 : true
Integer 基本类型和包装对象使用 equals 比较 : true
Integer 包装对象和包装对象使用 == 比较 : false
Integer 包装对象和包装对象使用 equals 比较 : true

Long 基本类型和包装对象使用 == 比较 : true
Long 基本类型和包装对象使用 equals 比较 : true
Long 包装对象和包装对象使用 == 比较 : false
Long 包装对象和包装对象使用 equals 比较 : true

Float 基本类型和包装对象使用 == 比较 : true
Float 基本类型和包装对象使用 equals 比较 : true
Float 包装对象和包装对象使用 == 比较 : false
Float 包装对象和包装对象使用 equals 比较 : true

Double 基本类型和包装对象使用 == 比较 : true
Double 基本类型和包装对象使用 equals 比较 : true
Double 包装对象和包装对象使用 == 比较 : false
Double 包装对象和包装对象使用 equals 比较 : true

Boolean 基本类型和包装对象使用 == 比较 : true
Boolean 基本类型和包装对象使用 equals 比较 : true
Boolean 包装对象和包装对象使用 == 比较 : false
Boolean 包装对象和包装对象使用 equals 比较 : true</code></pre><p>ps：可以延伸一个问题，基本类型与包装对象的拆/装箱的过程</p>
<h2 id="4-什么是装箱？什么是拆箱？装箱和拆箱的执行过程？常见问题？"><a href="#4-什么是装箱？什么是拆箱？装箱和拆箱的执行过程？常见问题？" class="headerlink" title="4 什么是装箱？什么是拆箱？装箱和拆箱的执行过程？常见问题？"></a>4 什么是装箱？什么是拆箱？装箱和拆箱的执行过程？常见问题？</h2><p>1、什么是装箱？什么是拆箱？<br>装箱：基本类型转变为包装器类型的过程。<br>拆箱：包装器类型转变为基本类型的过程。</p>
<pre><code>//JDK1.5之前是不支持自动装箱和自动拆箱的，定义Integer对象，必须
Integer i = new Integer(8);

//JDK1.5开始，提供了自动装箱的功能，定义Integer对象可以这样
Integer i = 8;
int n = i;//自动拆箱</code></pre><p>2、装箱和拆箱的执行过程？</p>
<ul>
<li>装箱是通过调用包装器类的 valueOf 方法实现的</li>
<li>拆箱是通过调用包装器类的 xxxValue 方法实现的，xxx代表对应的基本数据类型。</li>
<li>如int装箱的时候自动调用Integer的valueOf(int)方法；Integer拆箱的时候自动调用Integer的intValue方法。</li>
</ul>
<p>3、常见问题？</p>
<ul>
<li>整型的包装类 valueOf 方法返回对象时，在常用的取值范围内，会返回缓存对象。</li>
<li>浮点型的包装类 valueOf 方法返回新的对象。</li>
<li>布尔型的包装类 valueOf 方法 Boolean类的静态常量 TRUE | FALSE。</li>
</ul>
<p>实验代码</p>
<pre><code>Integer i1 = 100;
Integer i2 = 100;
Integer i3 = 200;
Integer i4 = 200;
System.out.println(i1 == i2);//true
System.out.println(i3 == i4);//false

Double d1 = 100.0;
Double d2 = 100.0;
Double d3 = 200.0;
Double d4 = 200.0;
System.out.println(d1 == d2);//false
System.out.println(d3 == d4);//false

Boolean b1 = false;
Boolean b2 = false;
Boolean b3 = true;
Boolean b4 = true;
System.out.println(b1 == b2);//true
System.out.println(b3 == b4);//true</code></pre><ul>
<li>包含算术运算会触发自动拆箱。</li>
<li>存在大量自动装箱的过程，如果装箱返回的包装对象不是从缓存中获取，会创建很多新的对象，比较消耗内存。</li>
</ul>
<pre><code>Integer s1 = 0;
long t1 = System.currentTimeMillis();
for(int i = 0; i &lt;1000 * 10000; i++){
    s1 += i;
}
long t2 = System.currentTimeMillis();
System.out.println(&quot;使用Integer，递增相加耗时：&quot; + (t2 - t1));//使用Integer，递增相加耗时：68

int s2 = 0;
long t3 = System.currentTimeMillis();
for(int i = 0; i &lt;1000 * 10000; i++){
    s2 += i;
}
long t4 = System.currentTimeMillis();
System.out.println(&quot;使用int&quot; + (t4 - t3));//使用int，递增相加耗时：6</code></pre><p>ps：可深入研究一下 javap 命令，看下自动拆箱、装箱后的class文件组成。<br>       看一下 JDK 中 Byte、Short、Character、Integer、Long、Boolean、Float、Double的 valueOf 和 xxxValue 方法的源码（xxx代表基本类型如intValue）。     </p>
<h2 id="hashCode-相同，equals-也一定为true吗？"><a href="#hashCode-相同，equals-也一定为true吗？" class="headerlink" title="hashCode()相同，equals()也一定为true吗？"></a>hashCode()相同，equals()也一定为true吗？</h2><p>首先，答案肯定是不一定。同时反过来 equals() 为true，hashCode() 也不一定相同。</p>
<ul>
<li>类的 hashCode() 方法和 equals() 方法都可以重写，返回的值完全在于自己定义。</li>
<li>hashCode() 返回该对象的哈希码值；equals() 返回两个对象是否相等。</li>
</ul>
<p>关于 hashCode() 和 equals() 是方法是有一些 常规协定 ：</p>
<ul>
<li><p>1、两个对象用 equals() 比较返回true，那么两个对象的hashCode()方法必须返回相同的结果。</p>
</li>
<li><p>2、两个对象用 equals() 比较返回false，不要求hashCode()方法也一定返回不同的值，但是最好返回不同值，以提搞哈希表性能。</p>
</li>
<li><p>3、重写 equals() 方法，必须重写 hashCode() 方法，以保证 equals() 方法相等时两个对象 hashcode() 返回相同的值。</p>
</li>
</ul>
<h2 id="final在java中的作用"><a href="#final在java中的作用" class="headerlink" title="final在java中的作用"></a>final在java中的作用</h2><p>final 语义是不可改变的。</p>
<ul>
<li>被 final 修饰的类，不能够被继承。</li>
<li>被 final 修饰的成员变量必须要初始化，赋初值后不能再重新赋值(可以调用对象方法修改属性值)。对基本类型来说是其值不可变；对引用变量来说其引用不可变，即不能再指向其他的对象。</li>
<li>被 final 修饰的方法代表不能重写。</li>
</ul>
<h2 id="final-finally-finalize-区别"><a href="#final-finally-finalize-区别" class="headerlink" title="final finally finalize()区别"></a>final finally finalize()区别</h2><ul>
<li><p>final 表示最终的、不可改变的。用于修饰类、方法和变量。final 变量必须在声明时给定初值，只能读取，不可修改。final 方法也同样只能使用，不能重写，但能够重载。final 修饰的对象，对象的引用地址不能变，但对象的属性值可以改变</p>
</li>
<li><p>finally 异常处理的一部分，它只能用在 try/catch 语句中，表示希望 finally 语句块中的代码最后一定被执行（存在一些情况导致 finally 语句块不会被执行，如 jvm 结束）</p>
</li>
<li><p>finalize() 是在 java.lang.Object 里定义的，Object 的 finalize() 方法什么都不做，对象被回收时 finalize() 方法会被调用。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要清理工作，在垃圾收集器删除对象之前被调用的。一般情况下，此方法由JVM调用。特殊情况下，可重写 finalize() 方法，当对象被回收的时候释放一些资源，须调用 super.finalize() 。 </p>
</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><h2 id="-5"><a href="#-5" class="headerlink" title=""></a></h2><h2 id="-6"><a href="#-6" class="headerlink" title=""></a></h2><h2 id="-7"><a href="#-7" class="headerlink" title=""></a></h2><h2 id="-8"><a href="#-8" class="headerlink" title=""></a></h2><h2 id="-9"><a href="#-9" class="headerlink" title=""></a></h2><h2 id="-10"><a href="#-10" class="headerlink" title=""></a></h2><h2 id="-11"><a href="#-11" class="headerlink" title=""></a></h2><h2 id="-12"><a href="#-12" class="headerlink" title=""></a></h2><h2 id="-13"><a href="#-13" class="headerlink" title=""></a></h2><h2 id="-14"><a href="#-14" class="headerlink" title=""></a></h2><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h1 id="文件解析与生成"><a href="#文件解析与生成" class="headerlink" title="文件解析与生成"></a>文件解析与生成</h1><h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><h1 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h1><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试，Java</tag>
      </tags>
  </entry>
  <entry>
    <title>linux环境变量总结</title>
    <url>/2018/05/28/linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="引用https-www-jianshu-com-p-ac2bc0ad3d74"><a href="#引用https-www-jianshu-com-p-ac2bc0ad3d74" class="headerlink" title="引用https://www.jianshu.com/p/ac2bc0ad3d74"></a>引用<a href="https://www.jianshu.com/p/ac2bc0ad3d74" target="_blank" rel="noopener">https://www.jianshu.com/p/ac2bc0ad3d74</a></h2><p>Linux是一个多用户多任务的操作系统,可以在Linux中为不同的用户设置不同的运行环境,<br>具体做法是设置不同用户的环境变量.</p>
<h2 id="Linux环境变量分类"><a href="#Linux环境变量分类" class="headerlink" title="Linux环境变量分类"></a>Linux环境变量分类</h2><p>一 按照生命周期来分,Linux环境变量可以分为两类:<br>1 永久的:需要用户修改相关的配置文件,变量永久生效.<br>2 临时的:用户利用export命令,在当前终端下声明环境变量,关闭shell终端失效.</p>
<p>二 按照作用域来分,Linux环境变量可以分为:<br>1 系统环境变量:系统环境变量对系统中的所有用户都有效.<br>2 用户环境变量:顾名思义,这种类型的环境变量只对特定的用户有效.</p>
<h2 id="Linux设置环境变量的方法"><a href="#Linux设置环境变量的方法" class="headerlink" title="Linux设置环境变量的方法"></a>Linux设置环境变量的方法</h2><p>一 在/etc/profile文件中增加变量,改变量将会对Linux下所有用户有效,并且是永久的.</p>
<p>example:</p>
<pre><code>vim /etc/profile    
export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib</code></pre><p>注意:修改文件后要想马上生效还要运行$ source ~/.bash_profile不然只能在下次<br>重进此用户是生效.</p>
<p>二 在用户目录下的.bash_profile文件中增加变量[对单一用户生效(永久的)]<br>用vim ~/.bash_profile文件中增加变量,改变仅会对当前用户有效,并且是”永久的”.</p>
<pre><code>vim ~/.bash.profile
export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib</code></pre><p>注意:修改文件后要想马上生效还要运行$ source ~/.bash_profile不然只能在下次<br>重进此用户时生效.</p>
<p>三 直接运行export命令定义变量[只对当前shell(bash)有效(临时的),]<br>在shell的命令行下直接使用   export 变量名=变量值<br>定义变量，该变量只在当前的shell（BASH）或其子shell（BASH）下是有效的，<br>shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的<br>话还需要重新定义。</p>
<h2 id="Linux环境变量使用"><a href="#Linux环境变量使用" class="headerlink" title="Linux环境变量使用"></a>Linux环境变量使用</h2><p>一 Linux中常见的环境变量有:</p>
<ul>
<li>PATH :指定命令的搜索路径</li>
</ul>
<pre><code>PATH声明用法:
PATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:------:&lt;PATH n&gt;
export PATH
你可以自己加上指定的路径,中间用冒号隔开.环境变量更改后,在用户下次登录时生效.
echo $path 查看当前系统path路径</code></pre><ul>
<li>HOME: 指定用户的主工作目录(即用户登陆到Linux系统中时,默认的用户目录)    </li>
<li>HISTSIZE: 指保存历史命令记录的条数.</li>
<li>LOGNAME: 指当前用户的登陆名.</li>
<li>HOSTNAME: 指定主机的名称,许多应用程序如果用到主机名的话,通常是从这个环境<br>变量中来取得的</li>
<li>SHELL: 指当前用户用的是哪种shell.</li>
<li>LANG/LANGUGE: 和语言相关的环境变量,使用多种语言的用户可以修改此环境变量.</li>
<li>MAIL: 指当前用户的邮件存放目录.</li>
</ul>
<p>注意:上述变量的名字并不固定,如:HOSTNAME在某些Linux系统中可能设置成HOST</p>
<p>二 Linux也提供了修改和查看环境变量的命令,下面通过几个实例来说明:</p>
<ul>
<li>echo 显示某个环境变量值 echo $PATH</li>
<li>export 设置一个新的环境变量 export HELLO=”hello”(可以无引号)</li>
<li>env 显示所有环境变量</li>
<li>set 显示本地定义的shell变量</li>
<li>unset 清除环境变量 unset HELLO</li>
<li>readonly 设置只读环境变量 readonly HELLO</li>
</ul>
<p>三 C程序调用环境变量函数</p>
<ul>
<li>getenv() 返回一个环境变量.</li>
<li>setenv() 设置一个环境变量.</li>
<li>unsetenv() 清除一个环境变量.</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title>mac上解决java.rmi.server.ExportException- Port already in use- 1099; nested exception is- java.net.Bi</title>
    <url>/2019/09/09/mac%E4%B8%8A%E8%A7%A3%E5%86%B3java-rmi-server-ExportException-Port-already-in-use-1099-nested-exception-is-java-net-Bi/</url>
    <content><![CDATA[<p>tomcat启动报如下的错误：</p>
<p>java.rmi.server.ExportException: Port already in use: 1099; nested exception is: java.net.BindException: Address already in use (Bind failed)</p>
<p>解决方法有两种</p>
<h1 id="第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法"><a href="#第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法" class="headerlink" title="第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法"></a>第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法</h1><h1 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h1><p>第一步：使用lsof -i tcp:1099 查看时那个应用占用了此端口</p>
<p>第二部：使用kill pid 即可，这里的pid是第一步所查询到结果</p>
<p><a href="https://blog.csdn.net/u010412719/article/details/76724125" target="_blank" rel="noopener">原文链接</a></p>
]]></content>
      <categories>
        <category>exception</category>
      </categories>
      <tags>
        <tag>exception</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下chrome快捷键</title>
    <url>/2018/05/09/mac%E4%B8%8Bchrome%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>Chrome在grwin环境下的刷新是F5,强制刷新是Ctrl+F5</p>
<p>Mac下Chrome的刷新是command+R,强制刷新为command+shift+R</p>
<p>option+shift+可以打出(logo)</p>
<h2 id="引用-https-blog-csdn-net-fjh658-article-details-8860967"><a href="#引用-https-blog-csdn-net-fjh658-article-details-8860967" class="headerlink" title="引用 https://blog.csdn.net/fjh658/article/details/8860967"></a>引用 <a href="https://blog.csdn.net/fjh658/article/details/8860967" target="_blank" rel="noopener">https://blog.csdn.net/fjh658/article/details/8860967</a></h2><h2 id="标签页和窗口快捷键"><a href="#标签页和窗口快捷键" class="headerlink" title="标签页和窗口快捷键"></a>标签页和窗口快捷键</h2><table>
<thead>
<tr>
<th align="left">按键</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>⌘+N</code></td>
<td align="left"><code>打开新窗口</code></td>
</tr>
<tr>
<td align="left"><code>⌘+T</code></td>
<td align="left"><code>打开新标签</code></td>
</tr>
<tr>
<td align="left"><code>⌘+shift+N</code></td>
<td align="left"><code>在隐身模式下打开新窗口</code></td>
</tr>
<tr>
<td align="left"><code>按 ⌘+O，然后选择文件</code></td>
<td align="left"><code>在 Google Chrome 浏览器中打开计算机中的文件。</code></td>
</tr>
<tr>
<td align="left"><code>按住 ⌘ 键，然后点击链接。或用鼠标中键（或鼠标滚轮）点击链接。</code></td>
<td align="left"><code>从后台在新标签页中打开链接。</code></td>
</tr>
<tr>
<td align="left"><code>按住 ⌘+Shift 键，然后点击链接。或按住 Shift 的同时用鼠标中键（或鼠标滚轮）点击链接。</code></td>
<td align="left"><code>在新标签页中打开链接并切换到刚打开的标签页。</code></td>
</tr>
<tr>
<td align="left"><code>按住 Shift 键，然后点击链接。</code></td>
<td align="left"><code>在新窗口中打开链接。</code></td>
</tr>
<tr>
<td align="left"><code>⌘+Shift+T</code></td>
<td align="left"><code>重新打开上次关闭的标签页。Google Chrome 浏览器可记住最近关闭的 10 个标签页。</code></td>
</tr>
<tr>
<td align="left"><code>将标签页拖出标签栏。</code></td>
<td align="left"><code>在新窗口中打开标签页。</code></td>
</tr>
<tr>
<td align="left"><code>将标签页从标签栏拖到现有窗口中。</code></td>
<td align="left"><code>在现有窗口中打开标签页。</code></td>
</tr>
<tr>
<td align="left"><code>同时按 ⌘+Option 和左或右箭头键。</code></td>
<td align="left"><code>左右切换标签页。</code></td>
</tr>
<tr>
<td align="left"><code>⌘+W</code></td>
<td align="left"><code>关闭当前标签页或弹出窗口。</code></td>
</tr>
<tr>
<td align="left"><code>⌘+Shift+W</code></td>
<td align="left"><code>关闭当前窗口。</code></td>
</tr>
<tr>
<td align="left"><code>⌘+Y</code></td>
<td align="left"><code>打开历史记录</code></td>
</tr>
<tr>
<td align="left"><code>按 Delete 或 ⌘-[</code></td>
<td align="left"><code>转到当前标签页的上一页浏览历史记录。</code></td>
</tr>
<tr>
<td align="left"><code>按 Shift-Delete 或 ⌘-]    。</code></td>
<td align="left"><code>转到当前标签页的下一页浏览历史记录。</code></td>
</tr>
<tr>
<td align="left"><code>按住 Shift，然后点击窗口左上方的 + 按钮。</code></td>
<td align="left"><code>最大化窗口。</code></td>
</tr>
<tr>
<td align="left"><code>⌘+M</code></td>
<td align="left"><code>最小化窗口。</code></td>
</tr>
<tr>
<td align="left"><code>⌘+H</code></td>
<td align="left"><code>隐藏chrome浏览器</code></td>
</tr>
<tr>
<td align="left"><code>⌘+option+H</code></td>
<td align="left"><code>隐藏其他所有窗口</code></td>
</tr>
<tr>
<td align="left"><code>⌘+Q</code></td>
<td align="left"><code>关闭浏览器</code></td>
</tr>
<tr>
<td align="left"><code>⌘+Shift+B</code></td>
<td align="left"><code>打开和关闭书签栏</code></td>
</tr>
<tr>
<td align="left"><code>⌘+Option+B</code></td>
<td align="left"><code>打开书签管理器</code></td>
</tr>
<tr>
<td align="left"><code>⌘-</code></td>
<td align="left"><code>打开偏好设置对话框</code></td>
</tr>
<tr>
<td align="left"><code>⌘+Y</code></td>
<td align="left"><code>打开历史记录</code></td>
</tr>
<tr>
<td align="left"><code>⌘+shift+J</code></td>
<td align="left"><code>打开下载内容页面</code></td>
</tr>
<tr>
<td align="left"><code>⌘+shift+delete</code></td>
<td align="left"><code>打开清除浏览记录对话框</code></td>
</tr>
<tr>
<td align="left"><code>⌘+shift+M</code></td>
<td align="left"><code>在多个用户之间切换</code></td>
</tr>
<tr>
<td align="left"><code>输入搜索词,然后按Enter</code></td>
<td align="left"><code>使用默认搜索引擎进行搜索</code></td>
</tr>
<tr>
<td align="left"><code>输入搜索引擎关键字,按空格键,再输入搜索字词,再按Enter</code></td>
<td align="left"><code>使用与关键字相关联的搜索引擎进行搜索</code></td>
</tr>
<tr>
<td align="left"><code>首先输入搜索引擎网址,然后在系统提示时按Tab,输入搜索字词,再按Enter</code></td>
<td align="left"><code>使用与网址相关联的搜索引擎进行搜索</code></td>
</tr>
<tr>
<td align="left"><code>输入网址，然后按 ⌘-Enter。</code></td>
<td align="left"><code>在新后台标签页中打开网址。</code></td>
</tr>
<tr>
<td align="left"><code>⌘-L</code></td>
<td align="left"><code>突出显示网址。</code></td>
</tr>
<tr>
<td align="left"><code>⌘-Option-F</code></td>
<td align="left"><code>将“?”置于地址栏中。在问号后输入搜索字词可用默认搜索引擎执行搜索。</code></td>
</tr>
<tr>
<td align="left"><code>同时按 Option 和向左箭头键。</code></td>
<td align="left"><code>将光标移到地址栏中的前一个关键字词</code></td>
</tr>
<tr>
<td align="left"><code>同时按 Option 和向右箭头键。</code></td>
<td align="left"><code>在地址栏中将光标移到下一个关键字词</code></td>
</tr>
<tr>
<td align="left"><code>同时按 Shift-Option 和向左箭头键。</code></td>
<td align="left"><code>在地址栏中突出显示上一关键字词</code></td>
</tr>
<tr>
<td align="left"><code>同时按 Shift-Option 和向右箭头键。</code></td>
<td align="left"><code>在地址栏中突出显示下一关键字词</code></td>
</tr>
<tr>
<td align="left"><code>⌘-Delete</code></td>
<td align="left"><code>在地址栏中删除光标前的关键字词</code></td>
</tr>
<tr>
<td align="left"><code>用键盘上的方向键从地址栏下拉菜单中选择一个条目，然后按 Shift-Fn-Delete。</code></td>
<td align="left"><code>从浏览历史记录中删除所选条目（如果可以）。</code></td>
</tr>
<tr>
<td align="left"><code>⌘+</code></td>
<td align="left"><code>tt</code></td>
</tr>
<tr>
<td align="left"><code>⌘+</code></td>
<td align="left"><code>tt</code></td>
</tr>
<tr>
<td align="left"><code>⌘+</code></td>
<td align="left"><code>tt</code></td>
</tr>
<tr>
<td align="left"><code>⌘+</code></td>
<td align="left"><code>tt</code></td>
</tr>
<tr>
<td align="left"><code>⌘+</code></td>
<td align="left"><code>tt</code></td>
</tr>
<tr>
<td align="left"><code>⌘+</code></td>
<td align="left"><code>tt</code></td>
</tr>
<tr>
<td align="left"><code>⌘+</code></td>
<td align="left"><code>tt</code></td>
</tr>
<tr>
<td align="left"><code>⌘+</code></td>
<td align="left"><code>tt</code></td>
</tr>
<tr>
<td align="left"><code>⌘+</code></td>
<td align="left"><code>tt</code></td>
</tr>
<tr>
<td align="left"><code>⌘+</code></td>
<td align="left"><code>tt</code></td>
</tr>
<tr>
<td align="left"><code>⌘+</code></td>
<td align="left"><code>tt</code></td>
</tr>
<tr>
<td align="left"><code>⌘+</code></td>
<td align="left"><code>tt</code></td>
</tr>
<tr>
<td align="left"><code>⌘+</code></td>
<td align="left"><code>tt</code></td>
</tr>
<tr>
<td align="left"><code>⌘+</code></td>
<td align="left"><code>tt</code></td>
</tr>
<tr>
<td align="left"><code>⌘+</code></td>
<td align="left"><code>tt</code></td>
</tr>
<tr>
<td align="left"><code>⌘+</code></td>
<td align="left"><code>tt</code></td>
</tr>
<tr>
<td align="left"><code>⌘+</code></td>
<td align="left"><code>tt</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>mac</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>mac使用brew update无反应,解决方案更新源</title>
    <url>/2019/08/23/mac%E4%BD%BF%E7%94%A8brew-update%E6%97%A0%E5%8F%8D%E5%BA%94-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9B%B4%E6%96%B0%E6%BA%90/</url>
    <content><![CDATA[<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>  资源访问太慢</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>更新源</p>
<p>使用中科大的镜像<br>替换默认源<br>第一步，替换brew.git</p>
<pre><code>cd &quot;$(brew --repo)&quot;
git remote set-url origin https://mirrors.ustc.edu.cn/brew.git</code></pre><p>第二步：替换homebrew-core.git</p>
<pre><code>cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;
git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</code></pre><p>最后验证</p>
<pre><code>brew update</code></pre>]]></content>
      <tags>
        <tag>brew</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql之锁</title>
    <url>/2020/04/28/mysql%E4%B9%8B%E9%94%81/</url>
    <content><![CDATA[<p><a href="https://xzh20121116.github.io/post/mysql-zhi-suo/" target="_blank" rel="noopener">摘自</a></p>
<h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><pre><code>加锁 lock tablas ...read/write
主动解锁 unlock tables ... 
被动解锁 客户端断开连接时被动解锁
限制其他线程读写，也会对本线程接下来的操作对象。
一般不用，消耗大</code></pre><h2 id="MDL（元数据锁-meta-data-lock）"><a href="#MDL（元数据锁-meta-data-lock）" class="headerlink" title="MDL（元数据锁 meta data lock）"></a>MDL（元数据锁 meta data lock）</h2><pre><code>自动加锁
读锁 对表数据的增删改查
写锁 对表结构的修改
多个事务读锁不互斥
多个事务写锁互斥
mdl作用保证读写的正确性</code></pre><h1 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h1><p>根据数据引擎来实现的，MyIsam就不支持行锁</p>
<h2 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h2><pre><code>innodb中有需要时加此锁，但并非不需要时解锁，而是在事务
提交之后解锁。

若一个事务锁多行，尽可能把并发多的行往后写。</code></pre><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><pre><code>事务a等待事务b释放某行的锁，事务b等待事务a释放某行的锁就造成死锁。
例如：
事务a update table a ... where line = 1;
事务b update table a ... where line = 2;
事务a update table a ... where line = 2;
事务b update table a ... where line = 1;

事务a等待事务b释放line=2的锁，事务b等待事务a释放line=1的锁，由于
两阶段锁的存在（即事务只有在commit之后才释放锁）顾造成锁都释放
不了，造成死锁。</code></pre><h2 id="mvcc-多版本并发控制"><a href="#mvcc-多版本并发控制" class="headerlink" title="mvcc(多版本并发控制)"></a>mvcc(多版本并发控制)</h2><pre><code>mysql在修改一行数据时，都会记录一行此数据相应的回滚操作，
若某行数据被改了n次，则此事务相应的回滚记录也被记录了n次。
这种一条数据在系统中有多个版本就是多版本并发控制mvcc.</code></pre><h1 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h1><p> <img src="mysql%E4%B9%8B%E9%94%81.png" alt=""> </p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>php中unset详解</title>
    <url>/2018/06/20/php%E4%B8%ADunset%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>unset()经常会被用到,用于销毁指定的变量,但它有自己的行为模式,如果<br>不仔细的话可能被中文解释给迷惑:</p>
<p>先来看看官方文档的说法:</p>
<p>unset —- unset a given variable</p>
<p>void unset(mixed $var [,mixed $…]);</p>
<p>parameters:</p>
<p>var:The variable to be unset. //要unset的变量</p>
<p>…Anther variable… // 其他需要unset的变量</p>
<p>return Values:No value is returned.  //unset不返回值</p>
<p>Because this is a language construct and not a function,it<br>cannot be called using variable functions</p>
<p>//unset()是语言结构,不是函数,因此不能被函数变量调用,具体参照函数变量.</p>
<p>使用function_exists(‘unset’)返回的false,以此证明unset并不是一个函数<br>,所以无法使用$fun=’unset’;$fun()的方式调用unset()</p>
<p>it is possible to unset even object properties visible in current context.</p>
<p>// 通用环境下unset可以销毁对象或者对象的可见属性(public)</p>
<p>It is not possible to unset $this inside on object method since PHP5</p>
<p>// 在PHP5之前unset无法销毁对象中的$this方法</p>
<p>when using unset() on inaccessible object properties,the _unset()<br>overloading method will be called,if declare.</p>
<p>当unset()无法销毁对象中的属性,例如私有属性,保护属性,那么会自动加载对象中的_unset<br>方法.</p>
<p>description:</p>
<p>unset()destroys the specified variables. //unset()销毁指定的变量</p>
<p>The behavior of unset()inside of a function can vary depending</p>
<p>on what type of variable you are attempting to destroy.</p>
<p>// unset()的行为在函数内部可以根据你所指定销毁的变量类型变化.</p>
<p>情况一:</p>
<p>if a globalized variable is unset() inside of a function,only the local<br>variable is destroyed.The variable in the calling environment will<br>retain the same value as before unset() was called.</p>
<p>如果在函数内使用一个global使其全局化的变量,使用unset进行销毁,那么只有局部的<br>变量会被销毁,在调用环境的变量将会保留没有unset()销毁之前的调用的变量值.</p>
<p>the example:</p>
<pre><code>&lt;?php  
function destroy_foo()   
{  
    global $foo;  
    unset($foo);  
}  

$foo = &apos;bar&apos;;  
destroy_foo();  
echo $foo;  
?&gt;  </code></pre><p>the above example will output:bar</p>
<p>这是官方文档的例子,可能这样还是不太明显,把上面的例子改成下面这样,一切就很清晰了.</p>
<pre><code>&lt;?php   
function des(){  
    global $foo;  
    $foo=&apos;bars&apos;;  
    unset($foo);  
    echo $foo;  
}  
$foo=&apos;bar&apos;;  
echo &quot;The globalized variable is unset() inside of a function:&quot;;  
des();  
echo &quot;&lt;br/&gt;&quot;;  
echo &quot;The variable in the calling environment:&quot;;  
echo $foo;  </code></pre>]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>unset</tag>
      </tags>
  </entry>
  <entry>
    <title>php调用shell的方法</title>
    <url>/2018/04/20/php%E8%B0%83%E7%94%A8shell%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="引用-http-www-jb51-net-article-57118-htm"><a href="#引用-http-www-jb51-net-article-57118-htm" class="headerlink" title="引用:http://www.jb51.net/article/57118.htm"></a>引用:<a href="http://www.jb51.net/article/57118.htm" target="_blank" rel="noopener">http://www.jb51.net/article/57118.htm</a></h2><h2 id="这篇文章主要介绍了PHP调用shell的方法-包括相关的原理-注意事项及函数的用法-需要的朋友可以参考下"><a href="#这篇文章主要介绍了PHP调用shell的方法-包括相关的原理-注意事项及函数的用法-需要的朋友可以参考下" class="headerlink" title="这篇文章主要介绍了PHP调用shell的方法,包括相关的原理 注意事项及函数的用法,需要的朋友可以参考下"></a>这篇文章主要介绍了PHP调用shell的方法,包括相关的原理 注意事项及函数的用法,需要的朋友可以参考下</h2><h3 id="一-配置"><a href="#一-配置" class="headerlink" title="一 配置"></a>一 配置</h3><h4 id="查看php-ini中配置是否打开安全模式-主要是以下三个地方"><a href="#查看php-ini中配置是否打开安全模式-主要是以下三个地方" class="headerlink" title="查看php.ini中配置是否打开安全模式,主要是以下三个地方"></a>查看php.ini中配置是否打开安全模式,主要是以下三个地方</h4><ul>
<li><p>safe_mode = (这个如果是off下面两个就不用管了)</p>
</li>
<li><p>disable_functions = </p>
</li>
<li><p>safe_mode_exec_dir = </p>
</li>
</ul>
<h3 id="二使用"><a href="#二使用" class="headerlink" title="二使用"></a>二使用</h3><h4 id="由于PHP是基本是用于WEB程序开发的-所以安全性成了人们考虑的一个重要方面-于是PHP的设计者们给-PHP加了一个门-安全模式-如果运行在安全模式下-那么PHP脚本中将受到如下四个方面的限制"><a href="#由于PHP是基本是用于WEB程序开发的-所以安全性成了人们考虑的一个重要方面-于是PHP的设计者们给-PHP加了一个门-安全模式-如果运行在安全模式下-那么PHP脚本中将受到如下四个方面的限制" class="headerlink" title="由于PHP是基本是用于WEB程序开发的,所以安全性成了人们考虑的一个重要方面.于是PHP的设计者们给  PHP加了一个门:安全模式.如果运行在安全模式下,那么PHP脚本中将受到如下四个方面的限制:"></a>由于PHP是基本是用于WEB程序开发的,所以安全性成了人们考虑的一个重要方面.于是PHP的设计者们给  PHP加了一个门:安全模式.如果运行在安全模式下,那么PHP脚本中将受到如下四个方面的限制:</h4><ul>
<li><p>执行外部命令</p>
</li>
<li><p>在打开文件时有些限制</p>
</li>
<li><p>连接MYSQL数据库</p>
</li>
<li><p>基于HTTP的认证</p>
</li>
</ul>
<p>在安全模式下,只有在特定目录中的外部程序才可以被执行,对其他程序的调用将被拒绝.这个目录可以在  PHP.ini文件中用safe_model_exex_dir指令,或在编译PHP时加上–with-exec-dir选项来指定,默认是  /usr/local/php/bin.</p>
<p>如果你调用一个应该可以输出结果的外部命令(意思是PHP脚本没有错误),得到的却是一片空白,那么很可能   你的网管已经把PHP运行在安全模式下了.</p>
<h3 id="三如何做"><a href="#三如何做" class="headerlink" title="三如何做"></a>三如何做</h3><h4 id="在PHP中调用外部命令-可以用如下三种方法来实现"><a href="#在PHP中调用外部命令-可以用如下三种方法来实现" class="headerlink" title="在PHP中调用外部命令,可以用如下三种方法来实现:"></a>在PHP中调用外部命令,可以用如下三种方法来实现:</h4><ul>
<li>1 ) 用PHP提供的专门函数</li>
</ul>
<h3 id="php提供了3个专门的执行外部命令的函数-system-exec-passthru"><a href="#php提供了3个专门的执行外部命令的函数-system-exec-passthru" class="headerlink" title="php提供了3个专门的执行外部命令的函数: system(),exec(),passthru()."></a>php提供了3个专门的执行外部命令的函数: system(),exec(),passthru().</h3><h3 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h3><p>原型: string system(string command[,int return_var])</p>
<p>system()函数和其他语言中的差不多,它执行给定的命令,输出和返回结果.第二个参数是可选的,用来得到命令执行后的状态码.</p>
<p>例子:</p>
<ul>
<li>system(“/usr/local/bin/webalizer/webalizer”);</li>
</ul>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p>原型: string exex(string command[,string array[,int return_var]])</p>
<p>exec()函数与system()类似,也执行给定的命令,但不输出结果,而是返回结果的最后一行.虽然它只返回命令  结果的最后一行,但用第二个参数array可以得到完整的结果,方法是吧结果逐行追加到  array的结尾处.所 以如果array不是空的,在调用之前最好用unset()把它清掉.只有指定了第二个参数时,才可以用第三个参数,用来取得命令执行的状态码.</p>
<p>例子:</p>
<ul>
<li>exec(“/bin/ls -|”);</li>
<li>exec(“/bin/ls -|”,$res);’</li>
<li>$res是一个数据,每个元素代表结果的一行</li>
<li>exec(“/bin/ls -|”,$res,$rc);’</li>
<li>$rc的值是命令/bin/ls -|的状态码.成功的情况下通常是0</li>
</ul>
<h3 id="passthru"><a href="#passthru" class="headerlink" title="passthru()"></a>passthru()</h3><p>  原型: void passthru(string command[,int return_var])</p>
<p>  passthru()只调用命令,不返回任何结果,但把命令的运行结果原样<br>  地直接输出到标准输出设备上.所以passthru()函数经常用来调用像<br>  pbmplus(Unix下的一个处理图片的工具,输出二进制的原始图片的流)<br>  这样的程序.同样它也可以得到命令执行的状态码.</p>
<p>  例子</p>
<p>  header(“Content-type:image/gif”);<br>  passthru(“./ppmtogif hunte.ppm”);</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql面试题</title>
    <url>/2020/04/16/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="MySQL的复制原理以及流程"><a href="#MySQL的复制原理以及流程" class="headerlink" title="MySQL的复制原理以及流程"></a>MySQL的复制原理以及流程</h1><pre><code>基本原理流程，3个线程以及之间的关联；
  主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；
  从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；
  从：sql执行线程——执行relay log中的语句；</code></pre><h1 id="MySQL中myisam与innodb的区别，至少5点"><a href="#MySQL中myisam与innodb的区别，至少5点" class="headerlink" title="MySQL中myisam与innodb的区别，至少5点"></a>MySQL中myisam与innodb的区别，至少5点</h1><pre><code>5点不同
  1&gt;.InnoDB支持事物，而MyISAM不支持事物
  2&gt;.InnoDB支持行级锁，而MyISAM支持表级锁
  3&gt;.InnoDB支持MVCC, 而MyISAM不支持
      MVCC是版本控制？
  4&gt;.InnoDB支持外键，而MyISAM不支持
  5&gt;.InnoDB不支持全文索引，而MyISAM支持。
 innodb引擎的4大特性
  插入缓冲（insert buffer)
  二次写(double write)
  自适应哈希索引(ahi)
  预读(read ahead)
2者selectcount(*)哪个更快，为什么
  myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</code></pre><h1 id="MySQL中varchar与char的区别以及varchar-50-中的50代表的涵义"><a href="#MySQL中varchar与char的区别以及varchar-50-中的50代表的涵义" class="headerlink" title="MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义"></a>MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义</h1><pre><code>(1)、varchar与char的区别
  char是一种固定长度的类型
  varchar则是一种可变长度的类型
(2)、varchar(50)中50的涵义
  最多存放50个字符
  varchar(50)和(200)存储hello所占空间一样
  但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)
(3)、int（20）中20的涵义
  是指显示字符的长度
  要加参数的，最大为255
  比如它是记录行数的id,插入10笔资料，它就显示00000000001 ~~~00000000010，当字符的位数超过11,它也只显示11位，如果你没有加那个让它未满11位就前面加0的参数，它不会在前面加0
  20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；
(4)、mysql为什么这么设计
  对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；</code></pre><h1 id="问了innodb的事务与日志的实现方式"><a href="#问了innodb的事务与日志的实现方式" class="headerlink" title="问了innodb的事务与日志的实现方式"></a>问了innodb的事务与日志的实现方式</h1><pre><code>(1)、有多少种日志；
  错误日志：记录出错信息，也记录一些警告信息或者正确的信息。
  查询日志：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。
  慢查询日志：设置一个阈(yu)值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。
  二进制日志：记录对数据库执行更改的所有操作。
  中继日志：中继日志也是二进制日志，用来给slave 库恢复
  事务日志：重做日志redo和回滚日志undo
(2)、事物的4种隔离级别
  读未提交(RU)
        read uncommited ：读到未提交数据
  读已提交(RC)
        read committed：脏读，不可重复读
  可重复读(RR)
        repeatable read：可重读
  串行
        serializable ：串行事物
(3)、事务是如何通过日志来实现的，说得越深入越好。
  事务日志是通过redo和innodb的存储引擎日志缓冲（Innodb log buffer）来实现的
  当开始一个事务的时候，会记录该事务的lsn(log sequence number)号;
  当事务执行时，会往InnoDB存储引擎的日志的日志缓存里面插入事务日志；
  当事务提交时，必须将存储引擎的日志缓冲写入磁盘（通过innodb_flush_log_at_trx_commit来控制），也就是写数据前，需要先写日志。这种方式称为“预写日志方式”</code></pre><h1 id="MySQL-binlog的几种日志录入格式以及区别"><a href="#MySQL-binlog的几种日志录入格式以及区别" class="headerlink" title="MySQL binlog的几种日志录入格式以及区别"></a>MySQL binlog的几种日志录入格式以及区别</h1><pre><code>Statement：每一条会修改数据的sql都会记录在binlog中。
  优点
      不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。
  缺点
      由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的 一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同 的结果。
      使用以下函数的语句也有问题：
              sleep()函数
              last_insert_id()
              user-defined functions(udf)
              LOAD_FILE()
              UUID()
              USER()
              FOUND_ROWS()
              SYSDATE() (除非启动时启用了 --sysdate-is-now 选项)
      同时在INSERT …SELECT 会产生比 RBR 更多的行级锁
Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改。
  优点
      binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了
      rowlevel的日志内容会非常清楚的记录下 每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题
  缺点
      可能会产生大量的日志内容
Mixedlevel: 是以上两种level的混合使用
  一般的语句修改使用statment格式保存binlog
  一些函数，statement无法完成主从复制的操作，则 采用row格式保存binlog</code></pre><h1 id="MySQL数据库cpu飙升到500-的话他怎么处理？"><a href="#MySQL数据库cpu飙升到500-的话他怎么处理？" class="headerlink" title="MySQL数据库cpu飙升到500%的话他怎么处理？"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h1><pre><code>1、列出所有进程 show processlist,观察所有进程 ,多秒没有状态变化的(干掉)
2、查看超时日志或者错误日志 (做了几年开发,一般会是查询以及大批量的插入会导致cpu与i/o上涨,当然不排除网络状态突然断了,导致一个请求服务器只接受到一半，比如where子句或分页子句没有发送,,当然的一次被坑经历)</code></pre><h1 id="sql优化各种方法"><a href="#sql优化各种方法" class="headerlink" title="sql优化各种方法"></a>sql优化各种方法</h1><pre><code>(1)、explain出来的各种item的意义；
  select_type
      表示查询中每个select子句的类型
  type
      表示MySQL在表中找到所需行的方式，又称“访问类型”
  possible_keys
      指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用
  key
      显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL
  key_len
      表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度
  ref
      表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值
  Extra
      包含不适合在其他列中显示但十分重要的额外信息
(2)、profile的意义以及使用场景；
  查询到 SQL 会执行多少时间, 并看出 CPU/Memory 使用量, 执行过程中 Systemlock, Table lock 花多少时间等等</code></pre><h1 id="备份计划，mysqldump以及xtranbackup的实现原理"><a href="#备份计划，mysqldump以及xtranbackup的实现原理" class="headerlink" title="备份计划，mysqldump以及xtranbackup的实现原理"></a>备份计划，mysqldump以及xtranbackup的实现原理</h1><pre><code>(1)、备份计划；
  这里每个公司都不一样，您别说那种1小时1全备什么的就行
(2)、备份恢复时间；
  这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考
      20G的2分钟（mysqldump）

      80G的30分钟(mysqldump)

      111G的30分钟（mysqldump)

      288G的3小时（xtra)

      3T的4小时（xtra)

      逻辑导入时间一般是备份时间的5倍以上
(3)、xtrabackup实现原理
  在InnoDB内部会维护一个redo日志文件，我们也可以叫做事务日志文件
  事务日志会存储每一个InnoDB表数据的记录修改。
  当InnoDB启动时，InnoDB会检查数据文件和事务日志，并执行两个步骤：它应用（前滚）已经提交的事务日志到数据文件，并将修改过但没有提交的数据进行回滚操作。</code></pre><h1 id="500台db，在最快时间之内重启"><a href="#500台db，在最快时间之内重启" class="headerlink" title="500台db，在最快时间之内重启"></a>500台db，在最快时间之内重启</h1><pre><code>使用批量 ssh 工具 pssh 来对需要重启的机器执行重启命令。 
也可以使用 salt（前提是客户端有安装 salt）或者 ansible（ ansible 只需要 ssh 免登通了就行）等多线程工具同时操作多台服务器</code></pre><h1 id="innodb的读写参数优化"><a href="#innodb的读写参数优化" class="headerlink" title="innodb的读写参数优化"></a>innodb的读写参数优化</h1><pre><code>(1)、读取参数
  global buffer pool以及 local buffer；
(2)、写入参数；
  innodb_flush_log_at_trx_commit
  innodb_buffer_pool_size
(3)、与IO相关的参数；
  innodb_write_io_threads = 8

  innodb_read_io_threads = 8

  innodb_thread_concurrency = 0
(4)、缓存参数以及缓存的适用场景。
  query cache/query_cache_type
  并不是所有表都适合使用query cache。造成query cache失效的原因主要是相应的table发生了变更
  第一个：读操作多的话看看比例，简单来说，如果是用户清单表，或者说是数据比例比较固定，比如说商品列表，是可以打开的，前提是这些库比较集中，数据库中的实务比较小。
  第二个：我们“行骗”的时候，比如说我们竞标的时候压测，把query cache打开，还是能收到qps激增的效果，当然前提示前端的连接池什么的都配置一样。大部分情况下如果写入的居多，访问量并不多，那么就不要打开，例如社交网站的，10%的人产生内容，其余的90%都在消费，打开还是效果很好的，但是你如果是qq消息，或者聊天，那就很要命。
  第三个：小网站或者没有高并发的无所谓，高并发下，会看到 很多 qcache 锁 等待，所以一般高并发下，不建议打开query cache</code></pre><h1 id="你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？"><a href="#你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？" class="headerlink" title="你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？"></a>你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？</h1><pre><code>监控的工具有很多，例如zabbix，lepus，我这里用的是lepus</code></pre><h1 id="你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？"><a href="#你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？" class="headerlink" title="你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？"></a>你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？</h1><pre><code>主从一致性校验有多种工具 例如checksum、mysqldiff、pt-table-checksum等
checksum
mysqldiff
pt-table-checksum</code></pre><h1 id="你们数据库是否支持emoji表情，如果不支持，如何操作？"><a href="#你们数据库是否支持emoji表情，如果不支持，如何操作？" class="headerlink" title="你们数据库是否支持emoji表情，如果不支持，如何操作？"></a>你们数据库是否支持emoji表情，如果不支持，如何操作？</h1><pre><code>如果是utf8字符集的话，需要升级至utf8_mb4方可支持
utf8_mb4</code></pre><h1 id="你是如何维护数据库的数据字典的？"><a href="#你是如何维护数据库的数据字典的？" class="headerlink" title="你是如何维护数据库的数据字典的？"></a>你是如何维护数据库的数据字典的？</h1><pre><code>一般是直接在生产库进行注释，利用工具导出成excel方便流通</code></pre><h1 id="表中有大字段X-例如：text类型-，且字段X不会经常更新，以读为为主，请问"><a href="#表中有大字段X-例如：text类型-，且字段X不会经常更新，以读为为主，请问" class="headerlink" title="表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为为主，请问"></a>表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为为主，请问</h1><pre><code>拆带来的问题：连接消耗 + 存储拆分空间
不拆可能带来的问题：查询性能；
如果能容忍拆分带来的空间问题,拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区) 顺序IO,减少连接消耗,最后这是一个文本列再加上一个全文索引来尽量抵消连接消耗
如果能容忍不拆分带来的查询性能损失的话:上面的方案在某个极致条件下肯定会出现问题,那么不拆就是最好的选择</code></pre><h1 id="MySQL中InnoDB引擎的行锁是通过加在什么上完成-或称实现-的？为什么是这样子的？"><a href="#MySQL中InnoDB引擎的行锁是通过加在什么上完成-或称实现-的？为什么是这样子的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？"></a>MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？</h1><pre><code>InnoDB是基于索引来完成行锁
例: select * from tab_with_index where id = 1 for update;
for update 可以根据条件来完成行锁锁定,并且 id 是有索引键的列,
如果 id 不是索引键那么InnoDB将完成表锁,,并发将无从谈起</code></pre><h1 id="开放性问题：据说是腾讯的"><a href="#开放性问题：据说是腾讯的" class="headerlink" title="开放性问题：据说是腾讯的"></a>开放性问题：据说是腾讯的</h1><pre><code>一个6亿的表a，一个3亿的表b，通过外键tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。
  1、如果A表TID是自增长,并且是连续的,B表的ID为索引
  select * from a,b where a.tid = b.id and a.tid&gt;500000 limit 200;
  2、如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。
  select * from b , (select tid from a limit 50000,200) a where b.id = a .tid;</code></pre><h1 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a>什么是存储过程？有哪些优缺点？</h1><pre><code>存储过程是一些预编译的SQL语句。
1、更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。
2、存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全</code></pre><h1 id="索引有哪些数据结构"><a href="#索引有哪些数据结构" class="headerlink" title="索引有哪些数据结构"></a>索引有哪些数据结构</h1><pre><code>Hash、B+
去创建索引的时候，可以选择索引的类型</code></pre><h1 id="索引是什么？有什么作用以及优缺点？"><a href="#索引是什么？有什么作用以及优缺点？" class="headerlink" title="索引是什么？有什么作用以及优缺点？"></a>索引是什么？有什么作用以及优缺点？</h1><pre><code>1、索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构
2、索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。
MySQL数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引
  1、索引加快数据库的检索速度

  2、索引降低了插入、删除、修改等维护任务的速度

  3、唯一索引可以确保每一行数据的唯一性

  4、通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能

  5、索引需要占物理和数据空间</code></pre><h1 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h1><pre><code>事务（Transaction）是并发控制的基本单位。
它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。
事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。</code></pre><h1 id="使用索引查询一定能提高查询的性能吗？为什么"><a href="#使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="使用索引查询一定能提高查询的性能吗？为什么"></a>使用索引查询一定能提高查询的性能吗？为什么</h1><pre><code>通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.
1、索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况:
2、基于一个范围的检索,一般查询返回结果集小于表中记录数的30%
3、基于非唯一性索引的检索</code></pre><h1 id="简单说一说drop、delete与truncate的区"><a href="#简单说一说drop、delete与truncate的区" class="headerlink" title="简单说一说drop、delete与truncate的区"></a>简单说一说drop、delete与truncate的区</h1><pre><code>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别
1、delete和truncate只删除表的数据不删除表的结构
2、速度,一般来说: drop&gt; truncate &gt;delete
3、delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;如果有相应的trigger,执行的时候将被触发.
4、 truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.</code></pre><h1 id="drop、delete与truncate分别在什么场景之下使用？"><a href="#drop、delete与truncate分别在什么场景之下使用？" class="headerlink" title="drop、delete与truncate分别在什么场景之下使用？"></a>drop、delete与truncate分别在什么场景之下使用？</h1><pre><code>1、不再需要一张表的时候，用drop
2、想删除部分数据行时候，用delete，并且带上where子句
3、保留表而删除所有数据的时候用truncate</code></pre><h1 id="超键、候选键、主键、外键分别是什么？"><a href="#超键、候选键、主键、外键分别是什么？" class="headerlink" title="超键、候选键、主键、外键分别是什么？"></a>超键、候选键、主键、外键分别是什么？</h1><pre><code>1、超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。
2、候选键：是最小超键，即没有冗余元素的超键。
3、主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。
4、外键：在一个表中存在的另一个表的主键称此表的外键。</code></pre><h1 id="什么是视图？以及视图的使用场景有哪些？"><a href="#什么是视图？以及视图的使用场景有哪些？" class="headerlink" title="什么是视图？以及视图的使用场景有哪些？"></a>什么是视图？以及视图的使用场景有哪些？</h1><pre><code>1、视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。
2、只暴露部分字段给访问者，所以就建一个虚表，就是视图。
3、查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异</code></pre><h1 id="说一说三个范式。"><a href="#说一说三个范式。" class="headerlink" title="说一说三个范式。"></a>说一说三个范式。</h1><pre><code>第一范式（1NF）：属性唯一
  数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。
第二范式（2NF）：记录唯一
  2:要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情
第三范式（3NF）：表唯一
  3:表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）</code></pre><h1 id="数据库的乐观锁和悲观锁是什么？"><a href="#数据库的乐观锁和悲观锁是什么？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？"></a>数据库的乐观锁和悲观锁是什么？</h1><pre><code>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。
悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作
乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</code></pre><h1 id="Mysql中有哪几种锁？"><a href="#Mysql中有哪几种锁？" class="headerlink" title="Mysql中有哪几种锁？"></a>Mysql中有哪几种锁？</h1><pre><code>1.表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
2.行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
3. 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</code></pre><h1 id="mysql有哪些引擎"><a href="#mysql有哪些引擎" class="headerlink" title="mysql有哪些引擎"></a>mysql有哪些引擎</h1><pre><code> MyISAM
Heap
Merge
INNODB
ISAM</code></pre><h1 id="简述在MySQL数据库中MyISAM和InnoDB的区别"><a href="#简述在MySQL数据库中MyISAM和InnoDB的区别" class="headerlink" title="简述在MySQL数据库中MyISAM和InnoDB的区别"></a>简述在MySQL数据库中MyISAM和InnoDB的区别</h1><pre><code>MyISAM：
  不支持事务，但是每次查询都是原子的；
  支持表级锁，即每次操作是对整个表加锁；
  存储表的总行数；
  一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；
  采用菲聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。
InnoDb
  支持ACID的事务，支持事务的四种隔离级别；
  支持行级锁及外键约束：因此可以支持写并发；
  不存储总行数；
  一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制；
  主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。</code></pre><h1 id="主键和候选键有什么区别？"><a href="#主键和候选键有什么区别？" class="headerlink" title="主键和候选键有什么区别？"></a>主键和候选键有什么区别？</h1><pre><code>表格的每一行都由主键唯一标识,一个表只有一个主键。
主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</code></pre><h1 id="myisamchk是用来做什么的？"><a href="#myisamchk是用来做什么的？" class="headerlink" title="myisamchk是用来做什么的？"></a>myisamchk是用来做什么的？</h1><pre><code>它用来压缩MyISAM表，这减少了磁盘或内存使用。</code></pre><h1 id="MyISAM-Static和MyISAM-Dynamic有什么区别？"><a href="#MyISAM-Static和MyISAM-Dynamic有什么区别？" class="headerlink" title="MyISAM Static和MyISAM Dynamic有什么区别？"></a>MyISAM Static和MyISAM Dynamic有什么区别？</h1><pre><code>在MyISAM Static上的所有字段有固定宽度。动态MyISAM表将具有像TEXT，BLOB等字段，以适应不同长度的数据类型。

MyISAM Static在受损情况下更容易恢复。</code></pre><h1 id="如果一个表有一列定义为TIMESTAMP，将发生什么？"><a href="#如果一个表有一列定义为TIMESTAMP，将发生什么？" class="headerlink" title="如果一个表有一列定义为TIMESTAMP，将发生什么？"></a>如果一个表有一列定义为TIMESTAMP，将发生什么？</h1><pre><code>每当行被更改时，时间戳字段将获取当前时间戳。</code></pre><h1 id="列设置为AUTO-INCREMENT时，如果在表中达到最大值，会发生什么情况？"><a href="#列设置为AUTO-INCREMENT时，如果在表中达到最大值，会发生什么情况？" class="headerlink" title="列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？"></a>列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？</h1><pre><code>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</code></pre><h1 id="怎样才能找出最后一次插入时分配了哪个自动增量？"><a href="#怎样才能找出最后一次插入时分配了哪个自动增量？" class="headerlink" title="怎样才能找出最后一次插入时分配了哪个自动增量？"></a>怎样才能找出最后一次插入时分配了哪个自动增量？</h1><pre><code>LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。</code></pre><h1 id="你怎么看到为表格定义的所有索引？"><a href="#你怎么看到为表格定义的所有索引？" class="headerlink" title="你怎么看到为表格定义的所有索引？"></a>你怎么看到为表格定义的所有索引？</h1><pre><code>SHOW INDEX FROM</code></pre><h1 id="LIKE声明中的％和-是什么意思？"><a href="#LIKE声明中的％和-是什么意思？" class="headerlink" title="LIKE声明中的％和_是什么意思？"></a>LIKE声明中的％和_是什么意思？</h1><pre><code>％对应于0个或更多字符，_只是LIKE语句中的一个字符。
子主题 2</code></pre><h1 id="如何在Unix和Mysql时间戳之间进行转换？"><a href="#如何在Unix和Mysql时间戳之间进行转换？" class="headerlink" title="如何在Unix和Mysql时间戳之间进行转换？"></a>如何在Unix和Mysql时间戳之间进行转换？</h1><pre><code>UNIX_TIMESTAMP是从Mysql时间戳转换为Unix时间戳的命令
FROM_UNIXTIME是从Unix时间戳转换为Mysql时间戳的命令</code></pre><h1 id="列对比运算符是什么？"><a href="#列对比运算符是什么？" class="headerlink" title="列对比运算符是什么？"></a>列对比运算符是什么？</h1><pre><code>在SELECT语句的列比较中使用=，&lt;&gt;，&lt;=，&lt;，&gt; =，&gt;，&lt;&lt;，&gt;&gt;，&lt;=&gt;，AND，OR或LIKE运算符。</code></pre><h1 id="BLOB和TEXT有什么区别？"><a href="#BLOB和TEXT有什么区别？" class="headerlink" title="BLOB和TEXT有什么区别？"></a>BLOB和TEXT有什么区别？</h1><pre><code>BLOB是一个二进制对象，可以容纳可变数量的数据。TEXT是一个不区分大小写的BLOB。
BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。</code></pre><h1 id="mysql-fetch-array和mysql-fetch-object的区别是什么？"><a href="#mysql-fetch-array和mysql-fetch-object的区别是什么？" class="headerlink" title="mysql_fetch_array和mysql_fetch_object的区别是什么？"></a>mysql_fetch_array和mysql_fetch_object的区别是什么？</h1><pre><code>mysql_fetch_array（） – 将结果行作为关联数组或来自数据库的常规数组返回。
mysql_fetch_object – 从数据库返回结果行作为对象。</code></pre><h1 id="MyISAM表格将在哪里存储，并且还提供其存储格式？"><a href="#MyISAM表格将在哪里存储，并且还提供其存储格式？" class="headerlink" title="MyISAM表格将在哪里存储，并且还提供其存储格式？"></a>MyISAM表格将在哪里存储，并且还提供其存储格式？</h1><pre><code>每个MyISAM表格以三种格式存储在磁盘上：
·“.frm”文件存储表定义
·数据文件具有“.MYD”（MYData）扩展名
索引文件具有“.MYI”（MYIndex）扩展名</code></pre><h1 id="Mysql如何优化DISTINCT？"><a href="#Mysql如何优化DISTINCT？" class="headerlink" title="Mysql如何优化DISTINCT？"></a>Mysql如何优化DISTINCT？</h1><pre><code>DISTINCT在所有列上转换为GROUP BY，并与ORDER BY子句结合使用。</code></pre><h1 id="如何显示前50行？"><a href="#如何显示前50行？" class="headerlink" title="如何显示前50行？"></a>如何显示前50行？</h1><pre><code>SELECT*FROM LIMIT 0,50;</code></pre><h1 id="可以使用多少列创建索引？"><a href="#可以使用多少列创建索引？" class="headerlink" title="可以使用多少列创建索引？"></a>可以使用多少列创建索引？</h1><pre><code>任何标准表最多可以创建16个索引列。</code></pre><h1 id="NOW（）和CURRENT-DATE（）有什么区别？"><a href="#NOW（）和CURRENT-DATE（）有什么区别？" class="headerlink" title="NOW（）和CURRENT_DATE（）有什么区别？"></a>NOW（）和CURRENT_DATE（）有什么区别？</h1><pre><code>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。
CURRENT_DATE（）仅显示当前年份，月份和日期。</code></pre><h1 id="什么是非标准字符串类型？"><a href="#什么是非标准字符串类型？" class="headerlink" title="什么是非标准字符串类型？"></a>什么是非标准字符串类型？</h1><pre><code>TINYTEXT
 TEXT
 MEDIUMTEXT
 LONGTEXT</code></pre><h1 id="什么是通用SQL函数？"><a href="#什么是通用SQL函数？" class="headerlink" title="什么是通用SQL函数？"></a>什么是通用SQL函数？</h1><pre><code>CONCAT(A, B) – 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。
FORMAT(X, D)- 格式化数字X到D有效数字。
CURRDATE(), CURRTIME()- 返回当前日期或时间。
NOW（） – 将当前日期和时间作为一个值返回。
MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） – 从日期值中提取给定数据。
HOUR（），MINUTE（），SECOND（） – 从时间值中提取给定数据。
DATEDIFF（A，B） – 确定两个日期之间的差异，通常用于计算年龄
SUBTIMES（A，B） – 确定两次之间的差异。
FROMDAYS（INT） – 将整数天数转换为日期值。</code></pre><h1 id="MYSQL支持事务吗？"><a href="#MYSQL支持事务吗？" class="headerlink" title="MYSQL支持事务吗？"></a>MYSQL支持事务吗？</h1><pre><code>在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。
但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，
你的MYSQL就可以使用事务处理,使用SET AUTOCOMMIT=0就可以使MYSQL允许在非autocommit模式，
在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。</code></pre><h1 id="mysql里记录货币用什么字段类型好"><a href="#mysql里记录货币用什么字段类型好" class="headerlink" title="mysql里记录货币用什么字段类型好"></a>mysql里记录货币用什么字段类型好</h1><pre><code>NUMERIC
DECIMAL
  salary DECIMAL(9,2)
  9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。
  因此，在这种情况下，能被存储在salary列中的值的范围是从-9999999.99到9999999.99。</code></pre><h1 id="mysql有关权限的表都有哪几个？"><a href="#mysql有关权限的表都有哪几个？" class="headerlink" title="mysql有关权限的表都有哪几个？"></a>mysql有关权限的表都有哪几个？</h1><pre><code>Mysql服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。
user
db
table_priv
columns_priv
host</code></pre><h1 id="列的字符串类型可以是什么？"><a href="#列的字符串类型可以是什么？" class="headerlink" title="列的字符串类型可以是什么？"></a>列的字符串类型可以是什么？</h1><pre><code>字符串类型是：
 SET
 BLOB
 ENUM
 CHAR
 TEXT</code></pre><h1 id="MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年-怎么优化？"><a href="#MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年-怎么优化？" class="headerlink" title="MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？"></a>MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？</h1><pre><code>a. 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。
b. 选择合适的表字段数据类型和存储引擎，适当的添加索引。
c. mysql库主从读写分离。
d. 找规律分表，减少单表中的数据量提高查询速度。
e。添加缓存机制，比如memcached，apc等。
f. 不经常改动的页面，生成静态页面。
g. 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE.</code></pre><h1 id="锁的优化策略"><a href="#锁的优化策略" class="headerlink" title="锁的优化策略"></a>锁的优化策略</h1><pre><code>1. 读写分离
2. 分段加锁
3. 减少锁持有的时间
4. 多个线程尽量以相同的顺序去获取资源
不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁。</code></pre><h1 id="索引的底层实现原理和优化"><a href="#索引的底层实现原理和优化" class="headerlink" title="索引的底层实现原理和优化"></a>索引的底层实现原理和优化</h1><pre><code>B+树，经过优化的B+树
主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此InnoDB建议为大部分表使用默认自增的主键作为主索引。</code></pre><h1 id="什么情况下设置了索引但无法使用"><a href="#什么情况下设置了索引但无法使用" class="headerlink" title="什么情况下设置了索引但无法使用"></a>什么情况下设置了索引但无法使用</h1><pre><code>1.以“%”开头的LIKE语句，模糊匹配
2. OR语句前后没有同时使用索引
3. 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）</code></pre><h1 id="实践中如何优化MySQL"><a href="#实践中如何优化MySQL" class="headerlink" title="实践中如何优化MySQL"></a>实践中如何优化MySQL</h1><pre><code>1.SQL语句及索引的优化
2. 数据库表结构的优化
3.系统配置的优化
4.硬件的优化</code></pre><h1 id="优化数据库的方法"><a href="#优化数据库的方法" class="headerlink" title="优化数据库的方法"></a>优化数据库的方法</h1><pre><code>选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如’省份’、’性别’最好适用ENUM
使用连接(JOIN)来代替子查询
适用联合(UNION)来代替手动创建的临时表
事务处理
锁定表、优化事务处理
适用外键，优化锁定表
建立索引
优化查询语句</code></pre>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql优化</title>
    <url>/2020/04/16/mysql%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>所谓超级读书法就是，读一段不会则停下来把之前的内容再读一遍，以此类推<br>                                                            ——费曼<br>孔子曰：温故而知新可以为师已<br>不知谁说的： 读书百遍，其义自见</p>
<p>mysql优化</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="两个瓶颈"><a href="#两个瓶颈" class="headerlink" title="两个瓶颈"></a>两个瓶颈</h2><pre><code>CPU
    CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候。
I/O
    磁盘I/O瓶颈发生在装入数据远大于内存容量的时候
    应用分布在网络上，那么查询量相当大的时候那么平瓶颈就会出现在网络上。</code></pre><h2 id="如何查看系统性能"><a href="#如何查看系统性能" class="headerlink" title="如何查看系统性能"></a>如何查看系统性能</h2><pre><code>mpstat
iostat
sar
vmstat</code></pre><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><pre><code>1 什么是索引
    加速查询最好的方法就是索引。
    类似于图书的目录
2.索引类型
     普通索引
            是最基本的索引，它没有任何限制。
     唯一索引
            与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
     组合索引
            指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。
     主键索引
            是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引
     全文索引
            主要用来查找文本中的关键字，而不是直接与索引中的值相比较
            它更像是一个搜索引擎
            fulltext索引配合match against操作使用
            可以在create table，alter table ，create index使用
            目前只有char、varchar，text 列上可以创建全文索引
            先插入数据再建索引比建表时先建索引再插入数据效率高
3.索引优化
    1 只要列中含有NULL值，就最好不要在此例设置索引，复合索引如果有NULL值，此列在使用时也不会使用索引
     2 尽量使用短索引，如果可以，应该制定一个前缀长度
     3 对于经常在where子句使用的列，最好设置索引，这样会加快查找速度
     4 对于有多个列where或者order by子句的，应该建立复合索引
     5 对于like语句，以%或者‘-’开头的不会使用索引，以%结尾会使用索引
     6 尽量不要在列上进行运算（函数操作和表达式操作）
     7 尽量不要使用not in和&lt;&gt;操作</code></pre><h2 id="SQL慢查询的优化"><a href="#SQL慢查询的优化" class="headerlink" title="SQL慢查询的优化"></a>SQL慢查询的优化</h2><pre><code>1.如何捕获低效sql
    1）slow_query_log
            这个参数设置为ON，可以捕获执行时间超过一定数值的SQL语句。
    2）ong_query_time
            当SQL语句执行时间超过此数值时，就会被记录到日志中，建议设置为1或者更短。
    3）slow_query_log_file
            记录日志的文件名。
    4）log_queries_not_using_indexes
            这个参数设置为ON，可以捕获到所有未使用索引的SQL语句，尽管这个SQL语句有可能执行得挺快。
2.慢查询优化的基本步骤
    1)先运行看看是否真的很慢，注意设置SQL_NO_CACHE
    2）where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高
    3)explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）
    4)order by limit 形式的sql语句让排序的表优先查
    5)了解业务方使用场景
    6)加索引时参照建索引的几大原则
    7)观察结果，不符合预期继续从1开始分析
2.优化原则
     1查询时，能不要*就不用*，尽量写全字段名
     2 大部分情况连接效率远大于子查询
     3 多使用explain和profile分析查询语句
     4 查看慢查询日志，找出执行时间长的sql语句优化
     5 多表连接时，尽量小表驱动大表，即小表 join 大表
    6  在千万级分页时使用limit
    7  对于经常使用的查询，可以开启缓存</code></pre><h2 id="数据库表优化"><a href="#数据库表优化" class="headerlink" title="数据库表优化"></a>数据库表优化</h2><pre><code>1 表的字段尽可能用NOT NULL
2 字段长度固定的表查询会更快
3 把数据库的大表按时间或一些标志分成小表
4 将表拆分
    水平切分:将记录散列到不同的表中，各表的结构完全相同，每次从分表中查询, 提高效率。
    垂直切分:将表中大字段单独拆分到另外一张表, 形成一对一的关系。</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><pre><code>索引的优化
  sql语句的优化
  表的优化
  在高并发网络环境下，除了优化数据库外，还会涉及到分布式缓存，CDN，数据库读写分离等高并发优化技术
mysql优化18条
  1 只要列中含有NULL值，就最好不要在此例设置索引，复合索引如果有NULL值，此列在使用时也不会使用索引
   2 尽量使用短索引，如果可以，应该制定一个前缀长度
   3 对于经常在where子句使用的列，最好设置索引，这样会加快查找速度
   4 对于有多个列where或者order by子句的，应该建立复合索引
   5 对于like语句，以%或者‘-’开头的不会使用索引，以%结尾会使用索引
   6 尽量不要在列上进行运算（函数操作和表达式操作）
   7 尽量不要使用not in和&lt;&gt;操作
   1查询时，能不要*就不用*，尽量写全字段名
   2 大部分情况连接效率远大于子查询
   3 多使用explain和profile分析查询语句
   4 查看慢查询日志，找出执行时间长的sql语句优化
   5 多表连接时，尽量小表驱动大表，即小表 join 大表
  6  在千万级分页时使用limit
  7  对于经常使用的查询，可以开启缓存
  1 表的字段尽可能用NOT NULL
  2 字段长度固定的表查询会更快
  3 把数据库的大表按时间或一些标志分成小表
  4 将表拆分
    水平切分:将记录散列到不同的表中，各表的结构完全相同，每次从分表中查询, 提高效率。
    垂直切分:将表中大字段单独拆分到另外一张表, 形成一对一的关系。</code></pre>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试，mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>spring mvc 控制台输出乱码</title>
    <url>/2019/09/03/spring-mvc-%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<p>1、运行环境：<br>操作系统系统：Mac OS X10.12.6，语言：英文<br>开发工具：IntelliJ IDEA 2017.2.2，默认编码：UTF-8<br>Tomcat:9.0.0.M26<br>2、问题：运行Web项目时，控制台输出乱码。<br>3、解决方法：<br>设置Servlet的VM options(虚拟机选项)为：-Dfile.encoding=UTF-8<br><img src="/images/vmset.png" alt=""></p>
<p><a href="https://www.cnblogs.com/gdwkong/p/7457181.html" target="_blank" rel="noopener">来源</a></p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>springmvc在controller方法里面跳转外网的方法  </title>
    <url>/2019/09/27/springmvc%E5%9C%A8controller%E6%96%B9%E6%B3%95%E9%87%8C%E9%9D%A2%E8%B7%B3%E8%BD%AC%E5%A4%96%E7%BD%91%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>1.return new ModelAndView(new RedirectView(“<a href="https://www.baidu.com&quot;" target="_blank" rel="noopener">https://www.baidu.com&quot;</a>));</p>
<p>2.return  “redirect:<a href="https://www.baidu.com/&quot;" target="_blank" rel="noopener">https://www.baidu.com/&quot;</a>;</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu16.04The System is running in low-graphics mode终极解决办法</title>
    <url>/2018/04/26/ubuntu16-04_The_system_is_running_in_low_graphics_mode%E7%BB%88%E6%9E%81%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<h2 id="问题-The-system-is-running-in-low-graphics-mode"><a href="#问题-The-system-is-running-in-low-graphics-mode" class="headerlink" title="问题: The system is running in low-graphics mode"></a>问题: The system is running in low-graphics mode</h2><h2 id="引用-https-blog-csdn-net-gpwner-article-details-79178832"><a href="#引用-https-blog-csdn-net-gpwner-article-details-79178832" class="headerlink" title="引用: https://blog.csdn.net/gpwner/article/details/79178832"></a>引用: <a href="https://blog.csdn.net/gpwner/article/details/79178832" target="_blank" rel="noopener">https://blog.csdn.net/gpwner/article/details/79178832</a></h2><p>大道至简,找了好多答案,最后发现这种方法最简单</p>
<p>sudo apt update</p>
<p>sudo apt upgrade</p>
]]></content>
      <categories>
        <category>异常处理</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat9因为在清除过期缓存条目后可用空间仍不足 - 请考虑增加缓存的最大空间。</title>
    <url>/2019/08/29/tomcat9%E5%9B%A0%E4%B8%BA%E5%9C%A8%E6%B8%85%E9%99%A4%E8%BF%87%E6%9C%9F%E7%BC%93%E5%AD%98%E6%9D%A1%E7%9B%AE%E5%90%8E%E5%8F%AF%E7%94%A8%E7%A9%BA%E9%97%B4%E4%BB%8D%E4%B8%8D%E8%B6%B3-%E8%AF%B7%E8%80%83%E8%99%91%E5%A2%9E%E5%8A%A0%E7%BC%93%E5%AD%98%E7%9A%84%E6%9C%80%E5%A4%A7%E7%A9%BA%E9%97%B4%E3%80%82/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>因为在清除过期缓存条目后可用空间仍不足 - 请考虑增加缓存的最大空间。</p>
<pre><code># 进入Tomcat安装位置
$CATALINA_HOME/
$ vim ../libexec/conf/context.xml

将下面代码添加到 &lt;Context&gt; &lt;/Context&gt;中
&lt;Resources
         cachingAllowed=&quot;true&quot;
         cacheMaxSize=&quot;100000&quot;
     /&gt;</code></pre>]]></content>
      <tags>
        <tag>java tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>redis面试题</title>
    <url>/2020/04/16/redis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="双写一致问题"><a href="#双写一致问题" class="headerlink" title="双写一致问题"></a>双写一致问题</h2><pre><code>非原子操作，多线程一定会发生
解决方案：延时双删策略
    先删Redis，再删数据库，再删Redis
知乎答案</code></pre><h2 id="redis与memcached有什么区别？为什么选用redis作为缓存的中间件"><a href="#redis与memcached有什么区别？为什么选用redis作为缓存的中间件" class="headerlink" title="redis与memcached有什么区别？为什么选用redis作为缓存的中间件"></a>redis与memcached有什么区别？为什么选用redis作为缓存的中间件</h2><pre><code>1： Redis支持数据结构多，如果需要缓存支持负责的结构，Redis是不错的选择
2： Redis天生支持集群，memcached需要依赖客户端来实现往集群中分片写入数据
3： 性能对比
    1 Redis单核，所以平均每个核上Redis处理小数据时性能优于memcached
    2 memcached多核,处理大于100k数据时优于Redis
4.Redis支持数据的备份，即master-slave模式的数据备份。
3.Redis可以持久化其数据</code></pre><h2 id="说说redis线程模型"><a href="#说说redis线程模型" class="headerlink" title="说说redis线程模型"></a>说说redis线程模型</h2><pre><code>1 file event handler
    内部使用文件事件处理器 file event handler，这个是单线程的，所以redis才叫单线程的模型
    结构
            1多个socket
            2 io多路复用程序
            3文件时间分派器
            4 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）
2 io多路复用机制同时监听多个socket
    采用io多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器进行处理。</code></pre><h2 id="Redis有哪些数据结构啊？"><a href="#Redis有哪些数据结构啊？" class="headerlink" title="Redis有哪些数据结构啊？"></a>Redis有哪些数据结构啊？</h2><pre><code>普通青年
    1String
            二进制安全的字符串，最大512M
    2 Hash
    3 List
            按照添加顺序保持顺序的字符串列表
    4 Set
            无序的字符串集合，不存在重复的元素。
    5 SortedSet(/Zset)
            已排序的字符串集合。
2B青年
    1 HyperLogLog
    2 Geo
    3 Pub
    4 Sub
文艺青年
    1 Redis Module
    2 BloomFilter
    3 RedisSearch
    4 Redis-ML</code></pre><h2 id="如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h2><pre><code>1 过期时间设置的过于集中，到过期的时候，Redis可能会出现短暂的卡顿现象，
2 严重会雪崩
3 一般在时间上加一个随机值，使得过期时间分散一些
4 示例：如电商的首页</code></pre><h2 id="你使用过Redis分布式锁么，它是怎么回事？"><a href="#你使用过Redis分布式锁么，它是怎么回事？" class="headerlink" title="你使用过Redis分布式锁么，它是怎么回事？"></a>你使用过Redis分布式锁么，它是怎么回事？</h2><pre><code>1 setnx
    先拿setnx来争抢锁
2 expire
    抢到之后，再用Expire给锁加一个过期时间防止锁忘记释放</code></pre><h2 id="如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？"><a href="#如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？" class="headerlink" title="如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？"></a>如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？</h2><pre><code>set指令有个非常复杂的参数EX，这个应该是可以同时把setnx和expire合成一条指令来用的</code></pre><h2 id="假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？"><a href="#假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？" class="headerlink" title="假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？"></a>假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？</h2><pre><code>使用keys指令可以扫出指定模式的key列表</code></pre><h2 id="继续追问：如果这个redis正在给线上的业务提供服务，那么使用keys指令会有什么问题"><a href="#继续追问：如果这个redis正在给线上的业务提供服务，那么使用keys指令会有什么问题" class="headerlink" title="继续追问：如果这个redis正在给线上的业务提供服务，那么使用keys指令会有什么问题?"></a>继续追问：如果这个redis正在给线上的业务提供服务，那么使用keys指令会有什么问题?</h2><pre><code>1 redis是单线程的，使用keys会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕
2 可使用scan指令非阻塞的取出
    1 缺点： 有一定重复
    2 单体花费时间比keys长</code></pre><h2 id="redis是怎么持久化的？"><a href="#redis是怎么持久化的？" class="headerlink" title="redis是怎么持久化的？"></a>redis是怎么持久化的？</h2><pre><code>1 rdb
    1 rdb做镜像全量持久化
    2 耗费较长
    3不够实时
    4导致大量丢失数据
    5理解为一整个表全量的数据
    6生成指定时间间隔内的 Redis 内存中数据快照，是一个二进制文件 dumpr.rdb
2 aof
    1 aof做增量持久化
    2 每次操作的日志
    3记录 Redis 除了查询以外的所有写命令，并在Redis 服务启动时，通过重新执行这些命令来还原数据。
3 在redis实例重启时，会使用rdb持久化文件重构内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态
4 机制
    1 aof持久化开启且存在aof文件时，优先加载aof文件
    2 aof关闭或者aof文件不存在时，加载rdb文件
    3 加载aof/rdb文件成功后，redis启动成功
    4 aof/rdb文件存在错误时，redis启动失败并打印错误信息</code></pre><h2 id="redis服务主从数据是怎么交互的？"><a href="#redis服务主从数据是怎么交互的？" class="headerlink" title="redis服务主从数据是怎么交互的？"></a>redis服务主从数据是怎么交互的？</h2><pre><code>1 slave发送psync命令给master
    若这个slave第一次连接到master，他会触发一个全量复制。
2 master就会启动一个线程，生成RDB快照，还会把新的写请求都缓存在内存中
3 RDB文件生成后，master会将这个RDB发送给slave的
4 slave拿到之后做的第一件事情就是写进本地的磁盘，然后加载进内存，
5 然后master会把内存里面缓存的那些新命名都发给slave。</code></pre><h2 id="对方追问如果突然机器停电会怎样"><a href="#对方追问如果突然机器停电会怎样" class="headerlink" title="对方追问如果突然机器停电会怎样?"></a>对方追问如果突然机器停电会怎样?</h2><pre><code>1 取决于aof日志sync属性的配置
2在每一条写指令时都sync一下磁盘，就不会丢失数据，
    在高性能要求下每次都sync是不现实的
3一般都使用定时sync，比如1s/1次，这个时候最多就会丢失1s的数据</code></pre><h2 id="对方继续追问rdb的原理是什么？"><a href="#对方继续追问rdb的原理是什么？" class="headerlink" title="对方继续追问rdb的原理是什么？"></a>对方继续追问rdb的原理是什么？</h2><pre><code>1 fork
    指redis通过创建子进程来进行rdb操作
2 cow
    cow指的是copy on write
            写时复制机制
3 原理
    1 Redis 调用 fork() ，同时拥有父进程和子进程。
    2 子进程将数据集写入到一个临时 RDB 文件中。
    3 当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。
4 优点
    1保存了 Redis 在某个时间点的数据，这种数据比较适合做备份和用于灾难恢复。
    2也可以随时将数据集还原到不同的版本
    RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。
    在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）
5 RDB 的缺点
    服务器故障时丢失数据</code></pre><h2 id="AOF创建原理"><a href="#AOF创建原理" class="headerlink" title="AOF创建原理"></a>AOF创建原理</h2><pre><code>1 AOF 重写和 RDB 创建快照一样，都巧妙地利用了写时复制机制。
2 Redis 执行 fork() ，现在同时拥有父进程和子进程。
3 子进程开始将新 AOF 文件的内容写入到临时文件。
4 对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾
    优点：即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。
5 当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。
6 优点
    只进行追加操作的日志文件，不产生新文件
    AOF文件过大自动优化为恢复当前数据集所需的最小命令集合。
    可以设置不同的 fsync 策略
7 缺点
    文件的体积通常要大于 RDB 文件
    根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。
    在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）
    RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</code></pre><h2 id="Redis的过期策略？"><a href="#Redis的过期策略？" class="headerlink" title="Redis的过期策略？"></a>Redis的过期策略？</h2><pre><code>1定期删除
    默认100s就随机抽一些设置了过期时间的key，去检查是否过期，过期了就删了
            为啥不扫描全部设置了过期时间的key呢？
            线上基本上也都是会设置一定的过期时间的。
            全扫描跟你去查数据库不带where条件不走索引全表扫描一样，100s一次，Redis累都累死了。
2 惰性删除
    见名知意，惰性嘛，我不主动删，我懒，我等你来查询了我看看你过期没，过期就删了还不给你返回，没过期该怎么样就怎么样。</code></pre><h2 id="Redis最后就是如果的如果，定期没删，我也没查询，那可咋整？"><a href="#Redis最后就是如果的如果，定期没删，我也没查询，那可咋整？" class="headerlink" title="Redis最后就是如果的如果，定期没删，我也没查询，那可咋整？"></a>Redis最后就是如果的如果，定期没删，我也没查询，那可咋整？</h2><pre><code>内存淘汰机制！
    noeviction
            返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）
    allkeys-lru
             尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
    volatile-lru
            尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。
    allkeys-random
            回收随机的键使得新添加的数据有空间存放。
    volatile-random
            回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
    volatile-ttl
            回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放</code></pre><h2 id="什么是LRU算法"><a href="#什么是LRU算法" class="headerlink" title="什么是LRU算法"></a>什么是LRU算法</h2><pre><code>1 一种缓存淘汰算法
2 Least recently used，最近最少使用
3 核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”
4实现方式
    LinkedHashMap</code></pre><h2 id="为什么redis那么快"><a href="#为什么redis那么快" class="headerlink" title="为什么redis那么快"></a>为什么redis那么快</h2><pre><code>先吹个牛逼
    Redis采用的是单进程单线程模型的kv数据库，由c编写，官方提供的数据是达到10w的qps（每秒内查询次数）
1 基于内存操作
    完全基于内存，绝大部分请求是纯粹的内存操作，非常快。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1);
2 数据结构优化
    数据结构简单，对数据操作也简单，redis中的数据结构是专门进行设计的
3 单线程
    避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换消耗，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。
4 多路I/O复用模型
    使用多路i/o复用模型，非阻塞io；
5 底层模型不同
    redis直接自己构建了vm机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</code></pre><h2 id="我可以问一下啥是上下文切换吗？为啥可能线程不安全？"><a href="#我可以问一下啥是上下文切换吗？为啥可能线程不安全？" class="headerlink" title="我可以问一下啥是上下文切换吗？为啥可能线程不安全？"></a>我可以问一下啥是上下文切换吗？为啥可能线程不安全？</h2><pre><code>好比你看一本英文书，你看到第十页发现有个单词不会，你加了个书签，然后去查字典，过了一会你回来继续从书签那里读，ok目前为止没问题。
问题来了，你去查字典的时候，别人过来翻了一下你的书，然后走了，然后你回来了，你再看书的时候发现书不是你看的那一页了。</code></pre><h2 id="那他是单线程，我们服务器都是多核的，那不是浪费吗？"><a href="#那他是单线程，我们服务器都是多核的，那不是浪费吗？" class="headerlink" title="那他是单线程，我们服务器都是多核的，那不是浪费吗？"></a>那他是单线程，我们服务器都是多核的，那不是浪费吗？</h2><pre><code>虽然他是单线程的，但是我们可以单机开多个实例啊</code></pre><h2 id="既然提到了单机会有瓶颈，那你们是怎么解决这个瓶颈的？"><a href="#既然提到了单机会有瓶颈，那你们是怎么解决这个瓶颈的？" class="headerlink" title="既然提到了单机会有瓶颈，那你们是怎么解决这个瓶颈的？"></a>既然提到了单机会有瓶颈，那你们是怎么解决这个瓶颈的？</h2><pre><code>redis cluster
主从同步读写分离
Redis cluster支撑n个redis mater node，并且每个master node 都可以挂载多个salve node
这样整个Redis就可以横向扩容了，如果你要吃成更大数据量的缓存，那就横向扩容更多的master节点，每个master节点就能存放更多的数据了。</code></pre><h2 id="Redis还有其他保证集群高可用的方式吗？"><a href="#Redis还有其他保证集群高可用的方式吗？" class="headerlink" title="Redis还有其他保证集群高可用的方式吗？"></a>Redis还有其他保证集群高可用的方式吗？</h2><pre><code>哨兵集群sentinel（森提nou）
哨兵必须用三个实例去保证自己的健壮性，
哨兵+主从并不能保证数据不丢失，但是可以保证集群的高可用
一个机器挂了，剩下两个机器需要选举出来一个执行故障转移，如果只有两台机器的话，挂了一个就剩下一个了，没有哨兵去允许故障转移了</code></pre><h2 id="Redis的同步机制"><a href="#Redis的同步机制" class="headerlink" title="Redis的同步机制"></a>Redis的同步机制</h2><pre><code>1 主从同步，从从同步
2 第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录内存buffer，
3 待完成后将rdb文件全量同步到复制节点
4 复制节点接受完成后将rdb镜像加载到内存
5 加载完成后，通知主节点将期间修改的操作记录同步到点进行重放就完成了同步过程
6 后续的增量数据通过aof日志同步即知，有点类似数据库的binlog。</code></pre><h2 id="Redis-并发竞争key问题如何解决"><a href="#Redis-并发竞争key问题如何解决" class="headerlink" title="Redis 并发竞争key问题如何解决?"></a>Redis 并发竞争key问题如何解决?</h2><pre><code>原因：同时有多个客户端去set一个key。
场景1： 例如有多个请求一起去对某个商品减库存
场景2： 比如有3个请求有序的修改某个key
解决方案：
    1：乐观锁适用于大家一起抢着改同一个key，对修改顺序没有要求的场景。
            watch 命令可以方便的实现乐观锁。
            乐观锁适用于大家一起抢着改同一个key，对修改顺序没有要求的场景。
            原理：watch 命令会监视给定的每一个key，当 exec 时如果监视的任一个key自从调用watch后发生过变化，则整个事务会回滚，不执行任何动作。
            如果你的 redis 使用了数据分片的方式，那么这个方法就不适用了
    2： 分布式锁
            适合分布式环境，不用关心 redis 是否为分片集群模式。
            ZooKeeper
            Redis
    3 时间戳，适合有序场景
    4 消息队列，串行化处理
            在并发量很大的情况下，可以通过消息队列进行串行化处理。这在高并发场景中是一种很常见的解决方案。</code></pre><h2 id="是否使用过Redis集群，集群的原理是什么？"><a href="#是否使用过Redis集群，集群的原理是什么？" class="headerlink" title="是否使用过Redis集群，集群的原理是什么？"></a>是否使用过Redis集群，集群的原理是什么？</h2><pre><code>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。
Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</code></pre><h2 id="如何使用过Redis做异步队列？"><a href="#如何使用过Redis做异步队列？" class="headerlink" title="如何使用过Redis做异步队列？"></a>如何使用过Redis做异步队列？</h2><pre><code>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。
如果不用sleep，list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。
如果想要生产一次消费多次，可以使用pub/sub主题订阅者模式，可以实现1:N的消息队列，但在消费者下线后，生产的消息会丢失，想要持久化的话，需要使用消息队列如rabbitmq等。</code></pre><h2 id="Redis如何实现延时队列？"><a href="#Redis如何实现延时队列？" class="headerlink" title="Redis如何实现延时队列？"></a>Redis如何实现延时队列？</h2><pre><code>使用sortedset
拿时间戳作为score
消息内容作为key调用zadd来生产消息
消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。</code></pre><h2 id="Redis单点吞吐量"><a href="#Redis单点吞吐量" class="headerlink" title="Redis单点吞吐量"></a>Redis单点吞吐量</h2><pre><code>单点TPS达到8万/秒
QPS达到10万/秒</code></pre><h2 id="什么是TPS"><a href="#什么是TPS" class="headerlink" title="什么是TPS"></a>什么是TPS</h2><pre><code>每秒钟最大能处理的请求数
每秒钟处理完的事务次数，一个应用系统1s能完成多少事务处理，一个事务在分布式处理中，可能会对应多个请求，对于衡量单个接口服务的处理能力，用QPS比较合理。</code></pre><h2 id="什么是QPS"><a href="#什么是QPS" class="headerlink" title="什么是QPS"></a>什么是QPS</h2><pre><code>应用系统每秒钟最大能接受的用户访问量
每秒钟处理完请求的次数，注意这里是处理完，具体是指发出请求到服务器处理完成功返回结果。可以理解在server中有个counter，每处理一个请求加1，1秒后counter=QPS。</code></pre><h2 id="Redis哈希槽"><a href="#Redis哈希槽" class="headerlink" title="Redis哈希槽"></a>Redis哈希槽</h2><pre><code>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，
当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中</code></pre><h2 id="Redis集群最大节点个数是多少？"><a href="#Redis集群最大节点个数是多少？" class="headerlink" title="Redis集群最大节点个数是多少？"></a>Redis集群最大节点个数是多少？</h2><pre><code>Redis集群预分好16384个桶(哈希槽)</code></pre><h2 id="Redis事务是什么？"><a href="#Redis事务是什么？" class="headerlink" title="Redis事务是什么？"></a>Redis事务是什么？</h2><pre><code>Redis事务可以一次执行多个命令，有以下特点：
    批量操作在发送 EXEC 命令前被放入队列缓存。
    收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。
    在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。
事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</code></pre><h2 id="Redis线程模型？"><a href="#Redis线程模型？" class="headerlink" title="Redis线程模型？"></a>Redis线程模型？</h2><pre><code>单线程
Redis 4.0 之后的版本却抛弃了单线程模型这一设</code></pre><h2 id="Pipeline有什么好处，为什么要用Pipeline？"><a href="#Pipeline有什么好处，为什么要用Pipeline？" class="headerlink" title="Pipeline有什么好处，为什么要用Pipeline？"></a>Pipeline有什么好处，为什么要用Pipeline？</h2><pre><code>可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。
使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目</code></pre><h2 id="redis常用命令"><a href="#redis常用命令" class="headerlink" title="redis常用命令"></a>redis常用命令</h2><pre><code>Keys
    *表示区配所有，
    以bit开头的，
    查看Exists key是否存在。
Set
    设置 key 对应的值为 string 类型的 value。
setnx
    设置 key 对应的值为 string 类型的 value
    如果 key 已经存在，返回 0，nx 是 not exist 的意思。
Expire
    设置过期时间（单位秒）
TTL
    查看剩下多少时间
    返回负数则key失效，key不存在了
Setex
    设置 key 对应的值为 string 类型的 value，并指定此键值对应的有效期。
Mset
    一次设置多个 key 的值，
    成功返回 ok 表示所有的值都设置了，失败返回 0 表示没有任何值被设置。
Getset
    设置 key 的值
    并返回 key 的旧值
Mget
    一次获取多个 key 的值
    如果对应 key 不存在，则对应返回 nil
Incr
    对 key 的值做加加操作,并返回新的值
    注意 incr 一个不是 int 的 value 会返回错误
    incr 一个不存在的 key，则设置 key 为 1
incrby
    同 incr 类似，加指定值 ，key 不存在时候会设置 key，并认为原来的 value 是 0
Decr
    对 key 的值做的是减减操作，decr 一个不存在 key，则设置 key 为-1
Decrby
    同 decr，减指定值。
Append
    给指定 key 的字符串值追加 value,返回新字符串值的长度。
Strlen
    取指定 key 的 value 值的长度。
persist xxx(取消过期时间)
    选择数据库（0-15库）
Select 0 //选择数据库
move age 1//把age 移动到1库
Randomkey随机返回一个key
Rename重命名
Type 返回数据类型
在bin下的可执行文件
    redis-server ：Redis的服务端
    redis-cli ：命令行客户端
    redis-benchmark ：Redis性能测试工具
    redis-check-aof ：AOF文件修复工具
    redis-check-dump ：RDB文件检测工具
    redis-sentinel : 用于做主备</code></pre><h2 id="Redis启动方式有几种"><a href="#Redis启动方式有几种" class="headerlink" title="Redis启动方式有几种"></a>Redis启动方式有几种</h2><pre><code>不加载配置启动：redis-server
加载配置启动：redis-server /etc/redis.conf
使用docker启动：run -d --rm -v /root/test/redis.conf:/redis.conf --name redis-test -p 6379:6379 redis:5.0.0</code></pre><h2 id="Redis停止方式有几种"><a href="#Redis停止方式有几种" class="headerlink" title="Redis停止方式有几种"></a>Redis停止方式有几种</h2><pre><code>命令行连上redis以后运行shutdown
直接结束redis进程：kill ...
停止docker启动的redis：docker stop redis-test</code></pre><h2 id="Redis常见性能问题解决之道"><a href="#Redis常见性能问题解决之道" class="headerlink" title="Redis常见性能问题解决之道"></a>Redis常见性能问题解决之道</h2><pre><code>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件
如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次
为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内
尽量避免在压力很大的主库上增加从库
(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…
    这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</code></pre><h2 id="redis集群投票机制"><a href="#redis集群投票机制" class="headerlink" title="redis集群投票机制"></a>redis集群投票机制</h2><pre><code>redis集群服务器之间通过互相的ping-pong判断是否节点可以连接上
如果有一半以上的节点去ping一个节点的时候没有回应，集群就认为这个节点宕机了。</code></pre><h2 id="Redis主要有哪些功能？"><a href="#Redis主要有哪些功能？" class="headerlink" title="Redis主要有哪些功能？"></a>Redis主要有哪些功能？</h2><pre><code>1.哨兵（Sentinel）和复制（Replication）
    Sentinel可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能，
    Replication则是负责让一个Redis服务器可以配备多个备份的服务器。
    Redis也是利用这两个功能来保证Redis的高可用的
2.事务
    支持一次性按顺序执行多个命令的能力，并保证其原子性。
3.LUA脚本
    在事务的基础上，如果我们需要在服务端一次性的执行更复杂的操作（包含一些逻辑判断），则lua就可以排上用场了
4.持久化
5.集群（Cluster）
    Cluster
    在Redis官方的分布式方案出来之前，有twemproxy和codis两种方案，这两个方案总体上来说都是依赖proxy来进行分布式的。</code></pre><h2 id="Redis为什么是单线程的？"><a href="#Redis为什么是单线程的？" class="headerlink" title="Redis为什么是单线程的？"></a>Redis为什么是单线程的？</h2><pre><code>多线程处理会涉及到锁，上下文切换，单线程没有这些消耗
Redis是单进程单线程的，Redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</code></pre><h2 id="Redis瓶颈可能是"><a href="#Redis瓶颈可能是" class="headerlink" title="Redis瓶颈可能是"></a>Redis瓶颈可能是</h2><pre><code>机器内存或者网络带宽</code></pre><h2 id="其他开源软件采用的模型"><a href="#其他开源软件采用的模型" class="headerlink" title="其他开源软件采用的模型"></a>其他开源软件采用的模型</h2><pre><code>Nginx：多进程单线程模型
Memcached：单进程多线程模型</code></pre><h2 id="使用Redis的优势？"><a href="#使用Redis的优势？" class="headerlink" title="使用Redis的优势？"></a>使用Redis的优势？</h2><pre><code>1.速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
2. 支持丰富数据类型，支持string，list，set，sorted set，hash
3.支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
4. 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</code></pre><h2 id="Redis集群方案应该怎么做？都有哪些方案？"><a href="#Redis集群方案应该怎么做？都有哪些方案？" class="headerlink" title="Redis集群方案应该怎么做？都有哪些方案？"></a>Redis集群方案应该怎么做？都有哪些方案？</h2><pre><code>1.twemproxy
2.codis，目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。
3.Redis cluster3.0自带的集，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。</code></pre><h2 id="Redis读写分离模型"><a href="#Redis读写分离模型" class="headerlink" title="Redis读写分离模型"></a>Redis读写分离模型</h2><pre><code>通过增加Slave DB的数量，读的性能可以线性增长。为了避免Master DB的单点故障，集群一般都会采用两台Master DB做双机热备，所以整个集群的读和写的可用性都非常高。
读写分离架构的缺陷在于，不管是Master还是Slave，每个节点都必须保存完整的数据，如果在数据量很大的情况下，集群的扩展能力还是受限于单个节点的存储能力，而且对于Write-intensive类型的应用，读写分离架构并不适合。</code></pre><h2 id="Redis数据分片模型"><a href="#Redis数据分片模型" class="headerlink" title="Redis数据分片模型"></a>Redis数据分片模型</h2><pre><code>为了解决读写分离模型的缺陷，可以将数据分片模型应用进来。
可以将每个节点看成都是独立的master，然后通过业务实现数据分片。
结合上面两种模型，可以将每个master设计成由一个master和多个slave组成的模型。</code></pre><h2 id="Redis支持的Java客户端都有哪些？官方推荐用哪个？"><a href="#Redis支持的Java客户端都有哪些？官方推荐用哪个？" class="headerlink" title="Redis支持的Java客户端都有哪些？官方推荐用哪个？"></a>Redis支持的Java客户端都有哪些？官方推荐用哪个？</h2><pre><code>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</code></pre><h2 id="Redis集群的主从复制模型是怎样的？"><a href="#Redis集群的主从复制模型是怎样的？" class="headerlink" title="Redis集群的主从复制模型是怎样的？"></a>Redis集群的主从复制模型是怎样的？</h2><pre><code>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.</code></pre><h2 id="Redis集群会有写操作丢失吗？为什么？"><a href="#Redis集群会有写操作丢失吗？为什么？" class="headerlink" title="Redis集群会有写操作丢失吗？为什么？"></a>Redis集群会有写操作丢失吗？为什么？</h2><pre><code>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</code></pre><h2 id="Redis集群之间是如何复制的？"><a href="#Redis集群之间是如何复制的？" class="headerlink" title="Redis集群之间是如何复制的？"></a>Redis集群之间是如何复制的？</h2><pre><code>异步复制</code></pre><h2 id="Redis如何做内存优化？"><a href="#Redis如何做内存优化？" class="headerlink" title="Redis如何做内存优化？"></a>Redis如何做内存优化？</h2><pre><code>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，
所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面.</code></pre><h2 id="Redis回收进程如何工作的？"><a href="#Redis回收进程如何工作的？" class="headerlink" title="Redis回收进程如何工作的？"></a>Redis回收进程如何工作的？</h2><pre><code>一个客户端运行了新的命令，添加了新的数据。
Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。</code></pre><h2 id="Redis回收使用的是什么算法？"><a href="#Redis回收使用的是什么算法？" class="headerlink" title="Redis回收使用的是什么算法？"></a>Redis回收使用的是什么算法？</h2><pre><code>LRU算法</code></pre><h2 id="Redis有哪些适合的场景？"><a href="#Redis有哪些适合的场景？" class="headerlink" title="Redis有哪些适合的场景？"></a>Redis有哪些适合的场景？</h2><pre><code>1）Session共享(单点登录)
2）页面缓存
3）队列
4）排行榜/计数器
5）发布/订阅</code></pre><h2 id="Redis持久化数据和缓存怎么做扩容？"><a href="#Redis持久化数据和缓存怎么做扩容？" class="headerlink" title="Redis持久化数据和缓存怎么做扩容？"></a>Redis持久化数据和缓存怎么做扩容？</h2><pre><code>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。
如果Redis被当做一个持久化存储使用
    必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。
    否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</code></pre><h2 id="Redis事务相关的命令有哪几个？"><a href="#Redis事务相关的命令有哪几个？" class="headerlink" title="Redis事务相关的命令有哪几个？"></a>Redis事务相关的命令有哪几个？</h2><pre><code>MULTI、EXEC、DISCARD、WATCH</code></pre><h2 id="Redis-key的过期时间和永久有效分别怎么设置？"><a href="#Redis-key的过期时间和永久有效分别怎么设置？" class="headerlink" title="Redis key的过期时间和永久有效分别怎么设置？"></a>Redis key的过期时间和永久有效分别怎么设置？</h2><pre><code>EXPIRE和PERSIST命令。</code></pre><h2 id="Redis如何做大量数据插入？"><a href="#Redis如何做大量数据插入？" class="headerlink" title="Redis如何做大量数据插入？"></a>Redis如何做大量数据插入？</h2><pre><code>Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。</code></pre><h2 id="Redis和Redisson有什么关系？"><a href="#Redis和Redisson有什么关系？" class="headerlink" title="Redis和Redisson有什么关系？"></a>Redis和Redisson有什么关系？</h2><pre><code>Redisson是一个高级的分布式协调Redis客服端
能帮助用户在分布式环境中轻松实现一些Java的对象
     (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</code></pre><h2 id="Jedis与Redisson对比有什么优缺点？"><a href="#Jedis与Redisson对比有什么优缺点？" class="headerlink" title="Jedis与Redisson对比有什么优缺点？"></a>Jedis与Redisson对比有什么优缺点？</h2><pre><code>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；
Redisson实现了分布式和可扩展的Java数据结构
和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。
Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</code></pre><h2 id="为什么要用-Redis-而不用-map-guava-做缓存"><a href="#为什么要用-Redis-而不用-map-guava-做缓存" class="headerlink" title="为什么要用 Redis 而不用 map/guava 做缓存?"></a>为什么要用 Redis 而不用 map/guava 做缓存?</h2><pre><code>缓存分为本地缓存和分布式缓存
使用自带的 map 或者 guava 实现的是本地缓存，
    特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，
    并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。
使用 redis 或 memcached 之类的称为分布式缓存，
    在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。
    缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。</code></pre><h2 id="你知道有哪些Redis分区实现方案？"><a href="#你知道有哪些Redis分区实现方案？" class="headerlink" title="你知道有哪些Redis分区实现方案？"></a>你知道有哪些Redis分区实现方案？</h2><pre><code>客户端分区
    在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。
代理分区
    意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。
    代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。
    redis和memcached的一种代理实现就是Twemproxy
查询路由(Query routing)
    客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点
    Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。</code></pre><h2 id="Redis分区有什么缺点"><a href="#Redis分区有什么缺点" class="headerlink" title="Redis分区有什么缺点"></a>Redis分区有什么缺点</h2><pre><code>涉及多个key的操作通常不会被支持。
同时操作多个key,则不能使用Redis事务
分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集
当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件。
分区时动态扩容或缩容可能非常复杂。</code></pre><h2 id="什么是-RedLock"><a href="#什么是-RedLock" class="headerlink" title="什么是 RedLock"></a>什么是 RedLock</h2><pre><code>Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 Redlock，此种方式比原先的单节点的方法更安全
安全特性：互斥访问，即永远只有一个 client 能拿到锁
避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区
容错性：只要大部分 Redis 节点存活就可以正常提供服务</code></pre><h2 id="布隆过滤器？"><a href="#布隆过滤器？" class="headerlink" title="布隆过滤器？"></a>布隆过滤器？</h2><pre><code>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力
Bitmap：典型的就是哈希表
    缺点是，Bitmap对于每个元素只能记录1bit信息
它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。
Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。
Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</code></pre>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试，redis</tag>
      </tags>
  </entry>
  <entry>
    <title>.zip和.tar.gz的文件有什么区别</title>
    <url>/2018/04/27/zip%E5%92%8C-tar-gz%E7%9A%84%E6%96%87%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="转自-https-blog-csdn-net-suyu-yuan-article-details-52733117"><a href="#转自-https-blog-csdn-net-suyu-yuan-article-details-52733117" class="headerlink" title="转自:https://blog.csdn.net/suyu_yuan/article/details/52733117"></a>转自:<a href="https://blog.csdn.net/suyu_yuan/article/details/52733117" target="_blank" rel="noopener">https://blog.csdn.net/suyu_yuan/article/details/52733117</a></h2><p>.tar.gz 压缩格式用于unix的操作系统,但在windows系统中用WinRar工具</p>
<p>同样可以解压缩tar.gz格式的</p>
<p>zip流行于windows系统上的压缩文件(其他系统也可以打开).zip格式开发且</p>
<p>免费.zip支持分卷压缩,128/256-bitAES加密算法等功能.zip的含义是速度,其</p>
<p>目标是为顶替ARC而诞生的”职业”压缩软件.</p>
<p>tar是”table archive”(磁带存档)的简称,它出现在还没有软盘驱动器 硬盘和</p>
<p>光盘驱动器的计算机早期阶段,随着时间的推移,tar命令逐渐变为一个将很多文件</p>
<p>进行存档的工具,目前许多用于Linux操作系统的程序就是打包为tar档案文件的形式</p>
<p>.在Linux里面,tar一般和其他没有文件管理的压缩算法文件结合使用,用tar打包整</p>
<p>个文件目录结构成一个文件,再用gz,bzip等压缩算法压缩成一次,也是Linux常见的</p>
<p>压缩归档的处理方法.</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>一个bug的旅程</title>
    <url>/2019/09/04/%E4%B8%80%E4%B8%AAbug%E7%9A%84%E6%97%85%E7%A8%8B/</url>
    <content><![CDATA[<p>大家好我叫bug,我爸叫后台,我妈叫大前端(H5,安卓,IOS)<br>听说有一个叫天堂的地方特美,我的目标就是天堂.</p>
<p>一天我懒洋洋的躺在海边,沐浴着和煦得阳光.吃着习惯,吹着<br>海风.意淫着隔壁的漂亮妹子……</p>
<p>突然一个叫测试的家伙发现了我!追着我就跑,非说要超度<br>我到天堂!</p>
<p>天堂有个规矩:不收无名之辈</p>
<p>两条路摆在了我面前</p>
<pre><code>1: 测试拿问题页面 -&gt; 前端 -&gt; 前端提供接口名 参数 返回值 -&gt; 后台
2: 测试拿问题页面 -&gt; 后端 -&gt; 前端 -&gt; 前端提供接口名 参数 返回值 -&gt; 后台</code></pre><p>好吧测试是个傻子一会儿走路线1 一会儿走路线2</p>
<p>我走路线1,很快到了天堂,天堂有好多妹子……</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>上线准备流程</title>
    <url>/2019/04/18/%E4%B8%8A%E7%BA%BF%E5%87%86%E5%A4%87%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="未来校长之家上线准备流程"><a href="#未来校长之家上线准备流程" class="headerlink" title="未来校长之家上线准备流程"></a>未来校长之家上线准备流程</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li><p>搭建生产环境(PHP,Mysql,Redis等已完成)</p>
</li>
<li><p>移动端与web端准备上线包</p>
</li>
<li><p>清除生产垃圾数据</p>
</li>
</ul>
<h2 id="核心流程图"><a href="#核心流程图" class="headerlink" title="核心流程图"></a>核心流程图</h2><p><img src="http://enchoufile.xiaohe.com/%E4%B8%8A%E7%BA%BF%E6%B5%81%E7%A8%8B.png" alt="流程示例"></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><p><a href="http://cop.edu2035.cn/" target="_blank" rel="noopener">点击查看接口调用地址</a></p>
</li>
<li><p>超管生成基础参数非必须</p>
</li>
<li><p>超管权限程序不可修改</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>vim教程</title>
    <url>/2019/06/11/vim%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="linux下-输入命令-vimtutor-基本练习"><a href="#linux下-输入命令-vimtutor-基本练习" class="headerlink" title="linux下 输入命令 vimtutor 基本练习"></a>linux下 输入命令 vimtutor 基本练习</h2><h2 id="vim使用的区域-块-选择"><a href="#vim使用的区域-块-选择" class="headerlink" title="vim使用的区域(块)选择"></a>vim使用的区域(块)选择</h2><pre><code>ctrl+v 块选择</code></pre><h2 id="字符选择"><a href="#字符选择" class="headerlink" title="字符选择"></a>字符选择</h2><pre><code>v 小写的v字符选择</code></pre><h2 id="行选择"><a href="#行选择" class="headerlink" title="行选择"></a>行选择</h2><pre><code>shift+v 大写V行选择</code></pre><h2 id="vim的模式"><a href="#vim的模式" class="headerlink" title="vim的模式"></a>vim的模式</h2><pre><code>esc  进入普通模式

shift + : 进入命令模式

普通模式下 a 在光标尾插入
普通模式下 i 在光标首插入

vim包括一般模式,插入模式,命令模式,区域选择在一般模式下,
选择的区域包括固定黑色,闪动黑色,闪动黑色表示光标位置.
在区域选择的情况下,d删除选择的区域,y复制选择的区域,p
粘贴选择的区域,小写p在当前行的下一行粘贴.大写P在当前行
的上一行粘贴.</code></pre><h2 id="在当前行首添加字符ddd"><a href="#在当前行首添加字符ddd" class="headerlink" title="在当前行首添加字符ddd"></a>在当前行首添加字符ddd</h2><pre><code>命令模式下
.s/^/ddd/g   </code></pre><h2 id="在第三行到第六行添加字符ddd"><a href="#在第三行到第六行添加字符ddd" class="headerlink" title="在第三行到第六行添加字符ddd"></a>在第三行到第六行添加字符ddd</h2><pre><code>3,6s/^/ddd/g</code></pre><h2 id="在当前行尾添加字符ddd"><a href="#在当前行尾添加字符ddd" class="headerlink" title="在当前行尾添加字符ddd"></a>在当前行尾添加字符ddd</h2><pre><code>.s/$/ddd/g</code></pre>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>不止代码</title>
    <url>/2018/07/06/%E4%B8%8D%E6%AD%A2%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>不止代码理解</p>
<p>将学到的东西真正试试,才能理解更加深刻.</p>
<p>I hear and i forget .<br>I see and i remember.<br>I do and i understand.</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>五笔口诀</title>
    <url>/2018/07/25/%E4%BA%94%E7%AC%94%E5%8F%A3%E8%AF%80/</url>
    <content><![CDATA[<p>五笔字型最直观,依照笔画把码编;<br>键名汉字打四下,基本字根请照搬;<br>一二三末取四码,顺序拆分大优先;<br>不足四码要注意,交叉识别补后边</p>
<h2 id="86版五笔字根"><a href="#86版五笔字根" class="headerlink" title="86版五笔字根"></a>86版五笔字根</h2><p>1区横起笔<br>11G 王旁青头戋（兼）五一<br>12F 土士二干十寸雨<br>13D 大犬三（羊）古石厂<br>14S 木丁西<br>15A 工戈草头右框七<br>2区竖起笔<br>21H 目具上止卜虎皮<br>22J 日早两竖与虫依<br>23K 口与川，字根稀<br>24L 田甲方框四车力<br>25M 山由贝，下框几<br>3区撇起笔<br>31T 禾竹一撇双人立，反文条头共三一<br>32R 白手看头三二斤<br>33E 月彡（衫）乃用家衣底<br>34W 人和八，三四里<br>35Q 金勺缺点无尾鱼，犬旁留儿一点夕，氏无七（妻）<br>4区点起笔<br>41Y 言文方广在四一，高头一捺谁人去<br>42U 立辛两点六门疒<br>43I 水旁兴头小倒立<br>44O 火业头，四点米<br>45P 之字军盖道建底，摘礻（示）衤（衣）<br>5区折起笔<br>51N 已半巳满不出己，左框折尸心和羽<br>52B 子耳了也框向上<br>53V 女刀九臼山朝西<br>54C 又巴马，丢矢矣<br>55X 慈母无心弓和匕，幼无力</p>
]]></content>
  </entry>
  <entry>
    <title>关于 getWriter() has already been called for this response 的错误解决办法</title>
    <url>/2019/09/09/%E5%85%B3%E4%BA%8E-getWriter-has-already-been-called-for-this-response-%E7%9A%84%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>上篇Filter、FilterChain、FilterConfig 介绍<br>文中的代码若在多个filter中执行则会报错” getWriter() has already been called for this response “</p>
<p>解决方案为在doFilter() 之前将流关闭.</p>
<pre><code>public void doFilter(ServletRequest request, ServletResponse response,
                        FilterChain chain) throws IOException, ServletException {
       System.out.println(&quot;begin headers-------------------&quot;);
       Enumeration&lt;?&gt; headerNames = ((HttpServletRequest)request).getHeaderNames();

       while(headerNames.hasMoreElements()) {
           String headerName = (String)headerNames.nextElement();
           System.out.println(headerName + &quot;: &quot; + ((HttpServletRequest)request).getHeader(headerName));
       }
       System.out.println(&quot;end headers-------------------&quot;);

       //在调用目标前写入响应内容
       response.setContentType(&quot;text/html; charset=utf-8&quot;);
       PrintWriter out = response.getWriter();
       out.println(&quot;IP地址为：&quot; + request.getRemoteHost() + &quot;&lt;br&gt;&quot;);


       //在目标返回后写入响应内容
       out.println(&quot;&lt;br&gt;名称为encoding的初始化参数的值为：&quot; + paramValue);
       out.println(&quot;&lt;br&gt;当前Web程序的真实路径为：&quot; + filterConfig.getServletContext().getRealPath(&quot;/&quot;));
       out.close(); // 不关闭则会报错 getWriter() has already been called for this response
       chain.doFilter(request, response);
   }</code></pre>]]></content>
      <categories>
        <category>exception</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 lombok 简化 Java 代码  </title>
    <url>/2019/09/25/%E4%BD%BF%E7%94%A8-lombok-%E7%AE%80%E5%8C%96-Java-%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="一个典型的-Java-类"><a href="#一个典型的-Java-类" class="headerlink" title="一个典型的 Java 类"></a>一个典型的 Java 类</h1><pre><code>public class A {

  private int a;

  private String b;

  public int getA() {
    return a;
  }

  public String getB() {
    return b;
  }

  public void setA(int a) {
    this.a = a;
  }

  public void setB(String b) {
    this.b = b;
  }

}</code></pre><p>对于这样一个简单的 Java 类，我们通常需要给每个属性写getter和setter，而这种实际上没有什么太大的意义。当然，如果有的公司或团队使用代码行数评估工作量，还是多写几行吧；同时，可以考虑一下我们团队。</p>
<h1 id="使用-lombok，简化代码"><a href="#使用-lombok，简化代码" class="headerlink" title="使用 lombok，简化代码"></a>使用 lombok，简化代码</h1><p>为了简化getter与setter，lombok 提供了一种机制，帮助我们自动生成这些样板代码。以上的代码，如果使用lombok的话，将变得很简单：</p>
<pre><code>@lombok.Getter
@lombok.Setter
public class A {

    private int a;

    private String b;

}</code></pre><p>顾名思义，lombok.Getter就是生成getter，lombok.Setter就是生成setter。但是，这样真的就可以了么？编译下，让我们看看生成的二进制代码。(请自行下载lombok.jar)</p>
<pre><code>命令行&gt; javac -cp lombok.jar A.java
命令行&gt; javap -c A.class</code></pre><p>输出结果略。可以看到完全一样。</p>
<p>更进一步，如果在编译的时候，加入-g:none选项，甚至可以看到生成的文件完全一样。</p>
<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>虽然我们可以在编译的时候，加入classpath，但是，一般来说，在各类IDE中使用，还是需要特殊处理一下。</p>
<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>加上依赖就好。同时，由于lombok只在编译期才处理，所以并不需要在运行时有这个依赖，可以把scope定义为provided。</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;version&gt;1.16.8&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre><p>值得注意的是，maven的maven-compiler-plugin低版本和lombok高版本不兼容，目前已知maven-compiler-plugin的2.3.X与lombok的1.6.X不兼容。这个需要了解lombok的原理才能进一步说明。</p>
<h2 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h2><p>由于eclipse的默认编译器并不是javac，所以，需要额外安装，基本就是改下引导参数，可以直接运行jar包，或者手动在eclipse.ini里加上参数-Xbootclasspath/a:lombok.jar -javaagent:lombok.jar。</p>
<h2 id="IDEA-IntelliJ"><a href="#IDEA-IntelliJ" class="headerlink" title="IDEA IntelliJ"></a>IDEA IntelliJ</h2><p>虽然IDEA IntelliJ默认使用javac作为编译器，理论上可以不装插件。可是，跳转等特性也随之没了。所以，还是安装个插件吧，直接去仓库里搜索lombok就成。</p>
<p>如果项目中使用高级配置，需要额外注意一下。虽然在编译的时候，lombok配置文件可以在任何能找到的目录，但是，lombok-intellij插件默认并不支持在任何目录，如果有配置文件，建议放在java的源代码根目录中。    </p>
<h1 id="更多-lombok-注解"><a href="#更多-lombok-注解" class="headerlink" title="更多 lombok 注解"></a>更多 lombok 注解</h1><table>
<thead>
<tr>
<th align="left">注解</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">@val</td>
<td align="left">如果你要定义一个final的变量，并且不想写类型，这个可以帮到你。但是，在实际项目中，完全没有使用到。</td>
</tr>
<tr>
<td align="left">@NonNull</td>
<td align="left">这个在参数中使用，如果调用时传了null，就直接抛空指针。</td>
</tr>
<tr>
<td align="left">@Data</td>
<td align="left">@ToString、@EqualsAndHashCode、@Getter、@Setter和@RequiredArgsConstructor注解的集合。</td>
</tr>
<tr>
<td align="left">@Getter与@Setter</td>
<td align="left">作用于属性和类上，自动生成属性的getXXX()和setXXX()方法。若在类上，则对所有属性有效。并可通过AccessLevel参数控制方法的访问级别。</td>
</tr>
<tr>
<td align="left">@ToString</td>
<td align="left">作用于类，自动重写类的ToString()方法。常用的参数有exclude（指定方法中不包含的属性）、callSuper（方法中是否包含父类ToString()方法返回的值）</td>
</tr>
<tr>
<td align="left">@EqualsAndHashCode</td>
<td align="left">作用于类，自动重写类的equals()、hashCode()方法。常用的参数有exclude（指定方法中不包含的属性）、callSuper（方法中是否包含父类ToString()方法返回的值）</td>
</tr>
<tr>
<td align="left">@NoArgsConstructor, @RequiredArgsConstructor和@AllArgsConstructor</td>
<td align="left">作用于类，@NoArgsConstructor自动生成不带参数的构造方法；@RequiredArgsConstructor自动生成带参数的构造方法，主要针对一些需要特殊处理的属性，比如未初始化的final属性；@AllArgsConstructor自动生成包含所有属性的构造方法。</td>
</tr>
<tr>
<td align="left">@Synchronized</td>
<td align="left">作用于方法，可锁定指定的对象，如果不指定，则默认创建创建一个对象锁定。</td>
</tr>
<tr>
<td align="left">@Log，或者直接@Slf4j</td>
<td align="left">作用于类，具体包含@CommonsLog、@Log、@Log4j、@Log4j2、@Slf4j和@XSlf4j，分别对用不同的日志系统。利用此类注解，可为类创建一个log属性。</td>
</tr>
</tbody></table>
<h2 id="sonar源码审查"><a href="#sonar源码审查" class="headerlink" title="sonar源码审查"></a>sonar源码审查</h2><p>sonar是一个源码审查工具。最新版5.X已经支持lombok的全部注解，不再认为是没有使用的变量。但是，旧的4.X还是认为没有使用这些变量。可以后向移植这些包，或者应用单独的补丁。</p>
<p><a href="https://segmentfault.com/a/1190000005133786" target="_blank" rel="noopener">摘自</a></p>
<p><a href="https://docs.sonarqube.org/latest/" target="_blank" rel="noopener">sonar</a></p>
]]></content>
      <categories>
        <category>Lombok</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>lombok</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Shiro</title>
    <url>/2019/09/12/%E5%88%9D%E8%AF%86Shiro/</url>
    <content><![CDATA[<h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p><a href="https://shiro.apache.org" target="_blank" rel="noopener">官网</a></p>
<h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1>]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2020/04/28/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<pre><code>public class Test02 {  
    /** 
     * 单例模式，懒汉式，线程安全 
     */  
    public static class Singleton {  
        private final static Singleton INSTANCE = new Singleton();  
        private Singleton() {  
        }  
        public static Singleton getInstance() {  
            return INSTANCE;  
        }  
    }    
    /** 
     * 单例模式，饿汉式，线程不安全 
     */  
    public static class Singleton2 {  
        private static Singleton2 instance = null;  
        private Singleton2() {  
        }  
        public static Singleton2 getInstance() {  
            if (instance == null) {  
                instance = new Singleton2();  
            }  
            return instance;  
        }  
    }  
    /** 
     * 单例模式，饿汉式，线程安全，多线程环境下效率不高 
     */  
    public static class Singleton3 {  
        private static Singleton3 instance = null;  
        private Singleton3() {  
        }  
        public static synchronized Singleton3 getInstance() {  
            if (instance == null) {  
                instance = new Singleton3();  
            }  
            return instance;  
        }  
    }  
    /** 
     * 单例模式，懒汉式，变种，线程安全 
     */  
    public static class Singleton4 {  
        private static Singleton4 instance = null;  
        static {  
            instance = new Singleton4();  
        }  
        private Singleton4() {  
        }  
        public static Singleton4 getInstance() {  
            return instance;  
        }  
    }  
    /** 
     * 单例模式，使用静态内部类，线程安全【推荐】 
     */  
    public static class Singleton5 {  
        private final static class SingletonHolder {  
            private static final Singleton5 INSTANCE = new Singleton5();  
        }  
        private Singleton5() {  
        }  
        public static Singleton5 getInstance() {  
            return SingletonHolder.INSTANCE;  
        }  
    }  
    /** 
     * 静态内部类，使用枚举方式，线程安全【推荐】 
     */  
    public enum Singleton6 {  
        INSTANCE;  
        public void whateverMethod() {  
        }  
    }  
    /** 
     * 静态内部类，使用双重校验锁，线程安全【推荐】 
     */  
    public static class Singleton7 {  
        private volatile static Singleton7 instance = null;  
        private Singleton7() {  
        }  
        public static Singleton7 getInstance() {  
            if (instance == null) {  
                synchronized (Singleton7.class) {  
                    if (instance == null) {  
                        instance = new Singleton7();  
                    }  
                }  
            }  
            return instance;  
        }  
    }  
    public static void main(String[] args) {  
        System.out.println(Singleton.getInstance() == Singleton.getInstance());  
        System.out.println(Singleton2.getInstance() == Singleton2.getInstance());  
        System.out.println(Singleton3.getInstance() == Singleton3.getInstance());  
        System.out.println(Singleton4.getInstance() == Singleton4.getInstance());  
        System.out.println(Singleton5.getInstance() == Singleton5.getInstance());  
        System.out.println(Singleton6.INSTANCE == Singleton6.INSTANCE);  
        System.out.println(Singleton7.getInstance() == Singleton7.getInstance());  
    }  
}  </code></pre><p><a href="https://wiki.jikexueyuan.com/project/for-offer/question-two.html" target="_blank" rel="noopener">参考1</a><br><a href="https://blog.csdn.net/u011595939/article/details/79972371" target="_blank" rel="noopener">参考2</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>喜迎猪宝</title>
    <url>/2019/03/26/%E5%96%9C%E8%BF%8E%E7%8C%AA%E5%AE%9D/</url>
    <content><![CDATA[<h1 id="2019年三月十三日农历二月初七"><a href="#2019年三月十三日农历二月初七" class="headerlink" title="2019年三月十三日农历二月初七"></a>2019年三月十三日农历二月初七</h1><p>今天是个特殊的日子,阳光明媚,春风和煦,孩子你来到了我们身边.</p>
<p>在过了预产期三天后,在我们得知你有可能超过八斤之后,在你妈妈<br>日渐痛苦(因为你太沉了,累的你妈妈睡不好觉,腰疼,翻身困难,吃饭泛酸水<br>等等),我和你妈还是想顺产,但当你超过预产期又有可能因为羊水<br>浑浊而感染时,我们坚定的认为得刨了!</p>
<p>三月十二号早上我跟你妈还有你芳芳姨一块去人民医院咨询住院事宜,<br>很幸运,接待的医生很热情!当天还有二十几个出院的!医院床位充足,<br>医生在了解了你的情况之后表示:随时可以住院!</p>
<p>中午我跟你妈美美的吃了一顿你奶奶做的家常饭!你妈又在你姥姥家洗了个澡,姥姥还给你妈搓的澡!<br>下午我们就拎着大包小包住院了!住院过程很顺利,不过爸妈还是来的有点儿晚,这时候<br>双人间已经满了,没办法我们只能住三人间,害的你妈跟我抱怨”应该上午来的时候办手续”!</p>
<p>我们住在了三床,隔壁2床是一个顺产的小姑娘!环境说不上多不好,但跟家里比是差多了,我跟你妈都<br>有些不适应!医生警告”不允许离开三层住院部”,可在爸爸在楼下买东西看到别的出来吃饭的孕妇后,<br>果断的决定带你妈回家吃饭,可能的话还想在家过夜.</p>
<p>护士很负责任,吃饭途中就给我们打了电话,询问去处,答曰:吃饭!护士严厉警告:<br>不许出楼,答曰:是是是,前后打了三四通电话,老爸真有点后悔带你妈回家!</p>
<p>上午妈妈进了手术室,在一片手忙脚乱中(包括准备手术铺盖,准备你的抱被…..)<br>等待的过程是漫长的,爸爸想了很多,各种担心,担心妈妈下不了手术台,担心你有啥问题……<br>爸爸长这么大,经历了大大小小无数次考试,但从来没有像今天这样紧张!</p>
<p>大约过了一个半小时吧!姥姥突然叫爸爸过去抱你,原来你跟妈妈不是一个门出来,<br>而爸爸一直在妈妈进去的门口等!你被护士抱着交给了爸爸,你是那么的软,抱被<br>半遮着你的脸,爸爸看不真切你的脸,倒是伸出的小手给了个特写,又细又长,帅!</p>
<p>爸爸把你抱到楼上观察室观察,(前一天睡前妈妈还特意跟爸爸交代一定要亲手抱你上楼,<br>然后寸步不离的看着你,洗澡等,目的就是怕把你弄丢!上手术室前又交代了一遍,伟大的妈妈.<br>你长大可得要对你妈好啊!)然后就下楼等你妈妈出来.</p>
<p>你妈终于出手术室了,豆大的一滴泪挂在她的眼角,她没有一声呻吟,表情坚毅!<br>爸爸从心里佩服你妈,她是个坚强的女子!女儿本柔,为母则刚!爸爸还是第一次<br>从你妈妈身上感触到这种坚强!</p>
<p>这次迎接你到来的有,姥姥,姥爷,奶奶,妈妈,爸爸.因为妈妈是剖腹产,出手术室<br>后要换床,需要人抬,咱们家来人少,主要也是没经验.所以抬妈妈有些困难,还好<br>隔壁床有两位叔叔帮忙一块儿抬的妈妈.他们都是咱们家的大恩人,虽然爸爸也<br>记不清他们了,但爸爸希望你做个好人,做个助人为乐的人.顺便涨了个经验,生孩子<br>家里可得多来点儿人!</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>后端架构图</title>
    <url>/2020/04/11/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="后端架构"><a href="#后端架构" class="headerlink" title="后端架构"></a>后端架构</h1><h2 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h2><pre><code>多线程
队列
高性能网络层
插件
压缩
加密
反射
调度
特性
扩张方法
表达式树</code></pre><h2 id="基础监控"><a href="#基础监控" class="headerlink" title="基础监控"></a>基础监控</h2><h3 id="业务监控"><a href="#业务监控" class="headerlink" title="业务监控"></a>业务监控</h3><pre><code>业务操作完成量
业务操作完成时间</code></pre><h3 id="用户行为"><a href="#用户行为" class="headerlink" title="用户行为"></a>用户行为</h3><pre><code>访问人数、在线人数
访问热点
访问轨迹</code></pre><h3 id="软件应用监控"><a href="#软件应用监控" class="headerlink" title="软件应用监控"></a>软件应用监控</h3><pre><code>执行性能，性能趋势报表图
    页面级别
    方法级别
    数据库操作
可用性
服务、页面使用量
开源组件性能监视</code></pre><h3 id="软件系统监控"><a href="#软件系统监控" class="headerlink" title="软件系统监控"></a>软件系统监控</h3><pre><code>磁盘
内存
CPU
网络</code></pre><h3 id="硬件监控"><a href="#硬件监控" class="headerlink" title="硬件监控"></a>硬件监控</h3><pre><code>硬件资源的消耗趋势（容量规划）
硬件资源的使用趋势（细化到进程）
硬件资源的总体利用率</code></pre><h3 id="通用报警"><a href="#通用报警" class="headerlink" title="通用报警"></a>通用报警</h3><pre><code>基于统计值
基于状态
事件处理流程
短信群发平台
集中化配置
邮件、短信通道
跨平台的客户端
分组+权限+自定义间隔
信息模板
细节报警信息</code></pre><h2 id="页面引擎"><a href="#页面引擎" class="headerlink" title="页面引擎"></a>页面引擎</h2><h3 id="MVC扩展"><a href="#MVC扩展" class="headerlink" title="MVC扩展"></a>MVC扩展</h3><pre><code>基础横切组件封装（ActionFilter等）
模板集中存储+后台修改
IOC支持
执行性能
组件全局注册</code></pre><h3 id="轻量级的ashx容器"><a href="#轻量级的ashx容器" class="headerlink" title="轻量级的ashx容器"></a>轻量级的ashx容器</h3><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><pre><code>脚本样式合并
分布式会话
验证码
各种控件</code></pre><h2 id="横切关注"><a href="#横切关注" class="headerlink" title="横切关注"></a>横切关注</h2><h3 id="日志、异常、状态信息"><a href="#日志、异常、状态信息" class="headerlink" title="日志、异常、状态信息"></a>日志、异常、状态信息</h3><pre><code>集中收集
    MongoDB
后台集中查阅
自动附加信息
异步队列提交</code></pre><h3 id="通用性能"><a href="#通用性能" class="headerlink" title="通用性能"></a>通用性能</h3><pre><code>只要提供Dictionary&lt;string.long&gt;数据源就可以实现性能监控
多级分组
通用性能查看后台（highchart+ajax)
支持各个粒度的数据聚合
数据类型支持TextValue、TotalValue、StateValue、ExpressionValue
数据源支持推模式和拉模式</code></pre><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><pre><code>本地缓存
远端缓存
    基于Redis
各种过期模式
    平滑过期
    绝对时间过期
    依赖过期
过期回调
容量限制</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><pre><code>配置集中化（消除本地配置）
支持横向扩容（同步）
支持复杂类型（自定义类型）
    列表
    字典
    枚举
    继承
    抽象类
配置后台（考虑多环境同步问题)
    考虑实现配置实用率跟踪
自动根据默认值初始化
    考虑默认值的使用策略
全局配配置和私有配置，支持分组
更新回调
    考虑细化到某个点
基于行的版本（同步）控制
高性能
    缓存+数据库</code></pre><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><pre><code>任意数据的同步支持
水平扩容支持
拉模式和推模式支持</code></pre><h3 id="NOSQL客户端"><a href="#NOSQL客户端" class="headerlink" title="NOSQL客户端"></a>NOSQL客户端</h3><pre><code>配置集中
统一的客户端
集群管理</code></pre><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h2 id="分布式数据访问"><a href="#分布式数据访问" class="headerlink" title="分布式数据访问"></a>分布式数据访问</h2><h3 id="ORM特性"><a href="#ORM特性" class="headerlink" title="ORM特性"></a>ORM特性</h3><pre><code>查询表达器
缓存（多级）
关系
延迟加载
映射配置
代码生成
多数据库支持
锁支持
枚举支持</code></pre><h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><pre><code>监控性能
NOSQL集成
领域驱动支持</code></pre><h3 id="Shard特性"><a href="#Shard特性" class="headerlink" title="Shard特性"></a>Shard特性</h3><pre><code>分库规则和路由
分表规则和路由
集群
    高可用
负载均衡策略
    软负载
可用性探测
读写分离
    高性能
分布式事物
多写
迁移辅助
基于元数据还是映射的策略
跨节点排序分页支持</code></pre><h2 id="服务端组件"><a href="#服务端组件" class="headerlink" title="服务端组件"></a>服务端组件</h2><p>  分布式文件系统<br>  分布式缓存系统<br>  分布式计算<br>  分布式存储系统<br>  分布式队列系统<br>  分布式计数器<br>  分布式锁</p>
<h2 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h2><h3 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h3><pre><code>同步调用
异步调用
双向调用
    事件回调
（软）负载均衡
    随机、轮训、最小调用
高级QoS均衡
    根据性能决定均衡策略
失败容错
    重试、日志、后台容错
调用拦截
    增加横切
平滑重启
优雅升降级
分布式事务
批量调用
    提高性能
本地伪装
    本地Mock逻辑用于容错
隐式传参
    客户端和服务端同步上下文
服务分组
    允许一个接口多种实现
客户端代理生成插件
    异步调用</code></pre><h3 id="协议集成"><a href="#协议集成" class="headerlink" title="协议集成"></a>协议集成</h3><pre><code>Hession
WebService
Protobuf
自定义二进制序列化</code></pre><h3 id="集群监控"><a href="#集群监控" class="headerlink" title="集群监控"></a>集群监控</h3><pre><code>可用性
性能
版本
路径
依赖</code></pre><h3 id="动态部署"><a href="#动态部署" class="headerlink" title="动态部署"></a>动态部署</h3><pre><code>服务容器
    守护、更新
自动部署
平滑回滚</code></pre><h3 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h3><pre><code>服务注册发现
服务测试
服务路由
    机房感知、机器、上下文
服务安全限制
    调用验证
    信息加密
服务依赖关系
服务负责人
    信息通知
服务文档
服务声明周期
服务命名空间
服务限流
    并发、流程</code></pre><h1 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h1><p><img src="%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84.png" alt="">        </p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>脑图</tag>
      </tags>
  </entry>
  <entry>
    <title>如何培养孩子的逻辑思维</title>
    <url>/2019/09/27/%E5%A6%82%E4%BD%95%E5%9F%B9%E5%85%BB%E5%AD%A9%E5%AD%90%E7%9A%84%E9%80%BB%E8%BE%91%E6%80%9D%E7%BB%B4/</url>
    <content><![CDATA[<h1 id="逻辑思维能力重要吗？"><a href="#逻辑思维能力重要吗？" class="headerlink" title="逻辑思维能力重要吗？"></a>逻辑思维能力重要吗？</h1><p>答案必然是肯定的，因为它不仅是学好数学必须具备的能力，同时也是学好其他学科，处理日常生活问题所必须具备的能力。</p>
<p>换句话说就是：逻辑思维，其可以成为“做好任何事情”的必要条件.</p>
<h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p>它是一种人类思维的高级形式，即我们所说的“抽象思维”。而一个人想具备很强的逻辑思维能力，往往需要从小开始培养。</p>
<h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>肥宅以为:逻辑思维就是智商最重要的方面之一,甚至之一也可以去掉.</p>
<h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>美国的很多学校，他们从学前班开始就有关于训练孩子逻辑思维能力的数学内容</p>
<p>但在国内，我们对孩子逻辑思维的培养还存在一定的误区，学校往往喜欢让学生做题，找到考试的捷径，却忽视了对数学本质的讲解。</p>
<p>所以当我们没有将数学应用在生活中，这些定理和公式也会随着时间的流逝慢慢被淡忘。</p>
<p>所以将数学应用在生活中也就是锻炼逻辑思维的必要过程</p>
<h2 id="那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。"><a href="#那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。" class="headerlink" title="那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。"></a>那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。</h2><h3 id="动作思维阶段（0-3岁）"><a href="#动作思维阶段（0-3岁）" class="headerlink" title="动作思维阶段（0-3岁）"></a>动作思维阶段（0-3岁）</h3><p>不到3岁的孩子以动作思维为主，思维在动作中进行。比如桌上放着一个苹果，宝宝矮小够不着，怎么办呢?这时候宝宝发现他旁边有凳子，于是把凳子搬过来，自己爬上去，成功地把苹果拿到手。<br>孩子学会借助别的东西来达到自己的目的，是从不断的操作过程中理解的。 孩子最初的动作往往是杂乱无章、漫无目的的，以后在不断的操作过程中了解了动作与结果之间的关系。</p>
<h3 id="具体形象思维阶段（3-6岁）"><a href="#具体形象思维阶段（3-6岁）" class="headerlink" title="具体形象思维阶段（3-6岁）"></a>具体形象思维阶段（3-6岁）</h3><p>3-6岁的孩子具体形象思维占优势，他们缺少立体感和空间感。这也是为什么用数字加减，孩子反应不过来，但是用实物举例子，就容易理解。<br>在这个阶段，家长要注意增加孩子的经验，丰富孩子的词汇，多给孩子动手的机会。有些家长和老师片面地、刻板地教孩子多识字、写字、计算等，对孩子的思维发展并没有好处。</p>
<h3 id="抽象逻辑思维能力（6-11岁）"><a href="#抽象逻辑思维能力（6-11岁）" class="headerlink" title="抽象逻辑思维能力（6-11岁）"></a>抽象逻辑思维能力（6-11岁）</h3><p>6-11岁是培养孩子抽象逻辑思维能力的关键时期。在这一时期要培养孩子正确的思维程序和科学的思维方法。</p>
<p>比如，一只狗有4条腿，两只狗有8条腿，三只狗有多少条腿?像这些问题，就是属于抽象逻辑思维能力题。家长要注意让孩子学会独立思考，不要给孩子现成的答案。    </p>
<h2 id="那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。"><a href="#那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。" class="headerlink" title="那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。"></a>那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。</h2><h3 id="一、丰富孩子的词汇，教孩子说话用词达意"><a href="#一、丰富孩子的词汇，教孩子说话用词达意" class="headerlink" title="一、丰富孩子的词汇，教孩子说话用词达意"></a>一、丰富孩子的词汇，教孩子说话用词达意</h3><p>语言是思维的外壳，尽早教孩子准确用词，不但能防止别人曲解、误解他的意思，而且促使他思维活跃、思路清晰。家长对孩子的话要多问几个为什么，对他的表达要多作分析，这可以使孩子用词准确、鲜明、生动。    </p>
<h3 id="二、有意识地对孩子设疑，给孩子留下思考的时间"><a href="#二、有意识地对孩子设疑，给孩子留下思考的时间" class="headerlink" title="二、有意识地对孩子设疑，给孩子留下思考的时间"></a>二、有意识地对孩子设疑，给孩子留下思考的时间</h3><p>孩子回答问题往往是凭直觉，如果家长满足于孩子的这点“小聪明”，那么，他们会习惯对问题不假思索地做出回答，没有足够的时间让大脑启动思维“程序”。</p>
<p>所以，当孩子遇到问题的时候，家长最好不要急于让他说答案，而是让他多问几个为什么，多想几种解决的方案，多几次对自己的否定，然后在否定中寻找最佳答案。</p>
<h3 id="三、利用游戏促进孩子思维能力的发展"><a href="#三、利用游戏促进孩子思维能力的发展" class="headerlink" title="三、利用游戏促进孩子思维能力的发展"></a>三、利用游戏促进孩子思维能力的发展</h3><p>在日常生活中，可以进行分类和归类的游戏。也可以进行比较动、植物或其他事物、训练理解力和创造力的游戏等。</p>
<p>比如收衣服时，让孩子将不同的袜子分类卷起来；去动物园时，告诉孩子如何通过牙齿区别食草和食肉的动物，并让他分辨；给孩子一些零钱，让孩子去买东西……</p>
<p>对孩子而言，说过的话，玩过的游戏或许会忘记，但日复一日默默培养起来的逻辑思维能力会伴随他们终身，使他们在生活和工作中表现得更为优秀出色。</p>
]]></content>
      <categories>
        <category>育儿</category>
      </categories>
      <tags>
        <tag>育儿</tag>
      </tags>
  </entry>
  <entry>
    <title>手写JVM</title>
    <url>/2019/08/26/%E6%89%8B%E5%86%99JVM/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>数据库回表与覆盖索引</title>
    <url>/2019/08/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9B%9E%E8%A1%A8%E4%B8%8E%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h2><p>oracle中有有一个很明显的物理ID,叫做rowid,这个是全局唯一的.<br>rowid是物理结构上的,在每条记录insert到数据库中时都会有<br>一个唯一的物理记录.</p>
<p>回表:当查询数据时,在索引中查找到该行索引后,根据索引<br>获得该行的rowid,根据rowid再查询表中数据就是回表.</p>
<p>demo</p>
<pre><code>SELECT c1,c2,c3  FROM TEST_TABLE WHERE c1=1  
如果c1列建立了索引。首先会从索引里面根据c1=1 查找出c1的rowid，然后根据rowid去找到数据块中对应的数据，将c1，c2,c3 查出来。

如果c1没有建立索引，那就需要进行全表扫描。到数据块中扫描一番，这样性能不好。</code></pre><h2 id="覆盖索引-不需要回表操作"><a href="#覆盖索引-不需要回表操作" class="headerlink" title="覆盖索引(不需要回表操作)"></a>覆盖索引(不需要回表操作)</h2><p>MySQL可以利用索引返回SELECT 列表中的字段。而不必根据索引再次读取数据文件。包含所有满足查询需要的数据的索引成为覆盖索引(Covering Index)<br>。也就是平时所说的不需要回表操作。</p>
<p>判断标准：</p>
<p>在查询前面使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为using index,MySQL查询优化器在执行查询前会决定是否有索引覆盖查询。<br> 也就是说当前查询所需要的数据直接就可以在索引里面查得到。有时候根据业务，建立多列索引，使用覆盖索引，可以取得相当好的性能优化</p>
<h2 id="回表为什么慢"><a href="#回表为什么慢" class="headerlink" title="回表为什么慢"></a>回表为什么慢</h2><p>回表是磁盘IO,而磁盘IO远远慢于内存操作<br>主要原因还是随机IO，增加了磁盘 IO的次数，<br>所以mysql针对大表扫描都有MRR优化策略.</p>
<p><a href="http://getby.cn/sql__db/2016/0928/93.html" target="_blank" rel="noopener">参考</a>    </p>
]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>回表</tag>
        <tag>覆盖索引</tag>
        <tag>数据库</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>持续集成服务 Travis CI</title>
    <url>/2019/09/27/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%9C%8D%E5%8A%A1-Travis-CI/</url>
    <content><![CDATA[<p><a href="https://www.travis-ci.org/dashboard" target="_blank" rel="noopener">官网</a><br><a href="https://liusir.me/2019/09/21/hexo-基于TravisCI实现hexo博客持续继承" target="_blank" rel="noopener">参考</a><br><a href="http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <categories>
        <category>TravisCI</category>
      </categories>
      <tags>
        <tag>TravisCI</tag>
      </tags>
  </entry>
  <entry>
    <title>如何设计一个秒杀系统</title>
    <url>/2020/05/11/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="高并发系统的几大方向"><a href="#高并发系统的几大方向" class="headerlink" title="高并发系统的几大方向"></a>高并发系统的几大方向</h1><p>1.请求数据尽量少，从而减少cpu消耗</p>
<p>2.访问路径尽量短，减少节点消耗</p>
<p>3.强依赖尽量少，减少加载时间</p>
<p>4.不要有单点，要有备份</p>
<p>5.减少额外请求，减少加载时间</p>
<pre><code>设计技巧
10w级别可能瓶颈就在数据读取上，通过增加缓存一般就能解决

100w那么，可能服务端的网络可能都是瓶颈，所以要把大部分的静态数据放到cdn上甚至缓存在浏览器里</code></pre><h1 id="数据的动静分离"><a href="#数据的动静分离" class="headerlink" title="数据的动静分离"></a>数据的动静分离</h1><h2 id="静态数据做缓存"><a href="#静态数据做缓存" class="headerlink" title="静态数据做缓存"></a>静态数据做缓存</h2><pre><code>第一，你应该把静态数据缓存到离用户最近的地方

第二，静态化改造就是要直接缓存 HTTP 连接</code></pre><h2 id="5-个方面来分离出动态内容"><a href="#5-个方面来分离出动态内容" class="headerlink" title="5 个方面来分离出动态内容"></a>5 个方面来分离出动态内容</h2><pre><code>URL 唯一化

分离浏览者相关的因素

分离时间因素

异步化地域因素

去掉 Cookie</code></pre><h2 id="动态内容的处理通常有两种方案：ESI（Edge-Side-Includes）方案和-CSI（Client-Side-Include）方案。"><a href="#动态内容的处理通常有两种方案：ESI（Edge-Side-Includes）方案和-CSI（Client-Side-Include）方案。" class="headerlink" title="动态内容的处理通常有两种方案：ESI（Edge Side Includes）方案和 CSI（Client Side Include）方案。"></a>动态内容的处理通常有两种方案：ESI（Edge Side Includes）方案和 CSI（Client Side Include）方案。</h2><ul>
<li><p>ESI 方案（或者 SSI）：即在 Web 代理服务器上做动态内容请求，并将请求插入到静态页面中，当用户拿到页面时已经是一个完整的页面了。这种方式对服务端性能有些影响，但是用户体验较好</p>
</li>
<li><p>CSI 方案。即单独发起一个异步 JavaScript 请求，以向服务端获取动态内容。这种方式服务端性能更佳，但是用户端页面可能会延时，体验稍差。</p>
</li>
</ul>
<h2 id="动静分离的几种架构方案"><a href="#动静分离的几种架构方案" class="headerlink" title="动静分离的几种架构方案"></a>动静分离的几种架构方案</h2><pre><code>实体机单机部署；

统一 Cache 层；

上 CDN。</code></pre><h1 id="有针对性地处理好系统的“热点数据”"><a href="#有针对性地处理好系统的“热点数据”" class="headerlink" title="有针对性地处理好系统的“热点数据”"></a>有针对性地处理好系统的“热点数据”</h1><h2 id="为什么要关注热点"><a href="#为什么要关注热点" class="headerlink" title="为什么要关注热点"></a>为什么要关注热点</h2><pre><code>28定律 </code></pre><h2 id="什么是“热点”"><a href="#什么是“热点”" class="headerlink" title="什么是“热点”"></a>什么是“热点”</h2><ul>
<li>热点操作</li>
</ul>
<pre><code>读请求

写请求 
优化方法：存储层根据CAP理论做平衡</code></pre><ul>
<li>热点数据</li>
</ul>
<pre><code>静态热点数据

能够提前预测的热点数据

动态热点数据

不能够提前预测的热点数据</code></pre><h2 id="发现热点数据"><a href="#发现热点数据" class="headerlink" title="发现热点数据"></a>发现热点数据</h2><h3 id="发现静态热点数据"><a href="#发现静态热点数据" class="headerlink" title="发现静态热点数据"></a>发现静态热点数据</h3><pre><code>报名

技术手段提前预测</code></pre><h3 id="发现动态热点数据"><a href="#发现动态热点数据" class="headerlink" title="发现动态热点数据"></a>发现动态热点数据</h3><pre><code>构建一个异步的系统，它可以收集交易链路上各个环节中的中间件产品的热点 Key，如 Nginx、缓存、RPC 服务框架等这些中间件（一些中间件产品本身已经有热点统计模块）。

建立一个热点上报和可以按照需求订阅的热点服务的下发规范，主要目的是通过交易链路上各个系统（包括详情、购物车、交易、优惠、库存、物流等）访问的时间差，把上游已经发现的热点透传给下游系统，提前做好保护。比如，对于大促高峰期，详情系统是最早知道的，在统一接入层上 Nginx 模块统计的热点 URL

将上游系统收集的热点数据发送到热点服务台，然后下游系统（如交易系统）就会知道哪些商品会被频繁调用，然后做热点保护。

重点
(构建一个异步的系统，它可以收集交易链路上各个环节中的中间件产品的热点 Key，如 Nginx、缓存、RPC 服务框架等这些中间件（一些中间件产品本身已经有热点统计模块）。, 建立一个热点上报和可以按照需求订阅的热点服务的下发规范，主要目的是通过交易链路上各个系统（包括详情、购物车、交易、优惠、库存、物流等）访问的时间差，把上游已经发现的热点透传给下游系统，提前做好保护。比如，对于大促高峰期，详情系统是最早知道的，在统一接入层上 Nginx 模块统计的热点 URL, 将上游系统收集的热点数据发送到热点服务台，然后下游系统（如交易系统）就会知道哪些商品会被频繁调用，然后做热点保护。)</code></pre><h2 id="处理热点数据"><a href="#处理热点数据" class="headerlink" title="处理热点数据"></a>处理热点数据</h2><pre><code>一是优化

缓存热点数据

LRU 淘汰算法

二是限制

例如对被访问商品的 ID 做一致性 Hash，然后根据 Hash 做分桶，每个分桶设置一个处理队列，这样可以把热点商品限制在一个请求队列里，防止因某些热点商品占用太多的服务器资源，而使其他请求始终得不到服务器的处理资源。

三是隔离

业务隔离

把秒杀做成一种营销活动，卖家要参加秒杀这种营销活动需要单独报名，从技术上来说，卖家报名后对我们来说就有了已知热点，因此可以提前做好预热。

系统隔离

系统隔离更多的是运行时的隔离，可以通过分组部署的方式和另外 99% 分开。秒杀可以申请单独的域名，目的也是让请求落到不同的集群中。

数据隔离

秒杀所调用的数据大部分都是热点数据，比如会启用单独的 Cache 集群或者 MySQL 数据库来放热点数据，目的也是不想 0.01% 的数据有机会影响 99.99% 数据

隔离的其他办法

比如，你可以按照用户来区分，给不同的用户分配不同的 Cookie，在接入层，路由到不同的服务接口中；再比如，你还可以在接入层针对 URL 中的不同 Path 来设置限流策略。服务层调用不同的服务接口，以及数据层通过给数据打标来区分</code></pre><h1 id="流量削峰这事应该怎么做？"><a href="#流量削峰这事应该怎么做？" class="headerlink" title="流量削峰这事应该怎么做？"></a>流量削峰这事应该怎么做？</h1><h2 id="为什么要削峰"><a href="#为什么要削峰" class="headerlink" title="为什么要削峰"></a>为什么要削峰</h2><ul>
<li><p>平稳</p>
</li>
<li><p>节省服务器的资源成本</p>
</li>
</ul>
<h2 id="方式方法？"><a href="#方式方法？" class="headerlink" title="方式方法？"></a>方式方法？</h2><h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h3><pre><code>消息队列来缓冲瞬时流量，把同步的直接调用转换成异步的间接推送，中间通过一个队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去。

利用线程池加锁等待也是一种常用的排队方式；

先进先出、先进后出等常用的内存排队算法的实现方式；

把请求序列化到文件中，然后再顺序地读文件（例如基于 MySQL binlog 的同步机制）来恢复请求等方式。</code></pre><h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a>答题</h3><pre><code>防止部分买家使用秒杀器在参加秒杀时作弊

延缓请求

题库生成模块

题库的推送模块

题目的图片生成模块

设计思路
(题库生成模块, 题库的推送模块, 题目的图片生成模块)</code></pre><h3 id="分层过滤"><a href="#分层过滤" class="headerlink" title="分层过滤"></a>分层过滤</h3><pre><code>在不同的层次尽可能地过滤掉无效请求，让“漏斗”最末端的才是有效请

分层校验的基本原则是

将动态请求的读数据缓存（Cache）在 Web 端，过滤掉无效的数据读；

对读数据不做强一致性校验，减少因为一致性校验产生瓶颈的问题；

对写数据进行基于时间的合理分片，过滤掉过期的失效请求；

对写请求做限流保护，将超出系统承载能力的请求过滤掉；

对写数据进行强一致性校验，只保留最后有效的数据。</code></pre><h3 id="业务手段"><a href="#业务手段" class="headerlink" title="业务手段"></a>业务手段</h3><pre><code>零点开启

优惠券

抽奖活动</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>一个是通过队列来缓冲请求，即控制请求的发出；一个是通过答题来延长请求发出的时间，在请求发出后承接请求时进行控制，最后再对不符合条件的请求进行过滤；最后一种是对请求进行分层过滤。

队列缓冲能起到很好的削峰和缓冲作用。

答题更适用于秒杀或者营销活动等应用场景

分层过滤非常适合交易性的写请求</code></pre><h1 id="影响性能的因素有哪些？又该如何提高系统的性能？"><a href="#影响性能的因素有哪些？又该如何提高系统的性能？" class="headerlink" title="影响性能的因素有哪些？又该如何提高系统的性能？"></a>影响性能的因素有哪些？又该如何提高系统的性能？</h1><h2 id="影响性能的因素"><a href="#影响性能的因素" class="headerlink" title="影响性能的因素"></a>影响性能的因素</h2><pre><code>QPS（Query Per Second，每秒请求数）

响应时间（Response Time，RT）

“总 QPS =（1000ms / 响应时间）× 线程数量”，一个是一次响应的服务端耗时，一个是处理请求的线程数。</code></pre><h2 id="响应时间和-QPS-有啥关系"><a href="#响应时间和-QPS-有啥关系" class="headerlink" title="响应时间和 QPS 有啥关系"></a>响应时间和 QPS 有啥关系</h2><pre><code>真正对性能有影响的是 CPU 的执行时间

应该致力于减少 CPU 的执行时间</code></pre><h2 id="线程数对-QPS-的影响"><a href="#线程数对-QPS-的影响" class="headerlink" title="线程数对 QPS 的影响"></a>线程数对 QPS 的影响</h2><pre><code>设置什么样的线程数最合理呢

“线程数 = 2 * CPU 核数 + 1”

线程数 = [(线程等待时间 + 线程 CPU 时间) / 线程 CPU 时间] × CPU 数量

当然，最好的办法是通过性能测试来发现最佳的线程数。</code></pre><h2 id="如何发现瓶颈"><a href="#如何发现瓶颈" class="headerlink" title="如何发现瓶颈"></a>如何发现瓶颈</h2><pre><code>缓存系统而言，制约它的是内存

对存储型系统来说 I/O 更容易是瓶颈。

秒杀，它的瓶颈更多地发生在 CPU 上

海量请求涌过来，你的页面又比较大，那么网络就有可能出现瓶颈。</code></pre><h2 id="如何发现CPU瓶颈？使用工具"><a href="#如何发现CPU瓶颈？使用工具" class="headerlink" title="如何发现CPU瓶颈？使用工具"></a>如何发现CPU瓶颈？使用工具</h2><pre><code>JProfiler

Yourkit

jstack 定时地打印调用栈</code></pre><h2 id="怎样简单地判断-CPU-是不是瓶颈呢"><a href="#怎样简单地判断-CPU-是不是瓶颈呢" class="headerlink" title="怎样简单地判断 CPU 是不是瓶颈呢"></a>怎样简单地判断 CPU 是不是瓶颈呢</h2><pre><code>一个办法就是看当 QPS 达到极限时，你的服务器的 CPU 使用率是不是超过了 95%，

如果没有超过，那么表示 CPU 还有提升的空间，要么是有锁限制，要么是有过多的本地 I/O 等待发生。</code></pre><h2 id="如何优化系统"><a href="#如何优化系统" class="headerlink" title="如何优化系统"></a>如何优化系统</h2><pre><code>1. 减少编码

网页输出是可以直接进行流输出的，即用 resp.getOutputStream() 函数写数据，把一些静态的数据提前转化成字节，等到真正往外写的时候再直接用 OutputStream() 函数写，就可以减少静态数据的编码转换。


网页输出是可以直接进行流输出的，即用 resp.getOutputStream() 函数写数据

性能提升30% 左右

2. 减少序列化

避免或者减少 RPC 就可以减少序列化

合并部署

部署到一台机器上

同一个 Tomcat 容器中

且不能走本机的 Socket

3. Java 极致优化

Web 系统做静态化改造，让大部分请求和数据直接在 Nginx 服务器或者 Web 代理服务器（如 Varnish、Squid 等）上直接返回（这样可以减少数据的序列化与反序列化）

直接使用 Servlet 处理请求。避免使用传统的 MVC 框架，这样可以绕过一大堆复杂且用处不大的处理逻辑，节省 1ms 时间（具体取决于你对 MVC 框架的依赖程度）。

直接输出流数据。使用 resp.getOutputStream() 而不是 resp.getWriter() 函数，可以省掉一些不变字符数据的编码，从而提升性能；数据输出时推荐使用 JSON 而不是模板引擎（一般都是解释执行）来输出页面。

4. 并发读优化

放到 Tair 缓存里面

集中式缓存为了保证命中率一般都会采用一致性 Hash，所以同一个 key 会落到同一台机器上。虽然单台缓存机器也能支撑 30w/s 的请求，但还是远不足以应对像“大秒”这种级别的热点商品

答案是采用应用层的 LocalCache，即在秒杀系统的单机上缓存商品相关的数据。

像商品中的“标题”和“描述”这些本身不变的数据，会在秒杀开始之前全量推送到秒杀机器上，并一直缓存到秒杀结束；

像库存这类动态数据，会采用“被动失效”的方式缓存一定时间（一般是数秒），失效后再去缓存拉取最新的数据。</code></pre><h1 id="秒杀系统“减库存”设计的核心逻辑"><a href="#秒杀系统“减库存”设计的核心逻辑" class="headerlink" title="秒杀系统“减库存”设计的核心逻辑"></a>秒杀系统“减库存”设计的核心逻辑</h1><h2 id="减库存有哪几种方式"><a href="#减库存有哪几种方式" class="headerlink" title="减库存有哪几种方式"></a>减库存有哪几种方式</h2><ul>
<li>下单减库存</li>
</ul>
<p>控制最精确</p>
<p>不会出现超卖</p>
<p>有些人下完单可能并不会付款</p>
<ul>
<li>付款减库存</li>
</ul>
<p>并发比较高，有可能出现买家下单后付不了款的情况，因为可能商品已经被其他人买走了。</p>
<ul>
<li>预扣库存</li>
</ul>
<p>买家下单后，库存为其保留一定的时间（如 10 分钟），超过这个时间，库存将会自动释放，释放后其他买家就可以继续购买。在买家付款前，系统会校验该订单的库存是否还有保留：如果没有保留，则再次尝试预扣；如果库存不足（也就是预扣失败）则不允许继续付款；如果预扣成功，则完成付款并实际地减去库存</p>
<h2 id="减库存可能存在的问题"><a href="#减库存可能存在的问题" class="headerlink" title="减库存可能存在的问题"></a>减库存可能存在的问题</h2><ul>
<li>下单减库存</li>
</ul>
<p>恶意下单商品就不能正常售卖</p>
<ul>
<li>付款减库存”又会导致另外一个问题：库存超卖。</li>
</ul>
<p>下单成功但是付不了款，买家的购物体验自然比较差。</p>
<ul>
<li>预扣库存</li>
</ul>
<p>一定程度上缓解上面的问题，但无法彻底解决</p>
<h2 id="解决办法还是要结合安全和反作弊的措施来制止。"><a href="#解决办法还是要结合安全和反作弊的措施来制止。" class="headerlink" title="解决办法还是要结合安全和反作弊的措施来制止。"></a>解决办法还是要结合安全和反作弊的措施来制止。</h2><pre><code>给经常下单不付款的买家进行识别打标（可以在被打标的买家下单时不减库存

给某些类目设置最大购买件数（例如，参加活动的商品一人最多只能买 3 件）

以及对重复下单不付款的操作进行次数限制等。

对普通的商品下单数量超过库存数量的情况，可以通过补货来解决

有些卖家完全不允许库存为负数的情况，那只能在买家付款时提示库存不足。</code></pre><h1 id="大型秒杀中如何减库存？"><a href="#大型秒杀中如何减库存？" class="headerlink" title="大型秒杀中如何减库存？"></a>大型秒杀中如何减库存？</h1><pre><code>下单减库存

由于参加秒杀的商品，一般都是“抢到就是赚到”，所以成功下单后却不付款的情况比较少，再加上卖家对秒杀商品的库存有严格限制，所以秒杀商品采用“下单减库存”更加合理。另外，理论上由于“下单减库存”比“预扣库存”以及涉及第三方支付的“付款减库存”在逻辑上更为简单，所以性能上更占优势。

主要就是保证大并发请求时库存数据不能为负数

一种是在应用程序中通过事务来判断，即保证减后库存不能为负数，否则就回滚；

另一种办法是直接设置数据库的字段数据为无符号整数，这样减后库存字段值小于零时会直接执行 SQL 语句来报错

再有一种就是使用 CASE WHEN 判断语句，例如这样的 SQL 语句：

UPDATE item SET inventory = CASE WHEN inventory &gt;= xxx THEN inventory-xxx ELSE inventory END</code></pre><h2 id="秒杀减库存的极致优化"><a href="#秒杀减库存的极致优化" class="headerlink" title="秒杀减库存的极致优化"></a>秒杀减库存的极致优化</h2><pre><code>缓存中减库存

秒杀商品的减库存逻辑非常单一，比如没有复杂的 SKU 库存和总库存这种联动关系的话可以在缓存中做

数据库中减库存

比较复杂的减库存逻辑，或者需要使用事务，你还是必须在数据库中完成减库存。

单个热点商品会影响整个数据库的性能

进行隔离，把热点商品放到单独的热点库中。但是这无疑会带来维护上的麻烦，比如要做热点数据的动态迁移以及单独的数据库等。

由于 MySQL 存储数据的特点，同一数据在数据库里肯定是一行存储（MySQL），因此会有大量线程来竞争 InnoDB 行锁，而并发度越高时等待线程会越多，</code></pre><h2 id="要解决并发锁的问题，有两种办法："><a href="#要解决并发锁的问题，有两种办法：" class="headerlink" title="要解决并发锁的问题，有两种办法："></a>要解决并发锁的问题，有两种办法：</h2><pre><code>应用层做排队。按照商品维度设置队列顺序执行，这样能减少同一台机器对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量，防止热点商品占用太多的数据库连接。

数据库层做排队。应用层只能做到单机的排队，但是应用机器数本身很多，这种排队方式控制并发的能力仍然有限，所以如果能在数据库层做全局排队是最理想的。阿里的数据库团队开发了针对这种 MySQL 的 InnoDB 层上的补丁程序（patch），可以在数据库层上对单行记录做到并发排队。</code></pre><h1 id="准备Plan-B：如何设计兜底方案"><a href="#准备Plan-B：如何设计兜底方案" class="headerlink" title="准备Plan B：如何设计兜底方案?"></a>准备Plan B：如何设计兜底方案?</h1><h2 id="高可用建设应该从哪里着手"><a href="#高可用建设应该从哪里着手" class="headerlink" title="高可用建设应该从哪里着手"></a>高可用建设应该从哪里着手</h2><ul>
<li>架构阶段</li>
</ul>
<pre><code>可扩展性

容错性

避免系统出现单点问题

多机房单元化部署，即使某个城市的某个机房出现整体故障，仍然不会影响整体网站的运转</code></pre><ul>
<li>编码阶段</li>
</ul>
<pre><code>健壮性

涉及远程调用问题时，要设置合理的超时退出机制，防止被其他系统拖垮

也要对调用的返回结果集有预期，防止返回的结果超出程序处理范围，最常见的做法就是对错误异常进行捕获，对无法预料的错误要有默认处理结果</code></pre><ul>
<li>测试阶段</li>
</ul>
<pre><code>保证测试用例的覆盖度，保证最坏情况发生时，我们也有相应的处理流程。</code></pre><ul>
<li>发布阶段</li>
</ul>
<pre><code>要有紧急的回滚机制。</code></pre><ul>
<li>运行阶段</li>
</ul>
<pre><code>运行态最重要的是对系统的监控要准确及时，发现问题能够准确报警并且报警数据要准确详细，以便于排查问题</code></pre><ul>
<li>故障发生</li>
</ul>
<pre><code>最重要的就是及时止损

例如由于程序问题导致商品价格错误，那就要及时下架商品或者关闭购买链接，防止造成重大资产损失。然后就是要能够及时恢复服务，并定位原因解决问题。</code></pre><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>所谓“降级”，就是当系统的容量达到一定程度时，限制或者关闭系统的某些非核心功能，从而把有限的资源保留给更核心的业务</p>
<p>可以通过预案系统和开关系统来实现降级</p>
<p>当秒杀流量达到 5w/s 时，把成交记录的获取从展示 20 条降级到只展示 5 条。“从 20 改到 5”这个操作由一个开关来实现，也就是设置一个能够从开关系统动态获取的系统参数。</p>
<p>降级的核心目标是牺牲次要的功能和用户体验来保证核心业务流程的稳定，是一个不得已而为之的举措。</p>
<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>基于 QPS 和线程数的限流应用最多，最大 QPS 很容易通过压测提前获取，例如我们的系统最高支持 1w QPS 时，可以设置 8000 来进行限流保护。线程数限流在客户端比较有效，例如在远程调用时我们设置连接池的线程数，超出这个并发线程请求，就将线程进行排队或者直接超时丢弃。</p>
<p>限流无疑会影响用户的正常请求，所以必然会导致一部分用户请求失败，因此在系统处理这种异常时一定要设置超时时间，防止因被限流的请求不能 fast fail（快速失败）而拖垮系统。</p>
<p>可以是在客户端限流，也可以是在服务端限流</p>
<p>限流的实现方式既要支持 URL 以及方法级别的限流，也要支持基于 QPS 和线程的限流。</p>
<p>客户端限流</p>
<p>好处可以限制请求的发出，通过减少发出无用请求从而减少对系统的消耗。缺点就是当客户端比较分散时，没法设置合理的限流阈值：如果阈值设的太小，会导致服务端没有达到瓶颈时客户端已经被限制；而如果设的太大，则起不到限制的作用。</p>
<p>服务端限流</p>
<p>好处是可以根据服务端的性能设置合理的阈值，而缺点就是被限制的请求都是无效的请求，处理这些无效的请求本身也会消耗服务器资源。</p>
<h2 id="拒绝服务"><a href="#拒绝服务" class="headerlink" title="拒绝服务"></a>拒绝服务</h2><p> CPU 使用率达到 90% 或者系统 load 值达到 2*CPU 核数时，系统直接拒绝所有请求</p>
<p>在最前端的 Nginx 上设置过载保护，当机器负载达到某个值时直接拒绝 HTTP 请求并返回 503 错误码，在 Java 层同样也可以设计过载保护</p>
<p>像这种系统过载保护虽然在过载时无法提供服务，但是系统仍然可以运作，当负载下降时又很容易恢复，所以每个系统和每个环节都应该设置这个兜底方案，对系统做最坏情况下的保护。</p>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>预防</p>
<p>建立常态的压力体系，例如上线前的单机压测到上线后的全链路压测</p>
<p>管控</p>
<p>做好线上运行时的降级、限流和兜底保护</p>
<p>监控</p>
<p>建立性能基线来记录性能的变化趋势以及线上机器的负载报警体系，发现问题及时预警</p>
<p>恢复体系</p>
<p>遇到故障要及时止损，并提供快速的数据订正工具等</p>
<p>准</p>
<p>稳</p>
<p>快</p>
<p>提高单次请求的效率</p>
<p>减少没必要的请求</p>
<p>秒杀核心<br>(准, 稳, 快)</p>
]]></content>
      <tags>
        <tag>架构</tag>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title>曲突徙薪之恩泽,焦头烂额为上客</title>
    <url>/2019/07/20/%E6%9B%B2%E7%AA%81%E5%BE%99%E8%96%AA%E4%B9%8B%E6%81%A9%E6%B3%BD-%E7%84%A6%E5%A4%B4%E7%83%82%E9%A2%9D%E4%B8%BA%E4%B8%8A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="曲突徙薪"><a href="#曲突徙薪" class="headerlink" title="曲突徙薪"></a>曲突徙薪</h2><p>客有过主人者(1),见其灶直突(2),旁有积薪(3),客谓主人:”更为曲突(4),<br>远徙其薪(5),不者且有火患”.主人默然不应.俄而果失火,邻里共救之,幸而<br>得息.于是杀牛置酒,谢其邻人,灼烂者在于上行(6),余各以功次坐,而不录<br>言曲突者(7),人谓主人曰:”向使听客之言(8),不费牛酒,终亡火患.今论功<br>而请宾,曲突徙薪亡恩泽,焦头烂额为上客耶?”主人乃寤而请之(9).</p>
<p>――节选自班固《汉书·霍光传》</p>
<p>注释<br>⑴过：拜访，探望。</p>
<p>⑵突：烟囱。</p>
<p>⑶薪：柴草。</p>
<p>⑷更：改。</p>
<p>⑸徙(xǐ)：搬走。</p>
<p>⑹灼：烧炙。烂：烧伤。行(háng)：座次。</p>
<p>⑺录：采，取，这里有邀请的意思。</p>
<p>⑻向使：向：原先。使：假使。</p>
<p>⑼寤(wù)：醒悟，明白</p>
<p>有一位客人到主人家拜访，见主人家炉灶的烟囱是直的，旁边又堆有柴薪，这位客人便对主人说：‘您的烟囱应改为弯曲的，并将柴薪搬到远处去，不然的话，将会发生火灾！’主人默然，不予理会。不久，主人家果然失火，邻居们共同抢救，幸而将火扑灭。于是，主人家杀牛摆酒，对邻居表示感谢，在救火中烧伤的被请到上座，其余则各按出力大小依次就坐，却没有请那位建议他改弯烟囱的人。有人对这家主人说：‘当初要是听了那位客人的劝告，就不用杀牛摆酒，终究不会有火灾。如今论功请客酬谢，建议改弯烟囱、移走柴薪的人没有功劳，而在救火时被烧得焦头烂额的人才是上客吗？’主人这才醒悟，将那位客人请来。</p>
<p>“曲突徙薪之恩泽,焦头烂额为上客”：建议改弯烟囱、移走柴薪的人没有功劳，而在救火时被烧得焦头烂额的人成了上客</p>
]]></content>
      <categories>
        <category>成语</category>
      </categories>
      <tags>
        <tag>成语</tag>
      </tags>
  </entry>
  <entry>
    <title>母子分离日</title>
    <url>/2019/08/03/%E6%AF%8D%E5%AD%90%E5%88%86%E7%A6%BB%E6%97%A5/</url>
    <content><![CDATA[<p>早上跟媳妇儿视频,看到了镜头中的儿子.小家伙又长高了,真可爱!<br>7:30过一点儿,媳妇儿要去上班了,儿子眼中有了我从未见过的东西!<br>我第一次发现这家伙眼中流露出的不舍!小家伙开始要找妈妈了!<br>第一次对妈妈的离去表现出了不情愿!<br>看来以后上班得偷偷去了!</p>
<p>昨天升级Ipaid,今早上班发现还在升级中,果断拔掉数据线!升级失败<br>ipaid也开不了机了!郁闷,点背喝凉水都塞牙缝!本想潇洒的翘个二郎腿<br>不知是桌子太矮还是大腿太长亦或自己太傻逼,竟然磕到了桌子上!疼死<br>老子了!IPAID也开不机!自己捣鼓了一下没搞定</p>
<p>去四楼找修手机的看看!这哥们蒙我!”你这一点儿都开不了机”要价70<br>真贵!好吧我太穷…6s换电池好点儿的要130!毅然不修走了!看到他的电脑竟然能<br>识别我的IPAID,感觉我自己也能搞定.</p>
<p>回来查资料首先<br>home键跟电源键一块儿按住约5秒进入维护模式<br>itunes 更新到最新版<br>点击恢复…傻瓜示下一步</p>
<p>中间遇见未知错误2015,崩溃难道我真的要花70块钱亦或大老远跑趟西单?!<br>当然不,以锲而不舍的程序员造bug精神,继续上网找资料!</p>
<p>哎呦! 有可能是数据线的问题!好吧我的这跟山寨线有时候还真是充不上电<br>换根试试!<br>好了…<br>人生处处有惊喜啊…</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>泰拳要领</title>
    <url>/2019/09/02/%E6%B3%B0%E6%8B%B3%E8%A6%81%E9%A2%86/</url>
    <content><![CDATA[<p>上周六送弟弟去学泰拳,偷师了几招.在此记录一下</p>
<ul>
<li><p>收拳要收到脸上(护头)</p>
</li>
<li><p>鞭腿腿是直的</p>
</li>
<li><p>提膝打击支撑腿是直的</p>
</li>
<li><p>鞭腿支撑腿略微忘左上走一点</p>
</li>
<li><p>打沙袋一定带护具 拳套等</p>
</li>
</ul>
<p>教练演示着实震撼,以后让儿子也学!</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>泰拳</tag>
        <tag>运动</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="1数据结构"><a href="#1数据结构" class="headerlink" title="1数据结构"></a>1数据结构</h2><h3 id="1线性表"><a href="#1线性表" class="headerlink" title="1线性表"></a>1线性表</h3><pre><code>1数组
2链表
    1单链表
    2双向链表
    3循环链表
    4双向循环链表
    5静态链表
3栈
    1顺序栈
    2链式栈
4队列
    1普通队列
    2双端队列
    3阻塞队列
    4并发队列
    5并发阻塞队列</code></pre><h3 id="2散列表"><a href="#2散列表" class="headerlink" title="2散列表"></a>2散列表</h3><pre><code>1散列函数
2解决冲突
    1链表法
    2开发寻址法
3动态扩容
4位图</code></pre><h3 id="3树"><a href="#3树" class="headerlink" title="3树"></a>3树</h3><pre><code>1二叉树
    1平衡二叉树
    2二叉查找树
    3平衡二叉查找树
            1AVL树
            2红黑树
    4完全二叉树
    5满二叉树
2多路查找树
    1B树
    2B+树
    3：2-3树
    4：2-3-4树
3堆
    1小顶堆
    2大顶堆
    3优先级队列
    4斐波那契堆
    5二项堆
4其他
    1树状数组
    2线段树</code></pre><h3 id="4图"><a href="#4图" class="headerlink" title="4图"></a>4图</h3><pre><code>1图的存储
    1邻接矩阵
    2邻接表
2拓扑排序
3最短路径
4最小生成树
5二分图
6最大流</code></pre><h2 id="2算法"><a href="#2算法" class="headerlink" title="2算法"></a>2算法</h2><h3 id="1复杂度分析"><a href="#1复杂度分析" class="headerlink" title="1复杂度分析"></a>1复杂度分析</h3><pre><code>1空间复杂度
2时间复杂度
    1最好
    2最坏
    3平均
    4分摊</code></pre><h3 id="2算法思想"><a href="#2算法思想" class="headerlink" title="2算法思想"></a>2算法思想</h3><pre><code>1贪心算法
2分治算法
3动态规划
4回溯算法
5枚举算法</code></pre><h3 id="3排序"><a href="#3排序" class="headerlink" title="3排序"></a>3排序</h3><pre><code>O(n^2)
    1冒泡排序
    2插入排序
    3选择排序
    4希尔排序
O(nlogn)
    1并归排序
    2堆排序
    3快速排序
O(n)
    1计数排序
    2基数排序
    3桶排序</code></pre><h3 id="4搜索"><a href="#4搜索" class="headerlink" title="4搜索"></a>4搜索</h3><pre><code>1深度优先
2广度优先
3A*启发式</code></pre><h3 id="5查找"><a href="#5查找" class="headerlink" title="5查找"></a>5查找</h3><pre><code>1线性查找
2树查找
3散列查找</code></pre><h3 id="6字符串匹配"><a href="#6字符串匹配" class="headerlink" title="6字符串匹配"></a>6字符串匹配</h3><pre><code>1朴素
2KMP
3Robin-Karp
4Boyer-Moore
5AC自动机
6Tire
7后缀数组</code></pre><h3 id="7其他"><a href="#7其他" class="headerlink" title="7其他"></a>7其他</h3><pre><code>1数论
2计算几何
3概率分析
4并查集
5拓扑网络
6矩阵运算
7线性规划</code></pre><h1 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h1><p><img src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.png" alt="">    </p>
]]></content>
      <categories>
        <category>脑图</category>
      </categories>
      <tags>
        <tag>数据结构，算法，脑图</tag>
      </tags>
  </entry>
  <entry>
    <title>深入解读RabbitMQ工作原理及Java中简单使用</title>
    <url>/2018/07/16/%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBRabbitMQ%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8AJava%E4%B8%AD%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="引用-https-mp-weixin-qq-com-s-ryu-zD3U62m32BZdByNxng-http-www-cnblogs-com-vipstone"><a href="#引用-https-mp-weixin-qq-com-s-ryu-zD3U62m32BZdByNxng-http-www-cnblogs-com-vipstone" class="headerlink" title="引用: https://mp.weixin.qq.com/s/ryu-zD3U62m32BZdByNxng http://www.cnblogs.com/vipstone/"></a>引用: <a href="https://mp.weixin.qq.com/s/ryu-zD3U62m32BZdByNxng" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ryu-zD3U62m32BZdByNxng</a> <a href="http://www.cnblogs.com/vipstone/" target="_blank" rel="noopener">http://www.cnblogs.com/vipstone/</a></h2><h2 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h2><p>在介绍RabbitMQ之前首先介绍一下MQ ,MQ是什么?</p>
<p>MQ全称是Message Queue.可以理解为消息队列的意思.简单的说就是消息以<br>管道的方式进行传递</p>
<p>RabbitMQ是一个实现了AMQP(Advanced Message Queuing Protocol)<br>高级消息队列协议的消息队列服务,用Erlang语音写成.</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在我们秒杀抢购商品的时候,系统会提醒我们稍等排队中,而不是像几年前一样<br>页面卡死或报错给用户.</p>
<p>像这种排队结算就是用到了消息队列机制,放入通道里面一个一个结算处理,而不<br>是某个时间段突然涌入大批量的查询新增把数据库给搞宕机.所以RabbitMQ本质<br>上起到的作用就是削峰填谷,为业务保驾护航.</p>
<h2 id="为什么选择RabbitMQ"><a href="#为什么选择RabbitMQ" class="headerlink" title="为什么选择RabbitMQ"></a>为什么选择RabbitMQ</h2><p>现在市面上有很多MQ可以选择,比如ActiveMQ ZeroMQ Appche Qpid,那问<br>题来了为啥要选择RabbitMQ?</p>
<p>1: 除了Qpid,RabbitMQ是唯一一个实现了AMQP标准的消息服务器;<br>2: 可靠性,RabbitMQ的持久化支持,保证了消息的稳定性;<br>3: 高并发,RabbitMQ使用了Erlang开发语言,Erlang是为电话交换机开发的语言,<br>天生自带高并发光环,和高可用特性;<br>4: 集群部署简单,正是因为Erlang使得RabbitMQ集群部署变得超级简单;<br>5: 社区活跃度高,根据网上资料来看,RabbitMQ也是首选;</p>
<h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><h3 id="生产者-消费者和代理"><a href="#生产者-消费者和代理" class="headerlink" title="生产者 消费者和代理"></a>生产者 消费者和代理</h3><p>在了解消息通讯之前首先要了解3个概念:生产者 消费者和代理.</p>
<p>生产者:消息的创建者,负责创建和推送数据到消息服务器;</p>
<p>消费者:消息的接收方,用于处理数据和确认消息;</p>
<p>代理者:就是RabbitMQ本身,用于扮演”快递”的角色,本身不生产消息,<br>只是扮演”快递”的角色.</p>
<h3 id="消息发送原理"><a href="#消息发送原理" class="headerlink" title="消息发送原理"></a>消息发送原理</h3><p>首先你必须连接到Rabbit才能发布和消费消息,那怎么连接和发送消息呢?</p>
<p>你的应用程序和Rabbit Server之间会创建一个TCP连接,一旦TCP打开,<br>并通过认证,认证就是你试图连接Rabbit之前发送的Rabbit服务器连接<br>信息和用户名和密码,有点像程序连接数据库,使用Java有两种连接认证<br>的方式,后面代码会详细介绍,一旦认证通过你的应用程序和Rabbit就创建<br>了一条AMQP信道(Channel).</p>
<p>信道是创建在”真实”TCP上的虚拟连接,AMQP命令都是通过信道发送出去的,<br>每个信道都会有唯一的ID,不论是发布消息,订阅队列或者介绍消息都是通过<br>信道完成的.</p>
<h3 id="为什么不通过TCP直接发送命令"><a href="#为什么不通过TCP直接发送命令" class="headerlink" title="为什么不通过TCP直接发送命令?"></a>为什么不通过TCP直接发送命令?</h3><p>对于操作系统来说创建和销毁TCP会话是非常昂贵的开销,假设高峰期每秒<br>有成千上万条连接,每个连接都要创建一条TCP会话,这就造成了TCP连接的<br>巨大浪费,而且操作系统每秒能创建的TCP也是有限的,因此很快就会遇到系统<br>瓶颈.</p>
<p>如果我们每个请求都使用一条TCP连接,既满足了性能的需要,又能确保每个<br>连接的私密性,这就是引入信道概念的原因.</p>
<h2 id="你必须知道的RabbitMQ"><a href="#你必须知道的RabbitMQ" class="headerlink" title="你必须知道的RabbitMQ"></a>你必须知道的RabbitMQ</h2><p>想要真正的了解Rabbit有些名词是你必须知道的.</p>
<p>包括:ConnectionFactory(连接管理器) Channel(信道)<br>Exchange(交换器) Queue(队列) RoutingKey(路由键)<br>BindingKey(绑定键)</p>
<p>ConnectionFactory(连接管理器): 应用程序与Rabbit之间<br>建立连接的管理器,程序代码中使用;</p>
<p>Channel(信道) :消息推送使用的通道;</p>
<p>Exchange(交换器) :用于接受 分配消息;</p>
<p>Queue(队列): 用于存储生产者的消息;</p>
<p>RoutingKey(路由键): 用于把生成者的数据分配到交换器上;</p>
<p>bingdingKey(绑定键): 用于把交换器的消息绑带到队列上;</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/WwPkUCFX4x6A5PeoEjBet8tpwnyOsaoWhdsqr2n1dLrSfJlaofbVayxUTemicQlbFmiaEHUMY83AIOsIXTaNicPwQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="示例图片"></p>
<h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p>Rabbit队列和交换器有一个不可告人的秘密,就是默认情况下重启<br>服务器会导致消息丢失,那么怎么保证Rabbit在重启的时候不丢失呢?<br>答案就是消息持久化.</p>
<p>当你把消息发送到Rabbit服务器的时候,你需要选择你是否要进行持久化,但这并<br>不能保证Rabbit能重崩溃中恢复,想要Rabbit消息能恢复必须要满足3个条件:</p>
<p>投递消息的时候durable设置为true,消息持久化;</p>
<p>消息已经到达持久化交换器上;</p>
<p>消息已经到达持久化的队列;</p>
<h3 id="持久化工作原理"><a href="#持久化工作原理" class="headerlink" title="持久化工作原理"></a>持久化工作原理</h3><p>Rabbit会将你的持久化消息写入磁盘上的持久化日志文件,等消息被消费后,Rabbit<br>会把这条消息标识为等待垃圾回收.</p>
<h3 id="持久化的缺点"><a href="#持久化的缺点" class="headerlink" title="持久化的缺点"></a>持久化的缺点</h3><p>消息持久化的优点显而易见,但缺点也很明显,那就是性能,因为要写入硬盘要比<br>写入内存性能低很多,从而降低了服务器的吞吐量,尽管使用SSD硬盘可以使事情<br>得到缓解,但他仍然吸干了Rabbit的性能,当消息成千上万条要写入磁盘的时候<br>,性能是很低的.</p>
<p>所以使用者要根据自己的的情况,选择适合自己的方式.</p>
<h2 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h2><p>每个Rabbit都能创建很多vhost,我们称之为虚拟主机,每个虚拟主机其实都是<br>mini版的RabbitMQ,拥有自己的队列,交换器和绑定,拥有自己的权限机制.</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>如果你是在Windows10上去安装那就更简单了，先放下载地址：</p>
<p>Erlang/Rabbit Server百度网盘链接：<a href="https://pan.baidu.com/s/1TnKDV-ZuXLiIgyK8c8f9dg" target="_blank" rel="noopener">https://pan.baidu.com/s/1TnKDV-ZuXLiIgyK8c8f9dg</a> 密码：wct9</p>
<p>当然也可去Erlang和Rabbit官网去下，就是速度比较慢。我的百度云Rabbit最新版本：3.7.6，Erlang版本：20.2，注意：不要下载最新的Erlang，在Windows10上打开扩展插件有问题，打不开。</p>
<p>1.安装Erlang；</p>
<p>2.安装Rabbit Server；</p>
<p>3.进入安装目录sbin下，使用命令“rabbitmq-plugins enable                                     rabbitmq_management”启动网页管理插件；</p>
<p>4.重启Rabbit服务；</p>
<p>使用：<a href="http://localhost:15672进行测试，默认的登陆账号为：guest，密码为：guest">http://localhost:15672进行测试，默认的登陆账号为：guest，密码为：guest</a></p>
<h2 id="重复安装Rabbit-Server的坑"><a href="#重复安装Rabbit-Server的坑" class="headerlink" title="重复安装Rabbit Server的坑"></a>重复安装Rabbit Server的坑</h2><p>如果不是第一次在Windows上安装Rabbit Server一定要把Rabbit和Erlang卸载干净<br>之后，找到注册表：HKEY_LOCAL_MACHINESOFTWAREEricssonErlangErlSrv 删除<br>其下的所有项。</p>
<p>不然会出现Rabbit安装之后启动不了的情况，理论上卸载的顺序也是先Rabbit在Erlang。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>java版实现,使用maven项目.</p>
<p>项目创建成功之后,添加Rabbit Client jar包,只需要在pom.xml里面配置,如下信息:</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;
    &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;
    &lt;version&gt;4.7.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre><p>java实现代码分为两个类,第一个是创建Rabbit连接,第二是应用类使用最简单的方式<br>发布和消费消息.</p>
<h3 id="Rabbit的连接-两种方式"><a href="#Rabbit的连接-两种方式" class="headerlink" title="Rabbit的连接,两种方式:"></a>Rabbit的连接,两种方式:</h3><p>方式一:</p>
<pre><code>public static Connection GetRabbitConnection() {
    ConnectionFactory factory = new ConnectionFactory();
    factory.setUsername(Config.UserName);
    factory.setPassword(Config.Password);
    factory.setVirtualHost(Config.VHost);
    factory.setHost(Config.Host);
    factory.setPort(Config.Port);
    Connection conn = null;
    try {
        conn = factory.newConnection();
    } catch (Exception e) {
        e.printStackTrace(); 
    } 

    return conn;
}</code></pre><p>方式二:</p>
<pre><code>public static Connection GetRabbitConnection() {
    ConnectionFactory factory = new ConnectionFactory();

    // 连接格式：amqp://userName:password@hostName:portNumber/virtualHost
    String uri = String.format(
            &quot;amqp://%s:%s@%s:%d%s&quot;, 
            Config.UserName, 
            Config.Password,
            Config.Host, 
            Config.Port,
            Config.VHost);
    Connection conn = null;
    try {
        factory.setUri(uri);
        factory.setVirtualHost(Config.VHost);
        conn = factory.newConnection();
    } catch (Exception e) {
        e.printStackTrace();
    }                
    return conn;
}</code></pre><h3 id="第二部分-应用类-使用最简单的方式发布和消费消息"><a href="#第二部分-应用类-使用最简单的方式发布和消费消息" class="headerlink" title="第二部分: 应用类,使用最简单的方式发布和消费消息"></a>第二部分: 应用类,使用最简单的方式发布和消费消息</h3><pre><code>public static void main(String[] args) {
    Publisher(); // 推送消息

    Consumer(); // 消费消息
}

/**
* 推送消息
*/
public static void Publisher() {
    // 创建一个连接
    Connection conn = ConnectionFactoryUtil.GetRabbitConnection();
    if (conn != null) {
        try{
            // 创建通道
            Channel channel = conn.createChannel();
            // 声明队列【参数说明：参数一：队列名称，参数二：是否持久化；参数三：是否独占模式；参数四：消费者断开连接时是否删除队列；参数五：消息其他参数】
            channel.queueDeclare(Config.QueueName, false, false, false, null);
            String content = 
                String.format(&quot;当前时间: %s&quot;,new Date().getTime());
            // 发送内容【参数说明：参数一：交换机名称；参数二：队列名称，参数三：消息的其他属性；参数四：消息主体】
            channel.basicPublish(&quot;&quot;, Config.QueueName, null, content.getBytes(&quot;UTF-8&quot;));
            System.out.println(&quot;已发送消息：&quot; + content);
            // 关闭连接
            channel.close();
            conn.close();
        } catch(Exception e) {
            e.printStackTrace();
        }
    } 
}

/**
* 消费消息
*/
public static void Consumer() {
    // 创建一个连接
    Connection conn = ConnectionFactoryUtil.GetRabbitConnection();
    if(conn != null) {
        try {
            // 创建通道
            Channel channel = conn.createChannel();
            // 声明队列[参数说明:1:队列名称,2:是否持久化,3:是否独占模式,4:消费者断开连接时是否删除队列,5:消息其他参数]
            channel.queueDelare(Config.QueueName,false,false,false,null);

            //创建订阅器,并接受消息
            channel.basicConsume(Config.QueueName,false,&quot;&quot;,new DefaultConsumer(channel) {
                @Overrride
                public void handleDelivery(
                    String consumerTag,
                    Envelope envelope,
                    AMQP.BasicPropeties properties,
                    byte[] body) throws IOException {
                    String routingKey = envelope.getRoutingkey(); // 队列名称
                    String contentType = properties.getContentType(); // 内容类型
                    String content = new String(body,&quot;utf-8&quot;); // 消息正文
                    System.out.println(&quot;消息正文:&quot; + content);
                    channel.basicAck(envelope.getDeliveryTag(),false); // 手动确认消息(参数1:该消息的index;2:是否批量应答,true批量确认小于index的消息)
                }

            });

        } catch(Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre><p>代码里面已经写了很详细的注释，在这里也不过多的介绍了。</p>
<p>执行效果，如图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/WwPkUCFX4x6A5PeoEjBet8tpwnyOsaoWtlqQAptMtgjn6YQXj1cJxNGyc0puMV6EVf1dwtNhCzjDqfj85XCsibA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1" alt="示例图片"></p>
]]></content>
      <categories>
        <category>rabbitMQ</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>rabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>杀威棍</title>
    <url>/2019/10/06/%E6%9D%80%E5%A8%81%E6%A3%8D/</url>
    <content><![CDATA[<p>《说唐》里秦叔宝进牢房时,衙役喊得一句话来解释:<br>“进的牢来先打你一百杀威棍,看你老不老实!”</p>
]]></content>
      <tags>
        <tag>传统文化</tag>
      </tags>
  </entry>
  <entry>
    <title>猪宝历险记</title>
    <url>/2019/05/28/%E7%8C%AA%E5%AE%9D%E5%8E%86%E9%99%A9%E8%AE%B0/</url>
    <content><![CDATA[<p>接上篇&lt;&lt;喜迎猪宝&gt;&gt;</p>
<p>爸爸刚安顿好妈妈就有一个年长一些的护士将爸爸叫到了一旁,<br>说”孩子刚来时好好的,大约过了半小时出现了呼吸急促的现象,<br>正常新生儿一般每分钟40次左右,你家孩子都70次了”.</p>
<p>爸爸当时就蒙了!担心你有危险!询问护士该如何做,此时护士<br>叫来了新生儿科主任,主任将你抱到了新生儿科,与爸爸的焦急<br>相比,主任倒没那么担心,爸爸心中暗责主任的冷血,反过来<br>想也许你这种情况也很常见!</p>
<p>进了新生儿科你就被抱到了NICU,爸爸此时还没有真正看过你<br>的脸,抱你的途中怕你着凉脸一直是遮着的<br>接待爸爸的是李芳医生,人很和气!她给爸爸介绍<br>说出现这种情况的原因可能是因为剖腹产,新生儿由于没有<br>经过产道挤压,肺没有充分扩张,还以为自己在妈妈肚子里,<br>还有一个原因是巨大儿有可能出现这种情况,<br>而孩子正好两条你都符合!</p>
<p>说了一些治疗手段,主要是给你吸氧,增加肺部扩张,若疗效不<br>好就要打一种刺激肺部扩张的药……</p>
<p>途中医生给爸爸看了你的一个小视频,看的爸爸很是揪心,视频<br>中你呼吸急促,鼻翼抖动明显,脸色发紫,胸腔随着每次呼吸<br>而剧烈抖动.孩子你在跟命运抗争,为生存而奋斗!爸爸在心<br>里给你鼓劲,一定要好起来啊,小家伙.</p>
<p>爸爸向医生要你的视频,医生答应的很好,可最后也没有给爸爸!</p>
<p>医生跟爸爸交代这种情况有三天到五天的危险期!一般一周也<br>就好的差不多了!爸爸好像有了底气,但又担心危险期的你!<br>可能是看出了爸爸的担心,医生又跟爸爸说前48个小时最危险,<br>过了就问题不大.其实最危险的是前24小时……</p>
<p>整个治理过程家长都不能见到孩子,每周一三五可以向医生询问<br>病情,每天09:00-11:00  16:00-17:00 可以去送奶.</p>
<p>安顿好了你,爸爸就回去照顾妈妈.<br>最可怜的还是你妈,10月怀胎一朝分娩.中途各种心酸暂且不表.<br>看着临床的孩子陆续抱过来,而你又迟迟不到妈妈身边,爸爸<br>知道得告诉妈妈了,不过爸爸耍了个小心机,没有把你的真实<br>情况说明,只是说你有点儿呼吸急促,医生让观察观察.</p>
<p>当天晚上爸爸一夜不眠!想到视频中你的样子,想到你正在跟<br>命运的抗争,想到你在里面吃啥,哭了有人哄吗……<br>爸爸静静的望着隔壁6楼的窗户,想着里面的你当时的境况<br>,五味杂陈……</p>
<p>第二天早上爸爸去儿科送湿纸巾,刚送完,就收到了你姥爷的<br>电话,询问爸爸为什么车门是开着的? 爸爸这是才意识到刚才<br>拿东西时,忘记了关车门!原来人在遇到大事时真的会六神无主<br>.爸爸要向你学习,与命运抗争,当下给自己鼓劲儿,我不能倒,<br>我还有孩子在NICU,媳妇儿还需要照顾,我必须振作,加油,一切<br>都会好起来的.</p>
<p>你也是真争气,医生告诉爸爸昨天下午,你就呼吸正常了,不过<br>还是要观察几天.至此爸爸跟妈妈总算松了口气.</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>猪宝起名记</title>
    <url>/2019/05/31/%E7%8C%AA%E5%AE%9D%E5%8F%96%E5%90%8D%E8%AE%B0/</url>
    <content><![CDATA[<p>接上篇&lt;&lt;猪宝历险记&gt;&gt;</p>
<p>好吧孩子,这几天除了担心你,还在忙活着一件事给你取名.爸爸<br>妈妈想了很多,在此一一记录.希望你长大后更能理解自己名字<br>的由来.</p>
<p>从怀孕开始爸妈就开始想你的名字</p>
<ul>
<li>卓恩</li>
</ul>
<p>这是第一个爸妈意向很大的名字,由来英文JUNE(六月)谐音而来<br>你是六月来到的爸妈身边,即有此意.对了爸爸一开始想的是朱恩<br>后来还是你二叔觉得卓恩好.爸爸也觉得这名字不错,可由于你一向<br>喜欢韩国欧巴的妈妈觉得这名字有点韩流,就给否了.</p>
<ul>
<li>给予</li>
</ul>
<p>这是爸爸意向差不多最大的一个名字,有三重意思:1是希望你可以<br>做个能帮助别人的人,2是谐音爸妈的家乡冀豫,3是希望你健健康康<br>可思来想去还是怕以后小朋友叫不好你的名字老叫你gei yu!<br>又给否了</p>
<ul>
<li>春风 小名小野</li>
</ul>
<p>出自野火烧不尽,春风吹又生!这名字是爸爸一厢情愿<br>你妈特别反对,觉得老掉牙!可爸爸觉得挺好,朴素,辨识度高<br>寓意也好,希望你以后坚韧,茁壮成长!一场春风一场暖,长大<br>当个大暖男!当然咱们家你妈说了算.</p>
<p>由于火爆当下的抖音,爸妈又刷出了几个名字</p>
<ul>
<li>予桐</li>
<li>锦汐</li>
<li>若凌<br>都由于意向不大没有采纳.</li>
</ul>
<p>中途还有个搞笑的小名叫抖爆,解释为抖音爆款!</p>
<p>言归正传,如何起个好名字?</p>
<p>爸爸跟妈妈的理解为</p>
<ul>
<li><p>寓意好,(女诗经 男楚辞 文论语 武周易 )最好有点出处.</p>
</li>
<li><p>响亮 郎朗上口.最好都为二声,或第一个字四声,第二个字二声.</p>
</li>
<li><p>好写 不要生僻字,最好小学毕业的人都认知.</p>
</li>
<li><p>独特 最好叫的人不多,名字毕竟是个IP.好多人都叫则辨识度太低.</p>
</li>
<li><p>作为传统的中国人,还是希望跟五行八卦相配合的.</p>
</li>
</ul>
<ul>
<li><p>出处:李白 侠客行 </p>
</li>
<li><p>响亮:都为二声,跟咱这姓氏配合也算郎朗上口.</p>
</li>
<li><p>好写:小学毕业肯定认识,笔画也不多.</p>
</li>
<li><p>独特:好吧奶奶给你上社保的时候就有工作人员夸,说这名字好,之前没见过,爸爸不甘寂寞,上省公安厅查,全省独一份!</p>
</li>
<li><p>跟你的八字五行还是比较配合的,网上测了一下99分.</p>
</li>
</ul>
<p>小名是你10岁的小叔叔起的.家里人一致认为这个名字好听,<br>爸爸也觉得这名字干净,纯洁,有力量.</p>
<p>中途也有人建议花钱找大师起名.爸爸不信这一套!爸爸认为孩子的<br>名字最好是父母来起.因为没有人比父母对你的名字更上心.经过<br>父母深思熟虑起的名字是最有力量的.这个是啥大师都比不了的.</p>
<p>参考的资料有:</p>
<ul>
<li><p><a href="https://bookdown.org/baydap/papasdiary/kids-name.html" target="_blank" rel="noopener">给孩子起名字</a></p>
</li>
<li><p><a href="https://www.zhihu.com/question/20436604?sort=created" target="_blank" rel="noopener">如何给孩子起名？</a></p>
</li>
<li><p><a href="http://www.vividict.com/WordInfo.aspx?id=2432" target="_blank" rel="noopener">象形字典</a></p>
</li>
<li><p><a href="http://www.vividict.com/WordInfo.aspx?id=908" target="_blank" rel="noopener">象形字典</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>玩物丧志</title>
    <url>/2019/08/26/%E7%8E%A9%E7%89%A9%E4%B8%A7%E5%BF%97/</url>
    <content><![CDATA[<p>曾闻古训戒禽荒，一鹤谁知便丧邦。荥泽当时遍磷火，可能骑鹤返仙乡？</p>
<p>谨以此致自己被玩儿的岁月!</p>
]]></content>
  </entry>
  <entry>
    <title>深入浅出Java多线程</title>
    <url>/2020/04/03/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJava%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="进程与线程的基本概念"><a href="#进程与线程的基本概念" class="headerlink" title="进程与线程的基本概念"></a>进程与线程的基本概念</h2><h3 id="进程产生的背景"><a href="#进程产生的背景" class="headerlink" title="进程产生的背景"></a>进程产生的背景</h3><p>指令—》指令集（批处理） </p>
<p>缺点：串行，效率低</p>
<p><strong>进程：</strong> 应用程序在内存中分配的空间，正在运行的程序。</p>
<p> 进程优点： 操作系统并发成为可能。</p>
<p><strong>线程:</strong> 一个线程执行一个子任务，一个进程包含多个线程。</p>
<p>优点：让进程的内部并发成为了可能。 </p>
<p> <strong>多进程的方式也可以实现并发，为什么我们要使用多线程？</strong></p>
<ul>
<li>进程通信复杂，线程间可共享资源，通信较线程容易;</li>
<li>进程重量级，线程轻量级，系统开销小。</li>
</ul>
<p><strong>进程线程的区别？</strong></p>
<ul>
<li>本质区别：能否单独占有内存空间及其他系统资源（如：I/O);</li>
<li>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行系统调度的基本单位，即CPU时间的分配单位。</li>
</ul>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p><strong>上下文：</strong> 某一时间点CPU寄存器和程序计数器的内容。</p>
<p><strong>上下文切换:</strong> CPU从一个进程/线程切换到另一个进程/线程。</p>
<p><strong>缺点：</strong> 上先文切换是计算密集型的，消耗大量的CPU时间，故线程也不是越多越好。</p>
<h2 id="java多线程入门类和接口"><a href="#java多线程入门类和接口" class="headerlink" title="java多线程入门类和接口"></a>java多线程入门类和接口</h2><h3 id="Thread类和Runnable接口"><a href="#Thread类和Runnable接口" class="headerlink" title="Thread类和Runnable接口"></a>Thread类和Runnable接口</h3><p><strong>Java如何实现多线程？</strong></p>
<ul>
<li>继承Thread类，并重写run()方法。</li>
<li>实现Runnable接口的run()方法。</li>
</ul>
<p><strong>继承Thread类需注意什么？</strong></p>
<p>thread.start()方法后，该线程才算启动，调用start()后，虚拟机会先为我们创建一个线程，然后等到这个线程第一次得到时间片时，再调用run()方法。start()不可多次调用，否则抛异常。</p>
<p><strong>Java8函数式编程</strong></p>
<pre><code>new Thread(()-&gt;{System.out.println(&quot;java8&quot;);}).start();</code></pre><p><strong>Thread类的构造方法</strong></p>
<pre><code>Thread(Runnable target)
Thread(Runnable target, String name)</code></pre><p><strong>Thread类的几个常用方法</strong></p>
<pre><code>currentThread(); // 静态方法，返回正在执行线程的引用。
start(); // 启动线程。
yield(); // 让出当前处理器的占用。
sleep(); // 静态方法，休眠。
join(); // 当前线程等待另一个线程执行完毕后再继续执行。内部调用的Object.wait()。</code></pre><p><strong>Thread类与Runnable比较？</strong></p>
<ul>
<li>Java单继承多实现，Runnable比Thread灵活；</li>
<li>Runnable更符合面向对象，将线程单独进行对象的封装;</li>
<li>Runnable降低了线程对象和线程任务的耦合性；</li>
<li>若不用Thread类诸多方法，Runnable更轻量级，适合实现多线程。</li>
</ul>
<h3 id="Callable、Future与FutureTask"><a href="#Callable、Future与FutureTask" class="headerlink" title="Callable、Future与FutureTask"></a>Callable、Future与FutureTask</h3><p><strong>为啥用Callable Future FutureTask?</strong><br>因为Runnable和Thread创建的线程没有返回值。当我们希望开启一个线程执行完一个任务后有返回值则用以上方式（异步模型）。</p>
<p><strong>Callable特点？</strong></p>
<ul>
<li>有返回值，支持泛型</li>
</ul>
<p><strong>Callable咋用？</strong></p>
<pre><code>伪代码 
ExecutorService.submit(Callable) return一个Future，
通过Future的get方法获取结果。</code></pre><p><strong>Future接口注意项</strong></p>
<ul>
<li>cancel() 试图取消，并不一定取消成功。</li>
</ul>
<p><strong>FutureTask类总结</strong></p>
<ul>
<li>Future类的实现类。</li>
<li>FutureTask实现了RunnableFuture接口，RunnableFuture同时继承了Runnable接口和Future接口。</li>
</ul>
<p><strong>为什么要用FutureTask?</strong><br>高并发下，Callable和FutureTask会创建多次。FutureTask能确保任务只执行一次。</p>
<p><strong>FutureTask有几个状态?分别是？及其转换关系？</strong><br>六个状态分别是：</p>
<ul>
<li>NEW = 0 // 新建</li>
<li>COMPLETING = 1 // 完成 </li>
<li>NORMAL = 2 // 正常</li>
<li>EXCEPTIONAL = 3 // 异常</li>
<li>CANCELLED = 4  // 取消</li>
<li>INTERRUPTING = 5 // 打断中</li>
<li>INTERRUPTED = 6 // 打断了的</li>
</ul>
<pre><code>转变路径
0 -&gt; 1 -&gt; 2
0 -&gt; 1 -&gt; 3
0 -&gt; 4
0 -&gt; 5 -&gt; 6</code></pre><h2 id="线程组和线程优先级"><a href="#线程组和线程优先级" class="headerlink" title="线程组和线程优先级"></a>线程组和线程优先级</h2><h3 id="线程组（ThreadGroup）"><a href="#线程组（ThreadGroup）" class="headerlink" title="线程组（ThreadGroup）"></a>线程组（ThreadGroup）</h3><p><strong>线程组作用？</strong></p>
<hr>
<hr>
<hr>
<hr>
<h2 id="java线程的状态和主要转化方法"><a href="#java线程的状态和主要转化方法" class="headerlink" title="java线程的状态和主要转化方法"></a>java线程的状态和主要转化方法</h2><h2 id="Java线程间的通信"><a href="#Java线程间的通信" class="headerlink" title="Java线程间的通信"></a>Java线程间的通信</h2><h1 id="Java内存模型基础知识"><a href="#Java内存模型基础知识" class="headerlink" title="Java内存模型基础知识"></a>Java内存模型基础知识</h1><h2 id="Java内存模型基础知识-1"><a href="#Java内存模型基础知识-1" class="headerlink" title="Java内存模型基础知识"></a>Java内存模型基础知识</h2><h2 id="重排序与happens-before"><a href="#重排序与happens-before" class="headerlink" title="重排序与happens-before"></a>重排序与happens-before</h2><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h2 id="synchronized与锁"><a href="#synchronized与锁" class="headerlink" title="synchronized与锁"></a>synchronized与锁</h2><h2 id="CAS与原子操作"><a href="#CAS与原子操作" class="headerlink" title="CAS与原子操作"></a>CAS与原子操作</h2><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h1 id="JDK工具"><a href="#JDK工具" class="headerlink" title="JDK工具"></a>JDK工具</h1><h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><h2 id="锁接口和类"><a href="#锁接口和类" class="headerlink" title="锁接口和类"></a>锁接口和类</h2><h2 id="并发集合容器简介"><a href="#并发集合容器简介" class="headerlink" title="并发集合容器简介"></a>并发集合容器简介</h2><h2 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h2><h2 id="通信工具类"><a href="#通信工具类" class="headerlink" title="通信工具类"></a>通信工具类</h2><h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h2><h2 id="Java8-Stream并行计算原理"><a href="#Java8-Stream并行计算原理" class="headerlink" title="Java8 Stream并行计算原理"></a>Java8 Stream并行计算原理</h2><h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>私有构造函数的作用</title>
    <url>/2020/04/28/%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>1 防止对象被随意创建</p>
<p>2 用于实现单例</p>
<p>3 工具类防止实例化（不创建对象，方法设为静态，可通过对象.来调用）</p>
<p>4 应用于工厂模式的实现</p>
<pre><code>父类方法调用子类实现
1。你可以返回任何的Shape类型，包括Shape的子类。比如你可以把makeShape写成这样：

public class Shape {
    private Shape() {
       /* set something here */
    }
    public static Shape makeShape(/* arglist */) {
           System.out.println(&quot;here is the shape you ordered&quot;);
           if (retangle)
                 return (new Retangle(/* arglist*/));
           if (Circle)
                return (new Circle(/* arglist */));
        /* you can return as many shapes as you like */
        }
}    
这里假设Retangle 和 Circle 都是shape的子类，并且和Shape类在同一个包內，
Shape类可以访问子类的构造函数。这样shape就提供了一个图形工厂。 用户通过一
个接口就可以生成不同的图形。事实上，这种用法被称为“工厂模式”。</code></pre><p>5 方便抛出异常</p>
<pre><code>在构造器中的异常一般会被jvm抛弃    </code></pre>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>精细阅读的杀手锏——SQ3R阅读法</title>
    <url>/2020/04/10/%E7%B2%BE%E7%BB%86%E9%98%85%E8%AF%BB%E7%9A%84%E6%9D%80%E6%89%8B%E9%94%8F%E2%80%94%E2%80%94SQ3R%E9%98%85%E8%AF%BB%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一-什么是SQ3R阅读法"><a href="#一-什么是SQ3R阅读法" class="headerlink" title="一. 什么是SQ3R阅读法"></a>一. 什么是SQ3R阅读法</h1><p>  美国俄亥俄州州立大学心理学教授罗宾逊（F. P. Robinson）<br>  1946年在他的著作Effective Study有所提及<br>  综览（Survey）、发问（Question）、阅读（Read）、背诵（Recite）、复习（Review）</p>
<h1 id="二-SQ3R阅读法的具体实施步骤"><a href="#二-SQ3R阅读法的具体实施步骤" class="headerlink" title="二. SQ3R阅读法的具体实施步骤"></a>二. SQ3R阅读法的具体实施步骤</h1><h2 id="1-Survey阶段"><a href="#1-Survey阶段" class="headerlink" title="1. Survey阶段"></a>1. Survey阶段</h2><ul>
<li>封面、扉页、前言</li>
<li>目录</li>
<li>各级标题</li>
<li>开头和结尾</li>
</ul>
<h2 id="2-Question阶段"><a href="#2-Question阶段" class="headerlink" title="2. Question阶段"></a>2. Question阶段</h2><ul>
<li>这本书/这篇文章主要说的什么</li>
<li>掌握了多少？</li>
<li>提问贯穿于整个阅读过程</li>
<li>只要有问题，你都可以用笔或借助电子设备将问题记录下来。</li>
<li>布朗和基利的《学会提问》</li>
</ul>
<h2 id="3-Read阶段"><a href="#3-Read阶段" class="headerlink" title="3.Read阶段"></a>3.Read阶段</h2><pre><code>加粗字段、重点图标
阅读难度较高的篇章时要放慢速度。
遇到不明白的地方，要停下来，再重读一遍。
一次只阅读一小段并背诵那一段。
阅读辅助说明的图象。          ——Study Guides and Strategies 博客网站</code></pre><h2 id="4-Recite阶段"><a href="#4-Recite阶段" class="headerlink" title="4. Recite阶段"></a>4. Recite阶段</h2><pre><code>非背诵，而是复述，尽可能多和详细
听、说、读、写
联想记忆法
关键词记忆法
谐音等记忆法</code></pre><h2 id="5-Review阶段"><a href="#5-Review阶段" class="headerlink" title="5.  Review阶段"></a>5.  Review阶段</h2><ol>
<li>Recite后半天Review一次；</li>
<li>一天后再Review一次；</li>
<li>三天后再Review一次；</li>
<li>一个星期后再Review一次；</li>
<li>一个月后再简单地Review一次。</li>
</ol>
<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="%E7%B2%BE%E7%BB%86%E9%98%85%E8%AF%BB%E7%9A%84%E6%9D%80%E6%89%8B%E9%94%8F%E2%80%94%E2%80%94SQ3R.png" alt=""></p>
]]></content>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>论语学习</title>
    <url>/2019/09/28/%E8%AE%BA%E8%AF%AD%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="学习地址"><a href="#学习地址" class="headerlink" title="学习地址"></a>学习地址</h1><p><a href="https://mooc1.chaoxing.com/ztnodedetailcontroller/visitnodedetail?courseId=201598687&knowledgeId=124210600&_from_=" target="_blank" rel="noopener">超星尔雅</a></p>
<h1 id="第一讲孔子思想的特色"><a href="#第一讲孔子思想的特色" class="headerlink" title="第一讲孔子思想的特色"></a>第一讲孔子思想的特色</h1><p>温和的理性主义</p>
<p>深刻的人道情怀</p>
<p>乐观的人生理想</p>
<h1 id="第二讲学儿篇"><a href="#第二讲学儿篇" class="headerlink" title="第二讲学儿篇"></a>第二讲学儿篇</h1><p>学而时习之(从学习中发现快乐)</p>
<p>时:适当的时候</p>
<p>学了做人处事的道理适当的时候加以练习运用</p>
<p>人同此心,心同此理</p>
<p>学习的内容: 五经与六艺</p>
<p>学习的方法: 学思并用</p>
<p>学习的目的: 培养德行</p>
<p>不迁怒 不贰过</p>
<p>朋友由来<br>同门曰朋<br>同志曰友</p>
<p>儒家:不反对情绪,但需要做情绪管理</p>
]]></content>
      <categories>
        <category>传统文化</category>
      </categories>
      <tags>
        <tag>传统文化</tag>
        <tag>论语</tag>
      </tags>
  </entry>
  <entry>
    <title>自旋锁、排队自旋锁、MCS锁、CLH锁</title>
    <url>/2020/05/28/%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E6%8E%92%E9%98%9F%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81MCS%E9%94%81%E3%80%81CLH%E9%94%81/</url>
    <content><![CDATA[<h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p>当锁被其他线程占用时，自己不断的循环检测锁是否释放，不改变线程状态<br>（即不挂起线程或睡眠状态），需占用CPU资源，适用于临界区很小的情况。<br>若线程竞争激烈，则会消耗大量CPU资源，不适用于自旋锁。</p>
<h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>线程的状态改变是很消耗CPU资源的，所以有了不改变线程状态的自旋锁。<br>适用于锁竞争不是很激烈的情况</p>
<h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><p>talk is cheap show me the code</p>
<pre><code>import java.util.concurrent.atomic.AtomicReference;

public class SpinLock {
   private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;Thread&gt;();

   public void lock() {
       Thread currentThread = Thread.currentThread();

              // 如果锁未被占用，则设置当前线程为锁的拥有者
       while (!owner.compareAndSet(null, currentThread)) {
       }
   }

   public void unlock() {
       Thread currentThread = Thread.currentThread();

              // 只有锁的拥有者才能释放锁
       owner.compareAndSet(currentThread, null);
   }</code></pre><p>SimpleSpinLock里有一个owner属性持有锁当前拥有者的线程的引用，如果该引用为null，则表示锁未被占用，不为null则被占用。</p>
<p>这里用AtomicReference是为了使用它的原子性的compareAndSet方法（CAS操作），解决了多线程并发操作导致数据不一致的问题，确保其他线程可以看到锁的真实状态。</p>
<p>缺点<br>CAS操作需要硬件的配合；<br>保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；<br>没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。       </p>
<h1 id="排队自旋锁（Ticket-Lock）"><a href="#排队自旋锁（Ticket-Lock）" class="headerlink" title="排队自旋锁（Ticket Lock）"></a>排队自旋锁（Ticket Lock）</h1><h1 id="what-1"><a href="#what-1" class="headerlink" title="what"></a>what</h1><h1 id="why-1"><a href="#why-1" class="headerlink" title="why"></a>why</h1><h1 id="how-1"><a href="#how-1" class="headerlink" title="how"></a>how</h1><h1 id="MCS锁"><a href="#MCS锁" class="headerlink" title="MCS锁"></a>MCS锁</h1><h1 id="what-2"><a href="#what-2" class="headerlink" title="what"></a>what</h1><h1 id="why-2"><a href="#why-2" class="headerlink" title="why"></a>why</h1><h1 id="how-2"><a href="#how-2" class="headerlink" title="how"></a>how</h1><h1 id="CLH锁"><a href="#CLH锁" class="headerlink" title="CLH锁"></a>CLH锁</h1><h1 id="what-3"><a href="#what-3" class="headerlink" title="what"></a>what</h1><h1 id="why-3"><a href="#why-3" class="headerlink" title="why"></a>why</h1><h1 id="how-3"><a href="#how-3" class="headerlink" title="how"></a>how</h1>]]></content>
      <tags>
        <tag>java</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之Builder模式  </title>
    <url>/2019/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BBuilder%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>读《活着》有感</title>
    <url>/2019/09/06/%E8%AF%BB-%E6%B4%BB%E7%9D%80-%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<p><img src="%E4%B8%8B%E8%BD%BD.jpeg" alt=""></p>
<ul>
<li><p>余华文笔真好,很有代入感</p>
</li>
<li><p>富贵就是那个时代的缩影</p>
</li>
<li><p>选择比努力重要</p>
</li>
<li><p>人首先要尊重自己!</p>
</li>
<li><p>凡事多替自己想想,富贵儿子死的真冤!</p>
</li>
<li><p>珍惜今天吧    </p>
</li>
</ul>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>读与时间做朋友有感</title>
    <url>/2019/12/22/%E8%AF%BB%E4%B8%8E%E6%97%B6%E9%97%B4%E5%81%9A%E6%9C%8B%E5%8F%8B%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<p>近日读完了李笑来写的《与时间做朋友》收货一下观点</p>
<ul>
<li><p>1 20分钟学习命令行下的批处理方法</p>
</li>
<li><p>2 Google通配符学习</p>
</li>
<li><p>3 概率统计学（买彩票这种行为在学过概率统计的人看来是对自己智商的侮辱）</p>
</li>
<li><p>4 千万不要拒绝学习</p>
</li>
<li><p>5 《今春的两种感想》对体验、试错、和观察进行补充的就是阅读。</p>
</li>
<li><p>6 伯纳姆与杰.费伦著《本能》</p>
</li>
<li><p>7 电影《新基督山伯爵》</p>
</li>
<li><p>8 达尔文《物种起源》 1859年11月24日</p>
</li>
<li><p>9 愚人网</p>
</li>
<li><p>10猴子吃香蕉被打（经验主义害猴子被打）</p>
</li>
<li><p>11 亚里士多德《论问题》”强光喷嚏反射”</p>
</li>
<li><p>12 美国前第一夫人罗莎琳.卡特就观察到了这样一个现象：”优秀的领导，能够把人们带到他们想去的地方，而卓越的领导，能够把人们带到他们应该去但是没想过要去的地方。<br>A leader takes people where they want to go .<br>A grate leader takes people where they don’t necessarily want to go ,but ought to be.</p>
</li>
<li><p>13 人在学生时期应该认真阅读至少3本关于科学史和科学方法的书籍</p>
</li>
<li><p>14 在人们探索未知、寻求真理的时候，困难几乎都来自于如何正确的理解”与现有经验相悖的知识”</p>
</li>
<li><p>15 自学能力的基础是阅读理解能力</p>
</li>
<li><p>16 写作能力在自学能力中占据重要位置。（这里提到的”写作能力”不是写小说的能力，不是写诗歌的能力，不是写剧本的能力，也不是写散文的能力，只是写作能力中最基本的一种——写出简洁、有效、准确、朴素、具体的说明性文章的能力。</p>
</li>
<li><p>17 对抗选择性输入：把目前无法理解的、支持的、反对的、无所谓的论点和观点记录下来。对无法理解的，写下自己当时的疑惑何在，对支持的，记录下几个理由或者实例；对反对的，同样记录几个理由或者实例；甚至对那些无所谓的，也记录其原因。一个有着这样良好记录习惯的人会获得他人无法拥有的处理信息和知识的能力——反刍chu</p>
</li>
<li><p>18 读教科书，要先把所有概念都记下来，暂时不懂的就死记硬背。把概念牢记于心，就可以通过以后的学习和实践反复审视它，并形成透彻理解。</p>
</li>
<li><p>19 学习任何一门学科，都最好先去读一下该学科的发展历史，这是最好的起点。</p>
</li>
<li><p>20 《围城》钱钟书著</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>读后感，李笑来</tag>
      </tags>
  </entry>
  <entry>
    <title>读别让自己墙了自己有感</title>
    <url>/2019/12/02/%E8%AF%BB%E5%88%AB%E8%AE%A9%E8%87%AA%E5%B7%B1%E5%A2%99%E4%BA%86%E8%87%AA%E5%B7%B1%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<p> <a href="https://coolshell.cn/articles/20276.html/comment-page-2#comments" target="_blank" rel="noopener">文章链接</a></p>
<h1 id="收获的主题"><a href="#收获的主题" class="headerlink" title="收获的主题"></a>收获的主题</h1><ul>
<li><p>只专注于一种技术其他都是垃圾（不要将自己的技术栈封闭起来）</p>
</li>
<li><p>关注负面的东西不要胜过正面的东西</p>
</li>
<li><p>离开Java的世界就基本上做不了架构了</p>
</li>
<li><p>把自己最宝贵的时间用在了很烂的项目上，就算能用一些新技术也只能是自娱自乐，在实验室中玩玩罢了</p>
</li>
<li><p>把自己的技术栈封闭起来，直接放弃了这个时代最具有工业化的技术Java，对于一个好的程序员来说同时掌握几种语言和技术是完全没有问题的，不要自己封闭了自己的视野</p>
</li>
<li><p>视野、环境和舞台对一个人的限制是非常大的。井蛙不知大海，被空间维度所限制；夏虫不知冬天，被时间维度所限制；圈养的动物没有斗志，是被自己意志所限制。</p>
</li>
<li><p>偏见和不开放，对一个人限制是真正有毁灭性的。主动让自己成为一个瞎子和聋子，主动把自己能力阉割掉是多么让人痛心的一件事。</p>
</li>
<li><p>不限制自己的人会穷举各种方法来解决问题，限制自己的人，会找各式各样的问题或借口。</p>
</li>
<li><p>不限制自己的人，会努力改变自己的问题和缺陷，限制自己的人会放任自己。</p>
</li>
<li><p>先把软件设计好再写代码。</p>
<h1 id="技术方向"><a href="#技术方向" class="headerlink" title="技术方向"></a>技术方向</h1></li>
<li><p>Docker、go、k8s</p>
</li>
<li><p>翻找Youtube的各种大会，GitHub的各种issue和pull request</p>
</li>
<li><p>成为一个技术牛人的条件：基础知识过硬，细节扎得深，面很广，学习能力强，有英文能力，逻辑思维能力不错，非常的自律，执行力也很强，抓得住重点,最重要的一点：在大公司历练过。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></li>
<li><p>做高价值的事。所谓高价值，就是：别人愿付高价的，高技术门槛的，有创造力的，颠覆性的……</p>
</li>
<li><p>扩大自己的眼界，开放自己的内心。你的英文语言能力对你能不能融入世界是起决定性的作用。你的视野决定了你知不知道要去哪，你的开放决定了你想不想去。</p>
</li>
<li><p>站在更高的维度.面的维度会超过点的维度，空间的维度会超过面的维度，在更高维度上思考和学习，你会收货更多。整天在焦虑那些低维度的事（比如自己的薪水、工作的地点、稳不稳定、有没有户口……)，只会让你变得越来越平庸，只要你站在更高的维度（比如：眼界有没有扩大、可能性是不是更多、竞争力是不是更强、能不能解决更大更难的问题、能创造多大的价值……)，时间会让你明白那些低维度的东西全都不是事儿。技术学习上也一样，站在学习编程语法特性的维度和站在学习编程范式、设计模式的维度是两种完全不一样的学习方式。</p>
</li>
<li><p>精于计算得失。很多人其实不是很懂计算。绝大多数人都是在计算自己会失去多少，而不会算得到多少。而一般的人也总是在算短期内会失去什么，优秀的则总是会算我投入后未来会有什么样的回报，前者在算计今天，目光短浅，而后者则是舍在今天，得在明天，计算的是未来。精于计算得失的，就懂得什么是投资，不懂的只会投机。对于赚钱，你可以投机，但是对于自己最好还是投资。</p>
</li>
<li><p>勇于跳出传统的束缚。做”鸡”的比”二奶”好多了</p>
</li>
<li><p>别自己墙了自己，人最可悲的就是自己限制自己，想都不敢想！</p>
<p>庄子曰过：</p>
<p> 井蛙不可以语于海者，拘于虚也；//空间局限</p>
<p> 夏虫不可以语于冰者，笃于时也；//时间局限</p>
<p> 曲士不可以语于道者，束于教也。//认识局限</p>
</li>
</ul>
]]></content>
      <categories>
        <category>读后感</category>
      </categories>
      <tags>
        <tag>读后感，左耳</tag>
      </tags>
  </entry>
  <entry>
    <title>过年请假</title>
    <url>/2019/02/13/%E8%BF%87%E5%B9%B4%E8%AF%B7%E5%81%87/</url>
    <content><![CDATA[<pre><code>年关将至，抢票不易!然小禾佑我，得票一张。
忧喜交集,喜与孕妻朝欢暮,又忧公司业务急!
遂背Mac,随时call我!
恭祝:新春吉祥如意，事事顺达，阖家幸福。</code></pre>]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>运动改造大脑</title>
    <url>/2020/04/07/%E8%BF%90%E5%8A%A8%E6%94%B9%E9%80%A0%E5%A4%A7%E8%84%91/</url>
    <content><![CDATA[<p><img src="yundong.png" alt=""></p>
]]></content>
      <categories>
        <category>读后感</category>
      </categories>
      <tags>
        <tag>运动，读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>钝感力</title>
    <url>/2020/05/14/%E9%92%9D%E6%84%9F%E5%8A%9B/</url>
    <content><![CDATA[<p>14：46分读完了钝感力这本书。有以下收货：</p>
<ul>
<li><p>1、我发现自己读pdf文件1小时大概能读1M（本书有3M，我读完大概花了3个小时）</p>
</li>
<li><p>2、所谓钝感力感觉还是要让自己看问题大度些：别把什么都看得太执着。</p>
</li>
</ul>
<p>作者是日本人渡边淳一。间接从一个侧面反映了日本的民族性格。想来一个美国人可能写不出这样的书。作者阐释了<br>啥是钝感力，从心理以及生理上。虽然其举的一些例字不敢苟同，但整体读下来还是挺值得一读的。钝感力可能不能让你立马富有或者啥的，但<br>肯定能让你比之前生活的更幸福。钝感力不是让你一味的忍，而是不要太在意，一些可有可无的小矛盾，能忽略就忽略。<br>钝感力可以让你有更好的适应能力。人最牛逼的能力就是在哪儿都能适应的能力。<br>钝感力不是为了别人，而是真的能让自己活的更好，身体上，心理上都是。</p>
<p>想来我是一个相对敏感的人，钝感力是一种能力，自己还是要努力锻炼这种能力！</p>
<h1 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h1><p>宽以待人，豁达处事（金刚经讲就是：应无所住而生其心）</p>
<h1 id="为什么要有钝感力"><a href="#为什么要有钝感力" class="headerlink" title="为什么要有钝感力"></a>为什么要有钝感力</h1><p> 1 人是社会性动物，而人际关系是第一生产力，有利于人际关系，也就是有利于生产力的发展。</p>
<p> 2 有利于血液循环</p>
<p> 3 有利于适应能力提高</p>
<p> 4 有利于身体健康</p>
<p> 5 有利于睡眠</p>
<h1 id="怎样做"><a href="#怎样做" class="headerlink" title="怎样做"></a>怎样做</h1><p>别太把别人说的当回事儿，遇事儿别往心里搁，该吃吃，该喝喝。吃好喝好比啥都重要。没事儿看看鬼畜也挺好。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>node.js教程</title>
    <url>/2019/08/26/node-js%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li><p>简单的说 Node.js 就是运行在服务端的 JavaScript。</p>
</li>
<li><p>Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。</p>
</li>
<li><p>Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</p>
</li>
</ul>
<h2 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h2><pre><code>node -v
v12.9.0</code></pre><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>   vim helloWorld.js</p>
<p>   console.log(“Hello World”);</p>
<p>   node helloWorld.js</p>
<h2 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h2><pre><code>$ node
&gt; console.log(&apos;Hello World!&apos;);
Hello World!</code></pre><h1 id="Node-js-安装配置"><a href="#Node-js-安装配置" class="headerlink" title="Node.js 安装配置"></a>Node.js 安装配置</h1><pre><code>Mac安装
brew install node</code></pre><h1 id="Node-js-创建第一个应用"><a href="#Node-js-创建第一个应用" class="headerlink" title="Node.js 创建第一个应用"></a>Node.js 创建第一个应用</h1><h2 id="步骤一、引入-required-模块"><a href="#步骤一、引入-required-模块" class="headerlink" title="步骤一、引入 required 模块"></a>步骤一、引入 required 模块</h2><p>我们使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下:</p>
<pre><code>var http = require(&quot;http&quot;);</code></pre><h2 id="步骤二、创建服务器"><a href="#步骤二、创建服务器" class="headerlink" title="步骤二、创建服务器"></a>步骤二、创建服务器</h2><p>接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。</p>
<p>实例如下，在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：</p>
<pre><code>var http = require(&apos;http&apos;);
http.createServer(function (request, response) {

    // 发送 HTTP 头部 
    // HTTP 状态值: 200 : OK
    // 内容类型: text/plain
    response.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;});

    // 发送响应数据 &quot;Hello World&quot;
    response.end(&apos;Hello World\n&apos;);
}).listen(8888);

// 终端打印如下信息
console.log(&apos;Server running at http://127.0.0.1:8888/&apos;);</code></pre><p>以上代码我们完成了一个可以工作的 HTTP 服务器。</p>
<p>使用 node 命令执行以上的代码：</p>
<pre><code>node server.js
Server running at http://127.0.0.1:8888/</code></pre><p>接下来，打开浏览器访问 <a href="http://127.0.0.1:8888/，你会看到一个写着" target="_blank" rel="noopener">http://127.0.0.1:8888/，你会看到一个写着</a> “Hello World”的网页。</p>
<h2 id="分析Node-js-的-HTTP-服务器："><a href="#分析Node-js-的-HTTP-服务器：" class="headerlink" title="分析Node.js 的 HTTP 服务器："></a>分析Node.js 的 HTTP 服务器：</h2><ul>
<li><p>第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。</p>
</li>
<li><p>接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。</p>
</li>
</ul>
<h1 id="NPM-使用介绍"><a href="#NPM-使用介绍" class="headerlink" title="NPM 使用介绍"></a>NPM 使用介绍</h1><p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p>
<ul>
<li><p>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</p>
</li>
<li><p>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</p>
</li>
<li><p>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</p>
</li>
</ul>
<h2 id="查看版本-1"><a href="#查看版本-1" class="headerlink" title="查看版本"></a>查看版本</h2><pre><code>$ npm -v
6.10.3</code></pre><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><pre><code>$ sudo npm install npm -g</code></pre><p>如果是 Window 系统使用以下命令即可：</p>
<pre><code>npm install npm -g</code></pre><p>使用淘宝镜像的命令：</p>
<pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><h2 id="使用-npm-命令安装模块"><a href="#使用-npm-命令安装模块" class="headerlink" title="使用 npm 命令安装模块"></a>使用 npm 命令安装模块</h2><p>npm 安装 Node.js 模块语法格式如下：</p>
<pre><code>$ npm install &lt;Module Name&gt;</code></pre><p>以下实例，我们使用 npm 命令安装常用的 Node.js web框架模块 express:</p>
<pre><code>$ npm install express</code></pre><p>安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 require(‘express’) 的方式就好，无需指定第三方包路径。</p>
<pre><code>var express = require(&apos;express&apos;);</code></pre><h2 id="全局安装与本地安装"><a href="#全局安装与本地安装" class="headerlink" title="全局安装与本地安装"></a>全局安装与本地安装</h2><p>npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，比如</p>
<pre><code>npm install express          # 本地安装
npm install express -g   # 全局安装</code></pre><p>如果出现以下错误：</p>
<pre><code>npm err! Error: connect ECONNREFUSED 127.0.0.1:8087 </code></pre><p>解决办法为：</p>
<pre><code>$ npm config set proxy null</code></pre><h2 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h2><ul>
<li><p>1.将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</p>
</li>
<li><p>2.可以通过 require() 来引入本地安装的包。</p>
</li>
</ul>
<h2 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h2><ul>
<li>1.将安装包放在 /usr/local 下或者你 node 的安装目录。</li>
<li>2.可以直接在命令行里使用。</li>
</ul>
<p>如果你希望具备两者功能，则需要在两个地方安装它或使用 npm link。<br>接下来我们使用全局方式安装 express</p>
<pre><code>$ npm install express -g</code></pre><h2 id="查看安装信息"><a href="#查看安装信息" class="headerlink" title="查看安装信息"></a>查看安装信息</h2><p>你可以使用以下命令来查看所有全局安装的模块：</p>
<pre><code>$ npm list -g

├─┬ cnpm@4.3.2
│ ├── auto-correct@1.0.0
│ ├── bagpipe@0.3.5
│ ├── colors@1.1.2
│ ├─┬ commander@2.9.0
│ │ └── graceful-readlink@1.0.1
│ ├─┬ cross-spawn@0.2.9
│ │ └── lru-cache@2.7.3
……</code></pre><p>如果要查看某个模块的版本号，可以使用命令如下：</p>
<pre><code>$ npm list grunt

projectName@projectVersion /path/to/project/folder
└── grunt@0.4.1</code></pre><h2 id="使用-package-json"><a href="#使用-package-json" class="headerlink" title="使用 package.json"></a>使用 package.json</h2><p>package.json 位于模块的目录下，用于定义包的属性。接下来让我们来看下 express 包的 package.json 文件，位于 node_modules/express/package.json 内容：</p>
<h2 id="Package-json-属性说明"><a href="#Package-json-属性说明" class="headerlink" title="Package.json 属性说明"></a>Package.json 属性说明</h2><pre><code>name - 包名。

version - 包的版本号。

description - 包的描述。

homepage - 包的官网 url 。

author - 包的作者姓名。

contributors - 包的其他贡献者姓名。

dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。

repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。

main - main 字段指定了程序的主入口文件，require(&apos;moduleName&apos;) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。

keywords - 关键字</code></pre><h2 id="卸载模块"><a href="#卸载模块" class="headerlink" title="卸载模块"></a>卸载模块</h2><p>我们可以使用以下命令来卸载 Node.js 模块。</p>
<pre><code>$ npm uninstall express</code></pre><p>卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看：</p>
<pre><code>$ npm ls</code></pre><h2 id="更新模块"><a href="#更新模块" class="headerlink" title="更新模块"></a>更新模块</h2><pre><code>$ npm update express</code></pre><h2 id="搜索模块"><a href="#搜索模块" class="headerlink" title="搜索模块"></a>搜索模块</h2><pre><code>$ npm search express</code></pre><h2 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h2><p>创建模块，package.json 文件是必不可少的。我们可以使用 NPM 生成 package.json 文件，生成的文件包含了基本的结果。</p>
<pre><code>$ npm init
This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.

See `npm help json` for definitive documentation on these fields
and exactly what they do.

Use `npm install &lt;pkg&gt; --save` afterwards to install a package and
save it as a dependency in the package.json file.

Press ^C at any time to quit.
name: (node_modules) runoob                   # 模块名
version: (1.0.0) 
description: Node.js 测试模块(www.runoob.com)  # 描述
entry point: (index.js) 
test command: make test
git repository: https://github.com/runoob/runoob.git  # Github 地址
keywords: 
author: 
license: (ISC) 
About to write to ……/node_modules/package.json:      # 生成地址

{
  &quot;name&quot;: &quot;runoob&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;Node.js 测试模块(www.runoob.com)&quot;,
  ……
}


Is this ok? (yes) yes</code></pre><p>以上的信息，你需要根据你自己的情况输入。在最后输入 “yes” 后会生成 package.json 文件。</p>
<p>接下来我们可以使用以下命令在 npm 资源库中注册用户（使用邮箱注册）：</p>
<pre><code>$ npm adduser
Username: mcmohd
Password:
Email: (this IS public) mcmohd@gmail.com</code></pre><p>接下来我们就用以下命令来发布模块：</p>
<pre><code>$ npm publish</code></pre><p>如果你以上的步骤都操作正确，你就可以跟其他模块一样使用 npm 来安装。</p>
<h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><p>使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。</p>
<p>语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。</p>
<ul>
<li>如果只是修复bug，需要更新Z位。</li>
<li>如果是新增了功能，但是向下兼容，需要更新Y位。</li>
<li>如果有大变动，向下不兼容，需要更新X位。</li>
</ul>
<p>版本号有了这个保证后，在申明第三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如”argv”: “0.0.x”表示依赖于0.0.x系列的最新版argv。                    </p>
<p>NPM支持的所有版本号范围指定方式可以查看<a href="https://docs.npmjs.com/" target="_blank" rel="noopener">官方文档</a>。</p>
<h2 id="NPM-常用命令"><a href="#NPM-常用命令" class="headerlink" title="NPM 常用命令"></a>NPM 常用命令</h2><p>使用npm help可查看所有命令。</p>
<ul>
<li><p>NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。</p>
</li>
<li><p>使用npm help <command>可查看某条命令的详细帮助，例如npm help install。</p>
</li>
<li><p>在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。</p>
</li>
<li><p>使用npm update <package>可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。</p>
</li>
<li><p>使用npm update <package> -g可以把全局安装的对应命令行程序更新至最新版。</p>
</li>
<li><p>使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</p>
</li>
<li><p>使用npm unpublish <package>@<version>可以撤销发布自己发布过的某个版本代码。</p>
</li>
</ul>
<h2 id="使用淘宝-NPM-镜像"><a href="#使用淘宝-NPM-镜像" class="headerlink" title="使用淘宝 NPM 镜像"></a>使用淘宝 NPM 镜像</h2><p>大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。</p>
<p>淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。</p>
<p>你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:</p>
<pre><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>这样就可以使用 cnpm 命令来安装模块了：</p>
<pre><code>$ cnpm install [name]</code></pre><h1 id="Node-js-REPL-交互式解释器"><a href="#Node-js-REPL-交互式解释器" class="headerlink" title="Node.js REPL(交互式解释器)"></a>Node.js REPL(交互式解释器)</h1><p>Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。</p>
<p>Node 自带了交互式解释器，可以执行以下任务：</p>
<ul>
<li><p>读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。</p>
</li>
<li><p>执行 - 执行输入的数据结构</p>
</li>
<li><p>打印 - 输出结果</p>
</li>
<li><p>循环 - 循环操作以上步骤直到用户<strong><em>两次</em></strong>按下  <strong>ctrl-c</strong>  按钮退出。</p>
</li>
</ul>
<p>Node 的交互式解释器可以很好的调试 Javascript 代码。</p>
<h2 id="启动-Node-的终端："><a href="#启动-Node-的终端：" class="headerlink" title="启动 Node 的终端："></a>启动 Node 的终端：</h2><pre><code>$ node
Welcome to Node.js v12.9.0.
Type &quot;.help&quot; for more information.
&gt;</code></pre><h2 id="简单的表达式运算"><a href="#简单的表达式运算" class="headerlink" title="简单的表达式运算"></a>简单的表达式运算</h2><p>这时我们就可以在 &gt; 后输入简单的表达式，并按下回车键来计算结果。</p>
<pre><code>$ node
&gt; 1 +4
5
&gt; 5 / 2
2.5
&gt; 3 * 6
18
&gt; 4 - 1
3
&gt; 1 + ( 2 * 3 ) - 4
3
&gt;</code></pre><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>你可以将数据存储在变量中，并在你需要的时候使用它。</p>
<p>变量声明需要使用 var 关键字，如果没有使用 var 关键字变量会直接打印出来。</p>
<p>使用 var 关键字的变量可以使用 console.log() 来输出变量。</p>
<pre><code>$ node
&gt; x = 10
10
&gt; var y = 10
undefined
&gt; x + y
20
&gt; console.log(&quot;Hello World&quot;)
Hello World
undefined
&gt; console.log(&quot;www.runoob.com&quot;)
www.runoob.com
undefined</code></pre><h2 id="多行表达式"><a href="#多行表达式" class="headerlink" title="多行表达式"></a>多行表达式</h2><p>Node REPL 支持输入多行表达式，这就有点类似 JavaScript。接下来让我们来执行一个 do-while 循环：</p>
<pre><code>$ node
&gt; var x = 0
undefined
&gt; do {
... x++;
... console.log(&quot;x: &quot; + x);
... } while ( x &lt; 5 );
x: 1
x: 2
x: 3
x: 4
x: 5
undefined
&gt;</code></pre><p>… 三个点的符号是系统自动生成的，你回车换行后即可。Node 会自动检测是否为连续的表达式。</p>
<h2 id="下划线-变量"><a href="#下划线-变量" class="headerlink" title="下划线(_)变量"></a>下划线(_)变量</h2><p>你可以使用下划线(_)获取上一个表达式的运算结果：</p>
<pre><code>$ node
&gt; var x = 10
undefined
&gt; var y = 20
undefined
&gt; x + y
30
&gt; var sum = _
undefined
&gt; console.log(sum)
30
undefined
&gt;</code></pre><h2 id="REPL-命令"><a href="#REPL-命令" class="headerlink" title="REPL 命令"></a>REPL 命令</h2><ul>
<li><p>ctrl + c - 退出当前终端。</p>
</li>
<li><p>ctrl + c 按下两次 - 退出 Node REPL。</p>
</li>
<li><p>ctrl + d - 退出 Node REPL.</p>
</li>
<li><p>向上/向下 键 - 查看输入的历史命令</p>
</li>
<li><p>tab 键 - 列出当前命令</p>
</li>
<li><p>.help - 列出使用命令</p>
</li>
<li><p>.break - 退出多行表达式</p>
</li>
<li><p>.clear - 退出多行表达式</p>
</li>
<li><p>.save filename - 保存当前的 Node REPL 会话到指定文件</p>
</li>
<li><p>.load filename - 载入当前 Node REPL 会话的文件内容。</p>
</li>
</ul>
<h2 id="停止-REPL"><a href="#停止-REPL" class="headerlink" title="停止 REPL"></a>停止 REPL</h2><p>前面我们已经提到按下两次 ctrl + c 键就能退出 REPL:</p>
<pre><code>$ node
&gt;
(^C again to quit)
&gt;      </code></pre><h1 id="Node-js-回调函数"><a href="#Node-js-回调函数" class="headerlink" title="Node.js 回调函数"></a>Node.js 回调函数</h1><p>Node.js 异步编程的直接体现就是回调。</p>
<p>异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。</p>
<p>回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。</p>
<p>例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。</p>
<p>回调函数一般作为函数的最后一个参数出现：</p>
<pre><code>function foo1(name, age, callback) { }
function foo2(value, callback1, callback2) { }</code></pre><h2 id="阻塞代码实例"><a href="#阻塞代码实例" class="headerlink" title="阻塞代码实例"></a>阻塞代码实例</h2><p>创建一个文件 input.txt ，内容如下：</p>
<pre><code>菜鸟教程官网地址：www.runoob.com</code></pre><p>创建 main.js 文件, 代码如下：</p>
<pre><code>var fs = require(&quot;fs&quot;);
var data = fs.readFileSync(&apos;input.txt&apos;);
console.log(data.toString());
console.log(&quot;程序执行结束!&quot;);</code></pre><p>以上代码执行结果如下：</p>
<pre><code>$ node main.js
菜鸟教程官网地址：www.runoob.com

程序执行结束!</code></pre><h2 id="非阻塞代码实例"><a href="#非阻塞代码实例" class="headerlink" title="非阻塞代码实例"></a>非阻塞代码实例</h2><p>创建一个文件 input.txt ，内容如下：</p>
<pre><code>菜鸟教程官网地址：www.runoob.com</code></pre><p>创建 main.js 文件, 代码如下：</p>
<pre><code>fs.readFile(&apos;input.txt&apos;, function (err, data) {
    if (err) return console.error(err);
    console.log(data.toString());
});

console.log(&quot;程序执行结束!&quot;);</code></pre><p>以上代码执行结果如下：</p>
<pre><code>$ node main.js
程序执行结束!
菜鸟教程官网地址：www.runoob.com</code></pre><p>以上两个实例我们了解了阻塞与非阻塞调用的不同。第一个实例在文件读取完后才执行完程序。 第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。</p>
<p>因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。</p>
<h1 id="Node-js-事件循环"><a href="#Node-js-事件循环" class="headerlink" title="Node.js 事件循环"></a>Node.js 事件循环</h1><ul>
<li><p>Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。    </p>
</li>
<li><p>Node.js 几乎每一个 API 都是支持回调函数的。</p>
</li>
<li><p>Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。</p>
</li>
<li><p>Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.</p>
</li>
</ul>
<h2 id="事件驱动程序"><a href="#事件驱动程序" class="headerlink" title="事件驱动程序"></a>事件驱动程序</h2><p>Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。</p>
<p>当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。</p>
<p>这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）</p>
<p>在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/09/event_loop.jpg" alt=""></p>
<p>整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。</p>
<p>Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：</p>
<pre><code>// 引入 events 模块
var events = require(&apos;events&apos;);
// 创建 eventEmitter 对象
var eventEmitter = new events.EventEmitter();</code></pre><p>以下程序绑定事件处理程序：</p>
<pre><code>// 绑定事件及事件的处理程序
eventEmitter.on(&apos;eventName&apos;, eventHandler);</code></pre><p>我们可以通过程序触发事件：</p>
<pre><code>// 触发事件
eventEmitter.emit(&apos;eventName&apos;);</code></pre><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>创建 main.js 文件，代码如下所示：</p>
<pre><code>// 引入 events 模块
var events = require(&apos;events&apos;);
// 创建 eventEmitter 对象
var eventEmitter = new events.EventEmitter();

// 创建事件处理程序
var connectHandler = function connected() {
   console.log(&apos;连接成功。&apos;);

   // 触发 data_received 事件 
   eventEmitter.emit(&apos;data_received&apos;);
} 

// 绑定 connection 事件处理程序
eventEmitter.on(&apos;connection&apos;, connectHandler);

// 使用匿名函数绑定 data_received 事件
eventEmitter.on(&apos;data_received&apos;, function(){
   console.log(&apos;数据接收成功。&apos;);
});    

// 触发 connection 事件 
eventEmitter.emit(&apos;connection&apos;);

console.log(&quot;程序执行完毕。&quot;);</code></pre><p>接下来让我们执行以上代码：</p>
<pre><code>$ node main.js
连接成功。
数据接收成功。
程序执行完毕。</code></pre><h2 id="Node-应用程序是如何工作的？"><a href="#Node-应用程序是如何工作的？" class="headerlink" title="Node 应用程序是如何工作的？"></a>Node 应用程序是如何工作的？</h2><p>在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。</p>
<p>接下来让我们来重新看下前面的实例，创建一个 input.txt ,文件内容如下：</p>
<pre><code>菜鸟教程官网地址：www.runoob.com</code></pre><p>创建 main.js 文件，代码如下：</p>
<pre><code>var fs = require(&quot;fs&quot;);

fs.readFile(&apos;input.txt&apos;, function (err, data) {
   if (err){
      console.log(err.stack);
      return;
   }
   console.log(data.toString());
});
console.log(&quot;程序执行完毕&quot;);</code></pre><p>以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。</p>
<p>如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。</p>
<p>执行以上代码，执行结果如下：</p>
<pre><code>程序执行完毕
菜鸟教程官网地址：www.runoob.com      </code></pre><p>接下来我们删除 input.txt 文件，执行结果如下所示：</p>
<pre><code>程序执行完毕
Error: ENOENT, open &apos;input.txt&apos;</code></pre><p>因为文件 input.txt 不存在，所以输出了错误信息。</p>
<h1 id="Node-js-EventEmitter"><a href="#Node-js-EventEmitter" class="headerlink" title="Node.js EventEmitter"></a>Node.js EventEmitter</h1><p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。</p>
<p>Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p>
<h2 id="EventEmitter-类"><a href="#EventEmitter-类" class="headerlink" title="EventEmitter 类"></a>EventEmitter 类</h2><p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。</p>
<p>你可以通过require(“events”);来访问该模块。</p>
<pre><code>// 引入 events 模块
var events = require(&apos;events&apos;);
// 创建 eventEmitter 对象
var eventEmitter = new events.EventEmitter();</code></pre><p>EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。</p>
<h3 id="下面我们用一个简单的例子说明-EventEmitter-的用法："><a href="#下面我们用一个简单的例子说明-EventEmitter-的用法：" class="headerlink" title="下面我们用一个简单的例子说明 EventEmitter 的用法："></a>下面我们用一个简单的例子说明 EventEmitter 的用法：</h3><pre><code>//event.js 文件
var EventEmitter = require(&apos;events&apos;).EventEmitter; 
var event = new EventEmitter(); 
event.on(&apos;some_event&apos;, function() { 
    console.log(&apos;some_event 事件触发&apos;); 
}); 
setTimeout(function() { 
    event.emit(&apos;some_event&apos;); 
}, 1000); </code></pre><p>执行结果如下：</p>
<p>运行这段代码，1 秒后控制台输出了 ‘some_event 事件触发’。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。</p>
<pre><code>$ node event.js 
some_event 事件触发          </code></pre><p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。</p>
<p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p>
<p>让我们以下面的例子解释这个过程：</p>
<pre><code>//event.js 文件
var events = require(&apos;events&apos;); 
var emitter = new events.EventEmitter(); 
emitter.on(&apos;someEvent&apos;, function(arg1, arg2) { 
    console.log(&apos;listener1&apos;, arg1, arg2); 
}); 
emitter.on(&apos;someEvent&apos;, function(arg1, arg2) { 
    console.log(&apos;listener2&apos;, arg1, arg2); 
}); 
emitter.emit(&apos;someEvent&apos;, &apos;arg1 参数&apos;, &apos;arg2 参数&apos;); </code></pre><p>执行以上代码，运行的结果如下：</p>
<pre><code>$ node event.js 
listener1 arg1 参数 arg2 参数
listener2 arg1 参数 arg2 参数    </code></pre><p>以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。</p>
<p>运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。</p>
<p>EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="1-addListener-event-listener"><a href="#1-addListener-event-listener" class="headerlink" title="1. addListener(event, listener)"></a>1. addListener(event, listener)</h3><p>为指定事件添加一个监听器到监听器数组的尾部。</p>
<h3 id="2-on-event-listener"><a href="#2-on-event-listener" class="headerlink" title="2. on(event, listener)"></a>2. on(event, listener)</h3><p>为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。</p>
<pre><code>server.on(&apos;connection&apos;, function (stream) {
  console.log(&apos;someone connected!&apos;);
});</code></pre><h3 id="3-once-event-listener"><a href="#3-once-event-listener" class="headerlink" title="3. once(event, listener)"></a>3. once(event, listener)</h3><p>为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。</p>
<pre><code>server.once(&apos;connection&apos;, function (stream) {
  console.log(&apos;Ah, we have our first user!&apos;);
});</code></pre><h3 id="4-removeListener-event-listener"><a href="#4-removeListener-event-listener" class="headerlink" title="4. removeListener(event, listener)"></a>4. removeListener(event, listener)</h3><p>移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。</p>
<p>它接受两个参数，第一个是事件名称，第二个是回调函数名称。</p>
<pre><code>var callback = function(stream) {
  console.log(&apos;someone connected!&apos;);
};
server.on(&apos;connection&apos;, callback);
// ...
server.removeListener(&apos;connection&apos;, callback);</code></pre><h3 id="5-removeAllListeners-event"><a href="#5-removeAllListeners-event" class="headerlink" title="5. removeAllListeners([event])"></a>5. removeAllListeners([event])</h3><p>移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。</p>
<h3 id="6-setMaxListeners-n"><a href="#6-setMaxListeners-n" class="headerlink" title="6. setMaxListeners(n)"></a>6. setMaxListeners(n)</h3><p>默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。</p>
<h3 id="7-listeners-event"><a href="#7-listeners-event" class="headerlink" title="7. listeners(event)"></a>7. listeners(event)</h3><p>返回指定事件的监听器数组。</p>
<h3 id="8-emit-event-arg1-arg2-…"><a href="#8-emit-event-arg1-arg2-…" class="headerlink" title="8. emit(event, [arg1], [arg2], […])"></a>8. emit(event, [arg1], [arg2], […])</h3><p>按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</p>
<h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><h3 id="listenerCount-emitter-event"><a href="#listenerCount-emitter-event" class="headerlink" title="listenerCount(emitter, event)"></a>listenerCount(emitter, event)</h3><p>返回指定事件的监听器数量。</p>
<pre><code>events.EventEmitter.listenerCount(emitter, eventName) //已废弃，不推荐
events.emitter.listenerCount(eventName) //推荐</code></pre><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="newListener"><a href="#newListener" class="headerlink" title="newListener"></a>newListener</h3><ul>
<li><p>event - 字符串，事件名称</p>
</li>
<li><p>listener - 处理事件函数</p>
</li>
</ul>
<p>该事件在添加新监听器时被触发。</p>
<h3 id="removeListener"><a href="#removeListener" class="headerlink" title="removeListener"></a>removeListener</h3><ul>
<li><p>event - 字符串，事件名称</p>
</li>
<li><p>listener - 处理事件函数</p>
</li>
</ul>
<p>从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。</p>
<p>创建 main.js 文件，代码如下：</p>
<pre><code>var events = require(&apos;events&apos;);
var eventEmitter = new events.EventEmitter();

// 监听器 #1
var listener1 = function listener1() {
   console.log(&apos;监听器 listener1 执行。&apos;);
}

// 监听器 #2
var listener2 = function listener2() {
  console.log(&apos;监听器 listener2 执行。&apos;);
}

// 绑定 connection 事件，处理函数为 listener1 
eventEmitter.addListener(&apos;connection&apos;, listener1);

// 绑定 connection 事件，处理函数为 listener2
eventEmitter.on(&apos;connection&apos;, listener2);

var eventListeners = eventEmitter.listenerCount(&apos;connection&apos;);
console.log(eventListeners + &quot; 个监听器监听连接事件。&quot;);

// 处理 connection 事件 
eventEmitter.emit(&apos;connection&apos;);

// 移除监绑定的 listener1 函数
eventEmitter.removeListener(&apos;connection&apos;, listener1);
console.log(&quot;listener1 不再受监听。&quot;);

// 触发连接事件
eventEmitter.emit(&apos;connection&apos;);

eventListeners = eventEmitter.listenerCount(&apos;connection&apos;);
console.log(eventListeners + &quot; 个监听器监听连接事件。&quot;);

console.log(&quot;程序执行完毕。&quot;);</code></pre><p>以上代码，执行结果如下所示：</p>
<pre><code>$ node main.js  
2 个监听器监听连接事件。
监听器 listener1 执行。
监听器 listener2 执行。
listener1 不再受监听。
监听器 listener2 执行。
1 个监听器监听连接事件。
程序执行完毕。</code></pre><h2 id="error-事件"><a href="#error-事件" class="headerlink" title="error 事件"></a>error 事件</h2><p>EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。</p>
<p>当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p>
<p>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：</p>
<pre><code>var events = require(&apos;events&apos;); 
var emitter = new events.EventEmitter(); 
emitter.emit(&apos;error&apos;); </code></pre><p>运行时会显示以下错误：</p>
<pre><code>node.js:201 
throw e; // process.nextTick error, or &apos;error&apos; event on first tick 
^ 
Error: Uncaught, unspecified &apos;error&apos; event. 
at EventEmitter.emit (events.js:50:15) 
at Object.&lt;anonymous&gt; (/home/byvoid/error.js:5:9) 
at Module._compile (module.js:441:26) 
at Object..js (module.js:459:10) 
at Module.load (module.js:348:31) 
at Function._load (module.js:308:12) 
at Array.0 (module.js:479:10) 
at EventEmitter._tickCallback (node.js:192:40)    </code></pre><h2 id="继承-EventEmitter"><a href="#继承-EventEmitter" class="headerlink" title="继承 EventEmitter"></a>继承 EventEmitter</h2><p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p>
<p>为什么要这样做呢？原因有两点：</p>
<p>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。</p>
<p>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p>
<h1 id="Node-js-Buffer-缓冲区"><a href="#Node-js-Buffer-缓冲区" class="headerlink" title="Node.js Buffer(缓冲区)"></a>Node.js Buffer(缓冲区)</h1><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。</p>
<p>但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。</p>
<p>在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。</p>
<blockquote>
<blockquote>
<p>在v6.0之前创建Buffer对象直接使用new Buffer()构造函数来创建对象实例，但是Buffer对内存的权限操作相比很大，可以直接捕获一些敏感信息，所以在v6.0以后，官方文档里面建议使用 Buffer.from() 接口去创建Buffer对象。    </p>
</blockquote>
</blockquote>
<h2 id="Buffer-与字符编码"><a href="#Buffer-与字符编码" class="headerlink" title="Buffer 与字符编码"></a>Buffer 与字符编码</h2><p>Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。</p>
<pre><code>const buf = Buffer.from(&apos;runoob&apos;, &apos;ascii&apos;);

// 输出 72756e6f6f62
console.log(buf.toString(&apos;hex&apos;));

// 输出 cnVub29i
console.log(buf.toString(&apos;base64&apos;));</code></pre><p>Node.js 目前支持的字符编码包括：</p>
<ul>
<li><p>ascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。</p>
</li>
<li><p>utf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。</p>
</li>
<li><p>utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。</p>
</li>
<li><p>ucs2 - utf16le 的别名。</p>
</li>
<li><p>base64 - Base64 编码。</p>
</li>
<li><p>latin1 - 一种把 Buffer 编码成一字节编码的字符串的方式。</p>
</li>
<li><p>binary - latin1 的别名。</p>
</li>
<li><p>hex - 将每个字节编码为两个十六进制字符。</p>
</li>
</ul>
<h2 id="创建-Buffer-类"><a href="#创建-Buffer-类" class="headerlink" title="创建 Buffer 类"></a>创建 Buffer 类</h2><p>Buffer 提供了以下 API 来创建 Buffer 类：</p>
<ul>
<li><p>Buffer.alloc(size[, fill[, encoding]])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0</p>
</li>
<li><p>Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据</p>
</li>
<li><p>Buffer.allocUnsafeSlow(size)</p>
</li>
<li><p>Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）</p>
</li>
<li><p>Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。</p>
</li>
<li><p>Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例</p>
</li>
<li><p>Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例</p>
<p>  / 创建一个长度为 10、且用 0 填充的 Buffer。<br>  const buf1 = Buffer.alloc(10);</p>
<p>  // 创建一个长度为 10、且用 0x1 填充的 Buffer。<br>  const buf2 = Buffer.alloc(10, 1);</p>
<p>  // 创建一个长度为 10、且未初始化的 Buffer。<br>  // 这个方法比调用 Buffer.alloc() 更快，<br>  // 但返回的 Buffer 实例可能包含旧数据，<br>  // 因此需要使用 fill() 或 write() 重写。<br>  const buf3 = Buffer.allocUnsafe(10);</p>
<p>  // 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。<br>  const buf4 = Buffer.from([1, 2, 3]);</p>
<p>  // 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。<br>  const buf5 = Buffer.from(‘tést’);</p>
<p>  // 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。<br>  const buf6 = Buffer.from(‘tést’, ‘latin1’);</p>
</li>
</ul>
<h2 id="写入缓冲区"><a href="#写入缓冲区" class="headerlink" title="写入缓冲区"></a>写入缓冲区</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>buf.write(string[, offset[, length]][, encoding])</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>参数描述如下：</p>
<ul>
<li><p>string - 写入缓冲区的字符串。</p>
</li>
<li><p>offset - 缓冲区开始写入的索引值，默认为 0 。</p>
</li>
<li><p>length - 写入的字节数，默认为 buffer.length</p>
</li>
<li><p>encoding - 使用的编码。默认为 ‘utf8’ 。</p>
</li>
</ul>
<p>根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。</p>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><pre><code>buf = Buffer.alloc(256);
len = buf.write(&quot;www.runoob.com&quot;);

console.log(&quot;写入字节数 : &quot;+  len);</code></pre><p>执行以上代码，输出结果为：</p>
<pre><code>$node main.js
写入字节数 : 14</code></pre><h2 id="从缓冲区读取数据"><a href="#从缓冲区读取数据" class="headerlink" title="从缓冲区读取数据"></a>从缓冲区读取数据</h2><h3 id="读取-Node-缓冲区数据的语法如下所示："><a href="#读取-Node-缓冲区数据的语法如下所示：" class="headerlink" title="读取 Node 缓冲区数据的语法如下所示："></a>读取 Node 缓冲区数据的语法如下所示：</h3><pre><code>buf.toString([encoding[, start[, end]]])</code></pre><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>参数描述如下：</p>
<ul>
<li><p>encoding - 使用的编码。默认为 ‘utf8’ 。</p>
</li>
<li><p>start - 指定开始读取的索引位置，默认为 0。</p>
</li>
<li><p>end - 结束位置，默认为缓冲区的末尾。</p>
</li>
</ul>
<h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><p>解码缓冲区数据并使用指定的编码返回字符串。</p>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><pre><code>buf = Buffer.alloc(26);
for (var i = 0 ; i &lt; 26 ; i++) {
  buf[i] = i + 97;
}

console.log( buf.toString(&apos;ascii&apos;));       // 输出: abcdefghijklmnopqrstuvwxyz
console.log( buf.toString(&apos;ascii&apos;,0,5));   // 输出: abcde
console.log( buf.toString(&apos;utf8&apos;,0,5));    // 输出: abcde
console.log( buf.toString(undefined,0,5)); // 使用 &apos;utf8&apos; 编码, 并输出: abcde</code></pre><p>执行以上代码，输出结果为：</p>
<pre><code>$ node main.js
abcdefghijklmnopqrstuvwxyz
abcde
abcde
abcde</code></pre><h2 id="将-Buffer-转换为-JSON-对象"><a href="#将-Buffer-转换为-JSON-对象" class="headerlink" title="将 Buffer 转换为 JSON 对象"></a>将 Buffer 转换为 JSON 对象</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><pre><code>buf.toJSON()</code></pre><p>当字符串化一个 Buffer 实例时，JSON.stringify() 会隐式地调用该 toJSON()。</p>
<h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>返回 JSON 对象。</p>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><pre><code>const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);
const json = JSON.stringify(buf);

// 输出: {&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]}
console.log(json);

const copy = JSON.parse(json, (key, value) =&gt; {
  return value &amp;&amp; value.type === &apos;Buffer&apos; ?
    Buffer.from(value.data) :
    value;
});

// 输出: &lt;Buffer 01 02 03 04 05&gt;
console.log(copy);</code></pre><p>执行以上代码，输出结果为：</p>
<pre><code>{&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]}
&lt;Buffer 01 02 03 04 05&gt;</code></pre><h2 id="缓冲区合并"><a href="#缓冲区合并" class="headerlink" title="缓冲区合并"></a>缓冲区合并</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><pre><code>Buffer.concat(list[, totalLength])</code></pre><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><p>参数描述如下：</p>
<ul>
<li><p>list - 用于合并的 Buffer 对象数组列表。</p>
</li>
<li><p>totalLength - 指定合并后Buffer对象的总长度。</p>
</li>
</ul>
<h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><p>返回一个多个成员合并的新 Buffer 对象。</p>
<h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><pre><code>var buffer1 = Buffer.from((&apos;菜鸟教程&apos;));
var buffer2 = Buffer.from((&apos;www.runoob.com&apos;));
var buffer3 = Buffer.concat([buffer1,buffer2]);
console.log(&quot;buffer3 内容: &quot; + buffer3.toString());</code></pre><p>执行以上代码，输出结果为：</p>
<pre><code>buffer3 内容: 菜鸟教程www.runoob.com</code></pre><h2 id="缓冲区比较"><a href="#缓冲区比较" class="headerlink" title="缓冲区比较"></a>缓冲区比较</h2><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><p>Node Buffer 比较的函数语法如下所示, 该方法在 Node.js v0.12.2 版本引入    </p>
<pre><code>buf.compare(otherBuffer);</code></pre><h3 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h3><p>参数描述如下：</p>
<ul>
<li>otherBuffer - 与 buf 对象比较的另外一个 Buffer 对象。</li>
</ul>
<h3 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h3><p>返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。</p>
<h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><pre><code>var buffer1 = Buffer.from(&apos;ABC&apos;);
var buffer2 = Buffer.from(&apos;ABCD&apos;);
var result = buffer1.compare(buffer2);

if(result &lt; 0) {
   console.log(buffer1 + &quot; 在 &quot; + buffer2 + &quot;之前&quot;);
}else if(result == 0){
   console.log(buffer1 + &quot; 与 &quot; + buffer2 + &quot;相同&quot;);
}else {
   console.log(buffer1 + &quot; 在 &quot; + buffer2 + &quot;之后&quot;);
}</code></pre><p>执行以上代码，输出结果为：</p>
<pre><code>ABC在ABCD之前</code></pre><h2 id="拷贝缓冲区"><a href="#拷贝缓冲区" class="headerlink" title="拷贝缓冲区"></a>拷贝缓冲区</h2><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><pre><code>buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</code></pre><ul>
<li><p>targetBuffer - 要拷贝的 Buffer 对象。</p>
</li>
<li><p>targetStart - 数字, 可选, 默认: 0</p>
</li>
<li><p>sourceStart - 数字, 可选, 默认: 0</p>
</li>
<li><p>sourceEnd - 数字, 可选, 默认: buffer.length</p>
</li>
</ul>
<h3 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h3><p>没有返回值。</p>
<h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><pre><code>var buf1 = Buffer.from(&apos;abcdefghijkl&apos;);
var buf2 = Buffer.from(&apos;RUNOOB&apos;);

//将 buf2 插入到 buf1 指定位置上
buf2.copy(buf1, 2);

console.log(buf1.toString());</code></pre><p>执行以上代码，输出结果为：</p>
<pre><code>abRUNOOBijkl</code></pre><h2 id="缓冲区裁剪"><a href="#缓冲区裁剪" class="headerlink" title="缓冲区裁剪"></a>缓冲区裁剪</h2><p>Node 缓冲区裁剪语法如下所示：</p>
<pre><code>buf.slice([start[, end]])</code></pre><p>参数<br>参数描述如下：</p>
<ul>
<li><p>start - 数字, 可选, 默认: 0</p>
</li>
<li><p>end - 数字, 可选, 默认: buffer.length</p>
</li>
</ul>
<p>返回值<br>返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。</p>
<p>实例</p>
<pre><code>var buffer1 = Buffer.from(&apos;runoob&apos;);
// 剪切缓冲区
var buffer2 = buffer1.slice(0,2);
console.log(&quot;buffer2 content: &quot; + buffer2.toString());
执行</code></pre><p>执行以上代码，输出结果为：</p>
<pre><code>buffer2 content: ru</code></pre><h2 id="缓冲区长度"><a href="#缓冲区长度" class="headerlink" title="缓冲区长度"></a>缓冲区长度</h2><pre><code>buf.length;</code></pre><p>返回值<br>返回 Buffer 对象所占据的内存长度。</p>
<p>实例</p>
<pre><code>var buffer = Buffer.from(&apos;www.runoob.com&apos;);
//  缓冲区长度
console.log(&quot;buffer length: &quot; + buffer.length);</code></pre><p>执行以上代码，输出结果为：</p>
<pre><code>buffer length: 14</code></pre><h1 id="Node-js-Stream-流"><a href="#Node-js-Stream-流" class="headerlink" title="Node.js Stream(流)"></a>Node.js Stream(流)</h1><p>Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。</p>
<p>Node.js，Stream 有四种流类型：</p>
<ul>
<li><p>Readable - 可读操作。</p>
</li>
<li><p>Writable - 可写操作。</p>
</li>
<li><p>Duplex - 可读可写操作.</p>
</li>
<li><p>Transform - 操作被写入数据，然后读出结果。</p>
</li>
</ul>
<p>所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：</p>
<ul>
<li><p>data - 当有数据可读时触发。</p>
</li>
<li><p>end - 没有更多的数据可读时触发。</p>
</li>
<li><p>error - 在接收和写入过程中发生错误时触发。</p>
</li>
<li><p>finish - 所有数据已被写入到底层系统时触发。</p>
</li>
</ul>
<h2 id="从流中读取数据"><a href="#从流中读取数据" class="headerlink" title="从流中读取数据"></a>从流中读取数据</h2><p>创建 input.txt 文件，内容如下：</p>
<pre><code>菜鸟教程官网地址：www.runoob.com

var fs = require(&quot;fs&quot;);
var data = &apos;&apos;;

// 创建可读流
var readerStream = fs.createReadStream(&apos;input.txt&apos;);

// 设置编码为 utf8。
readerStream.setEncoding(&apos;UTF8&apos;);

// 处理流事件 --&gt; data, end, and error
readerStream.on(&apos;data&apos;, function(chunk) {
   data += chunk;
});

readerStream.on(&apos;end&apos;,function(){
   console.log(data);
});

readerStream.on(&apos;error&apos;, function(err){
   console.log(err.stack);
});

console.log(&quot;程序执行完毕&quot;);</code></pre><p>以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下：</p>
<pre><code>$ node main.js 
程序执行完毕
写入完成。</code></pre><p>查看 output.txt 文件的内容：</p>
<pre><code>$ cat output.txt 
菜鸟教程官网地址：www.runoob.com</code></pre><h2 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h2><p>管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。    </p>
<p>设置 input.txt 文件内容如下：</p>
<pre><code>菜鸟教程官网地址：www.runoob.com
管道流操作实例</code></pre><p>创建 main.js 文件, 代码如下：</p>
<pre><code>var fs = require(&quot;fs&quot;);

// 创建一个可读流
var readerStream = fs.createReadStream(&apos;input.txt&apos;);

// 创建一个可写流
var writerStream = fs.createWriteStream(&apos;output.txt&apos;);

// 管道读写操作
// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中
readerStream.pipe(writerStream);

console.log(&quot;程序执行完毕&quot;);</code></pre><p>代码执行结果如下：</p>
<pre><code>$ node main.js 
程序执行完毕</code></pre><p>查看 output.txt 文件的内容：</p>
<pre><code>$ cat output.txt 
菜鸟教程官网地址：www.runoob.com
管道流操作实例</code></pre><h2 id="链式流"><a href="#链式流" class="headerlink" title="链式流"></a>链式流</h2><p>链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。</p>
<p>接下来我们就是用管道和链式来压缩和解压文件。</p>
<p>创建 compress.js 文件, 代码如下：</p>
<pre><code>var fs = require(&quot;fs&quot;);
var zlib = require(&apos;zlib&apos;);

// 压缩 input.txt 文件为 input.txt.gz
fs.createReadStream(&apos;input.txt&apos;)
  .pipe(zlib.createGzip())
  .pipe(fs.createWriteStream(&apos;input.txt.gz&apos;));

console.log(&quot;文件压缩完成。&quot;);</code></pre><p>代码执行结果如下：</p>
<pre><code>$ node compress.js 
文件压缩完成。</code></pre><p>执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。</p>
<p>接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下：</p>
<pre><code>var fs = require(&quot;fs&quot;);
var zlib = require(&apos;zlib&apos;);

// 解压 input.txt.gz 文件为 input.txt
fs.createReadStream(&apos;input.txt.gz&apos;)
  .pipe(zlib.createGunzip())
  .pipe(fs.createWriteStream(&apos;input.txt&apos;));

console.log(&quot;文件解压完成。&quot;);</code></pre><p>代码执行结果如下：</p>
<pre><code>$ node decompress.js 
文件解压完成。</code></pre><h1 id="Node-js模块系统"><a href="#Node-js模块系统" class="headerlink" title="Node.js模块系统"></a>Node.js模块系统</h1><p>为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。</p>
<p>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。</p>
<h2 id="创建模块-1"><a href="#创建模块-1" class="headerlink" title="创建模块"></a>创建模块</h2><p>在 Node.js 中，创建一个模块非常简单，如下我们创建一个 main.js 文件，代码如下:</p>
<pre><code>var hello = require(&apos;./hello&apos;);
hello.world();</code></pre><p>以上实例中，代码 require(‘./hello’) 引入了当前目录下的 hello.js 文件（./ 为当前目录，node.js 默认后缀为 js）。</p>
<p>Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。</p>
<p>接下来我们就来创建 hello.js 文件，代码如下：</p>
<pre><code>exports.world = function() {
  console.log(&apos;Hello World&apos;);
}</code></pre><p>在以上示例中，hello.js 通过 exports 对象把 world 作为模块的访问接口，在 main.js 中通过 require(‘./hello’) 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。</p>
<p>有时候我们只是想把一个对象封装到模块中，格式如下：</p>
<pre><code>module.exports = function() {
  // ...
}</code></pre><p>例如:</p>
<pre><code>//hello.js 
function Hello() { 
    var name; 
    this.setName = function(thyName) { 
        name = thyName; 
    }; 
    this.sayHello = function() { 
        console.log(&apos;Hello &apos; + name); 
    }; 
}; 
module.exports = Hello;</code></pre><p>这样就可以直接获得这个对象了：</p>
<pre><code>//main.js 
var Hello = require(&apos;./hello&apos;); 
hello = new Hello(); 
hello.setName(&apos;BYVoid&apos;); 
hello.sayHello(); </code></pre><p>模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。    </p>
<h2 id="服务端的模块放在哪里"><a href="#服务端的模块放在哪里" class="headerlink" title="服务端的模块放在哪里"></a>服务端的模块放在哪里</h2><p>也许你已经注意到，我们已经在代码中使用了模块了。像这样：</p>
<pre><code>var http = require(&quot;http&quot;);

...

http.createServer(...);</code></pre><p>Node.js 中自带了一个叫做 http 的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。</p>
<p>这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。</p>
<p>Node.js 的 require 方法中的文件查找策略如下：</p>
<p>由于 Node.js 中存在 4 类模块（原生模块和3种文件模块），尽管 require 方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。如下图所示：    </p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/03/nodejs-require.jpg" alt=""></p>
<h2 id="从文件模块缓存中加载"><a href="#从文件模块缓存中加载" class="headerlink" title="从文件模块缓存中加载"></a>从文件模块缓存中加载</h2><p>尽管原生模块与文件模块的优先级不同，但是都会优先从文件模块的缓存中加载已经存在的模块。</p>
<h2 id="从原生模块加载"><a href="#从原生模块加载" class="headerlink" title="从原生模块加载"></a>从原生模块加载</h2><p>原生模块的优先级仅次于文件模块缓存的优先级。require 方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个 http/http.js/http.node/http.json 文件，require(“http”) 都不会从这些文件中加载，而是从原生模块中加载。</p>
<p>原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。</p>
<h2 id="从文件加载"><a href="#从文件加载" class="headerlink" title="从文件加载"></a>从文件加载</h2><p>当文件模块缓存中不存在，而且不是原生模块的时候，Node.js 会解析 require 方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。</p>
<p>require方法接受以下几种参数的传递：    </p>
<ul>
<li><p>http、fs、path等，原生模块。</p>
</li>
<li><p>./mod或../mod，相对路径的文件模块。</p>
</li>
<li><p>/pathtomodule/mod，绝对路径的文件模块。</p>
</li>
<li><p>mod，非原生模块的文件模块。</p>
</li>
</ul>
<p>在路径 Y 下执行 require(X) 语句执行顺序：</p>
<pre><code>1. 如果 X 是内置模块
   a. 返回内置模块
   b. 停止执行
2. 如果 X 以 &apos;/&apos; 开头
   a. 设置 Y 为文件根路径
3. 如果 X 以 &apos;./&apos; 或 &apos;/&apos; or &apos;../&apos; 开头
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
4. LOAD_NODE_MODULES(X, dirname(Y))
5. 抛出异常 &quot;not found&quot;

LOAD_AS_FILE(X)
1. 如果 X 是一个文件, 将 X 作为 JavaScript 文本载入并停止执行。
2. 如果 X.js 是一个文件, 将 X.js 作为 JavaScript 文本载入并停止执行。
3. 如果 X.json 是一个文件, 解析 X.json 为 JavaScript 对象并停止执行。
4. 如果 X.node 是一个文件, 将 X.node 作为二进制插件载入并停止执行。

LOAD_INDEX(X)
1. 如果 X/index.js 是一个文件,  将 X/index.js 作为 JavaScript 文本载入并停止执行。
2. 如果 X/index.json 是一个文件, 解析 X/index.json 为 JavaScript 对象并停止执行。
3. 如果 X/index.node 是一个文件,  将 X/index.node 作为二进制插件载入并停止执行。

LOAD_AS_DIRECTORY(X)
1. 如果 X/package.json 是一个文件,
   a. 解析 X/package.json, 并查找 &quot;main&quot; 字段。
   b. let M = X + (json main 字段)
   c. LOAD_AS_FILE(M)
   d. LOAD_INDEX(M)
2. LOAD_INDEX(X)

LOAD_NODE_MODULES(X, START)
1. let DIRS=NODE_MODULES_PATHS(START)
2. for each DIR in DIRS:
   a. LOAD_AS_FILE(DIR/X)
   b. LOAD_AS_DIRECTORY(DIR/X)

NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let I = count of PARTS - 1
3. let DIRS = []
4. while I &gt;= 0,
   a. if PARTS[I] = &quot;node_modules&quot; CONTINUE
   b. DIR = path join(PARTS[0 .. I] + &quot;node_modules&quot;)
   c. DIRS = DIRS + DIR
   d. let I = I - 1
5. return DIRS</code></pre><p>exports 和 module.exports 的使用</p>
<p>如果要对外暴露属性或方法，就用 exports 就行，要暴露对象(类似class，包含了很多属性和方法)，就用 module.exports。    </p>
<h1 id="Node-js-函数"><a href="#Node-js-函数" class="headerlink" title="Node.js 函数"></a>Node.js 函数</h1><p>在JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。</p>
<p>Node.js中函数的使用与Javascript类似，举例来说，你可以这样做：</p>
<pre><code>function say(word) {
  console.log(word);
}

function execute(someFunction, value) {
  someFunction(value);
}

execute(say, &quot;Hello&quot;);</code></pre><p>以上代码中，我们把 say 函数作为execute函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！</p>
<p>这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。</p>
<p>当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。</p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>我们可以把一个函数作为变量传递。但是我们不一定要绕这个”先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：</p>
<pre><code>function execute(someFunction, value) {
  someFunction(value);
}</code></pre><p>我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。</p>
<p>用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做匿名函数 。</p>
<h2 id="函数传递是如何让HTTP服务器工作的"><a href="#函数传递是如何让HTTP服务器工作的" class="headerlink" title="函数传递是如何让HTTP服务器工作的"></a>函数传递是如何让HTTP服务器工作的</h2><p>带着这些知识，我们再来看看我们简约而不简单的HTTP服务器：</p>
<pre><code>var http = require(&quot;http&quot;);

http.createServer(function(request, response) {
  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
  response.write(&quot;Hello World&quot;);
  response.end();
}).listen(8888);</code></pre><p>现在它看上去应该清晰了很多：我们向 createServer 函数传递了一个匿名函数。</p>
<p>用这样的代码也可以达到同样的目的：</p>
<pre><code>var http = require(&quot;http&quot;);

function onRequest(request, response) {
  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
  response.write(&quot;Hello World&quot;);
  response.end();
}

http.createServer(onRequest).listen(8888);</code></pre><h1 id="Node-js-路由"><a href="#Node-js-路由" class="headerlink" title="Node.js 路由"></a>Node.js 路由</h1><p>我们要为路由提供请求的 URL 和其他需要的 GET 及 POST 参数，随后路由需要根据这些数据来执行相应的代码。</p>
<p>因此，我们需要查看 HTTP 请求，从中提取出请求的 URL 以及 GET/POST 参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。</p>
<p>我们需要的所有数据都会包含在 request 对象中，该对象作为 onRequest() 回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的 Node.JS 模块，它们分别是 url 和 querystring 模块。</p>
<pre><code>url.parse(string).query
                                           |
           url.parse(string).pathname      |
                       |                   |
                       |                   |
                     ------ -------------------
http://localhost:8888/start?foo=bar&amp;hello=world
                                ---       -----
                                 |          |
                                 |          |
              querystring.parse(queryString)[&quot;foo&quot;]    |
                                            |
                         querystring.parse(queryString)[&quot;hello&quot;]</code></pre><p>当然我们也可以用 querystring 模块来解析 POST 请求体中的参数，稍后会有演示。</p>
<p>现在我们来给 onRequest() 函数加上一些逻辑，用来找出浏览器请求的 URL 路径：</p>
<p><strong>server.js 文件代码：</strong></p>
<pre><code>var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start() {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);
    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
    response.write(&quot;Hello World&quot;);
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
}

exports.start = start;</code></pre><p>好了，我们的应用现在可以通过请求的 URL 路径来区别不同请求了–这使我们得以使用路由（还未完成）来将请求以 URL 路径为基准映射到处理程序上。</p>
<p>在我们所要构建的应用中，这意味着来自 /start 和 /upload 的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。</p>
<p>现在我们可以来编写路由了，建立一个名为 router.js 的文件，添加以下内容：<br><strong>router.js</strong></p>
<pre><code>function route(pathname) {
  console.log(&quot;About to route a request for &quot; + pathname);
}

exports.route = route;</code></pre><p>如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。</p>
<p>我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块。</p>
<p>首先，我们来扩展一下服务器的 start() 函数，以便将路由函数作为参数传递过去，server.js 文件代码如下</p>
<pre><code>var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start(route) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);

    route(pathname);

    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
    response.write(&quot;Hello World&quot;);
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
}

exports.start = start;</code></pre><p>同时，我们会相应扩展 index.js，使得路由函数可以被注入到服务器中：</p>
<p><strong>index.js 文件代码：</strong></p>
<pre><code>var server = require(&quot;./server&quot;);
var router = require(&quot;./router&quot;);

server.start(router.route);</code></pre><p>在这里，我们传递的函数依旧什么也没做。</p>
<p>如果现在启动应用（node index.js，始终记得这个命令行），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：</p>
<pre><code>$ node index.js
Server has started.        

以上输出已经去掉了比较烦人的 /favicon.ico 请求相关的部分。

浏览器访问 http://127.0.0.1:8888/，输出结果如下：</code></pre><h1 id="Node-js-全局对象"><a href="#Node-js-全局对象" class="headerlink" title="Node.js 全局对象"></a>Node.js 全局对象</h1><p>avaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。</p>
<p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p>
<p>在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</p>
<h2 id="全局对象与全局变量"><a href="#全局对象与全局变量" class="headerlink" title="全局对象与全局变量"></a>全局对象与全局变量</h2><p>global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量：</p>
<ul>
<li><p>在最外层定义的变量；</p>
</li>
<li><p>全局对象的属性；</p>
</li>
<li><p>隐式定义的变量（未定义直接赋值的变量）。</p>
</li>
</ul>
<p>你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注 意的是，在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。</p>
<p>注意： 最好不要使用 var 定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险。</p>
<h2 id="filename"><a href="#filename" class="headerlink" title="__filename"></a>__filename</h2><p>_filename 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。</p>
<p><strong>实例</strong><br>创建文件 main.js ，代码如下所示：</p>
<pre><code>// 输出全局变量 __filename 的值
console.log( __filename );</code></pre><p>执行 main.js 文件，代码如下所示:</p>
<pre><code>$ node main.js
/web/com/runoob/nodejs/main.js</code></pre><h2 id="dirname"><a href="#dirname" class="headerlink" title="__dirname"></a>__dirname</h2><p>__dirname 表示当前执行脚本所在的目录。</p>
<p><strong>实例</strong>    </p>
<p>创建文件 main.js ，代码如下所示：</p>
<pre><code>// 输出全局变量 __dirname 的值
console.log( __dirname );</code></pre><p>执行 main.js 文件，代码如下所示:</p>
<pre><code>$ node main.js
/web/com/runoob/nodejs</code></pre><h2 id="setTimeout-cb-ms"><a href="#setTimeout-cb-ms" class="headerlink" title="setTimeout(cb, ms)"></a>setTimeout(cb, ms)</h2><p>setTimeout(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout() 只执行一次指定函数。</p>
<p>返回一个代表定时器的句柄值。</p>
<p><strong>实例</strong>    </p>
<p>创建文件 main.js ，代码如下所示：</p>
<pre><code>function printHello(){
   console.log( &quot;Hello, World!&quot;);
}
// 两秒后执行以上函数
setTimeout(printHello, 2000);</code></pre><p>执行 main.js 文件，代码如下所示:</p>
<pre><code>$ node main.js
Hello, World!    </code></pre><h2 id="clearTimeout-t"><a href="#clearTimeout-t" class="headerlink" title="clearTimeout(t)"></a>clearTimeout(t)</h2><p>clearTimeout( t ) 全局函数用于停止一个之前通过 setTimeout() 创建的定时器。 参数 t 是通过 setTimeout() 函数创建的定时器。    </p>
<p>实例<br>创建文件 main.js ，代码如下所示：</p>
<pre><code>function printHello(){
   console.log( &quot;Hello, World!&quot;);
}
// 两秒后执行以上函数
var t = setTimeout(printHello, 2000);

// 清除定时器
clearTimeout(t);</code></pre><p>执行 main.js 文件，代码如下所示:</p>
<pre><code>$ node main.js    </code></pre><h2 id="setInterval-cb-ms"><a href="#setInterval-cb-ms" class="headerlink" title="setInterval(cb, ms)"></a>setInterval(cb, ms)</h2><p>setInterval(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。</p>
<p>返回一个代表定时器的句柄值。可以使用 clearInterval(t) 函数来清除定时器。</p>
<p>setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。</p>
<p>实例<br>创建文件 main.js ，代码如下所示：</p>
<pre><code>function printHello(){
   console.log( &quot;Hello, World!&quot;);
}
// 两秒后执行以上函数
setInterval(printHello, 2000);</code></pre><p>执行 main.js 文件，代码如下所示:</p>
<pre><code>$ node main.js
Hello, World!
Hello, World!
Hello, World!
Hello, World!
Hello, World!
Hello, World!
Hello, World!</code></pre><p>以上程序每隔两秒就会输出一次”Hello, World!”，且会永久执行下去，直到你按下 ctrl + c 按钮。</p>
<h2 id="console"><a href="#console" class="headerlink" title="console"></a>console</h2><p>console 用于提供控制台标准输出，它是由 Internet Explorer 的 JScript 引擎提供的调试工具，后来逐渐成为浏览器的实施标准。</p>
<p>Node.js 沿用了这个标准，提供与习惯行为一致的 console 对象，用于向标准输出流（stdout）或标准错误流（stderr）输出字符。</p>
<h3 id="console-log-data-…"><a href="#console-log-data-…" class="headerlink" title="console.log([data][, …])"></a>console.log([data][, …])</h3><p>向标准输出流打印字符并以换行符结束。该方法接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。</p>
<h3 id="console-info-data-…"><a href="#console-info-data-…" class="headerlink" title="console.info([data][, …])"></a>console.info([data][, …])</h3><p>该命令的作用是返回信息性消息，这个命令与console.log差别并不大，除了在chrome中只会输出文字外，其余的会显示一个蓝色的惊叹号。</p>
<h3 id="console-error-data-…"><a href="#console-error-data-…" class="headerlink" title="console.error([data][, …])"></a>console.error([data][, …])</h3><p>输出错误消息的。控制台在出现错误时会显示是红色的叉子。</p>
<h3 id="console-warn-data-…"><a href="#console-warn-data-…" class="headerlink" title="console.warn([data][, …])"></a>console.warn([data][, …])</h3><p>输出警告消息。控制台出现有黄色的惊叹号。</p>
<h3 id="console-dir-obj-options"><a href="#console-dir-obj-options" class="headerlink" title="console.dir(obj[, options])"></a>console.dir(obj[, options])</h3><p>用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</p>
<h3 id="console-time-label"><a href="#console-time-label" class="headerlink" title="console.time(label)"></a>console.time(label)</h3><p>输出时间，表示计时开始。</p>
<h3 id="console-timeEnd-label"><a href="#console-timeEnd-label" class="headerlink" title="console.timeEnd(label)"></a>console.timeEnd(label)</h3><p>结束时间，表示计时结束。</p>
<h3 id="console-trace-message-…"><a href="#console-trace-message-…" class="headerlink" title="console.trace(message[, …])"></a>console.trace(message[, …])</h3><p>当前执行的代码在堆栈中的调用路径，这个测试函数运行很有帮助，只要给想测试的函数里面加入 console.trace 就行了。</p>
<h3 id="console-assert-value-message-…"><a href="#console-assert-value-message-…" class="headerlink" title="console.assert(value[, message][, …])"></a>console.assert(value[, message][, …])</h3><p>用于判断某个表达式或变量是否为真，接收两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。</p>
<p>console.log()：向标准输出流打印字符并以换行符结束。<br>console.log 接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。</p>
<p>第一个参数是一个字符串，如果没有 参数，只打印一个换行。</p>
<pre><code>console.log(&apos;Hello world&apos;); 
console.log(&apos;byvoid%diovyb&apos;); 
console.log(&apos;byvoid%diovyb&apos;, 1991); 
运行结果为：

Hello world 
byvoid%diovyb 
byvoid1991iovyb 

console.error()：与console.log() 用法相同，只是向标准错误流输出。
console.trace()：向标准错误流输出当前的调用栈。

console.trace();

运行结果为：

Trace: 
at Object.&lt;anonymous&gt; (/home/byvoid/consoletrace.js:1:71) 
at Module._compile (module.js:441:26) 
at Object..js (module.js:459:10) 
at Module.load (module.js:348:31) 
at Function._load (module.js:308:12) 
at Array.0 (module.js:479:10) 
at EventEmitter._tickCallback (node.js:192:40)

console.info(&quot;程序开始执行：&quot;);

var counter = 10;
console.log(&quot;计数: %d&quot;, counter);

console.time(&quot;获取数据&quot;);
//
// 执行一些代码
// 
console.timeEnd(&apos;获取数据&apos;);

console.info(&quot;程序执行完毕。&quot;)

程序开始执行：
计数: 10
获取数据: 0ms
程序执行完毕</code></pre><h2 id="process"><a href="#process" class="headerlink" title="process"></a>process</h2><p>process 是一个全局变量，即 global 对象的属性。</p>
<p>它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要 和它打交道。下面将会介绍 process 对象的一些最常用的成员方法。</p>
<h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><p>当进程准备退出时触发。</p>
<h3 id="beforeExit"><a href="#beforeExit" class="headerlink" title="beforeExit"></a>beforeExit</h3><p>当 node 清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时 node 退出，但是 ‘beforeExit’ 的监听器可以异步调用，这样 node 就会继续执行。</p>
<h3 id="uncaughtException"><a href="#uncaughtException" class="headerlink" title="uncaughtException"></a>uncaughtException</h3><p>当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。</p>
<h3 id="Signal-事件"><a href="#Signal-事件" class="headerlink" title="Signal 事件"></a>Signal 事件</h3><p>当进程接收到信号时就触发。信号列表详见标准的 POSIX 信号名，如 SIGINT、SIGUSR1 等。</p>
<h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><p>创建文件 main.js ，代码如下所示：</p>
<pre><code>process.on(&apos;exit&apos;, function(code) {

  // 以下代码永远不会执行
  setTimeout(function() {
    console.log(&quot;该代码不会执行&quot;);
  }, 0);

  console.log(&apos;退出码为:&apos;, code);
});
console.log(&quot;程序执行结束&quot;);</code></pre><p>执行 main.js 文件，代码如下所示:</p>
<pre><code>$ node main.js
程序执行结束
退出码为: 0</code></pre><h3 id="退出状态码"><a href="#退出状态码" class="headerlink" title="退出状态码"></a>退出状态码</h3><table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">名称&amp;描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">Uncaught Fatal Exception <br> 有未捕获异常，并且没有被域或 uncaughtException 处理函数处理。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Unused <br> 保留</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Internal JavaScript Parse Error  <br> JavaScript的源码启动 Node 进程时引起解析错误。非常罕见，仅会在开发 Node 时才会有。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">Internal JavaScript Evaluation Failure  <br> JavaScript 的源码启动 Node 进程，评估时返回函数失败。非常罕见，仅会在开发 Node 时才会有。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">Fatal Error  <br> V8 里致命的不可恢复的错误。通常会打印到 stderr ，内容为： FATAL ERROR</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">Non-function Internal Exception Handler  <br> 未捕获异常，内部异常处理函数不知为何设置为on-function，并且不能被调用。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">Internal Exception Handler Run-Time Failure  <br> 未捕获的异常， 并且异常处理函数处理时自己抛出了异常。例如，如果 process.on(‘uncaughtException’) 或 domain.on(‘error’) 抛出了异常。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">Unused  <br> 保留</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">Invalid Argument  <br> 可能是给了未知的参数，或者给的参数没有值。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">Internal JavaScript Run-Time Failure  <br> JavaScript的源码启动 Node 进程时抛出错误，非常罕见，仅会在开发 Node 时才会有。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">Invalid Debug Argument   <br> 设置了参数–debug 和/或 –debug-brk，但是选择了错误端口。</td>
</tr>
<tr>
<td align="left">128</td>
<td align="left">Signal Exits  <br> 如果 Node 接收到致命信号，比如SIGKILL 或 SIGHUP，那么退出代码就是128 加信号代码。这是标准的 Unix 做法，退出信号代码放在高位。</td>
</tr>
</tbody></table>
<h3 id="Process-属性"><a href="#Process-属性" class="headerlink" title="Process 属性"></a>Process 属性</h3><p>Process 提供了很多有用的属性，便于我们更好的控制系统的交互：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">属性&amp;描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">stdout <br> 标准输出流。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">stderr <br> 标准错误流。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">stdin <br> 标准输入流。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">argv <br> argv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">execPath <br> 返回执行当前脚本的 Node 二进制文件的绝对路径。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">execArgv <br> 返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">env <br> 返回一个对象，成员为当前 shell 的环境变量</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">exitCode <br> 进程退出时的代码，如果进程优通过 process.exit() 退出，不需要指定退出码。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">version <br> Node 的版本，比如v0.10.18。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">versions <br> 一个属性，包含了 node 的版本和依赖.</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">config <br> 一个包含用来编译当前 node 执行文件的 javascript 配置选项的对象。它与运行 ./configure 脚本生成的 “config.gypi” 文件相同。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">pid <br> 当前进程的进程号。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">title <br> 进程名，默认值为”node”，可以自定义该值。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">arch <br> 当前 CPU 的架构：’arm’、’ia32’ 或者 ‘x64’。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">platform <br> 运行程序所在的平台系统 ‘darwin’, ‘freebsd’, ‘linux’, ‘sunos’ 或 ‘win32’</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">mainModule<br> require.main 的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。</td>
</tr>
</tbody></table>
<p><strong><em>实例</em></strong><br>创建文件 main.js ，代码如下所示：</p>
<pre><code>// 输出到终端
process.stdout.write(&quot;Hello World!&quot; + &quot;\n&quot;);

// 通过参数读取
process.argv.forEach(function(val, index, array) {
   console.log(index + &apos;: &apos; + val);
});

// 获取执行路径
console.log(process.execPath);


// 平台信息
console.log(process.platform);</code></pre><p>执行 main.js 文件，代码如下所示:</p>
<pre><code>$ node main.js
Hello World!
0: node
1: /web/www/node/main.js
/usr/local/node/0.10.36/bin/node
darwin</code></pre><p><strong>方法参考手册</strong><br>Process 提供了很多有用的方法，便于我们更好的控制系统的交互：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">abort() <br> 这将导致node触发abort事件。会让node退出并生成一个核心文件</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">chdir(directory) <br> 改变当前工作进程的目录，如果操作失败抛出异常。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">cwd() <br> 返回当前进程的工作目录</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">exit([code]) <br> 使用指定的 code 结束进程。如果忽略，将会使用 code 0。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">getgid() <br> 取进程的群组标识（参见 getgid(2)）。获取到得时群组的数字 id，而不是名字. 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">setgid(id) <br> 设置进程的群组标识（参见 setgid(2)）。可以接收数字 ID 或者群组名。如果指定了群组名，会阻塞等待解析为数字 ID 。                    注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">getuid() <br> 获取进程的用户标识(参见 getuid(2))。这是数字的用户 id，不是用户名。                  注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">setuid(id) <br> 设置进程的用户标识（参见setuid(2)）。接收数字 ID或字符串名字。果指定了群组名，会阻塞等待解析为数字 ID 。                    注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">getgroups() <br> 返回进程的群组 iD 数组。POSIX 系统没有保证一定有，但是 node.js 保证有。                     注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">setgroups(groups) <br> 设置进程的群组 ID。这是授权操作，所以你需要有 root 权限，或者有 CAP_SETGID 能力。                            注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">initgroups(user, extra_group) <br> 读取 /etc/group ，并初始化群组访问列表，使用成员所在的所有群组。这是授权操作，所以你需要有 root 权限，或者有 CAP_SETGID 能力。                                        注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">kill(pid[, signal]) <br> 发送信号给进程. pid 是进程id，并且 signal 是发送的信号的字符串描述。信号名是字符串，比如 ‘SIGINT’ 或 ‘SIGHUP’。如果忽略，信号会是 ‘SIGTERM’。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">memoryUsage() <br> 返回一个对象，描述了 Node 进程所用的内存状况，单位为字节。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">nextTick(callback) <br> 一旦当前事件循环结束，调用回调函数。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">umask([mask]) <br> 设置或读取进程文件的掩码。子进程从父进程继承掩码。如果mask 参数有效，返回旧的掩码。否则，返回当前掩码。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">uptime() <br> 返回 Node 已经运行的秒数。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left">hrtime() <br> 返回当前进程的高分辨时间，形式为 [seconds, nanoseconds]数组。它是相对于过去的任意事件。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。                   你可以将之前的结果传递给当前的 process.hrtime() ，会返回两者间的时间差，用来基准和测量时间间隔。</td>
</tr>
</tbody></table>
<h2 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h2><p>创建文件 main.js ，代码如下所示：</p>
<pre><code>// 输出当前目录
console.log(&apos;当前目录: &apos; + process.cwd());

// 输出当前版本
console.log(&apos;当前版本: &apos; + process.version);

// 输出内存使用情况
console.log(process.memoryUsage());</code></pre><p>执行 main.js 文件，代码如下所示:</p>
<pre><code>$ node main.js
当前目录: /web/com/runoob/nodejs
当前版本: v0.10.36
{ rss: 12541952, heapTotal: 4083456, heapUsed: 2157056 }</code></pre><h1 id="Node-js-常用工具"><a href="#Node-js-常用工具" class="headerlink" title="Node.js 常用工具"></a>Node.js 常用工具</h1><p>util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。</p>
<p>util.inherits<br>util.inherits(constructor, superConstructor) 是一个实现对象间原型继承的函数。</p>
<p>JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有提供对象继承的语言级别特性，而是通过原型复制来实现的。</p>
<p>在这里我们只介绍 util.inherits 的用法，示例如下</p>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>面试准备</title>
    <url>/2020/03/28/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><hr>
<ol>
<li><ul>
<li></li>
</ul>
</li>
</ol>
<h3 id="缓存雪崩-多个key过期"><a href="#缓存雪崩-多个key过期" class="headerlink" title="缓存雪崩(多个key过期)"></a>缓存雪崩(多个key过期)</h3><p><strong>缓存雪崩</strong>：</p>
<p>我们可以简单的理解为：由同一时间热点缓存大面积失效，(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p>
<p><strong>解决办法</strong>：</p>
<blockquote>
<p>大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时将缓存失效时间分散开。</p>
<p>或者设置热点数据永不过期，有更新操作的时候更新下缓存，电商首页用这个策略，保险</p>
</blockquote>
<h3 id="缓存击穿（当单个key过期）"><a href="#缓存击穿（当单个key过期）" class="headerlink" title="缓存击穿（当单个key过期）"></a>缓存击穿（当单个key过期）</h3><p><strong>问题：</strong>一些设置了过期时间的key，这些key可能会在某些时间点被超高并发访问，是一种非常热点的数据，这个时候请求发现缓存过期了，会直接读取db，大并发可能会搞垮db</p>
<p><strong>解决方案0：</strong>热点数据永不过期</p>
<p><strong>解决方案</strong>1：使用互斥锁：（SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。）</p>
<p>业界比较常用的方式是使用metex。简单的来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（setnx）去set一个mutex key，当操作成功时，再进行load db的操作并设置缓存，否则就重试整个get缓存的方法</p>
<p>优点：思路简单、保证一致性</p>
<p>缺点：代码复杂度增大、存在死锁的风险</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;  </span><br><span class="line">   String value = redis.get(key);  </span><br><span class="line">   <span class="keyword">if</span> (value  == <span class="keyword">null</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="string">"1"</span>)) &#123;  </span><br><span class="line">        <span class="comment">// 3 min timeout to avoid mutex holder crash  </span></span><br><span class="line">        redis.expire(key_mutex, <span class="number">3</span> * <span class="number">60</span>)  </span><br><span class="line">        value = db.get(key);  </span><br><span class="line">        redis.set(key, value);  </span><br><span class="line">        redis.delete(key_mutex);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">//其他线程休息50毫秒后重试  </span></span><br><span class="line">        Thread.sleep(<span class="number">50</span>);  </span><br><span class="line">        get(key);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案2：</strong>异步构建缓存</p>
<p>在这种方案下，构建缓存采取异步策略，会从线程池中取线程来异步构建缓存，从而不会让所有的请求直接怼到数据库上。该方案redis自己维护一个timeout，当timeout小于System.currentTimeMillis()时，则进行缓存更新，否则直接返回value值。</p>
<p>优点：用户无需等待</p>
<p>缺点：无法保证缓存一致性</p>
<p>集群环境的redis代码如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;  </span><br><span class="line">        V v = redis.get(key);  </span><br><span class="line">        String value = v.getValue();  </span><br><span class="line">        <span class="keyword">long</span> timeout = v.getTimeout();  </span><br><span class="line">        <span class="keyword">if</span> (v.timeout &lt;= System.currentTimeMillis()) &#123;  </span><br><span class="line">            <span class="comment">// 异步更新后台异常执行  </span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                    String keyMutex = <span class="string">"mutex:"</span> + key;  </span><br><span class="line">                    <span class="keyword">if</span> (redis.setnx(keyMutex, <span class="string">"1"</span>)) &#123;  </span><br><span class="line">                        <span class="comment">// 3 min timeout to avoid mutex holder crash  </span></span><br><span class="line">                        redis.expire(keyMutex, <span class="number">3</span> * <span class="number">60</span>);  </span><br><span class="line">                        String dbValue = db.get(key);  </span><br><span class="line">                        redis.set(key, dbValue);  </span><br><span class="line">                        redis.delete(keyMutex);  </span><br><span class="line">                   &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案3：</strong></p>
<p>布隆过滤器</p>
<p>优点：思路简单、保证一致性、性能强</p>
<p>缺点：代码复杂度增大、需要另外维护一个集合来存放缓存的key、不支持删值操作</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>问题：</strong>查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果db查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到db去，在流量大时，db可能就挂掉了</p>
<p>比如说：查询一个不存在id都是1开始自增上去的，如果查询一个id为-1的值</p>
<p><strong>解决方案：</strong></p>
<ol start="0">
<li>接口添加校验，比如用户鉴权，参数合法校验，比如id&lt;0的直接拦截等。</li>
</ol>
<p>1.最常见的就是布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力</p>
<p>2.更简单粗暴的方法：如果一个查询返回的数据为空（不管数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，设置一个比较短的过期时间</p>
<h3 id="双写一致问题"><a href="#双写一致问题" class="headerlink" title="双写一致问题"></a>双写一致问题</h3><p>数据库跟缓存同时操作肯定会出现不一致的问题</p>
<p>解决方案：延时双删策略</p>
<p>先删除redis，更新数据库，删除redis</p>
<p>参考文章：<a href="https://www.cnblogs.com/rjzheng/p/9041659.html" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/9041659.html</a></p>
<h3 id="redis与memcached有什么区别？为什么选用redis作为缓存的中间件"><a href="#redis与memcached有什么区别？为什么选用redis作为缓存的中间件" class="headerlink" title="redis与memcached有什么区别？为什么选用redis作为缓存的中间件"></a>redis与memcached有什么区别？为什么选用redis作为缓存的中间件</h3><ol>
<li>redis支持复杂结构，如果需要缓存支持复杂的结构和操作，redis 是不错的选择</li>
<li>redis原生支持集群模式：memcached需要依赖客户端来实现往集群中分片写入数据。</li>
</ol>
<h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h4><p>redis只是用单核，而memcached可以使用多核，所有平均每一个核上redis在存储小数据时比memcached性能更高，而在100k以上的数据中，memcached性能要高于redis</p>
<h3 id="redis线程模型"><a href="#redis线程模型" class="headerlink" title="redis线程模型"></a>redis线程模型</h3><p>内部使用文件事件处理器 file event handler，这个是单线程的，所以redis才叫单线程的模型，它采用io多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器进行处理。</p>
<blockquote>
<p>文件事件处理器，结构包括四个部分：</p>
<ul>
<li>多个socket</li>
<li>io多路复用程序</li>
<li>文件时间分派器</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
</blockquote>
<h3 id="Redis有哪些数据结构啊？"><a href="#Redis有哪些数据结构啊？" class="headerlink" title="Redis有哪些数据结构啊？"></a>Redis有哪些数据结构啊？</h3><blockquote>
<p>String、Hash、List、Set、SortedSet</p>
<p>以上五个基本类型，如果你是中高级用户的话，还有HyperLogLog、Geo、Pub、Sub</p>
<p>如果还想加分，还可以说玩过Redis Module，像BloomFilter、RedisSearch、Redis-ML</p>
</blockquote>
<h3 id="如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h3><blockquote>
<p>如果过期时间设置的过于集中，到过期的时候，Redis可能会出现短暂的卡顿现象，严重的话会出现缓存雪崩，一般在时间上加一个随机值，使得过期时间分散一些</p>
<p>电商首页经常会使用定时任务刷新缓存，可能大量的数据失效时间都十分集中，如果失效时间一样，又刚好在失效的时间点涌入大量访问，就可能缓存雪崩</p>
</blockquote>
<h3 id="你使用过Redis分布式锁么，它是怎么回事？"><a href="#你使用过Redis分布式锁么，它是怎么回事？" class="headerlink" title="你使用过Redis分布式锁么，它是怎么回事？"></a>你使用过Redis分布式锁么，它是怎么回事？</h3><blockquote>
<p>先拿setnx来争抢锁，抢到之后，再用Expire给锁加一个过期时间防止锁忘记释放。</p>
</blockquote>
<h4 id="如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？"><a href="#如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？" class="headerlink" title="如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？"></a>如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？</h4><blockquote>
<p>这个时候你一定要给予惊讶的反馈，是哦，这个锁就永远得不到释放了，紧接着，你抓了抓自己的头发，故作思考：我记得set指令有个非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的</p>
</blockquote>
<h3 id="假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？"><a href="#假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？" class="headerlink" title="假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？"></a>假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？</h3><blockquote>
<p>使用keys指令可以扫出指定模式的key列表</p>
</blockquote>
<p><strong>继续追问：如果这个redis正在给线上的业务提供服务，那么使用keys指令会有什么问题?</strong></p>
<blockquote>
<p>redis是单线程的，使用keys会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，这个时候可以使用<strong><u>scan</u></strong>指令，<strong><u>scan</u></strong>指令可以无阻塞的取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，单整体花费的时间会比直接使用keys指令长</p>
</blockquote>
<h3 id="redis是怎么持久化的？服务主从数据是怎么交互的？"><a href="#redis是怎么持久化的？服务主从数据是怎么交互的？" class="headerlink" title="redis是怎么持久化的？服务主从数据是怎么交互的？"></a>redis是怎么持久化的？服务主从数据是怎么交互的？</h3><blockquote>
<p>rdb做镜像全量持久化，aof做增量持久化。因为rdb会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用rdb持久化文件重构内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态</p>
<p>这里很好理解的，把rdb理解为一整个表全量的数据，aof理解为每次操作的日志就好了，服务器重启的时候先把表的数据全部搞进去，但是可能不完整，这个时候再回放一下日志，数据不就完整了嘛。不过redis本身的机制是aof持久化开启且存在aof文件时，优先加载aof文件；aof关闭或者aof文件不存在时，加载rdb文件；加载aof/rdb文件成功后，redis启动成功；aof/rdb文件存在错误时，redis启动失败并打印错误信息</p>
</blockquote>
<p><strong>对方追问如果突然机器停电会怎样?</strong></p>
<blockquote>
<p>取决于aof日志sync属性的配置，如果不要求心梗，在每一条写指令时都sync一下磁盘，就不会丢失数据，但是在高性能要求下每次都sync是不现实的，一般都使用定时sync，比如1s/1次，这个时候最多就会丢失1s的数据</p>
</blockquote>
<p><strong>对方继续追问rdb的原理是什么？</strong></p>
<blockquote>
<p>这个问题给出两个词汇就可以了，fork和cow。fork是指redis通过创建子进程来进行rdb操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会主键和子进程分离开来</p>
</blockquote>
<p><strong>Pipeline有什么好处，为什么要用Pipeline？</strong></p>
<blockquote>
<p>可以将多次io往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目</p>
</blockquote>
<blockquote>
</blockquote>
<p><strong>是否使用过redis集群，集群的高可用怎么保证，集群的原理是什么？</strong></p>
<blockquote>
<p>redis Sentinel着眼于高可用，在master宕机时会自动将slave升级为master，继续提供服务 。</p>
<p>redis cluster 着眼于扩展性，在单个redis内存不足时，使用cluster进行分片存储</p>
</blockquote>
<h3 id="哨兵、持久化、主从、手撕LRU"><a href="#哨兵、持久化、主从、手撕LRU" class="headerlink" title="哨兵、持久化、主从、手撕LRU"></a>哨兵、持久化、主从、手撕LRU</h3><p>在上面了解完基础知识已经一些缓存的常见问题之后，聊聊下面的</p>
<p><strong>为什么redis那么快</strong></p>
<blockquote>
<p>先看一下关系型数据库跟redis本质上的区别，如下图：</p>
<img src="img/面试准备.assets/image-20200224174728652.png" alt="image-20200224174728652" style="zoom:50%;" />

<p>Redis采用的是<strong>单进程单线程</strong>模型的kv数据库，由c编写，官方提供的数据是达到10w的qps（每秒内查询次数）</p>
<ul>
<li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快。数据存在内存中，类似于<strong>HashMap</strong>，HashMap的优势就是查找和操作的时间复杂度都是O(1);</li>
<li>数据结构简单，对数据操作也简单，redis中的数据结构是专门进行设计的</li>
<li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换消耗，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</li>
<li>使用多路i/o复用模型，非阻塞io；</li>
<li>使用底层模型不同，他么之间底层实现方式以及与客户端之间通信的应用协议不一样，redis直接自己构建了vm机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</li>
</ul>
</blockquote>
<p><strong>我可以问一下啥是上下文切换吗？为啥可能线程不安全？</strong></p>
<blockquote>
<p>好比你看一本英文书，你看到第十页发现有个单词不会，你加了个书签，然后去查字典，过了一会你回来继续从书签那里读，ok目前为止没问题。</p>
<p>问题来了，你去查字典的时候，别人过来翻了一下你的书，然后走了，然后你回来了，你再看书的时候发现书不是你看的那一页了。</p>
</blockquote>
<p><strong>那他是单线程，我们服务器都是多核的，那不是浪费吗？</strong></p>
<blockquote>
<p>虽然他是单线程的，但是我们可以单机开多个实例啊</p>
</blockquote>
<p><strong>既然提到了单机会有瓶颈，那你们是怎么解决这个瓶颈的？</strong></p>
<blockquote>
<p>我们用到了集群的部署方式也就是redis cluster,并且是主从同步读写分离，类似Mysql的主从同步，Redis cluster支撑n个redis mater node，并且每个master node 都可以挂载多个salve node</p>
<p>这样整个Redis就可以横向扩容了，如果你要吃成更大数据量的缓存，那就横向扩容更多的master节点，每个master节点就能存放更多的数据了。</p>
</blockquote>
<p><strong>那么问题来了，他们之间是怎么进行数据交互的？以及redis 是怎么进行持久化的？Redis数据都在内存中，一断电或者重启不就木有了吗？</strong></p>
<blockquote>
<p>是的，持久化的话是redis高可用中的重要一点，因为redis数据在内存的特性，持久化必须有，我了解方式有两种：</p>
<p><strong>RDB：</strong>是对redis中的数据进行周期性的持久化</p>
<p><strong>AOF：</strong>对每条写入命令作为日志，以[只追加]【append-only】的方式写入到一个日志文件中，没有任何磁盘寻址的开销，所以很快，有点像mysql中binlog</p>
<p>这两种方式都可以把redis内存中的数据持久化到磁盘上，rdb更适合做冷备，aof更适合做热备</p>
<p><strong>tip</strong>：两种机制全部开启的时候，redis在重启的时候回默认使用aof去重新构建数据，因为aof的数据是比rdb更完整的</p>
</blockquote>
<p><strong>那这两种机制各自优缺点是啥？</strong></p>
<blockquote>
<p><strong>RDB</strong></p>
<p><strong>优点：</strong></p>
<p>会生成多个数据文件，每个数据文件都代表了某一时刻redis里面的数据，这种方式，很适合做冷备</p>
<p>rdb对redis性能影响较小，是因为在同步时候他只是fork了一个子进程去做持久化的，而且他在数据恢复的时候速度比aof来得快</p>
<p><strong>缺点：</strong></p>
<p>rdb都是快照文件，都是默认五分钟甚至更久的时间才生成一次，意味着两次同步之间五分钟的数据可能全部丢失，aof则最多丢1秒的数据</p>
<p>还有就是rdb在生成数据快照的时候，如果文件很大， 客户端可能会暂停几毫秒甚至几秒，你公司在做秒杀的时候它刚搞在这个时候fork了一个子进程去生成一个大快照</p>
<p><strong>AOF</strong></p>
<p><strong>优点：</strong>一秒生成一个，只追加的方式写，性能惊人</p>
<p><strong>缺点：</strong></p>
<p>一样的数据aof文件比rdb还要大，aof开启后redis支持写的qps会比rdb支持写的要低</p>
</blockquote>
<p><strong>那两者如何选择呢？</strong></p>
<blockquote>
<p>两个都要，出现事故，第一时间用rdb恢复，在用aof补全</p>
</blockquote>
<p><strong>Redis还有其他保证集群高可用的方式吗？</strong></p>
<blockquote>
<p>还要哨兵集群sentinel（森提nou）</p>
<p>哨兵必须用三个实例去保证自己的健壮性，哨兵+主从并不能保证数据不丢失，但是可以保证集群的高可用</p>
<p>一个机器挂了，剩下两个机器需要选举出来一个执行故障转移，如果只有两台机器的话，挂了一个就剩下一个了，没有哨兵去允许故障转移了</p>
</blockquote>
<p>Redis<strong>的同步机制</strong></p>
<blockquote>
<p>redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存，加载完成后，通知主节点将期间修改的操作记录同步到点进行重放就完成了同步过程。后续的增量数据通过aof日志同步即知，有点类似数据库的binlog。</p>
</blockquote>
<p><strong>说一下他的内存淘汰机制</strong></p>
<blockquote>
<p>Redis的过期策略有两种，<strong>定期删除</strong>+<strong>惰性删除</strong></p>
<p><strong>定期删除：</strong>默认100ms就随意抽一些设置了过期时间的key，检查是否过期，过期就删除</p>
<p>为什么不扫描全部设置了过期时间的key呢？</p>
<blockquote>
<p>因为太慢，浪费资源</p>
</blockquote>
<p>如果没随机到很多key，里面不就存在大量的无效key了？</p>
<blockquote>
<p>好问题，不是还有惰性删除吗</p>
</blockquote>
<p><strong>惰性删除：</strong>我不主动删，我懒，等你来查询了，我看看有没有过期，过期就删了还不给你返回，没过期就那么挂着</p>
</blockquote>
<h3 id="1-13-双写一致性、并发竞争、线程模型"><a href="#1-13-双写一致性、并发竞争、线程模型" class="headerlink" title="1.13 双写一致性、并发竞争、线程模型"></a>1.13 双写一致性、并发竞争、线程模型</h3><h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引有哪些数据结构"><a href="#索引有哪些数据结构" class="headerlink" title="索引有哪些数据结构"></a>索引有哪些数据结构</h3><p>Hash、B+</p>
<p>去创建索引的时候，可以选择索引的类型</p>
<h3 id="为什么hash、完全平衡二叉树、b树、b-树都可以优化查询，mysql为什么喜欢b-树？"><a href="#为什么hash、完全平衡二叉树、b树、b-树都可以优化查询，mysql为什么喜欢b-树？" class="headerlink" title="为什么hash、完全平衡二叉树、b树、b+树都可以优化查询，mysql为什么喜欢b+树？"></a>为什么hash、完全平衡二叉树、b树、b+树都可以优化查询，mysql为什么喜欢b+树？</h3><p>先说hash索引，字段值所对应的数据下标是哈希随机算出来的，可能会出现hash冲突。</p>
<p>举例：where name = ‘鸡蛋’，“鸡蛋”可以直接hash出他的数组下标，然后直接从数据中取出来</p>
<p>举例2：where name &gt;’鸡蛋’，那么hash表就无能为力了，他可以精确查询，但是不支持范围查询，就算做成索引，速度也很慢，要扫全表。</p>
<h4 id="hash表的适合场景？"><a href="#hash表的适合场景？" class="headerlink" title="hash表的适合场景？"></a>hash表的适合场景？</h4><p>hash表是无序的。</p>
<p>redis、Memcached这些nosql的中间件。kv结构的</p>
<h4 id="说的是无序的hash表，有没有有序的结构？"><a href="#说的是无序的hash表，有没有有序的结构？" class="headerlink" title="说的是无序的hash表，有没有有序的结构？"></a>说的是无序的hash表，有没有有序的结构？</h4><p>有序数组，等值查询和范围查询都很好</p>
<p><strong>缺点：</strong>适合做静态数据，因为增删改会改变他的结构</p>
<p><strong>适用：</strong>静态存储的索引啊，比如说2019年的支付宝账单，等等历史记录，都是不会变动的数据</p>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>二叉树是有序的，所以支持范围查询，但是时间复杂度是o(log(n)),为了维持这个时间复杂度，更新的时间复杂度也得是o(log(n))，那就得保持这棵树是完全平衡二叉树了</p>
<p>索引页不止在内存里存储的，也要落盘持久化的，如果数据多了，树就很高了，查询成本随着树变高而高</p>
<p>如果公司为了节约成本用的机械盘，来一次千万级别的查询，那不得慢死了</p>
<h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p><img src="https://user-gold-cdn.xitu.io/2020/3/8/170baaef95fc7c13?imageslim" alt="img"></p>
<p>b树比完全平衡二叉树要矮，原因是b树中的一个节点可以存储多个元素</p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p><img src="https://user-gold-cdn.xitu.io/2020/3/8/170baaef96c4dc05?imageslim" alt="img"></p>
<p>同样的元素，b+树会比b树要“胖”，原因在于B+树中的非叶子节点会冗余一份在叶子节点中，并且叶子节点之间用指针相连</p>
<h4 id="B-树-优势"><a href="#B-树-优势" class="headerlink" title="B+树 优势"></a>B+树 优势</h4><p>Hash不支持范围查询</p>
<p>二叉树太高</p>
<p>只有B树可以跟b+比一比</p>
<p>b树一个节点存储多个元素，相对于完全平衡二叉树的树高整体降低了，磁盘io效率提高了</p>
<p>b+树是b树的升级版，只是把非叶子节点冗余一下，这样可以提高范围查找的效率：原因是会有指针指向下一个节点的叶子节点</p>
<h4 id="一个b-树节点可以存储多少个元素？"><a href="#一个b-树节点可以存储多少个元素？" class="headerlink" title="一个b+树节点可以存储多少个元素？"></a>一个b+树节点可以存储多少个元素？</h4><p>懵逼，换个角度，b+树中一个节点到底多大合适？</p>
<p>b+树中一个节点为一页或者页的倍数最合适</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p><strong>是什么?</strong></p>
<p>大概就是有个主键为ID的索引，和一天个普通字段 name 的索引，我们在普通字段上搜索：</p>
<p>select  * from table where name = ‘“丙丙”</p>
<p>执行的流程是：先查询name索引上的“丙丙”，然后找到他id是2，最后去主键索引，找到id为2对应的值。</p>
<p>回到主键索引树搜索的过程，就是回表。</p>
<p>覆盖索引可以避免回表</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p><strong>是什么？</strong></p>
<p>比如说刚才的 select * ，查询所有的，如果我们只是需要id，那么其实name字段的索引上就已经有了，就不需要回表了</p>
<p>很多联合索引的建立，就是为了支持覆盖索引，特定的业务能极大的提升效率</p>
<h3 id="char-、varchar的区别是什么？"><a href="#char-、varchar的区别是什么？" class="headerlink" title="char 、varchar的区别是什么？"></a>char 、varchar的区别是什么？</h3><p>varchar 是变长，而char是长度固定的，如果你的内容是固定大小的，使用char性能更好</p>
<h3 id="truncate与delete的区别是什么？"><a href="#truncate与delete的区别是什么？" class="headerlink" title="truncate与delete的区别是什么？"></a>truncate与delete的区别是什么？</h3><p>truncate 是永久删出表中的每一行，且不可恢复</p>
<h3 id="什么是触发器？"><a href="#什么是触发器？" class="headerlink" title="什么是触发器？"></a>什么是触发器？</h3><p>触发器是指一段代码，当触发某个事件时，自动执行这些代码。在mysql数据库中有如下6种触发器：1.Before Insert 2.After Insert 3.Before Update 4.After Update 5.Before Delete 6.After Delete</p>
<h3 id="float与double的区别是什么？"><a href="#float与double的区别是什么？" class="headerlink" title="float与double的区别是什么？"></a>float与double的区别是什么？</h3><p>fioat存储至多8位十进制数，内存占用4字节</p>
<p>double存储至多18位十进制数，内存占用8字节</p>
<h3 id="如果在mysql获取当前日期"><a href="#如果在mysql获取当前日期" class="headerlink" title="如果在mysql获取当前日期"></a>如果在mysql获取当前日期</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select current_date();</span><br></pre></td></tr></table></figure>

<h3 id="如何查询第n高的工资"><a href="#如何查询第n高的工资" class="headerlink" title="如何查询第n高的工资"></a>如何查询第n高的工资</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select distinct(salary) from employee order by salary Desc limit n-1,1</span><br></pre></td></tr></table></figure>

<h3 id="请说明innodb和mylsam的区别"><a href="#请说明innodb和mylsam的区别" class="headerlink" title="请说明innodb和mylsam的区别"></a>请说明innodb和mylsam的区别</h3><blockquote>
<p>innodb，支持事务</p>
<p>innodb，支持崩溃后的恢复</p>
</blockquote>
<h3 id="请列举三个以上表引擎"><a href="#请列举三个以上表引擎" class="headerlink" title="请列举三个以上表引擎"></a>请列举三个以上表引擎</h3><p>innodb 、MylSAM、Memory</p>
<h3 id="varchar和text的区别"><a href="#varchar和text的区别" class="headerlink" title="varchar和text的区别"></a>varchar和text的区别</h3><ul>
<li>varchar可以指定字符数，text不能指定</li>
<li>内部存储varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节（n&gt;255）,text是实际字符数+2个字节</li>
<li>text不能有默认值,默认值为null</li>
<li>varchar可以直接创建索引，text创建索引要指定前多少个字符，varchar查询速度快于text，在都创建索引的情况下，text的索引几乎不起作用。</li>
<li>查询text需要创建临时表</li>
</ul>
<h3 id="varchar（50）中50的含义"><a href="#varchar（50）中50的含义" class="headerlink" title="varchar（50）中50的含义"></a>varchar（50）中50的含义</h3><p>最多存放50个字符</p>
<p>varchar（50）和（200）存储“hello”所占用的空间是一样的，但是200在排序时会消耗更多内存。</p>
<h3 id="int（20）中20的含义"><a href="#int（20）中20的含义" class="headerlink" title="int（20）中20的含义"></a>int（20）中20的含义</h3><p>是指显示字符的长度，不影响内部存储，只是当定义了ZEROFILL时，前面补多少个0</p>
<h3 id="索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响？"><a href="#索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响？" class="headerlink" title="索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响？"></a>索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响？</h3><ol>
<li>唯一索引：数据列不允许重复，可以null，一个表可以创建多个</li>
<li>主键索引：一定是唯一索引，不允许null，一个表只能有一个</li>
<li>主键可以与外键构成曹肇完整性约束，防止数据不一致。</li>
<li>联合索引：将多个列组合在一起创建索引，可以覆盖多个列。</li>
<li>外检索引：基本不用，只有innodb类型的表才可以使用</li>
<li>全文索引：mysql自带的全文索引只能用于mylSAM，并且只能对英文进行全文检索（基本不用）</li>
</ol>
<h3 id="最左前缀"><a href="#最左前缀" class="headerlink" title="最左前缀"></a>最左前缀</h3><p>顾名思义，就是最左优先，在创建多列索引时，需要根据业务需求，where字句中使用最频繁的一列放在最左边。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以 index(a,b,c) 为例,(注意和顺序有关)</span><br><span class="line">where a&#x3D;2 可以用到索引</span><br><span class="line">where a&#x3D;1 and b&#x3D;2 可以用到索引</span><br><span class="line">where a&#x3D;1 and b&#x3D;2 and c&#x3D;3 可以用到索引</span><br><span class="line">where b&#x3D;1 &#x2F; c&#x3D;1 不能用到索引</span><br><span class="line">where a&#x3D;1 and c&#x3D;1 a可以发挥索引，c不能使用到索引</span><br><span class="line">where a&#x3D;1 and b&gt;10 and c&#x3D;1 a可以发挥索引，b也可以发挥索引，c不能发挥索引</span><br><span class="line">where a&#x3D;1 and b like &#39;xxx%&#39; and c&#x3D;1 a可以发挥索引，b可以发挥索引，c不能发挥索引</span><br></pre></td></tr></table></figure>

<ol>
<li>组合索引的生效原则是 从前往后依次使用生效，如果中间某个索引没有使用，那么断点前面的索引部分起作用，断点后面的索引没有起作用；</li>
</ol>
<h2 id="联合索引最左匹配原则"><a href="#联合索引最左匹配原则" class="headerlink" title="联合索引最左匹配原则"></a>联合索引最左匹配原则</h2><h4 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a><strong>最左前缀匹配原则</strong></h4><p>在mysql建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，示例：<br>对列col1、列col2和列col3建一个联合索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KEY test_col1_col2_col3 on test(col1,col2,col3);</span><br></pre></td></tr></table></figure>

<p>联合索引 test_col1_col2_col3 实际建立了(col1)、(col1,col2)、(col,col2,col3)三个索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM test WHERE col1&#x3D;“1” AND clo2&#x3D;“2” AND clo4&#x3D;“4”</span><br></pre></td></tr></table></figure>

<p>上面这个查询语句执行时会依照最左前缀匹配原则，检索时会使用索引(col1,col2)进行数据匹配。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h4><p>索引的字段可以是任意顺序的，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM test WHERE col1&#x3D;“1” AND clo2&#x3D;“2”</span><br><span class="line">SELECT * FROM test WHERE col2&#x3D;“2” AND clo1&#x3D;“1”</span><br></pre></td></tr></table></figure>

<p>这两个查询语句都会用到索引(col1,col2)，mysql创建联合索引的规则是首先会对联合合索引的最左边的，也就是第一个字段col1的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个字段col2进行排序。其实就相当于实现了类似 order by col1 col2这样一种排序规则。</p>
<p>有人会疑惑第二个查询语句不符合最左前缀匹配：首先可以肯定是两个查询语句都包含索引(col1,col2)中的col1、col2两个字段，只是顺序不一样，查询条件一样，最后所查询的结果肯定是一样的。既然结果是一样的，到底以何种顺序的查询方式最好呢？此时我们可以借助mysql查询优化器explain，explain会纠正sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。</p>
<h4 id="为什么要使用联合索引"><a href="#为什么要使用联合索引" class="headerlink" title="为什么要使用联合索引"></a><strong>为什么要使用联合索引</strong></h4><ul>
<li><strong>减少开销</strong>。建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！</li>
<li><strong>覆盖索引</strong>。对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。</li>
<li><strong>效率高</strong>。索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select <em>from table where col1=1 and col2=2 and col3=3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W<em>10%=100w条数据，然后再回表从100w条数据中找到符合col2=2 and col3= 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w</em>10%</em> 10% *10%=1w，效率提升可想而知！</li>
</ul>
<h4 id="引申"><a href="#引申" class="headerlink" title="引申"></a><strong>引申</strong></h4><p>对于联合索引(col1,col2,col3)，查询语句SELECT * FROM test WHERE col2=2;是否能够触发索引？<br>大多数人都会说NO，实际上却是YES。<br><strong>原因</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test WHERE col2&#x3D;2;</span><br><span class="line">EXPLAIN SELECT * FROM test WHERE col1&#x3D;1;</span><br></pre></td></tr></table></figure>

<p>观察上述两个explain结果中的type字段。查询中分别是：</p>
<ol>
<li>type: index</li>
<li>type: ref</li>
</ol>
<p><strong>index</strong>：这种类型表示mysql会对整个该索引进行扫描。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个<strong>联合索引的一部分</strong>，mysql都可能会采用index类型的方式扫描。但是呢，缺点是效率不高，mysql会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引。所以，上述语句会触发索引。</p>
<p><strong>ref</strong>：这种类型表示mysql会根据特定的算法快速查找到某个符合条件的索引，而不是会对索引中每一个数据都进行一一的扫描判断，也就是所谓你平常理解的使用索引查询会更快的取出数据。而要想实现这种查找，索引却是有要求的，要实现这种能快速查找的算法，索引就要满足特定的数据结构。简单说，<strong>也就是索引字段的数据必须是有序的，才能实现这种类型的查找，才能利用到索引。</strong></p>
<h4 id="索引算法"><a href="#索引算法" class="headerlink" title="索引算法"></a><strong>索引算法</strong></h4><p>btree是最常用的，也是mysql默认的算法，因为它不仅仅可以用在=、&gt;、&gt;=、&lt;、&lt;=和between这些比较操作符上，也可以用于like操作符，只要他的查询条件不是一通配符开头的常量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from user where name like ‘jack%’---使用索引</span><br><span class="line">select * from user where name like ‘%jack’---不使用索引</span><br></pre></td></tr></table></figure>



<p>hash索引只能用于对等比较，例如=、&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像btree索引需要从根节点到枝节点，最后才能访问到叶节点这样多次io访问，所以hash索引的效率远高于btree索引</p>
<h4 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a><strong>索引的设计原则</strong></h4><ol>
<li>适合索引的列是出现在where字句中的列，或者连接字句中指定的列</li>
<li>基数较小的列，索引效果差，没必要在此列建立索引</li>
<li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</li>
<li>不要过度索引，占用额外的磁盘空间，并降低写操作的性能。在修改表能容的时候，索引进行更新甚至重构</li>
</ol>
<h4 id="mysql中in-和exists区别"><a href="#mysql中in-和exists区别" class="headerlink" title="mysql中in 和exists区别"></a><strong>mysql中in 和exists区别</strong></h4><ol>
<li>如果查询的两个表大小想打，那么in和exists差别不大</li>
<li>如果一个小表，一个大表，则子查询表大的用exists，子查询表小的用in</li>
<li>not in 和 not exists 如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not exists 的子查询依然能用到表上的索引。所以无论哪个表达，用not exists 都比not in 要快</li>
</ol>
<h2 id="mysql的关联查询语句有哪些？"><a href="#mysql的关联查询语句有哪些？" class="headerlink" title="mysql的关联查询语句有哪些？"></a>mysql的关联查询语句有哪些？</h2><blockquote>
<p>6中关联查询：1 交叉连接（cross join）；2 内连接（inner join）；3 外连接（left join、right join）；4 联合查询（ union 与 union all）；5 全连接（full join）；</p>
</blockquote>
<p><strong>内连接分为三类</strong></p>
<blockquote>
<ol>
<li>等值连接：on a.id=b.id</li>
<li>不等值连接：on a.id &gt;b.id</li>
<li>自连接 ：select * from a t1 inner join a t2 on t1.id = t2.id</li>
</ol>
</blockquote>
<p><strong>外连接（left join、right join）</strong></p>
<blockquote>
<ol>
<li>左匹配连接，以左表为主，先查询出主表，按照on后的关联条件匹配右表，没有匹配到的用null填充，可以简写成left join</li>
<li>右匹配连接，同上</li>
</ol>
</blockquote>
<p><strong>联合查询（uninon 与 union all）</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> a <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> b <span class="keyword">union</span> 。。。</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>就是把多个结果集集中在一起，union前的结果为准，联合查询的列数要相等，相同的记录行会合并</li>
<li>如果使用union all，不会合并重复的记录行</li>
<li>union效率高于union all </li>
</ol>
</blockquote>
<h2 id="mysql的隔离级别和对应的问题"><a href="#mysql的隔离级别和对应的问题" class="headerlink" title="mysql的隔离级别和对应的问题"></a>mysql的隔离级别和对应的问题</h2><h3 id="Read-Uncomitted（读未提交）"><a href="#Read-Uncomitted（读未提交）" class="headerlink" title="Read Uncomitted（读未提交）"></a>Read Uncomitted（读未提交）</h3><p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结。</p>
<p>本级别很少用于实际应用，因为它的性能也不必其他级别好多事</p>
<p><strong>问题：</strong>脏读：读取未提交的数据</p>
<h3 id="Read-Committed（读已提交）"><a href="#Read-Committed（读已提交）" class="headerlink" title="Read Committed（读已提交）"></a>Read Committed（读已提交）</h3><p>大多数数据库系统的默认隔离级别（但不是mysql默认的）。满足了隔离的简单定义：一个事务只能看见已提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理期间可能会有新的commit，所以同一select 可能返回不同结果。</p>
<h3 id="Repeatable-Read（可重复读-默认级别）"><a href="#Repeatable-Read（可重复读-默认级别）" class="headerlink" title="Repeatable Read（可重复读-默认级别）"></a>Repeatable Read（可重复读-默认级别）</h3><p>这是mysql默认的事务隔离界别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。</p>
<p>不过理论上会导致另一个棘手的问题：幻读（Phantom Read）。简单的说，幻读指当前用户读取某一范围的数据行是，另一个书屋又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有心的“幻影”行。InnoDB和Falcon存储引擎通过多版本并发控制（mvcc）机制解决了该问题</p>
<h3 id="Serializable（可串行化）"><a href="#Serializable（可串行化）" class="headerlink" title="Serializable（可串行化）"></a>Serializable（可串行化）</h3><p>这是最高的隔离级别，通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，就是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。这四种隔离界别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：</p>
<ul>
<li><p>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p>
</li>
<li><p>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p>
</li>
<li><p>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就有几列数据是未查询出来的，如果此时插入和另外一个事务插入的数据，就会报错。</p>
</li>
</ul>
<h2 id="在数据库中如何优化？"><a href="#在数据库中如何优化？" class="headerlink" title="在数据库中如何优化？"></a>在数据库中如何优化？</h2><ul>
<li>对查询进行优化，尽量避免全表扫描，首先应考虑在where 及order by 涉及的列上建立索引</li>
<li>应尽量避免在where 字句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描</li>
<li>应尽量避免在where字句中使用！=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</li>
<li>应尽量避免在where字句中使用or来连接条件，如果一个字段有索引，一个字段没有索引，将导致全表扫描</li>
<li>in 和 not in 也要慎用，否则会导致全表扫描</li>
<li>like 模糊全匹配也将导致全表扫描</li>
</ul>
<h2 id="mysql的基础架构，画一下图"><a href="#mysql的基础架构，画一下图" class="headerlink" title="mysql的基础架构，画一下图"></a>mysql的基础架构，画一下图</h2><img src="img/面试准备.assets/image-20200306143322654.png" alt="image-20200306143322654" style="zoom:50%;" />

<h2 id="连接器是啥？"><a href="#连接器是啥？" class="headerlink" title="连接器是啥？"></a>连接器是啥？</h2><p>我们要查询db，第一步就是去连接db，这个连接器就是db跟我们对接的。</p>
<p>他负责跟客户端建立连接、获取权限、维持、管理连接</p>
<p>连接的时候回经过tcp握手，然后身份验证，然后输入账号密码就好了</p>
<p>验证ok后，我们就脸上mysql这个服务器了，但是这个时候处于空闲状态</p>
<h2 id="怎么查看空闲连接列表？"><a href="#怎么查看空闲连接列表？" class="headerlink" title="怎么查看空闲连接列表？"></a>怎么查看空闲连接列表？</h2><p><strong>show processList</strong></p>
<img src="img/面试准备.assets/image-20200306143801319.png" alt="image-20200306143801319" style="zoom:50%;" />

<p>其中Command列显示为<strong>sleep</strong>的这一行，就表示系统里面有一个空闲连接</p>
<p>如果数据库的客户端太久没有相应，连接器就自动断开了，这个时间参数是<strong>wait_timeout</strong>控制住的，默认时长是8小时。超时之后可以重新连接</p>
<h3 id="除了重新连接，还有其他方法吗？"><a href="#除了重新连接，还有其他方法吗？" class="headerlink" title="除了重新连接，还有其他方法吗？"></a>除了重新连接，还有其他方法吗？</h3><p>使用长连接</p>
<p>但是优缺点：长连接后，内存飙升很快，我们知道mysql在执行过程中临时使用的内存是管理在连接对象里面的。只有在断开连接的时候才能得到释放，如果长连接，这一部分内存就得不到释放，就oom了，在jvm里面就频繁fgc</p>
<h2 id="mysql缓存"><a href="#mysql缓存" class="headerlink" title="mysql缓存"></a>mysql缓存</h2><p>mysql拿到一个查询请求之后，会先到缓存里面查询看看，之前是否执行过这条</p>
<p>如果同一条语句执行两次，第一次明显比后面的慢，这就是因为缓存的存在</p>
<p>跟redis类似，只要你之前执行过的语句，都会在内存里面用key-value形式存储着</p>
<h3 id="为什么缓存弊大于利"><a href="#为什么缓存弊大于利" class="headerlink" title="为什么缓存弊大于利"></a>为什么缓存弊大于利</h3><p>缓存很容易失效，只要对表有任何的更新，这个表的所有查询缓存都会被清空，出现：缓存还没使用就被清空。</p>
<p>只有类似于配置表这种的，适用缓存</p>
<h3 id="查询的时候不想用缓存、想用缓存该如何操作？"><a href="#查询的时候不想用缓存、想用缓存该如何操作？" class="headerlink" title="查询的时候不想用缓存、想用缓存该如何操作？"></a>查询的时候不想用缓存、想用缓存该如何操作？</h3><p>可以显示调用，把query_cache_type设置成DEMAND，这样sql默认不适用缓存，想用缓存就用sql_cache。</p>
<p>缓存在mysql 8.0之后就取消了</p>
<h3 id="缓存查询完了，应该做啥呢？"><a href="#缓存查询完了，应该做啥呢？" class="headerlink" title="缓存查询完了，应该做啥呢？"></a>缓存查询完了，应该做啥呢？</h3><p>缓存没有命中的情况下，开始执行语句了，你写的sql有没有语法错误，这是接下来比较关心的点。</p>
<p>他会先<strong>词法分析</strong>，一条sql那么多单词，要识别每个字符代表的是什么？表名？列名？关键字？</p>
<p>然后开始<strong>语法分析</strong>，根据此法分析的结果，语法分析会判断你sql的对错，错了会提示你哪里错了</p>
<p>下一步：<strong>优化器</strong></p>
<p>主要优化什么：我们的表可能会建立很多索引，优化的有一步就是要确认使用哪个索引、执行顺序进行优化，条件那么多、先查哪个表，还是县关联？</p>
<p>最后就是执行了，交给 <strong>执行器</strong>去做</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h3 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a>什么是线程池？</h3><p>线程池的基本思想是对象池，在程序启动时就开辟一块内存空间，里面存放了众多（未死亡的）的线程，池中的线程执行调度由池管理器来处理，当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象带来的性能开销，节省了系统的资源</p>
<h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><blockquote>
<ol>
<li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用</li>
<li>运行线程池能有效的控制线程最大并发数，可以根据系统的承受能力</li>
<li>对线程进行一些简单的管理：比如：延迟执行、定时循环执行的策略等，运用线程池都能进行很好的实现</li>
</ol>
</blockquote>
<h3 id="线程池的主要组件"><a href="#线程池的主要组件" class="headerlink" title="线程池的主要组件"></a>线程池的主要组件</h3><p><img src="img/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.assets/image-20200214150028794.png" alt="image-20200214150028794"></p>
<p>一个线程池包括以下四个基本组成部分</p>
<blockquote>
<ol>
<li>线程池管理器（ThreadPool）:用于创建并管理线程池，创建、销毁线程池，添加新任务；</li>
<li>工作线程（WorkThread）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务</li>
<li>任务接口（Task）：每个任务都必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等。</li>
<li>任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。</li>
</ol>
</blockquote>
<h3 id="ThreadPoolExecutor类"><a href="#ThreadPoolExecutor类" class="headerlink" title="ThreadPoolExecutor类"></a>ThreadPoolExecutor类</h3><p>这个类的线程池中最核心的一个类</p>
<p><strong>线程池的主要处理流程</strong></p>
<blockquote>
<ol>
<li>线程数量未达到corePoolSize，则新建一个新城（核心线程）执行任务</li>
<li>线程数量达到了corePools，则将任务移入队列等待</li>
<li>队列已满，新建线程（非核心线程）执行任务</li>
<li>队列已满，总线程数又达到了maxImumPoolSize，就会抛出异常</li>
</ol>
</blockquote>
<p><strong>四中拒绝策略</strong></p>
<blockquote>
<ol>
<li>AbortPolicy：不执行新任务，直接抛出异常，提示线程池已满，线程池默认策略</li>
<li>DIscardPolicy：不执行新任务，也不抛出异常，基本上为静默模式</li>
<li>DIsCardOldSetPolicy：将消息队列中的一个任务替换为当前新进来的任务执行</li>
<li>CallerRunPolicy：用于被拒绝任务的处理程序，它直接在execute方法的调用线程中被拒绝的任务；如果执行程序已关闭，则会丢弃该任务。</li>
</ol>
</blockquote>
<h3 id="5-5-java通过Executors提供四种线程池"><a href="#5-5-java通过Executors提供四种线程池" class="headerlink" title="5.5 java通过Executors提供四种线程池"></a>5.5 java通过Executors提供四种线程池</h3><ol>
<li><p>CacheThreadPool：可缓存线程池</p>
<blockquote>
<ul>
<li>线程数无限制</li>
<li>有空闲线程则复用空闲线程，若没有则新建线程，一定程度减少频繁创建、销毁线程，减少系统开销</li>
</ul>
</blockquote>
</li>
<li><p>FixedThreadPool（）：定长线程池</p>
<blockquote>
<ul>
<li>可控制线程最大并发数（同时执行的线程数）</li>
<li>超出的线程会在队列中等待</li>
</ul>
</blockquote>
</li>
<li><p>ScheduledThreadPool</p>
<blockquote>
<ul>
<li>定时线程池</li>
<li>支持定时及周期性任务执行。</li>
</ul>
</blockquote>
</li>
<li><p>SingleThreadExecutor：单线程化的线程池</p>
<blockquote>
<ul>
<li>有且仅有一个工作线程任务</li>
<li>所有任务按照指定顺序执行，即遵循队列的入队出队规则</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="5-6-线程池参数设置"><a href="#5-6-线程池参数设置" class="headerlink" title="5.6 线程池参数设置"></a>5.6 线程池参数设置</h3><p>参数的设置跟系统的负载有直接关系，下面为系统负载的相关参数：</p>
<ul>
<li>tasks，每秒需要处理的任务数（针对系统需求）</li>
<li>threadtasks，每个线程每秒可处理任务数（针对线程本身）</li>
<li>responsetime，系统允许任务最大的响应时间，比如每个任务的响应时间不得超过2秒</li>
</ul>
<p><strong>corePoolSize</strong></p>
<p>系统每秒有tasks个任务需要处理理，则每个线程每钞可处理threadtasks个任务。，则需要的线程数为：tasks/threadtasks，即tasks/threadtasks个线程数。</p>
<p>假设系统每秒任务数为100 ~ 1000，每个线程每钞可处理10个任务，则需要100 / 10至1000 / 10，即10 ~ 100个线程。那么corePoolSize应该设置为大于10，具体数字最好根据8020原则，因为系统每秒任务数为100 ~ 1000，即80%情况下系统每秒任务数小于1000 * 20% = 200，则corePoolSize可设置为200 / 10 = 20。</p>
<p><strong>queueCapacity</strong></p>
<p>任务队列的长度要根据核心线程数，以及系统对任务响应时间的要求有关。队列长度可以设置为 所有核心线程每秒处理任务数 * 每个任务响应时间 = 每秒任务总响应时间 ，即(corePoolSize<em>threadtasks)</em>responsetime： (20<em>10)</em>2=400，即队列长度可设置为400。</p>
<p><strong>maxPoolSize</strong></p>
<p>当系统负载达到最大值时，核心线程数已无法按时处理完所有任务，这时就需要增加线程。每秒200个任务需要20个线程，那么当每秒达到1000个任务时，则需要（tasks - queueCapacity）/ threadtasks 即(1000-400)/10，即60个线程，可将maxPoolSize设置为60。</p>
<p>队列长度设置过大，会导致任务响应时间过长，切忌以下写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LinkedBlockingQueue queue &#x3D; new LinkedBlockingQueue();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这实际上是将队列长度设置为Integer.MAX_VALUE，将会导致线程数量永远为corePoolSize，再也不会增加，当任务数量陡增时，任务响应时间也将随之陡增。</p>
<p><strong>keepAliveTime</strong></p>
<p>当负载降低时，可减少线程数量，当线程的空闲时间超过keepAliveTime，会自动释放线程资源。默认情况下线程池停止多余的线程并最少会保持corePoolSize个线程。</p>
<p><strong>allowCoreThreadTimeout</strong></p>
<p>默认情况下核心线程不会退出，可通过将该参数设置为true，让核心线程也退出。</p>
<h3 id="5-7-线程池的五种状态"><a href="#5-7-线程池的五种状态" class="headerlink" title="5.7 线程池的五种状态"></a>5.7 线程池的五种状态</h3><ol>
<li><p>线程池的初始化状态running，能够接受新任务，以及对已添加的任务进行处理。</p>
</li>
<li><p>线程池出在shutdown状态时，不接受新任务，但能处理已添加的任务。调用线程池的shutdown（）接口时，线程池由running-&gt;shutdown</p>
</li>
<li><p>线程池出在stop状态时，不接受新任务，不处理已添加的任务，并且会终端正在处理的任务。调用线程池的shutdownNow（）接口时，线程池由（running or shutdown） -&gt;stop。</p>
</li>
<li><p>当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。</p>
</li>
<li><p>当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。</p>
</li>
<li><p>当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。 线程池彻底终止，就变成TERMINATED状态。线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。</p>
</li>
</ol>
<h3 id="5-8-关闭线程池"><a href="#5-8-关闭线程池" class="headerlink" title="5.8 关闭线程池"></a>5.8 关闭线程池</h3><p>线程池提供两种关闭方法：shutDown()和shutDownNow()</p>
<p><strong>shutDown()</strong></p>
<p>当线程池调用该方法时，线程池的状态则like变成shutdown状态，此时，则不能再往线程池中添加任何任务，否则将会抛出异常；但是，此时线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出</p>
<p><strong>shutdownNow（）</strong></p>
<p>执行该方法，线程池的状态立刻变成STOP状态，并试图停止所有正在执行的线程，不再处理线程池中等待的任务，当然，会返回那些未执行的任务；不代表立刻就能退出，可能要等待所有正在执行的任务都执行完才能退出</p>
<h3 id="5-9-各种场景下怎么设置线程数"><a href="#5-9-各种场景下怎么设置线程数" class="headerlink" title="5.9 各种场景下怎么设置线程数"></a>5.9 各种场景下怎么设置线程数</h3><p><strong>高并发、任务执行时间短的业务</strong></p>
<blockquote>
<p>线程池线程数可以设置为cpu核心数+1，减少线程上下文的切换</p>
</blockquote>
<p><strong>并发不高、任务执行时间长的业务</strong></p>
<blockquote>
<p>这个需要判断执行时间是耗在那个地方了？</p>
<ul>
<li>io操作耗时，也就是io密集型的任务，因为io操作并不占用cpu，所有不要让所有的cpu闲下来，可以适当加大线程池中的线程数目（cpu核心数*2），让cpu处理更多的业务</li>
<li>计算操作耗时，也就是cpu密集型任务，那么久设置cpu核心数+1，线程数设置的少一些，减少线程上下文的切换。</li>
</ul>
</blockquote>
<p><strong>并发高、业务执行时间长的业务</strong></p>
<blockquote>
<p>解决这种类型任务的关键不在于线程池，而在于整体架构的设计</p>
</blockquote>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="五个状态"><a href="#五个状态" class="headerlink" title="五个状态"></a>五个状态</h2><h3 id="new（新建）"><a href="#new（新建）" class="headerlink" title="new（新建）"></a>new（新建）</h3><h3 id="Runnable（就绪）"><a href="#Runnable（就绪）" class="headerlink" title="Runnable（就绪）"></a>Runnable（就绪）</h3><h3 id="Running（运行）"><a href="#Running（运行）" class="headerlink" title="Running（运行）"></a>Running（运行）</h3><h3 id="Blocked（阻塞）"><a href="#Blocked（阻塞）" class="headerlink" title="Blocked（阻塞）"></a>Blocked（阻塞）</h3><h3 id="死亡"><a href="#死亡" class="headerlink" title="死亡"></a>死亡</h3><h2 id="线程的创建方式到底有几种"><a href="#线程的创建方式到底有几种" class="headerlink" title="线程的创建方式到底有几种"></a><strong>线程的创建方式到底有几种</strong></h2><blockquote>
<ol>
<li><p>声明为Thread的子类，并重写run方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" Thread running..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现Runnable接口</p>
<p>Runnable的优点：</p>
<p>业务代码与线程类创建启动等逻辑解耦</p>
<p>Runnable可以复用，Thread则需要每次创建</p>
<p>类可以实现多个接口，而不可以继承多个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" Runnable running..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有点</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>归根结底</strong></p>
<p>创建线程只有一种方式，就是创建Thread对象，而构建一个线程的方式有多重，比如：创建线程类，实现Runnable接口，创建线程池，FutureTask等等</p>
<ol start="3">
<li><p>线程池创建线程：实际是由默认的工厂代为创建Thread类来实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Executors中的DefaultThreadFactory </span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        DefaultThreadFactory() &#123;</span><br><span class="line">            SecurityManager s = System.getSecurityManager();</span><br><span class="line">            group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                                  Thread.currentThread().getThreadGroup();</span><br><span class="line">            namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">                          poolNumber.getAndIncrement() +</span><br><span class="line">                         <span class="string">"-thread-"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                                  namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                  <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">                t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//由上newThread()方法可知，即使是线程池，本质上还是使用Thread的创建线程。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Callable和FutureTask创建线程，本质其实也是Thread</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时器Timer：它的TimerTask其实也是实现了Runnable接口，可以看下TimerTask这个抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        <span class="comment">// 每隔1s打印下自己的名字</span></span><br><span class="line">        timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" timer running..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p><strong>线程和进程的区别</strong></p>
<blockquote>
<p>线程是进程的子集，一个进程可以有多个线程；</p>
<p>不同的进程使用不同的内存空间，所有单线程共享一片相同的内存空间</p>
</blockquote>
<p><strong>用Runnable还是Thread</strong></p>
<blockquote>
<p>推荐用Runnable，因为可以继承多个接口</p>
</blockquote>
<p><strong>Thread类中的start()和run()方法有什么区别？</strong></p>
<blockquote>
<p>start()被用来启动新创建的线程，而且<strong>start()</strong>内部调用了run()方法；</p>
<p><strong>run()</strong>,只会在原来的线程中调用，没有新的线程启动</p>
</blockquote>
<p><strong>Runnable和Callable有什么不同</strong></p>
<blockquote>
<p>都代表那些要在不同的线程中执行的任务。Runnable从1.0开始就有了，Callable在1.5增加的；</p>
<p>Callable的call()方法可以返回值和抛出异常</p>
</blockquote>
<h2 id="乐观锁、悲观锁"><a href="#乐观锁、悲观锁" class="headerlink" title="乐观锁、悲观锁"></a>乐观锁、悲观锁</h2><p>简单说说乐观锁、悲观锁，他们对应的实现cas、Synchronized、ReentrantLock</p>
<p>锁只能升级，不能降级</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><h4 id="说一说cas"><a href="#说一说cas" class="headerlink" title="说一说cas"></a>说一说cas</h4><p>Compare and Swap 比较并且替换，是乐观锁的一种实现方式，是一种轻量级锁，juc中很多工具类的实现是基于cas的</p>
<h4 id="cas是怎么实现线程安全的？"><a href="#cas是怎么实现线程安全的？" class="headerlink" title="cas是怎么实现线程安全的？"></a>cas是怎么实现线程安全的？</h4><p>线程在读取数据时不进行加锁，在准备写回数据时，先去查询原值，操作的时候比较原值是否修改，若未被其他线程修改则写回，若已修改，则重新执行读取流程，无法处理aba问题</p>
<p>cas操作长时间不成功的话，会导致一直自旋，相当于死循环了，cpu压力很大</p>
<h4 id="乐观锁在项目中的实践？"><a href="#乐观锁在项目中的实践？" class="headerlink" title="乐观锁在项目中的实践？"></a>乐观锁在项目中的实践？</h4><p>比如订单表，比如流水表，为了防止并发安问题，就会加入cas的校验过程，保证线程安全，但并不是所有场景都适用的。</p>
<h4 id="cas性能很好，但是Synchronized性能不咋地，为啥1-8之后反而多了Synchronized？"><a href="#cas性能很好，但是Synchronized性能不咋地，为啥1-8之后反而多了Synchronized？" class="headerlink" title="cas性能很好，但是Synchronized性能不咋地，为啥1.8之后反而多了Synchronized？"></a><strong>cas性能很好，但是Synchronized性能不咋地，为啥1.8之后反而多了Synchronized？</strong></h4><p>synchronized之前一直都是重量级的锁，但是后来java官方对他进行过升级 的，他现在采用的是锁升级的方式去做的。</p>
<p>针对synchronized获取锁的方式，jvm使用了锁升级的优化方式，就是先使用偏向锁优先同一进程然后再次获取锁，如果失败，就升级为cas轻量级锁，如果失败就会端在自旋，防止线程被系统挂起，最后如果以上都失败就升级为重量级锁；所有是一步步升级上去的，一开始也是通过很多轻量级的方式锁定的</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>什么是悲观锁，悲观锁，就是默认你每次都是渣男，每次都要提防着你是的</p>
<h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>无论是修饰方法还是代码块，都是通过持有修饰对象的锁来实现同步</p>
<h5 id="是如何保证同一时刻只有一个线程可以进入临界区呢？"><a href="#是如何保证同一时刻只有一个线程可以进入临界区呢？" class="headerlink" title="是如何保证同一时刻只有一个线程可以进入临界区呢？"></a>是如何保证同一时刻只有一个线程可以进入临界区呢？</h5><p>jvm层面的synchronized加锁，是最常见的线程同步收之一</p>
<p>synchronized，代表这个方法加锁，相当于不管哪一个线程（比如线程A），运行到这个方法的时候，都要检查有没有其他线程B（或者c、d）正在用这个方法（或者该类方法啊其他同步方法），有的话要等他运行完之后，再运行，没有的话，锁定调用这，然后直接运行。</p>
<p>分别从他对对象、方法、代码块三方面加锁，去介绍怎么保证线程安全的</p>
<p><strong>同步方法</strong>和<strong>同步代码块</strong>底层都是通过monitor来实现同步的</p>
<h6 id="对象加锁"><a href="#对象加锁" class="headerlink" title="对象加锁"></a>对象加锁</h6><p>在jvm中，对象在内存中分为三块区域：对象头（header）、实例数据(Instance data)、对齐填充（padding）</p>
<p><strong>对象头</strong></p>
<p>以hotpot虚拟机为例，对象头主要包括两部分数据：mark word（标记字段）、klass pointer(类型指针)</p>
<ul>
<li><strong>mark word</strong>：默认存储对象的hashcode，分代年龄和锁标志位信息。它会根据对象的状态复制自己的存储空间，也就是说：在运行期间mark word里面存储的数据会随着锁标志位的变化而变化</li>
<li><strong>klass point</strong> ：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li>
</ul>
<img src="img/面试准备.assets/image-20200306165448996.png" alt="image-20200306165448996" style="zoom:33%;" />

<p>可以看到对象头保存了锁标志位和指向monitor对象的起始地址，如图所示，右侧就是对象对应的monitor对象</p>
<p>当monitor被某个线程持有后，就会处于锁定状态，如同种的 <strong>Owner</strong>部分，会指向持有monitor 对象的进程</p>
<p>另外 Monitor中海油两个队列分别是 EntryList和waitList，主要是用来存放进入及等待获取锁的线程，如果线程进入，则得到当前对象锁，那么别的线程在该类所有对象上的任何操作都不能进行</p>
<p><strong>如果一个对象有多个资源，就不需要将整个对象加锁</strong></p>
<p>由于每个对象都有锁，可以使用虚拟对象来上锁 Synchronized（new obj）</p>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>在介绍ReentrantLock之前，先介绍AQS（AbstractQueuedSynchronizer）</p>
<p>AQS：队列同步器，是实现ReentrantLock的基础</p>
<p>AQS有一个state标记位，值为1时表示有线程占用，其他线程需要进入到同步队列等待，同步队列是一个双向链表</p>
<h2 id="什么是aba"><a href="#什么是aba" class="headerlink" title="什么是aba"></a>什么是aba</h2><p><strong>什么是ABA</strong></p>
<p>就是一个线程把值改成了b，又一个线程把值改回了a，对于当前线程来说，发现他的值还是a，所有就不知道这个值到底有没有被人修改过，如果只追求最后结果正确，这是没关系的</p>
<p>但实际过程中还是需要记录修改过程的，比如资金修改什么的，你每次修改的都应该有记录，方便回溯</p>
<h3 id="如果和解决ABA问题？"><a href="#如果和解决ABA问题？" class="headerlink" title="如果和解决ABA问题？"></a><strong>如果和解决ABA问题？</strong></h3><p>用版本号去保证就好， 比如说，我在修改前去查询他原来的值的时候再带一个版本号，每次判断就连值和版本号一起判断，判断成功就给版本号+1，伪代码如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> a <span class="keyword">set</span> <span class="keyword">value</span> = newValue ，vision = vision + <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">value</span> = <span class="comment">#&#123;oldValue&#125; and vision = #&#123;vision&#125; // 判断原来的值和版本号是否匹配，中间有别的线程修改，值可能相等，但是版本号100%不一样</span></span><br></pre></td></tr></table></figure>

<h3 id="除了版本号还有别的方法保证吗"><a href="#除了版本号还有别的方法保证吗" class="headerlink" title="除了版本号还有别的方法保证吗"></a><strong>除了版本号还有别的方法保证吗</strong></h3><p>比如时间戳也可以，查询的时候把时间戳一起查询出来，对的上才修改并且更新值的时候一起修改更新时间，方法很多，都是跟版本号异曲同工</p>
<h1 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h1><h3 id="6-1-1成员变量"><a href="#6-1-1成员变量" class="headerlink" title="6.1.1成员变量"></a>6.1.1成员变量</h3><p><strong>1。集合的初始化容量（必须是2的n次幂）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure>

<p>HashMap构造方法可以指定集合的初始化容量大小：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hash(<span class="keyword">int</span> 初始大小) <span class="comment">//构造一个带指定初始容量和默认加载因子（0.75）的空HashMap</span></span><br></pre></td></tr></table></figure>

<p>由此可见，当想HashMap中添加一个元素的时候，需要根据key的hash值，去确定其在数组中的具体位置。HashMap为了存取高效，要尽量减少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就是把数据存储到哪个链表中的算法</p>
<p>这个算法实际就是取模，hash%length，计算机中直接求余效率远不如位运算。所有源码中做了优化，使用hash&amp;（length-1），而实际上hash%length等于hash&amp;（length-1）的前提是lengtn是2的n次幂。</p>
<p>hash&amp;（length-1）是计算数组的索引的</p>
<p><strong>为什么是2的n次幂</strong></p>
<blockquote>
<p>答：减少hash冲突，提高性能</p>
</blockquote>
<p><strong>如果不是2的n次幂会怎么样？比如如果是9？</strong></p>
<blockquote>
<p>答：会通过无符号右移 按位或运算变为比指定容量大的最小的2的n次幂</p>
</blockquote>
<p><strong>2。默认的负载因子，默认值是0.75</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>

<p>达到这个之后，会扩容，rehash</p>
<p><strong>3。集合最大容量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;<span class="comment">//集合最大容量的上线是2的30次幂</span></span><br></pre></td></tr></table></figure>

<p> <strong>4。当链表的值超过8则会转红黑树（1.8新增）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>链表中节点的分布符合泊松分布，也就是说转变为红黑树的概率非常小</p>
<p><strong>5。当链表的长度小于6则会从红黑树转回链表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p><strong>6。当map里面的数量超过这个值时，表中的桶才会树化，否则桶内元素太多时会扩容，而不是树化沦为了避免进行扩容、树化选择的冲突，这个值不能小于4*TREEIFY_THRESHOLD（8）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;<span class="comment">//桶中结构转化为红黑树时对应数组长度最小的值</span></span><br></pre></td></tr></table></figure>

<p><strong>7。table用来初始化（必须是2的n次幂）（★★★★）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table	;</span><br></pre></td></tr></table></figure>

<p>table在jdk1.8中是由数组+链表+红黑树来组成的结构其中table就是hashMap中的数组，jdk8之前的数组类型是Entry&lt;K,V&gt;类型，jdk8之后就是Node&lt;K,V&gt;类型。只是换了个名字，都实现了一样的接口：Map.Entry&lt;K,V&gt;。负责存储键值对数据的</p>
<p><strong>8。HashMap中存放元素的个数（★★★★）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存放元素的个数，注意这个不等于数组的长度</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<p>size为HashMap中k-v的实时数量，不是数组table的长度。</p>
<p>9。用来记录hashMap的修改次数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;<span class="comment">//每次扩容和更改map结构的计数器</span></span><br></pre></td></tr></table></figure>

<p>10。用来调整大小下一个容量的值计算方式（容量*负载因子）（边界值）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure>

<p><strong>11。哈希表的加载因子（★★★★）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<p>问题1：为什么架子啊因子设置是<strong>0.75</strong>，为什么不是是0.5呢？</p>
<p>考虑到hash冲突的问题，</p>
<h3 id="6-1-2构造方法"><a href="#6-1-2构造方法" class="headerlink" title="6.1.2构造方法"></a>6.1.2构造方法</h3><p>HashMap中重要的构造方法，他们分别如下：</p>
<p>1.构造一个空的hashMap，默认初始容量（16）和默认负载因子（0.75）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br></pre></td></tr></table></figure>

<p>2.构造一个具有指定出事容量和默认负载因子的HashMap（0.75）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>3.构造一个具有指定的初始容量和负载因子的HashMap（★★★★★）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 边界值，决定是否扩容，不是数组长度</span></span><br><span class="line">  	<span class="comment">//tableSizeFor(initialCapacity); 判断指定的初始容量是否是2的n次幂，如果不是，就会变成比初始容量大的最小的2的n次幂</span></span><br><span class="line">  	<span class="comment">//  注意，jdk1.8以后的构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推迟到了put方法中，在put方法中会对threshold重新计算</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-3-成员方法"><a href="#6-1-3-成员方法" class="headerlink" title="6.1.3 成员方法"></a>6.1.3 成员方法</h3><p><strong>增加方法</strong></p>
<p>put方法是比较复杂的，实现步骤大致如下：</p>
<ol>
<li>先通过hash值计算出key映射到哪个桶（就是数组）</li>
<li>如果桶上没有碰撞冲突，则直接插入 </li>
<li>如果出现碰撞冲突，则需要处理冲突<ol>
<li>如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据</li>
<li>否则采用传统的链式方法插入，如果链的长度达到临界值，则把链表转化为红黑树</li>
</ol>
</li>
<li>如果同种存在重复的键，则为该键替换为新值value；</li>
<li>如果size大于阈值threshold，则进行扩容</li>
</ol>
<p>具体的方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将链表转为红黑树</strong></p>
<p><strong>扩容方法 resize</strong></p>
<ol>
<li><p>什么时候才需要扩容？</p>
<blockquote>
<p>第一次是在putVal的时候扩容</p>
<p>补充：当HashMap中的其中一个链表的对象个数如果达到8个，此时如果数组长度没有达到64，那么HashMap会先扩容解决，如果已经达到64，那么这个链表会变成红黑树，节点类型由node变为treenode</p>
<p>当然，如果映射关系被移除后，下次执行resize方法时判断树节点个数低于6个，也会再把树转换为链表</p>
</blockquote>
</li>
<li><p>扩容是在做什么？</p>
<p>jdk8之前：</p>
<blockquote>
<p>reHash</p>
<p>创建新的数组</p>
<p>遍历放到新的数组</p>
</blockquote>
<p>jdk8开始：</p>
<blockquote>
<p>扩容避免了reHash，如何避免的呢？不需要重新计算hash；扩容之后要么还是在原来的索引位置，要么就是在（原来的索引位置+旧容量）的索引位置</p>
</blockquote>
</li>
<li><p>HashMap的扩容是什么？</p>
</li>
</ol>
<h2 id="面试题：谈谈你对hashMap的理解"><a href="#面试题：谈谈你对hashMap的理解" class="headerlink" title="面试题：谈谈你对hashMap的理解"></a>面试题：谈谈你对hashMap的理解</h2><p>hashmap是一种存取高效，但是不保证有序的容器。数据结构是<strong>数组+链表+红黑树</strong>，是解决hash冲突的产物，它实现了Map接口，采用kv键值对存储数据，并且实现了浅拷贝和序列化</p>
<p>默认大小是16，阈值是0.75，初始化大小必须是2的幂，最大是2的30次方，数组中存储的链表节点Entry类实现于Map.Entry接口，实现了对节点的通用操作</p>
<p>HashMap提供了四种构造方法，默认构造、指定初始容量构造、指定初始容量和阈值构造、基于Map的构造。虽然是构造方法，但是真正从初始化是在第一次添加操作里面实现的</p>
<p>第一次添加操作时，先判断数组有没有初始化，如果没有则先初始化</p>
<blockquote>
<p>添加操作的流程：</p>
<ol>
<li>先判断是否初始化</li>
<li>再判断传入的key是否为空，为空则保存在table[0]位置</li>
<li>key不为空的就对key进行hash，hash的结果再&amp;数组的长度就得到存储的位置</li>
<li>如果存储位置为空则创建节点，不为空说明存在冲突</li>
<li>解决冲突HashMap会先遍历链表，如果有相同的value就更新旧值，否则构建节点添加到链表头</li>
<li>添加还要先判断存储的节点数量是否达到阈值，达到阈值就要进行扩容</li>
<li>扩容2倍，是新建数组，所以要先转移节点，转移时都重新计算存储位置，可能保持不变，可能为就容量+位置</li>
<li>扩容结束后新插入的元素也得再hash一遍才能插入</li>
</ol>
</blockquote>
<p>获取节点的操作流程：</p>
<blockquote>
<ol>
<li>判断是否为空，为空就去table[0]找值</li>
<li>不为空，也是先hash，&amp;数组长度计算下标位置</li>
<li>遍历找相同的key返回值</li>
</ol>
</blockquote>
<p>HashMap是并发不安全的容器，并发添加操作中会出现丢失更新的问题；因为采用头插法在并发扩容时会产生环形链表的问题，导致cpu达到100%</p>
<p><strong>解决并发问题可以采用</strong></p>
<ul>
<li>java类库提供的Collections工具包下的Collections.synchronizedMap()方法，返回一个线程安全的map</li>
<li>使用并发包下的ConcurrentHashMap。它采用的是分段锁机制实现线程安全</li>
<li>使用HashTable（不推荐）</li>
</ul>
<p><strong>回答顺序：数据结构+继承结构+基本字段+构造方法+添加操作+扩容操作+并发问题+与1.8的区别</strong></p>
<h2 id="知识点扩展"><a href="#知识点扩展" class="headerlink" title="知识点扩展"></a>知识点扩展</h2><h4 id="说说浅拷贝与深拷贝的区别"><a href="#说说浅拷贝与深拷贝的区别" class="headerlink" title="说说浅拷贝与深拷贝的区别"></a><strong>说说浅拷贝与深拷贝的区别</strong></h4><blockquote>
<p><strong>基本数据类型</strong>：直接存储在栈中</p>
<p><strong>引用数据类型</strong>：存储的是该对象在栈中引用，真实数据存放在堆内存里。</p>
<p>这两种都是针对于Object和Array这样的引用类型数据的</p>
<p><strong>浅拷贝</strong>只复制指向某个对象的指针，而不是复制对象本身，新旧对象还是共享同一块内存，拷贝对象的时候只对基本数据类型进行了拷贝，对于引用数据类型只是进行了引用的传递，没有真实的创建一个新的对象。</p>
<p><strong>深拷贝</strong>会创造一个一模一样的对象，新旧对象不共享内存</p>
</blockquote>
<p><strong>Collections.synchronizedMap()和Hashtable的区别</strong></p>
<h4 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a><strong>HashMap和Hashtable的区别</strong></h4><blockquote>
<p>Hashtable是个过时的集合类</p>
<p>两者都实现了map接口，两者介乎等价，除了：Hashtable是synchronized的，这意味着线程安全，多个线程可以共享一个hashtable，java5提供了concurrentHashMap，他是Hashtable的替代，比Hashtable扩展性更好</p>
<table>
<thead>
<tr>
<th></th>
<th>HashMap</th>
<th>Hashtable</th>
</tr>
</thead>
<tbody><tr>
<td>线程是否安全</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>效率</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>null key 和null value</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>底层数据结构</td>
<td>数组+链表+红黑树</td>
<td></td>
</tr>
<tr>
<td>实现方式</td>
<td>继承AbstractMap类</td>
<td>继承了Dictionary类，是jdk1.0添加，好像已经过时了</td>
</tr>
<tr>
<td>初始化容量不同</td>
<td>16</td>
<td>11</td>
</tr>
<tr>
<td>扩容机制不同</td>
<td>翻倍</td>
<td>翻倍+1</td>
</tr>
<tr>
<td>迭代器不同</td>
<td>Iterator是fail-fast的</td>
<td>Enumerator不是fail-fast的</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>快速失败fail-fast是啥？原理是啥</strong></p>
<blockquote>
<p>是java集合中的一种机制，在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception</p>
<p>原理：在遍历的过程中使用一个modCount遍历用来记录内容变化，如果发生变化，他的值就会改变，每当迭代器使用hashNext、next遍历下一个元素之前，都会检测modCount变量</p>
</blockquote>
<p><strong>fail-fast场景？</strong></p>
<blockquote>
<p>java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改，算是一种安全机制吧。</p>
</blockquote>
<p><strong>安全失败 fail-safe</strong></p>
<blockquote>
<p>java.util.concurrent包下的容器都是安全失败的，可以在多线程下并发使用，并发修改。</p>
</blockquote>
<p><strong>Hashtable效率低的原因？</strong></p>
<blockquote>
<p>看过源码，会发现，他对数据的操作都会上锁</p>
</blockquote>
<p><strong>为啥Hashtable不允许键值为null？</strong></p>
<blockquote>
<p>Hashtable在put空值的时候回直接抛异常，HashMap却做了特殊处理</p>
<p>Hashtable使用的是<strong>安全失败机制</strong>，这种机制会使你此次读取到的数据不一定是最新的数据，如果你使用null值，就会使得它无法判断对应的key是不存在还是为空，因为你无法再调用一次contain（key）来对key是否存在进行判断，ConcurrentHashMap同理。</p>
</blockquote>
</blockquote>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="*ConcurrentHashMap *"></a>*<em>ConcurrentHashMap *</em></h1><p>ConcurrentHashMap的数据结构，以及并发度这么高？</p>
<blockquote>
<p>底层基于<strong>数组+链表</strong>组成的，不过在jdk1.7与18中稍有不同</p>
<p><strong>1.7版本</strong></p>
<p>先看1.7 如图所示：是有segment数组、HashEntry组成，和HashMap一样，仍然是<strong>数组+链表</strong></p>
<p>HashEntry跟HashMap差不多，不同的是，他使用了<strong>volatile修饰他的value还有next</strong>。</p>
<p>ConcurrentHashMap采用了分段锁，其中Segment继承于ReentrantLock。不会像Hashtable那样不管是put还是get操作都需要做同步处理，理论上他支持Segment数量的并发。</p>
<p>每当一个线程占用锁访问一个Segment时，不会影响到其他的Segment。</p>
<p><strong>put</strong>：第一步的时候回尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则尝试自旋获取锁，如果重试的次数达到了Max_SCAN_RETRIES则改为阻塞锁获取，保证能获取成功</p>
<p><strong>get：</strong>将key通过hash之后定位到具体的Segment，再通过一次Hash定位到具体的元素上。由于HashEntry中的value是volatile的，保证了内存可见性，所有每次获取的都是最新值，整个过程不需要加锁</p>
<blockquote>
<p>虽然1.7支持每个Segment并发访问，但是还是存在一些问题？基本还是数组+链表的方式，查询时候，还得遍历链表，效率低下，跟1.7的HashMap存在一样的问题</p>
</blockquote>
<p><strong>1.8版本</strong></p>
<p>基本抛弃了原有的Segment分段锁，采取了<strong>CAS+Synchronized</strong>来保证并发安全性，跟HashMap很像，也把之前的HashEntry改成了node，但是作用不变</p>
<p><strong>值的存取过程？以及怎么保证线程安全？</strong></p>
<p>put操作还是比较复杂的，大概有一下几个步骤：</p>
<ol>
<li>根据key计算出Hashcode。</li>
<li>判断是否需要进行初始化。</li>
<li>即为当前key定位出的node，如果为空表是当前位置可以写入数据，利用cas尝试写入，失败则自选保证成功。</li>
<li>如果当前位置的hashCode == moved == -1，则需要进行扩容</li>
<li>如果都不满足，则利用synchronized锁写入数据</li>
<li>如果数量大于 <strong>TREEIFY_THRESHOLD</strong>，则要转换为红黑树</li>
</ol>
<p><strong>这里所说的cas是什么？自旋又是什么？</strong></p>
<p>cas是乐观锁的一种实现方式，是一种轻量级锁，juc中很多工具类的实现就是基于cas的</p>
<p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。</p>
<p><strong>cas就一定能保证数据没被别的线程修改过吗？</strong></p>
<p>并不能，比如经典的<strong>ABA</strong>问题，CAS就无法判断了</p>
<p><strong>什么是ABA</strong></p>
<p>就是一个线程把值改成了b，又一个线程把值改回了a，对于当前线程来说，发现他的值还是a，所有就不知道这个值到底有没有被人修改过，如果只追求最后结果正确，这是没关系的</p>
<p>但实际过程中还是需要记录修改过程的，比如资金修改什么的，你每次修改的都应该有记录，方便回溯</p>
<p><strong>如果和解决ABA问题？</strong></p>
<p>用版本号去保证就好， 比如说，我在修改前去查询他原来的值的时候再带一个版本号，每次判断就连值和版本号一起判断，判断成功就给版本号+1，伪代码如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> a <span class="keyword">set</span> <span class="keyword">value</span> = newValue ，vision = vision + <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">value</span> = <span class="comment">#&#123;oldValue&#125; and vision = #&#123;vision&#125; // 判断原来的值和版本号是否匹配，中间有别的线程修改，值可能相等，但是版本号100%不一样</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>除了版本号还有别的方法保证吗</strong></p>
<p>比如时间戳也可以，查询的时候把时间戳一起查询出来，对的上才修改并且更新值的时候一起修改更新时间，方法很多，都是跟版本号异曲同工</p>
<p><strong>cas性能很好，但是Synchronized性能不咋地，为啥1.8之后反而多了Synchronized？</strong></p>
<p>synchronized之前一直都是重量级的锁，但是后来java官方对他进行过升级 的，他现在采用的是锁升级的方式去做的。</p>
<p>针对synchronized获取锁的方式，jvm使用了锁升级的优化方式，就是先使用偏向锁优先同一进程然后再次获取锁，如果失败，就升级为cas轻量级锁，如果失败就会端在自旋，防止线程被系统挂起，最后如果以上都失败就升级为重量级锁；所有是一步步升级上去的，一开始也是通过很多轻量级的方式锁定的</p>
</blockquote>
<blockquote>
<p>先来一张1.7图：</p>
<p><img src="img/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.assets/image-20200217155742981.png" alt="image-20200217155742981"></p>
<p><strong>jdk1.7</strong>从图中可以看出，Hashtable的锁是加在整个表上的，而ConcurrentHashMap是加在segment（每个段上的），这样我们在堆segment1操作的时候，同时也可以对segment2中的数据操作，这样效率会高很多。需要hash两次，第一次Hash定位到segment，第二次Hash定位到元素所在的链表的头部</p>
<p><strong>jdk1.8</strong></p>
<p>jdk8中ConcurrentHashMap参考了jdk8HashMap的实现，采用了数组+链表+红黑树的实现方式来设计，内部大量采用cas操作（CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。）从jdk8来看，它的数据结构已经接近HashMap，只是增加了同步的操作来控制并发</p>
</blockquote>
<h1 id="网络tcp常见面试题"><a href="#网络tcp常见面试题" class="headerlink" title="网络tcp常见面试题"></a>网络tcp常见面试题</h1><h2 id="为什么建立连接是三次握手？"><a href="#为什么建立连接是三次握手？" class="headerlink" title="为什么建立连接是三次握手？"></a>为什么建立连接是三次握手？</h2><p>两个目的：信息对等、防止超时</p>
<p>先从信息对等的角度来看，如下图，双方只有确定四类信息，才能建立连接，第二次握手之后，从b机器的视角看还有两个红色的no是无法确定的，只有在第三次握手之后才能确认完毕</p>
<img src="img/面试准备.assets/image-20200306195733777.png" alt="image-20200306195733777" style="zoom:50%;" />

<p>防止脏数据，ttl网络报文的生存时间往往都会超过tcp请求超时时间，如果两次握手就建立连接，传输数据并释放连接后，第一次超时的请求才到达b机器，b机器会认为是a创建新的连接请求，然后确认统一创建连接，因为a的状态不是xx，所以直接丢了b的确认数据，以至于最后只是b机器单方面的创建连接完毕</p>
<h2 id="tcp断开连接为什么是四次？"><a href="#tcp断开连接为什么是四次？" class="headerlink" title="tcp断开连接为什么是四次？"></a>tcp断开连接为什么是四次？</h2><p><strong>为什么四次？</strong></p>
<blockquote>
<p>确保数据能够完成传输</p>
</blockquote>
<p>第一次:**</p>
<p>A—&gt;B：我要断开连接</p>
<p><strong>第二次：</strong></p>
<p>B—&gt;A：我答应你，但是要等我处理完数据</p>
<p><strong>第三次</strong></p>
<p>B—&gt;A：我处理完了，咱们断开连接把</p>
<p><strong>第四次</strong></p>
<p>A—-&gt;B：我答应你，咱俩掰了</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序经典的呢，叫单轴快排，改进的叫双轴快排</p>
<p>他的排序思想就是：<strong>在数组中选择一个元素作为轴进行排序</strong></p>
<blockquote>
<p>第一次将大于轴的元素放在轴右边，小于轴的元素放在轴左边，这样就完成了第一次排序，然后对轴两边分区选轴进行递归排序，直到只剩下一个元素时返回。</p>
</blockquote>
<p>双轴快排使用到Arrays中是sort方法，所处理的都是基本数据类型</p>
<p>空间复杂度是 ologn，如果不考虑递归的话，可以达到o1 </p>
<h1 id="链表，反转链表"><a href="#链表，反转链表" class="headerlink" title="链表，反转链表"></a>链表，反转链表</h1><h1 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h1><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><strong>volatile</strong></h3><p><strong>可见性</strong>（✅）</p>
<blockquote>
<p>会强制将修改的值写入主内存，并且其他用过的工作内存的值都无效了</p>
</blockquote>
<p><strong>原子性</strong>（❌）</p>
<blockquote>
<p>自增不是原子操作，volatile也无法保证对变量的任何操作都是原子性的</p>
<p>valatile只能保证对单次读、写的原子性</p>
</blockquote>
<p><strong>有序性</strong>（✅❌一定程度）</p>
<blockquote>
<p>volatile禁止指令重排有两层意思：</p>
<ol>
<li>当程序执行到volatile变量的读操作或者写操作时，在他前面的操作肯定已经全部进行，且结果对后面的操作可见；在他后面的操作肯定都还没有执行</li>
<li>在进行指令优化时，不能讲volatile变量访问的语句放在他后面执行，也不能放到前面执行</li>
</ol>
</blockquote>
<p><strong>使用场景</strong></p>
<blockquote>
<p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于他，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile无法保证操作的原子性</p>
<p>使用volatile必须具备以下两个条件（实际就是保证使用场景是原子性操作）</p>
<ol>
<li>对变量的写操作不依赖于当前值</li>
<li>该变量没有包含在具有其他变量的不变式中</li>
</ol>
</blockquote>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h3 id="1、为什么用线程池"><a href="#1、为什么用线程池" class="headerlink" title="1、为什么用线程池"></a>1、为什么用线程池</h3><p>使用线程池主要是为了解决：</p>
<blockquote>
<p>通过重用线程池中的线程，来减少每个线程的创建销毁的性能开销</p>
<p>对线程进行一些维护和管理，比如定时开始，周期执行，并发控制等等</p>
</blockquote>
<p>不要用多线程去治理长连接，肯定是异步的网络模型nio，不在这里多说。</p>
<h3 id="2、线程池参数什么意思？"><a href="#2、线程池参数什么意思？" class="headerlink" title="2、线程池参数什么意思？"></a>2、线程池参数什么意思？</h3><p><strong>corePoolSize</strong></p>
<blockquote>
<p>常驻核心线程数，即本地任务执行完毕，核心线程也不会被销毁</p>
</blockquote>
<p><strong>maximumPoolSize</strong></p>
<blockquote>
<p>线程池最大线程数，必须大于等于1，如果待执行的线程数大于此值，需要借助第五个参数（workQueue）的帮助，缓存在队列中，如果与核心线程数一致的话，即固定了线程池大小</p>
</blockquote>
<p><strong>keepAliveTime</strong></p>
<blockquote>
<p>线程池中的线程空闲时间，当空闲时间达到此值时，线程会被销毁，只剩下核心线程</p>
</blockquote>
<p><strong>TimeUnit</strong></p>
<blockquote>
<p>时间单位，结合上面这个一起用，通常是秒</p>
</blockquote>
<p><strong>workQueue</strong></p>
<blockquote>
<p>表示缓存队列，请求的线程数大于线程池最大线程数时，线程进入BlockingQueue阻塞队列</p>
</blockquote>
<p><strong>threadFactory</strong></p>
<blockquote>
<p>线程工厂，用来生产一组相同任务的线程，线程池的命名就是通过给这个factory增加组名前缀来实现的</p>
</blockquote>
<p><strong>handler</strong></p>
<blockquote>
<p>表示执行拒绝策略的对象，当超过第五个为参数workQueue的任务缓存区上线的时候，就可以通过该策略处理请求，这是一种简单的限流保护</p>
</blockquote>
<h3 id="3、线程池中的threadpoolexecutor，每个参数是干嘛用的？"><a href="#3、线程池中的threadpoolexecutor，每个参数是干嘛用的？" class="headerlink" title="3、线程池中的threadpoolexecutor，每个参数是干嘛用的？"></a>3、线程池中的threadpoolexecutor，每个参数是干嘛用的？</h3><h3 id="4、说一下线程池内部使用规则"><a href="#4、说一下线程池内部使用规则" class="headerlink" title="4、说一下线程池内部使用规则"></a>4、说一下线程池内部使用规则</h3><h3 id="5、用过AtomicInteger吗？怎么用的"><a href="#5、用过AtomicInteger吗？怎么用的" class="headerlink" title="5、用过AtomicInteger吗？怎么用的"></a>5、用过AtomicInteger吗？怎么用的</h3><h3 id="6、用过threadlocal吗？怎么用的"><a href="#6、用过threadlocal吗？怎么用的" class="headerlink" title="6、用过threadlocal吗？怎么用的"></a>6、用过threadlocal吗？怎么用的</h3><h3 id="7、程序、进程、线程的区别？举个现实的例子说明"><a href="#7、程序、进程、线程的区别？举个现实的例子说明" class="headerlink" title="7、程序、进程、线程的区别？举个现实的例子说明"></a>7、程序、进程、线程的区别？举个现实的例子说明</h3><h3 id="8、java中通过哪些方式创建多线程类？分别使用代码说明，并调用之"><a href="#8、java中通过哪些方式创建多线程类？分别使用代码说明，并调用之" class="headerlink" title="8、java中通过哪些方式创建多线程类？分别使用代码说明，并调用之"></a>8、java中通过哪些方式创建多线程类？分别使用代码说明，并调用之</h3><h3 id="9、Thread类有没有实现Runnable接口？"><a href="#9、Thread类有没有实现Runnable接口？" class="headerlink" title="9、Thread类有没有实现Runnable接口？"></a>9、Thread类有没有实现Runnable接口？</h3><h3 id="10、当调用一个线程对象的start方法后，线程马上进入运行"><a href="#10、当调用一个线程对象的start方法后，线程马上进入运行" class="headerlink" title="10、当调用一个线程对象的start方法后，线程马上进入运行"></a>10、当调用一个线程对象的start方法后，线程马上进入运行</h3><h3 id="11、下面的代码，实际上有几个线程在运行"><a href="#11、下面的代码，实际上有几个线程在运行" class="headerlink" title="11、下面的代码，实际上有几个线程在运行"></a>11、下面的代码，实际上有几个线程在运行</h3><h3 id="12、线程的几种状态"><a href="#12、线程的几种状态" class="headerlink" title="12、线程的几种状态"></a>12、线程的几种状态</h3><h3 id="13、说说：sleep、yield、join、wait方法的区别"><a href="#13、说说：sleep、yield、join、wait方法的区别" class="headerlink" title="13、说说：sleep、yield、join、wait方法的区别"></a>13、说说：sleep、yield、join、wait方法的区别</h3><p><strong>join</strong></p>
<blockquote>
<p>谁调用了join，谁就会被阻塞，直到join执行完毕</p>
<p>当先线程等待，调用此方法的线程执行结束再继续执行</p>
<p>比如：在main方法中调用t.join(),那么main会进入阻塞状态，一直等待t线程执行完毕，main方法再恢复到就绪状态，准备继续执行</p>
</blockquote>
<p><strong>sleep</strong></p>
<blockquote>
<p>需要制定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态。</p>
<p>该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。</p>
</blockquote>
<h3 id="14、为什么不推荐使用stop和destory方法来结束线程"><a href="#14、为什么不推荐使用stop和destory方法来结束线程" class="headerlink" title="14、为什么不推荐使用stop和destory方法来结束线程"></a>14、为什么不推荐使用stop和destory方法来结束线程</h3><h3 id="15、写个代码说明，终止线程的典型方式"><a href="#15、写个代码说明，终止线程的典型方式" class="headerlink" title="15、写个代码说明，终止线程的典型方式"></a>15、写个代码说明，终止线程的典型方式</h3><h3 id="16、A线程的优先级是10，b线程的优先级是1，那么当进行调度时一定会调用A吗？"><a href="#16、A线程的优先级是10，b线程的优先级是1，那么当进行调度时一定会调用A吗？" class="headerlink" title="16、A线程的优先级是10，b线程的优先级是1，那么当进行调度时一定会调用A吗？"></a>16、A线程的优先级是10，b线程的优先级是1，那么当进行调度时一定会调用A吗？</h3><h3 id="17、synchronized加在static关键字前和普通方法前的区别？"><a href="#17、synchronized加在static关键字前和普通方法前的区别？" class="headerlink" title="17、synchronized加在static关键字前和普通方法前的区别？"></a>17、synchronized加在static关键字前和普通方法前的区别？</h3><blockquote>
<p>Synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”，不同的对象没有竞争关系</p>
<p>Synchronized修饰static静态方法，实际上是对该类对象加锁，俗称“类锁”，这个类所有的对象竞争一把锁</p>
<p>结论：类锁和对象锁不同，他们之间不会产生互斥。</p>
</blockquote>
<h3 id="18、使用Timer和TimerTask实现定时执行，定时在每天下午17：00执行"><a href="#18、使用Timer和TimerTask实现定时执行，定时在每天下午17：00执行" class="headerlink" title="18、使用Timer和TimerTask实现定时执行，定时在每天下午17：00执行"></a>18、使用Timer和TimerTask实现定时执行，定时在每天下午17：00执行</h3><h3 id="19、wait方法被调用时，所在线程是否会释放所持有的锁资源？sleep方法呢？"><a href="#19、wait方法被调用时，所在线程是否会释放所持有的锁资源？sleep方法呢？" class="headerlink" title="19、wait方法被调用时，所在线程是否会释放所持有的锁资源？sleep方法呢？"></a>19、wait方法被调用时，所在线程是否会释放所持有的锁资源？sleep方法呢？</h3><h3 id="20、wait、notify、notifyAll是在Thread类中定义的方法吗？作用分别是什么？"><a href="#20、wait、notify、notifyAll是在Thread类中定义的方法吗？作用分别是什么？" class="headerlink" title="20、wait、notify、notifyAll是在Thread类中定义的方法吗？作用分别是什么？"></a>20、wait、notify、notifyAll是在Thread类中定义的方法吗？作用分别是什么？</h3><h3 id="21、notify是唤醒所在对象watipool中的一个线程吗？"><a href="#21、notify是唤醒所在对象watipool中的一个线程吗？" class="headerlink" title="21、notify是唤醒所在对象watipool中的一个线程吗？"></a>21、notify是唤醒所在对象watipool中的一个线程吗？</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="java虚拟机"><a href="#java虚拟机" class="headerlink" title="java虚拟机"></a>java虚拟机</h1><h2 id="说一说jvm的内存模型（每一个模块都说）"><a href="#说一说jvm的内存模型（每一个模块都说）" class="headerlink" title="说一说jvm的内存模型（每一个模块都说）"></a>说一说jvm的内存模型（每一个模块都说）</h2><p><strong>方法区（Method Area）</strong></p>
<blockquote>
<p>方法区主要是放一下类似类定义、常量、编译后的代码、静态变量等，在jdk1.7中hotspot vm 的实现就把他放在了永久代中，这样的好处是可以直接使用堆中的gc算法来管理，但坏处就是经常会出现内存溢出。</p>
<p>所以在1.8中，取消了<strong>永久代</strong>，<strong>用元空间取而代之</strong>，元空间直接使用本地内存，perm（永久代）区的字符串常量在堆内存</p>
<p><strong>常量池中的string实际是保存在堆内存中的</strong></p>
</blockquote>
<p><strong>堆（heap）</strong></p>
<blockquote>
<p>oom故障最主要的发源地，几乎存储着所有的实例对象，堆由垃圾收集器自动回收，由各子线程共享使用，通常情况下，堆占用的内存是内存区域中最大的</p>
<p>对的内存空间既可以固定大小，也可以运行时动态调整，但是通常为了避免堆空间的不断扩容与收缩，在线上环境时，jvm最大堆空间和最小堆空间设置成一样，避免gc后调整大小带来的额外压力</p>
<p><strong>新生代：</strong>1个eden区+2个survivor区</p>
<p>绝大部分对象在eden区生成，当eden区满了的时候，会触发young gc。垃圾回收的时候，在eden区实现清除策略，没有被引用的对象则直接回收。依然存活的对象会被已送到Survivor区。</p>
<p>Survivor分为s0 和 s1两块内存空间，那么送到哪块呢？每次ygc的时候，他们将存活的对象复制到未使用的那块空间，然后将当前正在使用的空间完全清除，交换两块空间的使用状态。</p>
<p>如果ygc要移送的对象大于Survivor区容量的上限，则直接移交给老年代。</p>
<p>每个对象都有一个计数器，每次ygc都会加1，-XX：MaxTenuring Threshold参数能配置计数器的值达到某个阈值的时候，对象从新生代晋升至老年代，如果该参数配置为1，那么从新生代的eden区直接移送到年老代。</p>
<p>默认值是15，可以在Survivor区交换14次之后，晋升至老年代。</p>
<p>流程图如下：</p>
<p>![image-20200114135528237](img/尚学堂 java 300 讲.assets/image-20200114135528237.png)</p>
<p>如果Survivor区无法放下，会尝试在老年代中进行分配，如果老年代也放不下，则会触发「fgc」，如果『fgc』后依然放不下，则抛出oom，所以给jvm设置运行参数-XX：+heapDumpOnOutOfMemoryError，让jvm遇到oom异常时能输出堆信息，特别是相隔数月才出现的oom异常尤为重要</p>
</blockquote>
<p><strong>虚拟机栈</strong></p>
<blockquote>
<p>jvm在执行方法时，会在此区域中创建一个栈帧来存放方法的各种信息，比如返回值，局部变量表和各种对象引用等，方法开始执行前就先创建栈帧入栈，执行完后就出栈</p>
<p>只有位于栈顶帧才是有效的， 称为“当前栈”</p>
</blockquote>
<p><strong>本地方法栈</strong></p>
<blockquote>
<p>和虚拟机栈类似，不过是专门给native方法用的</p>
</blockquote>
<p><strong>程序计数器</strong></p>
<blockquote>
<p>占用很小的一块区域，我们知道jvm执行代码是一行一行执行字节码文件，所有需要一个计数器来记录当前执行的行数</p>
</blockquote>
<h2 id="说一说垃圾回收吧？有哪些垃圾回收算法"><a href="#说一说垃圾回收吧？有哪些垃圾回收算法" class="headerlink" title="说一说垃圾回收吧？有哪些垃圾回收算法"></a>说一说垃圾回收吧？有哪些垃圾回收算法</h2><p><strong>标记-清除</strong></p>
<blockquote>
<p>分为两个阶段，标记阶段、清除阶段</p>
<p>在标记阶段，首先通过<strong>根节点</strong>（gc roots）,标记所有从根节点开始的对象，未被标记的对象是未被引用的垃圾对象，然后，在清除阶段，清除所有未被标记的对象</p>
<p><strong>缺点：</strong>会带来大量的空间碎片，在分配一个较大连续空间时容易触发fgc</p>
</blockquote>
<p><strong>标记-整理</strong></p>
<blockquote>
<p>从根集合节点进行扫描，标记出所有的存活对象，并将这些存活的对象整理到内存空间的一端，形成连续的已使用空间，最后把已使用空间之外的部分全部清理掉，这样就不会产生空间碎片</p>
</blockquote>
<p><strong>标记-复制</strong></p>
<blockquote>
<p>为了能够并行的标记和整理，将空间分为了两块，每次只激活其中一块，垃圾回收时只需要把存活的对象复制到另一块未激活的空间上，然后把未激活标记为已激活，把已激活标记未激活，然后清理原空间中的对象</p>
<p><strong>场景：</strong>作为主流的ygc算法进行新生代的垃圾回收</p>
</blockquote>
<p><strong>分代收集算法</strong></p>
<blockquote>
<p>目前虚拟机使用回收算法，解决了标记整理不适合老年代的问题</p>
<p>将内存分为各个年代，一般是来年代，和新生代，永久代（jdk1.8中被元空间替代）</p>
<p>新生代存活率低，可以使用复制算法</p>
<p>老年代对象存活率高，没有额外空间对他进行分配担保，所以只能使用标记清除或者标记整理</p>
</blockquote>
<p><strong>如何判断一个对象是否应该回收</strong></p>
<blockquote>
<p><strong>方法1：引用计数</strong>，该对象每被一个地方引用，计数器就加+1，引用失效时，计数器-1，计数器为0时的对象就不能再被使用</p>
<p>缺点：很难解决循环引用的问题</p>
<p><strong>方法2：可达性分析法</strong>：通过gc  roots作为七点，从这些节点开始，向下搜索，当一个对象到gc roots没有任何引用链，这个对象就是不可用的，至少<strong>两次标记</strong></p>
</blockquote>
<p><strong>什么可以作为GC ROOT呢？</strong></p>
<blockquote>
<p>类静态属性中引用的对象（方法区）</p>
<p>常量引用的的对象（方法区）</p>
<p>虚拟机栈中引用的对象（栈帧中的本地变量表）</p>
<p>jni引用的对象（本地方法栈）</p>
</blockquote>
<p><strong>除了垃圾回收，还有哪些工作会造成cpu负载过高，100%负载，并给出排查过程</strong></p>
<blockquote>
<ol>
<li>使用top命令查找占用cpu高的进程pid</li>
<li>显示线程列表  ps -mp 35867 -o THREAD,tid,time—-找到占用cpu过高的tid</li>
<li>将需要的线程tid转换为16进制    printf “%x\n” 35889</li>
<li>打印线程堆栈信息     jstack 35867 |grep 8c31 -A 30</li>
</ol>
</blockquote>
<p><strong>cms收集器的特点</strong>（标记-清除）</p>
<blockquote>
<p>回收停顿时间比较短，四个步骤完成工作</p>
<ul>
<li>初始标记（只是标记一下gc roots能直接关联到的对象，速度很快）</li>
<li>并发标记（进行gc roots tracing 追踪）</li>
<li>重新标记（为了修正并发标记期间因用户程序持续运行产生变动的那一部分对象的标记记录，比1长，比2短）</li>
<li>并发清除（）</li>
</ul>
<p><strong>缺点</strong></p>
<p>第1、3步需要stw</p>
<p>对cpu资源非常敏感，在并发阶段，虽然不会导致用户线程停顿，但是因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低</p>
<p>因为标记-清除，会产生大量碎片，可以配置参数，强制jvm在fgc后对老年代进行压缩，但是会stw</p>
</blockquote>
<p><strong>G1</strong>★★★★</p>
<blockquote>
<p>四个步骤</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ul>
<p>g1在jdk1.7中是推荐使用，jdk11是默认的</p>
<p>将堆空间分割成若干个大小相同的区域，即region，包括eden、Survivor、old、Humongous四种类型，Humongous是特殊的ol的类型，专门存放大对象，防止了反复拷贝移动</p>
<p>这样的划分方式，意味着不需要一个连续的内存空间管理对象，g1采用的是mark-copy，不产生大量的空间碎片</p>
<p>g1提供两种gc模式，ygc，mixedgc，两种都是stw的</p>
</blockquote>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p><strong>String  a = ‘’abc”； 和 String b = new String（“abc”）；是不是一样的？为什么？他们对应的内存空间分别是什么？</strong></p>
<blockquote>
<p>不一样</p>
<p>String  a = ‘’abc”是在现在栈中创建一个string类的对象引用变量，然后查找栈中有没有存放“abc”，如果没有则将“abc”放入栈，并令a指向abc</p>
<p>new String（abc）是在堆中存放，每次new 都会在堆中存放一个</p>
<p>equals比较值是否相等，==比较地址是否相等</p>
</blockquote>
<h2 id="Object-o-new-Object"><a href="#Object-o-new-Object" class="headerlink" title="Object o = new Object()"></a>Object o = new Object()</h2><p><strong>解释一下对象的创建过程（半初始化）</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T t = <span class="keyword">new</span> T();</span><br></pre></td></tr></table></figure>

<p>编译后的字节码如下</p>
<ol>
<li><p>new</p>
<p>为对象申请了一块内存，m此时是默认值，半初始化</p>
</li>
<li><p>dup</p>
</li>
<li><p>invokespecial #3&lt;T.<init>&gt;</p>
<p>这里才会把m设置为8，第1、3步之间就是半初始化状态</p>
</li>
<li><p>astore_1</p>
</li>
<li><p>return</p>
</li>
</ol>
</blockquote>
<p><strong>dcl单例(Double Check Lock)到底需不需要volatile问题</strong></p>
<blockquote>
<p>上锁前检查一次，上锁后再检查一次，要不要在定义的 时候加个volatile？</p>
<p>阻止对这块内存的访问指令重排序 。需要，出现的几率很小，但是还是需要</p>
<p><img src="img/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.assets/image-20200305221218238.png" alt="image-20200305221218238"></p>
</blockquote>
<p><strong>对象在内存中的存储布局</strong></p>
<p><img src="img/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.assets/image-20200305223356714.png" alt="image-20200305223356714"></p>
<blockquote>
<p><strong>普通对象 new xx()</strong></p>
<ul>
<li>对象头markword </li>
<li>类型指针classpointer：这个类型是什么类型？指向xx.class</li>
<li>实例数据instance data  比如说m=1，对象的数据</li>
<li>对齐padding ，比如最后算出来是30个字节？不是8的倍数怎么办？长成32</li>
</ul>
<p><strong>数组</strong> T[] a = new T[5]</p>
<ul>
<li>对象头</li>
<li>类型指针:数组是什么类型？int？T？</li>
<li>数组长度（length 4字节）</li>
<li>实例数据</li>
<li>对齐</li>
</ul>
</blockquote>
<p><strong>对象头具体包括什么</strong></p>
<blockquote>
<ul>
<li>锁的信息</li>
<li>gc的信息：被回收多少次了</li>
<li>hashCode</li>
</ul>
<p><strong>对象头占用8个字节（64位虚拟机）</strong></p>
<img src="img/面试准备.assets/image-20200305223705998.png" alt="image-20200305223705998" style="zoom:50%;" />

<p>什么时候回产生hashcode？当然是调用未重写的hashcode()方法以及System.identityHashCode的时候</p>
</blockquote>
<p><strong>对象怎么定位</strong></p>
<blockquote>
<img src="img/面试准备.assets/image-20200306114341914.png" alt="image-20200306114341914" style="zoom:50%;" />

<p>直接指针是hotspot使用的方式</p>
<p><strong>句柄方式</strong>：</p>
<p>优点：对象小，垃圾回收时不用频繁改动t</p>
<p>缺点：两次访问</p>
<p><strong>直接指针</strong></p>
</blockquote>
<p><strong>对象怎么分配（栈上-线程本地-eden-old）</strong></p>
<blockquote>
<img src="img/面试准备.assets/image-20200306115136889.png" alt="image-20200306115136889" style="zoom:50%;" />
</blockquote>
<p><strong>该代码在内存中占用多少字节</strong></p>
<blockquote>
<p>要看压不压缩</p>
<p>一个object占多少字节？</p>
<p>16</p>
<p>new int[]{} 是24</p>
</blockquote>
<h1 id="常用框架、技术"><a href="#常用框架、技术" class="headerlink" title="常用框架、技术"></a>常用框架、技术</h1><h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><p>spring框架是一个轻量级的控制反转和面向切面的容器框架</p>
<p><strong>轻量</strong></p>
<blockquote>
<p>从大小到开销来说都是轻量的，spring框架开源字啊一个只有1m大小的jar文件中发布，而且spring所处理的开销也是微不足道的</p>
</blockquote>
<p><strong>非侵入式</strong></p>
<blockquote>
<p>spring应用中的对象不依赖于spring的特定类</p>
</blockquote>
<p><strong>IOC（控制反转）</strong></p>
<blockquote>
<p>一个对象依赖的其他对象会通过被动的方式传递进来，而不是这个对象自己创建或者主动查找依赖对象</p>
</blockquote>
<p><strong>AOP（面向切面）</strong></p>
<blockquote>
<p>只完成业务逻辑，并不负责其他的系统级的关注点</p>
</blockquote>
<p><strong>容器</strong></p>
<blockquote>
<p>定义了bean是如何创建、配置、管理的</p>
</blockquote>
<h3 id="框架模块"><a href="#框架模块" class="headerlink" title="框架模块"></a>框架模块</h3><p>你可以不必将应用完全基于spring，可以自由的挑选适用你的模块，而忽略其余的模块</p>
<h4 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h4><p>这是spring框架最基础的部分，它提供了<strong>依赖注入</strong>特征来实现容器对bean的管理。这里最基本的概念是BeanFactory，它是任何spring应用的核心。BeanFactory是工厂模式的一个实现，他使用ioc将应用配置和依赖说明从实际的应用代码中分离出来</p>
<h4 id="应用上下文（context）模块"><a href="#应用上下文（context）模块" class="headerlink" title="应用上下文（context）模块"></a>应用上下文（context）模块</h4><p>核心模块的beanFactory使spring成为了一个容器，而上下文模块使他成为一个框架，这个模块扩展了BeanFactory的概念，增加了对国际化消息、事件传播以及验证的支持</p>
<p>另外，这个模块提供了许多企业服务，例如电子邮件、JNDI访问、EJB集成、远程以及时序调度（scheduling）服务。也包括了对模版框架例如Velocity和FreeMarker集成的支持。</p>
<h4 id="AOP模块"><a href="#AOP模块" class="headerlink" title="AOP模块"></a>AOP模块</h4><h4 id="JDBC抽象和DAO模块"><a href="#JDBC抽象和DAO模块" class="headerlink" title="JDBC抽象和DAO模块"></a>JDBC抽象和DAO模块</h4><p>使用jdbc经常导致大量的重复代码：连接、创建于巨，处理结果集，关闭链接。</p>
<p>这两个模块抽取了这些重复代码，因此可以保持数据库访问代码干净简洁。</p>
<p>这个模块还使用了<strong>aop模块</strong>为spring应用中的对象提供了事务管理服务</p>
<h4 id="对象-关系映射集成"><a href="#对象-关系映射集成" class="headerlink" title="对象/关系映射集成"></a>对象/关系映射集成</h4><p>orm模块，spring并不试图实现自己的orm解决方案，而是为集中流行orm框架提供了集成方案。</p>
<p>spring的事务管理支持这些orm框架中的每一个也包括jdbc。</p>
<h4 id="WEB-模块"><a href="#WEB-模块" class="headerlink" title="WEB 模块"></a>WEB 模块</h4><p>web上下文模块建立于应用上下文模块之上，提供了一个合适于web应用的上下文。另外，这个模块还提供了一些面向服务支持。例如：实现文件上传的multipart请求，它也提供了spring 和其它web框架的集成，比如Struts、WebWork。</p>
<h4 id="mvc框架"><a href="#mvc框架" class="headerlink" title="mvc框架"></a>mvc框架</h4><p>spring为构建web应用提供了一个功能全面的mvc框架。虽然spring可以很容易的与其它mvc框架集成，例如struts，但spring的mvc框架使用ioc对控制逻辑和业务对象提供了完全的分离。</p>
<h2 id="ioc"><a href="#ioc" class="headerlink" title="ioc"></a>ioc</h2><h2 id="使用到的设计模式"><a href="#使用到的设计模式" class="headerlink" title="使用到的设计模式"></a>使用到的设计模式</h2><p><strong>1.简单工厂模式</strong></p>
<blockquote>
<p>应用场景：又叫静态工厂，不属于23中设计模式。实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类</p>
<p>BeanFactory就是简单工程模式的体现，根据传入一个唯一的标识来获取bean对象</p>
</blockquote>
<p><strong>2.工厂模式</strong></p>
<blockquote>
<p>应用场景：通常由应用程序直接使用new创建新的对象，为了将对象的创建和使用相分离，采用工厂模式，即应用程序将对象的创建及初始化职责交给工厂对象。</p>
<p>一般情况下，应用程序有自己的工厂对象来创建bena，如果将应用程序自己的工程对象交给spring管理，那么spring管理就不是普通bean，而是工程bean</p>
</blockquote>
<p><strong>3.单例模式</strong></p>
<blockquote>
<p>应用场景：保证一个类只有一个实例，并提供一个访问它的全局访问点</p>
<p>spring中的单例模式只完成了后半句，即提供了全局的访问点BeanFactory，但没有从构造器级别去空值单例，这是因为spring管理的是任意的java对象，spring下默认的bean均为单例</p>
</blockquote>
<p><strong>4.原型模式-Prototype</strong></p>
<blockquote>
<p>应用场景：原型模式就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节</p>
<p>所谓原型模式，就是java中的克隆技术，以某个对象为原型，复制出新的对象，显然新的对象具备原型对象的特点，效率噶（避免了重新执行构造过程步骤）</p>
</blockquote>
<p><strong>5.代理模式–Proxy</strong></p>
<blockquote>
<p>应用场景：为其他对象提供一种代理以控制对这个对象的访问。从结构上看和Decorator（装饰器）模式类似，但是proxy是控制，更像是一种对功能的闲置，而Decorator是增加职责。</p>
<p>spring中代理模式体现在aop中，比如cglibAopProxy，和jdkAopProxy</p>
</blockquote>
<p><strong>6.策略模式–Strategy</strong></p>
<blockquote>
<p>应用场景：定义一系列的算法，把它们一个个封装起来，并且使他们可互相替换，最终执行结果是固定的，执行过程和执行逻辑不一样</p>
<p>spring中在实例化对象的时候用到了Strategy模式</p>
</blockquote>
<p><strong>7.模板方法模式–TemplateMethod</strong></p>
<blockquote>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤</p>
<p>TemplateMethod模式一般是需要继承的。执行流程固定，但是中间实现步骤有细微差别</p>
<p>springorm数据类型</p>
</blockquote>
<p><strong>8.委派模式–Delegate</strong></p>
<blockquote>
<p>应用场景：不属于23中设计模式，是面向对象设计模式中常用的一种模式。这种模式的原理为类b和类a是两个没有任何关系的类，b具有和a一模一样的方法和属性；并且调用b中的方法，属性就是调用a中同名的方法和属性，b好像就是一个受a委托授权的终结。第三方的代码不需要指定a的存在，也不需要和a发生直接的联系，通过b就可以直接使用a的功能，这样既能够使用到a的各种功能，又能够很好的将a保护起来，一举两得</p>
<p>要和代理模式区分开来，持有被委托人的引用，不关心过程，只关心结果</p>
<p>DIspatcher</p>
</blockquote>
<p><strong>9.适配器模式–Adapter</strong></p>
<blockquote>
<p>springAOP模块对BeforeAdvice、AfterAdvice、ThrowsAdvice三种通知类型的支持实际上是借助适配器模式来实现的，这样的好处是使得框架允许用户向框架中加入自己想要支持任何一种通知雷丁，这三种通知类型是springAOP模块定义的，他们是AOP联盟定义的Advice的子类型</p>
</blockquote>
<p><strong>10.装饰器模式–Decorator</strong></p>
<blockquote>
<p>应用场景：比如说项目需要多数据库连接，用户每次访问都会根据需要去访问不同的数据库</p>
<p>首先想到的是在spring的applicationContext中配置所有的DataSource。这些DataSource可能是各种不同类型的，比如不同的数据库oracle、mysql，也可能是不同的数据源：比如Apache提供的org.apache.commons.dbcp.BasicDataSource、Spring提供的org.springframework.jndi.JndiObjectFactoryBean等。然后SessionFactory根据客户的每次请求，将DataSource属性设置成不同的数据源，以到达切换数据源的目的。</p>
<p>spring中用的包装器模式在类名上有两种表现：一种是类名中含有Wrapper、另一种是类名中喊有Decorator。基本上都是动态的给一个对象添加一些额外的职责。</p>
<p>io流包装、数据源包装等</p>
</blockquote>
<p><strong>11.观察者模式–Observer</strong></p>
<blockquote>
<p>应用场景：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变是，所有依赖于它的对象都得到通知并被自动更新</p>
<p>Spring中Observer模式常用的地方是Listener的实现。如：ApplicationListener</p>
<p>一般由两个角色组成：发布者和订阅者（观察者），观察者通常有一个回调，也可以没有，监听器、日志收集</p>
</blockquote>
<p>设计模式对比</p>
<table>
<thead>
<tr>
<th>设计模式</th>
<th>一句话归纳</th>
</tr>
</thead>
<tbody><tr>
<td>工厂模式Factory</td>
<td>只对结果负责，不要三无产品</td>
</tr>
<tr>
<td>单例模式Singleton</td>
<td>保证独一无二</td>
</tr>
<tr>
<td>适配器模式Adapter</td>
<td>需要一个转换头（兼容）</td>
</tr>
<tr>
<td>装饰器模式 Decorator</td>
<td>需要包装，但不改变本质（同宗同源）</td>
</tr>
<tr>
<td>代理模式Proxy</td>
<td>办事要求人，所以找代理</td>
</tr>
<tr>
<td>观察者模式Observer</td>
<td>完成时通知我</td>
</tr>
<tr>
<td>策略模式Strategy</td>
<td>我行我素，达到目的就行</td>
</tr>
<tr>
<td>模板模式Template</td>
<td>流程标准化，原料自己加</td>
</tr>
<tr>
<td>委派模式Delegate</td>
<td>干活是你的（普通员工），功劳是我的（项目经理）</td>
</tr>
<tr>
<td>原型模式prototype</td>
<td>拔一根好，吹出千万个</td>
</tr>
</tbody></table>
<p>编程思想总结</p>
<table>
<thead>
<tr>
<th>spring思想</th>
<th>应用场景（特点）</th>
<th>一句话归纳</th>
</tr>
</thead>
<tbody><tr>
<td>aop</td>
<td>面向切面变成，找出多个类中中有一定规律的代码，开发时拆开，运行时再合并，例如aop日志</td>
<td>解耦，专人做专事</td>
</tr>
<tr>
<td>oop</td>
<td>面向对象变成，归纳总结生活中的一切事务</td>
<td>封装、集成、多态</td>
</tr>
<tr>
<td>bop</td>
<td>面向bean编程，面向bean（普通java类）设计程序</td>
<td>一切从bean开始</td>
</tr>
<tr>
<td>ioc</td>
<td>控制翻转，将new对象的动作交给spring管理，并由spring保存已创建的对象（ioc容器）</td>
<td>转交控制权（控制翻转）</td>
</tr>
<tr>
<td>DI/DL</td>
<td>依赖注入或者依赖查找，spring不仅保存自己创建的对象，而保存对象与对象之间的关系<br />注入即赋值，主要三种方式：构造方法、set方法、直接赋值</td>
<td>先理清关系再赋值</td>
</tr>
</tbody></table>
<p>cglib与jdk的区别是：</p>
<blockquote>
<p>创建代理的消耗</p>
<p>cglib不适合频繁创建，适合创建一次，长期使用</p>
</blockquote>
<h3 id="spring-bean-的加载、注入过程"><a href="#spring-bean-的加载、注入过程" class="headerlink" title="spring bean 的加载、注入过程"></a>spring bean 的加载、注入过程</h3><blockquote>
<ol>
<li>执行该对象的构造方法</li>
<li>执行set参数注入方法</li>
<li>执行BeanNameAware的实现方法获取bean的id</li>
<li>执行BeanFactoryAware的实现方法获取bean的工厂</li>
<li>执行BeanPostProcessor的postProcessBeforeInitalization处理方法</li>
<li>执行In</li>
</ol>
</blockquote>
<h3 id="说一下对spring的理解，ioc和aop在项目里怎么用的"><a href="#说一下对spring的理解，ioc和aop在项目里怎么用的" class="headerlink" title="说一下对spring的理解，ioc和aop在项目里怎么用的"></a>说一下对spring的理解，ioc和aop在项目里怎么用的</h3><p>spring 是一个开源框架，处于mvc的控制层，能应对需求的快速变化，主要原因是它有一种面向切面编程（aop）的优势</p>
<p>其次它提升了系统性能，是因为通过依赖倒置机制（ioc），系统中用到的对象不是在系统加载时就全部实例化，而是在调用到这个类时才会实例化该对象</p>
<p><strong>优点</strong></p>
<blockquote>
<ul>
<li>降低了组件之间的耦合性，实现了软件各层之间的解耦</li>
<li>可以使用容易提供的众多服务，事务管理、消息服务、日志记录等</li>
<li>容器提供了aop，利用它很容易实现如权限拦截、运行期监控等功能</li>
</ul>
</blockquote>
<p>Spring中的aop技术是设计模式中的动态代理模式</p>
<h2 id="AOP的两种实现方式？哪个效率更高？为什么？"><a href="#AOP的两种实现方式？哪个效率更高？为什么？" class="headerlink" title="AOP的两种实现方式？哪个效率更高？为什么？"></a>AOP的两种实现方式？哪个效率更高？为什么？</h2><p>jdk动态代理、cglib</p>
<p>JDK<strong>动态代理具体实现原理</strong></p>
<blockquote>
<ul>
<li>通过实现InvocationHandle接口创建自己的调用处理器</li>
<li>通过Proxy类指定ClassLoader对象和一组interface来创建动态代理</li>
<li>通过反射机制获取动态代理类的构造函数，其唯一参数类型就是调用处理器接口类型</li>
<li>通过构造函数创建动态代理实例，构造时调用处理器对象作为参数传入；</li>
</ul>
<p>jdk动态代理是面向接口的代理模式，如果被代理目标没有接口那么spring也无能为力，Spring通过java的 反射机制生产被代理接口的新的匿名实现类，重写了其中AOP的增强方法。</p>
</blockquote>
<p><strong>CGLib动态代理</strong></p>
<blockquote>
<p>强大的、高性能的Code生产类库，可以实现运行期动态扩展java类，Spring在运行期间通过cglib集成要被动态代理的类，重写父类的方法，实现Aop切面变成</p>
</blockquote>
<p><strong>两者的对比</strong></p>
<blockquote>
<p>jdk是面向接口的</p>
<p>cglib是通过字节码底层集成要代理类来实现（如果被代理类被final修饰，那么会失败）</p>
</blockquote>
<p><strong>性能</strong></p>
<blockquote>
<p>主要体现在如下的两个指标中</p>
<ul>
<li>cglib所创建的动态搭理对象在实际运行时候的性能要比jdk高，大概10倍</li>
<li>cglib在创建对象的时候所花费的时间比jdk要高，大概8倍</li>
</ul>
<p>因此，对于Singleton的代理对象或者具有实例池的代理，因为无需频繁的创建代理对象，所以比较适合采用cglib动态代理，反之使用jdk</p>
</blockquote>
<h3 id="spring事务的传播机制"><a href="#spring事务的传播机制" class="headerlink" title="spring事务的传播机制"></a>spring事务的传播机制</h3><p>有如下几种</p>
<ul>
<li><p>PROPAGATION_REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</p>
</li>
<li><p>PROPAGATION_SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。</p>
</li>
<li><p>PROPAGATION_MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常。</p>
</li>
<li><p>PROPAGATION_REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。</p>
</li>
<li><p>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>
</li>
<li><p>PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p>
</li>
<li><p>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p>
</li>
</ul>
<p>常用的主要由三个：Required、RequresNew、Nested</p>
<ul>
<li>Required：简单理解就是事务方法会判断是否存在事务，有事务就用已有的，没有就重新开启一个</li>
<li>RequiresNew：简单理解就是开启新事务，若当前已有事务，挂起当前事务。新开启的事务和之前的事务无关，拥有自己的锁和隔离级别，可以独立提交和回滚，内层事务执行期间，外层事务挂起。内层事务执行完毕，外层事务恢复执行</li>
<li>Nested：简单理解就是：嵌套事务，如果外部事务回滚，则嵌套事务也回滚！！外部事务提交的时候，嵌套事务才会被提交。嵌套事务回滚不会影响外部事务</li>
</ul>
<p>如果想事务一起执行可以用Required满足大部分场景，如果不想让执行的子事务的结果影响到父事务的提交，可以将子事务设置为RequiresNew</p>
<h3 id="简单说一下IOC、DI"><a href="#简单说一下IOC、DI" class="headerlink" title="简单说一下IOC、DI"></a>简单说一下IOC、DI</h3><p>Inversion on Control，控制翻转，对象的创建交给外部容器完成，这个就叫做控制翻转</p>
<p>Dependency injection，依赖注入、处理对象的依赖关系</p>
<h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><ul>
<li>控制反转，解决对象创建的问题</li>
<li>依赖注入，在创建完对象后，对象的关系的处理就是依赖注入</li>
</ul>
<h2 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h2><ol>
<li><p>核心配置文件是哪几个？他们的区别是啥？</p>
<p>applicaion和boostrap配置文件</p>
<p>application配置文件主要用于springboot项目的自动化配置</p>
<p>boostrap配置文件主要用于</p>
<p>​    一些固定的不能被覆盖的属性，一些加密解密的场景</p>
</li>
<li><p>配置文件有哪几种格式？有什么区别？</p>
<p>properties和yml</p>
<p>区别就是书写格式不同</p>
<p>另外 yml 格式不支持@propertySource注解导入配置</p>
</li>
<li><p>事务是怎么实现的？</p>
<p>基于@Transactional注解</p>
<blockquote>
<p>整体事务控制流程</p>
<ol>
<li>当@Transactional注解的方法被外部的代码调用时，spring在运行时为方法所在类生成一个aop代理对象。</li>
<li>代理对象根据@transactional的属性，决定是否由事务拦截器TransactionInterceptor对此方法进行事务拦截。</li>
<li>在进行事务拦截时，会先开启事务，然后执行业务代码，根据执行是否出现异常，通过抽象事务管理来进行rollback或者commit。</li>
</ol>
</blockquote>
</li>
<li><p>数据库引擎是否支持事务？</p>
<p>mysql的mylsam不支持事务</p>
<p>如果事务生效，库和表的引擎必须是InnoDB</p>
<p>当事务方法被本类内部方法调用时，@Transactional 注解并不生效，因为，只有被当前类以外的调用时，才会由spring生成的代理对象来管理</p>
<p>一定要确保所使用的数据源加载了事务管理器（配置文件写一下就好）</p>
</li>
<li><p>springboot的核心注解是哪个？他主要由哪几个注解组成？</p>
<p>启动类上面的注解是@springbootApplication，它是核心注解，包含了以下三个注解</p>
<p>@springbootConfiguration：组合了@Configuration注解，实现配置文件的功能</p>
<p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项</p>
<p>@ComponentScan：spring组件扫描</p>
</li>
<li><p>开启springboot 特性有哪几种方式?</p>
<ol>
<li>继承spring-boot-starter-parent项目</li>
<li>导入spring-boot-dependencies项目依赖</li>
</ol>
</li>
<li><p>springboot需要独立的容器运行吗？</p>
<p>可以不需要，内置了tomcat/jetty等容器。</p>
</li>
<li><p>springboot 配置加载顺序</p>
<ol>
<li>properties</li>
<li>yaml文件</li>
<li>系统环境变量</li>
<li>命令行参数</li>
</ol>
</li>
<li><p>springboot可以兼容老spring项目吗？如何做?</p>
<p>可以兼容，使用@ImportResource注解导入老spring项目配置文件</p>
</li>
<li><p>保护springboot应用有哪些方法？</p>
<ol>
<li>在生产中使用https</li>
<li>启用csrf保护</li>
<li>使用内容安全策略防止xss攻击</li>
</ol>
</li>
</ol>
<p><strong>private不能事务，基于aop实现的，aspectj可以</strong>？？</p>
<p><strong>springboot默认的代理是cglib</strong>？？</p>
<h2 id="spring-cloud"><a href="#spring-cloud" class="headerlink" title="spring cloud"></a>spring cloud</h2><ol>
<li><p>微服务之间是如何独立通讯的？</p>
<ol>
<li>同步：rpc、rest等</li>
<li>异步：消息队列</li>
</ol>
</li>
<li><p>ribbon和feign的区别？</p>
<ol>
<li>都是客户端的负载均衡工具，feign的底层是通过ribbon实现的，是对riboon的封装</li>
<li>ribbon使用httpclient或者restTemplate模拟http请求，步骤繁琐。</li>
<li>feign采用接口+注解的方式，将需要调用的其他服务的方法定义成抽象方法即可，不需要自己构建http请求。就像调用自身工程的方法一样调用</li>
</ol>
</li>
<li><p>注册中心用的什么？</p>
<p>用的nacos= eureka+config</p>
</li>
<li><p>nacos优点？</p>
<ol>
<li>nacos自带配置中心，且提供了管理界面</li>
<li>动态刷新，eureka需要配合mq实现配置动态刷新，nacos采用netty保持tcp场链接实时推送</li>
<li>nacos可用根据业务和环境进行分组管理</li>
<li>默认提供权重设置功能，调整承载流量压力</li>
<li>nacos支持由客户端或服务端发起的健康检查，eureka是由客户端发起心跳</li>
<li>nacos支持对服务在线管理，eureka只是预览服务状态</li>
</ol>
</li>
<li><p>选型建议？</p>
<p>采用eureka防范的考虑</p>
<ol>
<li>想用spring cloud 原生全家桶</li>
<li>想用本地文件和git作为配置管理的，将配置与服务分开管理</li>
<li>考虑短期的稳定性</li>
</ol>
<p>采用Nacos方案的考虑</p>
<ol>
<li>想在线对服务进行上下线和流量管理</li>
<li>不想采用MQ实现配置中心动态刷新</li>
<li>不想新增配置中心生产集群</li>
<li>考虑引入spring cloud alibaba生态</li>
</ol>
</li>
<li><p>eureka 和zookeeper都可以提供服务注册和发现的功能，请说说两个的区别？</p>
<ol>
<li><p>zookeeper保证的是cp，Eureka保证的ap</p>
<p>zookeeper在选举期间注册服务谈话，虽然服务最终会回复，但是选举期间不可用的</p>
<p>eureka各个节点是平等关系，只要有一台eureka就可以保证服务可以用，查询到的数据并不是最新的</p>
<blockquote>
<p>自我保护机制会导致：</p>
<p>eureka不再从注册列表移除因长时间没有收到心跳而应该过期的服务</p>
<p>eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点（高可用）</p>
<p>当网络稳定是，当前实例新的注册信息会被同步到其他节点中（最终一致性）</p>
<p>eureka可以很好的应对因为网络故障导致部分节点失去联系的情况，而不会像zookeeper一样使得整个注册系统瘫痪</p>
</blockquote>
</li>
<li><p>eureka可以看做是一个工程，而zookeeper只是一个进程</p>
</li>
</ol>
</li>
<li><p>springcloud是如何实现服务发现和注册的？</p>
<p>服务在发布时指定对应的服务名（包括了ip地址和端口）将服务注册到注册中心（eureka或者zookeeper或者nacos）</p>
<p>在main方法添加@enableDiscoveryClient 同一个服务修改端口就可以启动多个实例</p>
<p>调用方的话：传递服务名称通过注册中心获取所有的可用实例，通过负载均衡策略调用（ribbon和feign）对用的服务</p>
</li>
</ol>
<h2 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h2><h3 id="说一下mybatis与hibernate的区别"><a href="#说一下mybatis与hibernate的区别" class="headerlink" title="说一下mybatis与hibernate的区别"></a>说一下mybatis与hibernate的区别</h3><p><strong>共同点</strong></p>
<blockquote>
<p>都是通过orm对象关系映射框架，都是持久层数据框架</p>
</blockquote>
<p><strong>不同点</strong></p>
<ul>
<li>hibernate重量级框架，Mybatis是轻量级框架</li>
<li>Hibernate对jdbc的封装比较深，对开发者写sql的要求高，只要通过hql语句操作对象即可完成数据的持久化操作了</li>
<li>Mybatis也是对jdbc的封装，但是没有H那么深，他的sql语句都在配置里，也可以通过重新配置里sql，来实现数据优化</li>
<li>处理大数据的时候，建议使用Mybatis，它优化sql更方便</li>
</ul>
<h2 id="RocketMq"><a href="#RocketMq" class="headerlink" title="RocketMq"></a>RocketMq</h2><p><strong>核心模块</strong></p>
<ul>
<li>rocketmq-broker：接受生产者发来的消息并存储（通过调用rocketmq-stroe），消费者从这里取得消息</li>
<li>rocketmq-client：提供发送、接收消息的客户端API</li>
<li>rocketmq-namesrv：NameServer，类似于Zookeeper，这里保存着消息的TopicName，队列运行时的元信息</li>
<li>rocketmq-common：通用的一些类、方法、数据结构等</li>
<li>rocketmq-remoting：基于Netty4的client/Server + fastjson序列化 + 自定义二进制协议</li>
<li>rocketmq-store：消息、索引存储等</li>
<li>rocketmq-filtersrv：消息过滤器（一般用tag就可以）</li>
<li>rocketmq-tools：命令行工具</li>
</ul>
<p><strong>四大核心</strong>组成部分</p>
<p>他主要有四大核心：NameServer、Broker、Producer以及Consumer</p>
<img src="img/面试准备.assets/image-20200309102855022.png" alt="image-20200309102855022" style="zoom:50%;" />

<p>可以看到，他啥都是可以集群的，这是他吞吐量大，高可用的原因之一</p>
<p>集群的模式也很花哨，可以支持多master模式、多master多slave异步复制模式、多master多slave同步双写模式</p>
<p>而且这个模式好像kafka啊，废话，rocketmq 本身就是阿里基于kafka的很多特性研发的</p>
<h3 id="分别介绍一下各个集群组成部分"><a href="#分别介绍一下各个集群组成部分" class="headerlink" title="分别介绍一下各个集群组成部分"></a>分别介绍一下各个集群组成部分</h3><h4 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h4><blockquote>
<p>主要负责对数据源的管理，包括了对于topic和路由信息的管理。</p>
</blockquote>
<p>类似于Dubbo中zookeeper，但NameServer与Zookeeper相比更轻量。主要是因为每个NameServer节点互相之间是独立的，没有任何信息交互。</p>
<p>NameServer压力不会太大，平时的开销主要是维持心跳和提供Topic-Broker的关系数据。</p>
<p>但是有一点需要注意，Brker想NameServer发心跳时，会带上当前自己所负责的所有Topic信息，如果Topic个数太多（万级别），会导致一次心跳中，光Topic的数据就几十m，网络情况差的话，网络传输失败，心跳失败，导致NameServer误认为Broker心跳失败</p>
<p>NameServer被设计成几乎无状态的，可以横向扩展，节点之间相互之间无通信，通过部署多台机器来标记自己是个伪集群。</p>
<p>每个Broker在启动的时候都会到NameServer注册， Producer在发送消息前会根据Topic到NameServer获取到Broker的路由信息，Consumer也会定时获取Topic的路由信息。</p>
<p>所有从功能上看NameServer应该是和Zookeeper差不多，据说RocketMq的早期版本确实使用的Zookeeper，后来改为了自己实现的NameServer</p>
<h4 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h4><blockquote>
<p><strong>生产者</strong>，负责产生消息，一般是由业务系统负责产生消息</p>
</blockquote>
<ul>
<li>Producer又用户进行分布式部署，消息由Producer通过多种负责均衡模式发送到Broker集群，发送延时低，支持快速失败。</li>
<li>RocketMq提供了三种方式发送消息：同步、异步、单向<ul>
<li><strong>同步发送</strong>：指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包。一般用于重要通知消息，重要通知邮件，营销短信等</li>
<li><strong>异步发送</strong>：指发送方发出数据后，不等待接收方发回响应，就发送下个数据包，一般用于对响应时间不敏感的业务</li>
<li><strong>单向发送：</strong>值负责发送消息而不等待服务器的回应且没有回调函数触发，适用于某些耗时非常短但对可靠性要求并不高的场景，例如日志收集</li>
</ul>
</li>
</ul>
<h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><blockquote>
<p>消息<strong>中转角色</strong>，负责存储消息，转发消息</p>
</blockquote>
<p>Broker是具体提供业务的服务器，单个broker节点与所有的NameServer节点保持长连接及心跳，并会定时将Topic信息注册到NameServer，顺带一提底层的通信和连接都是基于netty实现的</p>
<p>Broker负责消息存储，以Topic为维度支持轻量级的队列，单机可以支撑上完队列规模，支持消息推拉模型</p>
<p>官网上说：具有<strong>上亿级消息堆积能力</strong>，同事可严格保证消息的<strong>有序性</strong></p>
<h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><blockquote>
<p><strong>消费者</strong>，负责消费消息，一般是由后台系统负责异步消费</p>
</blockquote>
<p>Consumer也由用户部署，支持push和pull两种消费模式，支持<strong>集群消费</strong>和<strong>广播消费</strong>，提供实时的<strong>消息订阅机制</strong></p>
<p><strong>Pull：</strong>拉取，主动从消息服务器拉取消息，只要批量拉取到消息，用户应用就会启动消费过程</p>
<p><strong>Push：</strong>推送，封装了消息的拉取、消费进度和其他的内部维护工作，将消息到达时执行的回调接口留给用户应用程序来实现。所有Push被称为被动消费；从实现上看还是从消费服务器中拉取消息，不同于pull的是 push首先要注册消费监听器，当监听器触发后才开始消费消息。</p>
<h3 id="一次完成的通讯流程是什么样的？"><a href="#一次完成的通讯流程是什么样的？" class="headerlink" title="一次完成的通讯流程是什么样的？"></a>一次完成的通讯流程是什么样的？</h3><p>Producer 与 NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic陆游信息，并向Topic服务的Broker Master建立长连接，且定时向Broker发送心跳</p>
<p>Producer 只能将消息发送到Broker master，但是Consumer不一样，它同时和提供Topic的Master 和Slave建立长连接，既可以从Master订阅，也可以从Slave订阅消息</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>单机吞吐量：十万级</li>
<li>可用性：非常高，分布式架构</li>
<li>消息可靠性：经过参数优化配置，消息可以做到0丢失</li>
<li>功能支持：mq功能较为完善，还是分布式的，扩展性好</li>
<li>支持10亿级别的消息堆积，不会因为堆积导致性能下降</li>
<li>源码是java，我们可以自己阅读源码，定制自己公司的mq，可以掌控</li>
<li>天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况</li>
<li>稳定性更值得信赖，经历了多次双11</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>支持的客户端语言不多，java、c++(不成熟)</li>
<li>社区活跃度不是特别活跃的那种</li>
<li>没有在mq核心中去实现<strong>jms</strong>等接口，有些系统要迁移需要修改大量代码</li>
</ul>
<p>消息去</p>
<h1 id="陌陌面试题"><a href="#陌陌面试题" class="headerlink" title="陌陌面试题"></a>陌陌面试题</h1><h3 id="java多线程的实现？"><a href="#java多线程的实现？" class="headerlink" title="java多线程的实现？"></a>java多线程的实现？</h3><h3 id="二叉树后序遍历"><a href="#二叉树后序遍历" class="headerlink" title="二叉树后序遍历"></a>二叉树后序遍历</h3><h3 id="网络io模型"><a href="#网络io模型" class="headerlink" title="网络io模型"></a>网络io模型</h3><h3 id="三次握手每次在干嘛？"><a href="#三次握手每次在干嘛？" class="headerlink" title="三次握手每次在干嘛？"></a>三次握手每次在干嘛？</h3><h3 id="两个有序表的第n-和第n-1-大的数，不要额外空间，时间复杂度优化到nlogn？"><a href="#两个有序表的第n-和第n-1-大的数，不要额外空间，时间复杂度优化到nlogn？" class="headerlink" title="两个有序表的第n 和第n+1 大的数，不要额外空间，时间复杂度优化到nlogn？"></a>两个有序表的第n 和第n+1 大的数，不要额外空间，时间复杂度优化到nlogn？</h3><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><strong>单例模式</strong></h3><p><strong>优点</strong></p>
<blockquote>
<ol>
<li><p>只创建一个实例，节省内存开销 </p>
</li>
<li><p>减少了系统的性能开销，创建、回收对象都对性能有影响</p>
</li>
<li><p>提供了对唯一实例的受控访问</p>
</li>
<li><p>允许可变数目的实例</p>
</li>
</ol>
</blockquote>
<p><strong>缺点</strong></p>
<blockquote>
<ol>
<li>没有抽象层，因此扩展有很大的困难</li>
<li>单例类的职责过重，一定程度上违背了“单一职责原则”</li>
<li>滥用单例将带来一些负面问题：比如实例化的对象长时间不被利用，系统会认为是垃圾而回收</li>
</ol>
</blockquote>
<p><strong>使用场景</strong></p>
<blockquote>
<ul>
<li>web中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来</li>
<li>要求生产唯一序列号</li>
<li>创建一个对象需要消耗的资源过多，比如I/O与数据库的连接等</li>
</ul>
</blockquote>
<p><strong>关键代码</strong></p>
<blockquote>
<p>构造函数是私有的</p>
</blockquote>
<p><strong>注意事项</strong></p>
<blockquote>
<p>getInstance()方法中需要使用同步锁synchronized(Singleton.class)防止多线程同事进入造成instance被多次实例化。</p>
</blockquote>
<p><strong>懒汉</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类,在调用时才会初始化,因此是懒汉式</span></span><br><span class="line"><span class="comment"> * 看似是饿汉式,但只有调用getLazySingleton时才会初始化,线程安全由ClassLoad保证,不用思考怎么加锁</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 缺点:仍然会被反射和序列化攻击</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingletonHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton lazySingleton = <span class="keyword">new</span> LazySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getLazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazySingletonHolder.lazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>饿汉</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HungrySingleton 对象已经创建完成[在类加载时创建]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton hungrySingleton = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造函数,不能被外部访问</span></span><br><span class="line"><span class="comment">     * 创造对象的行为只能由这个类决定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回单例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getHungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungrySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建线程安全的单例有哪些实现方法？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">双检锁/双重校验锁</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">null</span>==singleton)&#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>( <span class="keyword">null</span> == singleton)&#123;</span><br><span class="line">					singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">			&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>登记式/静态内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">				<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>枚举</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">		INSTANCE;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whatEverMethod</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<ol start="6">
<li></li>
</ol>
</blockquote>
<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p><strong>ArrayList有用过吗？它是一个什么东西？可以用来做什么</strong>？</p>
<blockquote>
<p>就是一个数组列表，主要用来状态数据，如果装在的是基本数据类型（int、long、boolean、short、byte、double、char、float）的时候，只能存储他们对应的包装类,它的主要底层实现是数组</p>
<p>与它类似是LinkedList、和LinkedList相比，它的查找和访问元素的速度较快，但是增删慢</p>
<p><strong>小结：</strong>底层是数组实现的存储</p>
<p><strong>特点：</strong>查询效率高，增删效率低，线程不安全，使用频率高</p>
</blockquote>
<p><strong>线程不安全，为啥还使用它呢？</strong></p>
<blockquote>
<p>因为正常使用的场景中，都是用来查询，不会涉及太频繁的增删，如果涉及频繁的增删，可以使用LinkedList，如果要线程安全就使用Vector，这就是三者的区别，实际开发中还是ArrayList使用的最多。</p>
<p>不存在一个集合工具查询效率高，增删效率也高，线程还是安全的。</p>
<p>做的也都是一些线下的系统，没啥并发</p>
</blockquote>
<p><strong>它的底层是数组，数组是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？</strong></p>
<blockquote>
<p>ArrayList可以通过构造方法在初始化的时候指定底层数组的大小</p>
<p>如果是使用无参构造初始化，则赋值底层数据一个默认空数组，只有真正对数据进行添加是，才会分配默认的<strong>初始容量10</strong></p>
<p>可以看下它的无参构造和有参构造，无参就是默认大小，有参会判断参数</p>
</blockquote>
<p><strong>数组是有长度限制的，而ArrayList是可以存放任意数量对象，长度不受限制，那么他是怎么实现的呢？</strong></p>
<blockquote>
<p>实现比较简单，他就是通过数组扩容的方式去实现的。</p>
<p>比如说现在有一个长度为10的数组，需要新增第11个了，发现已经满了，那么会怎么做呢？</p>
<p>第一步：他会重新定义一个10+10/2的数组也就是一个长度为15的数组</p>
<p>第二步：把原数组的数据，原封不动的复制到新数组中，这个时候再把指向原数组的地址切换到新地址，ArrayList就这样完成了一次扩容</p>
</blockquote>
<p><strong>能具体说下1.7和1.8初始化的时候的区别么？</strong></p>
<blockquote>
<p>初始化的时候：1.7以前会调用this(10)的时候才是真正的容量为10，1.7开始就是默认走空数组了，只有第一次add的时候才会变成10</p>
</blockquote>
<p><strong>ArrayList的默认数组大小为什么是10？</strong></p>
<blockquote>
<p>不清楚。。。</p>
</blockquote>
<p><strong>为什么增删慢？</strong></p>
<blockquote>
<p>因为他的数组，是连续的内存空间，比如说删除一个的话，需要移动后面所有的</p>
</blockquote>
<p><strong>ArrayList（int initialCapacity）会不会初始化数组大小？</strong></p>
<blockquote>
<p>会初始化数组大小！但是List没，那size就没变，set下标和size比较的那就报错了。</p>
</blockquote>
<p><strong>ArrayList插入删除一定慢么？</strong></p>
<blockquote>
<p>取决于你删除的元素离数组末端有多远，ArrayList拿来作为堆栈来用还是挺合适的，push和pop操作完全不涉及数据移动操作。</p>
</blockquote>
<p><strong>它的删除是怎么实现的呢？</strong></p>
<blockquote>
<p>删除跟新增是一样的，不过叫是叫删除，但是在代码里可以发现，他还是在copy一个数组，举个例子：要删除index5这个位置</p>
<p><img src="img/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.assets/image-20200221162800968.png" alt="image-20200221162800968"></p>
<p>那么代码就复制一个index5+1到最后的数组，然后把它放到index开始的位置</p>
<p><img src="img/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.assets/image-20200221162852100.png" alt="image-20200221162852100"></p>
<p>index5的位置就被成功“删除了”，起始就是被覆盖了</p>
</blockquote>
<p>ArrayList是线程安全的么？</p>
<blockquote>
<p>当然不是，线程安全的数组容器是Vector</p>
<p>Vector的实现很简单，就是把所有的方法统统加上Synchronized就完事了。</p>
<p>你也可以不使用vector，用Collections.synchronizedList把一个普通的ArrayList包装成一个线程安全版本的数组容器也可以，原理同Vector是一样的，就是给所有的方法套上一层synchronized</p>
</blockquote>
<p>ArrayList用来做队列合适么？</p>
<blockquote>
<p>队列一般是FIFO（先进先出）的，如果用ArrayList做队列，就需要在数组尾部追加数据，数组头部删除数组，或者反过来。</p>
<p>但是无论如何总会有一个操作涉及到数组数据的迁移，耗费性能</p>
<p><strong>结论：</strong>不适合</p>
</blockquote>
<p><strong>那数组适合做队列吗？</strong></p>
<blockquote>
<p>数组是非常适合的</p>
<p>比如ArrayBlockingQueue内部实现就是一个环形队列，它是一个定长队列，内部是用一个定长数组来实现的。</p>
<p>另外著名的Disruptor开源Library也是用环形数组来实现的超高性能队列，具体原理不做解释，比较复杂。</p>
<p>简单点说就是使用两个偏移量来标记数组的读位置和写位置，如果超过长度就折回到数组开头，前提是它们是定长数组。</p>
</blockquote>
<p><strong>ArrayList的遍历和LinkedList遍历性能比较如何？</strong></p>
<blockquote>
<p>ArrayList快得多，内存是连续的，cpu的内部缓存结构会缓存连续的内存片段，可以大幅度降低读取内存的性能开销。</p>
</blockquote>
<p><strong>总结：</strong></p>
<blockquote>
<p>ArrayList就是动态数组，可以看成Array的复杂版本，提供了冬天的增删，实现了ICollection和IList接口，灵活的设置数组的大小等好处</p>
<p>面试频率不如HashMap和ConcurrentHashMap</p>
</blockquote>
<h1 id="秒杀系统设计"><a href="#秒杀系统设计" class="headerlink" title="秒杀系统设计"></a>秒杀系统设计</h1><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>要定点秒杀100件手机</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>高并发</strong></p>
<blockquote>
<p>时间短，瞬间用户量大</p>
</blockquote>
<p><strong>超卖</strong></p>
<p><strong>恶意请求</strong></p>
<blockquote>
<p>黄牛几十台机器脚本秒杀，模拟个十几万人的请求</p>
</blockquote>
<p><strong>链接暴露</strong></p>
<blockquote>
<p>前端暴露了地址，或者开发人员自己知道了，猛点</p>
</blockquote>
<p><strong>数据库</strong></p>
<blockquote>
<p>每秒上万甚至十几万的qps打到数据库，基本gg</p>
</blockquote>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>服务单一职责</strong></p>
<blockquote>
<p>微服务设计思想，再用分布式的部署方式</p>
<p>给秒单独的服务，单独的库</p>
<p><strong>好处：</strong>就算挂了， 也不会影响其他服务</p>
</blockquote>
<p><strong>秒杀连接加盐</strong></p>
<blockquote>
<p>把url动态化，就连写代码的人都不知道，通过md5之类的加密算法随机的字符串去做url，然后通过前端代码获取url后台校验才能通过。</p>
</blockquote>
<p>redis<strong>集群</strong></p>
<blockquote>
<p>单机redis顶不住，那就多找几个兄弟，秒杀本来就是读多写少</p>
<p>redis集群、主从同步、读写分离、还可以高点哨兵，开启持久化直接无敌高可用</p>
</blockquote>
<p><strong>nginx</strong></p>
<blockquote>
<p>高性能的web服务器，并发也是随便几万不是梦，但是tomcat只能顶几百的并发啊。那简单啊负载均衡嘛，一台服务器几百，那就多搞点，在秒杀的时候多租点流量机</p>
<p>恶意请求拦截也需要用它，一般单个用户请求次数太夸张，不像真人的请求在网关那一层就得拦截掉了</p>
</blockquote>
<p><strong>资源静态化</strong></p>
<blockquote>
<p>秒杀一般都是特定的商品还有页面模板，现在一般都是前后端分离的，所有页面一般是不会经过后端的，但是前段也要有自己的服务器啊，那就把能提前放到cdn服务器的东西都放进去，反正把能提升效率的步骤都做一下，减少真正秒杀时候服务器的压力</p>
</blockquote>
<p><strong>按钮控制</strong></p>
<blockquote>
<p>秒杀前按钮<strong>置灰</strong>，到点了才能点</p>
<p>这是防止在快到秒杀前的时间疯狂请求服务器，这个时候就需要前端的配合，定时去请求你的后端服务器，获取最新的北京时间，到时间点了再给按钮可以用</p>
<p>点击一次之后也得置灰几秒，防止一直点</p>
</blockquote>
<p><strong>限流</strong></p>
<blockquote>
<p>前端限流：跟按钮控制类似，防止一直点</p>
<p>后端限流：秒杀的时候肯定是涉及到了后续的<strong>订单生成</strong>和<strong>支付操作</strong>，一旦秒杀产品卖完了，return一个false，前端直接秒杀结束</p>
<p>真正的限流还会有限流组件，比如阿里的Sentinel、Hystrix等</p>
</blockquote>
<p><strong>库存预热</strong></p>
<blockquote>
<p>秒杀的本质，就是对库存的争夺，每个秒杀的用户来你都去数据库查询库存校验库存，然后扣减库存，对开发很不友好，而且数据库顶不住啊</p>
<p><strong>提前把商品的库存加载到redis中去</strong>，让整个流程都在redis里做，然后等秒杀结束了，再异步的去修改库存就好了</p>
<p>但是用redis的话就有一个问题了，我们上面说了主从，然后回去读库然后再判断有库存才去减库存，正常情况没问题，但是高并发的情况问题就很大了：比如只剩下一个库存了，高并发，四个服务器一起查询大家发现都还剩一个，都觉得自己抢到了，都去扣库存了，结果变成-3了，这样就发生了超卖</p>
<p><strong>Lua</strong>：lua脚本类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作，一个脚本=查库存+扣减库存，如果是0 了直接false</p>
</blockquote>
<p><strong>削峰填谷</strong></p>
<blockquote>
<p>说到这里就知道是说mq了，卖100个东西直接100个请求，我觉得没问题，但万一秒杀一万个，10万个呢，服务器挂了 </p>
<p>把他放消息队列，然后一点点消费去改库存不就好了嘛</p>
</blockquote>
<h1 id="消息队列基础"><a href="#消息队列基础" class="headerlink" title="消息队列基础"></a>消息队列基础</h1><p>经典场景，需要熟烂于心：异步、削峰、解耦</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a><strong>异步</strong></h3><blockquote>
<p>一个下单流程：本来需要100ms，后来产品说要加上积分，流程中加上积分扣减，200ms了</p>
<ul>
<li><p>产品说要加上优惠券，300毫秒了</p>
</li>
<li><p>产品说要发短信，400毫秒了</p>
</li>
<li><p>再后来。。。</p>
</li>
</ul>
<p>让产品加的这三点可以<strong>异步</strong></p>
</blockquote>
<p><strong>面试官：异步，我用线程、线程池去做不一样吗</strong>？</p>
<blockquote>
<p>为什么不能用线程去做？</p>
<p>用线程的话，扣积分、扣优惠券、发短信是不是都需要单独的接口？，每次加一个流程是不是代码都要改动？</p>
<p>但是用了消息队列，问题迎刃而解啊：</p>
<p>你下单了，你就把你支付成功的消息告诉别的系统，他们收到了去处理就好了，来多少类似的需求，只需要对应的人员去监听该消息就行了</p>
</blockquote>
<p><strong>那你的流程走完了，别人没成功怎么办？</strong></p>
<blockquote>
<p>起始不需要考虑，业务系统本身就是自己开发人员维护的，你扣积分失败和我下单有什么关系？</p>
</blockquote>
<h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>平时流量低，但是秒杀时流量猛增，你的服务器，redis，mysql各自的承受能力都不一样，全部流量赵丹全收肯定有问题啊，直接就挂了</p>
<p><strong>怎么办</strong></p>
<blockquote>
<p>把请求放到队列里面，每秒消费多少请求，就看自己的服务器处理能力，你能处理5000qps，你就消费这么多人，可能会比正常的慢一点，但是不至于打挂服务器，等流量高峰下去了，你的服务器也就没压力了</p>
</blockquote>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h2 id="消息去重、重复消费"><a href="#消息去重、重复消费" class="headerlink" title="消息去重、重复消费"></a>消息去重、重复消费</h2><p>原则：使用业务端逻辑保持幂等性</p>
<p>策略：保证每条消息都要唯一编号（比如唯一流水号），且保证消息处理成功与去重表的日志同时出现。</p>
<p>建立一个消息表，拿到这个消息做数据库的insert操作。给这个消息做一个唯一主键或约束，就算出现重复消费的情况，也会导致主键冲突，以后就不再处理这条消息了</p>
<h2 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h2><p><strong>Qos：Quality of Service 服务质量</strong></p>
<p>消息领域对投递的定义分为：</p>
<ul>
<li>最多一次</li>
<li>至少一次</li>
<li>仅一次</li>
</ul>
<p>几乎所有的mq产品都声称自己做到了  <strong>至少一次</strong></p>
<p>既然是至少一次，那避免不来消息重复，尤其是在分布式网络环境下</p>
<h2 id="消息可用性"><a href="#消息可用性" class="headerlink" title="消息可用性"></a>消息可用性</h2><p>当我们选择好了集群模式之后，那么我们需要关系的就是怎么去存储和复制这个数据，RocketMq对消息的刷盘提供了同步和异步的策略来满足我们。</p>
<p>同步刷盘：如果刷盘超时则会返给FLUSH_DISK_TIMEOUT，如果是异步刷盘不会返回刷盘相关信息，选择同步刷盘可以尽最大程度满足我们的消息不会丢失。</p>
<p>除了存储有选择之后，我们的主从同步提供了同步和异步两种模式来进行复制，当然选择同步可以提升可用性，但是消息的发送RT时间会下降10%左右。</p>
<p>RocketMq采用的是混合型的存储结构，即为Broker单个实例下所有的队列公用一个日志数据文件（即为COmmitLog）来存储</p>
<p>Kafka采用的是独立型的存储结构，每个队列一个文件。</p>
<p>RocketMq采用混合型存储结构的缺点在于：会存在较多的随机读操作，因此读的效率偏低。同时消费消息需要依赖ConsumeQueue，构建该逻辑消费队列需要一定开销。</p>
<h2 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h2><p>生产者消费者一般需要保证顺序消费的话，可能就是一个业务场景下的，比如订单的创建、支付、发货、收货。</p>
<p>那么这些东西是不是一个订单号呢？一个订单的肯定是一个订单号啊</p>
<p>一个topic下游多个队列，为了保证发送有序，RocketMq提供了MessageQueueSelector队列选择机制，他有三种实现：</p>
<img src="img/面试准备.assets/image-20200309154910190.png" alt="image-20200309154910190" style="zoom:50%;" />

<p>我们可以使用<strong>Hash取模法</strong>，让同一个订单发送到同一个队列中，再使用同步发送包，只有同个订单创建消息发送成功，再发送支付消息。这样就保证了<strong>发送有序</strong></p>
<p>Rokcet的topic内的队列机制，可以保证存储满足FIFO（先进先出），剩下的只需要消费者顺序消费即可</p>
<h2 id="分布式事务-1"><a href="#分布式事务-1" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="Half-Message-半消息）"><a href="#Half-Message-半消息）" class="headerlink" title="Half Message(半消息）"></a>Half Message(半消息）</h3><p>是指暂时不能倍Consumer消费的消息。Producer已经把消息成功发送到了Broker端，但此消息被标记为<strong>暂不能投递</strong>状态，处于该状态下的消息成为半消息，需要Producer对消息的二次确认后，Consumer才能去消费它。</p>
<h3 id="消息回查"><a href="#消息回查" class="headerlink" title="消息回查"></a>消息回查</h3><p>由于网络闪断，生产者重启等原因，导致Producer端一直没有对<strong>半消息</strong>进行二次确认，这时Brocker服务器会定时扫描长期处于半消息的消息，会主动询问Producer端，该消息的最终状态（Commit 或者 Rollback），该消息即为消息回查。</p>
<img src="img/面试准备.assets/image-20200309160441698.png" alt="image-20200309160441698" style="zoom:50%;" />

<p>A服务先发送个Half Message给Brock端，消息中携带 B服务 即将要+100元的信息。 </p>
<p>当A服务知道Half Message发送成功后，那么开始第3步执行本地事务。 </p>
<p>执行本地事务(会有三种情况1、执行成功。2、执行失败。3、网络等原因导致没有响应) </p>
<p>如果本地事务成功，那么Product像Brock服务器发送Commit,这样B服务就可以消费该message。 </p>
<p>如果本地事务失败，那么Product像Brock服务器发送Rollback,那么就会直接删除上面这条半消息。</p>
<p>如果因为网络等原因迟迟没有返回失败还是成功，那么会执行RocketMQ的回调接口,来进行事务的回查。</p>
<h2 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h2><h3 id="Broker端消息过滤"><a href="#Broker端消息过滤" class="headerlink" title="Broker端消息过滤"></a>Broker<strong>端消息过滤</strong></h3><p>在broker中，按照Consumer 的要求做过滤，优点是减少了对于 Consumer 无用消息的网络传输。缺点是增加了Broker的负担，实现相对复杂。</p>
<h3 id="Consumer-端消息过滤"><a href="#Consumer-端消息过滤" class="headerlink" title="Consumer 端消息过滤"></a>Consumer 端消息过滤</h3><p>这种过滤完全可由应用完全自定义实现，但是缺点是很多无用的消息要传到Consumer端</p>
<h2 id="Broker的Buffer问题"><a href="#Broker的Buffer问题" class="headerlink" title="Broker的Buffer问题"></a>Broker的Buffer问题</h2><p>Broker的buffer通常指的是Broker中一个队列的内存Buffer大小，这类Buffer通常大小有限。</p>
<p>另外，RokcetMq没有内存Buffer概念，RocketMq的队列都是持久化磁盘，数据定时清除。</p>
<p>RockertMq同其他mq有个非常显著的区别，RocketMq的内存Buffer抽象成一个无线长度的队列，不管有多少数据进来都能装得下，这个无线是有前提的，Broker会定期删除过期的数据。</p>
<p>例如Broker只保存三天的消息，那么Buffer长度虽然无线，但是3天前的数据会被从队尾删除。</p>
<h2 id="回溯消费"><a href="#回溯消费" class="headerlink" title="回溯消费"></a>回溯消费</h2><p>回溯消息是只Concumer已经消费成功的消息，由于业务上的需求需要重新消费，要支持此功能，Broker在向Consumer投递消息成功后，消息仍然需要保留。并且重新消费一般是按时间维度。</p>
<p>RocketMq支持按照时间回溯消费，可以精确到秒，可以向前，向后</p>
<h2 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h2><p>消息中间件的主要功能就是异步解耦，还有个重要功能是挡住前端的数据洪峰，保证后端系统的稳定性</p>
<p>消息堆积有两种</p>
<ul>
<li>堆积在内存Buffer，一旦超过内存Buffer，可以根据一定的丢弃策略来丢弃消息，这种情况堆积能力主要在于内存Buffer大小，而且消息堆积后，性能下降不大</li>
<li>堆积在持久化存储系统中，例如db，kv存储，文件记录形式。当消息不能再内存命cache命中时，要不可避免的访问磁盘，会产生大量读io，读io的吞吐量直接决定了消息堆积后的访问能力。</li>
</ul>
<p>评估消息堆积能力主要有以下四点：</p>
<ul>
<li>消息能堆积多少条，多少字节？即消息的堆积容量</li>
<li>消息堆积后，发消息的吞吐量大小，是否会受堆积影响？</li>
<li>正常消费的Consumer是否受影响</li>
<li>访问堆积在磁盘的消息是，吞吐量有多大？</li>
</ul>
<h2 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h2><p>定时消息是指消息发到Broker后，不能立刻被Consumer消费，要到特定的时间点或者等待特定的时间后才能被消费。</p>
<p>RocketMq支持定时消息，但是不支持任意时间精度，支持特定的level，例如5s,10s,1m等</p>
<p>如果要支持任意的时间精度，需要在Broker做，必须要做消息排序，再涉及到持久化，那么消息排序要不可避免的产生巨大性能开销</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM调优</title>
    <url>/2020/05/30/JVM%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<p><img src="JVM%E8%B0%83%E4%BC%98.png" alt="千字不如一图"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的类加载机制</title>
    <url>/2020/05/31/Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><img src="java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.png" alt="千字不如一图"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM垃圾回收算法与回收机制</title>
    <url>/2020/05/31/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><img src="JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.png" alt="千字不如一图"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM垃圾收集器</title>
    <url>/2020/05/31/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    <content><![CDATA[<p><img src="JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="千字不如一图"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程与JVM</title>
    <url>/2020/06/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8EJVM/</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="1、如何在Java中实现线程？"><a href="#1、如何在Java中实现线程？" class="headerlink" title="1、如何在Java中实现线程？"></a>1、如何在Java中实现线程？</h2><p>Tips：继承Thread、实现Runnable、实现Callable接口通过FutureTask包装器来创建Thread线程、线<br>程池。建议看源码消化；</p>
<h2 id="2、在具体多线程编程实践中，如何选用Runnable还是Thread？"><a href="#2、在具体多线程编程实践中，如何选用Runnable还是Thread？" class="headerlink" title="2、在具体多线程编程实践中，如何选用Runnable还是Thread？"></a>2、在具体多线程编程实践中，如何选用Runnable还是Thread？</h2><p>Tips：接口、类的区别。讲解服务熔断多线程ExceptionRatioDegradeDemo的代码示例。</p>
<h2 id="3、Thread类中的start-和run-方法有什么区别？"><a href="#3、Thread类中的start-和run-方法有什么区别？" class="headerlink" title="3、Thread类中的start()和run()方法有什么区别？"></a>3、Thread类中的start()和run()方法有什么区别？</h2><p>Tips：start就绪，run运行，掌握Thread的内部类State</p>
<h2 id="4、Java中Runnable和Callable有什么不同？"><a href="#4、Java中Runnable和Callable有什么不同？" class="headerlink" title="4、Java中Runnable和Callable有什么不同？"></a>4、Java中Runnable和Callable有什么不同？</h2><p>Tips：Runnable和Callable基于接口实现多线程，前者不带返回参数，后者带返回参数</p>
<h2 id="5、Java多线程中调用wait-和-sleep-方法有什么不同？"><a href="#5、Java多线程中调用wait-和-sleep-方法有什么不同？" class="headerlink" title="5、Java多线程中调用wait() 和 sleep()方法有什么不同？"></a>5、Java多线程中调用wait() 和 sleep()方法有什么不同？</h2><p>Tips：Wait、notify一起使用，sleep当前线程睡眠</p>
<h2 id="6、什么是Executor框架？"><a href="#6、什么是Executor框架？" class="headerlink" title="6、什么是Executor框架？"></a>6、什么是Executor框架？</h2><p>Tips：线程池框架，管理线程的生命周期。 Executor框架包含Executors，ExecutorService，CompletionService，<br>Future，Callable等 </p>
<h2 id="7、在Java中Executor和Executors的区别？"><a href="#7、在Java中Executor和Executors的区别？" class="headerlink" title="7、在Java中Executor和Executors的区别？"></a>7、在Java中Executor和Executors的区别？</h2><p>Tips：Executor是多线程自带的框架， Executors是Executor框架的工厂类，通过Executors创建不同类型的线程池</p>
<h2 id="8、Java中用到的线程调度算法是什么"><a href="#8、Java中用到的线程调度算法是什么" class="headerlink" title="8、Java中用到的线程调度算法是什么"></a>8、Java中用到的线程调度算法是什么</h2><p>Tips：对高优先级，使用优先调度的抢占式策略；同优先级线程组成先进先出队列（先到先服务），使用时间片策<br>略。</p>
<h2 id="9、什么是多线程中的上下文切换？"><a href="#9、什么是多线程中的上下文切换？" class="headerlink" title="9、什么是多线程中的上下文切换？"></a>9、什么是多线程中的上下文切换？</h2><p>Tips：CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换<br>前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加<br>载的过程就是一次上下文切换。</p>
<h2 id="10、什么是线程安全？"><a href="#10、什么是线程安全？" class="headerlink" title="10、什么是线程安全？"></a>10、什么是线程安全？</h2><p>Tips：多线程访问，有锁保护，不会出现数据不一致、数据污染等情况</p>
<h2 id="11、请说说有哪些线程不安全的java类？"><a href="#11、请说说有哪些线程不安全的java类？" class="headerlink" title="11、请说说有哪些线程不安全的java类？"></a>11、请说说有哪些线程不安全的java类？</h2><p>Tips： ArrayList(非)、Vector；HashMap(非)、HashTable</p>
<h2 id="12、Java中如何获取到线程dump文件？"><a href="#12、Java中如何获取到线程dump文件？" class="headerlink" title="12、Java中如何获取到线程dump文件？"></a>12、Java中如何获取到线程dump文件？</h2><p>Tips：jvm常见命令。 jmap -dump:format=b,file=文件名 [pid]。参考：<br><a href="https://www.cnblogs.com/0616--ataozhijia/p/4136312.html" target="_blank" rel="noopener">https://www.cnblogs.com/0616--ataozhijia/p/4136312.html</a></p>
<h2 id="13、池技术有什么作用，常见的池技术有哪些？"><a href="#13、池技术有什么作用，常见的池技术有哪些？" class="headerlink" title="13、池技术有什么作用，常见的池技术有哪些？"></a>13、池技术有什么作用，常见的池技术有哪些？</h2><p>tips：复用对象，节省创建、销毁资源的时间，提升性能</p>
<h2 id="14、请谈谈线程池的使用场景"><a href="#14、请谈谈线程池的使用场景" class="headerlink" title="14、请谈谈线程池的使用场景"></a>14、请谈谈线程池的使用场景</h2><p>tips：大量线程使用的场景，且线程执行的时间较短，特别耗时的操作会导致大量线程阻塞，甚<br>至导致系统宕机</p>
<h2 id="15、用线程池有什么好处？"><a href="#15、用线程池有什么好处？" class="headerlink" title="15、用线程池有什么好处？"></a>15、用线程池有什么好处？</h2><p>tips：线程的复用，节省线程的创建、销毁时间，提升性能。参考jason java多线程.ppt</p>
<h2 id="16、线程池的技术原理是什么？"><a href="#16、线程池的技术原理是什么？" class="headerlink" title="16、线程池的技术原理是什么？"></a>16、线程池的技术原理是什么？</h2><p>Tips：读ThreadPoolExecutor源码，了解execute 方法，掌握线程池的原理示意图。<br>可参考： <a href="https://www.cnblogs.com/cm4j/p/thread-pool.html" target="_blank" rel="noopener">https://www.cnblogs.com/cm4j/p/thread-pool.html</a></p>
<h2 id="17、线程池有哪些种类，各自的使用场景是什么？"><a href="#17、线程池有哪些种类，各自的使用场景是什么？" class="headerlink" title="17、线程池有哪些种类，各自的使用场景是什么？"></a>17、线程池有哪些种类，各自的使用场景是什么？</h2><p>tips：掌握excutors，读源码。参考jason java多线程.ppt</p>
<h2 id="18、线程池有哪些重要的参数？"><a href="#18、线程池有哪些重要的参数？" class="headerlink" title="18、线程池有哪些重要的参数？"></a>18、线程池有哪些重要的参数？</h2><p>Tips：掌握ThreadPoolExecutor， corePoolSize、maximumPoolSize、keepAliveTime</p>
<h2 id="19、你们在具体的设计开发过程中是如何设置这些重要参数的？"><a href="#19、你们在具体的设计开发过程中是如何设置这些重要参数的？" class="headerlink" title="19、你们在具体的设计开发过程中是如何设置这些重要参数的？"></a>19、你们在具体的设计开发过程中是如何设置这些重要参数的？</h2><p>Tips： corePoolSize、maximumPoolSize和cpu、内存有关系，考虑到一定的冗余，宁可小不可大。</p>
<h2 id="20、单例的使用场景是什么，如何实现单例？"><a href="#20、单例的使用场景是什么，如何实现单例？" class="headerlink" title="20、单例的使用场景是什么，如何实现单例？"></a>20、单例的使用场景是什么，如何实现单例？</h2><p>Tips：高性能、节省重量级操作的资源、唯一实例，手写</p>
<h2 id="21、如何在Java中创建线程安全的Singleton？"><a href="#21、如何在Java中创建线程安全的Singleton？" class="headerlink" title="21、如何在Java中创建线程安全的Singleton？"></a>21、如何在Java中创建线程安全的Singleton？</h2><p>Tips：注意线程安全条件下的单例写法</p>
<h2 id="22、synchronzied关键词的使用"><a href="#22、synchronzied关键词的使用" class="headerlink" title="22、synchronzied关键词的使用"></a>22、synchronzied关键词的使用</h2><p>Tips：悲观锁，保证线程安全。参考： <a href="https://blog.csdn.net/aa792978017/article/details/88835512" target="_blank" rel="noopener">https://blog.csdn.net/aa792978017/article/details/88835512</a></p>
<h2 id="23、ReentrantLock和synchronized使用的场景是什么，机制有何不同？"><a href="#23、ReentrantLock和synchronized使用的场景是什么，机制有何不同？" class="headerlink" title="23、ReentrantLock和synchronized使用的场景是什么，机制有何不同？"></a>23、ReentrantLock和synchronized使用的场景是什么，机制有何不同？</h2><p>Tips：二者都是锁， ReentrantLock基于CAS的乐观锁， synchronized是悲观锁。建议读<br>ReentrantLock源码，理解记忆。演示Counter7。</p>
<h2 id="24、什么是ThreadLocal变量？"><a href="#24、什么是ThreadLocal变量？" class="headerlink" title="24、什么是ThreadLocal变量？"></a>24、什么是ThreadLocal变量？</h2><p>Tips： ThreadLocal用于保存某个线程共享变量。不同线程只能从中get，set，remove自己的变量，<br>而不会影响其他线程的变量。讲解ThreadLocal的set、get、remove方法。</p>
<h2 id="25、ThreadLocal技术原理是什么，它在架构中常常用来做什么？"><a href="#25、ThreadLocal技术原理是什么，它在架构中常常用来做什么？" class="headerlink" title="25、ThreadLocal技术原理是什么，它在架构中常常用来做什么？"></a>25、ThreadLocal技术原理是什么，它在架构中常常用来做什么？</h2><p>tips： 读ThreadLocal ，理解ThreadLocalMap。 参考jason 16、ThreadLocal原理及在多层架构中的应<br>                                                 用</p>
<h2 id="26、volatile适用于高并发的什么场景？"><a href="#26、volatile适用于高并发的什么场景？" class="headerlink" title="26、volatile适用于高并发的什么场景？"></a>26、volatile适用于高并发的什么场景？</h2><p>Tips：轻量级锁，状态位。讲解服务熔断多线程ExceptionCountDegradeDemo的代码示例。</p>
<h2 id="27、CountDownLatch用于多线程的什么场景？"><a href="#27、CountDownLatch用于多线程的什么场景？" class="headerlink" title="27、CountDownLatch用于多线程的什么场景？"></a>27、CountDownLatch用于多线程的什么场景？</h2><p>Tips:线程计数、线程等待。建议阅读CountDownLatch，讲解Counter1示例.</p>
<h2 id="28、java多线程有哪些常见的锁，各自用法是什么？"><a href="#28、java多线程有哪些常见的锁，各自用法是什么？" class="headerlink" title="28、java多线程有哪些常见的锁，各自用法是什么？"></a>28、java多线程有哪些常见的锁，各自用法是什么？</h2><p>tips：至少有五种， volatile 、synchronized 、 ReentrantLock 、 Condition、 ReadWriteLock</p>
<h2 id="29、多线程join方法用于什么场景？"><a href="#29、多线程join方法用于什么场景？" class="headerlink" title="29、多线程join方法用于什么场景？"></a>29、多线程join方法用于什么场景？</h2><p>Tips:控制线程顺序，讲解Thread的join源码。讲解JoinTest示例</p>
<h2 id="30、java多线程中让所有子线程执行完毕的方法有哪几种？"><a href="#30、java多线程中让所有子线程执行完毕的方法有哪几种？" class="headerlink" title="30、java多线程中让所有子线程执行完毕的方法有哪几种？"></a>30、java多线程中让所有子线程执行完毕的方法有哪几种？</h2><p>tips：至少有两种。线程的sleep、join。</p>
<h2 id="31、高并发环境下的计数器如何实现？"><a href="#31、高并发环境下的计数器如何实现？" class="headerlink" title="31、高并发环境下的计数器如何实现？"></a>31、高并发环境下的计数器如何实现？</h2><p>Tips：至少有6种实现方式。讲解counter包下的代码示例。复习 CountDownLatch、AtomicInteger、<br>synchronized、ReentrantLock、线程状态。</p>
<h2 id="32、HashTable、HashMap、ConcurrentHashMap各自的技术原理和使用场景是什么？"><a href="#32、HashTable、HashMap、ConcurrentHashMap各自的技术原理和使用场景是什么？" class="headerlink" title="32、HashTable、HashMap、ConcurrentHashMap各自的技术原理和使用场景是什么？"></a>32、HashTable、HashMap、ConcurrentHashMap各自的技术原理和使用场景是什么？</h2><p>Tips： 建议看源码。HashTable线程安全、悲观锁，锁整个hash表的数据，效率低；ConcurrentHashMap线程<br>安全、乐观锁，分段锁； HashMap非线程安全； 可参考：<a href="https://www.cnblogs.com/zq-boke/p/8654539.html" target="_blank" rel="noopener">https://www.cnblogs.com/zq-boke/p/8654539.html</a></p>
<h2 id="33、LinkedBlockingQueue、ConcurrentLinkedQueue各自技术原理和使用场景是什么？"><a href="#33、LinkedBlockingQueue、ConcurrentLinkedQueue各自技术原理和使用场景是什么？" class="headerlink" title="33、LinkedBlockingQueue、ConcurrentLinkedQueue各自技术原理和使用场景是什么？"></a>33、LinkedBlockingQueue、ConcurrentLinkedQueue各自技术原理和使用场景是什么？</h2><p>Tips： 前者：阻塞队列，用于生产消费者模式； 后者：并发队列，用于高并发场景。</p>
<h2 id="34、-Java中如何停止一个线程？"><a href="#34、-Java中如何停止一个线程？" class="headerlink" title="34、 Java中如何停止一个线程？"></a>34、 Java中如何停止一个线程？</h2><p>Tips：stop（不推荐）、状态位、interrupt。讲解ThreadStop1、 ThreadStop2。</p>
<h2 id="35、Java中Semaphore是什么？"><a href="#35、Java中Semaphore是什么？" class="headerlink" title="35、Java中Semaphore是什么？"></a>35、Java中Semaphore是什么？</h2><p>Tips：信号量，用于访问限制可以访问某些资源（物理或逻辑的）线程数目。讲解SemaphoreTest。</p>
<h2 id="36、java多线程中有哪些并发流量控制工具类？"><a href="#36、java多线程中有哪些并发流量控制工具类？" class="headerlink" title="36、java多线程中有哪些并发流量控制工具类？"></a>36、java多线程中有哪些并发流量控制工具类？</h2><p>tips：至少有三种。 CountDownLatch、Semaphore 、CyclicBarrier</p>
<h2 id="37、高并发场景下，如何理解每一个线程执行的逻辑耗时不能过长？"><a href="#37、高并发场景下，如何理解每一个线程执行的逻辑耗时不能过长？" class="headerlink" title="37、高并发场景下，如何理解每一个线程执行的逻辑耗时不能过长？"></a>37、高并发场景下，如何理解每一个线程执行的逻辑耗时不能过长？</h2><p>Tips：如果每一个线程执行的逻辑耗时过长，会导致大量线程阻塞，性能急剧下降，系统可用性<br>存在风险，存在宕机的可能性。</p>
<h2 id="38、什么是线程非安全？"><a href="#38、什么是线程非安全？" class="headerlink" title="38、什么是线程非安全？"></a>38、什么是线程非安全？</h2><p>Tips：不提供数据访问保护，多个线程写数据造成所得到的数据是脏数据。</p>
<h2 id="39、在微服务的分布式架构中，设置服务的超时时间有什么好处？"><a href="#39、在微服务的分布式架构中，设置服务的超时时间有什么好处？" class="headerlink" title="39、在微服务的分布式架构中，设置服务的超时时间有什么好处？"></a>39、在微服务的分布式架构中，设置服务的超时时间有什么好处？</h2><p>Tips：防止大量线程阻塞导致系统宕机。</p>
<h2 id="40、常见的多线程数据结构有哪些，你用过其中的哪些多线程数据结构？"><a href="#40、常见的多线程数据结构有哪些，你用过其中的哪些多线程数据结构？" class="headerlink" title="40、常见的多线程数据结构有哪些，你用过其中的哪些多线程数据结构？"></a>40、常见的多线程数据结构有哪些，你用过其中的哪些多线程数据结构？</h2><p>tips：建议多读concurrent包下的源码。 ConcurrentHashMap、LinkedBlockingQueue、<br>ConcurrentLinkedQueue、Semaphore等</p>
<h2 id="41、多线程的常见设计模式，你用过其中的哪些设计模式"><a href="#41、多线程的常见设计模式，你用过其中的哪些设计模式" class="headerlink" title="41、多线程的常见设计模式，你用过其中的哪些设计模式"></a>41、多线程的常见设计模式，你用过其中的哪些设计模式</h2><p>tips：掌握三种最常见的多线程设计模式。</p>
<h2 id="42、什么是Master-Worker模式？如何实现Master-Worker模式？"><a href="#42、什么是Master-Worker模式？如何实现Master-Worker模式？" class="headerlink" title="42、什么是Master-Worker模式？如何实现Master-Worker模式？"></a>42、什么是Master-Worker模式？如何实现Master-Worker模式？</h2><p>Tips：大任务的并发分解、结果合并。掌握Master-Worker 设计模式原理图。讲解PlusWorker、<br>Master相关代码。</p>
<h2 id="43、什么是Producer-Consumer模式？如何实现Producer-Consumer模式？"><a href="#43、什么是Producer-Consumer模式？如何实现Producer-Consumer模式？" class="headerlink" title="43、什么是Producer-Consumer模式？如何实现Producer-Consumer模式？"></a>43、什么是Producer-Consumer模式？如何实现Producer-Consumer模式？</h2><p>Tips：利用缓冲区对生产者、消费者解耦。掌握生产消费者原理图。讲解Producer、 Consumer</p>
<h2 id="44、什么是Future模式？如何实现Future模式？"><a href="#44、什么是Future模式？如何实现Future模式？" class="headerlink" title="44、什么是Future模式？如何实现Future模式？"></a>44、什么是Future模式？如何实现Future模式？</h2><p>Tips：适合异步耗时的场景。阅读并掌握Excutors、ExecutorService、FutureTask。</p>
<h2 id="45、多线程使用场景是什么？"><a href="#45、多线程使用场景是什么？" class="headerlink" title="45、多线程使用场景是什么？"></a>45、多线程使用场景是什么？</h2><p>Tips：并发场景、”小逻辑”、性能提升。</p>
<h2 id="46、多线程有什么优缺点？"><a href="#46、多线程有什么优缺点？" class="headerlink" title="46、多线程有什么优缺点？"></a>46、多线程有什么优缺点？</h2><p>Tips：优点：提升性能；缺点：门槛高，特别是锁，滥用线程会产生死锁、影响性能甚至宕机，<br>线程切换耗性能；</p>
<h2 id="47、假设某系统的某个接口的峰值TPS为2w-s-其它接口的并发峰值至多为200每秒-，且该接口会"><a href="#47、假设某系统的某个接口的峰值TPS为2w-s-其它接口的并发峰值至多为200每秒-，且该接口会" class="headerlink" title="47、假设某系统的某个接口的峰值TPS为2w/s(其它接口的并发峰值至多为200每秒)，且该接口会"></a>47、假设某系统的某个接口的峰值TPS为2w/s(其它接口的并发峰值至多为200每秒)，且该接口会</h2><p>保存数据至数据库，如何提升该接口的性能？<br>Tips：线程池、多线程、分页、批处理。讲解thunder中间件的ThunderEngine源码。</p>
<h2 id="48、是否熟悉java-concurrent包的内容，请讲讲concurrent包有哪些重要的内容？"><a href="#48、是否熟悉java-concurrent包的内容，请讲讲concurrent包有哪些重要的内容？" class="headerlink" title="48、是否熟悉java concurrent包的内容，请讲讲concurrent包有哪些重要的内容？"></a>48、是否熟悉java concurrent包的内容，请讲讲concurrent包有哪些重要的内容？</h2><p>Tips：建议多阅读java concurrent包的内容。</p>
<h2 id="49、请讲讲并发编程的CAS理论"><a href="#49、请讲讲并发编程的CAS理论" class="headerlink" title="49、请讲讲并发编程的CAS理论"></a>49、请讲讲并发编程的CAS理论</h2><p>tips： Compare And Swap、乐观锁机制、jdk的Unsafe类执行这些操作、Doug Lea、 concurrent 包<br>的重要理论基石。</p>
<h2 id="50、请讲讲并发队列和阻塞队列"><a href="#50、请讲讲并发队列和阻塞队列" class="headerlink" title="50、请讲讲并发队列和阻塞队列"></a>50、请讲讲并发队列和阻塞队列</h2><p>tips： ConcurrentLinkedQueue、 LinkedBlockingQueue。掌握原理。</p>
<h2 id="51、多线程yield方法使用于什么场景？"><a href="#51、多线程yield方法使用于什么场景？" class="headerlink" title="51、多线程yield方法使用于什么场景？"></a>51、多线程yield方法使用于什么场景？</h2><p>Tips： yield：让步，线程等待。</p>
<h2 id="52、请讲讲线程异步处理的原理及关键组件？"><a href="#52、请讲讲线程异步处理的原理及关键组件？" class="headerlink" title="52、请讲讲线程异步处理的原理及关键组件？"></a>52、请讲讲线程异步处理的原理及关键组件？</h2><p>Tips：异步耗时的操作。读源码并掌握Excutors、ExecutorService、FutureTask。</p>
<h2 id="53、在实际项目（产品）研发过程中，你是否有使用过多线程，和线程池，如果有，请举例说明"><a href="#53、在实际项目（产品）研发过程中，你是否有使用过多线程，和线程池，如果有，请举例说明" class="headerlink" title="53、在实际项目（产品）研发过程中，你是否有使用过多线程，和线程池，如果有，请举例说明"></a>53、在实际项目（产品）研发过程中，你是否有使用过多线程，和线程池，如果有，请举例说明</h2><p>Tips：通用常见的技术场景：批量数据的处理。建议用STAR模型回答。</p>
<h2 id="54、什么是多线程的原子操作？"><a href="#54、什么是多线程的原子操作？" class="headerlink" title="54、什么是多线程的原子操作？"></a>54、什么是多线程的原子操作？</h2><p>Tips：基于cas的最基本的操作。阅读AtomicInteger的代码头说明并讲解AtomicInteger的CAS机制。</p>
<h2 id="55、Java-中有哪些原子操作？"><a href="#55、Java-中有哪些原子操作？" class="headerlink" title="55、Java 中有哪些原子操作？"></a>55、Java 中有哪些原子操作？</h2><p>Tips： AtomicInteger、 AtomicLong、AtomicBoolean、 AtomicIntegerArray等等</p>
<h2 id="56、多线程原子操作类使用场景是什么，你在项目的实际研发过程中是否有使用"><a href="#56、多线程原子操作类使用场景是什么，你在项目的实际研发过程中是否有使用" class="headerlink" title="56、多线程原子操作类使用场景是什么，你在项目的实际研发过程中是否有使用"></a>56、多线程原子操作类使用场景是什么，你在项目的实际研发过程中是否有使用</h2><p>过原子操作类？<br>Tips：并发计数，比如：微服务场景下的服务监控的统计。</p>
<h2 id="57、如何在多个线程间共享数据？"><a href="#57、如何在多个线程间共享数据？" class="headerlink" title="57、如何在多个线程间共享数据？"></a>57、如何在多个线程间共享数据？</h2><p>Tips：多个线程之间传参，共享变量；或者内部类；运行MultyThreadShareDateTest。</p>
<h2 id="58、线程的状态有哪些，线程状态的使用场景是什么？"><a href="#58、线程的状态有哪些，线程状态的使用场景是什么？" class="headerlink" title="58、线程的状态有哪些，线程状态的使用场景是什么？"></a>58、线程的状态有哪些，线程状态的使用场景是什么？</h2><p>Tips：建议阅读Thread类及其内部类State。讲解woker-master的Master类</p>
<h2 id="59、有多个线程T1，T2，T3，怎么确保它们按顺序执行？"><a href="#59、有多个线程T1，T2，T3，怎么确保它们按顺序执行？" class="headerlink" title="59、有多个线程T1，T2，T3，怎么确保它们按顺序执行？"></a>59、有多个线程T1，T2，T3，怎么确保它们按顺序执行？</h2><p>tips：参考JoinTest</p>
<h2 id="60、wait-notify-notifyAll一般使用于什么场景？"><a href="#60、wait-notify-notifyAll一般使用于什么场景？" class="headerlink" title="60、wait/notify/notifyAll一般使用于什么场景？"></a>60、wait/notify/notifyAll一般使用于什么场景？</h2><p>Tips：悲观锁，和synchronize关键字联合使用，不建议使用，编程复杂。</p>
<h1 id="JVM复习题"><a href="#JVM复习题" class="headerlink" title="JVM复习题"></a>JVM复习题</h1><h2 id="1、请说说jvm的基本结构"><a href="#1、请说说jvm的基本结构" class="headerlink" title="1、请说说jvm的基本结构"></a>1、请说说jvm的基本结构</h2><p>Tips：建议掌握jvm的基本结构图。java类加载器、方法区、堆、直接内存、java栈、本地方法栈、<br>PC寄存器、执行引擎。参考jason的JVM基础知识及性能调优.ppt。 </p>
<h2 id="2、什么是JVM-？"><a href="#2、什么是JVM-？" class="headerlink" title="2、什么是JVM ？"></a>2、什么是JVM ？</h2><p>Tips：Java Virtual Machine。Java应用和操作系统之间的桥梁。</p>
<h2 id="3、堆空间的结构"><a href="#3、堆空间的结构" class="headerlink" title="3、堆空间的结构"></a>3、堆空间的结构</h2><p>Tips:Eden、S0、S1、tenured(Old Gerneration)。记忆技巧：按照时间来分。参考jason的JVM基础<br>知识及性能调优.ppt。 </p>
<h2 id="4、Java中堆和栈有什么区别？"><a href="#4、Java中堆和栈有什么区别？" class="headerlink" title="4、Java中堆和栈有什么区别？"></a>4、Java中堆和栈有什么区别？</h2><p>Tips：堆主要用于管理对象，栈主要用来管理方法区相关的局部变量。参考：<br><a href="https://www.cnblogs.com/ibelieve618/p/6380328.html" target="_blank" rel="noopener">https://www.cnblogs.com/ibelieve618/p/6380328.html</a></p>
<h2 id="5、为何新生代要设置两个survivor区，jvm的设计上有何目的？"><a href="#5、为何新生代要设置两个survivor区，jvm的设计上有何目的？" class="headerlink" title="5、为何新生代要设置两个survivor区，jvm的设计上有何目的？"></a>5、为何新生代要设置两个survivor区，jvm的设计上有何目的？</h2><p>Tips:复制算法</p>
<h2 id="6、垃圾回收中的复制算法适用于在什么场景下使用？"><a href="#6、垃圾回收中的复制算法适用于在什么场景下使用？" class="headerlink" title="6、垃圾回收中的复制算法适用于在什么场景下使用？"></a>6、垃圾回收中的复制算法适用于在什么场景下使用？</h2><p>Tips:年轻代的垃圾回收。参考jason的JVM基础知识及性能调优.ppt。 </p>
<h2 id="7、老年代的垃圾回收一般用什么算法？"><a href="#7、老年代的垃圾回收一般用什么算法？" class="headerlink" title="7、老年代的垃圾回收一般用什么算法？"></a>7、老年代的垃圾回收一般用什么算法？</h2><p>Tips:标记清除算法、标记压缩算法。参考jason的JVM基础知识及性能调优.ppt。 </p>
<h2 id="8、-java方法栈和本地方法栈的区别？"><a href="#8、-java方法栈和本地方法栈的区别？" class="headerlink" title="8、 java方法栈和本地方法栈的区别？"></a>8、 java方法栈和本地方法栈的区别？</h2><p>Tips: 前者是java方法的调用，后者是java调用native方法，比如操作系统、dll等相关的c语<br>言的方法。</p>
<h2 id="9、GC回收机制？"><a href="#9、GC回收机制？" class="headerlink" title="9、GC回收机制？"></a>9、GC回收机制？</h2><p>Tips:垃圾回收算法、垃圾收集器。</p>
<h2 id="10、top、jmap、jstat、jstack命令各自有什么用途？"><a href="#10、top、jmap、jstat、jstack命令各自有什么用途？" class="headerlink" title="10、top、jmap、jstat、jstack命令各自有什么用途？"></a>10、top、jmap、jstat、jstack命令各自有什么用途？</h2><p>Tips:top系统整体资源使用情况，jmap导出堆到文件，jstat查看jvm运行情况，jstack导出 线程堆栈到文件。</p>
<h2 id="11、有哪些常见的jvm命令，说说各自的用途是什么？"><a href="#11、有哪些常见的jvm命令，说说各自的用途是什么？" class="headerlink" title="11、有哪些常见的jvm命令，说说各自的用途是什么？"></a>11、有哪些常见的jvm命令，说说各自的用途是什么？</h2><p>Tips:掌握jstat、jmap、jstack、jinfo等jvm命令。</p>
<h2 id="12、GC有哪些算法。"><a href="#12、GC有哪些算法。" class="headerlink" title="12、GC有哪些算法。"></a>12、GC有哪些算法。</h2><p>Tips:复制算法、标记算法、标记压缩算法、分代算法。</p>
<h2 id="13、什么是线程中断。"><a href="#13、什么是线程中断。" class="headerlink" title="13、什么是线程中断。"></a>13、什么是线程中断。</h2><p>Tips: stop the world，简称STW，垃圾回收的停顿，参考 billy 1.GC算法与种类</p>
<h2 id="14、MGC、FGC分别是什么意思，它们在什么情况下会发生？"><a href="#14、MGC、FGC分别是什么意思，它们在什么情况下会发生？" class="headerlink" title="14、MGC、FGC分别是什么意思，它们在什么情况下会发生？"></a>14、MGC、FGC分别是什么意思，它们在什么情况下会发生？</h2><p>Tips：年轻代垃圾回收、老年代垃圾回收。参考jason JVM基础知识及性能调优</p>
<h2 id="15、请讲讲jvm的分代，为什么要分代，jvm分代有什么好处？"><a href="#15、请讲讲jvm的分代，为什么要分代，jvm分代有什么好处？" class="headerlink" title="15、请讲讲jvm的分代，为什么要分代，jvm分代有什么好处？"></a>15、请讲讲jvm的分代，为什么要分代，jvm分代有什么好处？</h2><p>Tips：根据对象的实际情况采用不同的分代。掌握分代的临界值变量。参考jason<br>JVM基础知识及性能调优.PPT</p>
<h2 id="16、你知道哪些jvm调优工具么？"><a href="#16、你知道哪些jvm调优工具么？" class="headerlink" title="16、你知道哪些jvm调优工具么？"></a>16、你知道哪些jvm调优工具么？</h2><p>Tips：VisualVM、Jconsole、MAT。参考性能监控工具.ppt</p>
<h2 id="17、在jvm中，年轻代如何向老年代转变的，转换的重要参数是什么"><a href="#17、在jvm中，年轻代如何向老年代转变的，转换的重要参数是什么" class="headerlink" title="17、在jvm中，年轻代如何向老年代转变的，转换的重要参数是什么?"></a>17、在jvm中，年轻代如何向老年代转变的，转换的重要参数是什么?</h2><p>Tips：年龄累加、 MaxTenuringThreshold。参考jason JVM基础知识及性能调优.PPT</p>
<h2 id="18、直接内存使用场景是什么，使用直接内存可能会存在什么问题？"><a href="#18、直接内存使用场景是什么，使用直接内存可能会存在什么问题？" class="headerlink" title="18、直接内存使用场景是什么，使用直接内存可能会存在什么问题？"></a>18、直接内存使用场景是什么，使用直接内存可能会存在什么问题？</h2><p>Tips：java原生、netty、mina等相关的NIO操作。参考jason JVM基础知识及性能调优.PPT</p>
<h2 id="19、堆内存有哪些重要参数？"><a href="#19、堆内存有哪些重要参数？" class="headerlink" title="19、堆内存有哪些重要参数？"></a>19、堆内存有哪些重要参数？</h2><p>Tips: -Xms(初始堆大小)、 -Xmx(最大堆大小)</p>
<h2 id="20、如何设置堆大小，是否有一些经验值？"><a href="#20、如何设置堆大小，是否有一些经验值？" class="headerlink" title="20、如何设置堆大小，是否有一些经验值？"></a>20、如何设置堆大小，是否有一些经验值？</h2><p>Tips:堆内存至少可以设置为整个内存的一半大小，甚至2/3大小。</p>
<h2 id="21、如何打印JVM日志？"><a href="#21、如何打印JVM日志？" class="headerlink" title="21、如何打印JVM日志？"></a>21、如何打印JVM日志？</h2><p>Tips: -XX:+PrintGC、-XX:+PrintGCDetails、-XX:+PrintGCTimeStamps、-XX:+PrintGCDateStamps。演示<br>DirectBufferOOM</p>
<h2 id="22、请介绍常见的jvm参数"><a href="#22、请介绍常见的jvm参数" class="headerlink" title="22、请介绍常见的jvm参数"></a>22、请介绍常见的jvm参数</h2><p>Tips：堆内存参数、年轻代参数、日志参数、直接内存参数等等。参考jason JVM基础知识及性能<br>调优.PPT </p>
<h2 id="23、CMS收集器有什么特点？"><a href="#23、CMS收集器有什么特点？" class="headerlink" title="23、CMS收集器有什么特点？"></a>23、CMS收集器有什么特点？</h2><p>Tips:老年代、并发收集、低停顿。</p>
<h2 id="24、G1收集器有什么特点？"><a href="#24、G1收集器有什么特点？" class="headerlink" title="24、G1收集器有什么特点？"></a>24、G1收集器有什么特点？</h2><p>Tips:年轻代和老年代，最新的垃圾回收算法，较综合。</p>
<h2 id="25、垃圾回收器有哪些？"><a href="#25、垃圾回收器有哪些？" class="headerlink" title="25、垃圾回收器有哪些？"></a>25、垃圾回收器有哪些？</h2><p>Tips: Serial、Parallel 、CMS、G1。参考jason JVM基础知识及性能调优.PPT</p>
<h2 id="26、java内存模型"><a href="#26、java内存模型" class="headerlink" title="26、java内存模型"></a>26、java内存模型</h2><p>Tips:多个线程通信、同步、happens-before原则(volatile、join)。参考：<br><a href="https://www.cnblogs.com/yuanfy008/p/9252555.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanfy008/p/9252555.html</a></p>
<h2 id="27、什么是类加载器，类加载器有哪些，类加载器的加载顺序是什么？"><a href="#27、什么是类加载器，类加载器有哪些，类加载器的加载顺序是什么？" class="headerlink" title="27、什么是类加载器，类加载器有哪些，类加载器的加载顺序是什么？"></a>27、什么是类加载器，类加载器有哪些，类加载器的加载顺序是什么？</h2><p>Tips：将类的.class文件中的二进制数据读入到内存。三种类加载器：BootstrapClassLoader-&gt;ExtClassLoader-&gt;<br>AppClassLoader ，演示ClassLoaderTest，熟悉rt.jar的Launcher、Classloader。参考：<br><a href="https://www.cnblogs.com/heyanan/p/6123279.html" target="_blank" rel="noopener">https://www.cnblogs.com/heyanan/p/6123279.html</a></p>
<h2 id="28、简述java内存分配与回收策略"><a href="#28、简述java内存分配与回收策略" class="headerlink" title="28、简述java内存分配与回收策略"></a>28、简述java内存分配与回收策略</h2><p>Tips：年轻代，老年代，小对象，大对象。 参考：<a href="https://segmentfault.com/a/1190000014944731" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014944731</a></p>
<h2 id="29、Perm-Space中保存什么数据？会引起OutOfMemory吗？"><a href="#29、Perm-Space中保存什么数据？会引起OutOfMemory吗？" class="headerlink" title="29、Perm Space中保存什么数据？会引起OutOfMemory吗？"></a>29、Perm Space中保存什么数据？会引起OutOfMemory吗？</h2><p>Tips:类加载数据。永久代内存过小，会导致OOM。</p>
<h2 id="30、是否有做过jvm参数方面的调优，如果有，请举例说明。"><a href="#30、是否有做过jvm参数方面的调优，如果有，请举例说明。" class="headerlink" title="30、是否有做过jvm参数方面的调优，如果有，请举例说明。"></a>30、是否有做过jvm参数方面的调优，如果有，请举例说明。</h2><p>Tips：最好用star面试模型。设置堆内存参数、直接内存参数、eclipse、tomcat的相关的jvm参数等等。</p>
<h2 id="31、内存溢出的根本原因是什么，该如何解决？"><a href="#31、内存溢出的根本原因是什么，该如何解决？" class="headerlink" title="31、内存溢出的根本原因是什么，该如何解决？"></a>31、内存溢出的根本原因是什么，该如何解决？</h2><p>Tips:jvm的相关资源不够用，导致内存溢出。解决程序错误、调整参数、分布式架构(大数据、微服务架构，<br>本质都是多台机器分布式计算或者处理相关程序逻辑)。</p>
<h2 id="32、简述java类加载机制"><a href="#32、简述java类加载机制" class="headerlink" title="32、简述java类加载机制"></a>32、简述java类加载机制</h2><p>Tips：熟悉Launcher 、ClassLoader源码理解记忆。</p>
<h2 id="33、GC收集器有哪些？CMS收集器与G1收集器的特点"><a href="#33、GC收集器有哪些？CMS收集器与G1收集器的特点" class="headerlink" title="33、GC收集器有哪些？CMS收集器与G1收集器的特点"></a>33、GC收集器有哪些？CMS收集器与G1收集器的特点</h2><p>Tips:从内存年代、回收算法、线程数等角度整体理解记忆。参考：<br><a href="https://blog.csdn.net/qq_35503221/article/details/80313129" target="_blank" rel="noopener">https://blog.csdn.net/qq_35503221/article/details/80313129</a></p>
<h2 id="34、类加载器双亲委派模型机制是什么？"><a href="#34、类加载器双亲委派模型机制是什么？" class="headerlink" title="34、类加载器双亲委派模型机制是什么？"></a>34、类加载器双亲委派模型机制是什么？</h2><p>Tips：熟悉ClassLoader的loadClass() 。 参考：<a href="https://blog.csdn.net/weixin_38118016/article/details/79579657" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38118016/article/details/79579657</a></p>
<h2 id="35、什么情况下会出现永久代内存溢出，如何解决此类问题？"><a href="#35、什么情况下会出现永久代内存溢出，如何解决此类问题？" class="headerlink" title="35、什么情况下会出现永久代内存溢出，如何解决此类问题？"></a>35、什么情况下会出现永久代内存溢出，如何解决此类问题？</h2><p>Tips: jar包过多、加载大量class文件，永久代内存参数过小。增加JVM的PermSize和MaxPermSize参数大小。<br>演示PermTest、PermTest2、 PermTest3。</p>
<h2 id="36、什么情况下会出现堆内存溢出，如何解决此类问题？"><a href="#36、什么情况下会出现堆内存溢出，如何解决此类问题？" class="headerlink" title="36、什么情况下会出现堆内存溢出，如何解决此类问题？"></a>36、什么情况下会出现堆内存溢出，如何解决此类问题？</h2><p>Tips:参考jason JVM基础知识及性能调优.PPT。演示 HeapOOMTest。</p>
<h2 id="37、什么情况下会出现直接内存溢出，如何解决此类问题？"><a href="#37、什么情况下会出现直接内存溢出，如何解决此类问题？" class="headerlink" title="37、什么情况下会出现直接内存溢出，如何解决此类问题？"></a>37、什么情况下会出现直接内存溢出，如何解决此类问题？</h2><p>Tips:参考jason JVM基础知识及性能调优.PPT。演示 DirectBufferOOM 。</p>
<h2 id="38、什么情况下会出现过多线程导致内存溢出的问题，如何解决此类问题？"><a href="#38、什么情况下会出现过多线程导致内存溢出的问题，如何解决此类问题？" class="headerlink" title="38、什么情况下会出现过多线程导致内存溢出的问题，如何解决此类问题？"></a>38、什么情况下会出现过多线程导致内存溢出的问题，如何解决此类问题？</h2><p>Tips:参考jason JVM基础知识及性能调优.PPT。</p>
<h2 id="39、什么情况下会出现CPU使用率过高的问题，如何解决此类问题？"><a href="#39、什么情况下会出现CPU使用率过高的问题，如何解决此类问题？" class="headerlink" title="39、什么情况下会出现CPU使用率过高的问题，如何解决此类问题？"></a>39、什么情况下会出现CPU使用率过高的问题，如何解决此类问题？</h2><p>Tips:参考jason JVM基础知识及性能调优.PPT。</p>
<h2 id="40、OOM有哪些可能，应该如何处理。"><a href="#40、OOM有哪些可能，应该如何处理。" class="headerlink" title="40、OOM有哪些可能，应该如何处理。"></a>40、OOM有哪些可能，应该如何处理。</h2><p>Tips：该问题比较综合，参考Jason JVM基础知识及性能调优.PPT</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>多线程，JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql误删一条数据如何恢复</title>
    <url>/2020/06/27/mysql%E8%AF%AF%E5%88%A0%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<h1 id="误删了一条数据或一个表如何恢复"><a href="#误删了一条数据或一个表如何恢复" class="headerlink" title="误删了一条数据或一个表如何恢复"></a>误删了一条数据或一个表如何恢复</h1><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>读断舍离有感</title>
    <url>/2020/07/20/%E8%AF%BB%E6%96%AD%E8%88%8D%E7%A6%BB%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<p>   近日在老师的推荐下，有幸读了蔡雪莲老师的断舍离。感觉受益良多。特此记录。</p>
<p>   全书从断、舍、离三个方面阐述了如何做人及做事的道理。断指的是断绝繁杂，从是什么，为什么，怎么做三个发方面论述。舍指的是舍弃重负，人生就是一场旅行，行李越重，走的越艰辛。咱得学会做选择，舍弃一些不必要的，知道啥是自己真正需要的。啥都想要的 结果就是啥都得不到。一份耕耘一份收获！离：就是舍弃执念。这个观点使我不由的想起《金刚经》的精髓：”应无所住，而生其心”。我的理解：离并不是没有原则，啥都不坚持，而是老师说的”方法论”换个方法，再试！一件事儿成与不成！方法很重要。为同一个目标尝试多种方法，从而取最优解，比对所有目标用一个方法好的多。很简单的一个例子就是：一个经验用十年还是十年经验是不同的。别给自己设限，敢于尝试，乐于尝试！我行！</p>
<p>   读书真的就是交朋友，通过一个朋友认识另一个朋友。通过一本书，了解另一本书。人生三大喜事：洞房花烛夜、金榜题名时、他乡遇顾知。前两件或许很难实现，通过读书，第三件确是经常遇到。读的过程中，你会突然有一种他乡遇顾知的感觉,然后会心一笑，原来你也在这儿！</p>
<p>   读《断舍离》就有这种感觉，中间的好多观点与《少有人走的路》不谋而合。读这本书对我最大的启发还是第一章论述的一个观点”学会做人生的减法”，知行合一，读了这段自己就实践了一下：过程不表，就是扔了很多旧衣服啥的！心情顿时舒畅。然后开始读下一段：咦！不对啊！咋有一种笑傲江湖那个段子的感觉？</p>
<p>   “欲练此功？必先自宫” 刚完事！下一篇写到”欲练此功？也可不宫”！刚扔完，雪莲老师就开始教旧物利用。好吧，就这样吧！老实说扔点东西，还是很爽的！</p>
<p><img src="%E6%96%AD%E8%88%8D%E7%A6%BB.png" alt="脑图"></p>
]]></content>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>架构师问题</title>
    <url>/2020/12/18/%E6%9E%B6%E6%9E%84%E5%B8%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="架构师技术问题："><a href="#架构师技术问题：" class="headerlink" title="架构师技术问题："></a>架构师技术问题：</h1><h2 id="在生产者、消费者、MQ中间件，都存在的情况下，如何设计才能保证发送MQ消息的100-不丢失。"><a href="#在生产者、消费者、MQ中间件，都存在的情况下，如何设计才能保证发送MQ消息的100-不丢失。" class="headerlink" title="在生产者、消费者、MQ中间件，都存在的情况下，如何设计才能保证发送MQ消息的100%不丢失。"></a>在生产者、消费者、MQ中间件，都存在的情况下，如何设计才能保证发送MQ消息的100%不丢失。</h2><h2 id="如何让MQ消费者按照消息发送的先后顺序进行消费？"><a href="#如何让MQ消费者按照消息发送的先后顺序进行消费？" class="headerlink" title="如何让MQ消费者按照消息发送的先后顺序进行消费？"></a>如何让MQ消费者按照消息发送的先后顺序进行消费？</h2><h2 id="当MQ集群挂了情况下，你们如何处理消息，有没有备用方案？"><a href="#当MQ集群挂了情况下，你们如何处理消息，有没有备用方案？" class="headerlink" title="当MQ集群挂了情况下，你们如何处理消息，有没有备用方案？"></a>当MQ集群挂了情况下，你们如何处理消息，有没有备用方案？</h2><h2 id="说一说JVM实际工作中，常用的年轻代和老年代的组合。"><a href="#说一说JVM实际工作中，常用的年轻代和老年代的组合。" class="headerlink" title="说一说JVM实际工作中，常用的年轻代和老年代的组合。"></a>说一说JVM实际工作中，常用的年轻代和老年代的组合。</h2><h2 id="默认情况下，一个对象经过多少次垃圾回收会进入老年代？"><a href="#默认情况下，一个对象经过多少次垃圾回收会进入老年代？" class="headerlink" title="默认情况下，一个对象经过多少次垃圾回收会进入老年代？"></a>默认情况下，一个对象经过多少次垃圾回收会进入老年代？</h2><h2 id="生产环境下：永久代一般分配大多内存？"><a href="#生产环境下：永久代一般分配大多内存？" class="headerlink" title="生产环境下：永久代一般分配大多内存？"></a>生产环境下：永久代一般分配大多内存？</h2><h2 id="JVM如何只作YongGC不做FullGC？"><a href="#JVM如何只作YongGC不做FullGC？" class="headerlink" title="JVM如何只作YongGC不做FullGC？"></a>JVM如何只作YongGC不做FullGC？</h2><h2 id="G1垃圾回收器是如何分配内存的？"><a href="#G1垃圾回收器是如何分配内存的？" class="headerlink" title="G1垃圾回收器是如何分配内存的？"></a>G1垃圾回收器是如何分配内存的？</h2><h2 id="Java内存模型？"><a href="#Java内存模型？" class="headerlink" title="Java内存模型？"></a>Java内存模型？</h2><h2 id="JVM内存分配？一台4核8G的服务器，分配多少内存？"><a href="#JVM内存分配？一台4核8G的服务器，分配多少内存？" class="headerlink" title="JVM内存分配？一台4核8G的服务器，分配多少内存？"></a>JVM内存分配？一台4核8G的服务器，分配多少内存？</h2><h2 id="JVM优化思路？"><a href="#JVM优化思路？" class="headerlink" title="JVM优化思路？"></a>JVM优化思路？</h2><h2 id="G1垃圾回收器使用场景？"><a href="#G1垃圾回收器使用场景？" class="headerlink" title="G1垃圾回收器使用场景？"></a>G1垃圾回收器使用场景？</h2><p>##你们公司的缓存架构是如何设计的？</p>
<h2 id="微服务之间访问的超时时间是如何设置的，设置依据是什么？"><a href="#微服务之间访问的超时时间是如何设置的，设置依据是什么？" class="headerlink" title="微服务之间访问的超时时间是如何设置的，设置依据是什么？"></a>微服务之间访问的超时时间是如何设置的，设置依据是什么？</h2><h2 id="限流机制是如何做的？限流的线程池数量大小怎么设置的？有什么参考标准？"><a href="#限流机制是如何做的？限流的线程池数量大小怎么设置的？有什么参考标准？" class="headerlink" title="限流机制是如何做的？限流的线程池数量大小怎么设置的？有什么参考标准？"></a>限流机制是如何做的？限流的线程池数量大小怎么设置的？有什么参考标准？</h2><h2 id="HDFS的主节点和备份节点是如何同步数据的。"><a href="#HDFS的主节点和备份节点是如何同步数据的。" class="headerlink" title="HDFS的主节点和备份节点是如何同步数据的。"></a>HDFS的主节点和备份节点是如何同步数据的。</h2><h2 id="MySQL在8核16G，16核32G情况下，承载的并发量大概是多大？"><a href="#MySQL在8核16G，16核32G情况下，承载的并发量大概是多大？" class="headerlink" title="MySQL在8核16G，16核32G情况下，承载的并发量大概是多大？"></a>MySQL在8核16G，16核32G情况下，承载的并发量大概是多大？</h2><h2 id="SpringCloud有生产落地经验吗？"><a href="#SpringCloud有生产落地经验吗？" class="headerlink" title="SpringCloud有生产落地经验吗？"></a>SpringCloud有生产落地经验吗？</h2><h2 id="maven和私服是如何管理和使用的？"><a href="#maven和私服是如何管理和使用的？" class="headerlink" title="maven和私服是如何管理和使用的？"></a>maven和私服是如何管理和使用的？</h2><h2 id="redis和db如何做到读写一致？分低并发和高并发场景回答"><a href="#redis和db如何做到读写一致？分低并发和高并发场景回答" class="headerlink" title="redis和db如何做到读写一致？分低并发和高并发场景回答"></a>redis和db如何做到读写一致？分低并发和高并发场景回答</h2><h2 id="分布式事务使用的框架，遇到的问题，原理？"><a href="#分布式事务使用的框架，遇到的问题，原理？" class="headerlink" title="分布式事务使用的框架，遇到的问题，原理？"></a>分布式事务使用的框架，遇到的问题，原理？</h2><h2 id="分布式锁实现由哪些方式？性能如何，zk锁并发多的时候如何进行优化？"><a href="#分布式锁实现由哪些方式？性能如何，zk锁并发多的时候如何进行优化？" class="headerlink" title="分布式锁实现由哪些方式？性能如何，zk锁并发多的时候如何进行优化？"></a>分布式锁实现由哪些方式？性能如何，zk锁并发多的时候如何进行优化？</h2><h2 id="微服务拆分原则是什么？如何拆分的？"><a href="#微服务拆分原则是什么？如何拆分的？" class="headerlink" title="微服务拆分原则是什么？如何拆分的？"></a>微服务拆分原则是什么？如何拆分的？</h2><h2 id="你们的配置文件是如何管理的？"><a href="#你们的配置文件是如何管理的？" class="headerlink" title="你们的配置文件是如何管理的？"></a>你们的配置文件是如何管理的？</h2><h2 id="分布式锁有哪些实现方式，各自的使用场景？"><a href="#分布式锁有哪些实现方式，各自的使用场景？" class="headerlink" title="分布式锁有哪些实现方式，各自的使用场景？"></a>分布式锁有哪些实现方式，各自的使用场景？</h2><h2 id="分布式事务如何做的？"><a href="#分布式事务如何做的？" class="headerlink" title="分布式事务如何做的？"></a>分布式事务如何做的？</h2><h2 id="微服务用了几台服务器，服务器的配置是什么？"><a href="#微服务用了几台服务器，服务器的配置是什么？" class="headerlink" title="微服务用了几台服务器，服务器的配置是什么？"></a>微服务用了几台服务器，服务器的配置是什么？</h2><h2 id="服务熔断和降级如何做的？"><a href="#服务熔断和降级如何做的？" class="headerlink" title="服务熔断和降级如何做的？"></a>服务熔断和降级如何做的？</h2><h2 id="限流是如何做的？"><a href="#限流是如何做的？" class="headerlink" title="限流是如何做的？"></a>限流是如何做的？</h2><h2 id="接口基本的性能测试如何做？"><a href="#接口基本的性能测试如何做？" class="headerlink" title="接口基本的性能测试如何做？"></a>接口基本的性能测试如何做？</h2><h2 id="zookeeper挂了，dubbo还能用么？"><a href="#zookeeper挂了，dubbo还能用么？" class="headerlink" title="zookeeper挂了，dubbo还能用么？"></a>zookeeper挂了，dubbo还能用么？</h2><h2 id="MQ用过嘛？-用在哪些场景？"><a href="#MQ用过嘛？-用在哪些场景？" class="headerlink" title="MQ用过嘛？ 用在哪些场景？"></a>MQ用过嘛？ 用在哪些场景？</h2><h2 id="消费者默认重试多少次？"><a href="#消费者默认重试多少次？" class="headerlink" title="消费者默认重试多少次？"></a>消费者默认重试多少次？</h2><h2 id="rocketMQ如果几次消费重试都失败了，如何处理？"><a href="#rocketMQ如果几次消费重试都失败了，如何处理？" class="headerlink" title="rocketMQ如果几次消费重试都失败了，如何处理？"></a>rocketMQ如果几次消费重试都失败了，如何处理？</h2><h2 id="守护线程和用户线程区别？"><a href="#守护线程和用户线程区别？" class="headerlink" title="守护线程和用户线程区别？"></a>守护线程和用户线程区别？</h2><h2 id="线程池用过嘛？怎么用的？"><a href="#线程池用过嘛？怎么用的？" class="headerlink" title="线程池用过嘛？怎么用的？"></a>线程池用过嘛？怎么用的？</h2><h2 id="一台机器4C8G大约可以开多少线程？根据什么计算？可以分CPU密集型和IO密集型应用说。"><a href="#一台机器4C8G大约可以开多少线程？根据什么计算？可以分CPU密集型和IO密集型应用说。" class="headerlink" title="一台机器4C8G大约可以开多少线程？根据什么计算？可以分CPU密集型和IO密集型应用说。"></a>一台机器4C8G大约可以开多少线程？根据什么计算？可以分CPU密集型和IO密集型应用说。</h2><h2 id="读多写少用什么锁？"><a href="#读多写少用什么锁？" class="headerlink" title="读多写少用什么锁？"></a>读多写少用什么锁？</h2><h2 id="redis如何删除过期数据的？"><a href="#redis如何删除过期数据的？" class="headerlink" title="redis如何删除过期数据的？"></a>redis如何删除过期数据的？</h2><h2 id="redis雪崩如何处理？"><a href="#redis雪崩如何处理？" class="headerlink" title="redis雪崩如何处理？"></a>redis雪崩如何处理？</h2><h2 id="如何保证redis和db的读写一致？"><a href="#如何保证redis和db的读写一致？" class="headerlink" title="如何保证redis和db的读写一致？"></a>如何保证redis和db的读写一致？</h2><h2 id="都多写少用什么锁？"><a href="#都多写少用什么锁？" class="headerlink" title="都多写少用什么锁？"></a>都多写少用什么锁？</h2><h2 id="如果保证MQ消息的零丢失？"><a href="#如果保证MQ消息的零丢失？" class="headerlink" title="如果保证MQ消息的零丢失？"></a>如果保证MQ消息的零丢失？</h2><h2 id="假设一个表有abc三个字段，实际的查询场景需要按照-a-b，b-c进行查询，如何设计索引，让所有的查询都能用到索引？"><a href="#假设一个表有abc三个字段，实际的查询场景需要按照-a-b，b-c进行查询，如何设计索引，让所有的查询都能用到索引？" class="headerlink" title="假设一个表有abc三个字段，实际的查询场景需要按照 a+b，b+c进行查询，如何设计索引，让所有的查询都能用到索引？"></a>假设一个表有abc三个字段，实际的查询场景需要按照 a+b，b+c进行查询，如何设计索引，让所有的查询都能用到索引？</h2><h2 id="abc三个字段建立了联合索引"><a href="#abc三个字段建立了联合索引" class="headerlink" title="abc三个字段建立了联合索引"></a>abc三个字段建立了联合索引</h2><h2 id="where条件是-a-‘’-and-b-’’"><a href="#where条件是-a-‘’-and-b-’’" class="headerlink" title="where条件是 a = ‘’ and b=’’"></a>where条件是 a = ‘’ and b=’’</h2><h2 id="where条件是-a-‘’-and-c-’’"><a href="#where条件是-a-‘’-and-c-’’" class="headerlink" title="where条件是 a = ‘’ and c=’’"></a>where条件是 a = ‘’ and c=’’</h2><h2 id="where条件是-b-‘’-and-c-’’"><a href="#where条件是-b-‘’-and-c-’’" class="headerlink" title="where条件是 b = ‘’ and c=’’"></a>where条件是 b = ‘’ and c=’’</h2><h2 id="mysql数据库默认的事务隔离级别是什么？"><a href="#mysql数据库默认的事务隔离级别是什么？" class="headerlink" title="mysql数据库默认的事务隔离级别是什么？"></a>mysql数据库默认的事务隔离级别是什么？</h2><h2 id="mysql索引的创建原则？"><a href="#mysql索引的创建原则？" class="headerlink" title="mysql索引的创建原则？"></a>mysql索引的创建原则？</h2><h2 id="mysql如何进行性能压测？"><a href="#mysql如何进行性能压测？" class="headerlink" title="mysql如何进行性能压测？"></a>mysql如何进行性能压测？</h2><h2 id="mysql如何对sql进行性能分析？"><a href="#mysql如何对sql进行性能分析？" class="headerlink" title="mysql如何对sql进行性能分析？"></a>mysql如何对sql进行性能分析？</h2><h2 id="mysql服务器的配置？"><a href="#mysql服务器的配置？" class="headerlink" title="mysql服务器的配置？"></a>mysql服务器的配置？</h2><h2 id="必问问题："><a href="#必问问题：" class="headerlink" title="必问问题："></a>必问问题：</h2><h2 id="1、找工作最看重一家公司的哪些方面？3-5年职业规划。"><a href="#1、找工作最看重一家公司的哪些方面？3-5年职业规划。" class="headerlink" title="1、找工作最看重一家公司的哪些方面？3-5年职业规划。"></a>1、找工作最看重一家公司的哪些方面？3-5年职业规划。</h2><h2 id="团队，"><a href="#团队，" class="headerlink" title="团队，"></a>团队，</h2><h2 id="2、上班时间和距离是否接受"><a href="#2、上班时间和距离是否接受" class="headerlink" title="2、上班时间和距离是否接受"></a>2、上班时间和距离是否接受</h2><h2 id="东西上，8-30"><a href="#东西上，8-30" class="headerlink" title="东西上，8:30"></a>东西上，8:30</h2><h2 id="3、目前薪资-，期望薪资，最快入职时间。"><a href="#3、目前薪资-，期望薪资，最快入职时间。" class="headerlink" title="3、目前薪资 ，期望薪资，最快入职时间。"></a>3、目前薪资 ，期望薪资，最快入职时间。</h2><h2 id="30-40，1周"><a href="#30-40，1周" class="headerlink" title="30-40，1周"></a>30-40，1周</h2><h2 id="4、对加班看法？"><a href="#4、对加班看法？" class="headerlink" title="4、对加班看法？"></a>4、对加班看法？</h2><h2 id="5、在职还是离职？离职时间，离职原因"><a href="#5、在职还是离职？离职时间，离职原因" class="headerlink" title="5、在职还是离职？离职时间，离职原因:"></a>5、在职还是离职？离职时间，离职原因:</h2><h2 id="微服务的优点和缺点是什么？"><a href="#微服务的优点和缺点是什么？" class="headerlink" title="微服务的优点和缺点是什么？"></a>微服务的优点和缺点是什么？</h2><h2 id="Springboot如何区分开发环境和生产环境"><a href="#Springboot如何区分开发环境和生产环境" class="headerlink" title="Springboot如何区分开发环境和生产环境"></a>Springboot如何区分开发环境和生产环境</h2><h2 id="spring-cloud-的核心组件有哪些？"><a href="#spring-cloud-的核心组件有哪些？" class="headerlink" title="spring cloud 的核心组件有哪些？"></a>spring cloud 的核心组件有哪些？</h2><h2 id="Eureka：服务注册于发现。"><a href="#Eureka：服务注册于发现。" class="headerlink" title="Eureka：服务注册于发现。"></a>Eureka：服务注册于发现。</h2><h2 id="Feign：基于动态代理机制，根据注解和选择的机器，拼接请求-url-地址，发起请求。"><a href="#Feign：基于动态代理机制，根据注解和选择的机器，拼接请求-url-地址，发起请求。" class="headerlink" title="Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。"></a>Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。</h2><h2 id="Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。"><a href="#Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。" class="headerlink" title="Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。"></a>Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。</h2><h2 id="Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。"><a href="#Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。" class="headerlink" title="Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。"></a>Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。</h2><h2 id="Zuul：网关管理，由-Zuul-网关转发请求给对应的服务。"><a href="#Zuul：网关管理，由-Zuul-网关转发请求给对应的服务。" class="headerlink" title="Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。"></a>Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。</h2>]]></content>
  </entry>
  <entry>
    <title>如何替换if-Else</title>
    <url>/2021/02/02/%E5%A6%82%E4%BD%95%E6%9B%BF%E6%8D%A2if-Else/</url>
    <content><![CDATA[<h2 id="免责声明：本文并不肯定或者否定哪一种写法，仅仅为大家提供一些其他的编码思路或者一些值得借鉴的点子"><a href="#免责声明：本文并不肯定或者否定哪一种写法，仅仅为大家提供一些其他的编码思路或者一些值得借鉴的点子" class="headerlink" title="免责声明：本文并不肯定或者否定哪一种写法，仅仅为大家提供一些其他的编码思路或者一些值得借鉴的点子"></a>免责声明：本文并不肯定或者否定哪一种写法，仅仅为大家提供一些其他的编码思路或者一些值得借鉴的点子</h2><pre><code>if（condition）{
    do stuff
} else (otherCondition) {
    do something
} else {

}</code></pre><p>if-Else通常是个糟糕的选择，它导致设计复杂，代码可读性差，重构困难等等。说了这么多如何优化？或者说如何替换if-Else呢？</p>
<h2 id="五种方式"><a href="#五种方式" class="headerlink" title="五种方式"></a>五种方式</h2><h3 id="完全不必要的Else块"><a href="#完全不必要的Else块" class="headerlink" title="完全不必要的Else块"></a>完全不必要的Else块</h3><pre><code>public void PerformOperation(int input) {
    if(intput &gt; 5) {
        // do something
    } else {
        // do something
    } 
}</code></pre><p>只需要删除else块即可简化此过程，如下所示</p>
<pre><code>public void PerformOperation(int input) {
    if(intput &gt; 5) {
        // do something
        return;
    } 

    // do something
}</code></pre><p>仔细体会一下，那种写法更容易理解？其实就一句话：在满足特定条件的情况下执行某些操作并立即返回，适用于异常流先返回，往下执行的都是正常流业务。</p>
<h3 id="价值分配"><a href="#价值分配" class="headerlink" title="价值分配"></a>价值分配</h3><p>如果你想要根据某些输入为变量分配新值，如下：</p>
<pre><code>public static string determineGender(int input) {
    String gender = String.Empty;
    if(input == 0) {
        gender = &quot;male&quot;;
    } else if(input == 1) {
        gender = &quot;woman&quot;;
    } else if {
        gender = &quot;unknown&quot;;
    }

    return gender;
}</code></pre><p>上述if-Else很容易被开关取代。如下：</p>
<pre><code>public static string determineGender(int input) {
    if(input == 0) {
         return &quot;male&quot;;
    } else if(input == 1) {
         return &quot;woman&quot;;
    } else if {
         return &quot;unknown&quot;;
    }
}</code></pre><p>进一步优化，可通过删除else来进一步简化代码</p>
<pre><code>public static string determineGender(int input) {
    if(input == 0) {return &quot;male&quot;; } 
    if(input == 1) {return &quot;woman&quot;; }  

    return &quot;unknown&quot;;
}</code></pre><p>若不使用else，则我们将剩下干净的可读代码。这么做的好处是可以迅速得到想要的值。试想：如果已经找到正确的值，继续测试下一个值一点意义也没有。</p>
<h3 id="前提条件检查-用三元运算代替if"><a href="#前提条件检查-用三元运算代替if" class="headerlink" title="前提条件检查(用三元运算代替if)"></a>前提条件检查(用三元运算代替if)</h3><p>通常，我发现，如果方法提供了无效的值，则继续执行是没有意义的。假设有一个方法defineGender方法，要求输入值必须始终为0或者1。</p>
<pre><code>// Input must be 0 or 1
public String defineGender (int input) {
    // Continue executing logic
}</code></pre><p>在没有参数验证的情况下,执行该方法没有任何意义，或者说太容易出bug了，因此在实际业务之前，我们需要检查一些先决条件。</p>
<pre><code>// Input must be 0 or 1
public String defineGender (int input) {
    if(intput &lt; 0) throw new ArgumentException();
    if(intput &gt; 0) throw new ArgumentException();

    return input == 0 ? &quot;woman&quot; : &quot;man&quot;;
}</code></pre><p>因有明确的输入限制，if可以用三元代替，因此不再需要在结尾处写默认返回值。</p>
<h3 id="将-If-Else转换为字典，完全避免-IF-ELSE"><a href="#将-If-Else转换为字典，完全避免-IF-ELSE" class="headerlink" title="将 If-Else转换为字典，完全避免 IF-ELSE"></a>将 If-Else转换为字典，完全避免 IF-ELSE</h3><p>假设你需要执行一些操作，这些操作将根据某些条件进行选择，我们知道以后必须添加更多条件操作。</p>
<pre><code>public void performOp(String operationName) {
    if(operationName == &quot;Op1&quot;)) {
       // something 
    } else if (operationName == &quot;Op2&quot;) {
       // something 
    } else {
       // default path 
    }
}</code></pre><p>有些人倾向于使用久经考验的 If-Else。如果添加新操作，则只需要简单地添加其他内容即可。很简单!但是，就维护而言,这种方法不是一个号的设计。</p>
<p>知道我们以后需要添加新的操作后，我们可以将If-Else重构为字典。</p>
<pre><code>public void performOp(String operationName) {
    var operations = new Dictionary&lt;String, Action&gt;();
    operations[&quot;Op1&quot;] = () =&gt; {// something};
    operations[&quot;Op2&quot;] = () =&gt; {// something};

    operations[operationName].Invoke();
}</code></pre><p>可读性已经大大提高，并且可以轻松地推断出该代码。注意，仅用于说明目的将字典放置在方法内部。你可以在其他地方定义它。</p>
<h3 id="扩展应用程序，完全避免使用If-Else"><a href="#扩展应用程序，完全避免使用If-Else" class="headerlink" title="扩展应用程序，完全避免使用If-Else"></a>扩展应用程序，完全避免使用If-Else</h3><pre><code>public String printOrder(Order order, String formatType) {
    String result = String.Empty;

    if(formatType == &quot;Json&quot;) {
        result = JsonSerializer.Serialize(order);
    } else if (formatType == &quot;PlainText&quot;) {
        result = $&quot;Id:{order.Id}\nSum: {order.Sum}&quot;;
    } else {
        result = &quot;Unknown format&quot;;
    }

    return result;
}</code></pre><p>上述代码我们若有新业务增加，则可通过添加if-else来解决，但它违反了开闭原则，且可读性差。    </p>
<p>正确的做法为：遵循SOLID原则，我们通过实施动态类型发现过程（本例中为策略模式）来做到这一点。</p>
<p><strong>重构的过程如下</strong></p>
<ul>
<li>使用公共接口将每个分支提取到单独的策略类中。</li>
<li>动态查找实现通用接口的所有类。</li>
<li>根据输入决定执行哪种策略。</li>
</ul>
<p>重点是类型发现的工作原理。</p>
<pre><code>private String printOrder(Order order, String formatType) {

// Dynamic type discovery process that builds a dictionary
Dictionary&lt;String, Type&gt; formatterTypes = Assembly
    .GetExecutingAssembly()
    .GetExportedTypes()
    .Where(type =&gt; type.getInterfaces().Contains(typeof(IOrderOutputStrategy)))
    .ToDictionary(type =&gt; type.GetCustomAttribute&lt;OutputFormatterName&gt;().DisplayName);

Type choseFormatter = formatterTypes[formatType];

// Try instantiate the formatter -- could have utilized a DI framework here instead
IOrderOutputStrategy strategy = Activator.CreateInstance(chosenFormatter) as IOrderOutputStrategy;
if ( strategy is null) throw new InvalidOperationException(&quot;No valid formatter selected&quot;);

// Execute strategy method
string result = strategy.ConvertOrderToString(order);
return result;
}</code></pre>]]></content>
  </entry>
  <entry>
    <title>Code Review</title>
    <url>/2021/01/16/Code%20Review/</url>
    <content><![CDATA[<h1 id="代码审查标准及规范"><a href="#代码审查标准及规范" class="headerlink" title="代码审查标准及规范"></a>代码审查标准及规范</h1><h2 id="git-提交标准"><a href="#git-提交标准" class="headerlink" title="git 提交标准"></a>git 提交标准</h2><ul>
<li><p>mvn test 通过</p>
</li>
<li><p>代码格式化通过 (ctrl + alt + l) </p>
</li>
<li><p>阿里规约扫描无警告</p>
</li>
</ul>
<h2 id="git-提交前要做的"><a href="#git-提交前要做的" class="headerlink" title="git 提交前要做的"></a>git 提交前要做的</h2><pre><code>0、 git pull 

1、 执行代码格式化快捷键 reformat code 

2、 在项目根目录执行 mvn test 

3、阿里规约扫描</code></pre><h2 id="git提交参考脚本"><a href="#git提交参考脚本" class="headerlink" title="git提交参考脚本"></a>git提交参考脚本</h2><pre><code>#!bin/bash

if [ -z &quot;$1&quot; ]
then
    echo &quot;提交信息不可为空&quot;
    exit;
fi

git add -A

git commit -m &quot;$1&quot;

git pull

# 测试
mvn clean test

git push

git checkout debugging

git pull

git merge V1.0.0 -m &quot;$1&quot;

mvn test

git push

git checkout V1.0.0</code></pre><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a><a href="http://showdoc.huifanayb.cn:4999/web/#/p/9c0423d7da951ea5923f8f381c63a368" target="_blank" rel="noopener">代码规范</a></h2><h2 id="前后端规约"><a href="#前后端规约" class="headerlink" title="前后端规约"></a><a href="http://showdoc.huifanayb.cn:4999/web/#/p/6a57dc10a462d2a8a5cbac0bf402f777" target="_blank" rel="noopener">前后端规约</a></h2><h2 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a><a href="http://showdoc.huifanayb.cn:4999/web/#/p/5247ce95619e723c005451cf0bfcaf6d" target="_blank" rel="noopener">命名风格</a></h2><h2 id="代码格式配置及使用方法"><a href="#代码格式配置及使用方法" class="headerlink" title="代码格式配置及使用方法"></a><a href="http://showdoc.huifanayb.cn:4999/web/#/p/38fef09fc67bec02f52fdc107cde88d7" target="_blank" rel="noopener">代码格式配置及使用方法</a></h2><h2 id="规范特别提示"><a href="#规范特别提示" class="headerlink" title="规范特别提示"></a>规范特别提示</h2><ul>
<li><p>idea中不可出现爆红    </p>
</li>
<li><p>代码格式需标准统一</p>
</li>
<li><p>代码中不可出现无用引用包</p>
</li>
<li><p>阿里规约不可扫描出现问题</p>
</li>
</ul>
<h2 id="审查方式"><a href="#审查方式" class="headerlink" title="审查方式"></a>审查方式</h2><p>1、项目技术负责人负责自己所属项目代码审查</p>
<p>2、代码审查总负责人负责抽查项目</p>
<p>3、项目总负责人每周汇总每个人的代码不规范之处代码及数量</p>
]]></content>
  </entry>
  <entry>
    <title>Java教程</title>
    <url>/2020/12/18/Java%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Java教程"><a href="#Java教程" class="headerlink" title="Java教程"></a>Java教程</h1><h2 id="Java快速入门"><a href="#Java快速入门" class="headerlink" title="Java快速入门"></a>Java快速入门</h2><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h2 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h2><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h2 id="加密与安全"><a href="#加密与安全" class="headerlink" title="加密与安全"></a>加密与安全</h2><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h2 id="Maven基础"><a href="#Maven基础" class="headerlink" title="Maven基础"></a>Maven基础</h2><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h2 id="XML与JSON"><a href="#XML与JSON" class="headerlink" title="XML与JSON"></a>XML与JSON</h2><h2 id="JDBC编程"><a href="#JDBC编程" class="headerlink" title="JDBC编程"></a>JDBC编程</h2><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>函数式编程最早是数学家阿隆佐.邱奇研究的一套函数变换逻辑，又称Lambda Calculus(λ-Calculus),，所以也经常把函数式编程称为Lambda计算。</p>
<p><strong>特点： 允许把函数本省作为参数传入另一个函数，还允许返回一个函数</strong></p>
<h3 id="Lambda基础"><a href="#Lambda基础" class="headerlink" title="Lambda基础"></a>Lambda基础</h3><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p>在Java程序中，我们经常遇到一大堆单方法接口，即一个接口只定义了一个方法：</p>
<ul>
<li>Comparator</li>
<li>Runnable</li>
<li>Callable</li>
</ul>
<p>以<code>Comparator</code>为例，我们想要调用<code>Arrays.sort()</code>时，可以传入一个<code>Comparator</code>实例，以匿名类方式编写如下：</p>
<pre><code>String[] array = ...
Arrays.sort(array, new Comparator&lt;String&gt;() {
    public int compare(String s1, String s2) {
        return s1.compareTo(s2);        
    }
}</code></pre><p>上述方法非常繁琐。从Java8开始，我们可以用Lambda表达式替换单方法接口。改写上述代码如下：</p>
<pre><code>// Lambda
public class Main(String[] args) {
     public static void main(String[] args) {
            String[] array = new String[] { &quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;, &quot;Lemon&quot; };
            Arrays.sort(array, (s1, s2) -&gt; {
                return s1.compareTo(s2);
            });
            System.out.println(String.join(&quot;, &quot;, array));
        }
}    </code></pre><p>观察Lambda表达式的写法，它只需要写出方法定义：</p>
<pre><code>(s1,s2) -&gt; {
   return s1.compareTo（s2）;
}   </code></pre><p>其中，参数是<code>(s1,s2)</code>,参数类型可以省略，因为编译器可以自动推断出<code>String</code>类型。<code>-&gt; {... }</code>表示方法体，所有代码写在内部即可。<br>Lambda表达式没有<code>class</code>定义，因此写法非常简洁。如果只有一行<code>return xxx</code>的代码，完全可以用更简单的写法：</p>
<pre><code>Arrays.sort(array,(s1, s2) -&gt; s1.compareTo(s2));</code></pre><p>返回值得类型也是由编译器自动推断的，这里推断出的返回值是<code>int</code>,因此，只要返回<code>int</code>,编译器就不会报错。</p>
<h4 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="FunctionalInterface"></a>FunctionalInterface</h4><p>我们把只定义了单方法的接口称之为<code>FunctionalInterface</code>,用注解<code>@FunctionalInterface</code>标记。例如，<code>Callable</code>接口：</p>
<pre><code>@FunctionalInterface
public interface Callable&lt;V&gt; {
    V call() throws Exception;
}</code></pre><p>再来看<code>Comparator</code>接口：</p>
<pre><code>@FuctionalInterface
public interface Comparator&lt;T&gt; {

    int compare(T o1, T o2);

    boolean equals(Object obj);

    default Comparator&lt;T&gt; reversed() {
        return Collections.reverseOrder(this);
    }

    default Comparator&lt;T&gt; thenComparing(Comparator&lt;? super T&gt; other) {
        ...
    }
    ...
}    </code></pre><p>虽然<code>Comparator</code>接口有很多方法，但只有一个抽象方法<code>int compare(T o1, T o2)</code>，其他的方法都是<code>default</code>方法或<code>static</code>方法。<br>另外注意到<code>boolean equals(Object obj)</code>是<code>Object</code>定义的方法，不算在接口方法内。因此，<code>Comparator</code>也是一个<code>FunctionalInterface</code>。        </p>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>使用Lambda表达式，我们就可以不必编写<code>FunctionalInterface</code>接口的实现类，从而简化代码：</p>
<pre><code>Arrays.sort(array, (s1, s2) -&gt; {
    return s1.compareTo(s2);
});</code></pre><p>实际上，除了Lambda表达式，我们还可以直接传入方法引用。例如：</p>
<pre><code>public class Main {
    public static void main(String[] args) {
        String[] array = new String[] { &quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;, &quot;Lemon&quot; };
        Arrays.sort(array, Main::cmp);
        System.out.println(String.join(&quot;, &quot;, array));
    }

    static int cmp(String s1, String s2) {
        return s1.compareTo(s2);
    }
}</code></pre><p>上述代码在<code>Arrays.sort()</code>中直接传入了静态方法<code>cmp</code>的引用，用<code>Main::cmp</code>表示。</p>
<p>因此，所谓方法引用，是指如果某个方法签名和接口恰好一致，就可以直接传入方法引用。</p>
<p>因为<code>Comparator&lt;String&gt;</code>接口定义的方法是<code>int compare(String, String)</code>，和静态方法<code>int cmp(String, String)</code>相比，除了方法名外，<br>方法参数一致，返回类型相同，因此，我们说两者的方法签名一致，可以直接把方法名作为Lambda表达式传入：</p>
<pre><code>Arrays.sort(array,Main::cmp);</code></pre><p>注意：在这里，方法签名只看参数类型和返回类型，不看方法名称，也不看类的继承关系。</p>
<p>我们再看看如何引用实例方法。如果我们把代码改写如下：</p>
<pre><code>public class Main {
    public static void main(String[] args) {
        String[] array = new String[] { &quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;, &quot;Lemon&quot; };
        Arrays.sort(array, String::compareTo);
        System.out.println(String.join(&quot;, &quot;, array));
    }
}</code></pre><p>不但可以编译通过，而且运行结果也是一样的，这说明String.compareTo()方法也符合Lambda定义。</p>
<p>观察<code>String.compareTo()</code>的方法定义：</p>
<pre><code>public final class String {
    public int compareTo(String o) {
        ...
    }
}</code></pre><p>这个方法的签名只有一个参数，为什么和<code>int Comparator&lt;String&gt;.compare(String, String)</code>能匹配呢？<br>因为实例方法有一个隐含的<code>this</code>参数，<code>String</code>类的<code>compareTo()</code>方法在实际调用的时候，第一个隐含参数总是传入<code>this</code>，相当于静态方法：</p>
<pre><code>public static int compareTo(this, String o);</code></pre><p>所以，<code>String.compareTo()</code>方法也可以作为方法引用传入。</p>
<h4 id="构造方法引用"><a href="#构造方法引用" class="headerlink" title="构造方法引用"></a>构造方法引用</h4><p>除了可以引用静态方法和实例方法，我们还可以引用构造方法。</p>
<p>我们来看一个例子：如果要把一个 <code>List&lt;String&gt;</code> 转换为<code>List&lt;Person&gt;</code>,应该怎么办？</p>
<pre><code>class Person {
    String name;
    public Person(String name) {
        this.name = name;
    }
}    

List&lt;String&gt; names = List.of(&quot;Bob&quot;, &quot;Alice&quot;, &quot;Tim&quot;);    
List&lt;Person&gt; persons = ???</code></pre><p>传统的做法是先定义一个<code>ArrayList&lt;Person&gt;</code>,然后用<code>for</code>循环填充这个<code>List</code>:</p>
<pre><code>List&lt;String&gt; names = List.of(&quot;Bob&quot;, &quot;Alice&quot;, &quot;Tim&quot;);
List&lt;Person&gt; persons = new ArrayList&lt;&gt;();
for (String name : names) {
    persons.add(new Person(name));
}</code></pre><p>要更简单地实现String到Person的转换，我们可以引用Person的构造方法：</p>
<pre><code>public class Main {
    public static void main(String[] args) {
        List&lt;String&gt; names = List.of(&quot;Bob&quot;, &quot;Alice&quot;, &quot;Tim&quot;);
        List&lt;Person&gt; persons = names.stream().map(Person::new).collect(Collectors.toList());
        System.out.println(persons);
    }
}

class Person {
    String name;
    public Person(String name) {
        this.name = name;
    }
    public String toString() {
        return &quot;Person:&quot; + this.name;
    }
}</code></pre><p>后面我们会讲到Stream的map()方法。现在我们看到，这里的map()需要传入的FunctionalInterface的定义是：</p>
<pre><code>@FunctionalInterface
public interface Function&lt;T, R&gt; {
    R apply(T t);
}</code></pre><p>把泛型对应上就是方法签名<code>Person apply(String)</code>,即传入参数<code>String</code>,返回类型<code>Person</code>。<br>而<code>Person</code>类的构造方法恰好满足这个条件，因为构造方法的参数是<code>String</code>，而构造方法虽然没有<code>return</code>语句，<br>但它会隐式地返回<code>this</code>实例，类型就是<code>Person</code>，因此，此处可以引用构造方法。构造方法的引用写法是<code>类名::new</code>，因此，此处传入<code>Person::new</code>。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><code>FunctionalInterface</code>允许传入：</p>
<ul>
<li>接口的实现类（传统写法，代码较繁琐）；</li>
<li>Lambda表达式（只需要列出参数名，由编译器推断类型）；</li>
<li>符合方法签名的静态方法；</li>
<li>符合方法签名的实例方法（实例类型被看做第一个参数类型）；</li>
<li>符合方法签名的构造方法（实例类型被看做返回类型）。</li>
</ul>
<p><code>FunctionalInterface</code>不强制继承关系，不需要方法名称相同，只要求方法参数（类型和数量）与方法返回类型相同，即认为方法签名相同。</p>
<h3 id="使用Stream"><a href="#使用Stream" class="headerlink" title="使用Stream"></a>使用Stream</h3><p>Java从8开始，不但引入了Lambda表达式，还引入了一个全新的流式API：Stream API。它位于<code>java.util.stream</code>包中。</p>
<p><strong>划重点</strong>这个<code>stream</code>不同于<code>java.io</code>的<code>InputStream</code>和<code>OutputStream</code>，它代表的是任意Java对象的序列。两者对比如下：</p>
<table>
<thead>
<tr>
<th align="left">对比</th>
<th align="left">java.io</th>
<th align="left">java.util.stream</th>
</tr>
</thead>
<tbody><tr>
<td align="left">存储</td>
<td align="left">顺序读写的<code>byte</code>或<code>char</code></td>
<td align="left">顺序输出的任意Java对象实例</td>
</tr>
<tr>
<td align="left">用途</td>
<td align="left">序列化至文件或网络</td>
<td align="left">内存计算／业务逻辑</td>
</tr>
</tbody></table>
<p>有同学会问：一个顺序输出的Java对象序列，不就是一个List容器吗？</p>
<p>再次划重点：这个Stream和List也不一样，List存储的每个元素都是已经存储在内存中的某个Java对象，而Stream输出的元素可能并没有预先存储在内存中，而是实时计算出来的。</p>
<p>换句话说，List的用途是操作一组已存在的Java对象，而Stream实现的是惰性计算，两者对比如下：</p>
<table>
<thead>
<tr>
<th align="left">对比</th>
<th align="left">java.util.List</th>
<th align="left">java.util.stream</th>
</tr>
</thead>
<tbody><tr>
<td align="left">元素</td>
<td align="left">已分配并存储在内存</td>
<td align="left">可能未分配，实时计算</td>
</tr>
<tr>
<td align="left">用途</td>
<td align="left">操作一组已存在的Java对象</td>
<td align="left">惰性计算</td>
</tr>
</tbody></table>
<p>Stream看上去有点不好理解，但我们举个例子就明白了。</p>
<p>如果我们要表示一个全体自然数的集合，显然，用List是不可能写出来的，因为自然数是无限的，内存再大也没法放到List中：</p>
<pre><code>List&lt;BigInteger&gt; list = ??? // 全体自然数?</code></pre><p>但是，用Stream可以做到。写法如下：</p>
<pre><code>Stream&lt;BigInteger&gt; naturals = createNaturalStream(); // 全体自然数</code></pre><p>我们先不考虑createNaturalStream()这个方法是如何实现的，我们看看如何使用这个Stream。</p>
<p>首先，我们可以对每个自然数做一个平方，这样我们就把这个Stream转换成了另一个Stream：</p>
<pre><code>Stream&lt;BigInteger&gt; naturals = createNaturalStream(); // 全体自然数
Stream&lt;BigInteger&gt; streamNxN = naturals.map(n -&gt; n.multiply(n)); // 全体自然数的平方</code></pre><p>因为这个streamNxN也有无限多个元素，要打印它，必须首先把无限多个元素变成有限个元素，<br>可以用limit()方法截取前100个元素，最后用forEach()处理每个元素，这样，我们就打印出了前100个自然数的平方：</p>
<pre><code>Stream&lt;BigInteger&gt; naturals = createNaturalStream();
naturals.map(n -&gt; n.multiply(n)) // 1, 4, 9, 16, 25...
        .limit(100)
        .forEach(System.out::println);</code></pre><p>我们总结一下Stream的特点：它可以“存储”有限个或无限个元素。这里的存储打了个引号，是因为元素有可能已经全部存储在内存中，也有可能是根据需要实时计算出来的。</p>
<p>Stream的另一个特点是，一个Stream可以轻易地转换为另一个Stream，而不是修改原Stream本身。</p>
<p>最后，真正的计算通常发生在最后结果的获取，也就是惰性计算。</p>
<pre><code>Stream&lt;BigInteger&gt; naturals = createNaturalStream(); // 不计算
Stream&lt;BigInteger&gt; s2 = natural.map(BigInteger::multiply); // 不计算
Stream&lt;BigInteger&gt; s3 = s2.limit(100); // 不计算
s3.forEach(System.out::println); // 计算</code></pre><ul>
<li>惰性计算的特点是：一个<code>Stream</code>转换为另一个<code>Stream</code>时，实际上只存储了转换规则，并没有任何计算发生。</li>
</ul>
<p>例如，创建一个全体自然数的Stream，不会进行计算，把它转换为上述s2这个Stream，也不会进行计算。<br>再把s2这个无限Stream转换为s3这个有限的Stream，也不会进行计算。<br>只有最后，调用forEach确实需要Stream输出的元素时，才进行计算。我们通常把Stream的操作写成链式操作，代码更简洁：</p>
<pre><code>createNaturalStream()
    .map(BigInteger::multiply)
    .limit(100)
    .forEach(System.out::println);</code></pre><p>因此，Stream API的基本用法就是:创建一个<code>Stream</code>,然后做若干次转换，最后调用一个求值方法获取真正计算的结果：</p>
<pre><code>int result = createNaturalStream() // 创建Stream
            .filter(n -&gt; n % 2 ==0) // 任意个转换
            .map(n -&gt; n * n) // 任意个转换
            .limit(100) // 任意个转换
            .sum(); // 最终计算结果</code></pre><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>Stream API的特点是：</p>
<ul>
<li>Stream API提供了一套新的流式处理的抽象序列；</li>
<li>Stream API支持函数式编程和链式操作</li>
<li>Stream可以表示无限序列，并且大多数情况下是惰性求值的。                </li>
</ul>
<h4 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h4><p>要使用Stream，就必须现创建它。创建Stream有很多种方法，我们来一一介绍。</p>
<h5 id="Stream-of"><a href="#Stream-of" class="headerlink" title="Stream.of()"></a>Stream.of()</h5><p>创建Stream最简单的方式是直接用<code>Stream.of()</code>静态方法，传入可变参数即创建了一个能输出确定元素的Stream：</p>
<pre><code>import java.util.stream.Stream;
public class Main {
    public static void main(String[] args) {
        Stream&lt;String&gt; stream = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;);
        // forEach()方法相当于内部循环调用，
        // 可传入符合Consumer接口的void accept(T t)的方法引用：
        stream.forEach(System.out::println);
    }
}</code></pre><p>虽然这种方式基本上没啥实质性用途，但测试的时候很方便。</p>
<h5 id="基于数组或Collection"><a href="#基于数组或Collection" class="headerlink" title="基于数组或Collection"></a>基于数组或Collection</h5><p>第二种创建Stream的方法是基于一个数组或者Collection，这样该Stream输出的元素就是数组或者Collection持有的元素：</p>
<pre><code>public class Main {
    public static void main(String[] args) {
        Stream&lt;String&gt; stream1 = Arrays.stream(new String[] { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; });
        Stream&lt;String&gt; stream2 = List.of(&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;).stream();
        stream1.forEach(System.out::println);
        stream2.forEach(System.out::println);
    }
}</code></pre><p>把数组变成Stream使用Arrays.stream()方法。对于Collection（List、Set、Queue等），直接调用stream()方法就可以获得Stream。<br>上述创建Stream的方法都是把一个现有的序列变为Stream，它的元素是固定的。</p>
<h5 id="基于Supplier"><a href="#基于Supplier" class="headerlink" title="基于Supplier"></a>基于Supplier</h5><p>创建Stream还可以通过Stream.generate()方法，它需要传入一个Supplier对象：</p>
<pre><code>Stream&lt;String&gt; s = Stream.generate(Supplier&lt;String&gt; sp);</code></pre><p><strong>基于Supplier创建的Stream会不断调用Supplier.get()方法来不断产生下一个元素，这种Stream保存的不是元素，而是算法，它可以用来表示无限序列。</strong></p>
<p>例如，我们编写一个能不断生成自然数的Supplier，它的代码非常简单，每次调用get()方法，就生成下一个自然数：</p>
<pre><code>public class Main {
    public static void main(String[] args) {
        Stream&lt;Integer&gt; natual = Stream.generate(new NatualSupplier());
        // 注意：无限序列必须先变成有限序列再打印:
        natual.limit(20).forEach(System.out::println);
    }
}

class NatualSupplier implements Supplier&lt;Integer&gt; {
    int n = 0;
    public Integer get() {
        n++;
        return n;
    }
}</code></pre><p>上述代码我们用一个Supplier<Integer>模拟了一个无限序列（当然受int范围限制不是真的无限大）。如果用List表示，即便在int范围内，也会占用巨大的内存，而Stream几乎不占用空间，因为每个元素都是实时计算出来的，用的时候再算。</p>
<p>对于无限序列，如果直接调用forEach()或者count()这些最终求值操作，会进入死循环，因为永远无法计算完这个序列，所以正确的方法是先把无限序列变成有限序列，例如，用limit()方法可以截取前面若干个元素，这样就变成了一个有限序列，对这个有限序列调用forEach()或者count()操作就没有问题。</p>
<h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><p>创建Stream的第三种方法是通过一些API提供的接口，直接获得Stream。</p>
<p>例如，Files类的lines()方法可以把一个文件变成一个Stream，每个元素代表文件的一行内容：</p>
<pre><code>try (Stream&lt;String&gt; lines = Files.lines(Paths.get(&quot;/path/to/file.txt&quot;))) {
    ...
}</code></pre><p>此方法对于按行遍历文本文件十分有用。</p>
<p>另外，正则表达式的Pattern对象有一个splitAsStream()方法，可以直接把一个长字符串分割成Stream序列而不是数组：</p>
<pre><code>Pattern p = Pattern.compile(&quot;\\s+&quot;);
Stream&lt;String&gt; s = p.splitAsStream(&quot;The quick brown fox jumps over the lazy dog&quot;);
s.forEach(System.out::println);</code></pre><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><p>因为Java的泛型不支持基本类型，所以我们无法用Stream<int>这样的类型，会发生编译错误。为了保存int，只能使用Stream<Integer>,但这样会产生频繁<br>的装箱、拆箱操作。为了提高效率，Java标准库提供了<code>IntStream</code>、<code>LongStream</code>和<code>DoubleStream</code>这三种使用基本类型的<code>Stream</code>,它们的使用方法和<br>泛型Stream没有大的区别，设计这三个Stream的目的是提高运行效率：</p>
<pre><code>// 将int[]数组变为IntStream:
IntStream is = Arrays.stream(new int[] { 1, 2, 3 });
// 将Stream&lt;String&gt;转换为LongStream:
LongStream ls = List.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;).stream().mapToLong(Long::parseLong);</code></pre><h5 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h5><p>编写一个能输出斐波拉契数列（Fibonacci）的LongStream：</p>
<p>1, 1, 2, 3, 5, 8, 13, 21, 34, …</p>
<pre><code>public class Main {
    public static void main(String[] args) {
        LongStram fib = LongStram.generate(new FibSupplier());
        // 打印Fibonacci数列
        fib.limit(10).forEach(System.out::println);
    }
}

class FibSupplier implements LongSupplier {
    long n1 = 0;
    long n2 = 0;
    long n3 = 1;
    public long getAsLong() {
        n1 = n2;
        n2 = n3;
        n3 = n1 + n2;
        return n2;
    }
}    </code></pre><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><p>创建<code>Stream</code>的方法有：</p>
<ul>
<li>通过指定元素、指定数组、指定Collection创建Stream;</li>
<li>通过Supplier创建Stream,可以是无限序列；</li>
<li>通过其他类的相关方法创建。</li>
<li>基本类型的Stream有IntStream、LongStream和DoubleStream。</li>
</ul>
<h4 id="使用map"><a href="#使用map" class="headerlink" title="使用map"></a>使用map</h4><p>Stream.map()是Stream最常用的一个转换方法，它把一个Stream转换为另一个Stream。<br>所谓map操作，就是把一种操作运算，映射到一个序列的每一个元素上。例如，对<code>x</code>计算它的平方，可以使用函数<code>f(x) = x * x</code>。我们把这个函数映射到一个<br>序列1,2,3,4,5上，就得到了另一个序列1,4,9,16,25：</p>
<pre><code>  f(x) = x * x

                  │
                  │
  ┌───┬───┬───┬───┼───┬───┬───┬───┐
  │   │   │   │   │   │   │   │   │
  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼

[ 1   2   3   4   5   6   7   8   9 ]

  │   │   │   │   │   │   │   │   │
  │   │   │   │   │   │   │   │   │
  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼

[ 1   4   9  16  25  36  49  64  81 ]</code></pre><p>可见，map操作，把一个Stream的每个元素一一对应到应用了目标函数的结果上。</p>
<pre><code>Stream&lt;Integer&gt; s = Stream.of(1, 2, 3, 4, 5);
Stream&lt;Integer&gt; s2 = s.map(n -&gt; n * n);</code></pre><p>如果我们查看Stream的源码，会发现map()方法接收的对象是Function接口对象，它定义了一个apply（）方法，负责把一个<code>T</code>类型转换成<code>R</code>类型：</p>
<pre><code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</code></pre><p>其中<code>Function</code>的定义是：</p>
<pre><code>@FunctionalInterface
public interface Function&lt;T, R&gt; {
    // 将T类型转换为R
    R apply(T t);
}    </code></pre><p>利用<code>map()</code>,不但能完成数学计算，对于字符串操作，以及任何Java对象都是非常有用的。例如：</p>
<pre><code>public class Main {
    public static void main(String[] args) {
        List.of(&quot;  Apple &quot;, &quot; pear &quot;, &quot; ORANGE&quot;, &quot; BaNaNa &quot;)
            .stream()
            .map(String::trim) // 去空格
            .map(String::toLowerCase) // 变小写
            .forEach(System.out::println); // 打印
    }
}    </code></pre><p>通过若干步<code>map</code>转换，可以写出逻辑简单、清晰的代码。</p>
<h5 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h5><p>使用map（）把一组<code>String</code>转换为<code>LocalDate</code>并打印。    </p>
<pre><code>Stream&lt;String&gt;  stringStream = Arrays.stream(new String[]{&quot;2020-04-01&quot;,&quot;2020-04-02&quot;,&quot;2020-04-03&quot;,&quot;2020-04-04&quot;});
stringStream.map(LocalDate::parse).forEach(System.out::println);

public class MapProblem {
    public static void main(String[] args) {
        String[] array = new String[] {
                &quot; 2019-12-31 &quot;, &quot;2020 - 01-09&quot;, &quot;2020- 05 - 01 &quot;,
                &quot;2022 - 02 - 01&quot;, &quot;2025-01 -01&quot;};
        Arrays.stream(array)
                .map(s -&gt; s.replaceAll(&quot;\\s+&quot;, &quot;&quot;))
                .map(LocalDate::parse)
                .forEach(System.out::println);
    }
}        </code></pre><h5 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h5><p><code>map()</code>方法用于将一个<code>Stream</code>的每个元素映射成另一个元素并转换成一个新的<code>Stream</code>;</p>
<p><strong>可以将一种元素类型转换成另一种元素类型。</strong></p>
<h4 id="使用filter"><a href="#使用filter" class="headerlink" title="使用filter"></a>使用filter</h4><p>Stream.filter()是Stream的另一个常用转换方法。</p>
<p>所谓filter()操作，就是对一个Stream的所有元素一一进行测试，不满足条件的就被“滤掉”了，剩下的满足条件的元素就构成了一个新的Stream。</p>
<p>例如，我们对1，2，3，4，5这个Stream调用filter()，传入的测试函数f(x) = x % 2 != 0用来判断元素是否是奇数，这样就过滤掉偶数，只剩下奇数，因此我们得到了另一个序列1，3，5：</p>
<pre><code>          f(x) = x % 2 != 0

                  │
                  │
  ┌───┬───┬───┬───┼───┬───┬───┬───┐
  │   │   │   │   │   │   │   │   │
  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼

[ 1   2   3   4   5   6   7   8   9 ]

  │   X   │   X   │   X   │   X   │
  │       │       │       │       │
  ▼       ▼       ▼       ▼       ▼

[ 1       3       5       7       9 ]</code></pre><p>用IntStream写出上述逻辑，代码如下：</p>
<pre><code>public class Main {
    public static void main(String[] args) {
        IntStream.of(1, 2, 3, 4, 5, 6, 7, 8, 9)
                .filter(n -&gt; n % 2 != 0)
                .forEach(System.out::println);
    }
}</code></pre><p>从结果可知，经过filter()后生成的Stream元素可能变少。</p>
<p>filter()方法接收的对象是Predicate接口对象，它定义了一个test()方法，负责判断元素是否符合条件：</p>
<pre><code>@FunctionalInterface
public interface Predicate&lt;T&gt; {
    // 判断元素t是否符合条件:
    boolean test(T t);
}</code></pre><p>filter()除了常用于数值外，也可应用于任何Java对象。例如，从一组给定的LocalDate中过滤掉工作日，以便得到休息日：</p>
<pre><code>public class Main {
    public static void main(String[] args) {
        Stream.generate(new LocalDateSupplier())
                .limit(31)
                .filter(ldt -&gt; ldt.getDayOfWeek() == DayOfWeek.SATURDAY || ldt.getDayOfWeek() == DayOfWeek.SUNDAY)
                .forEach(System.out::println);
    }
}

class LocalDateSupplier implements Supplier&lt;LocalDate&gt; {
    LocalDate start = LocalDate.of(2020, 1, 1);
    int n = -1;
    public LocalDate get() {
        n++;
        return start.plusDays(n);
    }
}</code></pre><h5 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h5><p>请使用filter()过滤出成绩及格的同学，并打印出名字。</p>
<pre><code>public class Main {

    public static void main(String[] args) {
        List&lt;Person&gt; persons = List.of(new Person(&quot;小明&quot;, 88), new Person(&quot;小黑&quot;, 62), new Person(&quot;小白&quot;, 45),
                new Person(&quot;小黄&quot;, 78), new Person(&quot;小红&quot;, 99), new Person(&quot;小林&quot;, 58));
        // 请使用filter过滤出及格的同学，然后打印名字:
        persons.stream()
        .filter(p -&gt; p.score &gt;= 60)
        .map(s -&gt; s.name)
        .forEach(System.out::println);
    }
}

class Person {
    String name;
    int score;

    Person(String name, int score) {
        this.name = name;
        this.score = score;
    }
}</code></pre><h5 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h5><p>使用filter()方法可以对一个Stream的每个元素进行测试，通过测试的元素被过滤后生成一个新的Stream。</p>
<h4 id="使用reduce"><a href="#使用reduce" class="headerlink" title="使用reduce"></a>使用reduce</h4><p><code>map()</code>和<code>filter()</code>都是<code>Stream</code>的转换方法，而<code>Stream.reduce()</code>则是Stream的一个聚合方法，它可以把一个Stream的所有元素按照聚合函数聚合成一个结果。</p>
<p>我们来看一个简单的聚合方法：</p>
<pre><code>public class Main {
    public static void main(String[] args) {
        int sum = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9).reduce(0, (acc,n) -&gt; acc + n);
        System.out.println(sum); // 45
    }
}</code></pre><p>reduce()方法传入的对象是BinaryOperator接口，它定义了一个apply()方法，负责把上次累加的结果和本次的元素进行运算，并返回累加的结果：</p>
<pre><code>@FunctionalInterface
public interface BinaryOperator&lt;T&gt; {
    // Bi操作：两个输入，一个输出
    T apply (T t, T u);
}    </code></pre><p>上述代码看上去不好理解，但我们用for循环改写一下，就容易理解了：</p>
<pre><code>Stream&lt;Integer&gt; stream = ...
int sum = 0;
for (n : stream) {
    sum = (sum, n) -&gt; sum + n;
}    </code></pre><p>可见，reduce()操作首先初始化结果为指定值(这里是0),紧接着，reduce()对每个元素依次调用<code>(acc, n) -&gt; acc + n</code>,其中，<code>acc</code>是上次计算的结果：    </p>
<pre><code>// 计算过程:
acc = 0 // 初始化为指定值
acc = acc + n = 0 + 1 = 1 // n = 1
acc = acc + n = 1 + 2 = 3 // n = 2
acc = acc + n = 3 + 3 = 6 // n = 3
acc = acc + n = 6 + 4 = 10 // n = 4
acc = acc + n = 10 + 5 = 15 // n = 5
acc = acc + n = 15 + 6 = 21 // n = 6
acc = acc + n = 21 + 7 = 28 // n = 7
acc = acc + n = 28 + 8 = 36 // n = 8
acc = acc + n = 36 + 9 = 45 // n = 9</code></pre><p>因此，实际上这个reduce()操作是一个求和。<br>如果去掉初始值，我们会得到一个<code>Optional&lt;Integer&gt;</code>:</p>
<pre><code>Optional&lt;Integer&gt; opt = stream.reduce((acc, n) -&gt; acc + n);
if(opt.isPresent()) {
    System.out.println(opt.get());
}</code></pre><p>这是因为Stream的元素有可能是0个，这样就没法调用reduce()的聚合函数了，因此返回Optional对象，需要进一步判断结果是否存在。<br>利用reduce(),我们可以把求和改为求积，代码也十分简单：</p>
<pre><code>public class Main {
    public static void main(String[] args) {
        int s = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9).reduce(1, (acc, n) -&gt; acc * n);
        System.out.println(s); // 362880
    }
}        </code></pre><p>** 注意:计算求积时，初始值必须设置为1**</p>
<p>除了可以对数值进行累积计算外，灵活运用reduce()也可以对java对象进行操作。下面的代码演示了如何将配置文件的每一行配置通过map（）和reduce（）操作聚合<br>成一个Map&lt;String, String&gt;:</p>
<pre><code>public class Main {
    public static void main(String[] args) {
        // 按行读取配置文件:
        List&lt;String&gt; props = List.of(&quot;profile=native&quot;, &quot;debug=true&quot;, &quot;logging=warn&quot;, &quot;interval=500&quot;);
        Map&lt;String, String&gt; map = props.stream()
        // 把k=v转换为Map[k]=v
        .map(kv -&gt; {
            String[] ss = kv.split(&quot;\\=&quot;, 2);
            return Map.of(ss[0], ss[1]);
        })
        // 把所有Map聚合到一个Map:
        .reduce(new HashMap&lt;String, String&gt;(), (m, kv) -&gt; {
            m.putAll(kv);
            return m;
        });
    // 打印结果
    map.forEach((k, v) -&gt; {
        System.out.println(k + &quot;=&quot; + v);
    });
    }
}</code></pre><h5 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h5><p><code>reduce()</code>方法将一个<code>Stream</code>的每个元素依次作用于<code>BinaryOperator</code>,并将结果合并。</p>
<p><code>reduce()</code>是聚合方法，聚合方法会立刻对<code>Stream</code>进行计算。   </p>
<h4 id="输出集合"><a href="#输出集合" class="headerlink" title="输出集合"></a>输出集合</h4><p>我们介绍了Stream的几个常见操作：map()、filter()、reduce()。这些操作对Stream来说可以分为两类，一类是转换操作，即把一个Stream转换为另一个Stream，例如map()和filter()，另一类是聚合操作，即对Stream的每个元素进行计算，得到一个确定的结果，例如reduce()。</p>
<p>区分这两种操作是非常重要的，因为对于Stream来说，对其进行转换操作并不会触发任何计算！我们可以做个实验：</p>
<pre><code>public class Main {
    public static void main(String[] args) {
        Stream&lt;Long&gt; s1 = Stream.generate(new NatualSupplier());
        Stream&lt;Long&gt; s2 = s1.map(n -&gt; n*n);
        Stream&lt;Long&gt; s3 = s2.map(n -&gt; n -1);
        System.out.println(s3); // java.util.stream.ReferencePipeline$3@49476842
    }
}

class NatualSupplier implements Supplier&lt;Long&gt; {
    long n = 0;
    public Long get() {
        n++;
        return n;
    }
}</code></pre><p>因为s1是一个Long类型的序列，它的元素高达922亿亿个，但执行上述代码，既不会有任何内存增长，也不会有任何计算，因为转换操作只是保存了转换规则，无论我们对一个Stream转换多少次，都不会有任何实际计算发生。</p>
<p>而聚合操作则不一样，聚合操作会立刻促使Stream输出它的每一个元素，并依次纳入计算，以获得最终结果。所以，对一个Stream进行聚合操作，会触发一系列连锁反应：</p>
<pre><code>Stream&lt;Long&gt; s1 = Stream.generate(new NatualSupplier());
Stream&lt;Long&gt; s2 = s1.map(n -&gt; n * n);
Stream&lt;Long&gt; s3 = s2.map(n -&gt; n - 1);
Stream&lt;Long&gt; s4 = s3.limit(10);
s4.reduce(0, (acc, n) -&gt; acc + n);</code></pre><h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h2 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h2><h2 id="Spring开发"><a href="#Spring开发" class="headerlink" title="Spring开发"></a>Spring开发</h2><h2 id="Spring-Boot开发"><a href="#Spring-Boot开发" class="headerlink" title="Spring Boot开发"></a>Spring Boot开发</h2><h2 id="Spring-Cloud开发"><a href="#Spring-Cloud开发" class="headerlink" title="Spring Cloud开发"></a>Spring Cloud开发</h2>]]></content>
  </entry>
  <entry>
    <title>Maven全局配置文件Seetings.xml详解</title>
    <url>/2020/12/18/Maven%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6Seetings.xml%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="maven全局配置文件settings-xml详解"><a href="#maven全局配置文件settings-xml详解" class="headerlink" title="maven全局配置文件settings.xml详解"></a>maven全局配置文件settings.xml详解</h1><h2 id="settings-xml有什么用"><a href="#settings-xml有什么用" class="headerlink" title="settings.xml有什么用"></a>settings.xml有什么用</h2><pre><code>1、用来设置maven参数的配置文件。
2、是maven的全局配置文件。（pom.xml文件是所在项目的局部配置）
3、settings.xml中包含类似本地仓储位置、修改远程仓储服务器、认证信息等配置</code></pre><h2 id="settings-xml文件位置"><a href="#settings-xml文件位置" class="headerlink" title="settings.xml文件位置"></a>settings.xml文件位置</h2><pre><code>settings.xml文件一般存在于两个位置：
全局配置: ${M2_HOME}/conf/settings.xml
用户配置: user.home/.m2/settings.xmlnote：
用户配置优先于全局配置。{user.home} 
和所有其他系统属性只能在3.0+版本上使用。
请注意windows和Linux使用变量的区别。</code></pre><h2 id="配置优先级-pom-xml-gt-user-settings-gt-global-settings"><a href="#配置优先级-pom-xml-gt-user-settings-gt-global-settings" class="headerlink" title="配置优先级 pom.xml&gt; user settings &gt; global settings"></a>配置优先级 pom.xml&gt; user settings &gt; global settings</h2><pre><code>需要注意的是：局部配置优先于全局配置。
配置优先级从高到低：pom.xml&gt; user settings &gt; global settings
如果这些文件同时存在，在应用配置时，会合并它们的内容，
如果有重复的配置，优先级高的配置会覆盖优先级低的。</code></pre><h2 id="settings-xml元素详解"><a href="#settings-xml元素详解" class="headerlink" title="settings.xml元素详解"></a>settings.xml元素详解</h2><h3 id="顶级元素概览"><a href="#顶级元素概览" class="headerlink" title="顶级元素概览"></a>顶级元素概览</h3><pre><code>&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0
                          https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;
  &lt;localRepository/&gt;
  &lt;interactiveMode/&gt;
  &lt;usePluginRegistry/&gt;
  &lt;offline/&gt;
  &lt;pluginGroups/&gt;
  &lt;servers/&gt;
  &lt;mirrors/&gt;
  &lt;proxies/&gt;
  &lt;profiles/&gt;
  &lt;activeProfiles/&gt;
&lt;/settings&gt;</code></pre><h3 id="LocalRepository"><a href="#LocalRepository" class="headerlink" title="LocalRepository"></a>LocalRepository</h3><p><strong>作用：该值表示构建系统本地仓库的路径</strong></p>
<p>默认值： ~/.m2/repository</p>
<pre><code>&lt;localRepository&gt;${user.home}/.m2/repository&lt;/localRepository&gt;</code></pre><h3 id="InteractiveMode"><a href="#InteractiveMode" class="headerlink" title="InteractiveMode"></a>InteractiveMode</h3><p>作用：表示maven是否需要和用户交互以获得输入。</p>
<p>如果maven需要和用户交互以获得输入，则设置成true，反之则应为false。默认为true</p>
<pre><code>&lt;interactiveMode&gt;true&lt;/interactiveMode&gt;</code></pre><h3 id="UsePluginRegistry"><a href="#UsePluginRegistry" class="headerlink" title="UsePluginRegistry"></a>UsePluginRegistry</h3><p><strong>作用：maven是否需要使用plugin-registry.xml文件来管理插件版本。<br>如果需要让maven使用文件~/.m2/plugin-registry.xml来管理插件版本，则设为true。默认为false。</strong></p>
<pre><code>&lt;usePluginRegistry&gt;false&lt;/usePluginRegistry&gt;</code></pre><h3 id="Offline"><a href="#Offline" class="headerlink" title="Offline"></a>Offline</h3><p><strong>作用：表示maven是否需要在离线模式下运行。<br>  如果构建系统需要在离线模式下运行，则为true，默认为false。<br>  当由于网络设置原因或者安全因素，构建服务器不能连接远程仓库的时候，该配置就十分有用。</strong></p>
<pre><code>&lt;offline&gt;false&lt;/offline&gt;</code></pre><h3 id="PluginGroups"><a href="#PluginGroups" class="headerlink" title="PluginGroups"></a>PluginGroups</h3><p><strong>作用：当插件的组织id（groupId）没有显式提供时，供搜寻插件组织Id（groupId）的列表。<br>该元素包含一个pluginGroup元素列表，每个子元素包含了一个组织Id（groupId）。<br>当我们使用某个插件，并且没有在命令行为其提供组织Id（groupId）的时候，Maven就会使用该列表。默认情况下该列表包含了<code>org.apache.maven.plugins</code>和<code>org.codehaus.mojo</code>。</strong></p>
<pre><code>&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0
                      https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;
  ...
  &lt;pluginGroups&gt;
    &lt;!--plugin的组织Id（groupId） --&gt;
    &lt;pluginGroup&gt;org.codehaus.mojo&lt;/pluginGroup&gt;
  &lt;/pluginGroups&gt;
  ...
&lt;/settings&gt; </code></pre><h3 id="Servers"><a href="#Servers" class="headerlink" title="Servers"></a>Servers</h3><p><strong>作用：一般，仓库的下载和部署是在pom.xml文件中的<code>repositories</code>和<code>distributionManagenment</code><br>元素中定义的。然而，一般类似用户名、密码（有些仓库访问是需要安全认证的）等信息不应该在pom.xml文件中配置，<br>这些信息可以配置在<code>settings.xml</code>中。</strong></p>
<pre><code>&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0
                      https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;
  ...
  &lt;!--配置服务端的一些设置。一些设置如安全证书不应该和pom.xml一起分发。这种类型的信息应该存在于构建服务器上的settings.xml文件中。 --&gt;
  &lt;servers&gt;
    &lt;!--服务器元素包含配置服务器时需要的信息 --&gt;
    &lt;server&gt;
      &lt;!--这是server的id（注意不是用户登陆的id），该id与distributionManagement中repository元素的id相匹配。 --&gt;
      &lt;id&gt;server001&lt;/id&gt;
      &lt;!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --&gt;
      &lt;username&gt;my_login&lt;/username&gt;
      &lt;!--鉴权密码 。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。密码加密功能已被添加到2.1.0 +。详情请访问密码加密页面 --&gt;
      &lt;password&gt;my_password&lt;/password&gt;
      &lt;!--鉴权时使用的私钥位置。和前两个元素类似，私钥位置和私钥密码指定了一个私钥的路径（默认是${user.home}/.ssh/id_dsa）以及如果需要的话，一个密语。将来passphrase和password元素可能会被提取到外部，但目前它们必须在settings.xml文件以纯文本的形式声明。 --&gt;
      &lt;privateKey&gt;${usr.home}/.ssh/id_dsa&lt;/privateKey&gt;
      &lt;!--鉴权时使用的私钥密码。 --&gt;
      &lt;passphrase&gt;some_passphrase&lt;/passphrase&gt;
      &lt;!--文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。这两个元素合法的值是一个三位数字，其对应了unix文件系统的权限，如664，或者775。 --&gt;
      &lt;filePermissions&gt;664&lt;/filePermissions&gt;
      &lt;!--目录被创建时的权限。 --&gt;
      &lt;directoryPermissions&gt;775&lt;/directoryPermissions&gt;
    &lt;/server&gt;
  &lt;/servers&gt;
  ...
&lt;/settings&gt;</code></pre><h3 id="Mirrors"><a href="#Mirrors" class="headerlink" title="Mirrors"></a>Mirrors</h3><p><strong>作用：为仓库列表配置的下载镜像列表。</strong></p>
<pre><code>&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0
                      https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;
  ...
  &lt;mirrors&gt;
    &lt;!-- 给定仓库的下载镜像。 --&gt;
    &lt;mirror&gt;
      &lt;!-- 该镜像的唯一标识符。id用来区分不同的mirror元素。 --&gt;
      &lt;id&gt;planetmirror.com&lt;/id&gt;
      &lt;!-- 镜像名称 --&gt;
      &lt;name&gt;PlanetMirror Australia&lt;/name&gt;
      &lt;!-- 该镜像的URL。构建系统会优先考虑使用该URL，而非使用默认的服务器URL。 --&gt;
      &lt;url&gt;http://downloads.planetmirror.com/pub/maven2&lt;/url&gt;
      &lt;!-- 被镜像的服务器的id。例如，如果我们要设置了一个Maven中央仓库（http://repo.maven.apache.org/maven2/）的镜像，就需要将该元素设置成central。这必须和中央仓库的id central完全一致。 --&gt;
      &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
    &lt;/mirror&gt;
  &lt;/mirrors&gt;
  ...
&lt;/settings&gt;</code></pre><h3 id="Proxies"><a href="#Proxies" class="headerlink" title="Proxies"></a>Proxies</h3><p><strong>作用：用来配置不同的代理。</strong></p>
<pre><code>&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0
                      https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;
  ...
  &lt;proxies&gt;
    &lt;!--代理元素包含配置代理时需要的信息 --&gt;
    &lt;proxy&gt;
      &lt;!--代理的唯一定义符，用来区分不同的代理元素。 --&gt;
      &lt;id&gt;myproxy&lt;/id&gt;
      &lt;!--该代理是否是激活的那个。true则激活代理。当我们声明了一组代理，而某个时候只需要激活一个代理的时候，该元素就可以派上用处。 --&gt;
      &lt;active&gt;true&lt;/active&gt;
      &lt;!--代理的协议。 协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt;
      &lt;protocol&gt;http&lt;/protocol&gt;
      &lt;!--代理的主机名。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt;
      &lt;host&gt;proxy.somewhere.com&lt;/host&gt;
      &lt;!--代理的端口。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt;
      &lt;port&gt;8080&lt;/port&gt;
      &lt;!--代理的用户名，用户名和密码表示代理服务器认证的登录名和密码。 --&gt;
      &lt;username&gt;proxyuser&lt;/username&gt;
      &lt;!--代理的密码，用户名和密码表示代理服务器认证的登录名和密码。 --&gt;
      &lt;password&gt;somepassword&lt;/password&gt;
      &lt;!--不该被代理的主机名列表。该列表的分隔符由代理服务器指定；例子中使用了竖线分隔符，使用逗号分隔也很常见。 --&gt;
      &lt;nonProxyHosts&gt;*.google.com|ibiblio.org&lt;/nonProxyHosts&gt;
    &lt;/proxy&gt;
  &lt;/proxies&gt;
  ...
&lt;/settings&gt;</code></pre><h3 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h3><p><strong>作用：根据环境参数来调整构建配置的列表。<br><code>settings.xml</code>中的<code>profile</code>元素是<code>pom.xml</code>中<code>profile</code>元素的裁剪版本。<br>它包含了<code>id</code>、<code>activation</code>、<code>repositories</code>、<code>pluginRepositories</code>和<br><code>properties</code>元素。这里的<code>profile</code>元素只包含这五个子元素是因为这里只关<br>心构建系统这个整体（这正是<code>settings.xml</code>文件的角色定位），<br>而非单独的项目对象模型设置。如果一个<code>settings.xml</code>中的<code>profile</code>被激活，<br>它的值会覆盖任何其它定义在<code>pom.xml</code>中带有相同id的<code>profile</code>。</strong></p>
<pre><code>&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0
                      https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;!-- profile的唯一标识 --&gt;
      &lt;id&gt;test&lt;/id&gt;
      &lt;!-- 自动触发profile的条件逻辑 --&gt;
      &lt;activation /&gt;
      &lt;!-- 扩展属性列表 --&gt;
      &lt;properties /&gt;
      &lt;!-- 远程仓库列表 --&gt;
      &lt;repositories /&gt;
      &lt;!-- 插件仓库列表 --&gt;
      &lt;pluginRepositories /&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
  ...
&lt;/settings&gt;</code></pre><h3 id="Activation"><a href="#Activation" class="headerlink" title="Activation"></a>Activation</h3><p>作用：自动触发profile的条件逻辑。<br>如pom.xml中的profile一样，profile的作用在于它能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。<br>activation元素并不是激活profile的唯一方式。settings.xml文件中的activeProfile元素可以包含profile的id。profile也可以通过在命令行，使用-P标记和逗号分隔的列表来显式的激活（如，-P test)。</p>
<pre><code>&lt;activation&gt;
  &lt;!--profile默认是否激活的标识 --&gt;
  &lt;activeByDefault&gt;false&lt;/activeByDefault&gt;
  &lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt;
  &lt;jdk&gt;1.5&lt;/jdk&gt;
  &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;
  &lt;os&gt;
    &lt;!--激活profile的操作系统的名字 --&gt;
    &lt;name&gt;Windows XP&lt;/name&gt;
    &lt;!--激活profile的操作系统所属家族(如 &apos;windows&apos;) --&gt;
    &lt;family&gt;Windows&lt;/family&gt;
    &lt;!--激活profile的操作系统体系结构 --&gt;
    &lt;arch&gt;x86&lt;/arch&gt;
    &lt;!--激活profile的操作系统版本 --&gt;
    &lt;version&gt;5.1.2600&lt;/version&gt;
  &lt;/os&gt;
  &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过${name}引用），其拥有对应的name = 值，Profile就会被激活。如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;
  &lt;property&gt;
    &lt;!--激活profile的属性的名称 --&gt;
    &lt;name&gt;mavenVersion&lt;/name&gt;
    &lt;!--激活profile的属性的值 --&gt;
    &lt;value&gt;2.0.3&lt;/value&gt;
  &lt;/property&gt;
  &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;
  &lt;file&gt;
    &lt;!--如果指定的文件存在，则激活profile。 --&gt;
    &lt;exists&gt;${basedir}/file2.properties&lt;/exists&gt;
    &lt;!--如果指定的文件不存在，则激活profile。 --&gt;
    &lt;missing&gt;${basedir}/file1.properties&lt;/missing&gt;
  &lt;/file&gt;
&lt;/activation&gt;</code></pre><p><strong>注：在maven工程的pom.xml所在目录下执行mvn help:active-profiles命令可以查看中央仓储的profile是否在工程中生效。</strong></p>
<h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p><strong>作用：对应<code>profile</code>的扩展属性列表。maven属性和ant中的属性一样，可以用来存放一些值。<br>这些值可以在<code>pom.xml</code>中的任何地方使用标记<code>${x}</code>来使用，这里X是指属性的名称。属性有五种不同的形式，<br>并且都能在settings.xml文件中访问</strong></p>
<pre><code>&lt;!--
    1. env.X: 在一个变量前加上&quot;env.&quot;的前缀，会返回一个shell环境变量。例如，&quot;env.PATH&quot;指代了$path环境变量（在Windows上是%PATH%）。
    2. project.x:指代了POM中对应的元素值。例如：&lt;project&gt;&lt;version&gt;1.0&lt;/version&gt;&lt;/project&gt;通过${project.version}获得version的值。
    3. settings.x: 指代了settings.xml中对应元素的值。例如：&lt;settings&gt;&lt;offline&gt;false&lt;/offline&gt;&lt;/settings&gt;通过 ${settings.offline}获得offline的值。 
    4. Java System Properties: 所有可通过java.lang.System.getProperties()访问的属性都能在POM中使用该形式访问，例如 ${java.home}。 
    5. x: 在&lt;properties/&gt;元素中，或者外部文件中设置，以${someVar}的形式使用。
     --&gt;
    &lt;properties&gt;
      &lt;user.install&gt;${user.home}/our-project&lt;/user.install&gt;
    &lt;/properties&gt;
--&gt;</code></pre><p>注：如果该profile被激活，则可以在pom.xml中使用${user.install}。</p>
<h3 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a>Repositories</h3><p>作用：远程仓库列表，它是maven用来填充构建系统本地仓库所使用的一组远程仓库。</p>
<pre><code>&lt;repositories&gt;
  &lt;!--包含需要连接到远程仓库的信息 --&gt;
  &lt;repository&gt;
    &lt;!--远程仓库唯一标识 --&gt;
    &lt;id&gt;codehausSnapshots&lt;/id&gt;
    &lt;!--远程仓库名称 --&gt;
    &lt;name&gt;Codehaus Snapshots&lt;/name&gt;
    &lt;!--如何处理远程仓库里发布版本的下载 --&gt;
    &lt;releases&gt;
      &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;
      &lt;enabled&gt;false&lt;/enabled&gt;
      &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;
      &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;
      &lt;!--当Maven验证构件校验文件失败时该怎么做-ignore（忽略），fail（失败），或者warn（警告）。 --&gt;
      &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt;
    &lt;/releases&gt;
    &lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;
    &lt;snapshots&gt;
      &lt;enabled /&gt;
      &lt;updatePolicy /&gt;
      &lt;checksumPolicy /&gt;
    &lt;/snapshots&gt;
    &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;
    &lt;url&gt;http://snapshots.maven.codehaus.org/maven2&lt;/url&gt;
    &lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;
    &lt;layout&gt;default&lt;/layout&gt;
  &lt;/repository&gt;
&lt;/repositories&gt;</code></pre><h3 id="pluginRepositories"><a href="#pluginRepositories" class="headerlink" title="pluginRepositories"></a>pluginRepositories</h3><p>作用：发现插件的远程仓库列表。<br>和repository类似，只是repository是管理jar包依赖的仓库，pluginRepositories则是管理插件的仓库。<br>maven插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。pluginRepositories元素的结构和repositories元素的结构类似。每个pluginRepository元素指定一个Maven可以用来寻找新插件的远程地址。</p>
<pre><code>&lt;pluginRepositories&gt;
  &lt;!-- 包含需要连接到远程插件仓库的信息.参见profiles/profile/repositories/repository元素的说明 --&gt;
  &lt;pluginRepository&gt;
    &lt;releases&gt;
      &lt;enabled /&gt;
      &lt;updatePolicy /&gt;
      &lt;checksumPolicy /&gt;
    &lt;/releases&gt;
    &lt;snapshots&gt;
      &lt;enabled /&gt;
      &lt;updatePolicy /&gt;
      &lt;checksumPolicy /&gt;
    &lt;/snapshots&gt;
    &lt;id /&gt;
    &lt;name /&gt;
    &lt;url /&gt;
    &lt;layout /&gt;
  &lt;/pluginRepository&gt;
&lt;/pluginRepositories&gt;</code></pre><h3 id="ActiveProfiles"><a href="#ActiveProfiles" class="headerlink" title="ActiveProfiles"></a>ActiveProfiles</h3><p>作用：手动激活profiles的列表，按照profile被应用的顺序定义activeProfile。<br>该元素包含了一组activeProfile元素，每个activeProfile都含有一个profile id。任何在activeProfile中定义的profile id，不论环境设置如何，其对应的 profile都会被激活。如果没有匹配的profile，则什么都不会发生。<br>例如，env-test是一个activeProfile，则在pom.xml（或者profile.xml）中对应id的profile会被激活。如果运行过程中找不到这样一个profile，Maven则会像往常一样运行。</p>
<pre><code>&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0
                      https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;
  ...
  &lt;activeProfiles&gt;
    &lt;!-- 要激活的profile id --&gt;
    &lt;activeProfile&gt;env-test&lt;/activeProfile&gt;
  &lt;/activeProfiles&gt;
  ...
&lt;/settings&gt;</code></pre>]]></content>
  </entry>
  <entry>
    <title>MySQL规范</title>
    <url>/2020/12/18/MySQL%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="建表规约"><a href="#建表规约" class="headerlink" title="建表规约"></a>建表规约</h1><p>【强制】 表达是与否概念的字段，必须使用is_xxx 的方式命名，数据类型是unsigned tinyint (1表示是，0表示否)。</p>
<p>说明: 任何字段如果为非负数，必须是unsigned。</p>
<p>注意: POJO类中的任何布尔类型的变量，都不要加is前缀，所以，需要在设置 从is_xxx到Xxx的映射关系。数据库表示是与否的值，使用tinyint类型，坚持is_xxx的命名方式是为了明确其取值含义与取值范围。</p>
<p>正例: 表达逻辑删除的字段名is_deleted，1 表示删除，0 表示未删除。</p>
<p>【强制】 表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p>
<p>说明: MySQL在Windows下不区分大小写，但在Linux下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。</p>
<p>正例: aliyun_admin，rdc_config，level3_name</p>
<p>反例:AliyunAdmin，rdcConfig，level_3_name</p>
<p>【强制】 表名不使用复数名词。</p>
<p>说明: 表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合表达习惯。</p>
<p>【强制】 禁止保留字，如desc、range、match、delayed等，请参考MySQL官方保留字。</p>
<p>【强制】 主键索引名为pk_字段名;唯一索引名为uk_字段名;普通索引名则为 idx_字段名。</p>
<p>说明: pk_ 即 primary key； uk_ 即 unique key;idx_即index的简称。</p>
<p>【强制】 小数类型为decimal，禁止使用float和double。</p>
<p>说明: float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。</p>
<p>【强制】 如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</p>
<p>【强制】 varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p>
<p>【强制】 表必备三字段:id, gmt_create, gmt_modified。</p>
<p>说明: 其中id必为主键，类型为bigintunsigned、单表时自增、步长为1。gmt_create, gmt_modified 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被动更新。</p>
<p>【推荐】 表的命名最好是加上“业务名称_表的作用”。</p>
<p>正例: alipay_task / force_project / trade_config</p>
<p>【推荐】 库名与应用名称尽量一致。</p>
<p>【推荐】 如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。</p>
<p>【推荐】 字段允许适当冗余，以提高查询性能，但必须考虑数据一致。</p>
<p>冗余字段应遵循:</p>
<p>不是频繁修改的字段。<br>不是 varchar 超长字段，更不能是 text 字段。<br>正例: 商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。</p>
<p>【推荐】 单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。</p>
<p>说明: 如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p>
<p>【参考】 合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。</p>
<p>正例: 如下表，其中无符号值可以避免误存负数，且扩大了表示范围。</p>
<p>对象    年龄区间    类型    字节    表示范围<br>人    150岁之内    tinyint unsigned    1    无符号值:0 到 255<br>龟    数百岁    smallint unsigned    2    无符号值:0 到 65535<br>恐龙化石    数千万年    int unsigned    4    无符号值:0 到约 42.9 亿<br>太阳    约50亿年    bigint unsigned    8    无符号值:0 到约 10 的 19 次方</p>
<h1 id="索引规约"><a href="#索引规约" class="headerlink" title="索引规约"></a>索引规约</h1><p>【强制】 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。</p>
<p>说明: 不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的;另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</p>
<p>【强制】 超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致;多表关联查询时， 保证被关联的字段需要有索引。</p>
<p>说明: 即使双表 join 也要注意表索引、SQL 性能。</p>
<p>【强制】 在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。</p>
<p>说明: 索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。</p>
<p>【强制】 页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p>
<p>说明: 索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p>
<p>【推荐】 如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。</p>
<p>正例: where a=? and b=? order by c; 索引:a_b_c</p>
<p>反例: 索引中有范围查找，那么索引有序性无法利用，如:WHERE a&gt;10 ORDER BY b; 索引 a_b 无法排序。</p>
<p>【推荐】 利用覆盖索引来进行查询操作，避免回表。 *</p>
<p>说明: 如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗?目录浏览一下就好，这个目录就是起到覆盖索引的作用。</p>
<p>正例: 能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用explain的结果，extra列会出现:using index。</p>
<p>【推荐】 利用延迟关联或者子查询优化超多分页场景。</p>
<p>说明: MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。</p>
<p>正例: 先快速定位需要获取的 id 段，然后再关联:SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</p>
<p>【推荐】 SQL 性能优化的目标:至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。</p>
<p>SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</p>
<p>说明:</p>
<p>consts 单表中最多只有一个匹配行(主键或者唯一索引)，在优化阶段即可读取到数据。<br>ref 指的是使用普通的索引(normal index)。<br>range 对索引进行范围检索。<br>反例: explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级别比较range 还低，与全表扫描是小巫见大巫。</p>
<p>【推荐】 建组合索引的时候，区分度最高的在最左边。</p>
<p>正例: 如果 where a=? and b=? ，如果 a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。</p>
<p>说明: 存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如:where c&gt;? and d=? 那么即使 c 的区分度更高，也必须把 d 放在索引的最前列，即索引 idx_d_c。</p>
<p>【推荐】 防止因字段类型不同造成的隐式转换，导致索引失效。</p>
<p>【参考】 创建索引时避免有如下极端误解:</p>
<p>宁滥勿缺。认为一个查询就需要建一个索引。<br>宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。<br>抵制唯一索引。认为业务的唯一性一律需要在应用层通过“先查后插”方式解决。</p>
<h1 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h1><p>【强制】 不要使用 count(列名)或 count(常量)来替代 count()，count()是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。</p>
<p>说明: count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p>
<p>【强制】 count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2)如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。</p>
<p>【强制】 当某一列的值全是 NULL 时，count(col)的返回结果为 0，但sum(col)的返回结果为NULL，因此使用 sum()时需注意 NPE 问题。</p>
<p>正例: 可以使用如下方式来避免sum的NPE问题:SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;</p>
<p>【强制】 使用 ISNULL()来判断是否为 NULL 值。</p>
<p>说明: NULL 与任何值的直接比较都为 NULL。</p>
<p>NULL&lt;&gt;NULL 的返回结果是NULL，而不是false。<br>NULL=NULL 的返回结果是NULL，而不是true。<br>NULL&lt;&gt;1 的返回结果是NULL，而不是true。<br>【强制】 在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。</p>
<p>【强制】 不得使用外键与级联，一切外键概念必须在应用层解决。</p>
<p>说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。</p>
<p>如果更新学生表中的student_id，同时触发成绩表中的 student_id 更新，即为级联更新。</p>
<p>外键与级联更新适用于单机低并发，不适合分布式、高并发集群;<br>级联更新是强阻塞，存在数据库更新风暴的风险;<br>外键影响数据库的插入速度。<br>【强制】 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p>
<p>【强制】 数据订正(特别是删除、修改记录操作)时，要先 select，避免出现误删除，确认无误才能执行更新语句。</p>
<p>【推荐】 in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在1000 个之内。</p>
<p>【参考】 如果有国际化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数的区别。</p>
<p>说明:</p>
<p>SELECT LENGTH(“轻松工作”); 返回为12<br>SELECT CHARACTER_LENGTH(“轻松工作”); 返回为4</p>
<p>如果需要存储表情，那么选择 utf8mb4 来进行存储，注意它与 utf-8 编码的区别。</p>
<p>【参考】 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。</p>
<p>说明: TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p>
<h1 id="ORM映射"><a href="#ORM映射" class="headerlink" title="ORM映射"></a>ORM映射</h1><p>【强制】 在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。</p>
<p>说明:</p>
<p>增加查询分析器解析成本。<br>增减字段容易与 resultMap 配置不一致。<br>无用字段增加网络消耗，尤其是 text 类型的字段。<br>【强制】 POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。</p>
<p>说明: 参见定义 POJO 类以及数据库字段定义规定，在中增加映射，是必须的。 在MyBatis Generator生成的代码中，需要进行对应的修改。</p>
<p>【强制】 不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义;反过来，每一个表也必然有一个 POJO 类与之对应。</p>
<p>说明: 配置映射关系，使字段与 DO 类解耦，方便维护。</p>
<p>【强制】 sql.xml 配置参数使用:#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。</p>
<p>【强制】 iBATIS自带的queryForList(String statementName,int start,int size)不推荐使用。</p>
<p>说明: 其实现方式是在数据库取到 statementName 对应的 SQL 语句的所有记录，再通过 subList取 start,size 的子集合。</p>
<p>正例:</p>
<p>1<br>2<br>3<br>Map&lt; String, Object&gt; map = new HashMap&lt;&gt;();<br>map.put(“start”, start);<br>map.put(“size”, size);<br>【强制】 不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。</p>
<p>说明: resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。</p>
<p>【强制】 更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。</p>
<p>【推荐】 不要写一个大而全的数据更新接口。传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。</p>
<p>执行 SQL 时，不要更新无改动的字段，一是易出错;二是效率低;三是增加 binlog 存储。</p>
<p>【参考】 @Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</p>
<p>【参考】 中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带上此条件;表示不为空且不为 null 时执行;表示不为 null 值时执行。</p>
]]></content>
  </entry>
  <entry>
    <title>Maven构建流程</title>
    <url>/2021/01/16/Maven%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>#构建流程</p>
<h2 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h2><p>Maven不但有标准化的项目结构，而且还有一套标准化的构建流程，可以自动化实现编译，打包，发布，等等。</p>
<h2 id="Lifecycle和Phase"><a href="#Lifecycle和Phase" class="headerlink" title="Lifecycle和Phase"></a>Lifecycle和Phase</h2><p>使用Maven时，我们首先要了解什么是Maven的生命周期（lifecycle)</p>
<p>Maven的生命周期由一系列阶段（phase）构成，以内置的生命周期default为例，它包含以下phase:</p>
<ul>
<li>validate </li>
<li>initialize</li>
<li>generate-sources</li>
<li>process-sources</li>
<li>generate-resources</li>
<li>process-resources</li>
<li>compile</li>
<li>process-classes</li>
<li>generate-test-sources</li>
<li>process-test-sources</li>
<li>generate-test-resources</li>
<li>process-test-resources</li>
<li>test-compile</li>
<li>process-test-classes</li>
<li>test</li>
<li>prepare-package</li>
<li>package</li>
<li>pre-integration-test</li>
<li>integration-test</li>
<li>post-integration-test</li>
<li>verify</li>
<li>install</li>
<li>deploy</li>
</ul>
<p>如果我们运行 mvn package, Maven 就会执行default生命周期，它会从开始一直运行到package这个phase为止：</p>
<ul>
<li>validate</li>
<li>…</li>
<li>package</li>
</ul>
<p>如果我们运行mvn compile,Maven也会执行default生命周期，但这次它只会运行到compile,即已下几个phase:</p>
<ul>
<li>validate</li>
<li>…</li>
<li>package</li>
</ul>
<p>Maven的另一个生命周期是clean，它会执行3个phase:</p>
<ul>
<li>pre-clean</li>
<li>clean(注意这个clean不是lifecycle而是phase)</li>
<li>post-clean</li>
</ul>
<p>所以，我们使用mvn这个命令时，后面的参数是phase，Maven自动根据生命周期运行指定的phase</p>
<p>更复杂的例子是指定多个phase,例如，运行mvn clean package,Maven先执行clean生命周期并运行到clean这个phase，然后执行default生命周期<br>并运行到package这个phase，实际执行的phase如下：</p>
<ul>
<li>pre-clean</li>
<li>clean(注意这个clean是phase)</li>
<li>validate</li>
<li>…</li>
<li>package</li>
</ul>
<p>在实际开发过程中，经常使用的命令有：<br> mvn clean:清理所有生成的class和jar;</p>
<p> mvn clean compile:先清理，再执行compile；</p>
<p> mvn clean test:先清理，再执行test，因为执行test前必须执行compile，所以这里不必指定compile；</p>
<p> mvn clean package:先清理，再执行到package。</p>
<p> 大多数phase在执行过程中，因为我们通常没有在pom.xml中配置相关的设置，所以这些phase什么事情都不做。</p>
<p> 经常用到的phase其实只有几个：</p>
<ul>
<li>clean：清理</li>
<li>compile： 编译</li>
<li>test：运行测试</li>
<li>package：打包</li>
</ul>
<h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>执行一个phase又会触发一个或多个goal:<br>|执行的Phase| 对应执行的Goal |<br>|:— |:—|<br>|compile | compiler:compile |<br>|test | compiler:testCompile<br>    surefire:test |</p>
<p>goal的命名总是abc:xyz这种形式。</p>
<h2 id="lifeCycle、phase、goal类比"><a href="#lifeCycle、phase、goal类比" class="headerlink" title="lifeCycle、phase、goal类比"></a>lifeCycle、phase、goal类比</h2><ul>
<li>lifeCycle相当于Java的package，它包含一个或多个phase;</li>
<li>phase相当于Java的class,它包含一个或多个goal；</li>
<li>goal相当于class的method，它其实才是真正干活的。</li>
</ul>
<p>大多数情况下，我们只要指定phase，就默认执行这些phase默认绑定的goal,只有少数情况，我们可以直接指定运行一个goal，例如：启动Tomcat服务器：</p>
<pre><code>mvn tomcat:run</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Maven通过lifecycle、phase和goal来提供标准的构建流程。</p>
<p>最常用的构建名利是指定phase，然后让Maven执行到指定的phase：</p>
<ul>
<li><p>mvn clean</p>
</li>
<li><p>mvn clean compile</p>
</li>
<li><p>mvn clean test</p>
</li>
<li><p>mvn clean package</p>
<p>通常情况,我们总是执行phase默认绑定的goal，因此不必指定goal。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Vue学习笔记</title>
    <url>/2020/12/18/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Vue学习笔记"><a href="#Vue学习笔记" class="headerlink" title="Vue学习笔记"></a>Vue学习笔记</h1><h2 id="安装与部署"><a href="#安装与部署" class="headerlink" title="安装与部署"></a>安装与部署</h2><p>使用方式</p>
<pre><code>&lt;script&gt;标签
CLI(命令行工具）</code></pre>]]></content>
  </entry>
  <entry>
    <title>OAuth 2.0</title>
    <url>/2021/01/16/OAuth%202.0/</url>
    <content><![CDATA[<h1 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a><a href="https://oauth.net/2/" target="_blank" rel="noopener">OAuth 2.0</a></h1><p>OAuth 2.0 is the industry-standard protocol for authorization. OAuth 2.0 focuses on client developer simplicity while providing specific authorization flows for web applications, desktop applications, mobile phones, and living room devices. This specification and its extensions are being developed within the IETF OAuth Working Group.</p>
<p>OAuth2.0是授权的行业标准协议。OAuth2.0关注于客户机开发人员的简单性，同时为web应用程序、桌面应用程序、移动电话和客厅设备提供特定的授权流。本规范及其扩展正在ietf oauth工作组中开发。    </p>
<p>Questions, suggestions and protocol changes should be discussed on the mailing list.    </p>
<p>问题、建议和方案变更应在邮件列表中讨论。</p>
<h2 id="OAuth-2-0-1"><a href="#OAuth-2-0-1" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h2><ul>
<li><a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">OAuth 2.0 Framework </a> - RFC 6749<ul>
<li><a href="https://oauth.net/2/scope/" target="_blank" rel="noopener">OAuth Scope</a></li>
</ul>
</li>
<li><a href="">OAuth Grant Types</a><ul>
<li><a href="">Authorization Code</a></li>
<li><a href="">PKCE</a></li>
<li><a href="">Client Credentials</a></li>
<li><a href="">Device Code</a></li>
<li><a href="">Refresh Token</a></li>
<li>Legacy: <a href="">Implicit Flow</a></li>
<li>Legacy: <a href="">Password Grant</a></li>
</ul>
</li>
<li><a href="">Client Types - Confidential and Public Applications</a>    </li>
<li><a href="">Bearer Tokens</a> - RFC 6750    </li>
<li><a href="">Threat Model and Security Considerations</a> - RFC 6819    </li>
<li><a href="">OAuth Security Best Current Practice</a>    </li>
</ul>
<h3 id="Mobile-and-Other-Devices"><a href="#Mobile-and-Other-Devices" class="headerlink" title="Mobile and Other Devices"></a>Mobile and Other Devices</h3><ul>
<li><a href="">Native Apps</a> - Recommendations for using OAuth with native apps</li>
<li><a href="">Browser-Based Apps</a> - Recommendations for using OAuth with browser-based apps (e.g. an SPA)</li>
<li><a href="">Device Authorization Grant</a> - OAuth for devices with no browser or no keyboard</li>
</ul>
<h3 id="Token-and-Token-Management"><a href="#Token-and-Token-Management" class="headerlink" title="Token and Token Management"></a>Token and Token Management</h3><h3 id="Discovery-and-Registration"><a href="#Discovery-and-Registration" class="headerlink" title="Discovery and Registration"></a>Discovery and Registration</h3><h3 id="Experimental-and-Draft-Specs"><a href="#Experimental-and-Draft-Specs" class="headerlink" title="Experimental and Draft Specs"></a>Experimental and Draft Specs</h3><h3 id="Related-Specs-and-Extensions"><a href="#Related-Specs-and-Extensions" class="headerlink" title="Related Specs and Extensions"></a>Related Specs and Extensions</h3><h3 id="Community-Resources"><a href="#Community-Resources" class="headerlink" title="Community Resources"></a>Community Resources</h3><h3 id="Protocols-Built-on-OAuth-2-0"><a href="#Protocols-Built-on-OAuth-2-0" class="headerlink" title="Protocols Built on OAuth 2.0"></a>Protocols Built on OAuth 2.0</h3><h3 id="Code-and-Services"><a href="#Code-and-Services" class="headerlink" title="Code and Services"></a>Code and Services</h3><h3 id="OAuth-2-1"><a href="#OAuth-2-1" class="headerlink" title="OAuth 2.1"></a>OAuth 2.1</h3><h3 id="Legacy"><a href="#Legacy" class="headerlink" title="Legacy"></a>Legacy</h3><p>数组交集</p>
]]></content>
  </entry>
  <entry>
    <title>springboot项目中使用filter无法注入bean采坑</title>
    <url>/2021/01/16/springboot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8filter%E6%97%A0%E6%B3%95%E6%B3%A8%E5%85%A5bean%E9%87%87%E5%9D%91/</url>
    <content><![CDATA[<h1 id="springboot项目中使用filter无法注入bean采坑"><a href="#springboot项目中使用filter无法注入bean采坑" class="headerlink" title="springboot项目中使用filter无法注入bean采坑"></a>springboot项目中使用filter无法注入bean采坑</h1><h2 id="原因-web容器加载顺序所致"><a href="#原因-web容器加载顺序所致" class="headerlink" title="原因:web容器加载顺序所致"></a>原因:web容器加载顺序所致</h2><p>加载顺序是 listener —&gt; filter —&gt; servlet,当项目启动时，<br>filter先于servlet初始化，而Spring中默认Bean的初始化是在Servlet后进行的,<br>所以会注入失败。</p>
]]></content>
  </entry>
  <entry>
    <title>代码格式配置及使用</title>
    <url>/2021/01/16/%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="代码格式配置及使用方法"><a href="#代码格式配置及使用方法" class="headerlink" title="代码格式配置及使用方法"></a>代码格式配置及使用方法</h1><h2 id="代码格式配置"><a href="#代码格式配置" class="headerlink" title="代码格式配置"></a>代码格式配置</h2><ul>
<li>下载代码格式化文件huifan.xml</li>
</ul>
<pre><code>地址：
https://space.dingtalk.com/s/gwHOApBSNQLOA7lEmwPaACBlYTg5YjA3N2VjZGU0NjUzOWFiNjk3YTY5Y2YxYzJkYQ 
密码: uy2D

下载过期可在钉钉搜索huifan.xml</code></pre><h2 id="设置代码格式"><a href="#设置代码格式" class="headerlink" title="设置代码格式"></a>设置代码格式</h2><pre><code>File  --&gt; Settings --&gt; Editor --&gt; Code Style --&gt; Scheme --&gt; Import Scheme
引入下载的huifan.xml，Apply </code></pre><p><img src="http://49.4.55.138:4999/server/../Public/Uploads/2021-01-07/5ff6805c2de64.png" alt="引入格式" title="引入格式"></p>
<h2 id="设置格式化代码快捷键"><a href="#设置格式化代码快捷键" class="headerlink" title="设置格式化代码快捷键"></a>设置格式化代码快捷键</h2><pre><code>File  --&gt; Settings --&gt; keymap --&gt; 搜索框输入 --&gt; Reformat 
设置格式化代码快捷键(可根据自己喜好设置响应快捷键）
默认 Ctrl + alt + l
在当前类 按键为格式化当前类，
在包按快捷键为格式化包
在工程按快捷键为格式化整个工程</code></pre><p><img src="http://49.4.55.138:4999/server/../Public/Uploads/2021-01-07/5ff6808e88f8c.png" alt="设置快捷键" title="设置快捷键">    </p>
<h2 id="代码注释模板"><a href="#代码注释模板" class="headerlink" title="代码注释模板"></a>代码注释模板</h2><h3 id="类注释（会在新建类时生效）"><a href="#类注释（会在新建类时生效）" class="headerlink" title="类注释（会在新建类时生效）"></a>类注释（会在新建类时生效）</h3><pre><code>File  --&gt; Settings --&gt; Editor --&gt; File and Code Templates --&gt; Class 
将下面信息填入输入框，apply 

File  --&gt; Settings --&gt; Editor --&gt; File and Code Templates --&gt; Interface 
将下面信息填入输入框，apply 

File  --&gt; Settings --&gt; Editor --&gt; File and Code Templates --&gt; Enum
将下面信息填入输入框，apply 

File  --&gt; Settings --&gt; Editor --&gt; File and Code Templates --&gt; Record
将下面信息填入输入框，apply 

File  --&gt; Settings --&gt; Editor --&gt; File and Code Templates --&gt; AnnotationType
将下面信息填入输入框，apply 


   #if (${PACKAGE_NAME} &amp;&amp; ${PACKAGE_NAME} != &quot;&quot;)package ${PACKAGE_NAME};#end
   #parse(&quot;File Header.java&quot;)
   /**
    * &lt;b&gt;功能名：${NAME}&lt;/b&gt;&lt;br&gt;
    * &lt;b&gt;说明：&lt;/b&gt;&lt;br&gt;
    * &lt;b&gt;著作权：&lt;/b&gt; Copyright (C) 2021 HUIFANEDU  CORPORATION&lt;br&gt;
    * &lt;b&gt;修改履历：
    *
    * @author ${YEAR}-${MONTH}-${DAY} xuxiongzi
    */

   public class ${NAME} {
   }    </code></pre><p><img src="http://49.4.55.138:4999/server/../Public/Uploads/2021-01-07/5ff682f0604ab.png" alt="配置类注释" title="配置类注释"></p>
<p><strong>注意！修改作者名称为自己</strong> </p>
<h3 id="配置方法注释"><a href="#配置方法注释" class="headerlink" title="配置方法注释"></a>配置方法注释</h3><pre><code>File  --&gt; Settings --&gt; Editor --&gt; Live Templates --&gt; 点击右上角加号添加 --&gt; Live Template </code></pre><p><img src="http://49.4.55.138:4999/server/../Public/Uploads/2021-01-07/5ff6844029658.png" alt=""></p>
<p><img src="http://49.4.55.138:4999/server/../Public/Uploads/2021-01-07/5ff685c04b0e7.png" alt=""></p>
<p><img src="http://49.4.55.138:4999/server/../Public/Uploads/2021-01-07/5ff6864b3efc1.png" alt=""></p>
<h4 id="Template-text-内容"><a href="#Template-text-内容" class="headerlink" title="Template text 内容"></a>Template text 内容</h4><pre><code>**
 * &lt;b&gt;方法名: &lt;/b&gt; $name$ &lt;br&gt;
 * &lt;b&gt;说明: &lt;/b&gt;  &lt;br&gt;
 *
$param$
 * @return $return$
 * &lt;b&gt;修改履历: &lt;/b&gt;
 * @author $date$ xuxiongzi
 */</code></pre><h4 id="param脚本内容"><a href="#param脚本内容" class="headerlink" title="param脚本内容"></a>param脚本内容</h4><pre><code>groovyScript(&quot;def result=&apos;&apos;; def params=\&quot;${_1}\&quot;.replaceAll(&apos;[\\\\[|\\\\]|\\\\s]&apos;, &apos;&apos;).split(&apos;,&apos;).toList(); for(i = 0; i &lt; params.size(); i++) {result+=&apos; * @param &apos; + params[i] + ((i &lt; params.size() - 1) ? &apos;\\n&apos; : &apos;&apos;)}; return result&quot;, methodParameters()) </code></pre><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><pre><code>在相应方法上输入/f回车    </code></pre><h3 id="配置自定类注释（配置方法同配置方法注释）"><a href="#配置自定类注释（配置方法同配置方法注释）" class="headerlink" title="配置自定类注释（配置方法同配置方法注释）"></a>配置自定类注释（配置方法同配置方法注释）</h3><p>类模板</p>
<pre><code>/**
 * &lt;b&gt;功能名：&lt;/b&gt;$NAME$&lt;br&gt;
 * &lt;b&gt;说明：&lt;/b&gt;&lt;br&gt;
 * &lt;b&gt;著作权：&lt;/b&gt; Copyright (C) 2021 HUIFANEDU  CORPORATION&lt;br&gt;
 * &lt;b&gt;修改履历：&lt;/br&gt;
 *
 * @author $date$ xuxiongzi
 */</code></pre><h2 id="代码规约如何使用"><a href="#代码规约如何使用" class="headerlink" title="代码规约如何使用"></a>代码规约如何使用</h2><ul>
<li>随时格式化代码（Ctrl + alt + l)</li>
<li>写完方法后右键使用阿里规约扫描自己代码（修改不符之处）     </li>
<li>mvn test 或使用maven插件 Test自己代码 </li>
<li>重启自己项目没问题方可提交代码</li>
</ul>
<p><img src="http://49.4.55.138:4999/server/../Public/Uploads/2021-01-07/5ff6895686397.png" alt=""></p>
<p><img src="http://49.4.55.138:4999/server/../Public/Uploads/2021-01-07/5ff68986eccd3.png" alt=""></p>
<p>或执行push.sh (yi用户服务为例)<br><img src="http://49.4.55.138:4999/server/../Public/Uploads/2021-01-07/5ff689eae25ad.png" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>坏代码的味道</title>
    <url>/2021/01/26/%E5%9D%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E5%91%B3%E9%81%93/</url>
    <content><![CDATA[<h1 id="坏代码的味道"><a href="#坏代码的味道" class="headerlink" title="坏代码的味道"></a>坏代码的味道</h1><h2 id="Duplicated-Code-（重复代码）难维护"><a href="#Duplicated-Code-（重复代码）难维护" class="headerlink" title="Duplicated Code （重复代码）难维护"></a>Duplicated Code （重复代码）难维护</h2><ul>
<li>解决方法：提取公共函数。</li>
</ul>
<p>最单纯的Duplicated Code就是［同一个class内的两个方法含有相同表达式(expression)］。这时候你需要做的就是采用Extract Method提炼出重复的代码，然后让这两个地点都调用被提炼出来的那一段代码。    </p>
<p>另一种常见情况就是[两个互为兄弟(sibling)的subclasses内含有相同表达式]。要避免这种情况，只需要对两个classes都使用 Extract Method，然后再对被提炼出的代码使用Pull Up Method，将它推入superclass内。如果代码之间只是类似，并非完全相同，那么就得运用Extract Method将相似部分和差异部分割开，构成单独一个方法。然后你可能发现或许可以运用Form Template Method获得一个Template Method设计模式。如果有些方法以不同的算法做相同的事，你可以择定其中较清晰的一个，并使用Substitute Algorithm将其它方法的算法替换掉。</p>
<p>如果两个毫不相关的classes内出现Duplicated Code，你应该考虑对其中一个使用Extract Class，将重复代码提炼到一个独立class中，然后在另一个class内使用这个新class。但是，重复代码所在的方法也可能的确只应该属于某个 class，另一个class只能调用它，抑或这个方法可能属于第三个class，而另两个classes应该引用这第三个class。你必须决定这个方法放在哪儿最合适，并确保它被安置后就不会再在其它任何地方出现。    </p>
<h2 id="Long-Method-长函数-难理解"><a href="#Long-Method-长函数-难理解" class="headerlink" title="Long Method (长函数)难理解"></a>Long Method (长函数)难理解</h2><ul>
<li>解决方法：拆分成若干函数。</li>
</ul>
<p>拥有短方法(short methods)的对象会活得比较好、比较长。不熟悉面向对象技术的人，常常觉得对象程序中只有无穷无尽的delegation(委托)，根本没有进行任何计算。和此类程序共同生活数年之后，你才会知道，这些小小方法有多大价值。［间接层］所能带来的全部利益——解释能力、共享能力、选择能力——都是由小型方法支持的。</p>
<p>很久以前程序员就已认识到：程序愈长愈难理解。早期的编程语言中，［子程序调用动作］需要额外开销，这使得做你们不太乐意使用small method，现代OO语言几乎已经完全免除了进程内的[方法调用动作额外开销]。不过代码阅读者还是得多费力气，因为他必须经常转换上下文去看看子程序做了什么。某些开发环境允许用户同时看到两个方法，这可以帮助你省去部分麻烦，但是让small method容易理解的真正关键在于一个好名字。如果你能给方法起个好名字，读者就可以通过名字了解方法的作用，根本不必去看其中写了些什么。</p>
<p>最终的效果是：你应该更积极进取地分解方法。我们遵循这样一条原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立的方法中，并以其用途(而非实现手法)命名。我们可以对一组或甚至短短一行代码做这件事。哪怕替换后的方法调用动作比方法自身还长，只要方法名称能够解释其用途，我们也该毫不犹豫地那么做。关键不在于方法的长度，而在于方法[做什么]和[如何做]之间的语义距离。</p>
<p>百分之九十九的场合里，要把方法变小，只需使用Extract Method。找到方法中适合集在一起的部分，将它们提炼出来形成一个新方法。</p>
<p>如果方法内有大量的参数和临时变量，它们会对你的方法提炼形成阻碍。如果你尝试运用Extract Method，最终就会把许多这些参数和临时变量当作参数，传递给被提炼出来的新方法，导致可读性几乎没有任何提升。啊是的，你可以经常运用 Replace Temp with Query则可以将过长的参数列变得更简洁一些。</p>
<p>如果你已经这么做，仍然有太多临时变量和参数，那就应该拿出我们的杀手锏：Replace Method with Method Object。</p>
<p>如何确定该提炼哪一段代码呢？一个很好的技巧是：寻找注释。它们通常是指出[代码用途和实现手法间的语义距离]的信号。如果代码前言有一行注释，就是在提醒你：可以将这段代码替换成一个方法，而且可以在注释的基础上给这个方法命名。就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立的方法去。</p>
<p>条件式和循环常常也是提炼的信号。你可以使用Decompose Conditional处理条件式。至于循环，你应该将循环和其内的代码提炼到一例独立方法中。</p>
<h2 id="Large-Class-大类-难理解"><a href="#Large-Class-大类-难理解" class="headerlink" title="Large Class (大类)难理解"></a>Large Class (大类)难理解</h2><ul>
<li>解决方法：拆分成若干类。</li>
</ul>
<p>如果想利用单一class做太多事情，其内往往就会出现太多instance变量。一旦如此，Duplicated Code也就接踵而至了。</p>
<p>你可以运用Extract Class将数个变量一起提炼到新class内。提炼时应该选择class内彼此相关的变量，将它们放在一起。例如”depositAmount” 和”depositCurrency”可能应该隶属同一个class。通常如果class内的数个变量有着相同的前缀或字尾，这就意味有机会把它们提炼到某个组件内。如果这个组件适合作为一个subclass，你会发现Extract Subclass往往比较简单。</p>
<p>有时候class并非在所有时刻都使用所有instance变量。果真如此，你或许可以多次使用Extract Class或Extract Subclass。</p>
<p>和[太多instance变量]一样，class内如果有太多代码，也是[]代码重复、混乱、死亡]的绝佳滋生地点。最简单的解决方案是把赘余的东西消弭于class内部。如果有五个[百行方法]，它们之中很多代码都相同，那么或许你可以把它们变成五个［十行方法］和十个提炼出来的［双行方法］</p>
<p>和[拥有太多instance变量]一样，一个class如果拥有太多代码，往往也适合使用Extract Class和Extract Subclass。这里有个有用技巧：先确定客户端如何使用它们，然后运用Extract Interface为每一种使用一个接口。这或许可以帮助你看清楚如何分解这个class。</p>
<p>如果你的Large Class是个GUI class，你可能需要把数据和行为移到一个独立的领域对象去。你可能需要两边各保留一些重复数据，并令这些数据同步。Duplicate Observed Data告诉你该怎么做。这种情况下，特别是如果你使用旧式AWT组件，你可以采用这种方式去掉GUI class并代以Swing组件。</p>
<h2 id="Long-Parameter-List-参数多-难用，难理解"><a href="#Long-Parameter-List-参数多-难用，难理解" class="headerlink" title="Long Parameter List (参数多) 难用，难理解"></a>Long Parameter List (参数多) 难用，难理解</h2><ul>
<li>解决方法：将參数封装成结构或者类。</li>
</ul>
<p>刚开始学习编程的时候，老师教我们：把方法所需的所有东西都以参数传递进去。这可以理解，因为除此之外就只能选择全局数据，而全局数据是邪恶的东西。对象技术改变了这一情况，因为如果你手上没有你所需要的东西，总可以叫另一个对象给你。因此，有了对象，你就不必把方法需要的所有东西都以参数传递给它了，你只需给它足够的东西、让方法能从中获得自己需要的所有东西就行了。方法需要的东西多半可以在方法的宿主类(host class)中找到。面向对象程序中的方法，其参数列通常比在传统程序中短得多。</p>
<p>这是好现象，因为太长的参数列难以理解，太多参数会造成前后不一致、不易使用，而且一旦你需要更多数据，就不得不修改它。如果将对象传递给方法，大多数修改都将没有必要，因为你很可能只需(在方法内)增加一两条请求，就能得到更多数据。</p>
<p>如果[向既有对象发出一条请求]就可以取得原本位于参数列上的一份数据，那么你应该激活重构准则Replace Parameter with Method。上述的既有对象可能是方法所属class内的一个字段，也可能是另一个参数。你还可以运用Preserve Whole Object将来自同一对象的一堆数据收集起来，并以该对象替换它们。如果某些数据缺乏合理的对象归属，可使用Introduce Parameter Object为它们制造出一个[参数对象]。</p>
<p>此间存在一个重要的例外。有时候你明显不希望造成[被调用之对象]与[较大对象]间的某种依存关系。这时候将数据从对象中拆解出来单独作为参数，也很合情合理。但是请注意其所引发的代价。如果参数列太长或变化太频繁，你就需要重新考虑自己的依存结构了。</p>
<h2 id="Divergent-Change-发散式改动"><a href="#Divergent-Change-发散式改动" class="headerlink" title="Divergent Change ( 发散式改动)"></a>Divergent Change ( 发散式改动)</h2><ul>
<li>解决方法：拆，将总是一起变化的东西放在一块儿。</li>
</ul>
<p>我们希望软件能够更容易被修改——毕竟软件再怎么说本来就该是[软]的。一旦需要修改，我们希望能够跌到系统的某一点，只在该处做修改。如果不能做到这点，你就嗅出两种紧密相关的刺鼻味道中的一种了。</p>
<p>如果某个class经常因为不同的原因在不同的方向上发生变化，Divergent Change就出现了。当你看着一个class说：“ 呃，如果新加入一个数据库，我必须修改这三个方法；如果新出现一种金融工具，我必须修改这四个方法”，那么此时也许将这个对象分成两个会更好，这么一来每个对象就可以只因一种变化而需要修改。当然，往往只有在加入新数据库或新金融工具后，你才能发现这一点。针对某一外界变化的所有相应修改，都只应该发生在单一class中，而这个新class内的所有内容都应该反应该外界变化。为此，你应该找出因着某特定原因而造成的所有变化，然后运用Extract Class将它们提炼到另一个class中。</p>
<h2 id="Shotgun-Surgery-天女散花的逻辑-散弹式改动，改某个需求的时候，要改非常多的类"><a href="#Shotgun-Surgery-天女散花的逻辑-散弹式改动，改某个需求的时候，要改非常多的类" class="headerlink" title="Shotgun Surgery (天女散花的逻辑 ) 散弹式改动，改某个需求的时候，要改非常多的类"></a>Shotgun Surgery (天女散花的逻辑 ) 散弹式改动，改某个需求的时候，要改非常多的类</h2><ul>
<li>解决方法：将各个改动点，集中起来，抽象成一个新类。</li>
</ul>
<p>Shotgun Surgery类似Divergent Change，但恰恰相反。如果每遇到某种变化，你都必须在许多不同的class内做出许多小修改以响应之，你所面临的坏味道就是Shotgun Surgery。如果需要修改的代码散布四处，你不但很难找到它们，也很容易忘记某个重要的修改。</p>
<p>这种情况下你应该使用Move Method和Move Field把所有需要修改的代码放进同一个class。如果眼下没有合适的class可以安置这些代码，就创造一个。通常你可以运用Inline Class把一系列相关行为放进同一个class。这可能会造成少量Divergent Change，但你可以轻易处理它。</p>
<p>Divergent Change是指[一个class受多种变化的影响]，Shotgun Surgery则是指[一种变化引发多个classes相应修改]。这两种情况下你都会希望整理代码，取得[外界变化]与[待改类]呈现一对一关系的理想境地。</p>
<h2 id="Feature-Envy-依恋情结-红杏出墙的函数-使用了大量其他类的成员"><a href="#Feature-Envy-依恋情结-红杏出墙的函数-使用了大量其他类的成员" class="headerlink" title="Feature Envy (依恋情结 红杏出墙的函数)使用了大量其他类的成员"></a>Feature Envy (依恋情结 红杏出墙的函数)使用了大量其他类的成员</h2><ul>
<li>解决方法：将这个函数挪到那个类里面。</li>
</ul>
<p>对象技术的全部要点在于：这是一种[将数据和加诸其上的操作行为包装在一起]的技术。有一种经典气味是：方法对某个class的兴趣高过对自己所处之 host class的兴趣。这种孺慕之情最通常的焦点便是数据。无数次经验里，我们看到某个方法为了计算某值，从另一个对象那儿调用几乎半打的取值方法。疗法显而易见：把这个方法移到另一个地点。你应该使用Move Method把它移到它该去的地方。有时候方法中只有一部分受这种依恋之苦，这时候你应该使用Extract Method把这一部分提炼到独立方法中，再使用Move Method带它去它的梦中家园。</p>
<p>当然，并非所有情况都这么简单。一个方法往往会用上数个classes特性，那么它究竟该被置于何处呢？我们的原则是：判断哪个class拥有最多[被此方法使用]的数据，然后就把这个方法和那些数据摆在一起。如果先以Extract Method将这个方法分解为整个较小方法并分别置放于不同地点，上述步骤也就比较容易完成了。</p>
<p>有数个复杂精巧的模式破坏了这个规则。说起这个话题，［四巨头］的Streategy和Visitor立刻跳入我的脑海，Kent Beck的Self Delegation也丰此列。使用这些模式是为了对抗坏味道Divergent Change。最根本的原则是：将总是一起变化的东西放在一块儿。［数据］和[引用这些数据]的行为总是一起变化的，但也有例外。如果例外出现，我们就搬移那些行为，保持[变化只在一起发生]。Strategy和Visitor使你得以轻松修改方法行为，因为它们将少量需要被覆写的行为隔离开来——当然也付出了[多一层间接性]的代价。</p>
<h2 id="Data-Clumps-数据团-常一起出现的一坨数据"><a href="#Data-Clumps-数据团-常一起出现的一坨数据" class="headerlink" title="Data Clumps (数据团) 常一起出现的一坨数据"></a>Data Clumps (数据团) 常一起出现的一坨数据</h2><ul>
<li>解决方法:他们那么有基情，就在一起吧，给他们一个新的类。</li>
</ul>
<p>数据项就像小孩子：喜欢成群结队地待在一块儿。你常常可以在很多地方看到相同的三或四笔数据项：两个classes内的相同字段、许多方法签名式中的相同参数。这些[总是绑在一起出现的数据]真应该放进属于它们自己的对象中。首先请找出这些数据的字段形式出现点，运用Extract Class将它们提炼到一个独立对象中。然后将注意力转移到方法签名式上头，运用Introduce Parameter Object或Preserve Whole Object为它减肥。这么做的直接好处是可以将很多参数列缩短，简化方法调用动作。是的，不必因为Data Clumps只用上新对象的一部分字段而在意，只要你以新对象取代两个(或更多)字段，你就值回票价了。</p>
<p>一个好的评断办法是：删掉众多数据中的一笔。其它数据有没有因而失去意义？如果它们不再有问询，这就是个明确信号：你应该为它们产生一个新对象。</p>
<p>缩短字段个数和参数个数，当然可以支队一些坏味道，但更重要的是：一旦拥有新对象，你就有机会让程序散发出一种芳香。得到新对象后，你就可以着手寻找 Feature Envy，这可以帮你指出[可移到新class]中的种种程序行为。不必太久，所有classes都将在它们的小小社会中充分发挥自己的生产力。</p>
<h2 id="Primitive-Obsession-偏爱基本类型-热衷于使用int，long，String等基本类型"><a href="#Primitive-Obsession-偏爱基本类型-热衷于使用int，long，String等基本类型" class="headerlink" title="Primitive Obsession (偏爱基本类型) 热衷于使用int，long，String等基本类型"></a>Primitive Obsession (偏爱基本类型) 热衷于使用int，long，String等基本类型</h2><ul>
<li>解决方法:重复出现的一组參数，有关联的多个数组换成类吧。</li>
</ul>
<p>大多数编程环境都有两种数据：结构型别允许你将数据组织成有意义的形式；基本型别则是构成结构型别的积木块。结构总是会带来一定的额外开销。它们有点像数据库中的表格，或是那些得不偿失的东西。</p>
<p>对象的一个极具价值的东西：它们模糊了横亘于基本数据和体积较大的classes之间的界限。你可以轻松编写出一些与语言内置型别无异的小型 classes。例如Java就以基本型别表示数值，而心class表示字符串和日期——这两个型别在其它许多编程环境中都以基本型别表现。</p>
<p>对象技术的新手通常在小任务上运用小对象——像是结合数值和币别的money class、含一个起始值和一个结束值的range class、电话号码或邮政编码等等的特殊strings。你可以运用Replace Data Value with Object将原本单独存在的数据值替换为对象，从而走出传统的洞窟，进入炙手可热的对象世界。如果欲替换之数据值是type code，而它并不影响行为，你可以运用Replace Type Code with Class将它换掉。如果你有相依于此type code的条件式，可运用Replace Type Code with Subclass或Replace Type Code with State/Strategy加以处理。</p>
<p>如果你有一组应该总是被放在一起的字段，可运用Extract Class。如果你在参数列中看到基本型数据，不妨试试Introduce Parameter Object。如果你发现自己正从array中挑选数据，可运用Replace Array with Object。</p>
<h2 id="Switch-Statements-switch语句"><a href="#Switch-Statements-switch语句" class="headerlink" title="Switch Statements (switch语句)"></a>Switch Statements (switch语句)</h2><ul>
<li>解决方法:state/strategy 或者仅仅是简单的多态。</li>
</ul>
<p>面向对象程序的一个最明显特征就是：少用switch(或case)语句。从本质上说，switch语句的问题在于重复。你常会发现同样的switch语句散布于不同的地点。如果要为它添加一个新的case子句，你必须找到所有switch语句并修改它们。面向的多态概念可为此带来优雅的解决办法。</p>
<p>大多数时候，一看到switch语句你就应该考虑以多态来替换它。问题是多态该出现在哪儿？switch语句常常根据type code进行选择，你要的是[与该type code相关的方法或class]。所以你应该使用Extract Method将switch语句提炼到一个独立方法中，再以Move Method将它搬移到需要多态性的那个class里头。此时你必须决定是否使用Replace Type Code with Subclasses或Replace Type Code with State/Strategy。一旦这样完成继承结构之后，你就可以运用Replace Conditional with Polymorphism了。</p>
<p>如果你只是在单一方法中髭选择事例，而你并不想改动它们，那么[多态]就有点杀鸡用牛刀了。这种情况下Replace Parameter with Explicit Methods是个不错的选择。如果你的选择条件之一是null，可以试试Introduce Null Object。</p>
<h2 id="Parallel-Inheritance-Hierarchies-平行继承-添加A类的子类ax，B类也要对应的添加一个bx"><a href="#Parallel-Inheritance-Hierarchies-平行继承-添加A类的子类ax，B类也要对应的添加一个bx" class="headerlink" title="Parallel Inheritance Hierarchies (平行继承) 添加A类的子类ax，B类也要对应的添加一个bx"></a>Parallel Inheritance Hierarchies (平行继承) 添加A类的子类ax，B类也要对应的添加一个bx</h2><ul>
<li>解决方法:应该有一个类是能够去掉继承关系的。</li>
</ul>
<p>Parallel Inheritance Hierarchies其实是Shotgun Surgery的特殊情况。在这种情况下，每当你为某个class增加一个subclass，必须也为另一个class相应增加一个subclass。如果你发现某个继承体系的class名称前缀和另一个继承体系的class名称前缀完全相同，便是闻到了这种坏味道。</p>
<p>消除这种重复性的一般策略是：让一个继承体系的实体指涉另一个继承体系的实体。如果再接再厉运用Move Method和Move Field，就可以将指涉端的继承体系消弭于无形。</p>
<h2 id="Lazy-Class-冗赘类-假设他不干活了，炒掉他吧"><a href="#Lazy-Class-冗赘类-假设他不干活了，炒掉他吧" class="headerlink" title="Lazy Class (冗赘类) 假设他不干活了，炒掉他吧"></a>Lazy Class (冗赘类) 假设他不干活了，炒掉他吧</h2><ul>
<li>解决方法:把这些不再重要的类里面的逻辑，合并到相关类，删掉旧的。</li>
</ul>
<p>你所创建的每一个class，都得有人去理解它、维护它，这些工作都是要花钱的。如果一个class的所得不值其身份，它就应该消失。项目中经常会出现这样的情况：某个class原本对得起自己的身份，但重檐使它身形缩水，不再做那么多工作；或开发者事前规划了某些变化，并添加一个class来就会这些变化，但变化实际上没有发生。不论上述哪一种原因，请让这个class庄严赴义吧。如果某些subclass没有做满足够工作，试试Collapse Hierarchy[合并继承]。对于几乎没用的组件，你应该以Inline Class对付它们。</p>
<h2 id="Speculative-Generality-（夸夸其谈未来性）"><a href="#Speculative-Generality-（夸夸其谈未来性）" class="headerlink" title="Speculative Generality （夸夸其谈未来性）"></a>Speculative Generality （夸夸其谈未来性）</h2><ul>
<li>解决方法:删掉</li>
</ul>
<p>这个令我们十分敏感的坏味道，命名者是Brian Foote。当有人说“噢，我想我们总有一天需要做这事”并因而企图以各式各样的挂勾和特殊情况来处理一些非必要的事情，这种坏味道就出现了。那么做的结果往往造成系统更难理解和维护。如果所有装置都会被用到，那就值得那么做；如果用不到，就不值得。用不上的装置只会挡你的路，所以，把它搬弄吧。</p>
<p>如果你的某个abstract class其实没有太大作用，请运用Collapse Hierarchy。非必要之delegation可运用Inline Class除掉。如果方法的某些参数示被用上，可对它实施Rename Method让它现实一些。</p>
<p>如果方法或class的惟一用户是test cases，这就飘出了坏味道Speculative Generality。如果你发现这样的方法或class，请把它们连同其test cases都删掉。但如果它们的用途是帮助test cases检测正当功能，当然必须刀下留人。</p>
<h2 id="Temporary-Field-（临时字段）仅在特定环境下使用的变量"><a href="#Temporary-Field-（临时字段）仅在特定环境下使用的变量" class="headerlink" title="Temporary Field （临时字段）仅在特定环境下使用的变量"></a>Temporary Field （临时字段）仅在特定环境下使用的变量</h2><ul>
<li>解决方法:将这些暂时变量集中到一个新类中管理。</li>
</ul>
<p>有时你会看到这样的对象：其内某个instance 变量仅为某种特定情势而设。这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有变量。在变量未被使用的情况下猜测当初其设置目的，会让你发疯。</p>
<p>请使用Extract Class给这个可怜的孤独创造一个家，然后把所有和这个变量相关的代码都放进这个新家。也许你还可以使用Introduce Null Object在[变量不合法]的情况下创建一个Null对象，从而避免写出[条件式代码]。</p>
<p>如果class中有一个复杂算法，需要好几个变量，往往就可能导致坏味道Temporary Field的出现。由于实现者不希望传递一长串参数，所以他把这些参数都放进字段中。但是这些字段只在使用该算法时才有效，其它情况下只会让人迷惑。这时候你可以利用Extract Class把这些变量和其相关方法提炼到一个独立class中。提炼后的新对象将是一个method object。</p>
<h2 id="Message-Chains-（消息链）过度耦合的才是坏的。"><a href="#Message-Chains-（消息链）过度耦合的才是坏的。" class="headerlink" title="Message Chains （消息链）过度耦合的才是坏的。"></a>Message Chains （消息链）过度耦合的才是坏的。</h2><ul>
<li>解决方法:拆函数或者移动函数。</li>
</ul>
<p>如果你看到用户向一个对象索求另一个对象，然后再向后者索求另一个对象，然后再索求另一个对象……这就是Message Chain。实际代码中你看到的可能是一长串getThis()或一长串临时变量。采取这种方式，意味客户将与查找过程中的航行结构紧密耦合。一旦对象间的关系发生任何变化，客户端就不得不做出相应修改。</p>
<p>这时候你应该使用Hide Delegate。你可以在Message Chain的不同位置进行这种重构手法。理论上你可以重构Message Chain上的任何一个对象，但这么做往往会把所有中介对象都变成Middle Man。通常更好的选择是：先观察Message Chain最终得到的对象是用来干什么的，看看能否以Extract Method把使用该对象的代码提炼到一个独立方法中，再运用Move Method把这个方法推入Message Chain。如果这条链上的某个对象有多位客户打算航行此航线的剩余部分，就加一个方法来做这件事。</p>
<p>有些人把任何方法链都视为坏东西，我们不这样想。呵呵，我们的总代表镇定是出了名的，起码在这件事情上是这样。</p>
<h2 id="Middle-Man-中介-大部分都交给中介来处理了"><a href="#Middle-Man-中介-大部分都交给中介来处理了" class="headerlink" title="Middle Man (中介) 大部分都交给中介来处理了"></a>Middle Man (中介) 大部分都交给中介来处理了</h2><ul>
<li>解决方法:用继承替代托付。<br>对象的基本特征之一就是封装——对外部世界隐藏其内部细节。封装往往伴随delegation。比如说你问主管是否有时间参加一个会议，他就把这个消息委托给他的记事簿，然后才能回答你。很好，你没必要知道这位主管到底使用传统记事簿或电子记事簿抑或秘书来记录自己的约会。</li>
</ul>
<p>但是人们可能过度运用delegation。你也许会看到某个class接口有一半的方法都委托给其它class，这样就是过度运用。这里你应该使用 Remove Middle Man，直接和负责对象打交道。如果这样[不干实事]的方法只有少数几个，可以运用Inline Method把它们”inlining”，放进调用端。如果这些Middle Man还有其它行为内销可以运用Replace Delegation with Inheritance把它变成负责对象的subclass，这样你既可以扩展原对象的行为，又不必负担那么多的委托动作。</p>
<h2 id="Inappropriate-Intimacy-太亲热-两个类都使用对方私有的东西"><a href="#Inappropriate-Intimacy-太亲热-两个类都使用对方私有的东西" class="headerlink" title="Inappropriate Intimacy (太亲热) 两个类都使用对方私有的东西"></a>Inappropriate Intimacy (太亲热) 两个类都使用对方私有的东西</h2><ul>
<li>解决方法:划清界限拆散，或合并，或改成单项联系。<br>有时候你会看到两个classes过于亲密，花费太多时间去探究彼此的private成分。如果这发生在两个[人]之间，我们不必做卫道之士；但对于 classes，我们希望它们严守清规。</li>
</ul>
<p>就像古代恋人一样，过份狎昵的classes必须拆散。你可以采用Move Method和Move Field帮它们划清界线，从而减少狎昵行径。你也可以看看是否运用Change Bidirectional Association to Unidirectional[将双向关联改为单向]让其中一个class对另一个斩断情丝。如果两个classes实在情投意合，可以运用Extract Class把两者共同点提炼到一个安全地点，让它们坦荡地使用这个新class。或者也可以尝试运用Hide Delegate让另一个class来为它们传递相思情。</p>
<p>继承往往造成过度亲密，因为subclass对superclass的了解总是超过superclass的主观愿望。如果你觉得该让这个孩子独自生活了，请运用Replace Inheritance with Delegation让它离开继承体系。</p>
<h2 id="Alternative-Classes-with-Different-Interfaces-异曲同工的类"><a href="#Alternative-Classes-with-Different-Interfaces-异曲同工的类" class="headerlink" title="Alternative Classes with Different Interfaces (异曲同工的类)"></a>Alternative Classes with Different Interfaces (异曲同工的类)</h2><ul>
<li>解决方法:重命名，移动函数，或抽象子类。</li>
</ul>
<p>如果两个方法做同一件事，却有着不同的签名式，请运用Rename Method根据它们的用途重新命名。但这往往不够，请反复运用Move Method将某些行为移入classes，直到两者的协议一致为止。如果你必须重复而赘余地移入代码才能完成这些，或许可运用Extract Superclass为自己赎点罪。</p>
<h2 id="Incomplete-Library-Class-（不完美的程序库类）"><a href="#Incomplete-Library-Class-（不完美的程序库类）" class="headerlink" title="Incomplete Library Class （不完美的程序库类）"></a>Incomplete Library Class （不完美的程序库类）</h2><ul>
<li>解决方法:包一层函数或包成新的类。</li>
</ul>
<p>复用常被视为对象的终极目的。我们认为这实在是过度估计了。但是无可否认，许多编程技术都建立在library classes的基础上，没人敢说是不是我们都把排序算法忘得一干二净了。</p>
<p>Library classes构筑者没有未卜先知的能力，我们不能因此责怪他们。毕竟我们自己也几乎总是在系统快要构筑完成的时候才能弄清楚它的设计，所以 library构筑者的任务真的很艰巨。麻烦的是library的形式往往不够好，往往不可能让我们修改其中的classes使它完成我们希望完成的工作。这是否意味那些经过实践检验的战术如Move Method等等，如今都派不上用场了？</p>
<p>幸好我们有两个专门就会这种情况的工具。如果你只想修改library classes内的一两个方法，可以运用Introduce Foreign Method；如果想要添加一大堆额外行为，就得运用Introduce Local Extension。</p>
<h2 id="Data-Class-纯数据类-类非常简单，仅有公共成员变量，或简单操作函数。"><a href="#Data-Class-纯数据类-类非常简单，仅有公共成员变量，或简单操作函数。" class="headerlink" title="Data Class (纯数据类) 类非常简单，仅有公共成员变量，或简单操作函数。"></a>Data Class (纯数据类) 类非常简单，仅有公共成员变量，或简单操作函数。</h2><ul>
<li>解决方法:将相关操作封装进去，降低public成员变量。</li>
</ul>
<p>所谓Data Class是指：它们拥有一些字段，以及用于访问这些字段的方法，除此之外一无长物。这样的classes只是一种[不会说话的数据容器]，它们几乎一定被其它classes过份细琐地操控着。这些classes早期可能拥有public字段，果真如此你应该在别人注意到它们之前，立刻运用 Encapsulate Field将它们封装起来。如果这些classes内含容器类的字段，你应该检查它们是不是得到了恰当的封装；如果没有，就运用Encapsulate Collection把它们封装起来。对于那些不该被其它classes修改的字段，请运用Remove Setting Method。</p>
<p>然后，找出这些[取值/设值]方法被其它classes运用的地点。尝试以Move Method把那些调用行为搬移到Data Class来。如果无法搬移整个方法，就运用Extract Method产生一个可被搬移的方法。不久之后你就可以运用Hide Method把这些[取值/设值]方法隐藏起来了。</p>
<p>Data Class就像小孩子。作为一个起点很好，但若要让它们像[成年]的对象那样参与整个系统的工作，它们就必须承担一定责任。</p>
<h2 id="Refused-Bequest-继承过多-父类里面方法非常多，子类仅仅用有限几个"><a href="#Refused-Bequest-继承过多-父类里面方法非常多，子类仅仅用有限几个" class="headerlink" title="Refused Bequest (继承过多) 父类里面方法非常多，子类仅仅用有限几个"></a>Refused Bequest (继承过多) 父类里面方法非常多，子类仅仅用有限几个</h2><p>Subclasses应该继承superclass的方法和数据。但如果它们不想或不需要继承，又该怎么办呢？它们得到所有礼物，却只从中挑选几样来玩！</p>
<p>按传统说法，这就意味继承体系设计错误。你需要为这个subclass新建一个兄弟，再运用Push Down Method和Push Down Field把所有用不到的方法下推给那兄弟。这样一来superclass就只持有所有subclasses共享的东西。常常你会听到这样的建议：所有 superclasses都应该是抽象的。</p>
<p>既然使用[传统说法]这个略带贬义的词，你就可以猜到，我们不建议你这么做，起码不建议你每次都这么做。我们经常利用subclassing手法来复用一些行为，并发现这可以很好地应用于日常工作。这也是一种坏味道，我们不否认，但气味通常并不强烈。所以我们说：如果Refused Bequest引起困惑和问题，请遵循传统忠告。但不必认为你每次都得那么做。十有八九这种坏味道很淡，不值得理睬。</p>
<p>如果subclass复用了superclass的行为(实现)，却又不愿意支持superclass的接口，Refused Bequest的坏味道就会变得浓烈。拒绝继承superclass的实现，这一点我们不介意；但如果拒绝继承superclass的接口，我们不以为然。不过即使你不愿意继承接口，也不要胡乱修改继承系，你应该运用Replace Inheritance with Delegation来达到目的。</p>
<h2 id="Comments-过多的注释"><a href="#Comments-过多的注释" class="headerlink" title="Comments (过多的注释)"></a>Comments (过多的注释)</h2><ul>
<li>解决方法:F2</li>
</ul>
<p>别担心，我们并不是说你不该写注释。从嗅觉上说，Comments不是一种坏味道；事实上它们还是一种香味呢。我们之所以要在这里提到Comments，因为人们常把它当作除臭剂来使用。常常会有这样的情况：你看到一段代码有着长长的注释，然后发现，这些注释之所以存在乃是因为代码很糟糕。这种情况的发生次数之多，实在令人吃惊。</p>
<p>Comments可以带我们找到本章先前提到的各种坏味道。找到坏味道后，我们首先应该以各种重构手法把坏味道去除。完成之后我们常常会发现：注释已经变得多余了，因为代码已经清楚说明了一切。</p>
<p>如果你需要注释来解释一块代码做了什么，试试Extract Method;如果你需要注释说明某些系统的需求规格，试试Introduce Assertion。</p>
<p>如果你不知道该做什么，这才是注释的良好运用时机。除了用来记述将来的打算之外，注释还可以用来标记你并无十足把握的区域。你可以在注释里写下自己[为什么做某某事]。这类信息可以帮助将来的修改者，尤其是那些健忘的家伙。</p>
]]></content>
  </entry>
  <entry>
    <title>手撕各种LOG框架</title>
    <url>/2020/12/18/%E6%89%8B%E6%92%95%E5%90%84%E7%A7%8DLOG%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>日志的用途大致可以归纳为以下三种<br>    * 问题追踪：通过日志不仅仅包括我们程序的一些bug，也可以在安装配置时，通过日志发现问题。<br>    * 状态监控：通过实时分析日志，可以监控系统的运行状态，做到早发现问题、早处理问题。<br>    * 安全审计： 审计主要体现在安全上，通过对日志进行分析，可以发现是否存在非授权的操作。</p>
<h2 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Log4j是一个非常流行的日志框架，由Ceki Gulcu首创，之后将其开源贡献给Apache软件基金会。</p>
<p>Log4j有三个主要的组件：Loggers(记录器),Appenders(输出源)和Layouts（布局）。这里可以简单理解为<code>日志类别``日志要输出的地方</code>和<code>日志以何种形式输出</code>    </p>
<p>综合使用这三个组件可以轻松地记录信息的类型和级别，并可以在运行时控制日志输出的样式和位置</p>
<p>Log4j的架构大致如下：</p>
<pre><code>log.info(&quot;user signed in.&quot;);
|
|——&gt;Appender——&gt;Filter ——&gt; Layout ——&gt; Console
|
|——&gt;Appender——&gt;Filter ——&gt; Layout ——&gt; File
|
|——&gt;Appender——&gt;Filter ——&gt; Layout ——&gt; Socket </code></pre><p>当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender(输出源)把同一条日志输出到不同的目的地。例如：</p>
<ul>
<li>console: 输出到屏幕</li>
<li>file: 输出到屏幕 </li>
<li>socket: 通过网络输出到远程计算机</li>
<li>jdbc: 输出到数据库</li>
</ul>
<p>在输出日志的过程中，通过<code>Filter</code>来过滤哪些log需要被输出，哪些log不需要被输出。</p>
<h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><p>DEBUG</p>
<p>INFO</p>
<p>WARN</p>
<p>ERROR</p>
<p>FATAL</p>
<h3 id="日志级别顺序"><a href="#日志级别顺序" class="headerlink" title="日志级别顺序"></a>日志级别顺序</h3><p>DEBUG &lt; INFO &lt; WARN &lt;ERROR &lt;FATAL</p>
<p><strong>规则：只输出级别不低于设定级别的日志信息</strong></p>
<p>假设Logger级别设定为INFO，则INFO、WARN、ERROR和FATAL级别的日志信息都会输出，而级别比INFO低的DEBUG则不会输出。</p>
<p>最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。</p>
<p>具体输出样式配置，可以参考如下内容<a href="https://blog.csdn.net/guoquanyou/article/details/5689652" target="_blank" rel="noopener">Log4j2-Layouts布局介绍</a></p>
<h3 id="项目应用"><a href="#项目应用" class="headerlink" title="项目应用"></a>项目应用</h3><h4 id="添加-maven-依赖"><a href="#添加-maven-依赖" class="headerlink" title="添加 maven 依赖"></a>添加 maven 依赖</h4><pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
        &lt;version&gt;1.6.6&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
        &lt;version&gt;1.6.6&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j&lt;/artifactId&gt;
        &lt;version&gt;1.2.17&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre><h4 id="创建log4j配置"><a href="#创建log4j配置" class="headerlink" title="创建log4j配置"></a>创建log4j配置</h4><p>在实际应用中，要使Log4j在系统中运行须事先设定配置文件。</p>
<p>配置文件实际上也就是对Logger、Appender及Layout进行相应设定。</p>
<p>Log4j支持两种配置文件格式，一种是XML格式的文件，一种是properties属性文件，二选一。</p>
<p>创建一个log4j.xml或者log4j.properties，将其放入项目根目录下。</p>
<p>1、XML格式</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE log4j:configuration PUBLIC &quot;-//APACHE//DTD LOG4J 1.2//EN&quot; &quot;log4j.dtd&quot;&gt;
&lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt;
    &lt;!-- 控制台输出配置 --&gt;
    &lt;appender name=&quot;console&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt;
        &lt;!-- 目标为控制台 --&gt;
        &lt;param name=&quot;Target&quot; value=&quot;System.out&quot; /&gt;
        &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;
            &lt;!-- 输出格式 --&gt;
            &lt;param name=&quot;ConversionPattern&quot; value=&quot;%d{yyyy-MM-dd HH:mm:ss} [%t] %-5p %l %m%n&quot; /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;
    &lt;!-- 文件输出配置 --&gt;
    &lt;appender name=&quot;log_file&quot; class=&quot;org.apache.log4j.DailyRollingFileAppender&quot;&gt;
        &lt;!-- 目标为文件 --&gt;
        &lt;param name=&quot;File&quot; value=&quot;/logs/log/file.log&quot; /&gt;
        &lt;!-- 向文件追加输出 --&gt;
        &lt;param name=&quot;Append&quot; value=&quot;true&quot; /&gt;
        &lt;!-- 每个小时生成一个log --&gt;
        &lt;param name=&quot;DatePattern&quot; value=&quot;&apos;.&apos;yyyy-MM-dd-HH&quot; /&gt;
        &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;
            &lt;!-- 输出格式 --&gt;
            &lt;param name=&quot;ConversionPattern&quot; value=&quot;%d{yyyy-MM-dd HH:mm:ss} [%t] %-5p %l %m%n&quot; /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;
    &lt;!-- Application Loggers --&gt;
    &lt;logger name=&quot;org.example&quot;&gt;
        &lt;level value=&quot;info&quot; /&gt;
    &lt;/logger&gt;
    &lt;!-- 根目录 --&gt;
    &lt;!-- Root Logger --&gt;
    &lt;root&gt;
        &lt;priority value=&quot;info&quot; /&gt;
        &lt;appender-ref ref=&quot;console&quot; /&gt;
        &lt;appender-ref ref=&quot;log_file&quot; /&gt;
    &lt;/root&gt;
&lt;/log4j:configuration&gt;</code></pre><p>2、properties格式</p>
<pre><code>log4j.rootLogger=INFO,M,C,E
log4j.additivity.monitorLogger=false

# INFO级别文件输出配置
log4j.appender.M=org.apache.log4j.DailyRollingFileAppender
log4j.appender.M.File=/logs/info.log
log4j.appender.M.ImmediateFlush=false
log4j.appender.M.BufferedIO=true
log4j.appender.M.BufferSize=16384
log4j.appender.M.Append=true
log4j.appender.M.Threshold=INFO
log4j.appender.M.DatePattern=&apos;.&apos;yyyy-MM-dd
log4j.appender.M.layout=org.apache.log4j.PatternLayout
log4j.appender.M.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss} %p %l %m %n

# ERROR级别文件输出配置
log4j.appender.E=org.apache.log4j.DailyRollingFileAppender
log4j.appender.E.File=/logs/error.log
log4j.appender.E.ImmediateFlush=true
log4j.appender.E.Append=true
log4j.appender.E.Threshold=ERROR
log4j.appender.E.DatePattern=&apos;.&apos;yyyy-MM-dd
log4j.appender.E.layout=org.apache.log4j.PatternLayout
log4j.appender.E.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss} %p %l %m %n

# 控制台输出配置
log4j.appender.C=org.apache.log4j.ConsoleAppender
log4j.appender.C.Threshold=INFO
log4j.appender.C.layout=org.apache.log4j.PatternLayout
log4j.appender.C.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} [%t] %-5p %l %m %n</code></pre><h4 id="log4j使用"><a href="#log4j使用" class="headerlink" title="log4j使用"></a>log4j使用</h4><p>在需要打印日志的类中，引入Logger类，在需要的地方打印即可！</p>
<pre><code>package org.example.log4j.service;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class LogPrintUtil {
    /**log静态常量*/
    private static final Logger logger = LoggerFactory.getLogger(LogPrintUtil.class);
    public static void main(String[] args){
            logger.info(&quot;info信息&quot;);
            logger.warn(&quot;warn信息&quot;);
            logger.error(&quot;error信息&quot;);
    }
}</code></pre><p>当然你还可以这样写</p>
<pre><code>if(logger.isInfoEnabled()) {
    logger.info(&quot;info信息&quot;);
}
if(logger.isWarnEnabled()) {
    logger.warn(&quot;warn信息&quot;);
}</code></pre><h4 id="isInfoEnabled-有何作用呢？"><a href="#isInfoEnabled-有何作用呢？" class="headerlink" title="isInfoEnabled()有何作用呢？"></a>isInfoEnabled()有何作用呢？</h4><pre><code>简单来说，在某些场景下，用isInfoEnabled()方法判断下是能提升性能的！

例如我们打印这段内容logger.info(&quot;User:&quot; + userId + appId)，程序在打印这行代码时，先对内容(&quot;User:&quot; + userId + appId)进行字符串拼接，然后再输出。

如果当前配置文件中日志输出级别是info，是直接输出的，当日志输出级别是error时，logger.info()的内容时不输出的，但是我们却进行了字符串拼接，如果加上if(logger.isInfoEnabled())进行一次判定，logger.info()就不会执行，从而更好的提升性能，这个尤其是在高并发和复杂log打印情况下提升非常显著。

另外，ERROR及其以上级别的log信息是一定会被输出的，所以只有logger.isDebugEnabled、logger.isInfoEnabled和logger.isWarnEnabled()方法，而没有logger.isErrorEnabled方法。</code></pre><h2 id="Log4j2"><a href="#Log4j2" class="headerlink" title="Log4j2"></a>Log4j2</h2><p> log4j2 是 log4j 1.x 的升级版，参考了 logback 的一些优秀的设计，并且修复了一些问题，因此带来了一些重大的提升，主要特点有：</p>
<ul>
<li>异常处理：在logback中，Appender中的异常不会被应用感知到，但是在log4j2中，提供了一些异常处理机制。</li>
<li>性能提升， log4j2相较于log4j 1和logback都具有很明显的性能提升，后面会有官方测试的数据。</li>
<li>自动重载配置：参考了logback的设计，当然会提供自动刷新参数配置，最实用的就是我们在生产上可以动态的修改日志的级别而不需要重启应用——那对监控来说，是非常敏感的。</li>
<li>无垃圾机制：log4j2在大部分情况下，都可以使用其设计的一套无垃圾机制，避免频繁的日志收集导致的jvm gc。</li>
</ul>
<h3 id="项目应用-1"><a href="#项目应用-1" class="headerlink" title="项目应用"></a>项目应用</h3><h4 id="添加-maven-依赖-1"><a href="#添加-maven-依赖-1" class="headerlink" title="添加 maven 依赖"></a>添加 maven 依赖</h4><pre><code>&lt;dependencies&gt;
    &lt;!-- slf4j核心包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
        &lt;version&gt;1.7.13&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--用于与common-log保持桥接 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;
        &lt;version&gt;1.7.13&lt;/version&gt;
        &lt;scope&gt;runtime&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!--核心log4j2jar包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;
        &lt;version&gt;2.4.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
        &lt;version&gt;2.4.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--用于与slf4j保持桥接 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt;
        &lt;version&gt;2.4.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--需要使用log4j2的AsyncLogger需要包含disruptor --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.lmax&lt;/groupId&gt;
        &lt;artifactId&gt;disruptor&lt;/artifactId&gt;
        &lt;version&gt;3.2.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre><h4 id="创建log4j2配置"><a href="#创建log4j2配置" class="headerlink" title="创建log4j2配置"></a>创建log4j2配置</h4><p>在项目的根目录下创建一个log4j2.xml的文件，与log4j相比，log4j2的异步输出日志性能非常强劲，配置如下：</p>
<p>1、同步输出日志</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!-- status : 这个用于设置log4j2自身内部的信息输出,可以不设置,当设置成trace时。
 注：本配置文件的目标是将不同级别的日志输出到不同文件，最大1MB一个文件， 
    文件数据达到最大值时，旧数据会被压缩并放进指定文件夹 ，最多存放20个文件--&gt;
&lt;Configuration status=&quot;error&quot;&gt;
    &lt;!-- 配置日志文件输出目录，此配置将日志输出到根目录下的指定文件夹 --&gt;
    &lt;Properties&gt;
        &lt;Property name=&quot;fileDir&quot;&gt;/logs/log4j2&lt;/Property&gt;
        &lt;Property name=&quot;fileHistory&quot;&gt;/logs/log4j2/history&lt;/Property&gt;
    &lt;/Properties&gt;
    &lt;Appenders&gt;
        &lt;!-- 优先级从高到低分别是 OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL --&gt;
        &lt;!-- 单词解释： Match：匹配 DENY：拒绝 Mismatch：不匹配 ACCEPT：接受 --&gt;
        &lt;!-- DENY，日志将立即被抛弃不再经过其他过滤器； NEUTRAL，有序列表里的下个过滤器过接着处理日志； ACCEPT，日志会被立即处理，不再经过剩余过滤器。 --&gt;
        &lt;!--输出日志的格式
        %d{yyyy-MM-dd HH:mm:ss, SSS} : 日志生产时间
        %t 输出当前线程名称
        %-5level 输出日志级别，-5表示左对齐并且固定输出5个字符，如果不足在右边补0
        %logger 输出logger名称，因为Root Logger没有名称，所以没有输出
        %msg 日志文本
        %n 换行
        其他常用的占位符有：
        %F 输出所在的类文件名，如Client.java
        %L 输出行号
        %M 输出所在方法名
        %l  输出语句所在的行数, 包括类名、方法名、文件名、行数
         --&gt;
        &lt;!--这个输出控制台的配置，这里输出all信息到System.out --&gt;
        &lt;console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;
            &lt;!-- 输出日志的格式 --&gt;
            &lt;PatternLayout charset=&quot;UTF-8&quot; pattern=&quot;%d{yyyy-MM-dd HH:mm:ss} [%t] %-5level %l %msg%n&quot; /&gt;
        &lt;/console&gt;
        &lt;!--这个输出文件的配置，这里输出info信息到junbao_info.log --&gt;
        &lt;RollingFile name=&quot;RollingFileInfo&quot; fileName=&quot;${fileDir}/info.log&quot; filePattern=&quot;${fileHistory}/info/%d{yyyy-MM-dd}-%i.log&quot;&gt;
            &lt;!-- 此Filter意思是，只输出info级别的数据 DENY，日志将立即被抛弃不再经过其他过滤器； NEUTRAL，有序列表里的下个过滤器过接着处理日志； 
                    ACCEPT，日志会被立即处理，不再经过剩余过滤器。 --&gt;
            &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot; /&gt;
            &lt;PatternLayout charset=&quot;UTF-8&quot; pattern=&quot;%d{yyyy-MM-dd HH:mm:ss} [%t] %-5level %l %msg%n&quot; /&gt;
            &lt;Policies&gt;
            &lt;!-- 如果启用此配置，则日志会按文件名生成新文件， 即如果filePattern配置的日期格式为 %d{yyyy-MM-dd HH} 
                    ，则每小时生成一个压缩文件， 如果filePattern配置的日期格式为 %d{yyyy-MM-dd} ，则天生成一个压缩文件,默认为1 --&gt;
                &lt;TimeBasedTriggeringPolicy /&gt;
                &lt;!-- 每个日志文件最大1MB,超过1MB生产新的文件 ; --&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;100MB&quot; /&gt;
            &lt;/Policies&gt;
             &lt;!--文件夹下最多的文件个数--&gt;  
            &lt;DefaultRolloverStrategy max=&quot;20&quot; /&gt;
        &lt;/RollingFile&gt;
        &lt;RollingFile name=&quot;RollingFileWarn&quot; fileName=&quot;${fileDir}/warn.log&quot; filePattern=&quot;${fileHistory}/warn/%d{yyyy-MM-dd}-%i.log&quot;&gt;
            &lt;ThresholdFilter level=&quot;warn&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot; /&gt;
            &lt;PatternLayout charset=&quot;UTF-8&quot; pattern=&quot;%d{yyyy-MM-dd HH:mm:ss} [%t] %-5level %l %msg%n&quot; /&gt;
            &lt;Policies&gt;
                &lt;TimeBasedTriggeringPolicy /&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;100MB&quot; /&gt;
            &lt;/Policies&gt;
            &lt;DefaultRolloverStrategy max=&quot;20&quot; /&gt;
        &lt;/RollingFile&gt;
        &lt;RollingFile name=&quot;RollingFileError&quot; fileName=&quot;${fileDir}/error.log&quot; filePattern=&quot;${fileHistory}/error/%d{yyyy-MM-dd}-%i.log&quot;&gt;
            &lt;ThresholdFilter level=&quot;error&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot; /&gt;
            &lt;PatternLayout charset=&quot;UTF-8&quot; pattern=&quot;%d{yyyy-MM-dd HH:mm:ss} [%t] %-5level %l %msg%n&quot; /&gt;
            &lt;Policies&gt;
                &lt;TimeBasedTriggeringPolicy /&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;100MB&quot; /&gt;
            &lt;/Policies&gt;
            &lt;DefaultRolloverStrategy max=&quot;20&quot; /&gt;
        &lt;/RollingFile&gt;
    &lt;/Appenders&gt;
    &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效 --&gt;
    &lt;Loggers&gt;
        &lt;!--全异步输出info级以上的日志信息--&gt; 
        &lt;!-- &lt;asyncRoot level=&quot;info&quot; includeLocation=&quot;true&quot;&gt;
            &lt;appender-ref ref=&quot;Console&quot; /&gt;
            &lt;appender-ref ref=&quot;RollingFileInfo&quot; /&gt;
        &lt;/asyncRoot&gt; --&gt;
        &lt;!--同步输出info级以上的日志信息--&gt; 
        &lt;root level=&quot;info&quot; includeLocation=&quot;true&quot;&gt;
            &lt;appender-ref ref=&quot;Console&quot; /&gt;
        &lt;/root&gt;
    &lt;/Loggers&gt;
&lt;/Configuration&gt;</code></pre><p>2、异步输出日志</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!-- status : 这个用于设置log4j2自身内部的信息输出,可以不设置,当设置成trace时。
 注：本配置文件的目标是将不同级别的日志输出到不同文件，最大1MB一个文件， 
    文件数据达到最大值时，旧数据会被压缩并放进指定文件夹 ，最多存放20个文件--&gt;
&lt;Configuration status=&quot;error&quot;&gt;
    &lt;!-- 配置日志文件输出目录，此配置将日志输出到根目录下的指定文件夹 --&gt;
    &lt;Properties&gt;
        &lt;Property name=&quot;fileDir&quot;&gt;/logs/log4j2&lt;/Property&gt;
        &lt;Property name=&quot;fileHistory&quot;&gt;/logs/log4j2/history&lt;/Property&gt;
    &lt;/Properties&gt;
    &lt;Appenders&gt;
        &lt;!-- 优先级从高到低分别是 OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL --&gt;
        &lt;!-- 单词解释： Match：匹配 DENY：拒绝 Mismatch：不匹配 ACCEPT：接受 --&gt;
        &lt;!-- DENY，日志将立即被抛弃不再经过其他过滤器； NEUTRAL，有序列表里的下个过滤器过接着处理日志； ACCEPT，日志会被立即处理，不再经过剩余过滤器。 --&gt;
        &lt;!--输出日志的格式
        %d{yyyy-MM-dd HH:mm:ss, SSS} : 日志生产时间
        %t 输出当前线程名称
        %-5level 输出日志级别，-5表示左对齐并且固定输出5个字符，如果不足在右边补0
        %logger 输出logger名称，因为Root Logger没有名称，所以没有输出
        %msg 日志文本
        %n 换行
        其他常用的占位符有：
        %F 输出所在的类文件名，如Client.java
        %L 输出行号
        %M 输出所在方法名
        %l  输出语句所在的行数, 包括类名、方法名、文件名、行数
         --&gt;
        &lt;!--这个输出控制台的配置，这里输出all信息到System.out --&gt;
        &lt;console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;
            &lt;!-- 输出日志的格式 --&gt;
            &lt;PatternLayout charset=&quot;UTF-8&quot; pattern=&quot;%d{yyyy-MM-dd HH:mm:ss} [%t] %-5level %l %msg%n&quot; /&gt;
        &lt;/console&gt;
        &lt;!--这个输出文件的配置，这里输出info信息到junbao_info.log --&gt;
        &lt;RollingFile name=&quot;RollingFileInfo&quot; fileName=&quot;${fileDir}/info.log&quot; filePattern=&quot;${fileHistory}/info/%d{yyyy-MM-dd}-%i.log&quot;&gt;
            &lt;!-- 此Filter意思是，只输出info级别的数据 DENY，日志将立即被抛弃不再经过其他过滤器； NEUTRAL，有序列表里的下个过滤器过接着处理日志； 
                    ACCEPT，日志会被立即处理，不再经过剩余过滤器。 --&gt;
            &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot; /&gt;
            &lt;PatternLayout charset=&quot;UTF-8&quot; pattern=&quot;%d{yyyy-MM-dd HH:mm:ss} [%t] %-5level %l %msg%n&quot; /&gt;
            &lt;Policies&gt;
            &lt;!-- 如果启用此配置，则日志会按文件名生成新文件， 即如果filePattern配置的日期格式为 %d{yyyy-MM-dd HH} 
                    ，则每小时生成一个压缩文件， 如果filePattern配置的日期格式为 %d{yyyy-MM-dd} ，则天生成一个压缩文件,默认为1 --&gt;
                &lt;TimeBasedTriggeringPolicy /&gt;
                &lt;!-- 每个日志文件最大1MB,超过1MB生产新的文件 ; --&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;100MB&quot; /&gt;
            &lt;/Policies&gt;
             &lt;!--文件夹下最多的文件个数--&gt;  
            &lt;DefaultRolloverStrategy max=&quot;20&quot; /&gt;
        &lt;/RollingFile&gt;
        &lt;RollingFile name=&quot;RollingFileWarn&quot; fileName=&quot;${fileDir}/warn.log&quot; filePattern=&quot;${fileHistory}/warn/%d{yyyy-MM-dd}-%i.log&quot;&gt;
            &lt;ThresholdFilter level=&quot;warn&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot; /&gt;
            &lt;PatternLayout charset=&quot;UTF-8&quot; pattern=&quot;%d{yyyy-MM-dd HH:mm:ss} [%t] %-5level %l %msg%n&quot; /&gt;
            &lt;Policies&gt;
                &lt;TimeBasedTriggeringPolicy /&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;100MB&quot; /&gt;
            &lt;/Policies&gt;
            &lt;DefaultRolloverStrategy max=&quot;20&quot; /&gt;
        &lt;/RollingFile&gt;
        &lt;RollingFile name=&quot;RollingFileError&quot; fileName=&quot;${fileDir}/error.log&quot; filePattern=&quot;${fileHistory}/error/%d{yyyy-MM-dd}-%i.log&quot;&gt;
            &lt;ThresholdFilter level=&quot;error&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot; /&gt;
            &lt;PatternLayout charset=&quot;UTF-8&quot; pattern=&quot;%d{yyyy-MM-dd HH:mm:ss} [%t] %-5level %l %msg%n&quot; /&gt;
            &lt;Policies&gt;
                &lt;TimeBasedTriggeringPolicy /&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;100MB&quot; /&gt;
            &lt;/Policies&gt;
            &lt;DefaultRolloverStrategy max=&quot;20&quot; /&gt;
        &lt;/RollingFile&gt;
    &lt;/Appenders&gt;
    &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效 --&gt;
    &lt;Loggers&gt;
        &lt;!--全异步输出info级以上的日志信息--&gt; 
        &lt;asyncRoot level=&quot;info&quot; includeLocation=&quot;true&quot;&gt;
            &lt;appender-ref ref=&quot;Console&quot; /&gt;
            &lt;appender-ref ref=&quot;RollingFileInfo&quot; /&gt;
        &lt;/asyncRoot&gt;
        &lt;!--同步输出info级以上的日志信息--&gt; 
        &lt;!-- &lt;root level=&quot;info&quot; includeLocation=&quot;true&quot;&gt;
            &lt;appender-ref ref=&quot;Console&quot; /&gt;
        &lt;/root&gt; --&gt;
    &lt;/Loggers&gt;
&lt;/Configuration&gt;
H</code></pre><p>  详细 API 可以参考<a href="https://logging.apache.org/log4j/2.x/manual/configuration.html" target="_blank" rel="noopener">官方网站</a></p>
<h4 id="log4j2使用"><a href="#log4j2使用" class="headerlink" title="log4j2使用"></a>log4j2使用</h4><p>与 log4j 类似，直接在需要位置打印日志即可</p>
<pre><code>package org.example.log4j.service;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class LogPrintUtil {
    /**log静态常量*/
    private static final Logger logger = LoggerFactory.getLogger(LogPrintUtil.class);
    public static void main(String[] args){
            logger.info(&quot;info信息&quot;);
            logger.warn(&quot;warn信息&quot;);
            logger.error(&quot;error信息&quot;);
    }
}</code></pre><h2 id="Logback"><a href="#Logback" class="headerlink" title="Logback"></a>Logback</h2><p>Logback也是用java编写的一款非常热门的日志开源框架,由log4j创始人写的，性能比log4j要好！</p>
<p>logback主要分为3个模块</p>
<ul>
<li>logback-core:核心代码模块</li>
<li>logback-classic: log4j的一个改良版本，同时实现了slf4j的接口，这样你如果之后要切换其他日志组件也是一件很容易的事</li>
<li>logback-access:访问模块与Servlet容器集成提供通过Http来访问日志的功能</li>
</ul>
<h3 id="项目应用-2"><a href="#项目应用-2" class="headerlink" title="项目应用"></a>项目应用</h3><h4 id="添加-maven-依赖-2"><a href="#添加-maven-依赖-2" class="headerlink" title="添加 maven 依赖"></a>添加 maven 依赖</h4><pre><code>&lt;!--这个依赖直接包含了 logback-core 以及 slf4j-api的依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
    &lt;version&gt;1.2.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- 支持在xml中写判断标签 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.codehaus.janino&lt;/groupId&gt;
    &lt;artifactId&gt;janino&lt;/artifactId&gt;
    &lt;version&gt;2.7.8&lt;/version&gt;
&lt;/dependency&gt;</code></pre><h4 id="创建logback配置文件"><a href="#创建logback配置文件" class="headerlink" title="创建logback配置文件"></a>创建logback配置文件</h4><p>1、配置说明</p>
<p>logback在启动的时候，会按照下面的顺序加载配置文件：</p>
<ul>
<li>如果java程序启动时指定了logback.configurationFile属性，就用该属性指定的配置文件。</li>
</ul>
<pre><code>如java -Dlogback.configurationFile=/path/to/mylogback.xml Test，这样执行Test类的时候就会加载/path/to/mylogback.xml配置</code></pre><ul>
<li>在classpath中查找logback.groovy文件  </li>
<li>在classpath中查找logback-test.xml文件 </li>
<li>在classpath中查找logback.xml文件</li>
<li>如果是jdk6+,那么会调用ServiceLoader查找 com.qos.logback.classic.spi.Configurator接口的第一个实现类</li>
<li>自动使用ch.qos.logback.classic.BasicConfigurator，在控制台输出日志</li>
</ul>
<p>上面的顺序表示优先级，使用java -D配置的优先级最高，只要获取到配置后就不会再执行下面的流程。相关代码可以看ContextInitializer#autoConfig()方法。</p>
<p>2、同步输出日志</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。 scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 
    debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt;
&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt;
    &lt;!-- 运行环境，dev:开发，test:测试，pre:预生产，pro:生产 --&gt;
    &lt;property name=&quot;system_host&quot; value=&quot;dev&quot; /&gt;
    &lt;property file=&quot;system.properties&quot; /&gt;
    &lt;!-- 上下文变量设置,用来定义变量值,其中name的值是变量的名称，value的值时变量定义的值。 通过&lt;property&gt;定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量。 --&gt;
    &lt;property name=&quot;CONTEXT_NAME&quot; value=&quot;logback-test&quot; /&gt;
    &lt;!-- 日志文件存放路径设置，绝对路径 --&gt;
    &lt;property name=&quot;logs.dir&quot; value=&quot;/opt/logs&quot; /&gt;
    &lt;!-- 日志文件存放路径设置，tomcat路径 --&gt;
    &lt;property name=&quot;logs.dir&quot; value=&quot;${catalina.base}/logs&quot; /&gt;
    &lt;!-- 定义日志文件 相对输入位置 --&gt;  
    &lt;property name=&quot;log_dir&quot; value=&quot;log&quot; /&gt;
    &lt;!-- 日志输出格式设置 --&gt;
    &lt;!-- 
    %d{yyyy-MM-dd HH:mm:ss} [%level] - %msg%n
      Logger: %logger
      Class: %class
      File: %file
      Caller: %caller
      Line: %line
      Message: %m
      Method: %M
      Relative: %relative
      Thread: %thread
      Exception: %ex
      xException: %xEx
      nopException: %nopex
      rException: %rEx
      Marker: %marker
      newline:%n
    --&gt;
    &lt;property name=&quot;CUSTOM_LOG_PATTERN&quot;
        value=&quot;%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{90} - %msg%n&quot; /&gt;
    &lt;!-- 上下文名称：&lt;contextName&gt;, 每个logger都关联到logger上下文， 默认上下文名称为“default”。但可以使用&lt;contextName&gt;设置成其他名字，用于区分不同应用程序的记录。 
        一旦设置，不能修改。 --&gt;
    &lt;contextName&gt;${CONTEXT_NAME}&lt;/contextName&gt;
    &lt;!-- &lt;appender&gt;是&lt;configuration&gt;的子节点，是负责写日志的组件。 有两个必要属性name和class。 name指定appender名称， 
        class指定appender的实现类。 --&gt;
    &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;!-- 对日志进行格式化。 --&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;${CUSTOM_LOG_PATTERN}&lt;/pattern&gt;
            &lt;charset&gt;UTF-8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    &lt;appender name=&quot;file&quot;
        class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;!-- 按天来回滚，如果需要按小时来回滚，则设置为{yyyy-MM-dd_HH} --&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;fileNamePattern&gt;log/testC.%d{yyyy-MM-dd}.%i.log&lt;/fileNamePattern&gt;
            &lt;!-- 如果按天来回滚，则最大保存时间为30天，30天之前的都将被清理掉 --&gt;
            &lt;maxHistory&gt;30&lt;/maxHistory&gt;
            &lt;!-- 按时间回滚的同时，按文件大小来回滚 --&gt;
            &lt;timeBasedFileNamingAndTriggeringPolicy
                class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;
                &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;
            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;
        &lt;/rollingPolicy&gt;
        &lt;!-- 过滤器，只记录WARN级别的日志 --&gt;
        &lt;!-- 果日志级别等于配置级别，过滤器会根据onMath 和 onMismatch接收或拒绝日志。 --&gt;
        &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;
            &lt;!-- 设置过滤级别 --&gt;
            &lt;level&gt;WARN&lt;/level&gt;
            &lt;!-- 用于配置符合过滤条件的操作 --&gt;
            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;
            &lt;!-- 用于配置不符合过滤条件的操作 --&gt;
            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;
        &lt;/filter&gt;
        &lt;!-- 日志输出格式 --&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;${CUSTOM_LOG_PATTERN}&lt;/pattern&gt;
            &lt;charset&gt;UTF-8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;appender name=&quot;log_file&quot;
        class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;!-- 被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。 --&gt;
        &lt;file&gt;${logs.dir}/logback-test.log&lt;/file&gt;
        &lt;!-- 按照固定窗口模式生成日志文件，当文件大于20MB时，生成新的日志文件。窗口大小是1到3，当保存了3个归档文件后，将覆盖最早的日志 --&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;&gt;
            &lt;!-- 必须包含“%i”例如，假设最小值和最大值分别为1和2，命名模式为 mylog%i.log,会产生归档文件mylog1.log和mylog2.log。还可以指定文件压缩选项，例如，mylog%i.log.gz 
                或者 没有log%i.log.zip --&gt;
            &lt;FileNamePattern&gt;${logs.dir}/logback-test.%i.log&lt;/FileNamePattern&gt;
            &lt;!-- 窗口索引最小值 --&gt;
            &lt;minIndex&gt;1&lt;/minIndex&gt;
            &lt;!-- 窗口索引最大值 --&gt;
            &lt;maxIndex&gt;3&lt;/maxIndex&gt;
        &lt;/rollingPolicy&gt;
        &lt;!-- 日志级别过滤器 --&gt;
        &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;
            &lt;!-- 日志级别过滤器 --&gt;
            &lt;level&gt;INFO&lt;/level&gt;
            &lt;!-- 符合要求的日志级别，过滤，ACCEPT:接受 --&gt;
            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;
            &lt;!-- 不符合要求的日志级别，过滤，DENY:拒绝 --&gt;
            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;
        &lt;/filter&gt;
        &lt;!-- 激活滚动的条件。 --&gt;
        &lt;triggeringPolicy
            class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;
            &lt;!-- 活动文件的大小，默认值是10MB --&gt;
            &lt;maxFileSize&gt;30MB&lt;/maxFileSize&gt;
        &lt;/triggeringPolicy&gt;
        &lt;!-- 对记录事件进行格式化。 --&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;${CUSTOM_LOG_PATTERN}&lt;/pattern&gt;
            &lt;charset&gt;UTF-8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- 异步输出 --&gt;
    &lt;appender name=&quot;ASYNC_logback&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt;
        &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt;
        &lt;!-- &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt; --&gt;
        &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt;
        &lt;!-- &lt;queueSize&gt;256&lt;/queueSize&gt; --&gt;
        &lt;!-- 添加附加的appender,最多只能添加一个 --&gt;
        &lt;appender-ref ref=&quot;log_file&quot; /&gt;
    &lt;/appender&gt;
    &lt;!-- 指定包输出路径 --&gt;
    &lt;!-- 用来设置某一个 包 或者具体的某一个 类 的日志打印级别、以及指定&lt;appender&gt;, name:用来指定受此logger约束的某一个包或者具体的某一个类。 
        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。如果未设置此属性，那么当前loger将会继承上级的级别。 
        additivity:是否向上级logger传递打印信息。默认是true。(这个logger的上级就是上面的root) &lt;logger&gt;可以包含零个或多个&lt;appender-ref&gt;元素，标识这个appender将会添加到这个logger。 --&gt;
    &lt;logger name=&quot;org.logback.test&quot; level=&quot;DEBUG&quot; additivity=&quot;true&quot;&gt;
        &lt;appender-ref ref=&quot;stdout&quot; /&gt;
    &lt;/logger&gt;
    &lt;!-- 特殊的&lt;logger&gt;元素，是根logger。只有一个level属性，应为已经被命名为&quot;root&quot;. level:设置打印级别，大小写无关：TRACE, 
        DEBUG, INFO, WARN, ERROR, ALL 和 OFF，不能设置为INHERITED或者同义词NULL。默认是DEBUG。 &lt;root&gt;可以包含零个或多个&lt;appender-ref&gt;元素，标识这个appender将会添加到这个loger。 --&gt;
    &lt;root&gt;
        &lt;level value=&quot;WARN&quot; /&gt;
        &lt;!-- if表达式，需要Janino jar --&gt;
        &lt;!-- Janino 2.6.0版本开始，除了janino.jar之外， commons-compiler.jar也需要在类路径中 --&gt;
        &lt;if condition=&apos;property(&quot;system_host&quot;).contains(&quot;dev&quot;)&apos;&gt;
            &lt;then&gt;
                &lt;appender-ref ref=&quot;stdout&quot; /&gt;
            &lt;/then&gt;
        &lt;/if&gt;
        &lt;appender-ref ref=&quot;file&quot; /&gt;
    &lt;/root&gt;
&lt;/configuration&gt;</code></pre><p>注意：logback如果配置要输出行号，性能会明显降低，如果不是必须，建议不要配置！</p>
<h4 id="logback使用"><a href="#logback使用" class="headerlink" title="logback使用"></a>logback使用</h4><pre><code>package org.example.logback.service;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class LogPrintUtil {
    /**log静态常量*/
    private static final Logger logger = LoggerFactory.getLogger(LogPrintUtil.class);
    public static void main(String[] args){
            logger.info(&quot;info信息&quot;);
            logger.warn(&quot;warn信息&quot;);
            logger.error(&quot;error信息&quot;);
    }
}</code></pre><h2 id="SLF4J桥接"><a href="#SLF4J桥接" class="headerlink" title="SLF4J桥接"></a>SLF4J桥接</h2><pre><code>细心的你，会发现上面代码使用时，都使用的是private static final Logger logger = LoggerFactory.getLogger(LogPrintUtil.class)这个，其中都来自org.slf4j包，SLF4J是啥？有什么作用呢？

SLF4J本身并不输出日志，最大的特色是：它可以通过适配的方式挂接不同的日志系统，属于一个日志接口。

如果项目适配到log4j就使用log4j日志库进行输出；如果适配到logback就使用logback日志库进行输出；如果适配到log4j2就使用log4j2日志库进行输出。

这样最大的好处，就是当你想将项目从log4j换成log4j2的时候，只需要在项目pom.xml中进行桥接适配即可，不用修改具体需要打印日志的代码！</code></pre><h2 id="三大主流日志框架性能比较"><a href="#三大主流日志框架性能比较" class="headerlink" title="三大主流日志框架性能比较"></a>三大主流日志框架性能比较</h2><pre><code>介绍了这么多，但是我们还不知道三个日志框架的日志输出性能如何，本文以10000条数据进行打印，比较log4j、log4j2、logback日志的输出时间。

本次测试采用的是本地电脑（win7），每个电脑的配置不一样，测试的结果也不一样，结果是真实的。</code></pre><p>同步输出</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">log4j</th>
<th align="left">log4j2</th>
<th align="left">logback</th>
</tr>
</thead>
<tbody><tr>
<td align="left">控制台耗时(ms)</td>
<td align="left">21331</td>
<td align="left">31511</td>
<td align="left">23339</td>
</tr>
<tr>
<td align="left">纯文件耗时（ms)</td>
<td align="left">11574</td>
<td align="left">32642</td>
<td align="left">3829</td>
</tr>
</tbody></table>
<p>异步输出<br>|类型|log4j|log4j2|logback|<br>|:—- |:— |:— |:— |<br>|控制台耗时(ms)|未测试|9256|7497(异步输出未实时)|<br>|纯文件耗时（ms)|未测试|8455|3451(异步输出未实时)|</p>
<p>从测试结果上可以看出：</p>
<ul>
<li>不建议生产环境进行控制台输出；</li>
<li>在纯文件输出的环境下，logback的输出优于log4j2，而log4j2要优于log4j，如果要进行生产环境的部署，建议采用logback，如果是使用log4j2，建议使用异步方式进行输出，输出结果基本是实时输出；</li>
</ul>
<p>最后需要注意的地方是：log有风险，输出需谨慎！</p>
<p>由于输出log过程需要进行磁盘操作，且log4j为了保证log输出过程的线程安全性而使用同步锁，就使得输出log成为很耗时的操作，所以log信息一定要言简意赅，不要输出一些无用的log。</p>
]]></content>
  </entry>
  <entry>
    <title>技术网站</title>
    <url>/2021/01/16/%E6%8A%80%E6%9C%AF%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p>java程序员学技术的网站</p>
<p><a href="https://www.bilibili.com/" target="_blank" rel="noopener">哔哩哔哩</a><br><a href="https://www.csdn.net/nav/java" target="_blank" rel="noopener">CSDN</a><br><a href="https://juejin.cn/" target="_blank" rel="noopener">掘金</a><br><a href="https://www.jianshu.com/" target="_blank" rel="noopener">简书</a><br><a href="https://www.cnblogs.com/" target="_blank" rel="noopener">博客园</a><br><a href="https://www.imooc.com/" target="_blank" rel="noopener">慕课网</a><br><a href="http://github.com/" target="_blank" rel="noopener">github</a><br><a href="https://gitee.com/" target="_blank" rel="noopener">码云</a><br><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">力扣</a><br><a href="http://www.runoob.com" target="_blank" rel="noopener">菜鸟教程</a><br><a href="https://www.sojson.com/" target="_blank" rel="noopener">JSON在线</a><br><a href="https://tool.lu/" target="_blank" rel="noopener">程序员工具箱</a><br><a href="https://www.oschina.net" target="_blank" rel="noopener">开源中国</a><br><a href="https://www.processon.com" target="_blank" rel="noopener">Processon</a><br><a href="https://ke.qq.com/" target="_blank" rel="noopener">腾讯课堂</a><br><a href="http://tool.chinaz.com/Tools/unixtime.aspx" target="_blank" rel="noopener">时间戳转换</a><br><a href="https://www.w3school.com.cn/" target="_blank" rel="noopener">w3school</a><br><a href="https://stackoverflow.com/" target="_blank" rel="noopener">Stack Overflow</a><br><a href="https://www.lintcode.com/" target="_blank" rel="noopener">领扣</a><br><a href="https://www.v2ex.com/" target="_blank" rel="noopener">V2EX</a><br><a href="https://www.twle.cn/" target="_blank" rel="noopener">简单教程</a><br><a href="https://segmentfault.com/" target="_blank" rel="noopener">思否</a><br><a href="https://www.nowcoder.com/" target="_blank" rel="noopener">牛客网</a><br><a href="https://www.matools.com/api/java8" target="_blank" rel="noopener">java在线中文API</a><br><a href="https://www.zhihu.com/" target="_blank" rel="noopener">知乎</a><br><a href="http://www.kailing.pub/" target="_blank" rel="noopener">KL</a><br><a href="https://www.ituring.com.cn/" target="_blank" rel="noopener">图灵社区</a><br><a href="https://hutool.cn/docs/#/" target="_blank" rel="noopener">Hutool</a><br><a href="https://www.coolshell.cn/" target="_blank" rel="noopener">左耳朵耗子博客</a><br><a href="https://www.coolshell.cn/" target="_blank" rel="noopener">阮一峰的网络日志</a><br><a href="https://gudaoxuri.gitbook.io/microservices-architecture/" target="_blank" rel="noopener">微服务架构设计</a><br><a href="http://mysql.taobao.org/" target="_blank" rel="noopener">阿里云数据库内核月报</a><br><a href="https://tech.meituan.com/" target="_blank" rel="noopener">美团技术</a><br><a href="https://developer.ibm.com/zh/" target="_blank" rel="noopener">IBM技术</a><br><a href="https://iwantjingjing.com/">我想静静</a><br><a href="https://www.infoq.cn/" target="_blank" rel="noopener">infoQ</a><br><a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a></p>
]]></content>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2021/02/02/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>在策略模式（Strategy Pattern)中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p>
<p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的context对象。策略对象改变context对象的执行算法。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图</strong>：定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换。策略模式让算法独立与使用它的客户变换，也称为政策模式（policy）</p>
<p><strong>主要解决</strong>：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护</p>
<p><strong>何时使用</strong>：一个系统有许多许多类，而区分它们的只是他们直接的行为。</p>
<p><strong>如何解决</strong>：将这些算法封装成一个一个的类，任意地替换。</p>
<p><strong>关键代码</strong>：实现同一个接口。</p>
<p><strong>应用实例：</strong> </p>
<p>1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。</p>
<p>2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 </p>
<p>3、JAVA AWT 中的 LayoutManager。</p>
<p><strong>优点：</strong> </p>
<p>1、算法可以自由切换。</p>
<p>2、避免使用多重条件判断。</p>
<p>3、扩展性良好。</p>
<p><strong>缺点：</strong></p>
<p>1、策略类会增多。 </p>
<p>2、所有策略类都需要对外暴露。</p>
<p><strong>使用场景：</strong></p>
<p>1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 </p>
<p>2、一个系统需要动态地在几种算法中选择一种。</p>
<p>3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p>
<p><strong>注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</strong></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2>]]></content>
  </entry>
  <entry>
    <title>Mac装机必备</title>
    <url>/2021/04/01/Mac%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/</url>
    <content><![CDATA[<h2 id="Mac教程"><a href="#Mac教程" class="headerlink" title="Mac教程"></a><a href="https://search.bilibili.com/all?keyword=mac%E6%95%99%E7%A8%8B&from_source=nav_suggest_new" target="_blank" rel="noopener">Mac教程</a></h2><h2 id="如何在Mac上安装软件？"><a href="#如何在Mac上安装软件？" class="headerlink" title="如何在Mac上安装软件？"></a><a href="https://www.imymac.com/zh-CN/mac-uninstaller/how-to-install-software-on-mac.html" target="_blank" rel="noopener">如何在Mac上安装软件？</a></h2><h2 id="在-Mac-上安全地打开-App"><a href="#在-Mac-上安全地打开-App" class="headerlink" title="在 Mac 上安全地打开 App"></a><a href="https://support.apple.com/zh-cn/HT202491" target="_blank" rel="noopener">在 Mac 上安全地打开 App</a></h2><h2 id="装机神器"><a href="#装机神器" class="headerlink" title="装机神器"></a><a href="https://markdowner.net/article/144933455225282560" target="_blank" rel="noopener">装机神器</a></h2><h2 id="程序员用-Mac-都有哪些必备的-app？"><a href="#程序员用-Mac-都有哪些必备的-app？" class="headerlink" title="程序员用 Mac 都有哪些必备的 app？"></a><a href="https://www.zhihu.com/question/20036899/answer/81771318" target="_blank" rel="noopener">程序员用 Mac 都有哪些必备的 app？</a></h2><h2 id="iTerm"><a href="#iTerm" class="headerlink" title="iTerm"></a><a href="https://iterm2.com/downloads.html" target="_blank" rel="noopener">iTerm</a></h2><pre><code>brew search chrome
brew install google-chrome

brew search toolbox
brew install jetbrains-toolbox

brew search redis
brew install another-redis-desktop-manager

brew search java

brew install the-unarchiver

brew install alfred</code></pre><h2 id="强迫症的-Mac-设置指南"><a href="#强迫症的-Mac-设置指南" class="headerlink" title="强迫症的 Mac 设置指南"></a><a href="https://github.com/macdao/ocds-guide-to-setting-up-mac" target="_blank" rel="noopener">强迫症的 Mac 设置指南</a></h2>]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>STEAM教育</title>
    <url>/2021/04/08/STEAM%E6%95%99%E8%82%B2/</url>
    <content><![CDATA[<p>STEAM = STEM + ART</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在上個世紀末，美國國家科學基金會（NSF）發表一篇論文《型塑未來世界》，首次使用了STEM一詞。自那時開始，STEM被廣泛討論，時至如今也能看見許多玩具強調S.T.E.M。由於STEM一詞是由科學家們提出的概念，這些理工出身的背景忽略了一件重要的事情，那就是人文美學的重要性。因此在2006年至2008年期間由Georgette Yakman和John Maeda兩人提出將藝術（Art）整合進STEM，成為一項全人教育。</p>
<h2 id="21世纪需具备的技能"><a href="#21世纪需具备的技能" class="headerlink" title="21世纪需具备的技能"></a>21世纪需具备的技能</h2><p>如何正確尋找需要的資訊」成為了當代社會最需要的能力。</p>
<h3 id="思考方法"><a href="#思考方法" class="headerlink" title="思考方法"></a>思考方法</h3><ul>
<li>创造性与技术革新</li>
<li>思辨、解决问题、自我意志</li>
<li>学习方法、后设认知</li>
</ul>
<h3 id="工作方法"><a href="#工作方法" class="headerlink" title="工作方法"></a>工作方法</h3><ul>
<li>沟通</li>
<li>团队合作<h3 id="生存能力"><a href="#生存能力" class="headerlink" title="生存能力"></a>生存能力</h3></li>
<li>地球公民意识</li>
<li>人生与事业发展</li>
<li>个人与社会责任<h3 id="工作工具"><a href="#工作工具" class="headerlink" title="工作工具"></a>工作工具</h3></li>
<li>咨询读写能力</li>
<li>ICT读写能力</li>
</ul>
<h2 id="STEAM教育理念"><a href="#STEAM教育理念" class="headerlink" title="STEAM教育理念"></a>STEAM教育理念</h2><p>STEAM是由五個單字組成，他們就是：<br>Science(科學)<br>Technology(技術)<br>Engineering(工程)<br>Arts(藝術)<br>Mathematics(數學)。</p>
<p>STEAM 教育強調動手做（hands-on）、問題解決（problem-solving）、<br>專案取向的教學（project-based），藉此培養孩子內在的綜合能力，<br>包括了：「探究能力」、「批判思考能力」、「創意思考能力」、「問題解決能力」。</p>
]]></content>
      <categories>
        <category>教育</category>
      </categories>
      <tags>
        <tag>教育</tag>
      </tags>
  </entry>
  <entry>
    <title>关于sonar扫描的那点事</title>
    <url>/2021/04/10/%E5%85%B3%E4%BA%8Esonar%E6%89%AB%E6%8F%8F%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B/</url>
    <content><![CDATA[<p>关于sonar扫描的那点事</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、&quot;.equals()&quot; should not be used to test the values of &quot;Atomic&quot; classes.</span><br><span class="line">bug  主要</span><br><span class="line">不要使用equals方法对AtomicXXX进行是否相等的判断</span><br><span class="line">Atomic变量永远只会和自身相等，Atomic变量没有覆写equals()方法.</span><br><span class="line">2、&quot;&#x3D;+&quot; should not be used instead of &quot;+&#x3D;&quot;</span><br><span class="line">bug 主要</span><br><span class="line">&quot;&#x3D;+&quot; 与 &quot;&#x3D;+&quot; 意义不同</span><br><span class="line">a &#x3D;+ b;虽然正确但写法不合规，应写成 a &#x3D; +b;</span><br><span class="line">3、&quot;@NonNull&quot; values should not be set to null</span><br><span class="line">bug 次要</span><br><span class="line">标注非空假定非空且在使用之前不进行非空检查，设置为空会导致空指针异常</span><br><span class="line">4、&quot;BigDecimal(double)&quot; should not be used</span><br><span class="line">bug 主要</span><br><span class="line">因为浮点的不精确,可能使用BigDecimal(double)得不到期望的值</span><br><span class="line">5、&quot;compareTo&quot; results should not be checked for specific values</span><br><span class="line">bug 次要</span><br><span class="line">compareTo可能返回不是具体的值（除0外），建议用 &gt;0、&lt;0、&#x3D;0</span><br><span class="line">6、&quot;compareTo&quot; should not return &quot;Integer.MIN_VALUE&quot;</span><br><span class="line">bug 次要</span><br><span class="line">compareTo只代表一个不等标识，不代表不等的程度，应返回-1,0,1标识即可</span><br><span class="line">7、 &quot;Double.longBitsToDouble&quot; should not be used for &quot;int&quot;</span><br><span class="line">bug 主要  </span><br><span class="line">Double.longBitsToDouble返回给定的位所代表的double值,需要一个64位的long类型参数.</span><br><span class="line">8、 &quot;equals&quot; method overrides should accept &quot;Object&quot; parameters</span><br><span class="line">bug 主要  </span><br><span class="line">equals作为方法名应该仅用于重写Object.equals(Object)来避免混乱.</span><br><span class="line">9、 &quot;equals(Object obj)&quot; should test argument type</span><br><span class="line">bug 次要</span><br><span class="line">要比较obj的class  type是否一样</span><br><span class="line">10、&quot;equals&quot; methods should be symmetric and work for subclasses</span><br><span class="line">bug 次要</span><br><span class="line">equals应是对等并且在有子类参与时能正常工作</span><br><span class="line">11、&quot;equals(Object obj)&quot; and &quot;hashCode()&quot; should be overridden in pairs</span><br><span class="line">bug 次要</span><br><span class="line">成对重写</span><br><span class="line">12、&quot;Externalizable&quot; classes should have no-arguments constructors</span><br><span class="line">bug 主要</span><br><span class="line">Externalizable(可序列化与返序列化)类应该有无参构造器</span><br><span class="line">13、&quot;getClass&quot; should not be used for synchronization</span><br><span class="line">bug  主要</span><br><span class="line">&#123;synchronized (this.getClass())&#125;  错误 子类继承此方法时不能做到同步</span><br><span class="line">&#123;synchronized (MyClass.class)&#125; 正确</span><br><span class="line">14、&quot;hashCode&quot; and &quot;toString&quot; should not be called on array instances</span><br><span class="line">bug 主要</span><br><span class="line">使用Arrays.toString(args)和Arrays.hashCode(args)代替.</span><br><span class="line">15、&quot;instanceof&quot; operators that always return &quot;true&quot; or &quot;false&quot; should be removed</span><br><span class="line">bug 主要</span><br><span class="line">16、&quot;InterruptedException&quot; should not be ignored</span><br><span class="line">bug 主要</span><br><span class="line">try &#123;</span><br><span class="line">while (true) &#123;</span><br><span class="line">&#x2F;&#x2F; do stuff</span><br><span class="line">&#125;</span><br><span class="line">&#125;catch (InterruptedException e) &#123;</span><br><span class="line">LOGGER.log(Level.WARN, &quot;Interrupted!&quot;, e);</span><br><span class="line">&#x2F;&#x2F; Restore interrupted state...</span><br><span class="line">Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line">17、&quot;Iterator.hasNext()&quot; should not call &quot;Iterator.next()&quot;</span><br><span class="line">bug 主要</span><br><span class="line">18、&quot;Iterator.next()&quot; methods should throw &quot;NoSuchElementException&quot;</span><br><span class="line">bug 次要</span><br><span class="line">public String next()&#123;</span><br><span class="line">if(!hasNext())&#123;</span><br><span class="line">throw new NoSuchElementException();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">19、&quot;notifyAll&quot; should be used</span><br><span class="line">bug 主要</span><br><span class="line">notify可能不能唤醒正确的线程，notifyAll代之。</span><br><span class="line">20、&quot;null&quot; should not be used with &quot;Optional&quot;</span><br><span class="line">bug 主要</span><br><span class="line">把判空包装起来使用而不直接使用!&#x3D;null</span><br><span class="line">21、&quot;PreparedStatement&quot; and &quot;ResultSet&quot; methods should be called with valid indices</span><br><span class="line">bug 阻断</span><br><span class="line">PreparedStatement与ResultSet参数设置与获取数据由序号1开始而非0</span><br><span class="line">22、&quot;read&quot; and &quot;readLine&quot; return values should be used</span><br><span class="line">bug 主要</span><br><span class="line">BufferedReader.readLine(), Reader.read()及子类中的相关方法都应该先存储再比较</span><br><span class="line">buffReader &#x3D; new BufferedReader(new FileReader(fileName));</span><br><span class="line">String line &#x3D; null;</span><br><span class="line">while ((line &#x3D; buffReader.readLine()) !&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">23、&quot;runFinalizersOnExit&quot; should not be called</span><br><span class="line">bug 严重</span><br><span class="line">JVM退出时不可能运行finalizers,System.runFinalizersOnExit 和 Runtime.runFinalizersOnExit可以在jvm退出时运行但是因为他们不安全而弃用.</span><br><span class="line">正确用法:</span><br><span class="line">Runtime.addShutdownHook(new Runnable() &#123;</span><br><span class="line">public void run()&#123;</span><br><span class="line">doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">24、&quot;ScheduledThreadPoolExecutor&quot; should not have 0 core threads</span><br><span class="line">bug 严重</span><br><span class="line">java.util.concurrent.ScheduledThreadPoolExecutor由属性corePoolSize指定线程池大小，如果设置为0表示线程执行器无线程可用且不做任何事.</span><br><span class="line">25、&quot;Serializable&quot; inner classes of non-serializable classes should be &quot;static&quot;</span><br><span class="line">bug 次要</span><br><span class="line">序列化非静态内部类将导致尝试序列化外部类,如果外部类不是序列化类,会产生运行时异常，内部类静态化会避免这种情况</span><br><span class="line">26、&quot;SingleConnectionFactory&quot; instances should be set to &quot;reconnectOnException&quot;</span><br><span class="line">bug 主要</span><br><span class="line">使用Spring SingleConnectionFactory而不启用reconnectOnException设置当连接恶化将阻止自动连接恢复。</span><br><span class="line">27、&quot;StringBuilder&quot; and &quot;StringBuffer&quot; should not be instantiated with a character</span><br><span class="line">bug 主要</span><br><span class="line">StringBuffer foo &#x3D; new StringBuffer(&#39;x&#39;);  错  equivalent to StringBuffer foo &#x3D; new StringBuffer(120);</span><br><span class="line">StringBuffer foo &#x3D; new StringBuffer(&quot;x&quot;);  对</span><br><span class="line">28、 &quot;super.finalize()&quot; should be called at the end of &quot;Object.finalize()&quot; implementations</span><br><span class="line">bug 严重</span><br><span class="line">protected void finalize() &#123;</span><br><span class="line">releaseSomeResources();</span><br><span class="line">super.finalize();       &#x2F;&#x2F;调用，最后调用</span><br><span class="line">&#125;</span><br><span class="line">29、&quot;toArray&quot; should be passed an array of the proper type</span><br><span class="line">bug 次要</span><br><span class="line">toArray()无参且强制类型转换会产生运行时异常,应传入一个合适的类弄作参数</span><br><span class="line">public String [] getStringArray(List&lt;String&gt; strings) &#123;</span><br><span class="line">return strings.toArray(new String[0]);</span><br><span class="line">&#125;</span><br><span class="line">30、&quot;toString()&quot; and &quot;clone()&quot; methods should not return null</span><br><span class="line">bug 主要</span><br><span class="line">可返回&quot;&quot;</span><br><span class="line">31、 &quot;wait&quot; should not be called when multiple locks are held</span><br><span class="line">bug 阻断</span><br><span class="line">32、 &quot;wait&quot;, &quot;notify&quot; and &quot;notifyAll&quot; should only be called when a lock is obviously held on an object</span><br><span class="line">bug 主要</span><br><span class="line">先要获得对象锁才能进行上述操作</span><br><span class="line">private void removeElement() &#123;</span><br><span class="line">synchronized(obj) &#123;</span><br><span class="line">while (!suitableCondition())&#123;</span><br><span class="line">obj.wait();</span><br><span class="line">&#125;</span><br><span class="line">... &#x2F;&#x2F; Perform removal</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      or</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      private synchronized void removeElement() &#123;</span><br><span class="line">while (!suitableCondition())&#123;</span><br><span class="line">wait();</span><br><span class="line">&#125;</span><br><span class="line">... &#x2F;&#x2F; Perform removal</span><br><span class="line">&#125;</span><br><span class="line">33、&quot;wait(...)&quot; should be used instead of &quot;Thread.sleep(...)&quot; when a lock is held</span><br><span class="line">bug 阻断</span><br><span class="line">当持有锁的当前线程调用Thread.sleep(...)可能导致性能和扩展性问题，甚至死锁因为持有锁的当前线程已冻结.合适的做法是锁对象wait()释放锁让其它线程进来运行.</span><br><span class="line">34、A &quot;for&quot; loop update clause should move the counter in the right direction</span><br><span class="line">bug 主要</span><br><span class="line">检查for循环下标递增或递减正确</span><br><span class="line">35、All branches in a conditional structure should not have exactly the same implementation</span><br><span class="line">bug 主要</span><br><span class="line">分支中不应该有相同的实现</span><br><span class="line">36、Blocks should be synchronized on &quot;private final&quot; fields or parameters</span><br><span class="line">bug 主要</span><br><span class="line">synchronized同步块应该锁在private final fields或parameters对象上,因为同步块内非final锁对象可能改变导致其它线程进来运行.</span><br><span class="line">37、Boxing and unboxing should not be immediately reversed</span><br><span class="line">bug  次要</span><br><span class="line">自动拆箱和装箱不需手动转换</span><br><span class="line">38、Child class methods named for parent class methods should be overrides</span><br><span class="line">bug 主要</span><br><span class="line">以下情况不是重写:</span><br><span class="line">a、父类方法是static的而子类方法不是static的</span><br><span class="line">b、子类方法的参数或返回值与父类方法不是同一个包</span><br><span class="line">c、父类方法是private</span><br><span class="line">为了不产生混乱，不要与父类方法同名</span><br><span class="line">39、Classes extending java.lang.Thread should override the &quot;run&quot; method</span><br><span class="line">bug 主要</span><br><span class="line">线程类应该重写run方法</span><br><span class="line">40、Classes should not be compared by name</span><br><span class="line">bug 主要</span><br><span class="line">不要用类名称比较类是否相同，而用instanceof或者Class.isAssignableFrom()进行底动类型比较</span><br><span class="line">41、Classes that don&#39;t define &quot;hashCode()&quot; should not be used in hashes</span><br><span class="line">bug 主要</span><br><span class="line">没有定义hashCode()方法的类不能作为hash集合中的键值，因为equal相同的实例对像可能返回不同的hash值.</span><br><span class="line">42、Collections should not be passed as arguments to their own methods</span><br><span class="line">bug 主要</span><br><span class="line">集合实例不应该作为参数被传给集合实你还自已的方法中</span><br><span class="line">43、Conditionally executed blocks should be reachable</span><br><span class="line">bug 主要</span><br><span class="line">条件执行块应该可达</span><br><span class="line">44、Constructor injection should be used instead of field injection</span><br><span class="line">bug 主要</span><br><span class="line">构造器注入应该替代属性注入(非Spring framework)</span><br><span class="line">因为任何非Spring framework实例化而是通过构造器实例化的实例不能注入属性,这样公有的构造器实化化后可能产生NullPointerException，除非所有的构造器都是私有的</span><br><span class="line">45、Consumed Stream pipelines should not be reused</span><br><span class="line">bug 主要</span><br><span class="line">流不应该重用</span><br><span class="line">46、Custom resources should be closed</span><br><span class="line">bug 阻断</span><br><span class="line">资源应该关闭</span><br><span class="line">47、Custom serialization method signatures should meet requirements</span><br><span class="line">bug 主要</span><br><span class="line">自定义类序列化方法签名应该合法</span><br><span class="line">49、Dependencies should not have &quot;system&quot; scope</span><br><span class="line">bug 严重</span><br><span class="line">maven依赖不要在system scope</span><br><span class="line">50、Dissimilar primitive wrappers should not be used with the ternary operator without explicit casting</span><br><span class="line">bug 主要</span><br><span class="line">不同的原始包装类如果没有明确的类转换不能用于三元操作中</span><br><span class="line">51、Double Brace Initialization should not be used</span><br><span class="line">bug 次要</span><br><span class="line">双构造初始不要用</span><br><span class="line">Map source &#x3D; new HashMap()&#123;&#123; &#x2F;&#x2F; Noncompliant</span><br><span class="line">put(&quot;firstName&quot;, &quot;John&quot;);</span><br><span class="line">put(&quot;lastName&quot;, &quot;Smith&quot;);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">此操作如一个anonymous inner class，如果anonymous inner class返回且被其它对象引用，可能产生memory leaks，既使不产生memory leaks也会让大多维护者感到迷惑</span><br><span class="line">52、Double-checked locking should not be used</span><br><span class="line">bug 阻断</span><br><span class="line">重复检查的锁块不要使用</span><br><span class="line">public static Resource getInstance() &#123;</span><br><span class="line">if (resource &#x3D;&#x3D; null) &#123;</span><br><span class="line">synchronized (DoubleCheckedLocking.class) &#123;</span><br><span class="line">if (resource &#x3D;&#x3D; null)</span><br><span class="line">resource &#x3D; new Resource();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return resource;</span><br><span class="line">&#125;</span><br><span class="line">应</span><br><span class="line">public synchronized static Resource getInstance() &#123;</span><br><span class="line">if (resource &#x3D;&#x3D; null)</span><br><span class="line">resource &#x3D; new Resource();</span><br><span class="line">return resource;</span><br><span class="line">&#125;</span><br><span class="line">53、Equals Hash Code</span><br><span class="line">bug 严重</span><br><span class="line">成对重写equals()与hashCode()</span><br><span class="line">54、Exception should not be created without being thrown</span><br><span class="line">bug 主要</span><br><span class="line">不被抛出的异常不要创建</span><br><span class="line">55、Expressions used in &quot;assert&quot; should not produce side effects</span><br><span class="line">bug 主要</span><br><span class="line">assert表达式不要产生负影响，不要改变数据状态</span><br><span class="line">56、Failed unit tests should be fixed</span><br><span class="line">bug 主要</span><br><span class="line">失败的单元测试应该尽快解决掉</span><br><span class="line">57、Floating point numbers should not be tested for equality</span><br><span class="line">bug 主要</span><br><span class="line">浮点数不要进行比较</span><br><span class="line">58、Getters and setters should be synchronized in pairs</span><br><span class="line">bug 主要</span><br><span class="line">get与set应该成对进行同步操作</span><br><span class="line">59、Identical expressions should not be used on both sides of a binary operator</span><br><span class="line">bug 主要</span><br><span class="line">相同的表达式不要作为二进制操作的操作数使用,应该简化</span><br><span class="line">60、Inappropriate &quot;Collection&quot; calls should not be made</span><br><span class="line">bug 主要</span><br><span class="line">正确使用集合元素类型</span><br><span class="line">61、Inappropriate regular expressions should not be used</span><br><span class="line">bug 主要</span><br><span class="line">正确使用正则表达式</span><br><span class="line">62、Intermediate Stream methods should not be left unused</span><br><span class="line">bug 主要</span><br><span class="line">中间流应该被使用</span><br><span class="line">63、Ints and longs should not be shifted by zero or more than their number of bits-1</span><br><span class="line">bug 次要</span><br><span class="line">整型与长整型位移操作数应该价于1与类型占位数-1</span><br><span class="line">64、Invalid &quot;Date&quot; values should not be used</span><br><span class="line">bug 主要</span><br><span class="line">正确使用日期</span><br><span class="line">65、Jump statements should not occur in &quot;finally&quot; blocks</span><br><span class="line">bug 主要</span><br><span class="line">finally块中使用return, break, throw等Jump statements，会阻止在try catch中抛出的未处理异常的传播</span><br><span class="line">66、Locks should be released</span><br><span class="line">bug 严重</span><br><span class="line">保证锁的能够释放</span><br><span class="line">67、Loop conditions should be true at least once</span><br><span class="line">bug 主要</span><br><span class="line">循环应该至少走一次</span><br><span class="line">68、Loops should not be infinit</span><br><span class="line">bug 阻断</span><br><span class="line">循环不应该死循环</span><br><span class="line">69、Math operands should be cast before assignment</span><br><span class="line">bug 次要</span><br><span class="line">数字操作在操作或赋值前要转化</span><br><span class="line">70、Math should not be performed on floats</span><br><span class="line">bug 次要</span><br><span class="line">BigDecimal代替floats进行大数精确运算</span><br><span class="line">71、Methods &quot;wait(...)&quot;, &quot;notify()&quot; and &quot;notifyAll()&quot; should not be called on Thread instances</span><br><span class="line">bug 阻断</span><br><span class="line">不要在线程中使用&quot;wait(...)&quot;, &quot;notify()&quot; and &quot;notifyAll()&quot;</span><br><span class="line">72、Methods should not be named &quot;hashcode&quot; or &quot;equal&quot;</span><br><span class="line">bug 主要</span><br><span class="line">除非Override重写这些方法</span><br><span class="line">73、Multiline blocks should be enclosed in curly braces</span><br><span class="line">bug 主要</span><br><span class="line">多列块应用大括号括起来</span><br><span class="line">74、Neither &quot;Math.abs&quot; nor negation should be used on numbers that could be &quot;MIN_VALUE&quot;</span><br><span class="line">bug 次要</span><br><span class="line">不要对数值类型的MIN_VALUE值或返回值为此值进行Math.abs与取反操作，因为不会起作用。</span><br><span class="line">75、Non-public methods should not be &quot;@Transactional&quot;</span><br><span class="line">bug 主要</span><br><span class="line">非public方法不要注解Transactional,调用时spring 会抛出异常</span><br><span class="line">76、Non-serializable classes should not be written</span><br><span class="line">bug 主要</span><br><span class="line">执行写操作的类要序列化，否则会抛出异常</span><br><span class="line">77、Non-serializable objects should not be stored in &quot;HttpSession&quot; objects</span><br><span class="line">bug 主要</span><br><span class="line">HttpSession要保存序列化的对象</span><br><span class="line">78、Non-thread-safe fields should not be static</span><br><span class="line">bug 主要</span><br><span class="line">非线程安全的域不应该静态化</span><br><span class="line">79、Null pointers should not be dereferenced</span><br><span class="line">bug 主要</span><br><span class="line">空指针引用不应被访问</span><br><span class="line">80、Optional value should only be accessed after calling isPresent()</span><br><span class="line">bug 主要</span><br><span class="line">Optional实例值的获取要isPresent()之后再做操作</span><br><span class="line">90、Printf-style format strings should not lead to unexpected behavior at runtime</span><br><span class="line">bug 阻断</span><br><span class="line">因为Printf风格格式化是在运行期解读，而不是在编译期检验,会存在风险</span><br><span class="line">91、Raw byte values should not be used in bitwise operations in combination with shifts</span><br><span class="line">bug 主要</span><br><span class="line">原始字节值不应参与位运算</span><br><span class="line">result &#x3D; (result &lt;&lt; 8) | readByte(); &#x2F;&#x2F; Noncompliant</span><br><span class="line">正:</span><br><span class="line">result &#x3D; (result &lt;&lt; 8) | (readByte() &amp; 0xff);</span><br><span class="line">92、Reflection should not be used to check non-runtime annotations</span><br><span class="line">bug 主要</span><br><span class="line">反射操作不应该运于检查非运行时注解</span><br><span class="line">93、Related &quot;if&#x2F;else if&quot; statements should not have the same condition</span><br><span class="line">bug 主要</span><br><span class="line">if&#x2F;else if中不应该有相同的条件</span><br><span class="line">94、Resources should be closed</span><br><span class="line">bug 阻断</span><br><span class="line">打开的资源应该关闭并且放到finally块中进行关闭</span><br><span class="line">95、Return values from functions without side effects should not be ignored</span><br><span class="line">bug 主要</span><br><span class="line">操作对函数返回值没有影响的应该忽略</span><br><span class="line">public void handle(String command)&#123;</span><br><span class="line">command.toLowerCase(); &#x2F;&#x2F; Noncompliant; result of method thrown away</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">96、Servlets should not have mutable instance fields</span><br><span class="line">bug 主要</span><br><span class="line">servlet容器对每一个servlet创建一个实例导致实例变量共享产生问题</span><br><span class="line">struts1.x 也是单例</span><br><span class="line">97、Short-circuit logic should be used to prevent null pointer dereferences in conditionals</span><br><span class="line">bug 主要</span><br><span class="line">应正确使用短路逻辑来防止条件中的空指针引用访问</span><br><span class="line">98、Silly equality checks should not be made</span><br><span class="line">bug 主要</span><br><span class="line">愚蠢的相等检查不应该做</span><br><span class="line">非同类型的对象equal</span><br><span class="line">99、Spring &quot;@Controller&quot; classes should not use &quot;@Scope&quot;</span><br><span class="line">bug 主要</span><br><span class="line">保持spring controller的单例</span><br><span class="line">100、Synchronization should not be based on Strings or boxed primitives</span><br><span class="line">bug 主要</span><br><span class="line">字符串和封箱类不应该被用作锁定对象，因为它们被合并和重用。</span><br><span class="line">101、The non-serializable super class of a &quot;Serializable&quot; class should have a no-argument constructor</span><br><span class="line">bug 次要</span><br><span class="line">序列化的类的非序列化父类应有一个无参构造器</span><br><span class="line">102、The Object.finalize() method should not be called</span><br><span class="line">bug 主要</span><br><span class="line">Object.finalize()不要人为去调用</span><br><span class="line">103、The Object.finalize() method should not be overriden</span><br><span class="line">bug 主要</span><br><span class="line">Object.finalize()不要重写</span><br><span class="line">104、The signature of &quot;finalize()&quot; should match that of &quot;Object.finalize()&quot;</span><br><span class="line">bug 主要</span><br><span class="line">Object.finalize()不要重写</span><br><span class="line">105、The value returned from a stream read should be checked</span><br><span class="line">bug 次要</span><br><span class="line">从流中读取的值应先检查再操作</span><br><span class="line">106、Thread.run() should not be called directly</span><br><span class="line">bug 主要</span><br><span class="line">调用start()</span><br><span class="line">107、Useless &quot;if(true) &#123;...&#125;&quot; and &quot;if(false)&#123;...&#125;&quot; blocks should be removed</span><br><span class="line">bug 主要</span><br><span class="line">无用的if(true)和if(false)块应移除</span><br><span class="line">108、Value-based classes should not be used for locking</span><br><span class="line">bug 主要</span><br><span class="line">基于值的类不要用于锁对象</span><br><span class="line">109、Value-based objects should not be serialized</span><br><span class="line">bug 次要</span><br><span class="line">基于值的对象不应被用于序列化</span><br><span class="line">110、Values should not be uselessly incremented</span><br><span class="line">bug 主要</span><br><span class="line">值增减后不存储是代码浪费甚至是bug</span><br><span class="line">111、Variables should not be self-assigned</span><br><span class="line">bug 主要</span><br><span class="line">变量不应该自分配如下:</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">112、Week Year (&quot;YYYY&quot;) should not be used for date formatting</span><br><span class="line">bug 主要</span><br><span class="line">日期格式化错误</span><br><span class="line">113、Zero should not be a possible denominator</span><br><span class="line">bug 严重</span><br><span class="line">零不应该是一个可能的分母</span><br><span class="line">114、Loops should not be infinite</span><br><span class="line">Bug   阻断</span><br><span class="line">循环不应该是无限的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">漏洞类型:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1、&quot;@RequestMapping&quot; methods should be &quot;public&quot;</span><br><span class="line">漏洞  阻断</span><br><span class="line">标注了RequestMapping是controller是处理web请求。既使方法修饰为private,同样也能被外部调用，因为spring通过反射调用方法,没有检查方法可视度，</span><br><span class="line">2、&quot;enum&quot; fields should not be publicly mutable</span><br><span class="line">漏洞 次要</span><br><span class="line">枚举类域不应该是public，也不应该进行set</span><br><span class="line">3、&quot;File.createTempFile&quot; should not be used to create a directory</span><br><span class="line">漏洞 严重</span><br><span class="line">File.createTempFile不应该被用来创建目录</span><br><span class="line">4、&quot;HttpServletRequest.getRequestedSessionId()&quot; should not be used</span><br><span class="line">漏洞 严重</span><br><span class="line">HttpServletRequest.getRequestedSessionId()返回客户端浏览器会话id不要用，用HttpServletRequest.getSession().getId()</span><br><span class="line">5、&quot;javax.crypto.NullCipher&quot; should not be used for anything other than testing</span><br><span class="line">漏洞 阻断</span><br><span class="line">NullCipher类提供了一种“身份密码”，不会以任何方式转换或加密明文。 因此，密文与明文相同。 所以这个类应该用于测试，从不在生产代码中。</span><br><span class="line">6、&quot;public static&quot; fields should be constant</span><br><span class="line">漏洞 次要</span><br><span class="line">public static 域应该 final</span><br><span class="line">7、Class variable fields should not have public accessibility</span><br><span class="line">漏洞 次要</span><br><span class="line">类变量域应该是private,通过set，get进行操作</span><br><span class="line">8、Classes should not be loaded dynamically</span><br><span class="line">漏洞 严重</span><br><span class="line">不应该动态加载类,动态加载的类可能包含由静态类初始化程序执行的恶意代码.</span><br><span class="line">Class clazz &#x3D; Class.forName(className);  &#x2F;&#x2F; Noncompliant</span><br><span class="line">9、Cookies should be &quot;secure&quot;</span><br><span class="line">漏洞 次要</span><br><span class="line">Cookie c &#x3D; new Cookie(SECRET, secret);  &#x2F;&#x2F; Noncompliant; cookie is not secure</span><br><span class="line">response.addCookie(c);</span><br><span class="line">正:</span><br><span class="line">Cookie c &#x3D; new Cookie(SECRET, secret);</span><br><span class="line">c.setSecure(true);</span><br><span class="line">response.addCookie(c);</span><br><span class="line">10、Credentials should not be hard-coded</span><br><span class="line">漏洞 阻断</span><br><span class="line">凭证不应该硬编码</span><br><span class="line">11、Cryptographic RSA algorithms should always incorporate OAEP (Optimal Asymmetric Encryption Padding)</span><br><span class="line">漏洞 严重</span><br><span class="line">加密RSA算法应始终包含OAEP（最优非对称加密填充）</span><br><span class="line">12、Default EJB interceptors should be declared in &quot;ejb-jar.xml&quot;</span><br><span class="line">漏洞 阻断</span><br><span class="line">默认EJB拦截器应在“ejb-jar.xml”中声明</span><br><span class="line">13、Defined filters should be used</span><br><span class="line">漏洞 严重</span><br><span class="line">web.xml文件中定义的每个过滤器都应该在&lt;filter-mapping&gt;元素中使用。 否则不会调用此类过滤器。</span><br><span class="line">14、Exceptions should not be thrown from servlet methods</span><br><span class="line">漏洞 次要</span><br><span class="line">不应该从servlet方法抛出异常</span><br><span class="line">15、HTTP referers should not be relied on</span><br><span class="line">漏洞 严重</span><br><span class="line">不应依赖于http，将这些参数值中止后可能是安全的，但绝不应根据其内容作出决定。</span><br><span class="line">如:</span><br><span class="line">String referer &#x3D; request.getHeader(&quot;referer&quot;);  &#x2F;&#x2F; Noncompliant</span><br><span class="line">if(isTrustedReferer(referer))&#123;</span><br><span class="line">&#x2F;&#x2F;..</span><br><span class="line">&#125;</span><br><span class="line">16、IP addresses should not be hardcoded</span><br><span class="line">漏洞 次要</span><br><span class="line">ip 地址不应该硬编码</span><br><span class="line">17、Member variable visibility should be specified</span><br><span class="line">漏洞 次要</span><br><span class="line">应指定成员变量的可见性</span><br><span class="line">18、Members of Spring components should be injected</span><br><span class="line">漏洞 严重</span><br><span class="line">spring组件的成员应注入，单例注入非静态成员共享会产生风险</span><br><span class="line">19、Mutable fields should not be &quot;public static&quot;</span><br><span class="line">漏洞 次要</span><br><span class="line">多变在域不应为 public static</span><br><span class="line">20、Neither DES (Data Encryption Standard) nor DESede (3DES) should be used</span><br><span class="line">漏洞 阻断</span><br><span class="line">不应使用DES（数据加密标准）和DESEDE（3DES）</span><br><span class="line">21、Only standard cryptographic algorithms should be used</span><br><span class="line">漏洞 严重</span><br><span class="line">标准的加密算法如 SHA-256, SHA-384, SHA-512等,非标准算法是危险的，可能被功能者攻破算法</span><br><span class="line">22、Pseudorandom number generators (PRNGs) should not be used in secure contexts</span><br><span class="line">漏洞 严重</span><br><span class="line">伪随机数生成器（PRNG）不应在安全上下文中使用</span><br><span class="line">23、Return values should not be ignored when they contain the operation status code</span><br><span class="line">漏洞 次要</span><br><span class="line">当函数调用的返回值包含操作状态代码时，应该测试此值以确保操作成功完成。</span><br><span class="line">24、Security constraints should be definedin</span><br><span class="line">漏洞 阻断</span><br><span class="line">应定义安全约束，当web.xml文件没有&lt;security-constraint&gt;元素时，此规则引发了一个问题</span><br><span class="line">25、SHA-1 and Message-Digest hash algorithms should not be used</span><br><span class="line">漏洞 严重</span><br><span class="line">不应该使用SHA-1和消息摘要散列算法,已证实不再安全</span><br><span class="line">26、SQL binding mechanisms should be used</span><br><span class="line">漏洞 阻断</span><br><span class="line">应该使用SQL绑定机制</span><br><span class="line">27、Struts validation forms should have unique names</span><br><span class="line">漏洞 阻断</span><br><span class="line">struts验证表单应有唯一名称</span><br><span class="line">28、Throwable.printStackTrace(...) should not be called</span><br><span class="line">漏洞 次要</span><br><span class="line">Throwable.printStackTrace(...)会打印异常信息，但会暴露敏感信息</span><br><span class="line">29、Untrusted data should not be stored in sessions</span><br><span class="line">漏洞 主要</span><br><span class="line">不受信任的数据不应存储在会话中。</span><br><span class="line">Web会话中的数据被认为在“信任边界”内。 也就是说，它被认为是值得信赖的。 但存储未经身份验证的用户未经验证的数据违反信任边界，并可能导致该数据被不当使用。</span><br><span class="line">30、Values passed to LDAP queries should be sanitized</span><br><span class="line">漏洞 严重</span><br><span class="line">传递到LDAP查询的值应该被清理</span><br><span class="line">31、Values passed to OS commands should be sanitized</span><br><span class="line">漏洞 严重</span><br><span class="line">传递给OS命令的值应该被清理</span><br><span class="line">32、Web applications should not have a &quot;main&quot; method</span><br><span class="line">漏洞 严重</span><br><span class="line">web 应用中不应有一个main方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">坏味道：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1、&quot;&#x3D;&#x3D;&quot; and &quot;!&#x3D;&quot; should not be used when &quot;equals&quot; is overridden</span><br><span class="line">坏味道   次要</span><br><span class="line">当类重写equals方法后,不应该再用&quot;&#x3D;&#x3D;&quot;与&quot;!&#x3D;&quot;进行对象比较</span><br><span class="line">2、&quot;@Deprecated&quot; code should not be used</span><br><span class="line">坏味道   次要</span><br><span class="line">弃用方代码不应再用,弃用代码意味首将会移除,应该使用替代代码</span><br><span class="line">3、&quot;@Override&quot; should be used on overriding and implementing methods</span><br><span class="line">坏味道   主要</span><br><span class="line">重写的和实现在方法要加Override标注</span><br><span class="line">4、&quot;action&quot; mappings should not have too many &quot;forward&quot; entries</span><br><span class="line">坏味道   次要</span><br><span class="line">默认   4</span><br><span class="line">action不要有太多的forward</span><br><span class="line">5、&quot;Arrays.stream&quot; should be used for primitive arrays</span><br><span class="line">坏味道   主要</span><br><span class="line">Arrays.stream用于原始流类型(IntStream, LongStream, DoubleStream)会有更好的性能</span><br><span class="line">6、&quot;catch&quot; clauses should do more than rethrow</span><br><span class="line">坏味道   次要</span><br><span class="line">只是重新抛出捕获的异常和完全放弃异常捕获效果一样，但会给维护者带来疑惑</span><br><span class="line">7、&quot;clone&quot; should not be overridden</span><br><span class="line">坏味道   阻断</span><br><span class="line">不应重写clone方法</span><br><span class="line">8、&quot;Cloneables&quot; should implement &quot;clone&quot;</span><br><span class="line">坏味道   严重</span><br><span class="line">Cloneables类应该实现clone方法</span><br><span class="line">9、&quot;collect&quot; should be used with &quot;Streams&quot; instead of &quot;list::add&quot;</span><br><span class="line">坏味道   次要</span><br><span class="line">虽然您可以使用forEach（list :: add）或使用Stream收集，但是收集是更好的选择，因为它自动线程安全并且可并行</span><br><span class="line">10、&quot;Collections.EMPTY_LIST&quot;, &quot;EMPTY_MAP&quot;, and &quot;EMPTY_SET&quot; should not be used</span><br><span class="line">坏味道   次要</span><br><span class="line">11、&quot;DateUtils.truncate&quot; from Apache Commons Lang library should not be used</span><br><span class="line">坏味道   主要</span><br><span class="line">使用Java 8中引入的Instant类来截断日期可能会比Commons Lang的DateUtils类快得多。</span><br><span class="line">12、&quot;deleteOnExit&quot; should not be used</span><br><span class="line">坏味道   主要</span><br><span class="line">不推荐使用File.deleteOnExit()</span><br><span class="line">13、&quot;entrySet()&quot; should be iterated when both the key and value are needed</span><br><span class="line">坏味道   主要</span><br><span class="line">当循环中只需要一个map的键时，迭代keySet就是有意义的。 但是，当需要键和值两者时，迭代entrySet更有效，这将允许访问键和值</span><br><span class="line">14、&quot;equals(Object obj)&quot; should be overridden along with the &quot;compareTo(T obj)&quot; method</span><br><span class="line">坏味道   次要</span><br><span class="line">“equals（Object obj）”应该与“compareTo（T obj）”方法一起被重写</span><br><span class="line">15、&quot;Exception&quot; should not be caught when not required by called methods</span><br><span class="line">坏味道   次要</span><br><span class="line">如果被调方法没有抛出“Exception”时不要捕获&quot;Exception&quot;,应捕后被调方法抛出的异常</span><br><span class="line">16、&quot;final&quot; classes should not have &quot;protected&quot; members</span><br><span class="line">坏味道   次要</span><br><span class="line">最终类意味首不可继承所以不要有受保存成员，这样没有意义</span><br><span class="line">17、&quot;finalize&quot; should not set fields to &quot;null&quot;</span><br><span class="line">坏味道   次要</span><br><span class="line">finalize不应设置域空，对垃圾收集是没必要的，还可能为垃圾收集带来额处开消</span><br><span class="line">18、&quot;for&quot; loop increment clauses should modify the loops&#39; counters</span><br><span class="line">坏味道   严重</span><br><span class="line">loop循环应该增加递增序号变量</span><br><span class="line">19、&quot;for&quot; loop stop conditions should be invariant</span><br><span class="line">坏味道   主要</span><br><span class="line">循环停止条件应为不变</span><br><span class="line">20、&quot;indexOf&quot; checks should not be for positive numbers</span><br><span class="line">坏味道   严重</span><br><span class="line">检查indexOf返回不应使用正数</span><br><span class="line">21、&quot;indexOf&quot; checks should use a start position</span><br><span class="line">坏味道   次要</span><br><span class="line">如果您需要查看一个子字符串是否位于字符串中某个特定点之外，则可以测试该子字符串与该目标点的indexOf，也可以使用该起始点参数的indexOf版本。 后者可以更清楚，因为结果是针对-1测试的，这是一个容易识别的“未找到”指标</span><br><span class="line">22、&quot;java.lang.Error&quot; should not be extended</span><br><span class="line">坏味道   主要</span><br><span class="line">java.lang.Error及其子类表示异常情况，例如OutOfMemoryError，它只能由Java虚拟机进行处理。</span><br><span class="line">23、&quot;java.nio.Files#delete&quot; should be preferred</span><br><span class="line">坏味道   主要</span><br><span class="line">Files.delete(path)道选</span><br><span class="line">24、&quot;java.time&quot; classes should be used for dates and times</span><br><span class="line">坏味道   主要</span><br><span class="line">Date 和 Calendar类非线程同步，推荐使用LocalDate</span><br><span class="line">25、&quot;Lock&quot; objects should not be &quot;synchronized&quot;</span><br><span class="line">坏味道   主要</span><br><span class="line">“锁定”对象不应“同步”</span><br><span class="line">java.util.concurrent.locks.Lock提供比同步块更强大和灵活的锁定操作，应该使用tryLock（）和unlock（）锁定和解锁这些对象</span><br><span class="line">26、&quot;main&quot; should not &quot;throw&quot; anything</span><br><span class="line">坏味道   阻断</span><br><span class="line">main方法不应该抛出异常</span><br><span class="line">27、&quot;NullPointerException&quot; should not be caught</span><br><span class="line">坏味道   主要</span><br><span class="line">空指针不应捕获处理，应该避免NullPointerException，而不是被捕获</span><br><span class="line">28、&quot;NullPointerException&quot; should not be explicitly thrown</span><br><span class="line">坏味道   主要</span><br><span class="line">“NullPointerException”不应该被显式抛出</span><br><span class="line">29、&quot;Object.finalize()&quot; should remain protected (versus public) when overriding</span><br><span class="line">坏味道   严重</span><br><span class="line">重写finalizey方法应为protected</span><br><span class="line">30、&quot;Object.wait(...)&quot; and &quot;Condition.await(...)&quot; should be called inside a &quot;while&quot; loop</span><br><span class="line">坏味道   严重</span><br><span class="line">“Object.wait（...）”和“Condition.await（...）”应该在“while”循环内调用</span><br><span class="line">31、&quot;Object.wait(...)&quot; should never be called on objects that implement &quot;java.util.concurrent.locks.Condition&quot;</span><br><span class="line">坏味道   主要</span><br><span class="line">不应该在实现“java.util.concurrent.locks.Condition”的对象上调用“Object.wait（...）”</span><br><span class="line">32、&quot;Optional&quot; should not be used for parameters</span><br><span class="line">坏味道   主要</span><br><span class="line">Optional不要被用作参数</span><br><span class="line">33、&quot;Preconditions&quot; and logging arguments should not require evaluation</span><br><span class="line">坏味道   主要</span><br><span class="line">将连接的字符串传递到日志记录方法也可能导致不必要的性能消耗，因为每次调用该方法时将执行级联，无论日志级别是否足够低以显示消息</span><br><span class="line">34、&quot;private&quot; methods called only by inner classes should be moved to those classes</span><br><span class="line">坏味道   次要</span><br><span class="line">只被内部类调用的方法，应该在内部类内部</span><br><span class="line">35、&quot;private&quot; methods that don&#39;t access instance data should be &quot;static&quot;</span><br><span class="line">坏味道   次要</span><br><span class="line">不访问实例数据的“私有”方法应该是“静态”</span><br><span class="line">36、&quot;readObject&quot; should not be &quot;synchronized&quot;</span><br><span class="line">坏味道   主要</span><br><span class="line">“readObject”不应该被“同步”</span><br><span class="line">37、&quot;readResolve&quot; methods should be inheritable</span><br><span class="line">坏味道   严重</span><br><span class="line">“readResolve”方法应该是可继承的</span><br><span class="line">38、&quot;ResultSet.isLast()&quot; should not be used</span><br><span class="line">坏味道   主要</span><br><span class="line">ResultSet.isLast()不应用</span><br><span class="line">39、&quot;Serializable&quot; classes should have a version id</span><br><span class="line">坏味道   严重</span><br><span class="line">“Serializable”类应该有一个版本号</span><br><span class="line">40、&quot;Serializable&quot; inner classes of &quot;Serializable&quot; classes should be static</span><br><span class="line">坏味道   次要</span><br><span class="line">实现序列化的内部类应该是静态的</span><br><span class="line">41、&quot;static&quot; members should be accessed statically</span><br><span class="line">坏味道   主要</span><br><span class="line">“静态”成员应类访问</span><br><span class="line">42、&quot;Stream.anyMatch()&quot; should be preferred</span><br><span class="line">坏味道   次要</span><br><span class="line">“Stream.anyMatch（）”应该是首选的</span><br><span class="line">43、&quot;switch case&quot; clauses should not have too many lines of code</span><br><span class="line">坏味道   主要</span><br><span class="line">默认  5</span><br><span class="line">“switch case”子句不应该有太多的代码行</span><br><span class="line">44、&quot;switch&quot; statements should end with &quot;default&quot; clauses</span><br><span class="line">坏味道   严重</span><br><span class="line">“switch”语句应以“default”子句结尾</span><br><span class="line">45、&quot;switch&quot; statements should have at least 3 &quot;case&quot; clauses</span><br><span class="line">坏味道   次要</span><br><span class="line">“switch”语句应具有至少3个“case”子句，可以用if替代</span><br><span class="line">46、&quot;switch&quot; statements should not contain non-case labels</span><br><span class="line">坏味道   阻断</span><br><span class="line">switch语句不用包含非case标签</span><br><span class="line">47、&quot;switch&quot; statements should not have too many &quot;case&quot; clauses</span><br><span class="line">坏味道   主要</span><br><span class="line">默认 30</span><br><span class="line">switch语句不应包含太多case语句</span><br><span class="line">48、&quot;Thread.sleep&quot; should not be used in tests</span><br><span class="line">坏味道   主要</span><br><span class="line">“Thread.sleep”不应该在测试中使用</span><br><span class="line">49、&quot;ThreadLocal.withInitial&quot; should be preferred</span><br><span class="line">坏味道   次要</span><br><span class="line">“ThreadLocal.withInitial”应该是首选</span><br><span class="line">ThreadLocal&lt;List&lt;String&gt;&gt; myThreadLocal &#x3D; ThreadLocal.withInitial(ArrayList::new);</span><br><span class="line">50、&quot;Threads&quot; should not be used where &quot;Runnables&quot; are expected</span><br><span class="line">坏味道   主要</span><br><span class="line">Noncompliant Code Example</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Thread r &#x3D;new Thread() &#123;</span><br><span class="line">int p;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">while(true)</span><br><span class="line">System.out.println(&quot;a&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">new Thread(r).start();  &#x2F;&#x2F; Noncompliant</span><br><span class="line">Compliant Solution</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Runnable r &#x3D;new Runnable() &#123;</span><br><span class="line">int p;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">while(true)</span><br><span class="line">System.out.println(&quot;a&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">new Thread(r).start();</span><br><span class="line">51、&quot;throws&quot; declarations should not be superfluous</span><br><span class="line">坏味道   次要</span><br><span class="line">“抛出”声明不应该是多余的</span><br><span class="line">52、&quot;toString()&quot; should never be called on a String object</span><br><span class="line">坏味道   次要</span><br><span class="line">不应该在String对象上调用“toString（）”</span><br><span class="line">53、&quot;URL.hashCode&quot; and &quot;URL.equals&quot; should be avoided</span><br><span class="line">坏味道   主要</span><br><span class="line">应避免使用“URL.hashCode”和“URL.equals”</span><br><span class="line">54、&quot;writeObject&quot; should not be the only &quot;synchronized&quot; code in a class</span><br><span class="line">坏味道   主要</span><br><span class="line">“writeObject”不应该是类中唯一的“同步”代码</span><br><span class="line">55、 @FunctionalInterface annotation should be used to flag Single Abstract Method interfaces</span><br><span class="line">坏味道   严重</span><br><span class="line">一个只有一个抽象方法的接口应加FunctionalInterface注释</span><br><span class="line">56、A &quot;while&quot; loop should be used instead of a &quot;for&quot; loop</span><br><span class="line">坏味道   次要</span><br><span class="line">当在for循环中仅定义条件表达式，并且缺少初始化和增量表达式时，应使用while循环来增加可读性</span><br><span class="line">57、A close curly brace should be located at the beginning of a line</span><br><span class="line">坏味道   次要</span><br><span class="line">共享编码约定使得团队有可能有效地进行协作。 这个规则使得强制要在行的开头放置一个大括号。</span><br><span class="line">58、A field should not duplicate the name of its containing class</span><br><span class="line">坏味道   主要</span><br><span class="line">字段不应该重复其包含的类的名称</span><br><span class="line">59、Abbreviation As Word In Name</span><br><span class="line">坏味道   主要</span><br><span class="line">检查验证标识符名称中的缩写（连续大写字母）长度，还允许执行骆驼案例命名</span><br><span class="line">60、Abstract Class Name</span><br><span class="line">坏味道   主要</span><br><span class="line">检查抽象类名是否符合指定的格式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ignoreName  </span><br><span class="line">Controls whether to ignore checking the name. Realistically only useful if using the check to identify that match name and do not have the abstract modifier name. Default is false.</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">ignoreModifier</span><br><span class="line">Controls whether to ignore checking for the abstract modifier on classes that match the name. Default is false.</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">format  </span><br><span class="line">Regular expression</span><br><span class="line">默认值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">61、Abstract class names should comply with a naming convention</span><br><span class="line">坏味道   次要</span><br><span class="line">抽象类名称应符合命名约定</span><br><span class="line"></span><br><span class="line">     Regular expression used to check the abstract class names against.</span><br><span class="line">     默认值</span><br><span class="line">     ^Abstract[A-Z][a-zA-Z0-9]*$</span><br><span class="line">62、Abstract classes without fields should be converted to interfaces</span><br><span class="line">坏味道   次要</span><br><span class="line">没有字段的抽象类应该转换为接口</span><br><span class="line">63、Abstract methods should not be redundant</span><br><span class="line">坏味道   次要</span><br><span class="line">抽象方法不应该是多余的</span><br><span class="line">64、An abstract class should have both abstract and concrete methods</span><br><span class="line">坏味道   次要</span><br><span class="line">抽象类应该有抽象和具体的方法</span><br><span class="line">65、An open curly brace should be located at the beginning of a line</span><br><span class="line">坏味道   次要</span><br><span class="line">开放的大括号应位于一行的开头</span><br><span class="line">66、An open curly brace should be located at the end of a line</span><br><span class="line">坏味道   次要</span><br><span class="line">开放的大括号应位于一行的末尾</span><br><span class="line">67、Annotation arguments should appear in the order in which they were declared</span><br><span class="line">坏味道   次要</span><br><span class="line">注释参数应按其声明顺序显示</span><br><span class="line">68、Annotation Location</span><br><span class="line">坏味道   主要</span><br><span class="line">注释位置</span><br><span class="line">allowSamelineSingleParameterlessAnnotation  </span><br><span class="line">To allow single parameterless annotation to be located on the same line as target element.</span><br><span class="line">默认值</span><br><span class="line">true</span><br><span class="line">allowSamelineParameterizedAnnotation</span><br><span class="line">To allow parameterized annotation to be located on the same line as target element.</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">allowSamelineMultipleAnnotations</span><br><span class="line">To allow annotation to be located on the same line as target element.</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">tokens  </span><br><span class="line">tokens to check</span><br><span class="line">默认值</span><br><span class="line">CLASS_DEF,INTERFACE_DEF,ENUM_DEF,METHOD_DEF,CTOR_DEF,VARIABLE_DEF</span><br><span class="line">69、Annotation repetitions should not be wrapped</span><br><span class="line">坏味道   次要</span><br><span class="line">注释重复不应包装</span><br><span class="line">70、Annotation Use Style</span><br><span class="line">坏味道   主要</span><br><span class="line"></span><br><span class="line">trailingArrayComma</span><br><span class="line">Defines the policy for trailing comma in arrays. Default is never.</span><br><span class="line">closingParens  </span><br><span class="line">Defines the policy for ending parenthesis. Default is never.</span><br><span class="line">elementStyle  </span><br><span class="line">Defines the annotation element styles. Default value is compact_no_array.</span><br><span class="line">71、Anon Inner Length</span><br><span class="line">坏味道   主要</span><br><span class="line">检查长匿名内部类。</span><br><span class="line">max</span><br><span class="line">maximum allowable number of lines. Default is 20.</span><br><span class="line">72、Anonymous inner classes containing only one method should become lambdas</span><br><span class="line">坏味道   主要</span><br><span class="line">只有一个方法的匿名内部类应该变成lambdas</span><br><span class="line">jdk8以下自动禁用</span><br><span class="line">73、Array designators &quot;[]&quot; should be located after the type in method signatures</span><br><span class="line">坏味道   次要</span><br><span class="line">数组代号“[]”应位于方法签名类型之后</span><br><span class="line">74、Array designators &quot;[]&quot; should be on the type, not the variable</span><br><span class="line">坏味道   次要</span><br><span class="line">数组代号“[]”应位于类型之后而不是变量之后</span><br><span class="line">75、Array Trailing Comma</span><br><span class="line">坏味道   主要</span><br><span class="line">检查数组初始化是否包含逗号</span><br><span class="line">76、Array Type Style</span><br><span class="line">坏味道   次要</span><br><span class="line">数组类型样式</span><br><span class="line">javaStyle  </span><br><span class="line">Controls whether to enforce Java style (true) or C style (false). Default is true.</span><br><span class="line">77、Arrays should not be created for varargs parameters</span><br><span class="line">坏味道   次要</span><br><span class="line">不应为varargs参数创建数组</span><br><span class="line">78、Artifact ids should follow a naming convention</span><br><span class="line">坏味道   次要</span><br><span class="line">共享命名约定允许团队有效协作。 当pom的artifactId与提供的正则表达式不匹配时，此规则引发了一个问题</span><br><span class="line"></span><br><span class="line">regex</span><br><span class="line">The regular expression the &quot;artifactId&quot; should match</span><br><span class="line">默认值</span><br><span class="line">[a-z][a-z-0-9]+</span><br><span class="line">79、Assertions should be complete</span><br><span class="line">坏味道   阻断</span><br><span class="line">断言应该是完整的</span><br><span class="line">80、Assignments should not be made from within sub-expressions</span><br><span class="line">坏味道   主要</span><br><span class="line">不应在子表达式中作出赋值操作当赋值变量没有用到</span><br><span class="line">81、At-clause Order</span><br><span class="line">坏味道   主要</span><br><span class="line">检查从句顺序</span><br><span class="line">tagOrder</span><br><span class="line">allows to specify the order by tags.</span><br><span class="line">默认值</span><br><span class="line">@author,@version,@param,@return,@throws,@exception,@see,@since,@serial,@serialField,@serialData,@deprecated</span><br><span class="line">target  </span><br><span class="line">allows to specify targets to check at-clauses.</span><br><span class="line">82、Avoid Escaped Unicode Characters</span><br><span class="line">坏味道   主要</span><br><span class="line">避免转义的Unicode字符</span><br><span class="line"></span><br><span class="line">allowIfAllCharactersEscaped</span><br><span class="line">Allow if all characters in literal are escaped.</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">allowNonPrintableEscapes</span><br><span class="line">Allow non-printable escapes.</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">allowByTailComment</span><br><span class="line">Allow use escapes if trail comment is present.</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">allowEscapesForControlCharacters</span><br><span class="line">Allow use escapes for non-printable(control) characters.</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">83、Avoid Inline Conditionals</span><br><span class="line">坏味道   次要</span><br><span class="line">避免内联条件</span><br><span class="line">84、Avoid Nested Blocks</span><br><span class="line">坏味道   主要</span><br><span class="line">避免嵌套块</span><br><span class="line">allowInSwitchCase</span><br><span class="line">Allow nested blocks in case statements. Default is false.</span><br><span class="line">85、Avoid Star Import</span><br><span class="line">坏味道   次要</span><br><span class="line">检查发现使用*符号的导入语句</span><br><span class="line">excludes  </span><br><span class="line">packages where star imports are allowed. Note that this property is not recursive, subpackages of excluded packages are not automatically excluded.</span><br><span class="line">allowStaticMemberImports</span><br><span class="line">whether to allow starred static member imports like &lt;code&gt;import static org.junit.Assert.*;&lt;&#x2F;code&gt;. Default is false.</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">allowClassImports</span><br><span class="line">whether to allow starred class imports like &lt;code&gt;import java.util.*;&lt;&#x2F;code&gt;. Default is false.</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">86、Avoid Static Import</span><br><span class="line">坏味道   次要</span><br><span class="line">避免静态导入</span><br><span class="line">87、Boolean checks should not be inverted</span><br><span class="line">坏味道   次要</span><br><span class="line">布尔检查不应该被反转</span><br><span class="line">Noncompliant Code Example</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if ( !(a &#x3D;&#x3D; 2)) &#123; ...&#125;  &#x2F;&#x2F; Noncompliant</span><br><span class="line">boolean b &#x3D; !(i &lt; 10);  &#x2F;&#x2F; Noncompliant</span><br><span class="line">Compliant Solution</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (a !&#x3D; 2) &#123; ...&#125;</span><br><span class="line">boolean b &#x3D; (i &gt;&#x3D; 10);</span><br><span class="line">88、Boolean Expression Complexity</span><br><span class="line">坏味道   主要</span><br><span class="line">将嵌套布尔运算符（&amp;&amp;，||和^）限制为指定的深度（默认&#x3D; 3）。</span><br><span class="line"></span><br><span class="line">max</span><br><span class="line">the maximum allowed number of boolean operations in one expression. Default is 3.</span><br><span class="line">默认值</span><br><span class="line">3</span><br><span class="line">tokens  </span><br><span class="line">tokens to check. Default is LAND,BAND,LOR,BOR,BXOR.</span><br><span class="line">默认值</span><br><span class="line">LAND,BAND,LOR,BOR,BXOR</span><br><span class="line">89、Boolean expressions should not be gratuitous</span><br><span class="line">坏味道   主要</span><br><span class="line">如果boolean表达式的值是已定的，那么boolean表达式是没有必要的可以移除</span><br><span class="line">90、Boolean literals should not be redundant</span><br><span class="line">坏味道   次要</span><br><span class="line">boolean不需再与true,false比较作为boolean表达式</span><br><span class="line">91、Branches should have sufficient coverage by tests</span><br><span class="line">坏味道   主要</span><br><span class="line">分支应有足够的测试覆盖</span><br><span class="line"></span><br><span class="line">minimumBranchCoverageRatio</span><br><span class="line">默认值</span><br><span class="line">65</span><br><span class="line">92、Case insensitive string comparisons should be made without intermediate upper or lower casing</span><br><span class="line">坏味道   次要</span><br><span class="line">使用toLowerCase（）或toUpperCase（）来使不区分大小写的比较无效，因为它需要创建临时的中间String对象。</span><br><span class="line">93、Catch Parameter Name</span><br><span class="line">坏味道   主要</span><br><span class="line">检查catch参数名是否符合format属性指定的格式</span><br><span class="line"></span><br><span class="line">format  </span><br><span class="line">Specifies valid identifiers. Default is ^(e|t|ex|[a-z][a-z][a-zA-Z]+)$</span><br><span class="line">默认值</span><br><span class="line">^(e|t|ex|[a-z][a-z][a-zA-Z]+)$</span><br><span class="line">94、Catches should be combined</span><br><span class="line">坏味道   次要</span><br><span class="line">由于Java 7可以一次捕获多个异常。 因此，当多个catch块具有相同的代码时，它们应该被组合以便更好的可读性，sonar.java.source低于7时，此规则将自动禁用</span><br><span class="line">95、Checked exceptions should not be thrown</span><br><span class="line">坏味道   主要</span><br><span class="line">检查的异常不应该被抛出，要处理</span><br><span class="line">96、Child class fields should not shadow parent class fields</span><br><span class="line">坏味道   阻断</span><br><span class="line">子类字段不应该private父类的非private字段</span><br><span class="line">97、Class Data Abstraction Coupling</span><br><span class="line">坏味道   主要</span><br><span class="line">度量衡量给定类中其他类的实例化数。</span><br><span class="line"></span><br><span class="line">max</span><br><span class="line">the maximum threshold allowed. Default is 7.</span><br><span class="line">excludedClasses</span><br><span class="line">User-configured class names to ignore.</span><br><span class="line">excludeClassesRegexps</span><br><span class="line">User-configured regular expressions to ignore classes</span><br><span class="line">excludedPackages</span><br><span class="line">User-configured packages to ignore</span><br><span class="line">98、Class Fan Out Complexity</span><br><span class="line">坏味道   主要</span><br><span class="line">类的依赖类数量</span><br><span class="line"></span><br><span class="line">max</span><br><span class="line">the maximum threshold allowed. Default is 20.</span><br><span class="line">excludedClasses</span><br><span class="line">User-configured class names to ignore</span><br><span class="line">excludeClassesRegexps</span><br><span class="line">User-configured regular expressions to ignore classes</span><br><span class="line">excludedPackages</span><br><span class="line">User-configured packages to ignore</span><br><span class="line">99、Class names should comply with a naming convention</span><br><span class="line">坏味道   次要</span><br><span class="line">类名应符合命名约定</span><br><span class="line"></span><br><span class="line">format  </span><br><span class="line">Regular expression used to check the class names against.</span><br><span class="line">默认值</span><br><span class="line">^[A-Z][a-zA-Z0-9]*$</span><br><span class="line">100、Class names should not shadow interfaces or superclasses</span><br><span class="line">坏味道   严重</span><br><span class="line">类名称不应该影响接口或超类（相同）</span><br><span class="line">101、Class Type(Generic) Parameter Name</span><br><span class="line">坏味道   主要</span><br><span class="line">泛型参数名称符合指定的格式</span><br><span class="line"></span><br><span class="line">format  </span><br><span class="line">Regular expression</span><br><span class="line">默认值</span><br><span class="line">^[A-Z]$</span><br><span class="line">102、Classes and enums with private members should have a constructor</span><br><span class="line">坏味道   主要</span><br><span class="line">有私有成员的类和枚举应该有一个构造函数</span><br><span class="line">103、Classes and methods that rely on the default system encoding should not be used</span><br><span class="line">坏味道   次要</span><br><span class="line">不应使用依赖于默认系统编码的类和方法</span><br><span class="line">104、Classes from &quot;sun.*&quot; packages should not be used</span><br><span class="line">坏味道   主要</span><br><span class="line">不得使用“sun.*”软件包的类,sun类*或com.sun *包被视为实现细节，不属于Java API</span><br><span class="line"></span><br><span class="line">Exclude  </span><br><span class="line">Comma separated list of Sun packages to be ignored by this rule. Example: com.sun.jna,sun.misc</span><br><span class="line">105、Classes named like &quot;Exception&quot; should extend &quot;Exception&quot; or a subclass</span><br><span class="line">坏味道   主要</span><br><span class="line">名为“异常”的类应该扩展“异常”或者一个子类</span><br><span class="line">106、Classes should not access their own subclasses during initialization</span><br><span class="line">坏味道   严重</span><br><span class="line">类在初始化期间不应访问自己的子类</span><br><span class="line">107、Classes should not be coupled to too many other classes (Single Responsibility Principle)</span><br><span class="line">坏味道   主要</span><br><span class="line">类不应与太多其他类（单一责任原则）相耦合（依赖）</span><br><span class="line"></span><br><span class="line">max</span><br><span class="line">Maximum number of classes a single class is allowed to depend upon</span><br><span class="line">默认值</span><br><span class="line">20</span><br><span class="line">108、Classes should not be empty</span><br><span class="line">坏味道   次要</span><br><span class="line">空类没意义，作为公共扩展点可以作为接口</span><br><span class="line">109、Classes should not be too complex</span><br><span class="line">坏味道   严重  废弃</span><br><span class="line">类不应太复杂</span><br><span class="line"></span><br><span class="line">max</span><br><span class="line">Maximum complexity allowed.</span><br><span class="line">默认值</span><br><span class="line">200</span><br><span class="line">110、Classes should not have too many &quot;static&quot; imports</span><br><span class="line">坏味道   主要</span><br><span class="line">静态导入类允许您使用其公共静态成员，而不必使用类名。 这可以很方便，但如果静态导入太多的类，你的代码可能会变得混乱，很难维护</span><br><span class="line"></span><br><span class="line">threshold  </span><br><span class="line">The maximum number of static imports allowed</span><br><span class="line">默认值</span><br><span class="line">4</span><br><span class="line">111、Classes should not have too many fields</span><br><span class="line">坏味道   主要</span><br><span class="line">类不应有太多字段</span><br><span class="line">countNonpublicFields</span><br><span class="line">Whether or not to include non-public fields in the count</span><br><span class="line">默认值</span><br><span class="line">true</span><br><span class="line">maximumFieldThreshold</span><br><span class="line">The maximum number of fields</span><br><span class="line">默认值</span><br><span class="line">20</span><br><span class="line">112、Classes should not have too many methods</span><br><span class="line">坏味道   主要</span><br><span class="line">类不应该有太多方法</span><br><span class="line"></span><br><span class="line">countNonpublicMethods</span><br><span class="line">Whether or not to include non-public methods in the count.</span><br><span class="line">默认值</span><br><span class="line">true</span><br><span class="line">maximumMethodThreshold</span><br><span class="line">The maximum number of methods authorized in a class.</span><br><span class="line">默认值</span><br><span class="line">35</span><br><span class="line">113、Classes that override &quot;clone&quot; should be &quot;Cloneable&quot; and call &quot;super.clone()&quot;</span><br><span class="line">坏味道   次要</span><br><span class="line">覆盖“克隆”的类应该是“可克隆”，并调用“super.clone（）”</span><br><span class="line">114、Classes with only &quot;static&quot; methods should not be instantiated</span><br><span class="line">坏味道   主要</span><br><span class="line">只有“静态”方法的类不应该被实例化</span><br><span class="line">115、Classes without &quot;public&quot; constructors should be &quot;final&quot;</span><br><span class="line">坏味道   次要</span><br><span class="line">只有私有构造函数的类应该被标记为final，以防止任何错误的扩展尝试。</span><br><span class="line">116、Close curly brace and the next &quot;else&quot;, &quot;catch&quot; and &quot;finally&quot; keywords should be located on the same line</span><br><span class="line">坏味道   次要</span><br><span class="line">关闭大括号，下一个“else”，“catch”和“finally”关键字应位于同一行</span><br><span class="line">117、Close curly brace and the next &quot;else&quot;, &quot;catch&quot; and &quot;finally&quot; keywords should be on two different lines</span><br><span class="line">坏味道   次要</span><br><span class="line">关闭大括号和下一个“else”，“catch”和“finally”关键字应该在两个不同的行</span><br><span class="line">118、Cognitive Complexity of methods should not be too high</span><br><span class="line">坏味道   严重</span><br><span class="line">认知复杂度是衡量一种方法的控制流程难以理解的度量。 认知复杂性较高的方法难以维持。</span><br><span class="line">Threshold</span><br><span class="line">The maximum authorized complexity.</span><br><span class="line">默认值</span><br><span class="line">15</span><br><span class="line">119、Collapsible &quot;if&quot; statements should be merged</span><br><span class="line">坏味道   主要</span><br><span class="line">可合并的“if”语句应该合并</span><br><span class="line">120、Collection methods with O(n) performance should be used carefully</span><br><span class="line">坏味道   次要</span><br><span class="line">应仔细使用具有O（n）性能的集合方法</span><br><span class="line">121、Collection.isEmpty() should be used to test for emptiness</span><br><span class="line">坏味道   次要</span><br><span class="line">应该使用Collection.isEmpty（）来测试空集合</span><br><span class="line">122、Comment pattern matcher</span><br><span class="line">坏味道   次要</span><br><span class="line">该规则允许在TODO，NOPMD，...之外的任何类型的内容中找到任何类型的模式，NOSONAR除外</span><br><span class="line">123、Comments Indentation</span><br><span class="line">坏味道   次要</span><br><span class="line">注释缩进</span><br><span class="line"></span><br><span class="line">tokens  </span><br><span class="line">tokens to check</span><br><span class="line">默认值</span><br><span class="line">SINGLE_LINE_COMMENT,BLOCK_COMMENT_BEGIN</span><br><span class="line">124、Comments should not be located at the end of lines of code</span><br><span class="line">坏味道   次要</span><br><span class="line">注释不应位于代码行的末尾</span><br><span class="line"></span><br><span class="line">legalTrailingCommentPattern</span><br><span class="line">Description Pattern for text of trailing comments that are allowed. By default, comments containing only one word.</span><br><span class="line">默认值</span><br><span class="line">^\s*+[^\s]++$</span><br><span class="line">125、Comparators should be &quot;Serializable&quot;</span><br><span class="line">坏味道   严重</span><br><span class="line">Comparators should be &quot;Serializable&quot;</span><br><span class="line">126、Conditionals should start on new lines</span><br><span class="line">坏味道   严重</span><br><span class="line">条件表达式应该起始新行</span><br><span class="line">127、Constant Name</span><br><span class="line">坏味道   次要</span><br><span class="line">检查常数名称是否符合指定的格式</span><br><span class="line">applyToPackage</span><br><span class="line">Controls whether to apply the check to package-private member</span><br><span class="line">默认值</span><br><span class="line">true</span><br><span class="line">format  </span><br><span class="line">Regular expression</span><br><span class="line">默认值</span><br><span class="line">^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$</span><br><span class="line">applyToPublic  </span><br><span class="line">Controls whether to apply the check to public member</span><br><span class="line">默认值</span><br><span class="line">true</span><br><span class="line">applyToProtected</span><br><span class="line">Controls whether to apply the check to protected member</span><br><span class="line">默认值</span><br><span class="line">true</span><br><span class="line">applyToPrivate</span><br><span class="line">Controls whether to apply the check to private member</span><br><span class="line">默认值</span><br><span class="line">true</span><br><span class="line">128、Constant names should comply with a naming convention</span><br><span class="line">坏味道   严重</span><br><span class="line">常数名称应符合命名约定</span><br><span class="line"></span><br><span class="line">format  </span><br><span class="line">Regular expression used to check the constant names against.</span><br><span class="line">默认值</span><br><span class="line">^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$</span><br><span class="line">129、Constants should not be defined in interfaces</span><br><span class="line">坏味道   严重</span><br><span class="line">常量不应在接口中定义</span><br><span class="line">130、Constructors should not be used to instantiate &quot;String&quot; and primitive-wrapper classes</span><br><span class="line">坏味道   主要</span><br><span class="line">构造函数不应用于实例化“String”和原始包装类</span><br><span class="line">131、Constructors should only call non-overridable methods</span><br><span class="line">坏味道   严重</span><br><span class="line">构造函数只应该调用不可覆盖的方法</span><br><span class="line">132、Control flow statements &quot;if&quot;, &quot;for&quot;, &quot;while&quot;, &quot;switch&quot; and &quot;try&quot; should not be nested too deeply</span><br><span class="line">坏味道   严重</span><br><span class="line">控制流程语句“if”，“for”，“while”，“switch”和“try”不能嵌套太深</span><br><span class="line"></span><br><span class="line">max</span><br><span class="line">Maximum allowed control flow statement nesting depth.</span><br><span class="line">默认值</span><br><span class="line">3</span><br><span class="line">133、Control structures should use curly braces</span><br><span class="line">坏味道   严重</span><br><span class="line">控制结构应使用花括号</span><br><span class="line">134、Covariant Equals</span><br><span class="line">坏味道   严重</span><br><span class="line">检查一个类是否定义了一个协变方法equals，那么它定义了方法equals（java.lang.Object）</span><br><span class="line">135、Custom Import Order</span><br><span class="line">坏味道   主要</span><br><span class="line">检查导入声明组按照用户指定的顺序显示。 如果有导入，但是在组态中未指定其组，则导入应放在导入列表的末尾。</span><br><span class="line">thirdPartyPackageRegExp</span><br><span class="line">RegExp for THIRDPARTY_PACKAGE group imports.</span><br><span class="line">默认值</span><br><span class="line">^$</span><br><span class="line">separateLineBetweenGroups</span><br><span class="line">Force empty line separator between import groups.</span><br><span class="line">默认值</span><br><span class="line">true</span><br><span class="line">sortImportsInGroupAlphabetically</span><br><span class="line">Force grouping alphabetically.</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">specialImportsRegExp</span><br><span class="line">RegExp for SPECIAL_IMPORTS group imports.</span><br><span class="line">默认值</span><br><span class="line">^$</span><br><span class="line">customImportOrderRules</span><br><span class="line">List of order declaration customizing by user.</span><br><span class="line">standardPackageRegExp</span><br><span class="line">RegExp for STANDARD_JAVA_PACKAGE group imports.</span><br><span class="line">默认值</span><br><span class="line">java|javax</span><br><span class="line">136、Cyclomatic Complexity</span><br><span class="line">坏味道   主要</span><br><span class="line">检查针对特定限制的方法的循环复杂性</span><br><span class="line"></span><br><span class="line">switchBlockAsSingleDecisionPoint</span><br><span class="line">whether to treat the whole switch block as a single decision point</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">max</span><br><span class="line">the maximum threshold allowed.</span><br><span class="line">默认值</span><br><span class="line">10</span><br><span class="line">tokens  </span><br><span class="line">tokens to check</span><br><span class="line">默认值</span><br><span class="line">LITERAL_WHILE,LITERAL_DO,LITERAL_FOR,LITERAL_IF,LITERAL_SWITCH,LITERAL_CASE,LITERAL_CATCH,QUESTION,LAND,LOR</span><br><span class="line">137、Dead stores should be removed</span><br><span class="line">坏味道   主要</span><br><span class="line">没用的存储应该除移</span><br><span class="line">138、Declaration Order</span><br><span class="line">坏味道   提示</span><br><span class="line">声名的顺序</span><br><span class="line">ignoreModifiers</span><br><span class="line">Whether to ignore modifiers</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">ignoreConstructors</span><br><span class="line">Whether to ignore constructors</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">139、Declarations should use Java collection interfaces such as &quot;List&quot; rather than specific implementation classes such as &quot;LinkedList&quot;</span><br><span class="line">坏味道   次要</span><br><span class="line">声明应该使用Java集合接口，例如“List”，而不是特定的实现类，如“LinkedList”</span><br><span class="line">140、Default annotation parameter values should not be passed as arguments</span><br><span class="line">坏味道   次要</span><br><span class="line">默认注解参数值不应作为参数传递</span><br><span class="line">141、Default Comes Last</span><br><span class="line">坏味道   主要</span><br><span class="line">检查在switch语句中的所有情况之后的默认值。</span><br><span class="line"></span><br><span class="line">skipIfLastAndSharedWithCase</span><br><span class="line">whether to allow default along with case if they are not last</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">142、Deprecated &quot;$&#123;pom&#125;&quot; properties should not be used</span><br><span class="line">坏味道   次要</span><br><span class="line">不应使用不推荐使用的“$ &#123;pom&#125;”属性</span><br><span class="line">143、Deprecated code should be removed</span><br><span class="line">坏味道   提示</span><br><span class="line">应删除弃用的代码</span><br><span class="line">144、Deprecated elements should have both the annotation and the Javadoc tag</span><br><span class="line">坏味道   主要</span><br><span class="line">弃用元素应有注解和doc标签</span><br><span class="line">145、Descendant Token</span><br><span class="line">坏味道   次要</span><br><span class="line">检查其他令牌下的限制令牌</span><br><span class="line">maximumMessage</span><br><span class="line">error message when the maximum count is exceeded</span><br><span class="line">maximumDepth  </span><br><span class="line">the maximum depth for descendant counts</span><br><span class="line">limitedTokens  </span><br><span class="line">set of tokens with limited occurrences as descendants</span><br><span class="line">maximumNumber  </span><br><span class="line">a maximum count for descendants</span><br><span class="line">minimumMessage</span><br><span class="line">error message when the maximum count is exceeded</span><br><span class="line">minimumNumber  </span><br><span class="line">a minimum count for descendants</span><br><span class="line">minimumDepth  </span><br><span class="line">the minimum depth for descendant counts</span><br><span class="line">sumTokenCounts</span><br><span class="line">whether the number of tokens found should be calculated from the sum of the individual token counts</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">146、Design For Extension</span><br><span class="line">坏味道   次要</span><br><span class="line">扩展设计</span><br><span class="line"></span><br><span class="line">ignoredAnnotations</span><br><span class="line">Annotations which allow the check to skip the method from validation.</span><br><span class="line">默认值</span><br><span class="line">Test,Before,After,BeforeClass,AfterClass</span><br><span class="line">147、EJB interceptor exclusions should be declared as annotations</span><br><span class="line">坏味道   阻断</span><br><span class="line">EJB interceptor exclusions应该以注解的形式使用</span><br><span class="line">148、Empty arrays and collections should be returned instead of null</span><br><span class="line">坏味道   主要</span><br><span class="line">应该返回空数组和集合，而不是null</span><br><span class="line">149、Empty Block</span><br><span class="line">坏味道   主要</span><br><span class="line">Checks for empty blocks</span><br><span class="line">tokens</span><br><span class="line">blocks to check</span><br><span class="line">默认值</span><br><span class="line">LITERAL_WHILE,LITERAL_TRY,LITERAL_FINALLY,LITERAL_DO,LITERAL_IF,LITERAL_ELSE,LITERAL_FOR,INSTANCE_INIT,STATIC_INIT,LITERAL_SWITCH,LITERAL_SYNCHRONIZED</span><br><span class="line">option  </span><br><span class="line">policy on block contents</span><br><span class="line">默认值</span><br><span class="line">stmt</span><br><span class="line">150、Empty catch block</span><br><span class="line">坏味道   主要</span><br><span class="line">检查空的catch块。 有两个选项可以使验证更加精确（默认情况下，检查允许空的catch块和任何注释）</span><br><span class="line"></span><br><span class="line">exceptionVariableName</span><br><span class="line">Format of skipping exception&#39;&#39;s variable name.</span><br><span class="line">默认值</span><br><span class="line">^$</span><br><span class="line">commentFormat  </span><br><span class="line">Format of comment.</span><br><span class="line">默认值</span><br><span class="line">.*</span><br><span class="line">151、Empty For Initializer Pad</span><br><span class="line">坏味道   次要</span><br><span class="line">检查初始化程序为空的填充; 那是空的是否需要一个空的初始化程序，或者禁止这样的空格。 示例：for（; i &lt;j; i ++，j--）</span><br><span class="line"></span><br><span class="line">option  </span><br><span class="line">policy on how to pad an empty for iterator</span><br><span class="line">152、Empty For Iterator Pad</span><br><span class="line">坏味道   次要</span><br><span class="line">检查一个空的填充迭代器; 那就是空格是否需要一个空的迭代器，否则这样的空格是被禁止的。 示例：for（Iterator foo &#x3D; very.long.line.iterator（）; foo.hasNext（）;）</span><br><span class="line"></span><br><span class="line">option  </span><br><span class="line">policy on how to pad an empty for iterator</span><br><span class="line">153、Empty Line Separator</span><br><span class="line">坏味道   主要</span><br><span class="line">在标题，包，所有导入声明，字段，构造函数，方法，嵌套类，静态初始化器和实例初始化器之后检查空行分隔符</span><br><span class="line">allowNoEmptyLineBetweenFields</span><br><span class="line">Allow no empty line between fields</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">allowMultipleEmptyLines</span><br><span class="line">Allows multiple empty lines between class members.</span><br><span class="line">默认值</span><br><span class="line">true</span><br><span class="line">tokens  </span><br><span class="line">assignments to check</span><br><span class="line">默认值</span><br><span class="line">PACKAGE_DEF,IMPORT,CLASS_DEF,INTERFACE_DEF,ENUM_DEF,STATIC_INIT,INSTANCE_INIT,METHOD_DEF,CTOR_DEF,VARIABLE_DEF</span><br><span class="line">allowMultipleEmptyLinesInsideClassMembers</span><br><span class="line">Allow multiple empty lines inside class members</span><br><span class="line">默认值</span><br><span class="line">true</span><br><span class="line">154、Empty Statement</span><br><span class="line">坏味道   次要</span><br><span class="line">检测空的语句（独立的&#39;;&#39;）。</span><br><span class="line">155、Empty statements should be removed</span><br><span class="line">坏味道   次要</span><br><span class="line">移除空语句</span><br><span class="line">156、Enumeration should not be implemented</span><br><span class="line">坏味道   主要</span><br><span class="line">不应实同Enumeration</span><br><span class="line">157、Equality operators should not be used in &quot;for&quot; loop termination conditions</span><br><span class="line">坏味道   严重</span><br><span class="line">循环终止条件下不应使用平等运算符</span><br><span class="line">158、Equals Avoid Null</span><br><span class="line">坏味道   主要</span><br><span class="line">159、Escaped Unicode characters should not be used</span><br><span class="line">坏味道   主要</span><br><span class="line">不应使用转义的Unicode字符</span><br><span class="line">160、Exception classes should be immutable</span><br><span class="line">坏味道   次要</span><br><span class="line">异常类应该是不可变的</span><br><span class="line">161、Exception handlers should preserve the original exceptions</span><br><span class="line">坏味道   主要</span><br><span class="line">异常处理程序应保留原始异常</span><br><span class="line">162、Exception types should not be tested using &quot;instanceof&quot; in catch blocks</span><br><span class="line">坏味道   主要</span><br><span class="line">异常类型不应该在catch块中使用“instanceof”进行测试</span><br><span class="line">163、Exceptions should not be thrown in finally blocks</span><br><span class="line">坏味道   严重</span><br><span class="line">异常不应该在finally块中抛出</span><br><span class="line">164、Executable Statement Count</span><br><span class="line">坏味道   主要</span><br><span class="line">将可执行语句的数量限制为指定的限制（默认&#x3D; 30）。</span><br><span class="line"></span><br><span class="line">max</span><br><span class="line">the maximum threshold allowed. Default is 30.</span><br><span class="line">默认值</span><br><span class="line">30</span><br><span class="line">tokens  </span><br><span class="line">members to check</span><br><span class="line">默认值</span><br><span class="line">CTOR_DEF,METHOD_DEF,INSTANCE_INIT,STATIC_INIT</span><br><span class="line">165、Execution of the Garbage Collector should be triggered only by the JVM</span><br><span class="line">坏味道   严重</span><br><span class="line">垃圾收集器的执行只能由JVM触发</span><br><span class="line">166、Exit methods should not be called</span><br><span class="line">坏味道   阻断</span><br><span class="line">调用System.exit（int status）或Rutime.getRuntime（）。exit（int status）调用关闭挂钩并关闭整个Java虚拟机。 调用Runtime.getRuntime（）。halt（int）立即关闭，而不调用关闭挂钩，并跳过完成</span><br><span class="line">167、Explicit Initialization</span><br><span class="line">坏味道   主要</span><br><span class="line">检查任何类或对象成员是否明确地初始化为其类型值的默认值（对于对象引用为空，数字类型为零，对于布尔为char为false）。</span><br><span class="line">168、Expressions should not be too complex</span><br><span class="line">坏味道   严重</span><br><span class="line">表达式不应太复杂</span><br><span class="line"></span><br><span class="line">max</span><br><span class="line">Maximum number of allowed conditional operators in an expression</span><br><span class="line">默认值</span><br><span class="line">3</span><br><span class="line">169、Extensions and implementations should not be redundant</span><br><span class="line">坏味道   次要</span><br><span class="line">扩展和实现不应该是多余的</span><br><span class="line">170、Fall Through</span><br><span class="line">坏味道   主要</span><br><span class="line">171、Field names should comply with a naming convention</span><br><span class="line">坏味道   次要</span><br><span class="line">字段名称应符合命名约定</span><br><span class="line">format</span><br><span class="line">Regular expression used to check the field names against.</span><br><span class="line">默认值</span><br><span class="line">^[a-z][a-zA-Z0-9]*$</span><br><span class="line">172、Fields in a &quot;Serializable&quot; class should either be transient or serializable</span><br><span class="line">坏味道   严重</span><br><span class="line">“Serializable”类中的字段应该是transient或可序列化的</span><br><span class="line">173、Fields in non-serializable classes should not be &quot;transient&quot;</span><br><span class="line">坏味道   次要</span><br><span class="line">不可序列化类的字段不应该是“transient”</span><br><span class="line">174、Fields should not be initialized to default values</span><br><span class="line">坏味道   次要</span><br><span class="line">不应将字段初始化为默认值</span><br><span class="line">175、File Contents Holder</span><br><span class="line">坏味道   次要</span><br><span class="line">配置为TreeWalker子模块时，保留当前的全局访问文件内容。 例如，过滤器可以通过此模块访问当前文件内容</span><br><span class="line">176、File Length</span><br><span class="line">坏味道   主要</span><br><span class="line">如果源文件变得很长，那么很难理解。 因此，长类通常应该重构到专注于特定任务的几个单独的类中</span><br><span class="line"></span><br><span class="line">fileExtensions</span><br><span class="line">file type extension of files to process</span><br><span class="line">max</span><br><span class="line">maximum allowable number of lines. Default is 2000.</span><br><span class="line">177、File Tab Character</span><br><span class="line">坏味道   次要</span><br><span class="line">检查源代码中没有制表符（&#39;\ t&#39;）</span><br><span class="line"></span><br><span class="line">fileExtensions</span><br><span class="line">file type extension of files to process</span><br><span class="line">eachLine  </span><br><span class="line">whether to report on each line containing a tab, or just the first instance. Default is false.</span><br><span class="line">178、Files should contain an empty new line at the end</span><br><span class="line">坏味道   次要</span><br><span class="line">文件最后应该包含一个空的新行</span><br><span class="line">179、Files should contain only one top-level class or interface each</span><br><span class="line">坏味道   主要</span><br><span class="line">文件应该只包含一个顶级类或接口</span><br><span class="line">180、Files should not be empty</span><br><span class="line">坏味道   次要</span><br><span class="line">删除空文件</span><br><span class="line">181、Files should not have too many lines of code</span><br><span class="line">坏味道   主要</span><br><span class="line">源码文件代码行数检查</span><br><span class="line">182、Modifiers should be declared in the correct order</span><br><span class="line">坏味道   次要</span><br><span class="line">Java语言规范建议按以下顺序列出修饰符：</span><br><span class="line">1. Annotations</span><br><span class="line">2. public</span><br><span class="line">3. protected</span><br><span class="line">4. private</span><br><span class="line">5. abstract</span><br><span class="line">6. static</span><br><span class="line">7. final</span><br><span class="line">8. transient</span><br><span class="line">9. volatile</span><br><span class="line">10. synchronized</span><br><span class="line">11. native</span><br><span class="line">12. strictfp</span><br><span class="line">183、Sections of code should not be &quot;commented out&quot;</span><br><span class="line">坏味道   主要</span><br><span class="line">不要有注掉的代码，影响可读性，可以删除</span><br><span class="line">184、Strings should not be concatenated using &#39;+&#39; in a loop</span><br><span class="line">坏味道   次要</span><br><span class="line">用StringBuilder代替String拼接</span><br><span class="line">185、String function use should be optimized for single characters</span><br><span class="line">坏味道   主要</span><br><span class="line">字符串方法操作中单字符建议优先用单引号</span><br><span class="line">186、Unused local variables should be removed</span><br><span class="line">坏味道   次要</span><br><span class="line">如果一个局部变量被声明但未被使用，那么它是死代码，应该被删除。 这样做会提高可维护性，因为开发人员不会想知道使用什么变量</span><br><span class="line">187、The diamond operator (&quot;&lt;&gt;&quot;) should be used</span><br><span class="line">坏味道   次要</span><br><span class="line">Java 7引入了操作符（&lt;&gt;）来减少泛型代码的冗长度。</span><br><span class="line">List&lt;String&gt; strings &#x3D; new ArrayList&lt;&gt;()</span><br><span class="line">188、Useless imports should be removed</span><br><span class="line">坏味道   次要</span><br><span class="line">不要导入没有用到的导入</span><br><span class="line">189、Source files should not have any duplicated blocks</span><br><span class="line">坏味道   主要</span><br><span class="line">源文件不应有任何重复块</span><br><span class="line">190、Only static class initializers should be used</span><br><span class="line">坏味道   主要</span><br><span class="line">静态代码块应加，static标识</span><br><span class="line">191、Generic exceptions should never be thrown</span><br><span class="line">坏味道   主要</span><br><span class="line">通用异常如Error, RuntimeException, Throwable, and Exception不应抛出,应定义和抛出一个专门的异常，而不是使用通用异常</span><br><span class="line">192、Method names should comply with a naming convention</span><br><span class="line">坏味道   次要</span><br><span class="line">方法名称应符合命名约定</span><br><span class="line">默认规则：^[a-z][a-zA-Z0-9]*$</span><br><span class="line">193、Synchronized classes Vector, Hashtable, Stack and StringBuffer should not be used</span><br><span class="line">坏味道   主要</span><br><span class="line">Java API的早期类，例如Vector，Hashtable和StringBuffer已被同步，使其成为线程安全的。 不幸的是，即使从单个线程使用这些集合，同步也会对性能产生很大的负面影响</span><br><span class="line">194、Standard outputs should not be used directly to log anything</span><br><span class="line">坏味道   主要</span><br><span class="line">用日志记录代替标准输出</span><br><span class="line">195、Local variable and method parameter names should comply with a naming convention</span><br><span class="line">坏味道   次要</span><br><span class="line">局部变量和方法参数名称应符合命名约定</span><br><span class="line">默认:^[a-z][a-zA-Z0-9]*$</span><br><span class="line">196、Local Variables should not be declared and then immediately returned or thrown</span><br><span class="line">坏味道   次要</span><br><span class="line">声明一个变量只是立即返回或抛出它是一个糟糕的做法</span><br><span class="line">197、Instance methods should not write to &quot;static&quot; fields</span><br><span class="line">坏味道   严重</span><br><span class="line">静态属性更新需同步</span><br><span class="line">198、Methods should not be empty</span><br><span class="line">坏味道   严重</span><br><span class="line">不要存在空方法</span><br><span class="line">199、Utility classes should not have public constructors</span><br><span class="line">坏味道   主要</span><br><span class="line">帮助类不应该有公共构造函数，帮助类不宜实例化，且应该有一个如下的私有构造方法</span><br><span class="line">private StringUtils() &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Utility class&quot;);</span><br><span class="line">&#125;</span><br><span class="line">200、Static non-final field names should comply with a naming convention</span><br><span class="line">坏味道   次要</span><br><span class="line">静态非最终字段名称应符合命名约定</span><br><span class="line">默认:^[a-z][a-zA-Z0-9]*$</span><br><span class="line">201、Methods returns should not be invariant</span><br><span class="line">坏味道   阻断</span><br><span class="line">方法返回值不应该是相同的值</span><br><span class="line">202、Return of boolean expressions should not be wrapped into an &quot;if-then-else&quot; statement</span><br><span class="line">坏味道   次要</span><br><span class="line">可以根据boolean表达式就能返回的直接返回boolean表达式，不需要if-then-else语句</span><br><span class="line">203、Try-with-resources should be used</span><br><span class="line">坏味道   严重</span><br><span class="line">Try-with-resources代替try-catch-finally  </span><br><span class="line">204、String literals should not be duplicated</span><br><span class="line">坏味道   严重</span><br><span class="line">重复的字符串文字会使重构过程容易出错，因为您必须确保更新所有</span><br><span class="line"></span><br><span class="line">threshold  </span><br><span class="line">Number of times a literal must be duplicated to trigger an issue</span><br><span class="line">默认值</span><br><span class="line">3</span><br><span class="line">205、</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">坏味道</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可调整:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1、Abbreviation As Word In Name    (默认 关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line">检查验证标识符名称中的缩写（连续大写字母）长度，还允许执行骆驼案例命名</span><br><span class="line">allowedAbbreviationLength 3</span><br><span class="line">6、Annotation Location             (默认 关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line">注释位置</span><br><span class="line">allowSamelineSingleParameterlessAnnotation  </span><br><span class="line">To allow single parameterless annotation to be located on the same line as target element.</span><br><span class="line">默认值</span><br><span class="line">true</span><br><span class="line">allowSamelineParameterizedAnnotation</span><br><span class="line">To allow parameterized annotation to be located on the same line as target element.</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">allowSamelineMultipleAnnotations</span><br><span class="line">To allow annotation to be located on the same line as target element.</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">tokens  </span><br><span class="line">tokens to check</span><br><span class="line">默认值</span><br><span class="line">CLASS_DEF,INTERFACE_DEF,ENUM_DEF,METHOD_DEF,CTOR_DEF,VARIABLE_DEF</span><br><span class="line">7、Annotation Use Style                 (默认 关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line"></span><br><span class="line">trailingArrayComma</span><br><span class="line">Defines the policy for trailing comma in arrays. Default is never.</span><br><span class="line">closingParens  </span><br><span class="line">Defines the policy for ending parenthesis. Default is never.</span><br><span class="line">elementStyle  </span><br><span class="line">Defines the annotation element styles. Default value is compact_no_array.</span><br><span class="line">8、Artifact ids should follow a naming convention     (默认 关闭)</span><br><span class="line">坏味道   次要</span><br><span class="line">共享命名约定允许团队有效协作。 当pom的artifactId与提供的正则表达式不匹配时，此规则引发了一个问题</span><br><span class="line"></span><br><span class="line">regex</span><br><span class="line">The regular expression the &quot;artifactId&quot; should match</span><br><span class="line">默认值</span><br><span class="line">[a-z][a-z-0-9]+</span><br><span class="line">9、At-clause Order      (默认 关闭)  </span><br><span class="line">坏味道   主要</span><br><span class="line">检查从句顺序</span><br><span class="line">tagOrder</span><br><span class="line">allows to specify the order by tags.</span><br><span class="line">默认值</span><br><span class="line">@author,@version,@param,@return,@throws,@exception,@see,@since,@serial,@serialField,@serialData,@deprecated</span><br><span class="line">target  </span><br><span class="line">allows to specify targets to check at-clauses.</span><br><span class="line">10、Avoid Escaped Unicode Characters   (默认 关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line">避免转义的Unicode字符</span><br><span class="line"></span><br><span class="line">allowIfAllCharactersEscaped</span><br><span class="line">Allow if all characters in literal are escaped.</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">allowNonPrintableEscapes</span><br><span class="line">Allow non-printable escapes.</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">allowByTailComment</span><br><span class="line">Allow use escapes if trail comment is present.</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">allowEscapesForControlCharacters</span><br><span class="line">Allow use escapes for non-printable(control) characters.</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">11、Avoid Nested Blocks       (默认 关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line">避免嵌套块</span><br><span class="line">allowInSwitchCase</span><br><span class="line">Allow nested blocks in case statements. Default is false.</span><br><span class="line">12、Avoid Star Import       (默认 关闭)</span><br><span class="line">坏味道   次要</span><br><span class="line">检查发现使用*符号的导入语句</span><br><span class="line">excludes  </span><br><span class="line">packages where star imports are allowed. Note that this property is not recursive, subpackages of excluded packages are not automatically excluded.</span><br><span class="line">allowStaticMemberImports</span><br><span class="line">whether to allow starred static member imports like &lt;code&gt;import static org.junit.Assert.*;&lt;&#x2F;code&gt;. Default is false.</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">allowClassImports</span><br><span class="line">whether to allow starred class imports like &lt;code&gt;import java.util.*;&lt;&#x2F;code&gt;. Default is false.</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">13、Boolean Expression Complexity     (默认 关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line">将嵌套布尔运算符（&amp;&amp;，||和^）限制为指定的深度（默认&#x3D; 3）。</span><br><span class="line"></span><br><span class="line">max</span><br><span class="line">the maximum allowed number of boolean operations in one expression. Default is 3.</span><br><span class="line">默认值</span><br><span class="line">3</span><br><span class="line">tokens  </span><br><span class="line">tokens to check. Default is LAND,BAND,LOR,BOR,BXOR.</span><br><span class="line">默认值</span><br><span class="line">LAND,BAND,LOR,BOR,BXOR</span><br><span class="line">14、Branches should have sufficient coverage by tests    (默认 关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line">分支应有足够的测试覆盖</span><br><span class="line"></span><br><span class="line">minimumBranchCoverageRatio</span><br><span class="line">默认值</span><br><span class="line">65</span><br><span class="line">15、Catch Parameter Name       (默认 关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line">检查catch参数名是否符合format属性指定的格式</span><br><span class="line"></span><br><span class="line">format  </span><br><span class="line">Specifies valid identifiers. Default is ^(e|t|ex|[a-z][a-z][a-zA-Z]+)$</span><br><span class="line">默认值</span><br><span class="line">^(e|t|ex|[a-z][a-z][a-zA-Z]+)$</span><br><span class="line">16、Class Data Abstraction Coupling     (默认 关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line">度量衡量给定类中其他类的实例化数。</span><br><span class="line"></span><br><span class="line">max</span><br><span class="line">the maximum threshold allowed. Default is 7.</span><br><span class="line">excludedClasses</span><br><span class="line">User-configured class names to ignore.</span><br><span class="line">excludeClassesRegexps</span><br><span class="line">User-configured regular expressions to ignore classes</span><br><span class="line">excludedPackages</span><br><span class="line">User-configured packages to ignore</span><br><span class="line">17、Class Fan Out Complexity      (默认 关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line">类的依赖类数量</span><br><span class="line"></span><br><span class="line">max</span><br><span class="line">the maximum threshold allowed. Default is 20.</span><br><span class="line">excludedClasses</span><br><span class="line">User-configured class names to ignore</span><br><span class="line">excludeClassesRegexps</span><br><span class="line">User-configured regular expressions to ignore classes</span><br><span class="line">excludedPackages</span><br><span class="line">User-configured packages to ignore</span><br><span class="line">18、Class names should comply with a naming convention   (开放)</span><br><span class="line">坏味道   次要</span><br><span class="line">类名应符合命名约定</span><br><span class="line"></span><br><span class="line">format  </span><br><span class="line">Regular expression used to check the class names against.</span><br><span class="line">默认值</span><br><span class="line">^[A-Z][a-zA-Z0-9]*$</span><br><span class="line">19、Classes from &quot;sun.*&quot; packages should not be used    (开放)</span><br><span class="line">坏味道   主要</span><br><span class="line">不得使用“sun.*”软件包的类,sun类*或com.sun *包被视为实现细节，不属于Java API</span><br><span class="line"></span><br><span class="line">Exclude  </span><br><span class="line">Comma separated list of Sun packages to be ignored by this rule. Example: com.sun.jna,sun.misc   </span><br><span class="line">20、Classes should not be coupled to too many other classes (Single Responsibility Principle)      (默认 关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line">类不应与太多其他类（单一责任原则）相耦合（依赖）</span><br><span class="line"></span><br><span class="line">max</span><br><span class="line">Maximum number of classes a single class is allowed to depend upon</span><br><span class="line">默认值</span><br><span class="line">20</span><br><span class="line">21、Classes should not be too complex         (默认 关闭)</span><br><span class="line">坏味道   严重  废弃</span><br><span class="line">类不应太复杂</span><br><span class="line"></span><br><span class="line">max</span><br><span class="line">Maximum complexity allowed.</span><br><span class="line">默认值</span><br><span class="line">200</span><br><span class="line">22、Classes should not have too many &quot;static&quot; imports       (默认 关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line">静态导入类允许您使用其公共静态成员，而不必使用类名。 这可以很方便，但如果静态导入太多的类，你的代码可能会变得混乱，很难维护</span><br><span class="line"></span><br><span class="line">threshold  </span><br><span class="line">The maximum number of static imports allowed</span><br><span class="line">默认值</span><br><span class="line">4</span><br><span class="line">23、Classes should not have too many fields     (默认 关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line">类不应有太多字段</span><br><span class="line">countNonpublicFields</span><br><span class="line">Whether or not to include non-public fields in the count</span><br><span class="line">默认值</span><br><span class="line">true</span><br><span class="line">maximumFieldThreshold</span><br><span class="line">The maximum number of fields</span><br><span class="line">默认值</span><br><span class="line">20</span><br><span class="line">24、Classes should not have too many methods      (默认 关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line">类不应该有太多方法</span><br><span class="line"></span><br><span class="line">countNonpublicMethods</span><br><span class="line">Whether or not to include non-public methods in the count.</span><br><span class="line">默认值</span><br><span class="line">true</span><br><span class="line">maximumMethodThreshold</span><br><span class="line">The maximum number of methods authorized in a class.</span><br><span class="line">默认值</span><br><span class="line">35</span><br><span class="line">25、Close curly brace and the next &quot;else&quot;, &quot;catch&quot; and &quot;finally&quot; keywords should be located on the same line    (默认 关闭)</span><br><span class="line">坏味道   次要</span><br><span class="line">关闭大括号，下一个“else”，“catch”和“finally”关键字应位于同一行</span><br><span class="line">26、Close curly brace and the next &quot;else&quot;, &quot;catch&quot; and &quot;finally&quot; keywords should be on two different lines    (默认 关闭)</span><br><span class="line">坏味道   次要</span><br><span class="line">关闭大括号和下一个“else”，“catch”和“finally”关键字应该在两个不同的行</span><br><span class="line">29、Comments should not be located at the end of lines of code    (默认 关闭)</span><br><span class="line">坏味道   次要</span><br><span class="line">注释不应位于代码行的末尾</span><br><span class="line"></span><br><span class="line">legalTrailingCommentPattern</span><br><span class="line">Description Pattern for text of trailing comments that are allowed. By default, comments containing only one word.</span><br><span class="line">默认值</span><br><span class="line">^\s*+[^\s]++$</span><br><span class="line">30、Constant Name    (默认 关闭)</span><br><span class="line">坏味道   次要</span><br><span class="line">检查常数名称是否符合指定的格式</span><br><span class="line">applyToPackage</span><br><span class="line">Controls whether to apply the check to package-private member</span><br><span class="line">默认值</span><br><span class="line">true</span><br><span class="line">format  </span><br><span class="line">Regular expression</span><br><span class="line">默认值</span><br><span class="line">^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$</span><br><span class="line">applyToPublic  </span><br><span class="line">Controls whether to apply the check to public member</span><br><span class="line">默认值</span><br><span class="line">true</span><br><span class="line">applyToProtected</span><br><span class="line">Controls whether to apply the check to protected member</span><br><span class="line">默认值</span><br><span class="line">true</span><br><span class="line">applyToPrivate</span><br><span class="line">Controls whether to apply the check to private member</span><br><span class="line">默认值</span><br><span class="line">true</span><br><span class="line">31、Control flow statements &quot;if&quot;, &quot;for&quot;, &quot;while&quot;, &quot;switch&quot; and &quot;try&quot; should not be nested too deeply   (默认 关闭)</span><br><span class="line">坏味道   严重</span><br><span class="line">控制流程语句“if”，“for”，“while”，“switch”和“try”不能嵌套太深</span><br><span class="line"></span><br><span class="line">max</span><br><span class="line">Maximum allowed control flow statement nesting depth.</span><br><span class="line">默认值</span><br><span class="line">3</span><br><span class="line">32、Custom Import Order  (默认 关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line">检查导入声明组按照用户指定的顺序显示。 如果有导入，但是在组态中未指定其组，则导入应放在导入列表的末尾。</span><br><span class="line">thirdPartyPackageRegExp</span><br><span class="line">RegExp for THIRDPARTY_PACKAGE group imports.</span><br><span class="line">默认值</span><br><span class="line">^$</span><br><span class="line">separateLineBetweenGroups</span><br><span class="line">Force empty line separator between import groups.</span><br><span class="line">默认值</span><br><span class="line">true</span><br><span class="line">sortImportsInGroupAlphabetically</span><br><span class="line">Force grouping alphabetically.</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">specialImportsRegExp</span><br><span class="line">RegExp for SPECIAL_IMPORTS group imports.</span><br><span class="line">默认值</span><br><span class="line">^$</span><br><span class="line">customImportOrderRules</span><br><span class="line">List of order declaration customizing by user.</span><br><span class="line">standardPackageRegExp</span><br><span class="line">RegExp for STANDARD_JAVA_PACKAGE group imports.</span><br><span class="line">默认值</span><br><span class="line">java|javax</span><br><span class="line">33、Cyclomatic Complexity  (默认 关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line">检查针对特定限制的方法的循环复杂性</span><br><span class="line"></span><br><span class="line">switchBlockAsSingleDecisionPoint</span><br><span class="line">whether to treat the whole switch block as a single decision point</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">max</span><br><span class="line">the maximum threshold allowed.</span><br><span class="line">默认值</span><br><span class="line">10</span><br><span class="line">tokens  </span><br><span class="line">tokens to check</span><br><span class="line">默认值</span><br><span class="line">LITERAL_WHILE,LITERAL_DO,LITERAL_FOR,LITERAL_IF,LITERAL_SWITCH,LITERAL_CASE,LITERAL_CATCH,QUESTION,LAND,LOR</span><br><span class="line">34、Default Comes Last (默认 关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line">检查在switch语句中的所有情况之后的默认值。</span><br><span class="line"></span><br><span class="line">skipIfLastAndSharedWithCase</span><br><span class="line">whether to allow default along with case if they are not last</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">35、Empty catch block (默认 关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line">检查空的catch块。 有两个选项可以使验证更加精确（默认情况下，检查允许空的catch块和任何注释）</span><br><span class="line"></span><br><span class="line">exceptionVariableName</span><br><span class="line">Format of skipping exception&#39;&#39;s variable name.</span><br><span class="line">默认值</span><br><span class="line">^$</span><br><span class="line">commentFormat  </span><br><span class="line">Format of comment.</span><br><span class="line">默认值</span><br><span class="line">.*</span><br><span class="line">36、Empty For Initializer Pad   (默认 关闭)</span><br><span class="line">坏味道   次要</span><br><span class="line">检查初始化程序为空的填充; 那是空的是否需要一个空的初始化程序，或者禁止这样的空格。 示例：for（; i &lt;j; i ++，j--）</span><br><span class="line"></span><br><span class="line">option  </span><br><span class="line">policy on how to pad an empty for iterator</span><br><span class="line">37、Empty For Iterator Pad</span><br><span class="line">坏味道   次要</span><br><span class="line">检查一个空的填充迭代器; 那就是空格是否需要一个空的迭代器，否则这样的空格是被禁止的。 示例：for（Iterator foo &#x3D; very.long.line.iterator（）; foo.hasNext（）;）</span><br><span class="line"></span><br><span class="line">option  </span><br><span class="line">policy on how to pad an empty for iterator</span><br><span class="line">38、Empty Line Separator   (默认 关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line">在标题，包，所有导入声明，字段，构造函数，方法，嵌套类，静态初始化器和实例初始化器之后检查空行分隔符</span><br><span class="line">allowNoEmptyLineBetweenFields</span><br><span class="line">Allow no empty line between fields</span><br><span class="line">默认值</span><br><span class="line">false</span><br><span class="line">allowMultipleEmptyLines</span><br><span class="line">Allows multiple empty lines between class members.</span><br><span class="line">默认值</span><br><span class="line">true</span><br><span class="line">tokens  </span><br><span class="line">assignments to check</span><br><span class="line">默认值</span><br><span class="line">PACKAGE_DEF,IMPORT,CLASS_DEF,INTERFACE_DEF,ENUM_DEF,STATIC_INIT,INSTANCE_INIT,METHOD_DEF,CTOR_DEF,VARIABLE_DEF</span><br><span class="line">allowMultipleEmptyLinesInsideClassMembers</span><br><span class="line">Allow multiple empty lines inside class members</span><br><span class="line">默认值</span><br><span class="line">true</span><br><span class="line">39、Executable Statement Count  (默认 关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line">将可执行语句的数量限制为指定的限制（默认&#x3D; 30）。</span><br><span class="line"></span><br><span class="line">max</span><br><span class="line">the maximum threshold allowed. Default is 30.</span><br><span class="line">默认值</span><br><span class="line">30</span><br><span class="line">tokens  </span><br><span class="line">members to check</span><br><span class="line">默认值</span><br><span class="line">CTOR_DEF,METHOD_DEF,INSTANCE_INIT,STATIC_INIT</span><br><span class="line">40、Expressions should not be too complex (默认 关闭)</span><br><span class="line">坏味道   严重</span><br><span class="line">表达式不应太复杂</span><br><span class="line"></span><br><span class="line">max</span><br><span class="line">Maximum number of allowed conditional operators in an expression</span><br><span class="line">默认值</span><br><span class="line">3</span><br><span class="line">42、File Length    (默认 关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line">如果源文件变得很长，那么很难理解。 因此，长类通常应该重构到专注于特定任务的几个单独的类中</span><br><span class="line"></span><br><span class="line">fileExtensions</span><br><span class="line">file type extension of files to process</span><br><span class="line">max</span><br><span class="line">maximum allowable number of lines. Default is 2000.</span><br><span class="line">43、File Tab Character  (默认 关闭)</span><br><span class="line">坏味道   次要</span><br><span class="line">检查源代码中没有制表符（&#39;\ t&#39;）</span><br><span class="line"></span><br><span class="line">fileExtensions</span><br><span class="line">file type extension of files to process</span><br><span class="line">eachLine  </span><br><span class="line">whether to report on each line containing a tab, or just the first instance. Default is false.</span><br><span class="line">44、Files should contain an empty new line at the end  (默认 关闭)</span><br><span class="line">坏味道   次要</span><br><span class="line">文件最后应该包含一个空的新行</span><br><span class="line"></span><br><span class="line">45、Add a private constructor to hide the implicit public one.</span><br><span class="line">工具类不应该有默认或者公共的构造函数，也就是说这个类里可能方法都是static，那就不需要构造它的实例，因此应该给加一个private的构造函数，就不会报这个错了。</span><br><span class="line">a class which only has private constructors should be final</span><br><span class="line">例如上一个，加了private构造函数，又会出这个，把class设置成final即可。例：</span><br><span class="line">1</span><br><span class="line">public class Shape &#123;</span><br><span class="line">2</span><br><span class="line">private Shape() &#123;</span><br><span class="line">3</span><br><span class="line">&#x2F;* set something here *&#x2F;</span><br><span class="line">4</span><br><span class="line">&#125;</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">6</span><br><span class="line">public static Shape makeShape(&#x2F;* arglist *&#x2F;) &#123;</span><br><span class="line">7</span><br><span class="line">System.out.println(&quot;here is the shape you ordered&quot;);</span><br><span class="line">8</span><br><span class="line">return (new Shape());</span><br><span class="line">9</span><br><span class="line">&#125;</span><br><span class="line">10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">已调整：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1、String literals should not be duplicated      (调整)</span><br><span class="line">坏味道   严重</span><br><span class="line">重复的字符串文字会使重构过程容易出错，因为您必须确保更新所有</span><br><span class="line"></span><br><span class="line">threshold  </span><br><span class="line">Number of times a literal must be duplicated to trigger an issue</span><br><span class="line">默认值</span><br><span class="line">3   调整为 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">已关闭：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1、Utility classes should not have public constructors          (关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line">帮助类不应该有公共构造函数，帮助类不宜实例化，且应该有一个如下的私有构造方法</span><br><span class="line">private StringUtils() &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Utility class&quot;);</span><br><span class="line">&#125;</span><br><span class="line">2、Methods returns should not be invariant  (关闭)</span><br><span class="line">坏味道   阻断</span><br><span class="line">方法返回值不应该是相同的值</span><br><span class="line">3、Return of boolean expressions should not be wrapped into an &quot;if-then-else&quot; statement    (关闭)</span><br><span class="line">坏味道   次要</span><br><span class="line">可以根据boolean表达式就能返回的直接返回boolean表达式，不需要if-then-else语句</span><br><span class="line">4、The diamond operator (&quot;&lt;&gt;&quot;) should be used     (关闭)   jdk7+可用</span><br><span class="line">坏味道   次要</span><br><span class="line">Java 7引入了操作符（&lt;&gt;）来减少泛型代码的冗长度</span><br><span class="line">5、Sections of code should not be &quot;commented out&quot;    (关闭)</span><br><span class="line">坏味道   主要</span><br><span class="line">不要有注掉的代码，影响可读性，可以删除</span><br><span class="line">6、Try-with-resources should be used    (关闭)   jdk7+可用</span><br><span class="line">坏味道   严重</span><br><span class="line">Try-with-resources代替try-catch-finally</span><br><span class="line">7、Loops should not be infinite         (关闭)  </span><br><span class="line">Bug   阻断</span><br><span class="line">循环不应该是无限的</span><br><span class="line">8、Credentials should not be hard-coded    (关闭)  </span><br><span class="line">漏洞 阻断</span><br><span class="line">凭证不应该硬编码</span><br><span class="line">9、Anonymous inner classes containing only one method should become lambdas  (关闭)  </span><br><span class="line">坏味道   主要</span><br><span class="line">只有一个方法的匿名内部类应该变成lambdas</span><br><span class="line">10、&quot;throws&quot; declarations should not be superfluous    (关闭)  抛出运行时异常，有的框架接口即抛出此类异常</span><br><span class="line">坏味道   次要</span><br><span class="line">“抛出”声明不应该是多余的</span><br><span class="line">11、IP addresses should not be hardcoded   (关闭)</span><br><span class="line">漏洞 次要</span><br><span class="line">ip 地址不应该硬编码</span><br><span class="line">12、&quot;@Override&quot; should be used on overriding and implementing methods   (关闭)  </span><br><span class="line">坏味道   主要</span><br><span class="line">重写的和实现在方法要加Override标注</span><br><span class="line">13、An open curly brace should be located at the beginning of a line    (关闭)  </span><br><span class="line">坏味道   次要</span><br><span class="line">开放的大括号应位于一行的开头</span><br><span class="line">14、Cognitive Complexity of methods should not be too high  (关闭)</span><br><span class="line">坏味道   严重</span><br><span class="line">认知复杂度是衡量一种方法的控制流程难以理解的度量。 认知复杂性较高的方法难以维持。</span><br><span class="line">Threshold</span><br><span class="line">The maximum authorized complexity.</span><br><span class="line">默认值</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Java后端线上问题排查常用命令</title>
    <url>/2021/04/10/Java%E5%90%8E%E7%AB%AF%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Java后端线上问题排查常用命令收藏"><a href="#Java后端线上问题排查常用命令收藏" class="headerlink" title="Java后端线上问题排查常用命令收藏"></a>Java后端线上问题排查常用命令收藏</h1><pre><code>程序猿DD                                                                                       前天                 </code></pre><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>free是查看内存使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存。</p>
<p>free -h -s 3表示每隔三秒输出一次内存情况，命令如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ free</span><br><span class="line">total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:      119623656    43052220    45611364     4313760    30960072    70574408</span><br><span class="line">Swap:             0           0           0</span><br><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ free -h -s 3</span><br><span class="line">total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:           114G         41G         43G        4.1G         29G         67G</span><br><span class="line">Swap:            0B          0B          0B</span><br><span class="line"></span><br><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:           114G         41G         43G        4.1G         29G         67G</span><br><span class="line">Swap:            0B          0B          0B</span><br></pre></td></tr></table></figure>
<ul>
<li>Mem：是内存的使用情况。</li>
<li>Swap：是交换空间的使用情况。</li>
<li>total：系统总的可用物理内存和交换空间大小。</li>
<li>used：已经被使用的物理内存和交换空间。</li>
<li>free：还有多少物理内存和交换空间可用使用，是真正尚未被使用的物理内存数量。</li>
<li>shared：被共享使用的物理内存大小。</li>
<li>buff/cache：被 buffer（缓冲区） 和 cache（缓存） 使用的物理内存大小。</li>
<li>available：还可以被应用程序使用的物理内存大小，它是从应用程序的角度看到的可用内存数量，available ≈ free + buffer + cache。<br>交换空间(swap space)</li>
</ul>
<p>swap space 是磁盘上的一块区域，当系统物理内存吃紧时，Linux 会将内存中不常访问的数据保存到 swap 上，这样系统就有更多的物理内存为各个进程服务，而当系统需要访问 swap 上存储的内容时，再将 swap 上的数据加载到内存中，这就是常说的换出和换入。交换空间可以在一定程度上缓解内存不足的情况，但是它需要读写磁盘数据，所以性能不是很高。</p>
<h2 id="vmstat（推荐）"><a href="#vmstat（推荐）" class="headerlink" title="vmstat（推荐）"></a>vmstat（推荐）</h2><p>vmstat（VirtualMeomoryStatistics，虚拟内存统计）是Linux中监控内存的常用工具，可对操作系统的虚拟内存、进程、CPU等的整体情况进行监视，推荐使用。</p>
<p>vmstat 5 3表示每隔5秒统计一次，一共统计三次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ vmstat 5 3</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line">r  b   swpd   free   buff  cache   si   so    bi    bo   </span><br><span class="line">in</span><br><span class="line">cs us sy id wa st</span><br><span class="line">8  0      0 45453212 374768 30763728    0    0    14    99    1    1 11 10 78  0  1</span><br><span class="line">10  0      0 45489232 374768 30763360    0    0     2  1275 95118 97908 13 11 75  0  1</span><br><span class="line">6  0      0 45452908 374768 30765148    0    0     0  3996 89924 92073 12 10 78  0  1</span><br></pre></td></tr></table></figure>
<h2 id="procs"><a href="#procs" class="headerlink" title="procs"></a>procs</h2><p>r：表示运行和等待CPU时间片的进程数（就是说多少个进程真的分配到CPU），这个值如果长期大于系统CPU个数，说明CPU不足，需要增加CPU。b：表示在等待资源的进程数，比如正在等待I/O或者内存交换等。</p>
<h2 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h2><p>swpd：表示切换到内存交换区的内存大小，即虚拟内存已使用的大小（单位KB），如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。free：表示当前空闲的物理内存。buff：表示缓冲大小，一般对块设备的读写才需要缓冲 Cache：表示缓存大小，一般作为文件系统进行缓冲，频繁访问的文件都会被缓存，如果cache值非常大说明缓存文件比较多，如果此时io中的bi比较小，说明文件系统效率比较好。</p>
<h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h2><p>si：表示数据由磁盘读入内存；通俗的讲就是每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。so：表示由内存写入磁盘，也就是由内存交换区进入内存的数据大小。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!! 注意：一般情况下si、so的值都为0，如果si、so的值长期不为0，则说明系统内存不足，需要增加系统内存</span><br><span class="line">io</span><br><span class="line"></span><br><span class="line">bi：表示由块设备读入数据的总量，即读磁盘，单位kb&#x2F;s bo：表示写到块设备数据的总量，即写磁盘，单位kb&#x2F;s</span><br><span class="line">!! 注意：如果bi+bo的值过大，且wa值较大，则表示系统磁盘IO瓶颈。</span><br><span class="line">system</span><br><span class="line"></span><br><span class="line">in：表示某一时间间隔内观测到的每秒设备终端数。cs：表示每秒产生的上下文切换次数，这个值要越小越好，太大了，要考虑调低线程或者进程的数目。例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。</span><br><span class="line">!! 注意：这两个值越大，则由内核消耗的CPU就越多。</span><br><span class="line">CPU</span><br><span class="line"></span><br><span class="line">us：表示用户进程消耗的CPU时间百分比，us值越高，说明用户进程消耗CPU时间越多，如果长期大于50%，则需要考虑优化程序或者算法。sy：表示系统内核进程消耗的CPU时间百分比，一般来说us+sy应该小于80%，如果大于80%，说明可能存在CPU瓶颈。id：表示CPU处在空间状态的时间百分比。wa：表示IP等待所占用的CPU时间百分比，wa值越高，说明I&#x2F;O等待越严重，根据经验wa的参考值为20%，如果超过20%，说明I&#x2F;O等待严重，引起I&#x2F;O等待的原因可能是磁盘大量随机读写造成的，也可能是磁盘或者监控器的贷款瓶颈（主要是块操作）造成的。</span><br><span class="line">sar</span><br><span class="line"></span><br><span class="line">sar和free类似sar -r 3每隔三秒输出一次内存信息：</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># sar -r 3</span><br><span class="line">Linux 3.10.0-1062.el7.x86_64 (localhost.localdomain)    2020年04月28日  _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">15时40分10秒 kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">15时40分13秒    106800   1314960     92.49      2144    573248   4110864    116.82    563664    498888        36</span><br><span class="line">15时40分16秒    106816   1314944     92.49      2144    573248   4110864    116.82    563668    498888        36</span><br><span class="line">15时40分19秒    106816   1314944     92.49      2144    573248   4110864    116.82    563668    498888        36</span><br><span class="line">CPU瓶颈</span><br><span class="line"></span><br><span class="line">查看机器cpu核数</span><br><span class="line"></span><br><span class="line">CPU总核数 &#x3D; 物理CPU个数 * 每颗物理CPU的核数</span><br><span class="line">总逻辑CPU数 &#x3D; 物理CPU个数 * 每颗物理CPU的核数 * 超线程数</span><br><span class="line">查看CPU信息（型号）</span><br><span class="line"></span><br><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ cat &#x2F;proc&#x2F;cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br><span class="line">32  Intel(R) Xeon(R) CPU E5-2650 v4 @ 2.20GHz</span><br><span class="line">查看物理CPU个数</span><br><span class="line"></span><br><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ cat &#x2F;proc&#x2F;cpuinfo| grep</span><br><span class="line">&quot;physical id&quot;</span><br><span class="line">| sort| uniq| wc -l</span><br><span class="line">16</span><br><span class="line">查看每个物理CPU中core的个数(即核数)</span><br><span class="line"></span><br><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ cat &#x2F;proc&#x2F;cpuinfo| grep</span><br><span class="line">&quot;cpu cores&quot;</span><br><span class="line">| uniq</span><br><span class="line">cpu cores       : 2</span><br><span class="line">查看逻辑CPU的个数</span><br><span class="line"></span><br><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ cat &#x2F;proc&#x2F;cpuinfo| grep</span><br><span class="line">&quot;processor&quot;</span><br><span class="line">| wc -l</span><br><span class="line">32</span><br><span class="line">top</span><br><span class="line"></span><br><span class="line">在Linux内核的操作系统中，进程是根据虚拟运行时间（由进程优先级、nice值加上实际占用的CPU时间进行动态计算得出）进行动态调度的。在执行进程时，需要从用户态转换到内核态，用户空间不能直接操作内核空间的函数。通常要利用系统调用来完成进程调度，而用户空间到内核空间的转换通常是通过软中断来完成的。例如要进行磁盘操作，用户态需要通过系统调用内核的磁盘操作指令，所以CPU消耗的时间被切分成用户态CPU消耗、系统（内核） CPU 消耗，以及磁盘操作 CPU 消耗。执行进程时，需要经过一系列的操作，进程首先在用户态执行，在执行过程中会进行进程优先级的调整（nice），通过系统调用到内核，再通过内核调用，硬中断、软中断，让硬件执行任务。执行完成之后，再从内核态返回给系统调用，最后系统调用将结果返回给用户态的进程。</span><br><span class="line">top可以查看CPU总体消耗，包括分项消耗，如User，System，Idle，nice等。Shift + H显示java线程；Shift + M按照内存使用排序；Shift + P按照CPU使用时间（使用率）排序；Shift + T按照CPU累积使用时间排序；多核CPU，进入top视图1，可以看到各各CPU的负载情况。</span><br><span class="line">top - 15:24:11 up 8 days,  7:52,  1 user,  load average: 5.73, 6.85, 7.33</span><br><span class="line">Tasks:  17 total,   1 running,  16 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s): 13.9 us,  9.2 sy,  0.0 ni, 76.1 id,  0.1 wa,  0.0 hi,  0.1 si,  0.7 st</span><br><span class="line">KiB Mem : 11962365+total, 50086832 free, 38312808 used, 31224016 buff&#x2F;cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used. 75402760 avail Mem</span><br><span class="line"></span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">300 ymmapp    20   0 17.242g 1.234g  14732 S   2.3  1.1   9:40.38 java</span><br><span class="line">1 root      20   0   15376   1988   1392 S   0.0  0.0   0:00.06 sh</span><br><span class="line">11 root      20   0  120660  11416   1132 S   0.0  0.0   0:04.94 python</span><br><span class="line">54 root      20   0   85328   2240   1652 S   0.0  0.0   0:00.00 su</span><br><span class="line">55 ymmapp    20   0   17432   1808   1232 S   0.0  0.0   0:00.00 bash</span><br><span class="line">56 ymmapp    20   0   17556   2156   1460 S   0.0  0.0   0:00.03 control.sh</span><br><span class="line">57 ymmapp    20   0   11880    740    576 S   0.0  0.0   0:00.00 tee</span><br><span class="line">115 ymmapp    20   0   17556   2112   1464 S   0.0  0.0   0:00.02 control_new_war</span><br><span class="line">133 root      20   0  106032   4240   3160 S   0.0  0.0   0:00.03 sshd</span><br><span class="line">134 ymmapp    20   0   17080   6872   3180 S   0.0  0.0   0:01.82 ops-updater</span><br><span class="line">147 ymmapp    20   0   17956   2636   1544 S   0.0  0.0   0:00.07 control.sh</span><br><span class="line">6538 ymmapp    20   0  115656  10532   3408 S   0.0  0.0   0:00.46 beidou-agent</span><br><span class="line">6785 ymmapp    20   0 2572996  22512   2788 S   0.0  0.0   0:03.44 gatherinfo4dock</span><br><span class="line">29241 root      20   0  142148   5712   4340 S   0.0  0.0   0:00.04 sshd</span><br><span class="line">29243 1014154   20   0  142148   2296    924 S   0.0  0.0   0:00.00 sshd</span><br><span class="line">29244 1014154   20   0   15208   2020   1640 S   0.0  0.0   0:00.00 bash</span><br><span class="line">32641 1014154   20   0   57364   2020   1480 R   0.0  0.0   0:00.00 top</span><br><span class="line">第一行：15:24:11 up 8 days, 7:52, 1 user, load average: 5.73, 6.85, 7.33：15:24:11 系统时间，up 8 days 运行时间，1 user 当前登录用户数，load average 负载均衡情况，分别表示1分钟，5分钟，15分钟负载情况。</span><br><span class="line">第二行：Tasks: 17 total, 1 running, 16 sleeping, 0 stopped, 0 zombie：总进程数17，运行数1，休眠 16，停止0，僵尸进程0。</span><br><span class="line">第三行：%Cpu(s): 13.9 us, 9.2 sy, 0.0 ni, 76.1 id, 0.1 wa, 0.0 hi, 0.1 si, 0.7 st：用户空间CPU占比13.9%，内核空间CPU占比9.2%，改变过优先级的进程CPU占比0%，空闲CPU占比76.1，IO等待占用CPU占比0.1%，硬中断占用CPU占比0%，软中断占用CPU占比0.1%,当前VM中的cpu 时钟被虚拟化偷走的比例0.7%。</span><br><span class="line">第四和第五行表示内存和swap区域的使用情况。</span><br><span class="line">第七行表示：</span><br><span class="line">* PID: 进程id</span><br><span class="line">* USER:进程所有者</span><br><span class="line">* PR:进程优先级</span><br><span class="line">* NI:nice值。负值表示高优先级，正值表示低优先级</span><br><span class="line">* VIRT:虚拟内存，进程使用的虚拟内存总量，单位kb。VIRT&#x3D;SWAP+RES</span><br><span class="line">* RES:常驻内存，进程使用的、未被换出的物理内存大小，单位kb。RES&#x3D;CODE+DATA</span><br><span class="line">* SHR:共享内存，共享内存大小，单位kb</span><br><span class="line">* S:进程状态。D&#x3D;不可中断的睡眠状态 R&#x3D;运行 S&#x3D;睡眠 T&#x3D;跟踪&#x2F;停止 Z&#x3D;僵尸进程</span><br><span class="line">* %CPU:上次更新到现在的CPU时间占用百分比</span><br><span class="line">* %MEM:进程使用的物理内存百分比</span><br><span class="line">* TIME+:进程使用的CPU时间总计，单位1&#x2F;100秒</span><br><span class="line">* COMMAND:进程名称（命令名&#x2F;命令行）</span><br><span class="line">  计算在cpu load里面的uninterruptedsleep的任务数量</span><br><span class="line"></span><br><span class="line">top -b -n 1 | awk</span><br><span class="line">&#39;&#123;if (NR&lt;&#x3D;7)print;else if($8&#x3D;&#x3D;&quot;D&quot;)&#123;print;count++&#125;&#125;END&#123;print &quot;Total status D:&quot;count&#125;&#39;</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># top -b -n 1 | awk &#39;&#123;if (NR&lt;&#x3D;7)print;else if($8&#x3D;&#x3D;&quot;D&quot;)&#123;print;count++&#125;&#125;END&#123;print &quot;Total status D:&quot;count&#125;&#39;</span><br><span class="line">top - 15:35:05 up 1 day, 26 min,  3 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Tasks: 225 total,   1 running, 224 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  2.5 us, 10.0 sy,  0.0 ni, 87.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  1421760 total,   104516 free,   777344 used,   539900 buff&#x2F;cache</span><br><span class="line">KiB Swap:  2097148 total,  2071152 free,    25996 used.   456028 avail Mem</span><br><span class="line"></span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">Total status D:</span><br><span class="line">sar</span><br><span class="line"></span><br><span class="line">通过sar -u 3可以查看CUP总体消耗占比：</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># sar -u 3</span><br><span class="line">Linux 3.10.0-1062.el7.x86_64 (localhost.localdomain)    2020年05月01日  _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">15时18分03秒     CPU     %user     %nice   %system   %iowait    %steal     %idle</span><br><span class="line">15时18分06秒     all      0.00      0.00      0.17      0.00      0.00     99.83</span><br><span class="line">15时18分09秒     all      0.00      0.00      0.17      0.00      0.00     99.83</span><br><span class="line">15时18分12秒     all      0.17      0.00      0.17      0.00      0.00     99.66</span><br><span class="line">15时18分15秒     all      0.00      0.00      0.00      0.00      0.00    100.00</span><br><span class="line">15时18分18秒     all      0.00      0.00      0.00      0.00      0.00    100.00</span><br><span class="line">* %user：用户空间的CPU使用。</span><br><span class="line">* %nice：改变过优先级的进程的CPU使用率。</span><br><span class="line">* %system：内核空间的CPU使用率。</span><br><span class="line">* %iowait：CPU等待IO的百分比 。</span><br><span class="line">* %steal：虚拟机的虚拟机CPU使用的CPU。</span><br><span class="line">* %idle：空闲的CPU。</span><br><span class="line">  在以上的显示当中，主要看%iowait和%idle：</span><br><span class="line">* 若 %iowait的值过高，表示硬盘存在I&#x2F;O瓶颈；</span><br><span class="line">* 若 %idle的值高但系统响应慢时，有可能是 CPU 等待分配内存，此时应加大内存容量；</span><br><span class="line">* 若 %idle的值持续低于 10，则系统的 CPU 处理能力相对较低，表明系统中最需要解决的资源是 CPU；</span><br><span class="line">  定位线上最耗CPU的线程</span><br><span class="line"></span><br><span class="line">准备工作</span><br><span class="line"></span><br><span class="line">启动一个程序。arthas-demo是一个简单的程序，每隔一秒生成一个随机数，再执行质因数分解，并打印出分解结果。</span><br><span class="line">curl -O https:&#x2F;&#x2F;alibaba.github.io&#x2F;arthas&#x2F;arthas-demo.jar</span><br><span class="line">java -jar arthas-demo.jar</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># curl -O https:&#x2F;&#x2F;alibaba.github.io&#x2F;arthas&#x2F;arthas-demo.jar</span><br><span class="line">% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100  3743  100  3743    0     0   3022      0  0:00:01  0:00:01 --:--:--  3023</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># java -jar arthas-demo.jar</span><br><span class="line">1813&#x3D;7*7*37</span><br><span class="line">illegalArgumentCount:  1, number is: -180005, need &gt;&#x3D; 2</span><br><span class="line">illegalArgumentCount:  2, number is: -111175, need &gt;&#x3D; 2</span><br><span class="line">18505&#x3D;5*3701</span><br><span class="line">166691&#x3D;7*23813</span><br><span class="line">105787&#x3D;11*59*163</span><br><span class="line">60148&#x3D;2*2*11*1367</span><br><span class="line">196983&#x3D;3*3*43*509</span><br><span class="line">illegalArgumentCount:  3, number is: -173479, need &gt;&#x3D; 2</span><br><span class="line">illegalArgumentCount:  4, number is: -112840, need &gt;&#x3D; 2</span><br><span class="line">39502&#x3D;2*19751</span><br><span class="line">....</span><br><span class="line">通过top命令找到最耗时的进程</span><br><span class="line"></span><br><span class="line">[root@localhost ~]</span><br><span class="line"># top</span><br><span class="line">top - 11:11:05 up 20:02,  3 users,  load average: 0.09, 0.07, 0.05</span><br><span class="line">Tasks: 225 total,   1 running, 224 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.0 us,  0.7 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  1421760 total,   135868 free,   758508 used,   527384 buff&#x2F;cache</span><br><span class="line">KiB Swap:  2097148 total,  2070640 free,    26508 used.   475852 avail Mem</span><br><span class="line">Change delay from 3.0 to</span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">98344 root      20   0 2422552  23508  12108 S   0.7  1.7   0:00.32 java</span><br><span class="line">1 root      20   0  194100   6244   3184 S   0.0  0.4   0:20.41 systemd</span><br><span class="line">2 root      20   0       0      0      0 S   0.0  0.0   0:00.12 kthreadd</span><br><span class="line">4 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker&#x2F;0:0H</span><br><span class="line">6 root      20   0       0      0      0 S   0.0  0.0   0:20.25 ksoftirqd&#x2F;0</span><br><span class="line">找到进程号是98344。</span><br><span class="line">找到进程中最耗CUP的线程</span><br><span class="line"></span><br><span class="line">使用ps -Lp #pid cu命令，查看某个进程中的线程CPU消耗排序：</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># ps -Lp 98344 cu</span><br><span class="line">USER        PID    LWP %CPU NLWP %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root      98344  98344  0.0   10  4.1 2422552 59060 pts&#x2F;0   Sl+  11:09   0:00 java</span><br><span class="line">root      98344  98345  0.0   10  4.1 2422552 59060 pts&#x2F;0   Sl+  11:09   0:04 java</span><br><span class="line">root      98344  98346  0.0   10  4.1 2422552 59060 pts&#x2F;0   Sl+  11:09   0:01 VM Thread</span><br><span class="line">root      98344  98347  0.0   10  4.1 2422552 59060 pts&#x2F;0   Sl+  11:09   0:00 Reference Handl</span><br><span class="line">root      98344  98348  0.0   10  4.1 2422552 59060 pts&#x2F;0   Sl+  11:09   0:00 Finalizer</span><br><span class="line">root      98344  98349  0.0   10  4.1 2422552 59060 pts&#x2F;0   Sl+  11:09   0:00 Signal Dispatch</span><br><span class="line">root      98344  98350  0.0   10  4.1 2422552 59060 pts&#x2F;0   Sl+  11:09   0:05 C2 CompilerThre</span><br><span class="line">root      98344  98351  0.0   10  4.1 2422552 59060 pts&#x2F;0   Sl+  11:09   0:00 C1 CompilerThre</span><br><span class="line">root      98344  98352  0.0   10  4.1 2422552 59060 pts&#x2F;0   Sl+  11:09   0:00 Service Thread</span><br><span class="line">root      98344  98353  0.1   10  4.1 2422552 59060 pts&#x2F;0   Sl+  11:09   0:19 VM Periodic Tas</span><br><span class="line">看TIME列可以看出那个线程耗费CUP多，根据LWP列可以看到线程的ID号，但是需要转换成16进制才可以查询线程堆栈信息。</span><br><span class="line">获取线程id的十六进制码</span><br><span class="line"></span><br><span class="line">使用printf &#39;%x\n&#39; 98345命令做进制转换：</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># printf &#39;%x\n&#39; 98345</span><br><span class="line">18029</span><br><span class="line">查看线程堆栈信息</span><br><span class="line"></span><br><span class="line">使用jstack获取堆栈信息jstack 98344 | grep -A 10 18029：</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># jstack 98344 | grep -A 10 18029</span><br><span class="line">&quot;main&quot;</span><br><span class="line"></span><br><span class="line">#1 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x00007fb88404b800 nid&#x3D;0x18029 waiting on condition [0x00007fb88caab000]</span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at java.lang.Thread.sleep(Thread.java:340)</span><br><span class="line">at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)</span><br><span class="line">at demo.MathGame.main(MathGame.java:17)</span><br><span class="line"></span><br><span class="line">&quot;VM Thread&quot;</span><br><span class="line">os_prio&#x3D;0 tid&#x3D;0x00007fb8840f2800 nid&#x3D;0x1802a runnable</span><br><span class="line"></span><br><span class="line">&quot;VM Periodic Task Thread&quot;</span><br><span class="line">os_prio&#x3D;0 tid&#x3D;0x00007fb884154000 nid&#x3D;0x18031 waiting on condition</span><br><span class="line">通过命令我们可以看到这个线程的对应的耗时代码是在demo.MathGame.main(MathGame.java:17)</span><br><span class="line">grep -C 5 foo file 显示file文件里匹配foo字串那行以及上下5行</span><br><span class="line">grep -B 5 foo file 显示foo及前5行</span><br><span class="line">grep -A 5 foo file 显示foo及后5行</span><br><span class="line">网络瓶颈</span><br><span class="line"></span><br><span class="line">定位丢包，错包情况</span><br><span class="line"></span><br><span class="line">watch more &#x2F;proc&#x2F;net&#x2F;dev用于定位丢包，错包情况，以便看网络瓶颈，重点关注drop(包被丢弃)和网络包传送的总量，不要超过网络上限：</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># watch -n 2 more &#x2F;proc&#x2F;net&#x2F;dev</span><br><span class="line">Every 2.0s: more &#x2F;proc&#x2F;net&#x2F;dev                                                                                                                                                   Fri May  1 17:16:55 2020</span><br><span class="line"></span><br><span class="line">Inter-|   Receive                                                |  Transmit</span><br><span class="line">face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed</span><br><span class="line">lo:   10025     130    0    0    0     0          0         0    10025     130    0    0    0     0       0          0</span><br><span class="line">ens33: 759098071  569661    0    0    0     0          0         0 19335572  225551    0    0    0     0       0          0</span><br><span class="line">* 最左边的表示接口的名字，Receive表示收包，Transmit表示发送包；</span><br><span class="line">* bytes：表示收发的字节数；</span><br><span class="line">* packets：表示收发正确的包量；</span><br><span class="line">* errs：表示收发错误的包量；</span><br><span class="line">* drop：表示收发丢弃的包量；</span><br><span class="line">  查看路由经过的地址</span><br><span class="line"></span><br><span class="line">traceroute ip可以查看路由经过的地址，常用来统计网络在各个路由区段的耗时，如：</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># traceroute 14.215.177.38</span><br><span class="line">traceroute to 14.215.177.38 (14.215.177.38), 30 hops max, 60 byte packets</span><br><span class="line">1  CD-HZTK5H2.mshome.net (192.168.137.1)  0.126 ms * *</span><br><span class="line">2  * * *</span><br><span class="line">3  10.250.112.3 (10.250.112.3)  12.587 ms  12.408 ms  12.317 ms</span><br><span class="line">4  172.16.227.230 (172.16.227.230)  2.152 ms  2.040 ms  1.956 ms</span><br><span class="line">5  172.16.227.202 (172.16.227.202)  11.884 ms  11.746 ms  12.692 ms</span><br><span class="line">6  172.16.227.65 (172.16.227.65)  2.665 ms  3.143 ms  2.923 ms</span><br><span class="line">7  171.223.206.217 (171.223.206.217)  2.834 ms  2.752 ms  2.654 ms</span><br><span class="line">8  182.150.18.205 (182.150.18.205)  5.145 ms  5.815 ms  5.542 ms</span><br><span class="line">9  110.188.6.33 (110.188.6.33)  3.514 ms 171.208.199.185 (171.208.199.185)  3.431 ms 171.208.199.181 (171.208.199.181)  10.768 ms</span><br><span class="line">10  202.97.29.17 (202.97.29.17)  29.574 ms 202.97.30.146 (202.97.30.146)  32.619 ms *</span><br><span class="line">11  113.96.5.126 (113.96.5.126)  36.062 ms 113.96.5.70 (113.96.5.70)  35.940 ms 113.96.4.42 (113.96.4.42)  45.859 ms</span><br><span class="line">12  90.96.135.219.broad.fs.gd.dynamic.163data.com.cn (219.135.96.90)  35.680 ms  35.468 ms  35.304 ms</span><br><span class="line">13  14.215.32.102 (14.215.32.102)  35.135 ms 14.215.32.110 (14.215.32.110)  35.613 ms 14.29.117.242 (14.29.117.242)  54.712 ms</span><br><span class="line">14  * 14.215.32.134 (14.215.32.134)  49.518 ms 14.215.32.122 (14.215.32.122)  47.652 ms</span><br><span class="line">15  * * *</span><br><span class="line">...</span><br><span class="line">查看网络错误</span><br><span class="line"></span><br><span class="line">netstat -i可以查看网络错误：</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># netstat -i</span><br><span class="line">Kernel Interface table</span><br><span class="line">Iface             MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">ens33            1500   570291      0      0 0        225897      0      0      0 BMRU</span><br><span class="line">lo              65536      130      0      0 0           130      0      0      0 LRU</span><br><span class="line">* Iface: 网络接口名称;</span><br><span class="line">* MTU: 最大传输单元，它限制了数据帧的最大长度，不同的网络类型都有一个上限值，如：以太网的MTU是1500；</span><br><span class="line">* RX-OK：接收时，正确的数据包数。</span><br><span class="line">* RX-ERR：接收时，产生错误的数据包数。</span><br><span class="line">* RX-DRP：接收时，丢弃的数据包数。</span><br><span class="line">* RX-OVR：接收时，由于过速（在数据传输中，由于接收设备不能接收按照发送速率传送来的数据而使数据丢失）而丢失的数据包数。</span><br><span class="line">* TX-OK：发送时，正确的数据包数。</span><br><span class="line">* TX-ERR：发送时，产生错误的数据包数。</span><br><span class="line">* TX-DRP：发送时，丢弃的数据包数。</span><br><span class="line">* TX-OVR：发送时，由于过速而丢失的数据包数。</span><br><span class="line">* Flg：标志，B 已经设置了一个广播地址。L 该接口是一个回送设备。M 接收所有数据包（混乱模式）。N 避免跟踪。O 在该接口上，禁用ARP。P 这是一个点到点链接。R 接口正在运行。U 接口处于“活动”状态。</span><br><span class="line">  包的重传率</span><br><span class="line"></span><br><span class="line">cat &#x2F;proc&#x2F;net&#x2F;snmp用来查看和分析240秒内网络包量，流量，错包，丢包。通过RetransSegs和OutSegs来计算重传率tcpetr&#x3D;RetransSegs&#x2F;OutSegs。</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># cat &#x2F;proc&#x2F;net&#x2F;snmp</span><br><span class="line">Ip: Forwarding DefaultTTL InReceives InHdrErrors InAddrErrors ForwDatagrams InUnknownProtos InDiscards InDelivers OutRequests OutDiscards OutNoRoutes ReasmTimeout ReasmReqds ReasmOKs ReasmFails FragOKs FragFails FragCreates</span><br><span class="line">Ip: 1 64 241708 0 0 0 0 0 238724 225517 15 0 0 0 0 0 0 0 0</span><br><span class="line">Icmp: InMsgs InErrors InCsumErrors InDestUnreachs InTimeExcds InParmProbs InSrcQuenchs InRedirects InEchos InEchoReps InTimestamps InTimestampReps InAddrMasks InAddrMaskReps OutMsgs OutErrors OutDestUnreachs OutTimeExcds OutParmProbs OutSrcQuenchs OutRedirects OutEchos OutEchoReps OutTimestamps OutTimestampReps OutAddrMasks OutAddrMaskReps</span><br><span class="line">Icmp: 149 0 0 50 99 0 0 0 0 0 0 0 0 0 147 0 147 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">IcmpMsg: InType3 InType11 OutType3</span><br><span class="line">IcmpMsg: 50 99 147</span><br><span class="line">Tcp: RtoAlgorithm RtoMin RtoMax MaxConn ActiveOpens PassiveOpens AttemptFails EstabResets CurrEstab InSegs OutSegs RetransSegs InErrs OutRsts InCsumErrors</span><br><span class="line">Tcp: 1 200 120000 -1 376 6 0 0 4 236711 223186 292 0 4 0</span><br><span class="line">Udp: InDatagrams NoPorts InErrors OutDatagrams RcvbufErrors SndbufErrors InCsumErrors</span><br><span class="line">Udp: 1405 438 0 1896 0 0 0</span><br><span class="line">UdpLite: InDatagrams NoPorts InErrors OutDatagrams RcvbufErrors SndbufErrors InCsumErrors</span><br><span class="line">UdpLite: 0 0 0 0 0 0 0</span><br><span class="line">重传率&#x3D;292&#x2F;223186≈0.13%</span><br><span class="line">* 平均每秒新增TCP连接数：通过&#x2F;proc&#x2F;net&#x2F;snmp文件得到最近240秒内PassiveOpens的增量，除以240得到每秒的平均增量；</span><br><span class="line">* 机器的TCP连接数 ：通过&#x2F;proc&#x2F;net&#x2F;snmp文件的CurrEstab得到TCP连接数；</span><br><span class="line">* 平均每秒的UDP接收数据报：通过&#x2F;proc&#x2F;net&#x2F;snmp文件得到最近240秒内InDatagrams的增量，除以240得到平均每秒的UDP接收数据报；</span><br><span class="line">* 平均每秒的UDP发送数据报：通过&#x2F;proc&#x2F;net&#x2F;snmp文件得到最近240秒内OutDatagrams的增量，除以240得到平均每秒的UDP发送数据报；</span><br><span class="line">  磁盘瓶颈</span><br><span class="line"></span><br><span class="line">查磁盘空间</span><br><span class="line"></span><br><span class="line">查看磁盘剩余空间</span><br><span class="line"></span><br><span class="line">查看磁盘剩余空间使用df -hl命令：</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># df -hl</span><br><span class="line">文件系统                       容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs                       678M     0  678M    0% &#x2F;dev</span><br><span class="line">tmpfs                          695M     0  695M    0% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs                          695M   28M  667M    4% &#x2F;run</span><br><span class="line">tmpfs                          695M     0  695M    0% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">&#x2F;dev&#x2F;mapper&#x2F;centos_aubin-root   27G  5.6G   22G   21% &#x2F;</span><br><span class="line">&#x2F;dev&#x2F;sda1                     1014M  211M  804M   21% &#x2F;boot</span><br><span class="line">查看磁盘已使用空间</span><br><span class="line"></span><br><span class="line">du -sh命令是查看磁盘已使用空间的情况，这里的“已使用的磁盘空间”意思是指定的文件下的整个文件层次结构所使用的空间，在没给定参数的情况下，du报告当前目录所使用的磁盘空间。其实就是显示文件或目录所占用的磁盘空间的情况：</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># du -sh</span><br><span class="line">64K</span><br><span class="line">* -h：输出文件系统分区使用的情况，例如：10KB，10MB，10GB等。</span><br><span class="line">* -s：显示文件或整个目录的大小，默认单位是KB。</span><br><span class="line">  !! du的详细信息可以通过 man du查看。</span><br><span class="line">  查看磁盘读写情况</span><br><span class="line"></span><br><span class="line">查看磁盘总体读写情况</span><br><span class="line"></span><br><span class="line">通iostat查看磁盘总体的读写情况：</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># iostat</span><br><span class="line">Linux 3.10.0-1062.el7.x86_64 (localhost.localdomain)    2020年05月02日  _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">0.17    0.00    0.20    0.46    0.00   99.17</span><br><span class="line"></span><br><span class="line">Device:            tps    kB_read&#x2F;s    kB_wrtn&#x2F;s    kB_read    kB_wrtn</span><br><span class="line">sda               1.56        30.45        39.61    4659620    6060644</span><br><span class="line">scd0              0.00         0.02         0.00       3102          0</span><br><span class="line">dm-0              1.96        30.01        38.42    4591998    5878155</span><br><span class="line">dm-1              0.09         0.09         0.30      13840      45328</span><br><span class="line">* tps：该设备每秒的传输次数。</span><br><span class="line">* kB_read&#x2F;s：每秒从设备（drive expressed）读取的数据量；</span><br><span class="line">* kB_wrtn&#x2F;s：每秒向设备（drive expressed）写入的数据量；</span><br><span class="line">* kB_read：读取的总数据量；</span><br><span class="line">* kB_wrtn：写入的总数量数据量；</span><br><span class="line">  查看磁盘详细读写情况</span><br><span class="line"></span><br><span class="line">通过iostat -x 1 3可以看到磁盘详细读写情况，没隔一秒输出一次一共输出3次，当看到I&#x2F;O等待时间所占CPU时间的比重很高的时候，首先要检查的就是机器是否正在大量使用交换空间，同时关注iowait占比cpu的消耗是否很大，如果大说明磁盘存在大的瓶颈，同时关注await，表示磁盘的响应时间以便小于5ms：</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># iostat -x 1 3</span><br><span class="line">Linux 3.10.0-1062.el7.x86_64 (localhost.localdomain)    2020年05月02日  _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">0.17    0.00    0.20    0.46    0.00   99.16</span><br><span class="line"></span><br><span class="line">Device:         rrqm&#x2F;s   wrqm&#x2F;s     r&#x2F;s     w&#x2F;s    rkB&#x2F;s    wkB&#x2F;s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.01     0.49    0.63    0.95    30.59    39.78    89.58     0.34  214.23   49.16  323.48   8.55   1.34</span><br><span class="line">scd0              0.00     0.00    0.00    0.00     0.02     0.00    98.48     0.00    1.21    1.21    0.00   0.95   0.00</span><br><span class="line">dm-0              0.00     0.00    0.62    1.35    30.15    38.59    69.70     0.91  460.67   49.12  648.54   6.66   1.31</span><br><span class="line">dm-1              0.00     0.00    0.02    0.07     0.09     0.30     8.52     0.04  442.74   95.43  521.17   6.91   0.06</span><br><span class="line">avg-cpu表示总体cpu使用情况统计信息，对于多核cpu，这里为所有cpu的平均值：</span><br><span class="line">* %user：CPU处在用户模式下的时间百分比。</span><br><span class="line">* %nice：CPU处在带NICE值的用户模式下的时间百分比。</span><br><span class="line">* %system：CPU处在系统模式下的时间百分比。</span><br><span class="line">* %iowait：CPU等待输入输出完成时间的百分比，如果%iowait的值过高，表示硬盘存在I&#x2F;O瓶颈。</span><br><span class="line">* %steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。</span><br><span class="line">* %idle：CPU空闲时间百分比，如果%idle值高，表示CPU较空闲；如果%idle值高但系统响应慢时，可能是CPU等待分配内存，应加大内存容量；如果%idle值持续低于10，表明CPU处理能力相对较低，系统中最需要解决的资源是CPU。。</span><br><span class="line">  Device表示设备信息：</span><br><span class="line">* rrqm&#x2F;s：每秒对该设备的读请求被合并次数，文件系统会对读取同块(block)的请求进行合并</span><br><span class="line">* wrqm&#x2F;s：每秒对该设备的写请求被合并次数</span><br><span class="line">* r&#x2F;s：每秒完成的读次数</span><br><span class="line">* w&#x2F;s：每秒完成的写次数</span><br><span class="line">* rkB&#x2F;s：每秒读数据量(kB为单位)</span><br><span class="line">* wkB&#x2F;s：每秒写数据量(kB为单位)</span><br><span class="line">* avgrq-sz：平均每次IO操作的数据量(扇区数为单位)</span><br><span class="line">* avgqu-sz：平均等待处理的IO请求队列长度</span><br><span class="line">* await：平均每次IO请求等待时间(包括等待时间和处理时间，毫秒为单位)</span><br><span class="line">* svctm：平均每次IO请求的处理时间(毫秒为单位)</span><br><span class="line">* %util：一秒中有百分之多少的时间用于 I&#x2F;O如果%util接近100%，说明产生的I&#x2F;O请求太多，I&#x2F;O系统已经满负荷。idle小于70% IO压力就较大了，一般读取速度有较多的wait。</span><br><span class="line">  !! iostat -xmd 1 3：新增m选项可以在输出是使用M为单位。</span><br><span class="line">  查看最耗IO的进程</span><br><span class="line"></span><br><span class="line">一般先通过iostat查看是否存在io瓶颈，再使用iotop命令来定位那个进程最耗费IO：</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># iotop</span><br><span class="line">Total DISK READ :       0.00 B&#x2F;s | Total DISK WRITE :       0.00 B&#x2F;s</span><br><span class="line">Actual DISK READ:       0.00 B&#x2F;s | Actual DISK WRITE:       0.00 B&#x2F;s</span><br><span class="line">TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND</span><br><span class="line">123931 be&#x2F;4 root        0.00 B&#x2F;s    0.00 B&#x2F;s  0.00 %  0.02 % [kworker&#x2F;1:30]</span><br><span class="line">94208 be&#x2F;4 xiaolyuh    0.00 B&#x2F;s    0.00 B&#x2F;s  0.00 %  0.00 % nautilus-desktop --force [gmain]</span><br><span class="line">1 be&#x2F;4 root        0.00 B&#x2F;s    0.00 B&#x2F;s  0.00 %  0.00 % systemd --system --deserialize 62</span><br><span class="line">2 be&#x2F;4 root        0.00 B&#x2F;s    0.00 B&#x2F;s  0.00 %  0.00 % [kthreadd]</span><br><span class="line">94211 be&#x2F;4 xiaolyuh    0.00 B&#x2F;s    0.00 B&#x2F;s  0.00 %  0.00 % gvfsd-trash --spawner :1.4 &#x2F;org&#x2F;gtk&#x2F;gvfs&#x2F;exec_spaw&#x2F;0</span><br><span class="line">4 be&#x2F;0 root        0.00 B&#x2F;s    0.00 B&#x2F;s  0.00 %  0.00 % [kworker&#x2F;0:0H]</span><br><span class="line">6 be&#x2F;4 root        0.00 B&#x2F;s    0.00 B&#x2F;s  0.00 %  0.00 % [ksoftirqd&#x2F;0]</span><br><span class="line">7 rt&#x2F;4 root        0.00 B&#x2F;s    0.00 B&#x2F;s  0.00 %  0.00 % [migration&#x2F;0]</span><br><span class="line">8 be&#x2F;4 root        0.00 B&#x2F;s    0.00 B&#x2F;s  0.00 %  0.00 % [rcu_bh]</span><br><span class="line">9 be&#x2F;4 root        0.00 B&#x2F;s    0.00 B&#x2F;s  0.00 %  0.00 % [rcu_sched]</span><br><span class="line">10 be&#x2F;0 root        0.00 B&#x2F;s    0.00 B&#x2F;s  0.00 %  0.00 % [lru-add-drain]</span><br><span class="line">...</span><br><span class="line">通过iotop -p pid可以查看单个进程的IO情况：</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># iotop -p 124146</span><br><span class="line">Total DISK READ :       0.00 B&#x2F;s | Total DISK WRITE :       0.00 B&#x2F;s</span><br><span class="line">Actual DISK READ:       0.00 B&#x2F;s | Actual DISK WRITE:       0.00 B&#x2F;s</span><br><span class="line">TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND</span><br><span class="line">124146 be&#x2F;4 root        0.00 B&#x2F;s    0.00 B&#x2F;s  0.00 %  0.00 % java -jar arthas-demo.jar</span><br><span class="line">应用瓶颈</span><br><span class="line"></span><br><span class="line">查看某个进程的PID</span><br><span class="line"></span><br><span class="line">如查看java的进程的pid，ps -ef | grep java:</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># ps -ef | grep java</span><br><span class="line">root     124146   1984  0 09:13 pts&#x2F;0    00:00:06 java -jar arthas-demo.jar</span><br><span class="line">root     125210  98378  0 10:07 pts&#x2F;1    00:00:00 grep --color&#x3D;auto java</span><br><span class="line">查看特定进程的数量</span><br><span class="line"></span><br><span class="line">如查看java进程的数量,ps -ef | grep java| wc -l：</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># ps -ef | grep java| wc -l</span><br><span class="line">2</span><br><span class="line">查看线程是否存在死锁</span><br><span class="line"></span><br><span class="line">查看线程是否存在死锁，jstack -l pid：</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># jstack -l 124146</span><br><span class="line">2020-05-02 10:13:38</span><br><span class="line">Full thread dump OpenJDK 64-Bit Server VM (25.252-b09 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;C1 CompilerThread1&quot;</span><br><span class="line"></span><br><span class="line">#6 daemon prio&#x3D;9 os_prio&#x3D;0 tid&#x3D;0x00007f27f013c000 nid&#x3D;0x1e4f9 waiting on condition [0x0000000000000000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">Locked ownable synchronizers:</span><br><span class="line">- None</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread0&quot;</span><br><span class="line"></span><br><span class="line">#5 daemon prio&#x3D;9 os_prio&#x3D;0 tid&#x3D;0x00007f27f012d000 nid&#x3D;0x1e4f8 waiting on condition [0x0000000000000000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">Locked ownable synchronizers:</span><br><span class="line">- None</span><br><span class="line"></span><br><span class="line">&quot;main&quot;</span><br><span class="line"></span><br><span class="line">#1 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x00007f27f004b800 nid&#x3D;0x1e4f3 waiting on condition [0x00007f27f7274000]</span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at java.lang.Thread.sleep(Thread.java:340)</span><br><span class="line">at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)</span><br><span class="line">at demo.MathGame.main(MathGame.java:17)</span><br><span class="line"></span><br><span class="line">Locked ownable synchronizers:</span><br><span class="line">- None</span><br><span class="line">...</span><br><span class="line">查看某个进程的线程数</span><br><span class="line"></span><br><span class="line">ps -efL | grep [PID] | wc -l，如：</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># ps -efL | grep 124146 | wc -l</span><br><span class="line">12</span><br><span class="line">查看具体有哪些线程用ps -Lp [pid] cu:</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># ps -Lp 124146 cu</span><br><span class="line">USER        PID    LWP %CPU NLWP %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root     124146 124146  0.0   11  2.5 2489116 35724 pts&#x2F;0   Sl+  09:13   0:00 java</span><br><span class="line">root     124146 124147  0.0   11  2.5 2489116 35724 pts&#x2F;0   Sl+  09:13   0:01 java</span><br><span class="line">root     124146 124148  0.0   11  2.5 2489116 35724 pts&#x2F;0   Sl+  09:13   0:00 VM Thread</span><br><span class="line">root     124146 124149  0.0   11  2.5 2489116 35724 pts&#x2F;0   Sl+  09:13   0:00 Reference Handl</span><br><span class="line">root     124146 124150  0.0   11  2.5 2489116 35724 pts&#x2F;0   Sl+  09:13   0:00 Finalizer</span><br><span class="line">root     124146 124151  0.0   11  2.5 2489116 35724 pts&#x2F;0   Sl+  09:13   0:00 Signal Dispatch</span><br><span class="line">root     124146 124152  0.0   11  2.5 2489116 35724 pts&#x2F;0   Sl+  09:13   0:00 C2 CompilerThre</span><br><span class="line">root     124146 124153  0.0   11  2.5 2489116 35724 pts&#x2F;0   Sl+  09:13   0:00 C1 CompilerThre</span><br><span class="line">root     124146 124154  0.0   11  2.5 2489116 35724 pts&#x2F;0   Sl+  09:13   0:00 Service Thread</span><br><span class="line">root     124146 124155  0.1   11  2.5 2489116 35724 pts&#x2F;0   Sl+  09:13   0:05 VM Periodic Tas</span><br><span class="line">root     124146 125362  0.0   11  2.5 2489116 35724 pts&#x2F;0   Sl+  10:13   0:00 Attach Listener</span><br><span class="line">统计所有的log文件中，包含Error字符的行</span><br><span class="line"></span><br><span class="line">find &#x2F; -type f -name &quot;*.log&quot; | xargs grep &quot;ERROR&quot;，这个在排查问题过程中比较有用：</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># find &#x2F; -type f -name &quot;*.log&quot; | xargs grep &quot;ERROR&quot;</span><br><span class="line">&#x2F;var&#x2F;</span><br><span class="line">log</span><br><span class="line">&#x2F;tuned&#x2F;tuned.log:2020-03-13 18:05:59,145 ERROR    tuned.utils.commands: Writing to file</span><br><span class="line">&#39;&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreq&#x2F;scaling_governor&#39;</span><br><span class="line">error:</span><br><span class="line">&#39;[Errno 19] No such device&#39;</span><br><span class="line">&#x2F;var&#x2F;</span><br><span class="line">log</span><br><span class="line">&#x2F;tuned&#x2F;tuned.log:2020-03-13 18:05:59,145 ERROR    tuned.utils.commands: Writing to file</span><br><span class="line">&#39;&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu1&#x2F;cpufreq&#x2F;scaling_governor&#39;</span><br><span class="line">error:</span><br><span class="line">&#39;[Errno 19] No such device&#39;</span><br><span class="line">&#x2F;var&#x2F;</span><br><span class="line">log</span><br><span class="line">&#x2F;tuned&#x2F;tuned.log:2020-04-28 14:55:34,857 ERROR    tuned.utils.commands: Writing to file</span><br><span class="line">&#39;&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreq&#x2F;scaling_governor&#39;</span><br><span class="line">error:</span><br><span class="line">&#39;[Errno 19] No such device&#39;</span><br><span class="line">&#x2F;var&#x2F;</span><br><span class="line">log</span><br><span class="line">&#x2F;tuned&#x2F;tuned.log:2020-04-28 14:55:34,859 ERROR    tuned.utils.commands: Writing to file</span><br><span class="line">&#39;&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu1&#x2F;cpufreq&#x2F;scaling_governor&#39;</span><br><span class="line">error:</span><br><span class="line">&#39;[Errno 19] No such device&#39;</span><br><span class="line">&#x2F;var&#x2F;</span><br><span class="line">log</span><br><span class="line">&#x2F;tuned&#x2F;tuned.log:2020-04-28 15:23:19,037 ERROR    tuned.utils.commands: Writing to file</span><br><span class="line">&#39;&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreq&#x2F;scaling_governor&#39;</span><br><span class="line">error:</span><br><span class="line">&#39;[Errno 19] No such device&#39;</span><br><span class="line">...</span><br><span class="line">应用启动时指定JVM参数</span><br><span class="line"></span><br><span class="line">java -jar -Xms128m -Xmx1024m -Xss512k -XX:PermSize&#x3D;128m -XX:MaxPermSize&#x3D;64m -XX:NewSize&#x3D;64m -XX:MaxNewSize&#x3D;256m arthas-demo.jar，如：</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># java -jar -Xms128m -Xmx1024m -Xss512k -XX:PermSize&#x3D;128m -XX:MaxPermSize&#x3D;64m -XX:NewSize&#x3D;64m -XX:MaxNewSize&#x3D;256m  arthas-demo.jar</span><br><span class="line">OpenJDK 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed</span><br><span class="line">in</span><br><span class="line">8.0</span><br><span class="line">OpenJDK 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;64m; support was removed</span><br><span class="line">in</span><br><span class="line">8.0</span><br><span class="line">157518&#x3D;2*3*3*3*2917</span><br><span class="line">illegalArgumentCount:  1, number is: -187733, need &gt;&#x3D; 2</span><br><span class="line">illegalArgumentCount:  2, number is: -102156, need &gt;&#x3D; 2</span><br><span class="line">173379&#x3D;3*57793</span><br><span class="line">总结</span><br><span class="line"></span><br><span class="line">在使用linux命令时，如果想看帮助可以使用--help或者man查看帮助信息：</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># grep --help</span><br><span class="line">用法: grep [选项]... PATTERN [FILE]...</span><br><span class="line">在每个 FILE 或是标准输入中查找 PATTERN。</span><br><span class="line">默认的 PATTERN 是一个基本正则表达式(缩写为 BRE)。</span><br><span class="line">例如: grep -i</span><br><span class="line">&#39;hello world&#39;</span><br><span class="line">menu.h main.c</span><br><span class="line">...</span><br><span class="line">[root@localhost ~]</span><br><span class="line"># man grep</span><br><span class="line"></span><br><span class="line">GREP(1)                                                        General Commands Manual                                                        GREP(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">grep, egrep, fgrep - 打印匹配给定模式的行</span><br><span class="line"></span><br><span class="line">总览 SYNOPSIS</span><br><span class="line">grep [options] PATTERN [FILE...]</span><br><span class="line">grep [options] [-e PATTERN | -f FILE] [FILE...]</span><br><span class="line"></span><br><span class="line">描述 DESCRIPTION</span><br><span class="line">Grep    搜索以    FILE    命名的文件输入   (或者是标准输入，如果没有指定文件名，或者给出的文件名是   -   的话)，寻找含有与给定的模式   PATTERN</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">类别	监控命令	描述	备注</span><br><span class="line">内存瓶颈	free	查看内存使用</span><br><span class="line"></span><br><span class="line">vmstat 3(间隔时间) 100(监控次数)	查看swap in&#x2F;out详细定位是否存在性能瓶颈	推荐使用</span><br><span class="line"></span><br><span class="line">sar -r 3	和free命令类似，查看内存的使用情况，但是不包含swap的情况</span><br><span class="line">cpu瓶颈	top -H	按照cpu消耗高低进行排序</span><br><span class="line"></span><br><span class="line">ps -Lp 进程号 cu	查看某个进程的cpu消耗排序</span><br><span class="line"></span><br><span class="line">cat &#x2F;proc&#x2F;cpuinfo |grep &#39;processor&#39;|wc -l	查看cpu核数</span><br><span class="line"></span><br><span class="line">top	查看cpu总体消耗，包括分项消耗如user,system,idle,nice等消耗</span><br><span class="line"></span><br><span class="line">top 然后shift+h:显示java线程，然后shift+M:按照内存使用进行排序；shift+P:按照cpu时间排序;shift+T:按照cpu累计使用时间排序多核cpu，按“1”进入top视图	专项性能排查，多核CPU主要看CUP各个内核的负载情况</span><br><span class="line"></span><br><span class="line">sar -u 3(间隔时间)	查看cpu总体消耗占比</span><br><span class="line"></span><br><span class="line">sar -q	查看cpu load</span><br><span class="line"></span><br><span class="line">top -b -n 1 | awk &#39;&#123;if (NR&lt;&#x3D;7)print;else if($8&#x3D;&#x3D;&quot;D&quot;)&#123;print;count++&#125;&#125;END&#123;print &quot;Total status D:&quot;count&#125;&#39;	计算在cpu load里面的uninterruptedsleep的任务数量 uninterruptedsleep的任务会被计入cpu load，如磁盘堵塞</span><br><span class="line">网络瓶颈	cat &#x2F;var&#x2F;log&#x2F;messages	查看内核日志，查看是否丢包</span><br><span class="line"></span><br><span class="line">watch more &#x2F;proc&#x2F;net&#x2F;dev	用于定位丢包，错包情况，以便看网络瓶颈	重点关注drop(包被丢弃)和网络包传送的总量，不要超过网络上限</span><br><span class="line"></span><br><span class="line">sar -n SOCK	查看网络流量</span><br><span class="line"></span><br><span class="line">netstat -na|grep ESTABLISHED|wc -l	查看tcp连接成功状态的数量	此命令特别消耗cpu，不适合进行长时间监控数据收集</span><br><span class="line"></span><br><span class="line">netstat -na|awk&#39;&#123;print $6&#125;&#39;|sort |uniq -c |sort -nr	看tcp各个状态数量</span><br><span class="line"></span><br><span class="line">netstat -i	查看网络错误</span><br><span class="line"></span><br><span class="line">ss state ESTABLISHED| wc -l	更高效地统计tcp连接状态为ESTABLISHED的数量</span><br><span class="line"></span><br><span class="line">cat &#x2F;proc&#x2F;net&#x2F;snmp	查看和分析240秒内网络包量，流量，错包，丢包	用于计算重传率tcpetr&#x3D;RetransSegs&#x2F;OutSegs</span><br><span class="line"></span><br><span class="line">ping $ip	测试网络性能</span><br><span class="line"></span><br><span class="line">traceroute $ip	查看路由经过的地址	常用于定位网络在各个路由区段的耗时</span><br><span class="line"></span><br><span class="line">dig $域名	查看域名解析地址</span><br><span class="line"></span><br><span class="line">dmesg	查看系统内核日志</span><br><span class="line">磁盘瓶颈	iostat -x -k -d 1	详细列出磁盘的读写情况	当看到I&#x2F;O等待时间所占CPU时间的比重很高的时候，首先要检查的就是机器是否正在大量使用交换空间，同时关注iowait占比cpu的消耗是否很大，如果大说明磁盘存在大的瓶颈，同时关注await，表示磁盘的响应时间以便小于5ms</span><br><span class="line"></span><br><span class="line">iostat -x	查看系统各个磁盘的读写性能	重点关注await和iowait的cpu占比</span><br><span class="line"></span><br><span class="line">iotop	查看哪个进程在大量读取IO	一般先通过iostat查看是否存在io瓶颈，再定位哪个进程在大量读取IO</span><br><span class="line"></span><br><span class="line">df -hl	查看磁盘剩余空间</span><br><span class="line"></span><br><span class="line">du -sh	查看磁盘使用了多少空间</span><br><span class="line">应用瓶颈	ps -ef	grep java	查看某个进程的id号</span><br><span class="line"></span><br><span class="line">ps -ef | grep httpd| wc -l	查看特定进程的数量</span><br><span class="line"></span><br><span class="line">cat *** .log | grep *** Exception| wc -l	统计日志文件中包含特定异常数量</span><br><span class="line"></span><br><span class="line">jstack -l pid	用于查看线程是否存在死锁</span><br><span class="line"></span><br><span class="line">awk&#39;&#123;print $8&#125;&#39; 2017-05-22-access_log|egrep &#39;301|302&#39;| wc -l	统计log中301、302状态码的行数，$8表示第八列是状态码，可以根据实际情况更改	常用于应用故障定位</span><br><span class="line"></span><br><span class="line">grep &#39;wholesaleProductDetailNew&#39; cookie_log | awk &#39;&#123;if($10&#x3D;&#x3D;&quot;200&quot;)&#125;&#39;print&#125;&#39;	awk &#39;print $12&#39; | more	打印包含特定数据的12列数据</span><br><span class="line"></span><br><span class="line">grep &quot;2017:05:22&quot; cookielog | awk &#39;($12&gt;0.3)&#123;print 8&#125;&#39; | sort &gt; 目录地址	对apache或者nginx访问log进行响应时间排序，$12表示cookie log中的12列表示响应时间 用于排查是否是由于是某些访问超长造成整体的RT变长</span><br><span class="line"></span><br><span class="line">grep -v &#39;HTTP&#x2F;1.1&quot; 200&#39;	取出非200响应码的URL</span><br><span class="line"></span><br><span class="line">pgm -A -f $应用集群名称 &quot;grep &quot;&#39;301&#39; log文件地址 | wc -l&quot;	查看整个集群的log中301状态码的数量</span><br><span class="line"></span><br><span class="line">ps -efL | grep [PID] | wc -l	查看某个进程创建的线程数</span><br><span class="line"></span><br><span class="line">find &#x2F; -type f -name &quot; * .log&quot; | xargs grep &quot;ERROR&quot;	统计所有的log文件中，包含Error字符的行	这个在排查问题过程中比较有用</span><br><span class="line"></span><br><span class="line">jstat -gc [pid]	查看gc情况</span><br><span class="line"></span><br><span class="line">jstat -gcnew [pid]	查看young区的内存使用情况，包括MTT(最大交互次数就被交换到old区)，TT是目前已经交换的次数</span><br><span class="line"></span><br><span class="line">jstat -gcold	查看old区的内存使用情况</span><br><span class="line"></span><br><span class="line">jmap -J-d64 -dump:format&#x3D;b,file&#x3D;dump.bin PID	dump出内存快照	-J-d64防止jmap导致虚拟机crash(jdk6有bug)</span><br><span class="line"></span><br><span class="line">-XX:+HeapDumpOnOutOfMemeryError	在java启动时加入，当出现内存溢出时，存储内存快照</span><br><span class="line"></span><br><span class="line">jmap -histo [pid]	按照对象内存大小排序	注意会导致full gc</span><br><span class="line"></span><br><span class="line">gcore [pid]	导出完成的内存快照	通常和jmap -permstat &#x2F;opt&#x2F; ** &#x2F;java gcore.bin一起使用，将core dump转换成heap dump</span><br><span class="line"></span><br><span class="line">-XX:HeapDumpPath&#x3D;&#x2F;home&#x2F;logs -Xloggc:&#x2F;home&#x2F;log&#x2F;gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps	在Java启动参数中加入，打印gc日志</span><br><span class="line"></span><br><span class="line">-server -Xms4000m -Xmx4000m -Xmn1500m -Xss256k -XX:PermSize&#x3D;340m -XX:MaxPermSize&#x3D;340m -XX:+UseConcMarkSweepGC	调整JVM堆大小	xss是栈大小</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>代码中特殊注释——TODO、FIXME、XXX、HACK</title>
    <url>/2021/04/14/%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%89%B9%E6%AE%8A%E6%B3%A8%E9%87%8A%E2%80%94%E2%80%94TODO%E3%80%81FIXME%E3%80%81XXX%E3%80%81HACK/</url>
    <content><![CDATA[<h1 id="代码中特殊注释——TODO、FIXME、XXX、HACK"><a href="#代码中特殊注释——TODO、FIXME、XXX、HACK" class="headerlink" title="代码中特殊注释——TODO、FIXME、XXX、HACK"></a>代码中特殊注释——TODO、FIXME、XXX、HACK</h1><h2 id="TODO-待办事项。若代码中有这个标识，则说明此处代码还未完成，待完成的功能会在说明中简略说明。"><a href="#TODO-待办事项。若代码中有这个标识，则说明此处代码还未完成，待完成的功能会在说明中简略说明。" class="headerlink" title="TODO 待办事项。若代码中有这个标识，则说明此处代码还未完成，待完成的功能会在说明中简略说明。"></a>TODO 待办事项。若代码中有这个标识，则说明此处代码还未完成，待完成的功能会在说明中简略说明。</h2><h2 id="XXX-此标识说明代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。"><a href="#XXX-此标识说明代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。" class="headerlink" title="XXX 此标识说明代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。"></a>XXX 此标识说明代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。</h2><h2 id="HACK-英语翻译为砍，如果代码中有该标识，说明标识处代码是我们需要根据自己的需求去调整程序代码。"><a href="#HACK-英语翻译为砍，如果代码中有该标识，说明标识处代码是我们需要根据自己的需求去调整程序代码。" class="headerlink" title="HACK 英语翻译为砍，如果代码中有该标识，说明标识处代码是我们需要根据自己的需求去调整程序代码。"></a>HACK 英语翻译为砍，如果代码中有该标识，说明标识处代码是我们需要根据自己的需求去调整程序代码。</h2><h2 id="FIXME-可以拆解成短语，fix-me，意为修理我。若代码中有该标识，说明标识代码需要修改，甚至是错误的，不能工作，需要修复，如何修正会在说明中简略说明。"><a href="#FIXME-可以拆解成短语，fix-me，意为修理我。若代码中有该标识，说明标识代码需要修改，甚至是错误的，不能工作，需要修复，如何修正会在说明中简略说明。" class="headerlink" title="FIXME 可以拆解成短语，fix me，意为修理我。若代码中有该标识，说明标识代码需要修改，甚至是错误的，不能工作，需要修复，如何修正会在说明中简略说明。"></a>FIXME 可以拆解成短语，fix me，意为修理我。若代码中有该标识，说明标识代码需要修改，甚至是错误的，不能工作，需要修复，如何修正会在说明中简略说明。</h2><h2 id="NOTE-汝等凡人"><a href="#NOTE-汝等凡人" class="headerlink" title="NOTE 汝等凡人"></a>NOTE 汝等凡人</h2><p>Description of how the code works (when it isn’t self evident)</p>
<h2 id="BUG-丢锅埋雷挖坑"><a href="#BUG-丢锅埋雷挖坑" class="headerlink" title="BUG: 丢锅埋雷挖坑"></a>BUG: 丢锅埋雷挖坑</h2><p>There is a problem here.</p>
]]></content>
  </entry>
  <entry>
    <title>谷粒商城分布式分布式基础概念</title>
    <url>/2021/04/18/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E5%88%86%E5%B8%83%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h2><ul>
<li>Nacos注册中心</li>
<li>Nacos配置中心</li>
<li>Seata分布式事务</li>
<li>Sentinel服务容错</li>
<li>Feign远程调用&amp;负载均衡</li>
<li>Gateway网关</li>
<li>Sleuth服务追踪</li>
<li>Zipkin可视化追踪</li>
</ul>
<h2 id="应用监控"><a href="#应用监控" class="headerlink" title="应用监控"></a>应用监控</h2><ul>
<li>Prometheus</li>
<li>Grafana</li>
</ul>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>跨域：指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是<br>浏览器对javascript施加的安全限制。</p>
<p>同源策略:是指协议，域名，端口都要相同，其中有一个不同都会产生跨域;</p>
<h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><p>解决跨域-(一)使用nginx部署为同一域</p>
<p>解决跨域-(二)配置当次请求允许跨域</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、添加响应头</span><br><span class="line">• Access-Control-Allow-Origin:支持哪些来源的请求跨域</span><br><span class="line">• Access-Control-Allow-Methods:支持哪些方法跨域</span><br><span class="line">• Access-Control-Allow-Credentials:跨域请求默认不包含cookie，设置为true可以包含 cookie</span><br><span class="line">• Access-Control-Expose-Headers:跨域请求暴露的字段</span><br><span class="line">• CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段: Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如 果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。</span><br><span class="line">• Access-Control-Max-Age:表明该响应的有效时间为多少秒。在有效时间内，浏览器无 须为同一请求再次发起预检请求。请注意，浏览器自身维护了一个最大有效时间，如果 该首部字段的值超过了最大有效时间，将不会生效。</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分布式基础篇总结</p>
<p>• 1、分布式基础概念</p>
<p>• 微服务、注册中心、配置中心、远程调用、Feign、网关</p>
<p>• 2、基础开发</p>
<p>• SpringBoot2.0、SpringCloud、Mybatis-Plus、Vue组件化、阿里云对象存储</p>
<p>• 3、环境</p>
<p>• Vagrant、Linux、Docker、MySQL、Redis、逆向工程&amp;人人开源</p>
<p>• 4、开发规范</p>
<p>• 数据校验JSR303、全局异常处理、全局统一返回、全局跨域处理 • 枚举状态、业务状态码、VO与TO与PO划分、逻辑删除</p>
<p>• Lombok:@Data、@Slf4j</p>
]]></content>
  </entry>
  <entry>
    <title>ElasticSearch背后的核心理念</title>
    <url>/2021/04/18/ElasticSearch%E8%83%8C%E5%90%8E%E7%9A%84%E6%A0%B8%E5%BF%83%E7%90%86%E5%BF%B5/</url>
    <content><![CDATA[<p>ElasticSearch是构建在极少数的几个概念之上的。ElasticSearch的开发团队希望它能够快速上手，可扩展性强。而且这些核心特性体现在ElasticSearch的各个方面。从架构的角度来看，这些主要特性是：</p>
<ul>
<li><p>开箱即用。安装好ElasticSearch后，所有参数的默认值都自动进行了比较合理的设置，基本不需要额外的调整。包括内置的发现机制(比如Field类型的自动匹配)和自动化参数配置。</p>
</li>
<li><p>天生集群。ElasticSearch默认工作在集群模式下。节点都将视为集群的一部分，而且在启动的过程中自动连接到集群中。</p>
</li>
<li><p>自动容错。ElasticSearch通过P2P网络进行通信，这种工作方式消除了单点故障。节点自动连接到集群中的其它机器，自动进行数据交换及以节点之间相互监控。索引分片</p>
</li>
<li><p>扩展性强。无论是处理能力和数据容量上都可以通过一种简单的方式实现扩展，即增添新的节点。</p>
</li>
<li><p>近实时搜索和版本控制。由于ElasticSearch天生支持分布式，所以延迟和不同节点上数据的短暂性不一致无可避免。ElasticSearch通过版本控制(versioning)的机制尽量减少问题的出现。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>ElasticSearch的工作原理</title>
    <url>/2021/04/18/ElasticSearch%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><p>当ElasticSearch的节点启动后，它会利用多播(multicast)(或者单播，如果用户更改了配置)寻找集群中的其它节点，并与之建立连接。</p>
<p>在集群中，一个节点被选举成主节点(master node)。这个节点负责管理集群的状态，当群集的拓扑结构改变时把索引分片分派到相应的节点上。</p>
<h2 id="ElasticSearch如何建立索引"><a href="#ElasticSearch如何建立索引" class="headerlink" title="ElasticSearch如何建立索引"></a>ElasticSearch如何建立索引</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">索引的不变性</span><br><span class="line">由于倒排索引的结构特性，在索引建立完成后对其进行修改将会非常复杂。再加上几层索引嵌套，更让索引的更新变成了几乎不可能的动作。</span><br><span class="line">所以索性设计成不可改变的：倒排索引被写入磁盘后是不可改变的，它永远不会修改。</span><br><span class="line"></span><br><span class="line">不变性有重要的价值：</span><br><span class="line">1.不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。</span><br><span class="line">2.一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。</span><br><span class="line">3.其它缓存(像filter缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。</span><br><span class="line">4.写入单个大的倒排索引允许数据压缩，减少磁盘 I&#x2F;O 和 需要被缓存到内存的索引的使用量。</span><br></pre></td></tr></table></figure>




]]></content>
  </entry>
  <entry>
    <title>ElasticSearch概念-基础概念</title>
    <url>/2021/04/18/ElasticSearch%E6%A6%82%E5%BF%B5-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="索引-Index"><a href="#索引-Index" class="headerlink" title="索引(Index)"></a>索引(Index)</h2><p>ElasticSearch把数据存放到一个或者多个索引(indices)中。如果用关系型数据库模型对比，索引(index)的地位与数据库实例(database)相当。索引存放和读取的基本单元是文档(Document)。我们也一再强调，ElasticSearch内部用Apache Lucene实现索引中数据的读写。读者应该清楚的是：在ElasticSearch中被视为单独的一个索引(index)，在Lucene中可能不止一个。这是因为在分布式体系中，ElasticSearch会用到分片(shards)和备份(replicas)机制将一个索引(index)存储多份。</p>
<h2 id="文档-Document"><a href="#文档-Document" class="headerlink" title="文档(Document)"></a>文档(Document)</h2><p>在ElasticSearch的世界中，文档(Document)是主要的存在实体(在Lucene中也是如此)。所有的ElasticSearch应用需求到最后都可以统一建模成一个检索模型：检索相关文档。文档(Document)由一个或者多个域(Field)组成，每个域(Field)由一个域名(此域名非彼域名)和一个或者多个值组成(有多个值的值称为多值域(multi-valued))。在ElasticSeach中，每个文档(Document)都可能会有不同的域(Field)集合；也就是说文档(Document)是没有固定的模式和统一的结构。文档(Document)之间保持结构的相似性即可(Lucene中的文档(Document)也秉持着相同的规定)。实际上，ElasticSearch中的文档(Document)就是Lucene中的文档(Document)。从客户端的角度来看，文档(Document)就是一个JSON对象(关于JSON格式的相关信息,请参看hhtp://en.wikipedia.org/wiki/JSON)。</p>
<h3 id="参数映射-Mapping"><a href="#参数映射-Mapping" class="headerlink" title="参数映射(Mapping)"></a>参数映射(Mapping)</h3><p>在  1.1节 认识Apache Lucene  中已经提到，所有的文档(Document)在存储之前都必须经过分析(analyze)流程。用户可以配置输入文本分解成Token的方式；哪些Token应该被过滤掉；或者其它的的处理流程，比如去除HTML标签。此外，ElasticSearch提供的各种特性，比如排序的相关信息。保存上述的配置信息，这就是参数映射(Mapping)在ElasticSearch中扮演的角色。尽管ElasticSearch可以根据域的值自动识别域的类型(field type)，在生产应用中，都是需要自己配置这些信息以避免一些奇的问题发生。要保证应用的可控性。</p>
<h2 id="文档类型-Type"><a href="#文档类型-Type" class="headerlink" title="文档类型(Type)"></a>文档类型(Type)</h2><p>每个文档在ElasticSearch中都必须设定它的类型。文档类型使得同一个索引中在存储结构不同文档时，只需要依据文档类型就可以找到对应的参数映射(Mapping)信息，方便文档的存取。</p>
<h2 id="节点-Node"><a href="#节点-Node" class="headerlink" title="节点(Node)"></a>节点(Node)</h2><p>单独一个ElasticSearch服务器实例称为一个节点。对于许多应用场景来说，部署一个单节点的ElasticSearch服务器就足够了。但是考虑到容错性和数据过载，配置多节点的ElasticSearch集群是明智的选择。</p>
<h2 id="集群-Cluster"><a href="#集群-Cluster" class="headerlink" title="集群(Cluster)"></a>集群(Cluster)</h2><p>集群是多个ElasticSearch节点的集合。这些节点齐心协力应对单个节点无法处理的搜索需求和数据存储需求。集群同时也是应对由于部分机器(节点)运行中断或者升级导致无法提供服务这一问题的利器。ElasticSearch提供的集群各个节点几乎是无缝连接(所谓无缝连接，即集群对外而言是一个整体，增加一个节点或者去掉一个节点对用户而言是透明的&lt;个人理解，仅供参考&gt;)。在ElasticSearch中配置一个集群非常简单，在我们看来，这是在与同类产品中竞争所体现出的最大优势。</p>
<h2 id="分片索引-Shard"><a href="#分片索引-Shard" class="headerlink" title="分片索引(Shard)"></a>分片索引(Shard)</h2><p>前面已经提到，集群能够存储超出单机容量的信息。为了实现这种需求，ElasticSearch把数据分发到多个存储Lucene索引的物理机上。这些Lucene索引称为分片索引，这个分发的过程称为索引分片(Sharding)。在ElasticSearch集群中，索引分片(Sharding)是自动完成的，而且所有分片索引(Shard)是作为一个整体呈现给用户的。需要注意的是，尽管索引分片这个过程是自动的，但是在应用中需要事先调整好参数。因为集群中分片的数量需要在索引创建前配置好，而且服务器启动后是无法修改的，至少目前无法修改。</p>
<h2 id="索引副本-Replica"><a href="#索引副本-Replica" class="headerlink" title="索引副本(Replica)"></a>索引副本(Replica)</h2><p>通过索引分片机制(Sharding)可以向ElasticSearch集群中导入超过单机容量的数据，客户端操作任意一个节点即可实现对集群数据的读写操作。当集群负载增长，用户搜索请求阻塞在单个节点上时，通过索引副本(Replica)机制就可以解决这个问题。索引副本(Replica)机制的的思路很简单：为索引分片创建一份新的拷贝，它可以像原来的主分片一样处理用户搜索请求。同时也顺便保证了数据的安全性。即如果主分片数据丢失，ElasticSearch通过索引副本使得数据不丢失。索引副本可以随时添加或者删除，所以用户可以在需要的时候动态调整其数量。</p>
<h2 id="时间之门-Gateway"><a href="#时间之门-Gateway" class="headerlink" title="时间之门(Gateway)"></a>时间之门(Gateway)</h2><p>在运行的过程中，ElasticSearch会收集集群的状态、索引的参数等信息。这些数据被存储在Gateway中。</p>
]]></content>
  </entry>
  <entry>
    <title>Electron教程</title>
    <url>/2021/06/09/Electron%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://www.electronjs.org/" target="_blank" rel="noopener">官网</a><br><a href="https://www.w3cschool.cn/electronmanual/lz4y1ql3.html" target="_blank" rel="noopener">w3c教程</a><br><a href="https://zh.wikipedia.org/wiki/Electron" target="_blank" rel="noopener">维基</a><br><a href="https://search.bilibili.com/all?keyword=Electron%E6%95%99%E7%A8%8B&from_source=web_search" target="_blank" rel="noopener">bilibili</a><br><a href="https://www.google.com.hk/search?q=mac+%E6%90%AD%E5%BB%BAElectron%E7%8E%AF%E5%A2%83&oq=mac+%E6%90%AD%E5%BB%BAElectron%E7%8E%AF%E5%A2%83&aqs=chrome..69i57.13096j0j4&sourceid=chrome&ie=UTF-8" target="_blank" rel="noopener">mac 搭建Electron环境</a></p>
]]></content>
      <categories>
        <category>Electron</category>
      </categories>
      <tags>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title>java9JShell</title>
    <url>/2021/06/12/java9JShell/</url>
    <content><![CDATA[<h1 id="Java-9-REPL-JShell"><a href="#Java-9-REPL-JShell" class="headerlink" title="Java 9 REPL (JShell)"></a>Java 9 REPL (JShell)</h1><p>REPL(Read Eval Print Loop)意为交互式的编程环境。</p>
<p>JShell 是 Java 9 新增的一个交互式的编程环境工具。它允许你无需使用类或者方法包装来执行 Java 语句。它与 Python 的解释器类似，可以直接 输入表达式并查看其执行结果。</p>
<p>执行 JSHELL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ jshell</span><br><span class="line">|  Welcome to JShell -- Version 9-ea</span><br><span class="line">|  For an introduction type: &#x2F;help intro</span><br><span class="line">jshell&gt;</span><br></pre></td></tr></table></figure>
<p>查看 JShell 命令</p>
<p>输入 /help 可以查看 JShell相关的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jshell&gt; &#x2F;help</span><br><span class="line">|  Type a Java language expression, statement, or declaration.</span><br><span class="line">|  Or type one of the following commands:</span><br><span class="line">|  &#x2F;list [&lt;name or id&gt;|-all|-start]</span><br><span class="line">|  list the source you have typed</span><br><span class="line">|  &#x2F;edit &lt;name or id&gt;</span><br><span class="line">|  edit a source entry referenced by name or id</span><br><span class="line">|  &#x2F;drop &lt;name or id&gt;</span><br><span class="line">|  delete a source entry referenced by name or id</span><br><span class="line">|  &#x2F;save [-all|-history|-start] &lt;file&gt;</span><br><span class="line">|  Save snippet source to a file.</span><br><span class="line">|  &#x2F;open &lt;file&gt;</span><br><span class="line">|  open a file as source input</span><br><span class="line">|  &#x2F;vars [&lt;name or id&gt;|-all|-start]</span><br><span class="line">|  list the declared variables and their values</span><br><span class="line">|  &#x2F;methods [&lt;name or id&gt;|-all|-start]</span><br><span class="line">|  list the declared methods and their signatures</span><br><span class="line">|  &#x2F;types [&lt;name or id&gt;|-all|-start]</span><br><span class="line">|  list the declared types</span><br><span class="line">|  &#x2F;imports </span><br><span class="line">|  list the imported items</span><br></pre></td></tr></table></figure>
<p>执行 JShell 命令<br>/imports 命令用于查看已导入的包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jshell&gt; &#x2F;imports</span><br><span class="line">|    import java.io.*</span><br><span class="line">|    import java.math.*</span><br><span class="line">|    import java.net.*</span><br><span class="line">|    import java.nio.file.*</span><br><span class="line">|    import java.util.*</span><br><span class="line">|    import java.util.concurrent.*</span><br><span class="line">|    import java.util.function.*</span><br><span class="line">|    import java.util.prefs.*</span><br><span class="line">|    import java.util.regex.*</span><br><span class="line">|    import java.util.stream.*</span><br><span class="line">jshell&gt;</span><br></pre></td></tr></table></figure>
<p>JShell 执行计算<br>以下实例执行 JShell 简单计算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jshell&gt; 3+1</span><br><span class="line">$1 &#x3D;&#x3D;&gt; 4</span><br><span class="line">jshell&gt; 13%7</span><br><span class="line">$2 &#x3D;&#x3D;&gt; 6</span><br><span class="line">jshell&gt; $2</span><br><span class="line">$2 &#x3D;&#x3D;&gt; 6</span><br><span class="line">jshell&gt;</span><br></pre></td></tr></table></figure>
<p>JShell 创建与使用函数<br>创建一个函数 doubled() ，将传入的整型参数乘于 2 后返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jshell&gt; int doubled(int i)&#123; return i*2;&#125;</span><br><span class="line">|  created method doubled(int)</span><br><span class="line">jshell&gt; doubled(6)</span><br><span class="line">$3 &#x3D;&#x3D;&gt; 12</span><br><span class="line">jshell&gt;</span><br></pre></td></tr></table></figure>
<p>退出 JShell</p>
<p>输入 /exit 命令退出 jshell：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jshell&gt; &#x2F;exit</span><br><span class="line">| Goodbye</span><br></pre></td></tr></table></figure>




]]></content>
  </entry>
  <entry>
    <title>java9改进的Javadoc</title>
    <url>/2021/06/12/java9%E6%94%B9%E8%BF%9B%E7%9A%84Javadoc/</url>
    <content><![CDATA[<p>javadoc 工具可以生成 Java 文档， Java 9 的 javadoc 的输出现在符合兼容 HTML5 标准。</p>
<p>Java 9 之前的旧版本文档</p>
<p>考虑以下文件代码 C:/JAVA/Tester.java:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * @author MahKumar</span><br><span class="line">  * @version 0.1</span><br><span class="line">*&#x2F;</span><br><span class="line">public class Tester &#123;</span><br><span class="line">   &#x2F;**</span><br><span class="line">      * Default method to be run to print </span><br><span class="line">      * &lt;p&gt;Hello world&lt;&#x2F;p&gt;</span><br><span class="line">      * @param args command line arguments</span><br><span class="line">   *&#x2F;</span><br><span class="line">   public static void main(String []args) &#123;</span><br><span class="line">      System.out.println(&quot;Hello World&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 jdk 7 的 javadoc 生成文档：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\JAVA&gt;javadoc -d C:&#x2F;JAVA Tester.java</span><br><span class="line">Loading source file tester.java...</span><br><span class="line">Constructing Javadoc information...</span><br><span class="line">Standard Doclet version 1.7.0_21</span><br><span class="line">Building tree for all the packages and classes...</span><br><span class="line">Generating C:\JAVA\Tester.html...</span><br><span class="line">Generating C:\JAVA\package-frame.html...</span><br><span class="line">Generating C:\JAVA\package-summary.html...</span><br><span class="line">Generating C:\JAVA\package-tree.html...</span><br><span class="line">Generating C:\JAVA\constant-values.html...</span><br><span class="line">Building index for all the packages and classes...</span><br><span class="line">Generating C:\JAVA\overview-tree.html...</span><br><span class="line">Generating C:\JAVA\index-all.html...</span><br><span class="line">Generating C:\JAVA\deprecated-list.html...</span><br><span class="line">Building index for all classes...</span><br><span class="line">Generating C:\JAVA\allclasses-frame.html...</span><br><span class="line">Generating C:\JAVA\allclasses-noframe.html...</span><br><span class="line">Generating C:\JAVA\index.html...</span><br><span class="line">Generating C:\JAVA\help-doc.html...</span><br></pre></td></tr></table></figure>
<p>执行以上命令会再 C:/JAVA 命令下生成文档页面，如下图所示：<br><img src="img.png" alt="img.png"></p>
<p>Java 9 生成的文档兼容 HTML5 标准</p>
<p>使用 jdk 9 javadoc 命令中的 -html5 参数可以让生成的文档支持 HTML5 标准：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\JAVA&gt; javadoc -d C:&#x2F;JAVA -html5 Tester.java</span><br><span class="line">Loading source file Tester.java...</span><br><span class="line">Constructing Javadoc information...</span><br><span class="line">Standard Doclet version 9.0.1</span><br><span class="line">Building tree for all the packages and classes...</span><br><span class="line">Generating C:\JAVA\Tester.html...</span><br><span class="line">Generating C:\JAVA\package-frame.html...</span><br><span class="line">Generating C:\JAVA\package-summary.html...</span><br><span class="line">Generating C:\JAVA\package-tree.html...</span><br><span class="line">Generating C:\JAVA\constant-values.html...</span><br><span class="line">Building index for all the packages and classes...</span><br><span class="line">Generating C:\JAVA\overview-tree.html...</span><br><span class="line">Generating C:\JAVA\index-all.html...</span><br><span class="line">Generating C:\JAVA\deprecated-list.html...</span><br><span class="line">Building index for all classes...</span><br><span class="line">Generating C:\JAVA\allclasses-frame.html...</span><br><span class="line">Generating C:\JAVA\allclasses-frame.html...</span><br><span class="line">Generating C:\JAVA\allclasses-noframe.html...</span><br><span class="line">Generating C:\JAVA\allclasses-noframe.html...</span><br><span class="line">Generating C:\JAVA\index.html...</span><br><span class="line">Generating C:\JAVA\help-doc.html...</span><br></pre></td></tr></table></figure>
<p>执行以上命令会再 C:/JAVA 命令下生成文档页面，如下图所示：</p>
<p><img src="img_1.png" alt="img_1.png"></p>
]]></content>
  </entry>
  <entry>
    <title>java9模块系统</title>
    <url>/2021/06/12/java9%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>Java 9 最大的变化之一是引入了模块系统（Jigsaw 项目）。<br>模块就是代码和数据的封装体。模块的代码被组织成多个包，每个包中包含Java类和接口；模块的数据则包括资源文件和其他静态信息。<br>Java 9 模块的重要特征是在其工件（artifact）的根目录中包含了一个描述模块的 module-info.class 文 件。 工件的格式可以是传统的 JAR 文件或是 Java 9 新增的 JMOD 文件。这个文件由根目录中的源代码文件 module-info.java 编译而来。该模块声明文件可以描述模块的不同特征。<br>在 module-info.java 文件中，我们可以用新的关键词module来声明一个模块，如下所示。下面给出了一个模块com.mycompany.mymodule的最基本的模块声明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module com.runoob.mymodule &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h2><p>接下来我们创建一个 com.runoob.greetings 的模块。</p>
<p><strong>第一步</strong></p>
<p>创建文件夹 C:&gt;JAVA\src，然后在该目录下再创建与模块名相同的文件夹 com.runoob.greetings。</p>
<p><strong>第二步</strong><br>在 C:&gt;JAVA\src\com.runoob.greetings 目录下创建 module-info.java 文件，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module com.runoob.greetings &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>module-info.java 用于创建模块。这一步我们创建了 com.runoob.greetings 模块。</p>
<p><strong>第三步</strong><br>在模块中添加源代码文件，在目录 C:&gt;JAVA\src\com.runoob.greetings\com\runoob\greetings 中创建文件 Java9Tester.java，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.runoob.greetings;</span><br><span class="line"></span><br><span class="line">public class Java9Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第四步</strong><br>创建文件夹 C:&gt;JAVA\mods，然后在该目录下创建 com.runoob.greetings 文件夹，编译模块到这个目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:&#x2F;&gt;JAVA&gt; javac -d mods&#x2F;com.runoob.greetings </span><br><span class="line">   src&#x2F;com.runoob.greetings&#x2F;module-info.java </span><br><span class="line">   src&#x2F;com.runoob.greetings&#x2F;com&#x2F;runoob&#x2F;greetings&#x2F;Java9Tester.java</span><br></pre></td></tr></table></figure>
<p><strong>第五步</strong><br>执行模块，查看输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:&#x2F;&gt;JAVA&gt; java --module-path mods -m com.runoob.greetings&#x2F;com.runoob.greetings.Java9Tester</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
<p>module-path 指定了模块所在的路径。<br>-m 指定主要模块。</p>
]]></content>
  </entry>
  <entry>
    <title>github登录不上解决办法</title>
    <url>/2021/09/01/github%E7%99%BB%E5%BD%95%E4%B8%8D%E4%B8%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<h2 id="打开下面网站获取IP地址"><a href="#打开下面网站获取IP地址" class="headerlink" title="打开下面网站获取IP地址"></a>打开下面网站获取IP地址</h2><p><a href="https://github.com.ipaddress.com/" target="_blank" rel="noopener">https://github.com.ipaddress.com/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">140.82.113.3 github.com</span><br></pre></td></tr></table></figure>

<h2 id="打开下面网站获取IP地址-1"><a href="#打开下面网站获取IP地址-1" class="headerlink" title="打开下面网站获取IP地址"></a>打开下面网站获取IP地址</h2><p><a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net#ipinfo" target="_blank" rel="noopener">https://fastly.net.ipaddress.com/github.global.ssl.fastly.net#ipinfo</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">199.232.69.194 github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure>

<h2 id="打开下面网站获取IP地址-2"><a href="#打开下面网站获取IP地址-2" class="headerlink" title="打开下面网站获取IP地址"></a>打开下面网站获取IP地址</h2><p><a href="https://github.com.ipaddress.com/assets-cdn.github.com" target="_blank" rel="noopener">https://github.com.ipaddress.com/assets-cdn.github.com</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">185.199.109.153 assets-cdn.github.com</span><br><span class="line">185.199.110.153 assets-cdn.github.com</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br></pre></td></tr></table></figure>

<h2 id="修改host文件，在host文件添加上面地址"><a href="#修改host文件，在host文件添加上面地址" class="headerlink" title="修改host文件，在host文件添加上面地址"></a>修改host文件，在host文件添加上面地址</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">140.82.113.3 github.com</span><br><span class="line">199.232.69.194 github.global.ssl.fastly.net</span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">185.199.109.153 assets-cdn.github.com</span><br><span class="line">185.199.110.153 assets-cdn.github.com</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk8更换</title>
    <url>/2021/09/27/jdk8%E6%9B%B4%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="最新免费版jdk"><a href="#最新免费版jdk" class="headerlink" title="最新免费版jdk"></a>最新免费版jdk</h2><p><a href="https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html" target="_blank" rel="noopener">最新免费版下载地址</a></p>
<h2 id="Linux系统更换jdk"><a href="#Linux系统更换jdk" class="headerlink" title="Linux系统更换jdk"></a>Linux系统更换jdk</h2><ul>
<li><p>查看Linux内核版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一种方式</span><br><span class="line">uname -srm</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">Linux 3.10.0-957.12.2.el7.x86_64 x86_64</span><br><span class="line">3 - 内核版本.</span><br><span class="line">10 - 主修订版本.</span><br><span class="line">0-957 - 次要修订版本.</span><br><span class="line">12 - 补丁版本.</span><br><span class="line"></span><br><span class="line">第二种方式</span><br><span class="line">使用&#96;hostnamectl&#96;命令查看内核版本</span><br><span class="line">hostnamectl实用程序是systemd的一部分，用于查询和更改系统主机名。 它还显示Linux发行版和内核版本：</span><br><span class="line"></span><br><span class="line">root@pre-k8s-node1 ~]# hostnamectl</span><br><span class="line">   Static hostname: pre-k8s-node1</span><br><span class="line">         Icon name: computer-vm</span><br><span class="line">           Chassis: vm</span><br><span class="line">        Machine ID: 8f5b018f6eb344909f6cfec5ad0839ef</span><br><span class="line">           Boot ID: 89c4766582c24bb8b9bfa1300c74d151</span><br><span class="line">    Virtualization: kvm</span><br><span class="line">  Operating System: CentOS Linux 7 (Core)</span><br><span class="line">       CPE OS Name: cpe:&#x2F;o:centos:centos:7</span><br><span class="line">            Kernel: Linux 3.10.0-1062.12.1.el7.x86_64</span><br><span class="line">      Architecture: x86-64</span><br><span class="line">      </span><br><span class="line">第三种方式      </span><br><span class="line">使用以下命令只显示当前内核版本：</span><br><span class="line"></span><br><span class="line">[root@pre-k8s-node1 ~]# hostnamectl | grep -i kernel</span><br><span class="line">            Kernel: Linux 3.10.0-1062.12.1.el7.x86_64</span><br><span class="line">            </span><br><span class="line">第四种方式      </span><br><span class="line">通过查看&#x2F;proc&#x2F;version文件确认内核版本</span><br><span class="line">&#x2F;proc目录包含虚拟文件，其中包含有关系统内存，CPU内核，已安装文件系统等的信息。有关正在运行的内核的信息存储在&#x2F;proc&#x2F;version虚拟文件中。</span><br><span class="line">结合cat查看文件内容：</span><br><span class="line"></span><br><span class="line">cat &#x2F;proc&#x2F;version</span><br><span class="line">输出结果如下：</span><br><span class="line"></span><br><span class="line">Linux version 3.10.0-957.12.2.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC) ) 1 SMP Tue May 14 21:24:32 UTC 2019            </span><br><span class="line">      </span><br><span class="line">这些命令适用于所有流行的Linux发行版，包括Debian，Red Hat，Ubuntu，Arch Linux，Fedora，CentOS，Kali Linux，OpenSUSE，Linux Mint等。</span><br></pre></td></tr></table></figure>
</li>
<li><p>从<a href="https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html" target="_blank" rel="noopener">最新免费版下载地址</a><br>获取最新版本。</p>
</li>
<li><p>依据Linux内核确定 版本为jdk-8u202-linux-x64.tar.gz</p>
</li>
<li><p>通过FinalShell将解压后的文件上传至/usr/local/java/</p>
</li>
<li><p>配置环境变量vim /etc/profile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_202</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br><span class="line">export CLASSPATH&#x3D;.:JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br></pre></td></tr></table></figure>
</li>
<li><p>刷新配置<br>source /etc/profile</p>
</li>
<li><p>查看java的安装目录<br>which java</p>
</li>
</ul>
<h2 id="docker环境更换jdk"><a href="#docker环境更换jdk" class="headerlink" title="docker环境更换jdk"></a>docker环境更换jdk</h2><h2 id="公告文档"><a href="#公告文档" class="headerlink" title="公告文档"></a>公告文档</h2><p>Hello开发小伙伴们：</p>
<p>   因Oracle JDK许可变更，在没有商业许可的情况下，在2019年1月之后发布的Oracle Java SE 8的公开更新将不可用于<br>商业或生产用途。</p>
<p>   经架构委员会、运维部会议讨论，目前Oracle JDK 8u202已经满足公司当前开发需求。如后期有更高版本的使用需求，须<br>经架构委员会评估后，另行通知方可使用。</p>
<p>   从即日起全公司使用的Oracle JDK版本不得高于8u202,请各业务线上技术经理知悉并安排自检，同时通知研发人员不得使用<br>更高版本JDK进行开发，以防新特性无法上线。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p> <a href="https://www.cnblogs.com/xuruiming/p/12881503.html" target="_blank" rel="noopener">Oracle JDK究竟从哪个版本开始收费？</a></p>
<p> <a href="https://www.shuzhiduo.com/A/kvJ34GYw5g/" target="_blank" rel="noopener">linux下解决安装jdk后‘环境变量’不生效的问题</a></p>
<p> <a href="https://lenjor.github.io/2020/12/Linux-Java-JDK-install/" target="_blank" rel="noopener">Linux安装JDK，并配置多个JDK切换</a></p>
<p> <a href="https://blog.csdn.net/jxpxlinkui/article/details/79649204" target="_blank" rel="noopener">Linux下安装JDK(多个版本) 切换</a></p>
<p> <a href="https://www.cnblogs.com/javabg/p/10332993.html" target="_blank" rel="noopener">linux 卸载jdk和安装</a></p>
<p> <a href="https://blog.csdn.net/ca1m0921/article/details/90322309" target="_blank" rel="noopener">JDK Linux修改jdk不生效</a></p>
<p> <a href="https://blog.csdn.net/zhangvalue/article/details/84979635" target="_blank" rel="noopener">Linux 给文件夹或者文件增加权限</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod -R 777 文件夹</span><br><span class="line">参数-R是递归的意思</span><br><span class="line">777表示开放所有权限</span><br><span class="line"></span><br><span class="line">chmod 777 test.sh</span><br><span class="line"></span><br><span class="line">chmod +x 某文件</span><br><span class="line"></span><br><span class="line">如果给所有人添加可执行权限：chmod a+x 文件名；</span><br><span class="line">如果给文件所有者添加可执行权限：chmod u+x 文件名；</span><br><span class="line">如果给所在组添加可执行权限：chmod g+x 文件名；</span><br><span class="line">如果给所在组以外的人添加可执行权限：chmod o+x 文件名；</span><br></pre></td></tr></table></figure>
<p> <a href="https://www.cnblogs.com/linuxprobe/p/11664104.html" target="_blank" rel="noopener">查看Linux内核版本</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>git提交标准及工具</title>
    <url>/2021/10/27/git%E6%8F%90%E4%BA%A4%E6%A0%87%E5%87%86%E5%8F%8A%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="Git-Message规范化实践"><a href="#Git-Message规范化实践" class="headerlink" title="Git Message规范化实践"></a>Git Message规范化实践</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="为什么（why"><a href="#为什么（why" class="headerlink" title="为什么（why)"></a>为什么（why)</h3><p>随着项目业务的发展、编程人员的增多，当你想要找到某次代码提交的记录时，git commit message就显得尤为重要，标准化的commit message可以大大提高我们的开发效率，对项目的可持续化维护尤为重要。毕竟谁也不想只看到add、update、优化、新增列表等反馈不了实际修改了哪些内容的git log。</p>
<h3 id="是什么-what"><a href="#是什么-what" class="headerlink" title="是什么(what)"></a>是什么(what)</h3><p>先说结论： 标准化commit message（Angular规范） + Commitizen + Change log</p>
<h3 id="怎么做（how）"><a href="#怎么做（how）" class="headerlink" title="怎么做（how）"></a>怎么做（how）</h3><ol>
<li>安装brew(已安装忽略)</li>
<li>安装node(已安装忽略)</li>
<li>安装Commitizen</li>
<li>生成 Change log</li>
</ol>
<h2 id="Commit-message的作用"><a href="#Commit-message的作用" class="headerlink" title="Commit message的作用"></a>Commit message的作用</h2><h3 id="（1）提供更多的历史信息，方便快速浏览"><a href="#（1）提供更多的历史信息，方便快速浏览" class="headerlink" title="（1）提供更多的历史信息，方便快速浏览"></a>（1）提供更多的历史信息，方便快速浏览</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log &lt;last tag&gt; HEAD --pretty&#x3D;format:%s</span><br></pre></td></tr></table></figure>
<h3 id="（2）过滤某些commit（比如文档改动），便于快速查找信息"><a href="#（2）过滤某些commit（比如文档改动），便于快速查找信息" class="headerlink" title="（2）过滤某些commit（比如文档改动），便于快速查找信息"></a>（2）过滤某些commit（比如文档改动），便于快速查找信息</h3><p>比如，下面的命令仅仅显示本次发布新增加的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log &lt;last release&gt; HEAD --grep feature</span><br></pre></td></tr></table></figure>
<h3 id="（3）可以直接从commit生成Change-log"><a href="#（3）可以直接从commit生成Change-log" class="headerlink" title="（3）可以直接从commit生成Change log"></a>（3）可以直接从commit生成Change log</h3><h2 id="Commit-message的格式"><a href="#Commit-message的格式" class="headerlink" title="Commit message的格式"></a>Commit message的格式</h2><p>每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure>
<p>其中，Header 是必需的，Body 和 Footer 可以省略。</p>
<p>不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。</p>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。</p>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>type 用于说明commit的类别，只允许使用下面7个标识。</p>
<ul>
<li>feat: 新功能（feature）</li>
<li>fix: 修补bug</li>
<li>docs: 文档（documentation）</li>
<li>style: 格式（不影响代码运行的变动）</li>
<li>refactor: 重构（即不是新增功能，也不是修改bug的代码变动）</li>
<li>test: 增加测试</li>
<li>chore: 构建过程或辅助工具的变动</li>
</ul>
<p><font color=red>type为feat和fix，则该commit将肯定出现在Change log之中。其他情况（docs、chore、style、refactor、test)由你决定，要不要放入Change log,建议是不要。 </font></p>
<h4 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h4><p>scope用于说明commit影响的范围，比如数据层、控制层、视图层等等，或业务影响范围。</p>
<h4 id="subject"><a href="#subject" class="headerlink" title="subject"></a>subject</h4><p>subject是commit的简短描述,不超过50个字符。</p>
<ul>
<li>以动词开头，使用第一人称现在时，比如change,而不是changed或changes</li>
<li>第一个字母小写</li>
<li>结尾不加句号（.)<h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3>body部分是对本次commit的详细描述，可以分为多行，下面是一个范例。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">More detailed explanatory text, if necessary.  Wrap it to </span><br><span class="line">about 72 characters or so. </span><br><span class="line"></span><br><span class="line">Further paragraphs come after blank lines.</span><br><span class="line"></span><br><span class="line">- Bullet points are okay, too</span><br><span class="line">- Use a hanging indent</span><br></pre></td></tr></table></figure>
<font color=red>注意：</font></li>
</ul>
<ol>
<li>使用第一人称现在时，比如使用change而不是changed或changes。</li>
<li>应该说明代码变动的动机，以及与以前行为的对比。</li>
</ol>
<h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><p>Footer 部分只用于两种情况。</p>
<h4 id="（1）不兼容变动"><a href="#（1）不兼容变动" class="headerlink" title="（1）不兼容变动"></a>（1）不兼容变动</h4><p>如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BREAKING CHANGE: isolate scope bindings definition has changed.</span><br><span class="line"></span><br><span class="line">    To migrate the code follow the example below:</span><br><span class="line"></span><br><span class="line">    Before:</span><br><span class="line"></span><br><span class="line">    scope: &#123;</span><br><span class="line">      myAttr: &#39;attribute&#39;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    After:</span><br><span class="line"></span><br><span class="line">    scope: &#123;</span><br><span class="line">      myAttr: &#39;@&#39;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    The removed &#96;inject&#96; wasn&#39;t generaly useful for directives so there should be no code using it.</span><br></pre></td></tr></table></figure>
<h4 id="（2）关闭-Issue"><a href="#（2）关闭-Issue" class="headerlink" title="（2）关闭 Issue"></a>（2）关闭 Issue</h4><p>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Closes #234</span><br></pre></td></tr></table></figure>
<p>也可以一次关闭多个 issue 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Closes #123, #245, #992</span><br><span class="line">&#96;&#96;&#96;&#96;        </span><br><span class="line"></span><br><span class="line">### Revert</span><br><span class="line">还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。</span><br></pre></td></tr></table></figure>
<p>revert: feat(pencil): add ‘graphiteWidth’ option</p>
<p>This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Body部分的格式是固定的，必须写成This reverts commit &lt;hash&gt;.，其中的hash是被撤销 commit 的 SHA 标识符。</span><br><span class="line"></span><br><span class="line">如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。</span><br><span class="line"></span><br><span class="line">## Commitizen</span><br><span class="line"></span><br><span class="line">[Commitizen](https:&#x2F;&#x2F;github.com&#x2F;commitizen&#x2F;cz-cli) 是一个撰写合格 Commit message的工具。</span><br><span class="line"></span><br><span class="line">### 安装命令</span><br></pre></td></tr></table></figure>
<p>$ npm install -g commitizen</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 在项目根目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。</span><br></pre></td></tr></table></figure>
<p>$ commitizen init cz-conventional-changelog –save –save-exact</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意 执行node项目一般没问题，但我们是Java项目，可能会一下错误</span><br></pre></td></tr></table></figure>
<p>Attempting to initialize using the npm package cz-conventional-changelog<br>npm WARN saveError ENOENT: no such file or directory, open ‘/Users/owner/my/huifan/hf-kernel/package.json’<br>npm notice created a lockfile as package-lock.json. You should commit this file.<br>npm WARN enoent ENOENT: no such file or directory, open ‘/Users/owner/my/huifan/hf-kernel/package.json’<br>npm WARN hf-kernel No description<br>npm WARN hf-kernel No repository field.<br>npm WARN hf-kernel No README data<br>npm WARN hf-kernel No license field.</p>
<p>Error: ENOENT: no such file or directory, open ‘/Users/owner/my/huifan/hf-kernel/package.json’<br>    at Object.openSync (fs.js:458:3)<br>    at Object.readFileSync (fs.js:360:35)<br>    at addPathToAdapterConfig (/usr/local/lib/node_modules/commitizen/dist/commitizen/adapter.js:1257:62)<br>    at init (/usr/local/lib/node_modules/commitizen/dist/commitizen/init.js:1035:5)<br>    at Object.bootstrap (/usr/local/lib/node_modules/commitizen/dist/cli/commitizen.js:34:30)<br>    at Object.<anonymous> (/usr/local/lib/node_modules/commitizen/bin/commitizen.js:2:38)<br>    at Module._compile (internal/modules/cjs/load</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上述报错的原因为没有package.json文件，可执行以下命令生成默认的package.json</span><br></pre></td></tr></table></figure>
<p>npm init –yes</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### git commit 替换为 git cz</span><br><span class="line">以后，&lt;font color&#x3D;red&gt;凡是用到git commit命令，一律改为使用git cz。&lt;&#x2F;font&gt;这时，就会出现选项，用来生成符合格式的 Commit message。</span><br><span class="line"></span><br><span class="line">## validate-commit-msg</span><br><span class="line">[validate-commit-msg](https:&#x2F;&#x2F;github.com&#x2F;conventional-changelog-archived-repos&#x2F;validate-commit-msg) 用于检查 Node 项目的 Commit message 是否符合格式。</span><br><span class="line"></span><br><span class="line">### 安装</span><br></pre></td></tr></table></figure>
<p>npm install –save-dev validate-commit-msg</p>
<p>npm install ghooks –save-dev</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 配置</span><br><span class="line"></span><br><span class="line">在项目的根目录下, 新建一个名为.vcmrc的文件, 并输入以下内容:</span><br></pre></td></tr></table></figure>
<p>{<br>  “types”: [“feat”, “fix”, “docs”, “style”, “refactor”, “perf”, “test”, “build”, “ci”, “chore”, “revert”],<br>  “scope”: {<br>    “required”: false,<br>    “allowed”: [“*”],<br>    “validate”: false,<br>    “multiple”: false<br>  },<br>  “warnOnFail”: false,<br>  “maxSubjectLength”: 100,<br>  “subjectPattern”: “.+”,<br>  “subjectPatternErrorMsg”: “subject does not match subject pattern!”,<br>  “helpMessage”: “”,<br>  “autoFix”: false<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">然后, 在package.json中添加如下配置</span><br></pre></td></tr></table></figure>
<p>  “config”: {<br>    “ghooks”: {<br>      “commit-msg”: “validate-commit-msg”<br>    }<br>  }</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 使用场景</span><br><span class="line">每次git commit的时候，这个脚本就会自动检查 Commit message 是否合格。如果不合格，就会报错。</span><br></pre></td></tr></table></figure>
<p>$ git add -A<br>$ git commit -m “edit markdown”<br>INVALID COMMIT MSG: does not match “<type>(<scope>): <subject>“ ! was: edit markdown</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 生成Change log</span><br><span class="line">如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成。</span><br><span class="line"></span><br><span class="line">生成的文档包括以下三个部分。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;&#96;        </span><br><span class="line">New features</span><br><span class="line">Bug fixes</span><br><span class="line">Breaking changes</span><br><span class="line">&#96;&#96;&#96;&#96;        </span><br><span class="line"></span><br><span class="line">每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。</span><br><span class="line"></span><br><span class="line">[conventional-changelog](https:&#x2F;&#x2F;github.com&#x2F;conventional-changelog&#x2F;conventional-changelog) 就是生成 Change log 的工具，运行下面的命令即可。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;&#96;        </span><br><span class="line">$ npm install -g conventional-changelog</span><br><span class="line">$ cd my-project</span><br><span class="line">$ conventional-changelog -p angular -i CHANGELOG.md -w</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;&#96;        </span><br><span class="line"></span><br><span class="line">上面命令不会覆盖以前的 Change log，只会在CHANGELOG.md的头部加上自从上次发布以来的变动。</span><br><span class="line"></span><br><span class="line">如果你想生成所有发布的 Change log，要改为运行下面的命令。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;&#96;    </span><br><span class="line">$ conventional-changelog -p angular -i CHANGELOG.md -w -r 0</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;&#96;    </span><br><span class="line">为了方便使用，可以将其写入package.json的scripts字段。</span><br></pre></td></tr></table></figure>
<p>{<br>  “scripts”: {<br>      “changelog”: “conventional-changelog -p angular -i CHANGELOG.md -s -r 0”</p>
<p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以后，直接运行下面的命令即可。</span><br></pre></td></tr></table></figure>
<p>$ npm run changelog</p>
<pre><code>
## 参考文档
[Git - Git 钩子](https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90)

[优雅的使用Git](https://juejin.cn/post/6844904008025391118)

[Linux统计文件夹下的文件数目](http://noahsnail.com/2017/02/07/2017-02-07-Linux%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E7%9B%AE/)

[git commit 、CHANGELOG 和版本发布的标准自动化](https://zhuanlan.zhihu.com/p/51894196)

[git教程](https://git-scm.com/book/zh/v2)

[优雅的使用Git](https://juejin.cn/post/6844904008025391118)

[ghooks](https://www.npmjs.com/package/ghooks)

[npm 安装参数中的 --save-dev 是什么意思](https://segmentfault.com/q/1010000000403629)
</code></pre>]]></content>
  </entry>
  <entry>
    <title>markdown画流程图</title>
    <url>/2021/11/25/markdown%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="流程图各个形状的含义"><a href="#流程图各个形状的含义" class="headerlink" title="流程图各个形状的含义"></a>流程图各个形状的含义</h2><p><img src="flow.png" alt=""></p>
<ul>
<li>圆角矩形（表示起止）</li>
<li>平行四边形（输入输出）</li>
<li>菱形（判断）</li>
<li>直角矩形（操作/执行）</li>
</ul>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">start</td>
<td align="left">开始（圆角矩形）</td>
</tr>
<tr>
<td align="left">end</td>
<td align="left">结束（圆角矩形）</td>
</tr>
<tr>
<td align="left">condition</td>
<td align="left">判断（菱形）</td>
</tr>
<tr>
<td align="left">operation</td>
<td align="left">操作（直角矩形）</td>
</tr>
<tr>
<td align="left">inputoutput</td>
<td align="left">输入输出（平行四边形）</td>
</tr>
</tbody></table>
<p>** note:可以对符号自定义命名，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt; start: 输入数据</span><br><span class="line">解释：</span><br><span class="line">    st就是对start的命名，命名用&#x3D;&gt;符号</span><br><span class="line">    start: 后的文字，就是图形框内要显示的文字</span><br><span class="line">    start: 冒号后一定要空格再写文字</span><br></pre></td></tr></table></figure>
<p><strong>注意: 冒号后一定要加一个空格！！！</strong></p>
<p>下面表示各个图形和流程的串联，一个简单的-&gt;符号就好:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下面是赋值语句</span><br><span class="line">st&#x3D;&gt;start: Start|past:&gt;http:&#x2F;&#x2F;www.google.com[blank]</span><br><span class="line">e&#x3D;&gt;end: End:&gt;http:&#x2F;&#x2F;www.google.com</span><br><span class="line">op1&#x3D;&gt;operation: My Operation|past</span><br><span class="line">op2&#x3D;&gt;operation: Stuff</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?</span><br><span class="line">c2&#x3D;&gt;condition: Good idea</span><br><span class="line">io&#x3D;&gt;inputoutput: catch something...</span><br><span class="line"></span><br><span class="line"># 下面是连接语句</span><br><span class="line">st-&gt;op1-&gt;cond</span><br><span class="line">cond(yes)-&gt;c2</span><br><span class="line">c2(yes)-&gt;io-&gt;e</span><br><span class="line">c2(no)-&gt;op2-&gt;e</span><br><span class="line"></span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure>

<h2 id="横向流程图源码格式："><a href="#横向流程图源码格式：" class="headerlink" title="横向流程图源码格式："></a>横向流程图源码格式：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line"></span><br><span class="line">B --&gt; C&#123;条件a&#125;</span><br><span class="line"></span><br><span class="line">C --&gt;|a&#x3D;1| D[结果1]</span><br><span class="line"></span><br><span class="line">C --&gt;|a&#x3D;2| E[结果2]</span><br><span class="line"></span><br><span class="line">F[横向流程图]</span><br></pre></td></tr></table></figure>

<h2 id="竖向流程图源码格式："><a href="#竖向流程图源码格式：" class="headerlink" title="竖向流程图源码格式："></a>竖向流程图源码格式：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">A[方形] --&gt; B(圆角)</span><br><span class="line"></span><br><span class="line">B --&gt; C&#123;条件a&#125;</span><br><span class="line"></span><br><span class="line">C --&gt; |a&#x3D;1| D[结果1]</span><br><span class="line"></span><br><span class="line">C --&gt; |a&#x3D;2| E[结果2]</span><br><span class="line"></span><br><span class="line">F[竖向流程图]</span><br></pre></td></tr></table></figure>

<h2 id="标准流程图源码格式："><a href="#标准流程图源码格式：" class="headerlink" title="标准流程图源码格式："></a>标准流程图源码格式：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line"></span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line"></span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line"></span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line"></span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line"></span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line"></span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line"></span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure>

<h2 id="标准流程图源码格式（横向）："><a href="#标准流程图源码格式（横向）：" class="headerlink" title="标准流程图源码格式（横向）："></a>标准流程图源码格式（横向）：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line"></span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line"></span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line"></span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line"></span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line"></span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line"></span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line"></span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line"></span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure>

<h2 id="UML时序图源码样例："><a href="#UML时序图源码样例：" class="headerlink" title="UML时序图源码样例："></a>UML时序图源码样例：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sequenceDiagram</span><br><span class="line"></span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line"></span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line"></span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line"></span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line"></span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br></pre></td></tr></table></figure>

<h2 id="UML时序图源码复杂样例："><a href="#UML时序图源码复杂样例：" class="headerlink" title="UML时序图源码复杂样例："></a>UML时序图源码复杂样例：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sequenceDiagram</span><br><span class="line"></span><br><span class="line">Title: 标题：复杂使用</span><br><span class="line"></span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line"></span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line"></span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line"></span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line"></span><br><span class="line">对象B-&gt;小三: 你好吗</span><br><span class="line"></span><br><span class="line">小三--&gt;&gt;对象A: 对象B找我了</span><br><span class="line"></span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line"></span><br><span class="line">Note over 小三,对象B: 我们是朋友</span><br><span class="line"></span><br><span class="line">participant C</span><br><span class="line"></span><br><span class="line">Note right of C: 没人陪我玩</span><br></pre></td></tr></table></figure>

<h2 id="UML标准时序图样例："><a href="#UML标准时序图样例：" class="headerlink" title="UML标准时序图样例："></a>UML标准时序图样例：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头</span><br><span class="line"></span><br><span class="line">sequenceDiagram</span><br><span class="line"></span><br><span class="line">participant 张三</span><br><span class="line"></span><br><span class="line">participant 李四</span><br><span class="line"></span><br><span class="line">张三-&gt;王五: 王五你好吗？</span><br><span class="line"></span><br><span class="line">loop 健康检查</span><br><span class="line"></span><br><span class="line">王五-&gt;王五: 与疾病战斗</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">Note right of 王五: 合理 食物 &lt;br&#x2F;&gt;看医生...</span><br><span class="line"></span><br><span class="line">李四--&gt;&gt;张三: 很好!</span><br><span class="line"></span><br><span class="line">王五-&gt;李四: 你怎么样?</span><br><span class="line"></span><br><span class="line">李四--&gt;王五: 很好!</span><br></pre></td></tr></table></figure>

<h2 id="甘特图样例："><a href="#甘特图样例：" class="headerlink" title="甘特图样例："></a>甘特图样例：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gantt</span><br><span class="line"></span><br><span class="line">dateFormat YYYY-MM-DD</span><br><span class="line"></span><br><span class="line">title 软件开发甘特图</span><br><span class="line"></span><br><span class="line">section 设计</span><br><span class="line"></span><br><span class="line">需求 :done, des1, 2014-01-06,2014-01-08</span><br><span class="line"></span><br><span class="line">原型 :active, des2, 2014-01-09, 3d</span><br><span class="line"></span><br><span class="line">UI设计 : des3, after des2, 5d</span><br><span class="line"></span><br><span class="line">未来任务 : des4, after des3, 5d</span><br><span class="line"></span><br><span class="line">section 开发</span><br><span class="line"></span><br><span class="line">学习准备理解需求 :crit, done, 2014-01-06,24h</span><br><span class="line"></span><br><span class="line">设计框架 :crit, done, after des2, 2d</span><br><span class="line"></span><br><span class="line">开发 :crit, active, 3d</span><br><span class="line"></span><br><span class="line">未来任务 :crit, 5d</span><br><span class="line"></span><br><span class="line">耍 :2d</span><br><span class="line"></span><br><span class="line">section 测试</span><br><span class="line"></span><br><span class="line">功能测试 :active, a1, after des3, 3d</span><br><span class="line"></span><br><span class="line">压力测试 :after a1 , 20h</span><br><span class="line"></span><br><span class="line">测试报告 : 48h</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>markdown</category>
        <category>idea</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>java9新特性</title>
    <url>/2021/06/12/java9%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="java9新特性"><a href="#java9新特性" class="headerlink" title="java9新特性"></a>java9新特性</h1><p>Java 9 发布于 2017 年 9 月 22 日，带来了很多新特性，其中最主要的变化是已经实现的模块化系统。接下来我们会详细介绍 Java 9 的新特性。</p>
<ul>
<li><p>模块系统：模块是一个包的容器，java9最大的变化之一是引入了<br>模块系统（Jigsaw项目）。</p>
</li>
<li><p>REPL(JShell):交互式编程环境。</p>
</li>
<li><p>HTTP2客户端：HTTP/2标准是是HTTP协议的最新版本，新的 HTTPClient API 支持 WebSocket 和 HTTP2 流以及服务器推送特性。</p>
</li>
<li><p>改进的 Javadoc：Javadoc 现在支持在 API 文档中的进行搜索。另外，Javadoc 的输出现在符合兼容 HTML5 标准。</p>
</li>
<li><p>多版本兼容 JAR 包：多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本。</p>
</li>
<li><p>集合工厂方法：List，Set 和 Map 接口中，新的静态工厂方法可以创建这些集合的不可变实例。</p>
</li>
<li><p>私有接口方法：在接口中使用private私有方法。我们可以使用 private 访问修饰符在接口中编写私有方法。</p>
</li>
<li><p>进程 API: 改进的 API 来控制和管理操作系统进程。引进 java.lang.ProcessHandle 及其嵌套接口 Info 来让开发者逃离时常因为要获取一个本地进程的 PID 而不得不使用本地代码的窘境。</p>
</li>
<li><p>改进的 Stream API：改进的 Stream API 添加了一些便利的方法，使流处理更容易，并使用收集器编写复杂的查询。</p>
</li>
<li><p>改进 try-with-resources：如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中使用该变量，而无需在 try-with-resources 语句中声明一个新变量。</p>
</li>
<li><p>改进的弃用注解 @Deprecated：注解 @Deprecated 可以标记 Java API 状态，可以表示被标记的 API 将会被移除，或者已经破坏。</p>
</li>
<li><p>改进钻石操作符(Diamond Operator) ：匿名类可以使用钻石操作符(Diamond Operator)。</p>
</li>
<li><p>改进 Optional 类：java.util.Optional 添加了很多新的有用方法，Optional 可以直接转为 stream。</p>
</li>
<li><p>多分辨率图像 API：定义多分辨率图像API，开发者可以很容易的操作和展示不同分辨率的图像了。</p>
</li>
<li><p>改进的 CompletableFuture API ： CompletableFuture 类的异步机制可以在 ProcessHandle.onExit 方法退出时执行操作。</p>
</li>
<li><p>轻量级的 JSON API：内置了一个轻量级的JSON API</p>
</li>
<li><p>响应式流（Reactive Streams) API: Java 9中引入了新的响应式流 API 来支持 Java 9 中的响应式编程。</p>
</li>
</ul>
<p>更多的新特性可以参阅官网：<a href="https://docs.oracle.com/javase/9/whatsnew/toc.htm" target="_blank" rel="noopener">What’s New in JDK 9</a></p>
<p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk9-doc-downloads-3850606.html" target="_blank" rel="noopener">JDK 9 下载地址</a><br>在关于 Java 9 文章的实例，我们均使用 jdk 1.9 环境，你可以使用以下命令查看当前 jdk 的版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">java version &quot;9-ea&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 9-ea+163)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 9-ea+163, mixed mode)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mermaid实用教程</title>
    <url>/2021/11/25/Mermaid%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://vincentruan.github.io/2020/02/04/Mermaid-%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">转发自</a></p>
<p><a href="https://mermaid-js.github.io/mermaid/#/" target="_blank" rel="noopener">官方文档</a></p>
<p><a href="https://github.com/knsv/mermaid" target="_blank" rel="noopener">github</a></p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><h3 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h3><h4 id="图标方向"><a href="#图标方向" class="headerlink" title="图标方向"></a>图标方向</h4><p>Mermaid支持多种图表的方向，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph 方向描述</span><br><span class="line">    图表中的其他语句...</span><br></pre></td></tr></table></figure>

<h5 id="方向描述"><a href="#方向描述" class="headerlink" title="方向描述"></a>方向描述</h5><table>
<thead>
<tr>
<th align="left">方向描述</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">TB</td>
<td align="left">从上到下</td>
</tr>
<tr>
<td align="left">BT</td>
<td align="left">从下到上</td>
</tr>
<tr>
<td align="left">RL</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">LR</td>
<td align="left">从左到右</td>
</tr>
</tbody></table>
<h5 id="节点描述"><a href="#节点描述" class="headerlink" title="节点描述"></a>节点描述</h5><p>即流程图中每个文本块，包括开始、结束、处理、判断等。Mermaid中每个节点都有一个id，以及节点的文字。</p>
<table>
<thead>
<tr>
<th align="left">表述</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">id[文字]</td>
<td align="left">矩形节点</td>
</tr>
<tr>
<td align="left">id(文字)</td>
<td align="left">圆角矩形节点</td>
</tr>
<tr>
<td align="left">id((文字))</td>
<td align="left">圆形节点</td>
</tr>
<tr>
<td align="left">id&gt;文字}</td>
<td align="left">右向旗帜状节点</td>
</tr>
<tr>
<td align="left">id{文字}</td>
<td align="left">菱形节点</td>
</tr>
<tr>
<td align="left">需要注意的是，如果节点的文字中包含标点符号，需要时用双引号包裹起来。</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>希望在文字中换行，请使用</p>
<p>替换换行</p>
<h5 id="节点间的连线"><a href="#节点间的连线" class="headerlink" title="节点间的连线"></a>节点间的连线</h5><table>
<thead>
<tr>
<th align="left">表述</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&gt;</td>
<td align="left">添加尾部箭头</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">不添加尾部箭头</td>
</tr>
<tr>
<td align="left">–</td>
<td align="left">单线</td>
</tr>
<tr>
<td align="left">–text–</td>
<td align="left">单线上加文字</td>
</tr>
<tr>
<td align="left">==</td>
<td align="left">粗线</td>
</tr>
<tr>
<td align="left">==text==</td>
<td align="left">粗线加文字</td>
</tr>
<tr>
<td align="left">-.-</td>
<td align="left">虚线</td>
</tr>
<tr>
<td align="left">-.text.-</td>
<td align="left">虚线上加文字</td>
</tr>
</tbody></table>
<h5 id="子图表"><a href="#子图表" class="headerlink" title="子图表"></a>子图表</h5><p>使用以下语法添加子图表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subgraph 子图表名称</span><br><span class="line">    子图表中的描述语句...</span><br><span class="line">end123</span><br></pre></td></tr></table></figure>

<h5 id="对font-awesome的支持"><a href="#对font-awesome的支持" class="headerlink" title="对font awesome的支持"></a>对font awesome的支持</h5><p>使用<code>fa: #图表名称#</code>的语法添加fontawesome</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A--&gt;B;</span><br><span class="line">    A--&gt;C;</span><br><span class="line">    B--&gt;D;</span><br><span class="line">    C--&gt;D;</span><br></pre></td></tr></table></figure>

<h3 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h3><ul>
<li>TB/TD - top bottom</li>
<li>BT - bottom top</li>
<li>RL - right left</li>
<li>LR - left right</li>
</ul>
<h4 id="向下"><a href="#向下" class="headerlink" title="向下"></a>向下</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">Start --&gt; Stop</span><br></pre></td></tr></table></figure>

<h4 id="向下-1"><a href="#向下-1" class="headerlink" title="向下"></a>向下</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">Start --&gt; Stop</span><br></pre></td></tr></table></figure>

<h4 id="向上"><a href="#向上" class="headerlink" title="向上"></a>向上</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph BT</span><br><span class="line">Start --&gt; Stop</span><br></pre></td></tr></table></figure>

<h4 id="从右向左"><a href="#从右向左" class="headerlink" title="从右向左"></a>从右向左</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph RL</span><br><span class="line">Start --&gt; Stop</span><br></pre></td></tr></table></figure>

<h4 id="从左向右"><a href="#从左向右" class="headerlink" title="从左向右"></a>从左向右</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Start --&gt; Stop</span><br></pre></td></tr></table></figure>

<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><h4 id="普通节点"><a href="#普通节点" class="headerlink" title="普通节点"></a>普通节点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id</span><br></pre></td></tr></table></figure>

<h4 id="带文字节点"><a href="#带文字节点" class="headerlink" title="带文字节点"></a>带文字节点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id[带文字节点]</span><br></pre></td></tr></table></figure>

<h4 id="圆角节点"><a href="#圆角节点" class="headerlink" title="圆角节点"></a>圆角节点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id(圆角节点)</span><br></pre></td></tr></table></figure>

<h4 id="圆形节点"><a href="#圆形节点" class="headerlink" title="圆形节点"></a>圆形节点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id((圆形节点))</span><br></pre></td></tr></table></figure>

<h4 id="不对称节点"><a href="#不对称节点" class="headerlink" title="不对称节点"></a>不对称节点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id&gt;不对称节点]</span><br></pre></td></tr></table></figure>

<h4 id="菱形节点"><a href="#菱形节点" class="headerlink" title="菱形节点"></a>菱形节点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id&#123;菱形节点&#125;</span><br></pre></td></tr></table></figure>

<h3 id="连接线"><a href="#连接线" class="headerlink" title="连接线"></a>连接线</h3><h4 id="实线，有箭头，无文字"><a href="#实线，有箭头，无文字" class="headerlink" title="实线，有箭头，无文字"></a>实线，有箭头，无文字</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A--&gt;B</span><br></pre></td></tr></table></figure>

<h4 id="实线，无箭头，无文字"><a href="#实线，无箭头，无文字" class="headerlink" title="实线，无箭头，无文字"></a>实线，无箭头，无文字</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A---B</span><br></pre></td></tr></table></figure>

<h4 id="实线，无箭头，有文字"><a href="#实线，无箭头，有文字" class="headerlink" title="实线，无箭头，有文字"></a>实线，无箭头，有文字</h4><p>前面两个<code>-</code>,后面三个<code>-</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A-- 文字 ---B</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A--- |文字| B</span><br></pre></td></tr></table></figure>
<h4 id="实线，有箭头，有文字"><a href="#实线，有箭头，有文字" class="headerlink" title="实线，有箭头，有文字"></a>实线，有箭头，有文字</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A-- 文字 --&gt;B</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A--&gt; |文字| B</span><br></pre></td></tr></table></figure>

<h4 id="虚线，有箭头，有文字"><a href="#虚线，有箭头，有文字" class="headerlink" title="虚线，有箭头，有文字"></a>虚线，有箭头，有文字</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A-. text .-&gt; B</span><br></pre></td></tr></table></figure>

<h4 id="大箭头，无文字"><a href="#大箭头，无文字" class="headerlink" title="大箭头，无文字"></a>大箭头，无文字</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A &#x3D;&#x3D;&gt; B</span><br></pre></td></tr></table></figure>
<h4 id="大箭头，文字"><a href="#大箭头，文字" class="headerlink" title="大箭头，文字"></a>大箭头，文字</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A &#x3D;&#x3D; text &#x3D;&#x3D;&gt; B</span><br></pre></td></tr></table></figure>

<h3 id="特殊语法"><a href="#特殊语法" class="headerlink" title="特殊语法"></a>特殊语法</h3><h4 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h4><p>文字里用引号避免一些特殊字符的错误。比如矩形节点里有（）时就无法渲染，所以加上引号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id1[&quot;This is the (text) in the box&quot;]</span><br></pre></td></tr></table></figure>

<h4 id="实体字符"><a href="#实体字符" class="headerlink" title="实体字符"></a>实体字符</h4><p>可以使用 HTML 中的实体字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[&quot;A double quote:#quot;&quot;] --&gt;B[&quot;A dec char:#9829;&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    c1--&gt;a2</span><br><span class="line">    subgraph one</span><br><span class="line">    a1--&gt;a2</span><br><span class="line">    end</span><br><span class="line">    subgraph two</span><br><span class="line">    b1--&gt;b2</span><br><span class="line">    end</span><br><span class="line">    subgraph three</span><br><span class="line">    c1--&gt;c2</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><h4 id="linkStyle-后面的数字表示第几根线，从-0-开始。可以指定颜色和粗细。"><a href="#linkStyle-后面的数字表示第几根线，从-0-开始。可以指定颜色和粗细。" class="headerlink" title="linkStyle 后面的数字表示第几根线，从 0 开始。可以指定颜色和粗细。"></a>linkStyle 后面的数字表示第几根线，从 0 开始。可以指定颜色和粗细。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A--&gt;B;</span><br><span class="line">    A--&gt;C;</span><br><span class="line">    B--&gt;D;</span><br><span class="line">    C--&gt;D;</span><br><span class="line">    linkStyle 0 stroke:#0ff,stroke-width:2px;</span><br><span class="line">    linkStyle 3 stroke:#ff3,stroke-width:4px;</span><br></pre></td></tr></table></figure>

<h4 id="设置节点背景，边框颜色，粗细，实线还是虚线"><a href="#设置节点背景，边框颜色，粗细，实线还是虚线" class="headerlink" title="设置节点背景，边框颜色，粗细，实线还是虚线"></a>设置节点背景，边框颜色，粗细，实线还是虚线</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    id1(Start)--&gt;id2(Stop)</span><br><span class="line">    style id1 fill:#f9f,stroke:#333,stroke-width:4px</span><br><span class="line">    style id2 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5</span><br></pre></td></tr></table></figure>

<h4 id="样式类"><a href="#样式类" class="headerlink" title="样式类"></a>样式类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A--&gt;B</span><br><span class="line"></span><br><span class="line">    %% 定义样式类</span><br><span class="line">    classDef className fill:#f9f,stroke:#333,stroke-width:4px;</span><br><span class="line"></span><br><span class="line">    %% 应用样式类，markdown里没效果</span><br><span class="line">    class A className</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classDef default fill:#f9f,stroke:#333,stroke-width:4px;</span><br></pre></td></tr></table></figure>
<p>定义一个名为 default 的类，节点没有指定特定样式类时，将都会应用这个样式类。</p>
<h3 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h3><p>可以使用 Font Awesome 图标。语法 fa:icon class name。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">   B[&quot;fa:fa-twitter for peace&quot;]</span><br><span class="line">   B--&gt;C[fa:fa-ban forbidden]</span><br><span class="line">   B--&gt;D(fa:fa-spinner);</span><br><span class="line">   B--&gt;E(A fa:fa-camera-retro perhaps?);</span><br></pre></td></tr></table></figure>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Alice</span><br><span class="line">    participant Bob</span><br><span class="line">    Alice-&gt;John: Hello John, how are you?</span><br><span class="line">    loop Healthcheck</span><br><span class="line">        John-&gt;John: Fight against hypochondria</span><br><span class="line">    end</span><br><span class="line">    Note right of John: Rational thoughts &lt;br&#x2F;&gt;prevail...</span><br><span class="line">    John--&gt;Alice: Great!</span><br><span class="line">    John-&gt;Bob: How about you?</span><br><span class="line">    Bob--&gt;John: Jolly good!</span><br></pre></td></tr></table></figure>

<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><p>如果不显示声明，参与者将根据第一次出现的顺序排列，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">    John--&gt;&gt;Alice: Great!</span><br></pre></td></tr></table></figure>
<p>第一条语句出现了两个参与者角色，而在这条语句中，Alice 在 John 之前，所以图中也是这个顺序。如果不想根据第一次出现的顺序来排，可以主动声明以定义顺序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant John</span><br><span class="line">    participant Alice</span><br><span class="line">    Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">    John--&gt;&gt;Alice: Great!</span><br></pre></td></tr></table></figure>

<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>可以给角色写一个简短的别名以方便书写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant A as Alice</span><br><span class="line">    participant J as John</span><br><span class="line">    A-&gt;&gt;J: Hello John, how are you?</span><br><span class="line">    J-&gt;&gt;A: Great!</span><br></pre></td></tr></table></figure>

<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>消息连线有六种样式。</p>
<p>有一个<code>-</code>是实线，两个<code>-</code>是虚线。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    A-&gt;B: 无箭头实线</span><br><span class="line">    A--&gt;B: 无箭头虚线(点线)</span><br><span class="line">    A-&gt;&gt;B: 有箭头实线</span><br><span class="line">    A--&gt;&gt;B: 有箭头实线</span><br><span class="line">    A-x B: 有箭头实线，加上叉</span><br><span class="line">    A--x B: 有箭头虚线，加上叉</span><br></pre></td></tr></table></figure>

<h3 id="活动期"><a href="#活动期" class="headerlink" title="活动期"></a>活动期</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">    %% activate 角色名 表示激活控制焦点</span><br><span class="line">    activate John</span><br><span class="line">    John--&gt;&gt;Alice: Great!</span><br><span class="line">    %% deactivate 角色名 表示控制焦点结束</span><br><span class="line">    deactivate John</span><br></pre></td></tr></table></figure>
<p>使用 <code>+/-</code> 的更方便的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;+John: Hello John, how are you?</span><br><span class="line">    John--&gt;&gt;-Alice: Great!</span><br></pre></td></tr></table></figure>
<p>可以嵌套：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;+John: Hello John, how are you?</span><br><span class="line">    Alice-&gt;&gt;+John: John, can you hear me?</span><br><span class="line">    John--&gt;&gt;-Alice: Hi Alice, I can hear you!</span><br><span class="line">    John--&gt;&gt;-Alice: I feel great!</span><br></pre></td></tr></table></figure>

<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>语法：Note [ right of | left of | over ] [Actor]。</p>
<table>
<thead>
<tr>
<th align="left">表述</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">right of</td>
<td align="left">右侧</td>
</tr>
<tr>
<td align="left">left of</td>
<td align="left">左侧</td>
</tr>
<tr>
<td align="left">over</td>
<td align="left">在当中，可以横跨多个参与者</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant John</span><br><span class="line">    Note right of John: Text in note</span><br></pre></td></tr></table></figure>
<p>over 可用于单独一个角色上，也可以用于相邻两个角色间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;John: Hello John, how are you?</span><br><span class="line">    Note over Alice,John: A typical interaction</span><br></pre></td></tr></table></figure>

<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loop Loop text</span><br><span class="line">... statements ...</span><br><span class="line">end</span><br><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;John: Hello John, how are you?</span><br><span class="line">    %% loop 后跟循环体说明文字</span><br><span class="line">    loop Every minute</span><br><span class="line">        John--&gt;Alice: Great!</span><br><span class="line">    %% 标记循环结束</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>语法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alt Describing text</span><br><span class="line">... statements ...</span><br><span class="line">else</span><br><span class="line">... statements ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>可选条件，比如在没有 else 分支的情况下使用，有点类似 java 中的 switch 的 default 分支，代表剩下所有情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">opt Describing text</span><br><span class="line">... statements ...</span><br><span class="line">end</span><br><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;Bob: Hello Bob, how are you?</span><br><span class="line">    alt is sick</span><br><span class="line">        Bob-&gt;&gt;Alice: Not so good :(</span><br><span class="line">    else is well</span><br><span class="line">        Bob-&gt;&gt;Alice: Feeling fresh like a daisy</span><br><span class="line">    end</span><br><span class="line">    opt Extra response</span><br><span class="line">        Bob-&gt;&gt;Alice: Thanks for asking</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年技术盘点与展望</title>
    <url>/2022/02/22/2021%E5%B9%B4%E6%8A%80%E6%9C%AF%E7%9B%98%E7%82%B9%E4%B8%8E%E5%B1%95%E6%9C%9B/</url>
    <content><![CDATA[<h1 id="2021年技术盘点与展望"><a href="#2021年技术盘点与展望" class="headerlink" title="2021年技术盘点与展望"></a>2021年技术盘点与展望</h1><p>本文摘抄自infoQ《2021年技术盘点与展望》</p>
<p><a href="https://www.infoq.cn/minibook/Rmc3QT7vIXdr0ovFhZZ8" target="_blank" rel="noopener">原文链接</a></p>
<p><strong>2021 年度技术盘点</strong></p>
<h2 id="解读编程语言的-2021：Go-与-Rust-走向「成熟」，Kotlin、wasm、Julia「无限生长」1"><a href="#解读编程语言的-2021：Go-与-Rust-走向「成熟」，Kotlin、wasm、Julia「无限生长」1" class="headerlink" title="解读编程语言的 2021：Go 与 Rust 走向「成熟」，Kotlin、wasm、Julia「无限生长」1"></a>解读编程语言的 2021：Go 与 Rust 走向「成熟」，Kotlin、wasm、Julia「无限生长」1</h2><h2 id="解读云原生的2021：抢占技术C位，迎来落地大爆发"><a href="#解读云原生的2021：抢占技术C位，迎来落地大爆发" class="headerlink" title="解读云原生的2021：抢占技术C位，迎来落地大爆发"></a>解读云原生的2021：抢占技术C位，迎来落地大爆发</h2><h2 id="解读数据架构的2021：大数据10体系基本建成，但头上仍有几朵乌云"><a href="#解读数据架构的2021：大数据10体系基本建成，但头上仍有几朵乌云" class="headerlink" title="解读数据架构的2021：大数据10体系基本建成，但头上仍有几朵乌云"></a>解读数据架构的2021：大数据10体系基本建成，但头上仍有几朵乌云</h2><h2 id="解读人工智能的2021：超大规模预训练模型爆发，自动驾驶迎来商业化前夜"><a href="#解读人工智能的2021：超大规模预训练模型爆发，自动驾驶迎来商业化前夜" class="headerlink" title="解读人工智能的2021：超大规模预训练模型爆发，自动驾驶迎来商业化前夜"></a>解读人工智能的2021：超大规模预训练模型爆发，自动驾驶迎来商业化前夜</h2><h3 id="2021-年度-AI-技术突破"><a href="#2021-年度-AI-技术突破" class="headerlink" title="2021 年度 AI 技术突破"></a>2021 年度 AI 技术突破</h3><h4 id="人工智能预测蛋白质结构"><a href="#人工智能预测蛋白质结构" class="headerlink" title="人工智能预测蛋白质结构"></a>人工智能预测蛋白质结构</h4><h5 id="AphaFold2“解锁”98-人类蛋白质组"><a href="#AphaFold2“解锁”98-人类蛋白质组" class="headerlink" title="AphaFold2“解锁”98%人类蛋白质组"></a>AphaFold2“解锁”98%人类蛋白质组</h5><h5 id="RoseTTAFold-可十分钟内计算出蛋白质结构"><a href="#RoseTTAFold-可十分钟内计算出蛋白质结构" class="headerlink" title="RoseTTAFold 可十分钟内计算出蛋白质结构"></a>RoseTTAFold 可十分钟内计算出蛋白质结构</h5><h5 id="其他研究进展"><a href="#其他研究进展" class="headerlink" title="其他研究进展"></a>其他研究进展</h5><h3 id="AI-技术-2021-年发展总结与展望"><a href="#AI-技术-2021-年发展总结与展望" class="headerlink" title="AI 技术 2021 年发展总结与展望"></a>AI 技术 2021 年发展总结与展望</h3><h4 id="人工智能迈向“炼大模型”阶段"><a href="#人工智能迈向“炼大模型”阶段" class="headerlink" title="人工智能迈向“炼大模型”阶段"></a>人工智能迈向“炼大模型”阶段</h4><h5 id="超大规模预训练模型的“军备竞赛”"><a href="#超大规模预训练模型的“军备竞赛”" class="headerlink" title="超大规模预训练模型的“军备竞赛”"></a>超大规模预训练模型的“军备竞赛”</h5><h5 id="预训练模型技术新进展"><a href="#预训练模型技术新进展" class="headerlink" title="预训练模型技术新进展"></a>预训练模型技术新进展</h5><h5 id="降低-AI-规模化落地的门槛"><a href="#降低-AI-规模化落地的门槛" class="headerlink" title="降低 AI 规模化落地的门槛"></a>降低 AI 规模化落地的门槛</h5><h5 id="小结和展望"><a href="#小结和展望" class="headerlink" title="小结和展望"></a>小结和展望</h5><h4 id="国产深度学习框架不再是“技术的跟随者”"><a href="#国产深度学习框架不再是“技术的跟随者”" class="headerlink" title="国产深度学习框架不再是“技术的跟随者”"></a>国产深度学习框架不再是“技术的跟随者”</h4><h5 id="新进展，新趋势"><a href="#新进展，新趋势" class="headerlink" title="新进展，新趋势"></a>新进展，新趋势</h5><h5 id="技术自立之路"><a href="#技术自立之路" class="headerlink" title="技术自立之路"></a>技术自立之路</h5><h5 id="研发难点"><a href="#研发难点" class="headerlink" title="研发难点"></a>研发难点</h5><h5 id="将更好地支持大模型训练"><a href="#将更好地支持大模型训练" class="headerlink" title="将更好地支持大模型训练"></a>将更好地支持大模型训练</h5><h4 id="智能语音这一年：技术突破不断，工业落地加速"><a href="#智能语音这一年：技术突破不断，工业落地加速" class="headerlink" title="智能语音这一年：技术突破不断，工业落地加速"></a>智能语音这一年：技术突破不断，工业落地加速</h4><h5 id="语⾳领域的⼤规模预训练模型层出不穷"><a href="#语⾳领域的⼤规模预训练模型层出不穷" class="headerlink" title="语⾳领域的⼤规模预训练模型层出不穷"></a>语⾳领域的⼤规模预训练模型层出不穷</h5><h5 id="工业界落地加速"><a href="#工业界落地加速" class="headerlink" title="工业界落地加速"></a>工业界落地加速</h5><h5 id="商业化难点主要在于商业模式选择"><a href="#商业化难点主要在于商业模式选择" class="headerlink" title="商业化难点主要在于商业模式选择"></a>商业化难点主要在于商业模式选择</h5><h5 id="端到端和预训练等技术仍然值得关注"><a href="#端到端和预训练等技术仍然值得关注" class="headerlink" title="端到端和预训练等技术仍然值得关注"></a>端到端和预训练等技术仍然值得关注</h5><h4 id="群雄逐鹿，谁能赢得自动驾驶之战？"><a href="#群雄逐鹿，谁能赢得自动驾驶之战？" class="headerlink" title="群雄逐鹿，谁能赢得自动驾驶之战？"></a>群雄逐鹿，谁能赢得自动驾驶之战？</h4><h5 id="造车热"><a href="#造车热" class="headerlink" title="造车热"></a>造车热</h5><h5 id="商业化前夜"><a href="#商业化前夜" class="headerlink" title="商业化前夜"></a>商业化前夜</h5><h5 id="2022，这些技术将是下半场竞争胜负的关键"><a href="#2022，这些技术将是下半场竞争胜负的关键" class="headerlink" title="2022，这些技术将是下半场竞争胜负的关键"></a>2022，这些技术将是下半场竞争胜负的关键</h5><h4 id="NLP，黄金时代持续？"><a href="#NLP，黄金时代持续？" class="headerlink" title="NLP，黄金时代持续？"></a>NLP，黄金时代持续？</h4><h5 id="基于提示的微调技术迅速流行"><a href="#基于提示的微调技术迅速流行" class="headerlink" title="基于提示的微调技术迅速流行"></a>基于提示的微调技术迅速流行</h5><h5 id="与-CV、语音识别相比，NLP-项目在业务中落地往往较慢"><a href="#与-CV、语音识别相比，NLP-项目在业务中落地往往较慢" class="headerlink" title="与 CV、语音识别相比，NLP 项目在业务中落地往往较慢"></a>与 CV、语音识别相比，NLP 项目在业务中落地往往较慢</h5><h5 id="明年，NLP-将在哪些场景实现规模化落地？"><a href="#明年，NLP-将在哪些场景实现规模化落地？" class="headerlink" title="明年，NLP 将在哪些场景实现规模化落地？"></a>明年，NLP 将在哪些场景实现规模化落地？</h5><h5 id="2022-年，NLP-值得关注的技术点"><a href="#2022-年，NLP-值得关注的技术点" class="headerlink" title="2022 年，NLP 值得关注的技术点"></a>2022 年，NLP 值得关注的技术点</h5><h4 id="元宇宙概念大火，计算机视觉是基石技术之一"><a href="#元宇宙概念大火，计算机视觉是基石技术之一" class="headerlink" title="元宇宙概念大火，计算机视觉是基石技术之一"></a>元宇宙概念大火，计算机视觉是基石技术之一</h4><h5 id="具身智能，从被动式-AI-转向主动式人工智能"><a href="#具身智能，从被动式-AI-转向主动式人工智能" class="headerlink" title="具身智能，从被动式 AI 转向主动式人工智能"></a>具身智能，从被动式 AI 转向主动式人工智能</h5><h5 id="进入元宇宙，需要智能感知和交互这张门票"><a href="#进入元宇宙，需要智能感知和交互这张门票" class="headerlink" title="进入元宇宙，需要智能感知和交互这张门票"></a>进入元宇宙，需要智能感知和交互这张门票</h5><h5 id="趋势一：面向内容生成的-AIGC"><a href="#趋势一：面向内容生成的-AIGC" class="headerlink" title="趋势一：面向内容生成的 AIGC"></a>趋势一：面向内容生成的 AIGC</h5><h5 id="趋势二：SCV-合成"><a href="#趋势二：SCV-合成" class="headerlink" title="趋势二：SCV 合成"></a>趋势二：SCV 合成</h5><h4 id="制约知识图谱商业化落地的主要问题在于标准化"><a href="#制约知识图谱商业化落地的主要问题在于标准化" class="headerlink" title="制约知识图谱商业化落地的主要问题在于标准化"></a>制约知识图谱商业化落地的主要问题在于标准化</h4><h5 id="重要技术进展"><a href="#重要技术进展" class="headerlink" title="重要技术进展"></a>重要技术进展</h5><h5 id="应用落地进展"><a href="#应用落地进展" class="headerlink" title="应用落地进展"></a>应用落地进展</h5><h3 id="2022-年，值得关注的重要技术趋势"><a href="#2022-年，值得关注的重要技术趋势" class="headerlink" title="2022 年，值得关注的重要技术趋势"></a>2022 年，值得关注的重要技术趋势</h3><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><h2 id="解读大前端的2021：究竟“卷”出了什么名堂？"><a href="#解读大前端的2021：究竟“卷”出了什么名堂？" class="headerlink" title="解读大前端的2021：究竟“卷”出了什么名堂？"></a>解读大前端的2021：究竟“卷”出了什么名堂？</h2><h2 id="解读操作系统的2021：触到了创新的天花板，却站在巨变的前夜"><a href="#解读操作系统的2021：触到了创新的天花板，却站在巨变的前夜" class="headerlink" title="解读操作系统的2021：触到了创新的天花板，却站在巨变的前夜"></a>解读操作系统的2021：触到了创新的天花板，却站在巨变的前夜</h2><h2 id="解读服务网格的2021：告别架构“大跃进”，技术生态百家争鸣"><a href="#解读服务网格的2021：告别架构“大跃进”，技术生态百家争鸣" class="headerlink" title="解读服务网格的2021：告别架构“大跃进”，技术生态百家争鸣"></a>解读服务网格的2021：告别架构“大跃进”，技术生态百家争鸣</h2><h2 id="解读Julia的2021：逐步迈向主流编程语言"><a href="#解读Julia的2021：逐步迈向主流编程语言" class="headerlink" title="解读Julia的2021：逐步迈向主流编程语言"></a>解读Julia的2021：逐步迈向主流编程语言</h2><h2 id="解读中间件的2021：被云原生重塑之后，选型更难了"><a href="#解读中间件的2021：被云原生重塑之后，选型更难了" class="headerlink" title="解读中间件的2021：被云原生重塑之后，选型更难了"></a>解读中间件的2021：被云原生重塑之后，选型更难了</h2><h2 id="解读架构的2021：服务网格开道，云原生架构成型"><a href="#解读架构的2021：服务网格开道，云原生架构成型" class="headerlink" title="解读架构的2021：服务网格开道，云原生架构成型"></a>解读架构的2021：服务网格开道，云原生架构成型</h2><h2 id="2021年是开源鸿蒙的元年，也是打基础的一年"><a href="#2021年是开源鸿蒙的元年，也是打基础的一年" class="headerlink" title="2021年是开源鸿蒙的元年，也是打基础的一年"></a>2021年是开源鸿蒙的元年，也是打基础的一年</h2><h2 id="解读鸿蒙系统的2021：喧嚣褪去，生态初具规模"><a href="#解读鸿蒙系统的2021：喧嚣褪去，生态初具规模" class="headerlink" title="解读鸿蒙系统的2021：喧嚣褪去，生态初具规模"></a>解读鸿蒙系统的2021：喧嚣褪去，生态初具规模</h2><h2 id="解读开源的2021：从“开发者亚文化”，变成主流软件开发模式"><a href="#解读开源的2021：从“开发者亚文化”，变成主流软件开发模式" class="headerlink" title="解读开源的2021：从“开发者亚文化”，变成主流软件开发模式"></a>解读开源的2021：从“开发者亚文化”，变成主流软件开发模式</h2><h2 id="解读计算机视觉的2021：「进化」的力量推动技术变革，元宇宙时代的重要技术基础"><a href="#解读计算机视觉的2021：「进化」的力量推动技术变革，元宇宙时代的重要技术基础" class="headerlink" title="解读计算机视觉的2021：「进化」的力量推动技术变革，元宇宙时代的重要技术基础"></a>解读计算机视觉的2021：「进化」的力量推动技术变革，元宇宙时代的重要技术基础</h2><h2 id="解读预训练大模型的2021年：人们正在驯服这些“庞然大物”"><a href="#解读预训练大模型的2021年：人们正在驯服这些“庞然大物”" class="headerlink" title="解读预训练大模型的2021年：人们正在驯服这些“庞然大物”"></a>解读预训练大模型的2021年：人们正在驯服这些“庞然大物”</h2><h2 id="解读Go语言的2021：稳定为王"><a href="#解读Go语言的2021：稳定为王" class="headerlink" title="解读Go语言的2021：稳定为王"></a>解读Go语言的2021：稳定为王</h2><h2 id="解读数据库的2021：资本进来添了一把火，开源已占据半壁江山"><a href="#解读数据库的2021：资本进来添了一把火，开源已占据半壁江山" class="headerlink" title="解读数据库的2021：资本进来添了一把火，开源已占据半壁江山"></a>解读数据库的2021：资本进来添了一把火，开源已占据半壁江山</h2><h2 id="漫谈操作系统现状：波澜不惊的应用环境与风起云涌的技术狂潮"><a href="#漫谈操作系统现状：波澜不惊的应用环境与风起云涌的技术狂潮" class="headerlink" title="漫谈操作系统现状：波澜不惊的应用环境与风起云涌的技术狂潮"></a>漫谈操作系统现状：波澜不惊的应用环境与风起云涌的技术狂潮</h2><p><strong>2022年度技术展望</strong></p>
<h2 id="编程语言将走入怎样的2022"><a href="#编程语言将走入怎样的2022" class="headerlink" title="编程语言将走入怎样的2022"></a>编程语言将走入怎样的2022</h2><h2 id="展望2022年大数据趋势：上云短期不会是ClickHouse社区目标，现在仍是“黄金时代”"><a href="#展望2022年大数据趋势：上云短期不会是ClickHouse社区目标，现在仍是“黄金时代”" class="headerlink" title="展望2022年大数据趋势：上云短期不会是ClickHouse社区目标，现在仍是“黄金时代”"></a>展望2022年大数据趋势：上云短期不会是ClickHouse社区目标，现在仍是“黄金时代”</h2><h2 id="展望中间件的2022：微服务中间件还需进一步优化，消息队列迈向“标准-化”"><a href="#展望中间件的2022：微服务中间件还需进一步优化，消息队列迈向“标准-化”" class="headerlink" title="展望中间件的2022：微服务中间件还需进一步优化，消息队列迈向“标准 化”"></a>展望中间件的2022：微服务中间件还需进一步优化，消息队列迈向“标准 化”</h2><h2 id="2022年，云原生领域有哪些值得关注的趋势？"><a href="#2022年，云原生领域有哪些值得关注的趋势？" class="headerlink" title="2022年，云原生领域有哪些值得关注的趋势？"></a>2022年，云原生领域有哪些值得关注的趋势？</h2><h2 id="展望架构的2022：热度居高不下的云原生，如何撑起架构的未来"><a href="#展望架构的2022：热度居高不下的云原生，如何撑起架构的未来" class="headerlink" title="展望架构的2022：热度居高不下的云原生，如何撑起架构的未来"></a>展望架构的2022：热度居高不下的云原生，如何撑起架构的未来</h2><h2 id="展望大前端的2022：VR大潮来袭，大前端迎来新机遇"><a href="#展望大前端的2022：VR大潮来袭，大前端迎来新机遇" class="headerlink" title="展望大前端的2022：VR大潮来袭，大前端迎来新机遇"></a>展望大前端的2022：VR大潮来袭，大前端迎来新机遇</h2><h2 id="展望操作系统的2022：加速驶向快车道，云、XPU和开源成“催化剂”"><a href="#展望操作系统的2022：加速驶向快车道，云、XPU和开源成“催化剂”" class="headerlink" title="展望操作系统的2022：加速驶向快车道，云、XPU和开源成“催化剂”"></a>展望操作系统的2022：加速驶向快车道，云、XPU和开源成“催化剂”</h2><h2 id="对话小马智行：量产、商业化、路线之争，聊聊自动驾驶的现在和未来"><a href="#对话小马智行：量产、商业化、路线之争，聊聊自动驾驶的现在和未来" class="headerlink" title="对话小马智行：量产、商业化、路线之争，聊聊自动驾驶的现在和未来"></a>对话小马智行：量产、商业化、路线之争，聊聊自动驾驶的现在和未来</h2><h3 id="对话腾讯云数据库技术负责人：得益于开源的深入和云厂商的崛起，数据库又重新回到了聚光灯下"><a href="#对话腾讯云数据库技术负责人：得益于开源的深入和云厂商的崛起，数据库又重新回到了聚光灯下" class="headerlink" title="对话腾讯云数据库技术负责人：得益于开源的深入和云厂商的崛起，数据库又重新回到了聚光灯下"></a>对话腾讯云数据库技术负责人：得益于开源的深入和云厂商的崛起，数据库又重新回到了聚光灯下</h3>]]></content>
      <categories>
        <category>技术视野</category>
      </categories>
      <tags>
        <tag>技术视野</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch7.15指南</title>
    <url>/2021/11/30/Elasticsearch7-15%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="Elasticsearch7-15指南"><a href="#Elasticsearch7-15指南" class="headerlink" title="Elasticsearch7.15指南"></a>Elasticsearch7.15指南</h2><h3 id="什么是Elasticsearch"><a href="#什么是Elasticsearch" class="headerlink" title="什么是Elasticsearch?"></a>什么是Elasticsearch?</h3><p>你知道，为了搜索（和分析）</p>
<p>Elasticsearch 是位于 Elastic Stack 核心的分布式搜索和分析引擎。Logstash 和 Beats 有助于收集、聚合和丰富您的数据并将其存储在 Elasticsearch 中。Kibana<br>使您能够以交互方式探索、可视化和共享对数据的洞察，并管理和监控堆栈。Elasticsearch 是索引、搜索和分析魔法发生的地方。</p>
<p>Elasticsearch 为所有类型的数据提供近乎实时的搜索和分析。无论您拥有结构化或非结构化文本、数值数据还是地理空间数据，Elasticsearch<br>都可以以支持快速搜索的方式高效地存储和索引它。您可以超越简单的数据检索和聚合信息来发现数据中的趋势和模式。随着您的数据和查询量的增长，Elasticsearch 的分布式特性使您的部署能够随之无缝增长。</p>
<p>虽然并非所有问题都是搜索问题，但 Elasticsearch 提供了在各种用例中处理数据的速度和灵活性：</p>
<ul>
<li>向应用程序或网站添加搜索框</li>
<li>存储和分析日志、指标和安全事件数据</li>
<li>使用机器学习自动实时建模数据的行为</li>
<li>使用 Elasticsearch 作为存储引擎自动化业务工作流</li>
<li>使用 Elasticsearch 作为地理信息系统 (GIS) 管理、集成和分析空间信息</li>
<li>使用 Elasticsearch 作为生物信息学研究工具存储和处理遗传数据</li>
</ul>
<p>我们不断对人们使用搜索的新颖方式感到惊讶。但是，无论您的用例是否与其中之一类似，或者您正在使用 Elasticsearch 来解决新问题，您在 Elasticsearch 中处理数据、文档和索引的方式都是相同的。</p>
<h3 id="数据输入：文档和索引"><a href="#数据输入：文档和索引" class="headerlink" title="数据输入：文档和索引"></a>数据输入：文档和索引</h3><p>Elasticsearch 是一个分布式文档存储。Elasticsearch 不是将信息存储为列状数据的行，而是存储已序列化为 JSON 文档的复杂数据结构。当集群中有多个 Elasticsearch<br>节点时，存储的文档分布在整个集群中，并且可以从任何节点立即访问。</p>
<p>存储文档后，它会被编入索引，并且可以近乎实时地在1 秒内完全搜索。Elasticsearch 使用一种称为倒排索引的数据结构，它支持非常快速的全文搜索。倒排索引列出出现在任何文档中的每个唯一单词，并标识每个单词出现的所有文档。</p>
<p>可以将索引视为文档的优化集合，每个文档都是字段的集合，这些字段是包含您的数据的键值对。默认情况下，Elasticsearch<br>索引每个字段中的所有数据，每个索引字段都有一个专用的、优化的数据结构。例如，文本字段存储在倒排索引中，数值和地理字段存储在 BKD 树中。使用每个字段的数据结构来组合和返回搜索结果的能力使 Elasticsearch 如此之快。</p>
<p>Elasticsearch 还具有无模式的能力，这意味着可以在不明确指定如何处理文档中可能出现的每个不同字段的情况下为文档编制索引。启用动态映射后，Elasticsearch<br>会自动检测并将新字段添加到索引中。这种默认行为使索引和探索数据变得容易——只需开始索引文档，Elasticsearch 就会检测并将布尔值、浮点和整数值、日期和字符串映射到适当的 Elasticsearch 数据类型。</p>
<p>但是，归根结底，您比 Elasticsearch 更了解您的数据以及您希望如何使用它。您可以定义规则来控制动态映射并显式定义映射以完全控制字段的存储和索引方式。</p>
<p>定义您自己的映射使您能够：</p>
<ul>
<li>区分全文字符串字段和精确值字符串字段</li>
<li>执行特定于语言的文本分析</li>
<li>优化部分匹配的字段</li>
<li>使用自定义日期格式</li>
<li>使用无法自动检测到的 数据类型geo_point和geo_shape<br>为了不同的目的以不同的方式索引相同的字段通常很有用。例如，您可能希望将字符串字段索引为用于全文搜索的文本字段和用于排序或聚合数据的关键字字段。或者，您可以选择使用多个语言分析器来处理包含用户输入的字符串字段的内容。</li>
</ul>
<p>在索引期间应用于全文字段的分析链也在搜索时使用。当您查询全文字段时，在索引中查找术语之前，查询文本会经过相同的分析。</p>
<h3 id="信息输出：搜索和分析"><a href="#信息输出：搜索和分析" class="headerlink" title="信息输出：搜索和分析"></a>信息输出：搜索和分析</h3><p>虽然您可以将 Elasticsearch 用作文档存储并检索文档及其元数据，但真正的强大之处在于能够轻松访问构建在 Apache Lucene 搜索引擎库上的全套搜索功能。</p>
<p>Elasticsearch 提供了一个简单、一致的 REST API 来管理您的集群以及索引和搜索您的数据。出于测试目的，您可以直接从命令行或通过 Kibana 中的开发人员控制台轻松提交请求。在您的应用程序中，您可以将<br>Elasticsearch 客户端 用于您选择的语言：Java、JavaScript、Go、.NET、PHP、Perl、Python 或 Ruby。</p>
<p>搜索您的数据</p>
<p>Elasticsearch REST API 支持结构化查询、全文查询和将两者结合的复杂查询。结构化查询类似于您可以在 SQL<br>中构造的查询类型。例如，您可以搜索索引中的gender和age字段并按字段employee对匹配项进行排序hire_date。全文查询查找与查询字符串匹配的所有文档，并按相关性排序返回它们——它们与您的搜索词的匹配程度。</p>
<p>除了搜索单个术语外，您还可以执行短语搜索、相似性搜索和前缀搜索，并获得自动完成建议。</p>
<p>有要搜索的地理空间数据或其他数字数据吗？Elasticsearch 在支持高性能地理和数值查询的优化数据结构中索引非文本数据。</p>
<p>您可以使用 Elasticsearch 的综合 JSON 样式查询语言 ( Query DSL )访问所有这些搜索功能。您还可以构建SQL 样式的查询以在 Elasticsearch 内部搜索和聚合数据，JDBC 和 ODBC<br>驱动程序使广泛的第三方应用程序能够通过 SQL 与 Elasticsearch 交互。</p>
<p>分析您的数据编辑 Elasticsearch 聚合使您能够构建复杂的数据摘要并深入了解关键指标、模式和趋势。聚合不仅可以找到众所周知的“大海捞针”，还可以让您回答以下问题：</p>
<ul>
<li>大海捞针有多少针？</li>
<li>针的平均长度是多少？</li>
<li>制造商细分的针的中位数长度是多少？</li>
<li>在过去的六个月中，每一个月都向大海捞针添加了多少针？</li>
</ul>
<p>您还可以使用聚合来回答更微妙的问题，例如：</p>
<ul>
<li>您最受欢迎的针头制造商是哪些？</li>
<li>是否有异常或异常的针团？</li>
</ul>
<p>因为聚合利用了用于搜索的相同数据结构，所以它们也非常快。这使您能够实时分析和可视化数据。您的报告和仪表板会随着数据的变化而更新，以便您可以根据最新信息采取行动。</p>
<p>更重要的是，聚合与搜索请求一起运行。您可以在单个请求中对相同数据同时搜索文档、过滤结果和执行分析。并且因为聚合是在特定搜索的上下文中计算的，所以您不仅会显示所有 70 号针的计数，还显示了与用户搜索条件匹配的 70<br>号针的计数——例如，所有尺寸 70不粘绣花针。</p>
<p>但是等等，还有更多编辑</p>
<p>想要自动化时间序列数据的分析吗？您可以使用 机器学习功能创建数据中正常行为的准确基线并识别异常模式。通过机器学习，您可以检测：</p>
<ul>
<li>与值、计数或频率的时间偏差相关的异常</li>
<li>统计稀有度</li>
<li>某个群体成员的异常行为</li>
</ul>
<p>最好的部分是？您无需指定算法、模型或其他与数据科学相关的配置即可执行此操作。</p>
<h3 id="可扩展性和弹性：集群、节点和分片"><a href="#可扩展性和弹性：集群、节点和分片" class="headerlink" title="可扩展性和弹性：集群、节点和分片"></a>可扩展性和弹性：集群、节点和分片</h3><p>Elasticsearch 旨在始终可用并根据您的需求进行扩展。它通过自然分布来做到这一点。您可以将服务器（节点）添加到集群以增加容量，Elasticsearch<br>会自动在所有可用节点之间分配您的数据和查询负载。无需大修您的应用程序，Elasticsearch 知道如何平衡多节点集群以提供可扩展性和高可用性。节点越多越好。</p>
<p>这是如何运作的？在幕后，Elasticsearch 索引实际上只是一个或多个物理分片的逻辑分组，其中每个分片实际上是一个独立的索引。通过将索引中的文档分布在多个分片中，并将这些分片分布在多个节点上，Elasticsearch<br>可以确保冗余，这既可以防止硬件故障，又可以在将节点添加到集群时增加查询容量。随着集群的增长（或缩小），Elasticsearch 会自动迁移分片以重新平衡集群。</p>
<p>有两种类型的分片：主分片和副本。索引中的每个文档都属于一个主分片。副本分片是主分片的副本。副本提供数据的冗余副本，以防止硬件故障并增加处理读取请求（如搜索或检索文档）的容量。</p>
<p>索引中的主分片数量在创建索引时是固定的，但副本分片的数量可以随时更改，而不会中断索引或查询操作。</p>
<p>这取决于……</p>
<p>关于分片大小和为索引配置的主分片数量，有许多性能考虑和权衡。分片越多，维护这些索引的开销就越大。分片大小越大，当 Elasticsearch 需要重新平衡集群时，移动分片所需的时间就越长。</p>
<p>查询大量小分片会使每个分片的处理速度更快，但更多查询意味着更多开销，因此查询较少数量的较大分片可能会更快。简而言之……视情况而定。</p>
<p>作为起点：</p>
<ul>
<li>旨在将平均分片大小保持在几 GB 到几十 GB 之间。对于具有基于时间的数据的用例，通常会看到 20GB 到 40GB 范围内的分片。</li>
<li>避免大量碎片问题。一个节点可以容纳的分片数量与可用的堆空间成正比。作为一般规则，每 GB 堆空间的分片数应小于 20。</li>
</ul>
<p>为您的用例确定最佳配置的最佳方法是 使用您自己的数据和查询进行测试。</p>
<p>发生灾害时</p>
<p>集群节点之间需要良好、可靠的连接。为了提供更好的连接，您通常将节点放在同一数据中心或附近的数据中心。但是，为了保持高可用性，您还需要避免任何单点故障。在一个位置发生重大中断的情况下，另一个位置的服务器需要能够接管。答案？跨集群复制 (<br>CCR)。</p>
<p>CCR 提供了一种将索引从主集群自动同步到可用作热备份的辅助远程集群的方法。如果主集群出现故障，辅助集群可以接管。您还可以使用 CCR 创建辅助集群，以便为您的用户提供地理位置邻近的读取请求。</p>
<p>跨集群复制是主动-被动的。主集群上的索引是活动的领导者索引，处理所有写请求。复制到辅助集群的索引是只读的跟随者。</p>
<p>护理和喂养</p>
<p>与任何企业系统一样，您需要工具来保护、管理和监控您的 Elasticsearch 集群。集成到 Elasticsearch 中的安全、监控和管理功能使您能够将Kibana 用作管理集群的控制中心。类似的特征数据汇总和指标生命周期管理<br>可帮助您明智随着时间的推移管理您的数据。</p>
<h3 id="7-15-中的新功能"><a href="#7-15-中的新功能" class="headerlink" title="7.15 中的新功能"></a>7.15 中的新功能</h3><p>以下是 Elasticsearch 7.15 中新增和改进的亮点！</p>
<p>有关此版本的详细信息，请参阅发行说明和 迁移指南。</p>
<p>其他版本： 7.14 | 7.13 | 7.12 | 7.11 | 7.10 | 7.9 | 7.8 | 7.7 | 7.6 | 7.5 | 7.4 | 7.3 | 7.2 | 7.1 | 7.0</p>
<p>索引磁盘使用API编辑</p>
<p>有一个新的 API 支持分析索引的每个字段的磁盘使用情况，包括整个索引本身。API 通过迭代字段的内容并跟踪读取的字节数来估计字段的磁盘使用情况。请参阅分析索引磁盘使用情况 API。</p>
<p>搜索矢量切片 API编辑</p>
<p>有一个新端点可用于从存储在 Elasticsearch 中的地理空间数据生成矢量切片。此功能对于想要在地图上呈现存储在 Elasticsearch 中的地理空间信息的任何应用程序都很有用。请参阅搜索矢量切片 API。</p>
<p>复合运行时字段编辑</p>
<p>运行时字段支持 grok 和 dissect 模式，但之前仅针对单个字段发出值。您现在可以使用composite运行时字段从单个字段发出多个值。请参阅定义复合运行时字段。</p>
<h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><p>本指南帮助初学者学习如何：</p>
<ul>
<li>在测试环境中安装和运行 Elasticsearch</li>
<li>将数据添加到 Elasticsearch</li>
<li>搜索和排序数据</li>
<li>在搜索期间从非结构化内容中提取字段</li>
</ul>
<h4 id="运行-Elasticsearch编辑"><a href="#运行-Elasticsearch编辑" class="headerlink" title="运行 Elasticsearch编辑"></a>运行 Elasticsearch编辑</h4><p>设置 Elasticsearch 的最简单方法是在 Elastic Cloud 上使用 Elasticsearch Service 创建托管部署。如果您更喜欢管理自己的测试环境，可以使用 Docker 安装和运行<br>Elasticsearch。</p>
<blockquote>
<blockquote>
<p>弹性搜索服务</p>
</blockquote>
<ol>
<li>获得免费试用。</li>
<li>登录Elastic Cloud。</li>
<li>单击创建部署。</li>
<li>选择一个解决方案并为您的部署命名。</li>
<li>单击创建部署并下载elastic用户的密码。</li>
</ol>
</blockquote>
<blockquote>
<blockquote>
<p>docker 安装</p>
</blockquote>
<p><strong>安装并运行 Elasticsearch</strong></p>
<p>1.安装并启动Docker 桌面。</p>
<p>2.运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network create elastic</span><br><span class="line">docker pull docker.elastic.co&#x2F;elasticsearch&#x2F;elasticsearch:7.15.2</span><br><span class="line">docker run --name es01-test --net elastic -p 127.0.0.1:9200:9200 -p 127.0.0.1:9300:9300 -e &quot;discovery.type&#x3D;single-node&quot; docker.elastic.co&#x2F;elasticsearch&#x2F;elasticsearch:7.15.2</span><br></pre></td></tr></table></figure>


<p><strong>安装并运行 Kibana</strong></p>
<p>要使用直观的 UI 分析、可视化和管理 Elasticsearch 数据，请安装 Kibana。</p>
<p>1.在新的终端会话中，运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;docker pull docker.elastic.co&#x2F;kibana&#x2F;kibana:7.15.2</span><br><span class="line">&gt;docker run --name kib01-test --net elastic -p 127.0.0.1:5601:5601 -e &quot;ELASTICSEARCH_HOSTS&#x3D;http:&#x2F;&#x2F;es01-test:9200&quot; docker.elastic.co&#x2F;kibana&#x2F;kibana:7.15.2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.要访问 Kibana，请转到<a href="http://localhost:5601" target="_blank" rel="noopener">http://localhost:5601</a></p>
</blockquote>
<h4 id="向-Elasticsearch-发送请求编辑"><a href="#向-Elasticsearch-发送请求编辑" class="headerlink" title="向 Elasticsearch 发送请求编辑"></a>向 Elasticsearch 发送请求编辑</h4><p>您使用 REST API 向 Elasticsearch 发送数据和其他请求。这使您可以使用任何发送 HTTP 请求的客户端（例如curl ）与 Elasticsearch 进行交互 。您还可以使用 Kibana 的控制台向<br>Elasticsearch 发送请求。</p>
<blockquote>
<blockquote>
<p>弹性搜索服务<br>使用卷曲</p>
</blockquote>
<p>1.要使用 curl 或其他客户端与 Elasticsearch 通信，您需要集群的端点。进入Elasticsearch页面，点击Copy endpoint。<br>2.要提交示例 API 请求，请在新的终端会话中运行以下 curl 命令。替换<password>为elastic用户的密码。替换<elasticsearch_endpoint>为您的端点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl - u elastic :&lt;密码&gt; &lt; elasticsearch_endpoint &gt;&#x2F;</span><br></pre></td></tr></table></figure>

<p>使用 Kibana</p>
<p>1.转到Kibana页面并单击Launch。</p>
<p>2.打开 Kibana 的主菜单并转到Dev Tools &gt; Console。</p>
<p>在控制台中运行以下示例 API 请求：</p>
</blockquote>
<p>Add dataedit</p>
<p>You add data to Elasticsearch as JSON objects called documents. Elasticsearch stores these documents in searchable indices.</p>
<p>For time series data, such as logs and metrics, you typically add documents to a data stream made up of multiple auto-generated backing indices.</p>
<p>A data stream requires an index template that matches its name. Elasticsearch uses this template to configure the stream’s backing indices. Documents sent to a data stream must have a @timestamp field.</p>
<p>Add a single documentedit</p>
<p>Submit the following indexing request to add a single log entry to the logs-my_app-default data stream. Since logs-my_app-default doesn’t exist, the request automatically creates it using the built-in logs-<em>-</em> index template.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X POST &quot;localhost:9200&#x2F;logs-my_app-default&#x2F;_doc?pretty&quot; -H &#39;Content-Type: application&#x2F;json&#39; -d&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;@timestamp&quot;: &quot;2099-05-06T16:21:15.000Z&quot;,</span><br><span class="line">  &quot;event&quot;: &#123;</span><br><span class="line">    &quot;original&quot;: &quot;192.0.2.42 - - [06&#x2F;May&#x2F;2099:16:21:15 +0000] \&quot;GET &#x2F;images&#x2F;bg.jpg HTTP&#x2F;1.0\&quot; 200 24736&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#39;</span><br></pre></td></tr></table></figure>
<p>The response includes metadata that Elasticsearch generates for the document:</p>
<ul>
<li>The backing _index that contains the document. Elasticsearch automatically generates the names of backing indices.</li>
<li>A unique _id for the document within the index.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot;: &quot;.ds-logs-my_app-default-2099-05-06-000001&quot;,</span><br><span class="line">  &quot;_type&quot;: &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot;: &quot;gl5MJXMBMk1dGnErnBW8&quot;,</span><br><span class="line">  &quot;_version&quot;: 1,</span><br><span class="line">  &quot;result&quot;: &quot;created&quot;,</span><br><span class="line">  &quot;_shards&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 2,</span><br><span class="line">    &quot;successful&quot;: 1,</span><br><span class="line">    &quot;failed&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_seq_no&quot;: 0,</span><br><span class="line">  &quot;_primary_term&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Add multiple documentsedit</li>
</ul>
<p>Use the _bulk endpoint to add multiple documents in one request. Bulk data must be newline-delimited JSON (NDJSON). Each line must end in a newline character (\n), including the last line.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X PUT &quot;localhost:9200&#x2F;logs-my_app-default&#x2F;_bulk?pretty&quot; -H &#39;Content-Type: application&#x2F;json&#39; -d&#39;</span><br><span class="line">&#123; &quot;create&quot;: &#123; &#125; &#125;</span><br><span class="line">&#123; &quot;@timestamp&quot;: &quot;2099-05-07T16:24:32.000Z&quot;, &quot;event&quot;: &#123; &quot;original&quot;: &quot;192.0.2.242 - - [07&#x2F;May&#x2F;2020:16:24:32 -0500] \&quot;GET &#x2F;images&#x2F;hm_nbg.jpg HTTP&#x2F;1.0\&quot; 304 0&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;create&quot;: &#123; &#125; &#125;</span><br><span class="line">&#123; &quot;@timestamp&quot;: &quot;2099-05-08T16:25:42.000Z&quot;, &quot;event&quot;: &#123; &quot;original&quot;: &quot;192.0.2.255 - - [08&#x2F;May&#x2F;2099:16:25:42 +0000] \&quot;GET &#x2F;favicon.ico HTTP&#x2F;1.0\&quot; 200 3638&quot; &#125; &#125;</span><br><span class="line">&#39;</span><br></pre></td></tr></table></figure>

<h4 id="Search-dataedit"><a href="#Search-dataedit" class="headerlink" title="Search dataedit"></a>Search dataedit</h4><p>Indexed documents are available for search in near real-time. The following search matches all log entries in logs-my_app-default and sorts them by @timestamp in descending order.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X GET &quot;localhost:9200&#x2F;logs-my_app-default&#x2F;_search?pretty&quot; -H &#39;Content-Type: application&#x2F;json&#39; -d&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;@timestamp&quot;: &quot;desc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">&#39;</span><br></pre></td></tr></table></figure>
<p>By default, the hits section of the response includes up to the first 10 documents that match the search. The _source of each hit contains the original JSON object submitted during indexing.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot;: 2,</span><br><span class="line">  &quot;timed_out&quot;: false,</span><br><span class="line">  &quot;_shards&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 1,</span><br><span class="line">    &quot;successful&quot;: 1,</span><br><span class="line">    &quot;skipped&quot;: 0,</span><br><span class="line">    &quot;failed&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: &#123;</span><br><span class="line">      &quot;value&quot;: 3,</span><br><span class="line">      &quot;relation&quot;: &quot;eq&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;max_score&quot;: null,</span><br><span class="line">    &quot;hits&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;: &quot;.ds-logs-my_app-default-2099-05-06-000001&quot;,</span><br><span class="line">        &quot;_type&quot;: &quot;_doc&quot;,</span><br><span class="line">        &quot;_id&quot;: &quot;PdjWongB9KPnaVm2IyaL&quot;,</span><br><span class="line">        &quot;_score&quot;: null,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;@timestamp&quot;: &quot;2099-05-08T16:25:42.000Z&quot;,</span><br><span class="line">          &quot;event&quot;: &#123;</span><br><span class="line">            &quot;original&quot;: &quot;192.0.2.255 - - [08&#x2F;May&#x2F;2099:16:25:42 +0000] \&quot;GET &#x2F;favicon.ico HTTP&#x2F;1.0\&quot; 200 3638&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;sort&quot;: [</span><br><span class="line">          4081940742000</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Get-specific-fields"><a href="#Get-specific-fields" class="headerlink" title="Get specific fields"></a>Get specific fields</h5><p>Parsing the entire _source is unwieldy for large documents. To exclude it from the response, set the _source parameter to false. Instead, use the fields parameter to retrieve the fields you want.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X GET &quot;localhost:9200&#x2F;logs-my_app-default&#x2F;_search?pretty&quot; -H &#39;Content-Type: application&#x2F;json&#39; -d&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;fields&quot;: [</span><br><span class="line">    &quot;@timestamp&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;_source&quot;: false,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;@timestamp&quot;: &quot;desc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">&#39;</span><br></pre></td></tr></table></figure>
<p>The response contains each hit’s fields values as a flat array.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;hits&quot;: &#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;hits&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;: &quot;.ds-logs-my_app-default-2099-05-06-000001&quot;,</span><br><span class="line">        &quot;_type&quot;: &quot;_doc&quot;,</span><br><span class="line">        &quot;_id&quot;: &quot;PdjWongB9KPnaVm2IyaL&quot;,</span><br><span class="line">        &quot;_score&quot;: null,</span><br><span class="line">        &quot;fields&quot;: &#123;</span><br><span class="line">          &quot;@timestamp&quot;: [</span><br><span class="line">            &quot;2099-05-08T16:25:42.000Z&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;sort&quot;: [</span><br><span class="line">          4081940742000</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Search-a-date-range"><a href="#Search-a-date-range" class="headerlink" title="Search a date range"></a>Search a date range</h5><p>To search across a specific time or IP range, use a range query.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X GET &quot;localhost:9200&#x2F;logs-my_app-default&#x2F;_search?pretty&quot; -H &#39;Content-Type: application&#x2F;json&#39; -d&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;@timestamp&quot;: &#123;</span><br><span class="line">        &quot;gte&quot;: &quot;2099-05-05&quot;,</span><br><span class="line">        &quot;lt&quot;: &quot;2099-05-08&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;fields&quot;: [</span><br><span class="line">    &quot;@timestamp&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;_source&quot;: false,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;@timestamp&quot;: &quot;desc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">&#39;</span><br></pre></td></tr></table></figure>
<p>You can use date math to define relative time ranges. The following query searches for data from the past day, which won’t match any log entries in logs-my_app-default.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X GET &quot;localhost:9200&#x2F;logs-my_app-default&#x2F;_search?pretty&quot; -H &#39;Content-Type: application&#x2F;json&#39; -d&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;@timestamp&quot;: &#123;</span><br><span class="line">        &quot;gte&quot;: &quot;now-1d&#x2F;d&quot;,</span><br><span class="line">        &quot;lt&quot;: &quot;now&#x2F;d&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;fields&quot;: [</span><br><span class="line">    &quot;@timestamp&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;_source&quot;: false,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;@timestamp&quot;: &quot;desc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">&#39;</span><br></pre></td></tr></table></figure>
<h5 id="Extract-fields-from-unstructured-contentedit"><a href="#Extract-fields-from-unstructured-contentedit" class="headerlink" title="Extract fields from unstructured contentedit"></a>Extract fields from unstructured contentedit</h5><p>You can extract runtime fields from unstructured content, such as log messages, during a search.</p>
<p>Use the following search to extract the source.ip runtime field from event.original. To include it in the response, add source.ip to the fields parameter.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X GET &quot;localhost:9200&#x2F;logs-my_app-default&#x2F;_search?pretty&quot; -H &#39;Content-Type: application&#x2F;json&#39; -d&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;runtime_mappings&quot;: &#123;</span><br><span class="line">    &quot;source.ip&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;ip&quot;,</span><br><span class="line">      &quot;script&quot;: &quot;String sourceip&#x3D;grok(\u0027%&#123;IPORHOST:sourceip&#125; .*\u0027).extract(doc[ \&quot;event.original\&quot; ].value)?.sourceip;\nif (sourceip !&#x3D; null) emit(sourceip);&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;@timestamp&quot;: &#123;</span><br><span class="line">        &quot;gte&quot;: &quot;2099-05-05&quot;,</span><br><span class="line">        &quot;lt&quot;: &quot;2099-05-08&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;fields&quot;: [</span><br><span class="line">    &quot;@timestamp&quot;,</span><br><span class="line">    &quot;source.ip&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;_source&quot;: false,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;@timestamp&quot;: &quot;desc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">&#39;</span><br></pre></td></tr></table></figure>
<h5 id="Combine-queriesedit"><a href="#Combine-queriesedit" class="headerlink" title="Combine queriesedit"></a>Combine queriesedit</h5><p>You can use the bool query to combine multiple queries. The following search combines two range queries: one on @timestamp and one on the source.ip runtime field.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X GET &quot;localhost:9200&#x2F;logs-my_app-default&#x2F;_search?pretty&quot; -H &#39;Content-Type: application&#x2F;json&#39; -d&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;runtime_mappings&quot;: &#123;</span><br><span class="line">    &quot;source.ip&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;ip&quot;,</span><br><span class="line">      &quot;script&quot;: &quot;String sourceip&#x3D;grok(\u0027%&#123;IPORHOST:sourceip&#125; .*\u0027).extract(doc[ \&quot;event.original\&quot; ].value)?.sourceip;\nif (sourceip !&#x3D; null) emit(sourceip);&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;range&quot;: &#123;</span><br><span class="line">            &quot;@timestamp&quot;: &#123;</span><br><span class="line">              &quot;gte&quot;: &quot;2099-05-05&quot;,</span><br><span class="line">              &quot;lt&quot;: &quot;2099-05-08&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;range&quot;: &#123;</span><br><span class="line">            &quot;source.ip&quot;: &#123;</span><br><span class="line">              &quot;gte&quot;: &quot;192.0.2.0&quot;,</span><br><span class="line">              &quot;lte&quot;: &quot;192.0.2.240&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;fields&quot;: [</span><br><span class="line">    &quot;@timestamp&quot;,</span><br><span class="line">    &quot;source.ip&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;_source&quot;: false,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;@timestamp&quot;: &quot;desc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">&#39;</span><br></pre></td></tr></table></figure>
<h5 id="Aggregate-dataedit"><a href="#Aggregate-dataedit" class="headerlink" title="Aggregate dataedit"></a>Aggregate dataedit</h5><p>Use aggregations to summarize data as metrics, statistics, or other analytics.</p>
<p>The following search uses an aggregation to calculate the average_response_size using the http.response.body.bytes runtime field. The aggregation only runs on documents that match the query.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X GET &quot;localhost:9200&#x2F;logs-my_app-default&#x2F;_search?pretty&quot; -H &#39;Content-Type: application&#x2F;json&#39; -d&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;runtime_mappings&quot;: &#123;</span><br><span class="line">    &quot;http.response.body.bytes&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;long&quot;,</span><br><span class="line">      &quot;script&quot;: &quot;String bytes&#x3D;grok(\u0027%&#123;COMMONAPACHELOG&#125;\u0027).extract(doc[ \&quot;event.original\&quot; ].value)?.bytes;\nif (bytes !&#x3D; null) emit(Integer.parseInt(bytes));&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;average_response_size&quot;:&#123;</span><br><span class="line">      &quot;avg&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;http.response.body.bytes&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;range&quot;: &#123;</span><br><span class="line">            &quot;@timestamp&quot;: &#123;</span><br><span class="line">              &quot;gte&quot;: &quot;2099-05-05&quot;,</span><br><span class="line">              &quot;lt&quot;: &quot;2099-05-08&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;fields&quot;: [</span><br><span class="line">    &quot;@timestamp&quot;,</span><br><span class="line">    &quot;http.response.body.bytes&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;_source&quot;: false,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;@timestamp&quot;: &quot;desc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">&#39;</span><br></pre></td></tr></table></figure>
<p>The response’s aggregations object contains aggregation results.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;aggregations&quot; : &#123;</span><br><span class="line">    &quot;average_response_size&quot; : &#123;</span><br><span class="line">      &quot;value&quot; : 12368.0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Explore more search optionsedit<br>To keep exploring, index more data to your data stream and check out Common search options.</p>
<h4 id="Clean-upedit"><a href="#Clean-upedit" class="headerlink" title="Clean upedit"></a>Clean upedit</h4><p>When you’re done, delete your test data stream and its backing indices.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X DELETE &quot;localhost:9200&#x2F;_data_stream&#x2F;logs-my_app-default?pretty&quot;</span><br></pre></td></tr></table></figure>
<p>You can also delete your test deployment.</p>
<blockquote>
<blockquote>
<p>Elasticsearch Service</p>
</blockquote>
<p>Click Delete deployment from the deployment overview page and follow the prompts.</p>
</blockquote>
<blockquote>
<blockquote>
<p>Self-managed</p>
</blockquote>
<p>To stop your Elasticsearch and Kibana Docker containers, run:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop es01-test</span><br><span class="line">docker stop kib01-test</span><br></pre></td></tr></table></figure>

<p>To remove the containers and their network, run:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;docker network rm elastic</span><br><span class="line">docker rm es01-test</span><br><span class="line">docker rm kib01-test</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>What’s next?edit</strong></p>
<ul>
<li>Get the most out of your time series data by setting up data tiers and ILM. See Use Elasticsearch for time series data.</li>
<li>Use Fleet and Elastic Agent to collect logs and metrics directly from your data sources and send them to Elasticsearch. See the Fleet quick start guide.</li>
<li>Use Kibana to explore, visualize, and manage your Elasticsearch data. See the Kibana quick start guide.</li>
</ul>
<h3 id="Set-up-Elasticsearchedit"><a href="#Set-up-Elasticsearchedit" class="headerlink" title="Set up Elasticsearchedit"></a>Set up Elasticsearchedit</h3><p>This section includes information on how to setup Elasticsearch and get it running, including:</p>
<ul>
<li>Downloading</li>
<li>Installing</li>
<li>Starting</li>
<li>Configuring</li>
</ul>
<h4 id="Supported-platforms"><a href="#Supported-platforms" class="headerlink" title="Supported platforms"></a>Supported platforms</h4><p>The matrix of officially supported operating systems and JVMs is available here: Support Matrix. Elasticsearch is tested on the listed platforms, but it is possible that it will work on other platforms too.</p>
<h4 id="Java-JVM-Version"><a href="#Java-JVM-Version" class="headerlink" title="Java (JVM) Version"></a>Java (JVM) Version</h4><p>Elasticsearch is built using Java, and includes a bundled version of OpenJDK from the JDK maintainers (GPLv2+CE) within each distribution. The bundled JVM is the recommended JVM and is located within the jdk directory of the Elasticsearch home directory.</p>
<p>To use your own version of Java, set the ES_JAVA_HOME environment variable. If you must use a version of Java that is different from the bundled JVM, we recommend using a supported LTS version of Java. Elasticsearch will refuse to start if a known-bad version of Java is used. The bundled JVM directory may be removed when using your own JVM.</p>
<h4 id="Use-dedicated-hosts"><a href="#Use-dedicated-hosts" class="headerlink" title="Use dedicated hosts"></a>Use dedicated hosts</h4><p>In production, we recommend you run Elasticsearch on a dedicated host or as a primary service. Several Elasticsearch features, such as automatic JVM heap sizing, assume it’s the only resource-intensive application on the host or container. For example, you might run Metricbeat alongside Elasticsearch for cluster statistics, but a resource-heavy Logstash deployment should be on its own host.</p>
<h3 id="Installing-Elasticsearch"><a href="#Installing-Elasticsearch" class="headerlink" title="Installing Elasticsearch"></a>Installing Elasticsearch</h3><h4 id="Hosted-Elasticsearch"><a href="#Hosted-Elasticsearch" class="headerlink" title="Hosted Elasticsearch"></a>Hosted Elasticsearch</h4><p>You can run Elasticsearch on your own hardware or use our hosted Elasticsearch Service that is available on AWS, GCP, and Azure. Try the Elasticsearch Service for free.</p>
<h4 id="Installing-Elasticsearch-Yourself"><a href="#Installing-Elasticsearch-Yourself" class="headerlink" title="Installing Elasticsearch Yourself"></a>Installing Elasticsearch Yourself</h4><p>Elasticsearch is provided in the following package formats:</p>
<table>
<thead>
<tr>
<th align="left">系统</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Linux and MacOS tar.gz archives</td>
<td align="left">The tar.gz archives are available for installation on any Linux distribution and MacOS.</td>
</tr>
<tr>
<td align="left">Windows .zip archive</td>
<td align="left">The zip archive is suitable for installation on Windows.</td>
</tr>
<tr>
<td align="left">deb</td>
<td align="left">The deb package is suitable for Debian, Ubuntu, and other Debian-based systems. Debian packages may be downloaded from the Elasticsearch website or from our Debian repository.</td>
</tr>
<tr>
<td align="left">rpm</td>
<td align="left">The rpm package is suitable for installation on Red Hat, Centos, SLES, OpenSuSE and other RPM-based systems. RPMs may be downloaded from the Elasticsearch website or from our RPM repository.</td>
</tr>
<tr>
<td align="left">msi</td>
<td align="left">[beta] This functionality is in beta and is subject to change. The design and code is less mature than official GA features and is being provided as-is with no warranties. Beta features are not subject to the support SLA of official GA features.The msi package is suitable for installation on Windows 64-bit systems with at least .NET 4.5 framework installed, and is the easiest choice for getting started with Elasticsearch on Windows. MSIs may be downloaded from the Elasticsearch website.</td>
</tr>
<tr>
<td align="left">docker</td>
<td align="left">Images are available for running Elasticsearch as Docker containers. They may be downloaded from the Elastic Docker Registry.<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.15/docker.html" target="_blank" rel="noopener">Install Elasticsearch with Docker</a></td>
</tr>
<tr>
<td align="left">brew</td>
<td align="left">Formulae are available from the Elastic Homebrew tap for installing Elasticsearch on macOS with the Homebrew package manager.</td>
</tr>
</tbody></table>
<h4 id="Configuration-Management-Tools"><a href="#Configuration-Management-Tools" class="headerlink" title="Configuration Management Tools"></a>Configuration Management Tools</h4><p>We also provide the following configuration management tools to help with large deployments:</p>
<table>
<thead>
<tr>
<th align="left">tool</th>
<th align="left">url</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Puppet</td>
<td align="left"><a href="https://github.com/voxpupuli/puppet-elasticsearch" target="_blank" rel="noopener">puppet-elasticsearch</a></td>
</tr>
<tr>
<td align="left">Chef</td>
<td align="left"><a href="https://github.com/elastic/cookbook-elasticsearch" target="_blank" rel="noopener">cookbook-elasticsearch</a></td>
</tr>
<tr>
<td align="left">Ansible</td>
<td align="left"><a href="https://github.com/elastic/ansible-elasticsearch" target="_blank" rel="noopener">ansible-elasticsearch</a></td>
</tr>
</tbody></table>
<h3 id="Install-Elasticsearch-from-archive-on-Linux-or-MacOS"><a href="#Install-Elasticsearch-from-archive-on-Linux-or-MacOS" class="headerlink" title="Install Elasticsearch from archive on Linux or MacOS"></a>Install Elasticsearch from archive on Linux or MacOS</h3><h3 id="Configuring-Elasticsearchedit"><a href="#Configuring-Elasticsearchedit" class="headerlink" title="Configuring Elasticsearchedit"></a>Configuring Elasticsearchedit</h3><p>Elasticsearch ships with good defaults and requires very little configuration. Most settings can be changed on a running cluster using the Cluster update settings API.</p>
<p>The configuration files should contain settings which are node-specific (such as node.name and paths), or settings which a node requires in order to be able to join a cluster, such as cluster.name and network.host.</p>
<h4 id="Config-files-locationedit"><a href="#Config-files-locationedit" class="headerlink" title="Config files locationedit"></a>Config files locationedit</h4><p>Elasticsearch has three configuration files:</p>
<ul>
<li>elasticsearch.yml for configuring Elasticsearch</li>
<li>jvm.options for configuring Elasticsearch JVM settings</li>
<li>log4j2.properties for configuring Elasticsearch logging</li>
</ul>
<p>These files are located in the config directory, whose default location depends on whether or not the installation is from an archive distribution (tar.gz or zip) or a package distribution (Debian or RPM packages).</p>
<p>For the archive distributions, the config directory location defaults to $ES_HOME/config. The location of the config directory can be changed via the ES_PATH_CONF environment variable as follows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ES_PATH_CONF&#x3D;&#x2F;path&#x2F;to&#x2F;my&#x2F;config .&#x2F;bin&#x2F;elasticsearch</span><br></pre></td></tr></table></figure>
<p>Alternatively, you can export the ES_PATH_CONF environment variable via the command line or via your shell profile.</p>
<p>For the package distributions, the config directory location defaults to /etc/elasticsearch. The location of the config directory can also be changed via the ES_PATH_CONF environment variable, but note that setting this in your shell is not sufficient. Instead, this variable is sourced from /etc/default/elasticsearch (for the Debian package) and /etc/sysconfig/elasticsearch (for the RPM package). You will need to edit the ES_PATH_CONF=/etc/elasticsearch entry in one of these files accordingly to change the config directory location.</p>
]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>解读人工智能的2021：超大规模预训练模型爆发，自动驾驶迎来商业化前夜</title>
    <url>/2022/02/22/%E8%A7%A3%E8%AF%BB%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%842021%EF%BC%9A%E8%B6%85%E5%A4%A7%E8%A7%84%E6%A8%A1%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E7%88%86%E5%8F%91%EF%BC%8C%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E8%BF%8E%E6%9D%A5%E5%95%86%E4%B8%9A%E5%8C%96%E5%89%8D%E5%A4%9C/</url>
    <content><![CDATA[<p>本文摘抄自infoQ《2021年技术盘点与展望》</p>
<p><a href="https://www.infoq.cn/minibook/Rmc3QT7vIXdr0ovFhZZ8" target="_blank" rel="noopener">原文链接</a></p>
<h2 id="解读人工智能的2021：超大规模预训练模型爆发，自动驾驶迎来商业化前夜"><a href="#解读人工智能的2021：超大规模预训练模型爆发，自动驾驶迎来商业化前夜" class="headerlink" title="解读人工智能的2021：超大规模预训练模型爆发，自动驾驶迎来商业化前夜"></a>解读人工智能的2021：超大规模预训练模型爆发，自动驾驶迎来商业化前夜</h2><p><strong>AI 技术</strong></p>
<ul>
<li><p>人工智能大模型</p>
</li>
<li><p>深度学习框架</p>
</li>
<li><p>NLP</p>
</li>
<li><p>智能语音</p>
<table>
<thead>
<tr>
<th>col1</th>
<th>col2</th>
<th>col3</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>自动驾驶</p>
</li>
<li><p>知识图谱</p>
</li>
</ul>
<h3 id="2021-年度-AI-技术突破"><a href="#2021-年度-AI-技术突破" class="headerlink" title="2021 年度 AI 技术突破"></a>2021 年度 AI 技术突破</h3><h4 id="人工智能预测蛋白质结构"><a href="#人工智能预测蛋白质结构" class="headerlink" title="人工智能预测蛋白质结构"></a>人工智能预测蛋白质结构</h4><h5 id="AphaFold2“解锁”98-人类蛋白质组"><a href="#AphaFold2“解锁”98-人类蛋白质组" class="headerlink" title="AphaFold2“解锁”98%人类蛋白质组"></a>AphaFold2“解锁”98%人类蛋白质组</h5><h5 id="RoseTTAFold-可十分钟内计算出蛋白质结构"><a href="#RoseTTAFold-可十分钟内计算出蛋白质结构" class="headerlink" title="RoseTTAFold 可十分钟内计算出蛋白质结构"></a>RoseTTAFold 可十分钟内计算出蛋白质结构</h5><h5 id="其他研究进展"><a href="#其他研究进展" class="headerlink" title="其他研究进展"></a>其他研究进展</h5><h3 id="AI-技术-2021-年发展总结与展望"><a href="#AI-技术-2021-年发展总结与展望" class="headerlink" title="AI 技术 2021 年发展总结与展望"></a>AI 技术 2021 年发展总结与展望</h3><p>去年，GPT-3 横空出世，这个具有 1750 亿参数规模的预训练模型所表现出来的零样本与小样本学习能力刷新了人们的认知，也引爆了 2021 年 AI 大模型研究的热潮。</p>
<h4 id="人工智能迈向“炼大模型”阶段"><a href="#人工智能迈向“炼大模型”阶段" class="headerlink" title="人工智能迈向“炼大模型”阶段"></a>人工智能迈向“炼大模型”阶段</h4><p>2021 年 1 月，Google 推出的 Switch Transformer 模型以高达 1.6 万亿的参数量打 破了 GPT-3 作为最大 AI 模型的统治地位，成为史上首个万亿级语言模型。</p>
<p>国内研究机构也不甘示弱。今年 6 月，北京智源人工智能研究院发布了超大规模智能 模型“悟道 2.0”，达到 1.75 万亿参数，超过 Switch Transformer 成为全球最大的预训 练模型。</p>
<h5 id="超大规模预训练模型的“军备竞赛”"><a href="#超大规模预训练模型的“军备竞赛”" class="headerlink" title="超大规模预训练模型的“军备竞赛”"></a>超大规模预训练模型的“军备竞赛”</h5><h5 id="预训练模型技术新进展"><a href="#预训练模型技术新进展" class="headerlink" title="预训练模型技术新进展"></a>预训练模型技术新进展</h5><h5 id="降低-AI-规模化落地的门槛"><a href="#降低-AI-规模化落地的门槛" class="headerlink" title="降低 AI 规模化落地的门槛"></a>降低 AI 规模化落地的门槛</h5><h5 id="小结和展望"><a href="#小结和展望" class="headerlink" title="小结和展望"></a>小结和展望</h5><h4 id="国产深度学习框架不再是“技术的跟随者”"><a href="#国产深度学习框架不再是“技术的跟随者”" class="headerlink" title="国产深度学习框架不再是“技术的跟随者”"></a>国产深度学习框架不再是“技术的跟随者”</h4><h5 id="新进展，新趋势"><a href="#新进展，新趋势" class="headerlink" title="新进展，新趋势"></a>新进展，新趋势</h5><h5 id="技术自立之路"><a href="#技术自立之路" class="headerlink" title="技术自立之路"></a>技术自立之路</h5><h5 id="研发难点"><a href="#研发难点" class="headerlink" title="研发难点"></a>研发难点</h5><h5 id="将更好地支持大模型训练"><a href="#将更好地支持大模型训练" class="headerlink" title="将更好地支持大模型训练"></a>将更好地支持大模型训练</h5><h4 id="智能语音这一年：技术突破不断，工业落地加速"><a href="#智能语音这一年：技术突破不断，工业落地加速" class="headerlink" title="智能语音这一年：技术突破不断，工业落地加速"></a>智能语音这一年：技术突破不断，工业落地加速</h4><h5 id="语⾳领域的⼤规模预训练模型层出不穷"><a href="#语⾳领域的⼤规模预训练模型层出不穷" class="headerlink" title="语⾳领域的⼤规模预训练模型层出不穷"></a>语⾳领域的⼤规模预训练模型层出不穷</h5><h5 id="工业界落地加速"><a href="#工业界落地加速" class="headerlink" title="工业界落地加速"></a>工业界落地加速</h5><h5 id="商业化难点主要在于商业模式选择"><a href="#商业化难点主要在于商业模式选择" class="headerlink" title="商业化难点主要在于商业模式选择"></a>商业化难点主要在于商业模式选择</h5><h5 id="端到端和预训练等技术仍然值得关注"><a href="#端到端和预训练等技术仍然值得关注" class="headerlink" title="端到端和预训练等技术仍然值得关注"></a>端到端和预训练等技术仍然值得关注</h5><h4 id="群雄逐鹿，谁能赢得自动驾驶之战？"><a href="#群雄逐鹿，谁能赢得自动驾驶之战？" class="headerlink" title="群雄逐鹿，谁能赢得自动驾驶之战？"></a>群雄逐鹿，谁能赢得自动驾驶之战？</h4><h5 id="造车热"><a href="#造车热" class="headerlink" title="造车热"></a>造车热</h5><h5 id="商业化前夜"><a href="#商业化前夜" class="headerlink" title="商业化前夜"></a>商业化前夜</h5><h5 id="2022，这些技术将是下半场竞争胜负的关键"><a href="#2022，这些技术将是下半场竞争胜负的关键" class="headerlink" title="2022，这些技术将是下半场竞争胜负的关键"></a>2022，这些技术将是下半场竞争胜负的关键</h5><h4 id="NLP，黄金时代持续？"><a href="#NLP，黄金时代持续？" class="headerlink" title="NLP，黄金时代持续？"></a>NLP，黄金时代持续？</h4><h5 id="基于提示的微调技术迅速流行"><a href="#基于提示的微调技术迅速流行" class="headerlink" title="基于提示的微调技术迅速流行"></a>基于提示的微调技术迅速流行</h5><h5 id="与-CV、语音识别相比，NLP-项目在业务中落地往往较慢"><a href="#与-CV、语音识别相比，NLP-项目在业务中落地往往较慢" class="headerlink" title="与 CV、语音识别相比，NLP 项目在业务中落地往往较慢"></a>与 CV、语音识别相比，NLP 项目在业务中落地往往较慢</h5><h5 id="明年，NLP-将在哪些场景实现规模化落地？"><a href="#明年，NLP-将在哪些场景实现规模化落地？" class="headerlink" title="明年，NLP 将在哪些场景实现规模化落地？"></a>明年，NLP 将在哪些场景实现规模化落地？</h5><h5 id="2022-年，NLP-值得关注的技术点"><a href="#2022-年，NLP-值得关注的技术点" class="headerlink" title="2022 年，NLP 值得关注的技术点"></a>2022 年，NLP 值得关注的技术点</h5><h4 id="元宇宙概念大火，计算机视觉是基石技术之一"><a href="#元宇宙概念大火，计算机视觉是基石技术之一" class="headerlink" title="元宇宙概念大火，计算机视觉是基石技术之一"></a>元宇宙概念大火，计算机视觉是基石技术之一</h4><h5 id="具身智能，从被动式-AI-转向主动式人工智能"><a href="#具身智能，从被动式-AI-转向主动式人工智能" class="headerlink" title="具身智能，从被动式 AI 转向主动式人工智能"></a>具身智能，从被动式 AI 转向主动式人工智能</h5><h5 id="进入元宇宙，需要智能感知和交互这张门票"><a href="#进入元宇宙，需要智能感知和交互这张门票" class="headerlink" title="进入元宇宙，需要智能感知和交互这张门票"></a>进入元宇宙，需要智能感知和交互这张门票</h5><h5 id="趋势一：面向内容生成的-AIGC"><a href="#趋势一：面向内容生成的-AIGC" class="headerlink" title="趋势一：面向内容生成的 AIGC"></a>趋势一：面向内容生成的 AIGC</h5><h5 id="趋势二：SCV-合成"><a href="#趋势二：SCV-合成" class="headerlink" title="趋势二：SCV 合成"></a>趋势二：SCV 合成</h5><h4 id="制约知识图谱商业化落地的主要问题在于标准化"><a href="#制约知识图谱商业化落地的主要问题在于标准化" class="headerlink" title="制约知识图谱商业化落地的主要问题在于标准化"></a>制约知识图谱商业化落地的主要问题在于标准化</h4><h5 id="重要技术进展"><a href="#重要技术进展" class="headerlink" title="重要技术进展"></a>重要技术进展</h5><h5 id="应用落地进展"><a href="#应用落地进展" class="headerlink" title="应用落地进展"></a>应用落地进展</h5><h3 id="2022-年，值得关注的重要技术趋势"><a href="#2022-年，值得关注的重要技术趋势" class="headerlink" title="2022 年，值得关注的重要技术趋势"></a>2022 年，值得关注的重要技术趋势</h3><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3>]]></content>
      <categories>
        <category>技术视野</category>
      </categories>
      <tags>
        <tag>技术视野</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>解读数据架构的2021：大数据10体系基本建成，但头上仍有几朵乌云</title>
    <url>/2022/02/22/%E8%A7%A3%E8%AF%BB%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%9A%842021%EF%BC%9A%E5%A4%A7%E6%95%B0%E6%8D%AE10%E4%BD%93%E7%B3%BB%E5%9F%BA%E6%9C%AC%E5%BB%BA%E6%88%90%EF%BC%8C%E4%BD%86%E5%A4%B4%E4%B8%8A%E4%BB%8D%E6%9C%89%E5%87%A0%E6%9C%B5%E4%B9%8C%E4%BA%91/</url>
    <content><![CDATA[<p>本文摘抄自infoQ《2021年技术盘点与展望》</p>
<p><a href="https://www.infoq.cn/minibook/Rmc3QT7vIXdr0ovFhZZ8" target="_blank" rel="noopener">原文链接</a></p>
<h2 id="解读数据架构的2021：大数据10体系基本建成，但头上仍有几朵乌云"><a href="#解读数据架构的2021：大数据10体系基本建成，但头上仍有几朵乌云" class="headerlink" title="解读数据架构的2021：大数据10体系基本建成，但头上仍有几朵乌云"></a>解读数据架构的2021：大数据10体系基本建成，但头上仍有几朵乌云</h2><h3 id="2021年，大数据领域发展到哪一阶段？"><a href="#2021年，大数据领域发展到哪一阶段？" class="headerlink" title="2021年，大数据领域发展到哪一阶段？"></a>2021年，大数据领域发展到哪一阶段？</h3><p>Gartner Hype Cycle 把整个发展周期分成 5 个部分</p>
<ul>
<li>创新期  </li>
<li>狂热期</li>
<li>冷静期</li>
<li>复兴期</li>
<li>普惠期 </li>
</ul>
<h4 id="大数据技术体系-1-0-基本建成"><a href="#大数据技术体系-1-0-基本建成" class="headerlink" title="大数据技术体系 1.0 基本建成"></a>大数据技术体系 1.0 基本建成</h4><p>新技术</p>
<ul>
<li>湖仓一体</li>
<li>边缘计算</li>
<li>区块链账本<h4 id="数据平台赛道价值显性化，带来大量投资和创业机会"><a href="#数据平台赛道价值显性化，带来大量投资和创业机会" class="headerlink" title="数据平台赛道价值显性化，带来大量投资和创业机会"></a>数据平台赛道价值显性化，带来大量投资和创业机会</h4></li>
<li> 2021 年 6 月 25 日，Apache Kafka 商业化公司 Confluent 正式登陆纳斯达克，首日开涨 25%，市值超过 110 亿美元。</li>
<li> 2021 年 8 月 29 日，Apache Iceberg 的创建者 Ryan Blue、Dan Weeks 和 Netflix数据架构总监 Jason Reid 宣布从风投 a16z 处拿到了 A 轮融资，正式成立围绕</li>
<li>Apache Iceberg 构建新型数据平台的商业公司 Tabular。  2021 年 8 月 31 日，大数据初创公司 Databricks 宣布获得 16 亿美元 H 轮融资，</li>
<li>最新估值飙升至 380 亿美元，距离上一轮 10 亿美元的 G 轮融资仅仅过去 7 个月时间。</li>
<li> 2021 年 9 月 20 日，ClickHouse 的创建者 Alexey 正式从 Yandex 独立出来并成成立了一个公司ClickHouse, Inc。同时 ClickHouse 公司获得由 Index Ventures 和 Benchmark 领投的 5000 万美元 A 轮融资，Yandex 也参与其中。</li>
<li> 2021 年 10 月 12 日，基于开源的 Apache Pulsar 的商业化公司 StreamNative 宣布获得 2300 万美元 A 轮融资。</li>
<li>2021 年，Clickhouse、Tebula（Apache Iceberg 背后的商业公司）、Firebolt 以及国内诸多新兴创业公司为这一领域带来了很好的讨论度。</li>
</ul>
<h4 id="客户开始明确分层，带来平台架构的不同取舍"><a href="#客户开始明确分层，带来平台架构的不同取舍" class="headerlink" title="客户开始明确分层，带来平台架构的不同取舍"></a>客户开始明确分层，带来平台架构的不同取舍</h4><p><strong>客户分层</strong></p>
<ol>
<li><p>头部互联网技术公司，以 Top30-50 一线互联网公司为代表。技术栈上，以自建平台为主，且大部分公司采用以开源为基础的自建方式（其中少数 Top10 头部厂商会投资 0 到 1 自研）。</p>
</li>
<li><p>中腰部技术公司，其中又可以细分为两类：  </p>
<ul>
<li><p>中腰部互联网公司，这类型公司大多数诞生于云时代（近 8 年），通常处于成 长期并聚焦自身业务发展，对基础设施投资有限，同时追求更低的 TCO（包含 硬件和人力的总成本），倾向直接采用公共云平台架构并购买 PaaS 服务。（注：这类型客户是 SnowFlake 的典型客户）。 </p>
</li>
<li><p>有技术能力的非互联网公司，以银行/通信等领域企业为主。因监管或者资管要 求，通常采用专有云或者混合云模式，企业具备数据开发人员，能够在数据平 台上完成数据应用/解决方案的开发。这类型客户通常负责关键业务，对平台的 企业级能力（包括稳定性、安全性、免运维能力）要求很高。</p>
</li>
</ul>
</li>
<li><p>纯甲方应用型客户，以线下大型非技术型企业为主。这类型客户通常没有数据开发 和应用建设的经验和团队，对数据类应用的需求多通过与合作伙伴（ISV）合作或 者外包方式完成。对技术栈和技术选型通常不敏感，但对稳定性要求很高。</p>
</li>
</ol>
<h3 id="当下技术架构的五个热点"><a href="#当下技术架构的五个热点" class="headerlink" title="当下技术架构的五个热点"></a>当下技术架构的五个热点</h3><h4 id="引擎架构的进化，向进一步解耦和池化发展"><a href="#引擎架构的进化，向进一步解耦和池化发展" class="headerlink" title="引擎架构的进化，向进一步解耦和池化发展"></a>引擎架构的进化，向进一步解耦和池化发展</h4><h4 id="面向云原生、云中立的系统架构设计"><a href="#面向云原生、云中立的系统架构设计" class="headerlink" title="面向云原生、云中立的系统架构设计"></a>面向云原生、云中立的系统架构设计</h4><h4 id="数据湖与数据仓库技术相互融合：湖仓一体"><a href="#数据湖与数据仓库技术相互融合：湖仓一体" class="headerlink" title="数据湖与数据仓库技术相互融合：湖仓一体"></a>数据湖与数据仓库技术相互融合：湖仓一体</h4><table>
<thead>
<tr>
<th>对比维度</th>
<th>数据湖</th>
<th>数据仓库</th>
</tr>
</thead>
<tbody><tr>
<td>方法论</td>
<td>事后建模</td>
<td>事前建模</td>
</tr>
<tr>
<td>存储类型</td>
<td>结构化、半结构化、非结构化</td>
<td>结构化、半结构化</td>
</tr>
<tr>
<td>计算引擎</td>
<td>向所有引擎开放 各引擎有限优化</td>
<td>向特定引擎开放</td>
</tr>
<tr>
<td>成本</td>
<td>难运维管理</td>
<td>难启动</td>
</tr>
<tr>
<td>数据治理</td>
<td>质量低 难管理使用</td>
<td>质量高 易管理使用</td>
</tr>
</tbody></table>
<p>发展趋势：湖仓一体</p>
<p>实际上湖仓一体有两个流派：数据仓库到数据湖，数据湖到数据仓库</p>
<p>第一个流派是以数仓这种方式诞生的，它是一个左右派，左边是一个数据仓库，右边是一个数据湖，中间以高速网络相连形成一个反对式的联动；</p>
<p>第二个流派是从数据湖向数仓演进，整体架构是在数据湖上搭建数据仓库。</p>
<p>这两个流派的代表分别是 AWS Redshift/阿里云 MaxCompute，以及 Databricks，目前这两个流派都还在发展中。</p>
<h4 id="AI-成为数据平台的一等公民"><a href="#AI-成为数据平台的一等公民" class="headerlink" title="AI 成为数据平台的一等公民"></a>AI 成为数据平台的一等公民</h4><p>数据分析和 BI 更侧重于历史数据的总结</p>
<p>而算法/AI 具备越来越好的面向未来做预测,给大家带来更多决策支撑</p>
<h4 id="“1-N-1”的系统架构"><a href="#“1-N-1”的系统架构" class="headerlink" title="“1+N+1”的系统架构"></a>“1+N+1”的系统架构</h4><p>第一个 1，代表存储和资源的统一。</p>
<p>中间的 N 指代的是多种运算引擎和模式，例如批处理、流处理、机器学习、图计算等等，不同的计算引擎共享底层的数据和资源池。</p>
<p>最后一个 1，是指统一的接入层和数据开发应用层，这个层次是可选的。有些企业选择统一入口管理的架构，做更好的权限管理等。有些企业和厂商选择不再收敛了，引擎可以被各种团队或者各种用户独立使用。</p>
<h3 id="面向未来的四个发展趋势"><a href="#面向未来的四个发展趋势" class="headerlink" title="面向未来的四个发展趋势"></a>面向未来的四个发展趋势</h3><h4 id="实现从离线到实时的全频谱"><a href="#实现从离线到实时的全频谱" class="headerlink" title="实现从离线到实时的全频谱"></a>实现从离线到实时的全频谱</h4><p>Apache Delta、Hudi为代表的近实时化技术</p>
<p>Data Freshness、Resource Costs 和 Query Performance</p>
<h4 id="IoT-类数据处理成为新热点"><a href="#IoT-类数据处理成为新热点" class="headerlink" title="IoT 类数据处理成为新热点"></a>IoT 类数据处理成为新热点</h4><p>云边端协同的计算模式会成为热点，统称 IoT。</p>
<h4 id="数据安全、共享与隐私保护的矛盾需要新解法"><a href="#数据安全、共享与隐私保护的矛盾需要新解法" class="headerlink" title="数据安全、共享与隐私保护的矛盾需要新解法"></a>数据安全、共享与隐私保护的矛盾需要新解法</h4><p>数据安全不仅仅是一个权限问题，还涉及很复杂的系统架构包括:</p>
<ul>
<li>权限管理</li>
<li>用户隔离</li>
<li>存储加密</li>
<li>异地备份</li>
<li>敏感数据、风险行为的识别</li>
</ul>
<h4 id="AI-for-System（DW-Automation）"><a href="#AI-for-System（DW-Automation）" class="headerlink" title="AI for System（DW Automation）"></a>AI for System（DW Automation）</h4><ul>
<li>PB级别</li>
<li>EB级别</li>
<li>每天百万级别</li>
</ul>
<p>DBA 以人为轴的数据管理和优化方式不再胜任</p>
<p>机器学习、深度学习的自动化技术</p>
<p>通过机器学习自动进行数据分层：</p>
<ul>
<li>依据访问的统计判断什么样的数据更重要</li>
<li>什么样的数据其实不重要</li>
<li>哪些作业可以放在冷存储上</li>
<li>哪些是关键作业需要放在更高优先级的存储上。</li>
</ul>
<p><font color=red>当作业量达到百万量级时，这些决策应该由机器来自动完成，而不应该由人来完成。</font></p>
<h3 id="三个未解的挑战"><a href="#三个未解的挑战" class="headerlink" title="三个未解的挑战"></a>三个未解的挑战</h3><h4 id="疑问1：引擎多样化，最终是否能诞生一套OneSizeForAll引擎满足多样的计算需求，并兼顾通用性和效率？"><a href="#疑问1：引擎多样化，最终是否能诞生一套OneSizeForAll引擎满足多样的计算需求，并兼顾通用性和效率？" class="headerlink" title="疑问1：引擎多样化，最终是否能诞生一套OneSizeForAll引擎满足多样的计算需求，并兼顾通用性和效率？"></a>疑问1：引擎多样化，最终是否能诞生一套OneSizeForAll引擎满足多样的计算需求，并兼顾通用性和效率？</h4><p>自建系统：</p>
<ul>
<li>Spark 做批处理</li>
<li>Flink 做流处理</li>
<li>Clickhouse 做交互分析</li>
<li>HBase 做 KV 查询</li>
<li>ElasticSearch 做文本检索。</li>
</ul>
<h4 id="疑问-2：基于开源自建与直接选购企业级产品，谁更能获得用户的认可？"><a href="#疑问-2：基于开源自建与直接选购企业级产品，谁更能获得用户的认可？" class="headerlink" title="疑问 2：基于开源自建与直接选购企业级产品，谁更能获得用户的认可？"></a>疑问 2：基于开源自建与直接选购企业级产品，谁更能获得用户的认可？</h4><p>这个答案可能需要结合客户分层来看</p>
<p><strong>一个简单的经验公式是：</strong></p>
<p><font color=red>对于百台规模的平台，基于开源软件自建的总 TCO=物理硬件成本+开发和维护人力成本=物理硬件成本*2</font></p>
<h4 id="疑问-3：关系模型之外，是否会发展出其他主流计算范式？"><a href="#疑问-3：关系模型之外，是否会发展出其他主流计算范式？" class="headerlink" title="疑问 3：关系模型之外，是否会发展出其他主流计算范式？"></a>疑问 3：关系模型之外，是否会发展出其他主流计算范式？</h4><p>主流的计算范式就是二维关系表达</p>
<p>图计算是目前最被看好的方向，它是点边模型。</p>
<p>图学习 GraphEmbedding 技术</p>
]]></content>
      <categories>
        <category>技术视野</category>
      </categories>
      <tags>
        <tag>技术视野</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>六顶思考帽</title>
    <url>/2022/02/25/%E5%85%AD%E9%A1%B6%E6%80%9D%E8%80%83%E5%B8%BD/</url>
    <content><![CDATA[<h2 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h2><p><img src="img_2.png" alt=""></p>
<h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>作者: [英] 爱德华•德•博诺 (Edward De Bono)</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><ul>
<li>01 引言 </li>
<li>02 六顶帽子，六种颜色 </li>
<li>03 使用思考帽 <h3 id="蓝帽思考"><a href="#蓝帽思考" class="headerlink" title="蓝帽思考"></a>蓝帽思考</h3></li>
<li>04 蓝帽思考：掌控思考 </li>
<li>05 蓝帽思考：专注 </li>
<li>06 蓝帽思考：程序设计 </li>
<li>07 蓝帽思考：归纳与总结 </li>
<li>08 蓝帽思考：控制与监控 </li>
<li>09 蓝色思考帽小结 <h3 id="白帽思考"><a href="#白帽思考" class="headerlink" title="白帽思考"></a>白帽思考</h3></li>
<li>10 白帽思考：事实和数据 </li>
<li>11 白帽思考：这是谁的事实？ </li>
<li>12 白帽思考：日式输入 </li>
<li>13 白帽思考：事实、真理和哲学家 </li>
<li>14 白帽思考：谁戴上了这顶帽子？ </li>
<li>15 白色思考帽小结 <h3 id="红帽思考"><a href="#红帽思考" class="headerlink" title="红帽思考"></a>红帽思考</h3></li>
<li>16 红帽思考：情绪与情感 </li>
<li>17 红帽思考：情绪在思考中的地位 </li>
<li>18 红帽思考：直觉和预感 </li>
<li>19 红帽思考：时时刻刻 </li>
<li>20 红帽思考：用对情绪 </li>
<li>21 红帽思考：情绪的语言 </li>
<li>22 红色思考帽小结 <h3 id="黄帽思考"><a href="#黄帽思考" class="headerlink" title="黄帽思考"></a>黄帽思考</h3></li>
<li>23 黄帽思考：冒险之帽——积极探索 </li>
<li>24 黄帽思考：积极的范围 </li>
<li>25 黄帽思考：理由和逻辑证据 </li>
<li>26 黄帽思考：建设性思考 </li>
<li>27 黄帽思考：投机远见 </li>
<li>28 黄帽思考：与创造力的关系 </li>
<li>29 黄色思考帽小结 <h3 id="黑帽思考"><a href="#黑帽思考" class="headerlink" title="黑帽思考"></a>黑帽思考</h3></li>
<li>30 黑帽思考：谨慎和小心 </li>
<li>31 黑帽思考：内容和过程 </li>
<li>32 黑帽思考：过去和未来 </li>
<li>33 黑帽思考：过度使用的问题 </li>
<li>34 黑色思考帽小结 <h3 id="绿帽思考"><a href="#绿帽思考" class="headerlink" title="绿帽思考"></a>绿帽思考</h3></li>
<li>35 绿帽思考：创造性思考 </li>
<li>36 绿帽思考：水平思考 </li>
<li>37 绿帽思考：行动而非判断 </li>
<li>38 绿帽思考：激发的必要性 </li>
<li>39 绿帽思考：备选路线 </li>
<li>40 绿帽思考：性格与技能 </li>
<li>41 绿帽思考：创意的遭遇？ </li>
<li>42 绿色思考帽小结 </li>
<li>43 六顶思考帽方法的优点 <h3 id="结-语"><a href="#结-语" class="headerlink" title="结 语"></a>结 语</h3></li>
</ul>
<h2 id="最近感悟"><a href="#最近感悟" class="headerlink" title="最近感悟"></a>最近感悟</h2><p>最近在读六顶思考帽这本书。很早之前就听过这本书，一直也没看，最近公司读书会形式有所改变，不再是大家通读一本书，说实话原来那种形式我不是太喜欢，每天往群里发几页，遇见想看的吧嫌发的太少，大多数时候都是不喜欢读，从书的选择和读形式我都是很抵触的，本来自我感觉还是喜欢看书的人，但读书会的这种形式，我看还是算了吧！</p>
<p>别把我好不容易来的读书兴趣给抹杀了！</p>
<p>现在信息爆炸，每天被各种垃圾信息包围，读书也是：如果不经过认真挑选，你就会被垃圾环绕。</p>
<p>作为一个挑食（精神食粮）的人，初看到这本书，扫了眼豆瓣，评分好像是6点多，属实不高。用什么6个颜色来表达6种思考方式，我觉得很欠妥。本来就有见文知意的字来形容这6种思维模式。愣是自造概念整了6种颜色。好吧——在我创造的世界里我就是上帝。</p>
<p>以上吐槽告一段落。说点积极的，书中还是有一些积极意义的：</p>
<p>6中思维模式</p>
<table>
<thead>
<tr>
<th align="left">颜色</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">蓝色</td>
<td align="left">框架思维</td>
</tr>
<tr>
<td align="left">白色</td>
<td align="left">事实思维</td>
</tr>
<tr>
<td align="left">绿色</td>
<td align="left">创造性思维</td>
</tr>
<tr>
<td align="left">黄色</td>
<td align="left">积极思维</td>
</tr>
<tr>
<td align="left">黑色</td>
<td align="left">危机思维</td>
</tr>
<tr>
<td align="left">红色</td>
<td align="left">情绪思维</td>
</tr>
</tbody></table>
<p>咋用呢？</p>
<p>书中说可以单独用，也可以顺序都用，也可以定时用，注意纪律性。好吧貌似都是说给开会使用的。</p>
<p>说到开会，想起了一句话：”评价一个人领导力水平高低就是看这人会不会开会”</p>
<p>书中说到了一句话我很喜欢，在此记录：”思考最大的敌人是复杂性，因为那会导致混乱。当思考过程清晰简单，它本身就很愉快，也更有效。”</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>思维模型</tag>
      </tags>
  </entry>
  <entry>
    <title>解读Go语言的2021：稳定为王</title>
    <url>/2022/02/25/%E8%A7%A3%E8%AF%BBGo%E8%AF%AD%E8%A8%80%E7%9A%842021%EF%BC%9A%E7%A8%B3%E5%AE%9A%E4%B8%BA%E7%8E%8B/</url>
    <content><![CDATA[<p>本文摘抄自infoQ《2021年技术盘点与展望》</p>
<p><a href="https://www.infoq.cn/minibook/Rmc3QT7vIXdr0ovFhZZ8" target="_blank" rel="noopener">原文链接</a></p>
<h2 id="年度回顾"><a href="#年度回顾" class="headerlink" title="年度回顾"></a>年度回顾</h2><h3 id="新的官网网站"><a href="#新的官网网站" class="headerlink" title="新的官网网站"></a>新的官网网站</h3><p><a href="https://golang.org" target="_blank" rel="noopener">官网</a></p>
<p><a href="https://golang.google.cn" target="_blank" rel="noopener">中国官网</a></p>
<p><a href="https://go.dev" target="_blank" rel="noopener">google新搞的</a></p>
<p><a href="https://pkg.go.dev" target="_blank" rel="noopener">google新搞的二级域名存文档啥的</a></p>
<h3 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h3><h4 id="系统环境变量-GO111MODULE"><a href="#系统环境变量-GO111MODULE" class="headerlink" title="系统环境变量 GO111MODULE"></a>系统环境变量 GO111MODULE</h4><h4 id="Go-模块的配置文件：模块图修剪"><a href="#Go-模块的配置文件：模块图修剪" class="headerlink" title="Go 模块的配置文件：模块图修剪"></a>Go 模块的配置文件：模块图修剪</h4><h4 id="Go-模块的配置文件：新的指令"><a href="#Go-模块的配置文件：新的指令" class="headerlink" title="Go 模块的配置文件：新的指令"></a>Go 模块的配置文件：新的指令</h4><h4 id="Go-模块的配置文件：新的注释"><a href="#Go-模块的配置文件：新的注释" class="headerlink" title="Go 模块的配置文件：新的注释"></a>Go 模块的配置文件：新的注释</h4><h3 id="标准命令"><a href="#标准命令" class="headerlink" title="标准命令"></a>标准命令</h3><h4 id="go-install-命令"><a href="#go-install-命令" class="headerlink" title="go install 命令"></a>go install 命令</h4><h4 id="go-get命令"><a href="#go-get命令" class="headerlink" title="go get命令"></a>go get命令</h4><h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><h4 id="新增的-3-个代码包"><a href="#新增的-3-个代码包" class="headerlink" title="新增的 3 个代码包"></a>新增的 3 个代码包</h4><h4 id="废弃-io-ioutil-包"><a href="#废弃-io-ioutil-包" class="headerlink" title="废弃 io/ioutil 包"></a>废弃 io/ioutil 包</h4><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h3 id="其他更新"><a href="#其他更新" class="headerlink" title="其他更新"></a>其他更新</h3><h2 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h2><h4 id="模块管理工具"><a href="#模块管理工具" class="headerlink" title="模块管理工具"></a>模块管理工具</h4><h4 id="泛型语法支持"><a href="#泛型语法支持" class="headerlink" title="泛型语法支持"></a>泛型语法支持</h4><h4 id="其他期待"><a href="#其他期待" class="headerlink" title="其他期待"></a>其他期待</h4><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      <categories>
        <category>技术视野</category>
      </categories>
      <tags>
        <tag>技术视野</tag>
        <tag>Go</tag>
      </tags>
  </entry>
</search>
