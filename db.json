{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/images/vmset.png","path":"images/vmset.png","modified":1,"renderable":0},{"_id":"source/uploads/avatar.JPG","path":"uploads/avatar.JPG","modified":1,"renderable":0},{"_id":"themes/next/source/googlea34b5edc9a26f03a.html","path":"googlea34b5edc9a26f03a.html","modified":1,"renderable":1},{"_id":"source/images/Filter的基本工作原理.png","path":"images/Filter的基本工作原理.png","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"af29cb70298b76ff7e938370e4327c186292968f","modified":1525486221443},{"_id":"source/CNAME","hash":"90621995f3ffcca7fcff9bb1334110fe90641e66","modified":1569572828020},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1569572828081},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1569572828080},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1569572828080},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1569572828080},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1569572828081},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1569572828081},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1569572828081},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1569572828081},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1569572828082},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1569572828082},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1569572828082},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1569572828083},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1569572828082},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1569572828083},{"_id":"themes/next/_config.yml","hash":"17360c4fbc056085f516abfbcd94ab7629ca3dbe","modified":1569572828083},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1569572828100},{"_id":"source/.idea/misc.xml","hash":"7df46872d1421797d543d0323da2e81710cc573d","modified":1525486221444},{"_id":"source/.idea/workspace.xml","hash":"cfd2da50b8d142158ff6eaf3f438a0f1b60c7404","modified":1525486221444},{"_id":"source/about/index.md","hash":"6655a31520540a4c6d69fd48dc246a789cc8a2a4","modified":1569572828056},{"_id":"source/categories/index.md","hash":"363bd1b259332da7ffa70b7b3ca6338a102367e6","modified":1569572828056},{"_id":"source/_posts/AtomicInteger原理分析.md","hash":"31870d9967328f41a45471a09658647d0fce9318","modified":1569572828020},{"_id":"source/_posts/AtomicInteger类的理解与使用.md","hash":"5414112535f5c75047558cc0d030e620f79cbf8d","modified":1569572828020},{"_id":"source/_posts/CentOS防火墙设置与端口开放的方法.md","hash":"f70471c1f2e7d4025cdb31c598084e06804101e2","modified":1569572828021},{"_id":"source/_posts/Git配置多个SSH-Key.md","hash":"f4711f4b457119b89ee90d8087e9d059aa3b20e5","modified":1569572828022},{"_id":"source/_posts/Hexo博客备份.md","hash":"5e19f23030beac188b245d23c7bdbee5c6b941fb","modified":1569572828022},{"_id":"source/_posts/Filter、FilterChain、FilterConfig-介绍.md","hash":"c2c0b76d141b28b3fc7d6c135317ab8a92f67864","modified":1569572828022},{"_id":"source/_posts/IntelliJ-IDEA开发快捷键-IDEA-tool-Keyboard-shutcuts.md","hash":"cc05aba1a93145794c6aa3d56ce60ae071d36a38","modified":1569572828023},{"_id":"source/_posts/Intellij-IDEA如何配置JDK.md","hash":"69d2c047a36acddad866c13f13d45b40514bb98f","modified":1569572828023},{"_id":"source/_posts/JSP与JavaScript.md","hash":"5afd8d08017f43560c57a04ba989dd6d673b2d52","modified":1569572828024},{"_id":"source/_posts/Javac原理.md","hash":"3b362c90c3d9a4c56c01bd1ab4adbc1f3b05c030","modified":1569572828024},{"_id":"source/_posts/Kotlin.md","hash":"883ae9fb9e247183bd0feb67ad82cbd1c26d6816","modified":1569572828026},{"_id":"source/_posts/Laravel学习笔记.md","hash":"abeadf29b258de596be0aa0ed7a7e1100aaaac4d","modified":1569572828026},{"_id":"source/_posts/Learn-Linux.md","hash":"35298fb5a33705f4c0cc02b0c99e0cbe8105e60c","modified":1569572828026},{"_id":"source/_posts/LeetCode.md","hash":"c3d97818f18220e43945a73824dd88e5949434f9","modified":1569572828027},{"_id":"source/_posts/Linux下tar-gz-tar-bz2-zip等压缩与解压缩总结.md","hash":"762da73e259c93ae14d1da5c170cdf9ee1e25469","modified":1569572828027},{"_id":"source/_posts/Linux常用命令.md","hash":"fa7b0d58829450fbd585d6b0a72bf8e6405a0799","modified":1569572828028},{"_id":"source/_posts/Linux简介.md","hash":"adc3357881becb0797db0969306d454b51461afb","modified":1569572828028},{"_id":"source/_posts/Lombok-看这篇就够了.md","hash":"db4df2c1088dae594d6626c0a986e0f20d9bf045","modified":1569572828029},{"_id":"source/_posts/Mac-下locate命令使用问题WARNING-The-locate-database-var-db-locate-database-does-not-exist.md","hash":"2af99128119dd72350cd789b9fdeafea334c78fe","modified":1569572828029},{"_id":"source/_posts/Mac中node卸载与安装.md","hash":"1a4486b74f8603544804c24736d4ca6492d7dece","modified":1569572828030},{"_id":"source/_posts/Mac配置多个Java版本.md","hash":"a09b167e19c7cfa391eb36b3fdc4f29a7e9ea4c9","modified":1569572828031},{"_id":"source/_posts/My-New-Post.md","hash":"b00602dee00d569bb4d08046b903653e3b049865","modified":1569572828031},{"_id":"source/_posts/MySQL-InnoDB-MRR-优化.md","hash":"88beb6ae947cbfb46bf905d54048cb65dfff163a","modified":1569572828031},{"_id":"source/_posts/MySQL创建用户与授权.md","hash":"4b7957920dbdda6e66908f356ad7f8a78e63f6a2","modified":1569572828032},{"_id":"source/_posts/Spring-Boot-核心注解.md","hash":"fac98639eb6ab79e97b0a560307fb897ba5acb76","modified":1569572828032},{"_id":"source/_posts/Spring基础知识.md","hash":"0a534dc0ba520482733db3351c1edd65320d4798","modified":1569572828033},{"_id":"source/_posts/Ubuntu-Linux下安装软件方法.md","hash":"471ca8da926fa245a068eff988dfd76b641a264f","modified":1569572828033},{"_id":"source/_posts/Ubuntu-远程连接22端口.md","hash":"3a68c1c221d4f3d5fc20e9fe7debd8065531c872","modified":1569572828034},{"_id":"source/_posts/Vagrant基本用法.md","hash":"130604aa84930e2793a44d538537e0f057a130b4","modified":1569572828034},{"_id":"source/_posts/WARNING-REMOTE-HOST-IDENTIFICATION-HAS-CHANGED.md","hash":"4b9c41ad5d558684c8a51bd15931f104d21ca40d","modified":1569572828034},{"_id":"source/_posts/git回滚已经PUSH的内容.md","hash":"5e50dbfa12858fafbb0e28db54d19a46196b7174","modified":1569572828035},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1569572828035},{"_id":"source/_posts/hex-编码.md","hash":"c022a1ccaf9c0b024b7ab2ac7f06786dfaf4f5f2","modified":1569572828036},{"_id":"source/_posts/hexo插入图片.md","hash":"12ca7cac0a8cac80c3baa3040cae1715ce37d7cb","modified":1569572828036},{"_id":"source/_posts/hhkb配置Mac.md","hash":"84e0c834c747be7ef4f00c5c0033690c900e0692","modified":1569572828036},{"_id":"source/_posts/homestead-安装PHP-mongo-扩展.md","hash":"465cd79b03777db406015d523dc9d3c6ba46eceb","modified":1569572828037},{"_id":"source/_posts/idea将普通Java项目改为Maven项目.md","hash":"78718c1d26ac83a0ae755808b467006e420f1a57","modified":1569572828037},{"_id":"source/_posts/idea突然有些字母不显示.md","hash":"418c1bf8984fc397b8f229cad51e3023fa3f363b","modified":1569572828038},{"_id":"source/_posts/java-io-EOFException.md","hash":"77ecb80272d2493a137c966e98c18a574f7acdcc","modified":1569572828038},{"_id":"source/_posts/learning-hexo.md","hash":"bbb4e7f299721bbe70e51d66596a68de456669e2","modified":1569572828039},{"_id":"source/_posts/linux环境变量总结.md","hash":"820c73a52da3d3d56ac3d96e8ce418046863991e","modified":1569572828039},{"_id":"source/_posts/mac上解决java-rmi-server-ExportException-Port-already-in-use-1099-nested-exception-is-java-net-Bi.md","hash":"2f96224f6592e458d53557ee2c892e6950300302","modified":1569572828040},{"_id":"source/_posts/mac下chrome快捷键.md","hash":"931fca152a8e6a00d664188924ef3593a0b6afc4","modified":1569572828040},{"_id":"source/_posts/mac使用brew-update无反应-解决方案更新源.md","hash":"1643521a96314c8276575e43e500970e4a97e380","modified":1569572828040},{"_id":"source/_posts/php中unset详解.md","hash":"119a47fde01e781cfc1247d73ca10a0c6aa4e29a","modified":1569572828042},{"_id":"source/_posts/php调用shell的方法.md","hash":"b03433fbafb3670c0a04cfb8cc835de9a016e481","modified":1569572828043},{"_id":"source/_posts/spring-mvc-控制台输出乱码.md","hash":"1e5fa1a6455d56a935391dfaf37d1a082c7f956e","modified":1569572828043},{"_id":"source/_posts/springmvc在controller方法里面跳转外网的方法.md","hash":"ed59b76835c302c1657c9dc0cabc8015c5dd7c22","modified":1569572828044},{"_id":"source/_posts/tomcat9因为在清除过期缓存条目后可用空间仍不足-请考虑增加缓存的最大空间。.md","hash":"6c7696a0fa09a08cb3ba19700e5c961dcce03cce","modified":1569572828044},{"_id":"source/_posts/ubuntu16-04_The_system_is_running_in_low_graphics_mode终极解决办法.md","hash":"27ca55cb300d2193e9a855b0ddc97e14390152f9","modified":1569572828045},{"_id":"source/_posts/vim教程.md","hash":"3872a571ad841039a60977379289fac554aeeb49","modified":1569572828045},{"_id":"source/_posts/zip和-tar-gz的文件有什么区别.md","hash":"cbc99d81c6893e0867e332b920211a1078696cba","modified":1569572828045},{"_id":"source/_posts/一个bug的旅程.md","hash":"cb7f3e3d0f40e040265c1bc24ad9def2889ca612","modified":1569572828046},{"_id":"source/_posts/上线准备流程.md","hash":"42a276c4d183bdcfc4c915380b7f923801c2d646","modified":1569572828046},{"_id":"source/_posts/不止代码.md","hash":"a1c433a7f82178894b08eac86ec674942d693c58","modified":1569572828047},{"_id":"source/_posts/五笔口诀.md","hash":"4f5dde12e9102f5e696906507a5dd73d0b9a55e9","modified":1569572828047},{"_id":"source/_posts/使用-lombok-简化-Java-代码.md","hash":"bbb9b67510a6fbf2bc7bc3cf62e58842644d66f0","modified":1569572828047},{"_id":"source/_posts/关于-getWriter-has-already-been-called-for-this-response-的错误解决办法.md","hash":"c133a48f38eb8299d091cafe97ae53d0aaca5e3d","modified":1569572828048},{"_id":"source/_posts/初识Shiro.md","hash":"ad022045ce2bd34245183ecfa344ff24c1948fd0","modified":1569572828048},{"_id":"source/_posts/喜迎猪宝.md","hash":"1d9039b2a42b1e788272aa25ec1fd62803ecaf0d","modified":1569572828049},{"_id":"source/_posts/如何培养孩子的逻辑思维.md","hash":"c94fbc07b12463ecbc21c5dff343658349fcd6e3","modified":1569572828049},{"_id":"source/_posts/手写JVM.md","hash":"ec34ded05faf7d7d4bd7ec12b2d7d1fbaab2294e","modified":1569572828049},{"_id":"source/_posts/持续集成服务-Travis-CI.md","hash":"5428560ff96cbf89ca80b87bd0513504fa9d52e6","modified":1569572828050},{"_id":"source/_posts/数据库回表与覆盖索引.md","hash":"28a1eba944916bee5553e36b82a112f481bff3ea","modified":1569572828051},{"_id":"source/_posts/曲突徙薪之恩泽-焦头烂额为上客.md","hash":"a3952fdb60b986f2e0387e504a5c6f6c5bff77c0","modified":1569572828051},{"_id":"source/_posts/母子分离日.md","hash":"fe6432d8bb2228af4bab0d3a3157ea4faaaf4c8c","modified":1569572828052},{"_id":"source/_posts/泰拳要领.md","hash":"c57f63be33837b0aa526455b747bc5b5272d569d","modified":1569572828052},{"_id":"source/_posts/深入解读RabbitMQ工作原理及Java中简单使用.md","hash":"c6341b00c57210b26bc9e33c470e72746f6f3aa6","modified":1569572828053},{"_id":"source/_posts/猪宝历险记.md","hash":"8c39aab87b0ba768fa63196ccb40453c357576c3","modified":1569572828053},{"_id":"source/_posts/猪宝取名记.md","hash":"91a5dccca60425b106241e546451604b3904fc50","modified":1569572828053},{"_id":"source/_posts/玩物丧志.md","hash":"4318d8babe6e48f6607763f8a9aac71eec0823f1","modified":1569572828054},{"_id":"source/_posts/设计模式之Builder模式.md","hash":"02eb3e92f2f29de0b324d3170daa79382aeb7eea","modified":1569572828054},{"_id":"source/_posts/读-活着-有感.md","hash":"cb6577931b3cee0d3460fd4e62d1d7fca151ef55","modified":1569572828054},{"_id":"source/_posts/过年请假.md","hash":"15f13d1e3e64a4524ecadbbed67f2d0f45697aac","modified":1569572828055},{"_id":"source/tags/index.md","hash":"acc1f08bf36b3865b5e0bed2300bf0bd794f980f","modified":1569572828060},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1569572828080},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1569572828080},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1569572828080},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1569572828081},{"_id":"themes/next/languages/de.yml","hash":"d82344704001efddbab9c0a5f887734838ff29c1","modified":1569572828084},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1569572828084},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1569572828084},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1569572828084},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1569572828084},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1569572828085},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1569572828085},{"_id":"themes/next/languages/ja.yml","hash":"ec50902b554a46faf81eb1beed1b31c5af940850","modified":1569572828085},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1569572828086},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1569572828086},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1569572828086},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1569572828086},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1569572828086},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1569572828086},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1569572828086},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1569572828087},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1569572828087},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1569572828099},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1569572828099},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1569572828099},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1569572828099},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1569572828100},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1569572828100},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1569572828100},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1569572828100},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1569572828101},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1569572828152},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1569572828152},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1569572828152},{"_id":"themes/next/source/googlea34b5edc9a26f03a.html","hash":"07a447211c97ef93f934e72f2623d192f451ad15","modified":1569572828122},{"_id":"source/images/vmset.png","hash":"094e7f510d2831a27029720a619d0f3fd33652da","modified":1569572828059},{"_id":"source/uploads/avatar.JPG","hash":"e9864d8c686e1cbb7f4df5208e0ecf6da9a96365","modified":1569572828060},{"_id":"source/_posts/node-js教程.md","hash":"88df365844cb6f970e1cfc2785452712b64ce3f6","modified":1569572828042},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569572828122},{"_id":"source/_posts/Javac原理/j.jpg","hash":"00243d68debabd98886255537e57902143066416","modified":1569572828025},{"_id":"source/_posts/读-活着-有感/下载.jpeg","hash":"0028fe5a1e905c17a749c94db1be2d3e8d67e7d0","modified":1569572828055},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1569572828087},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1569572828087},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1569572828087},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"ef1c6c4263c4e3ec3490c79fca948199dea09652","modified":1569572828088},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1569572828088},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1569572828089},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1569572828089},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1569572828089},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1569572828089},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1569572828089},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1569572828090},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1569572828090},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1569572828090},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1569572828090},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1569572828091},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1569572828092},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1569572828092},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1569572828093},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1569572828097},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1569572828097},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1569572828097},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1569572828097},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1569572828097},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1569572828098},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1569572828098},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1569572828101},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1569572828101},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1569572828101},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1569572828102},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1569572828102},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1569572828102},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1569572828102},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1569572828102},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1569572828102},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1569572828122},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1569572828122},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1569572828123},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1569572828123},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1569572828123},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1569572828123},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1569572828123},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1569572828123},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1569572828124},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1569572828124},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1569572828124},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1569572828124},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1569572828123},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1569572828124},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1569572828124},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1569572828124},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1569572828125},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1569572828125},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1569572828124},{"_id":"source/images/Filter的基本工作原理.png","hash":"9cfcaca53f7d28c49b0c314d8b12f323a91f7658","modified":1569572828058},{"_id":"source/_posts/Mac-下locate命令使用问题WARNING-The-locate-database-var-db-locate-database-does-not-exist/locate.png","hash":"48c99c70fd76ff2744b37def7bfc5a83aed366f1","modified":1569572828030},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569572828093},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569572828093},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569572828115},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569572828115},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569572828115},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569572828121},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569572828122},{"_id":"source/_posts/Javac原理/f.jpg","hash":"e9c8a719aca94a1a3ea572a6552abb1834cdec8b","modified":1569572828025},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1569572828090},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1569572828090},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1569572828091},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1569572828091},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1569572828091},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1569572828092},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1569572828091},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1569572828092},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1569572828092},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1569572828092},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1569572828093},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1569572828093},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1569572828093},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1569572828093},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1569572828093},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1569572828094},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1569572828094},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1569572828094},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1569572828094},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1569572828094},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1569572828094},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1569572828095},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1569572828095},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1569572828095},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1569572828095},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1569572828095},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1569572828095},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1569572828095},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1569572828096},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1569572828096},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1569572828096},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1569572828096},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1569572828096},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1569572828097},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1569572828098},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1569572828099},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1569572828099},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1569572828099},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1569572828115},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1569572828115},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1569572828115},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1569572828115},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1569572828121},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1569572828121},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1569572828121},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1569572828125},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1569572828125},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1569572828122},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1569572828125},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1569572828126},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1569572828125},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1569572828126},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1569572828126},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1569572828127},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1569572828126},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1569572828127},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1569572828127},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1569572828130},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1569572828132},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1569572828135},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1569572828133},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1569572828135},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1569572828136},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1569572828136},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1569572828135},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1569572828136},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1569572828136},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1569572828137},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1569572828136},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1569572828141},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1569572828142},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1569572828142},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1569572828143},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1569572828143},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1569572828143},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1569572828143},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1569572828144},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1569572828145},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1569572828145},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1569572828144},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1569572828144},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1569572828145},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1569572828145},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1569572828145},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1569572828146},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1569572828146},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1569572828146},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1569572828146},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1569572828146},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1569572828146},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1569572828147},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1569572828146},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1569572828147},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1569572828147},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1569572828148},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1569572828147},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1569572828150},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1569572828150},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1569572828152},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1569572828152},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1569572828152},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1569572828142},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1569572828098},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1569572828098},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1569572828103},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1569572828103},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1569572828103},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1569572828103},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1569572828103},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1569572828106},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1569572828110},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1569572828113},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1569572828114},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1569572828114},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1569572828114},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1569572828114},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1569572828114},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1569572828115},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1569572828116},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1569572828116},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1569572828117},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1569572828116},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1569572828117},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1569572828117},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1569572828117},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1569572828117},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1569572828118},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1569572828118},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1569572828118},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1569572828119},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1569572828119},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1569572828120},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1569572828120},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1569572828120},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1569572828121},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1569572828121},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1569572828121},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1569572828126},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1569572828130},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1569572828130},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1569572828133},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1569572828133},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1569572828133},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1569572828133},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1569572828133},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1569572828133},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1569572828134},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1569572828135},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1569572828135},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1569572828136},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1569572828136},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1569572828137},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1569572828137},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1569572828150},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1569572828150},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1569572828129},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1569572828141},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1569572828137},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1569572828105},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1569572828105},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1569572828105},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1569572828105},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1569572828106},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1569572828106},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1569572828105},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1569572828105},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1569572828104},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1569572828104},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1569572828104},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1569572828104},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1569572828105},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1569572828108},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1569572828109},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1569572828109},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1569572828109},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1569572828109},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1569572828109},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1569572828109},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1569572828110},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1569572828110},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1569572828109},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1569572828104},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1569572828106},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1569572828106},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1569572828106},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1569572828106},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1569572828107},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1569572828107},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1569572828107},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1569572828107},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1569572828107},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1569572828108},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1569572828107},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1569572828108},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1569572828108},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1569572828110},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1569572828108},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1569572828108},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1569572828111},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1569572828111},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1569572828110},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1569572828111},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1569572828112},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1569572828111},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1569572828111},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1569572828112},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1569572828112},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1569572828112},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1569572828112},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1569572828112},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1569572828113},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1569572828112},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1569572828113},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1569572828113},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1569572828113},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1569572828113},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1569572828118},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1569572828118},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1569572828119},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1569572828127},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1569572828128},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1569572828128},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1569572828129},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1569572828127},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1569572828128},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1569572828133},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1569572828134},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1569572828134},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1569572828134},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1569572828134},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1569572828134},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1569572828141},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1569572828138},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1569572828151},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1569572828139},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1569572828140},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1569572828132},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1569572828150},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1569572828140},{"_id":"public/sitemap.xml","hash":"276235b98016ca3207b656b1248cdaab9fabd65c","modified":1569657164912},{"_id":"public/baidusitemap.xml","hash":"dd598bc8a196703c607c52804676e927e964d229","modified":1569657164912},{"_id":"public/atom.xml","hash":"f2322437e18311d238684a2d0311a8a8b63b6ceb","modified":1569657164913},{"_id":"public/search.xml","hash":"063af6c64bd808bd4fceb46b046d4bb0fa435bb7","modified":1569657164913},{"_id":"public/about/index.html","hash":"49a4e3ace80b211db3a49517129340e36d5d5880","modified":1569657164935},{"_id":"public/categories/index.html","hash":"99fe545a0da70e324f861cc713c30dd29271e15c","modified":1569657164935},{"_id":"public/tags/index.html","hash":"3a28a6aa757f793cf60e642eca024bff020ee40f","modified":1569657164935},{"_id":"public/2019/09/27/如何培养孩子的逻辑思维/index.html","hash":"5cf2f4bcd05498f6862413f39b24121c71419122","modified":1569657164935},{"_id":"public/2019/09/25/Spring-Boot-核心注解/index.html","hash":"58639f9d986dfdae1fc6552d01ca9b4f72972fc4","modified":1569657164935},{"_id":"public/2019/09/25/Javac原理/index.html","hash":"ba69fcce0288ff8a364897715d54700a4fa46567","modified":1569657164935},{"_id":"public/2019/09/25/使用-lombok-简化-Java-代码/index.html","hash":"b8863584df8ca97c81882c4318f6edfae872ea1e","modified":1569657164935},{"_id":"public/2019/09/19/设计模式之Builder模式/index.html","hash":"39bae00aa8e6fc978d9abdba46ff2341c96c74a0","modified":1569657164935},{"_id":"public/2019/09/12/MySQL创建用户与授权/index.html","hash":"2231f72f87b535dd5d53bc1241490ef7f8995e5d","modified":1569657164935},{"_id":"public/2019/09/12/Lombok-看这篇就够了/index.html","hash":"41eef09ad4caaaf97af0520b506463de55a75e45","modified":1569657164935},{"_id":"public/2019/09/12/初识Shiro/index.html","hash":"ca8e50eaf58208095acec79f02a0287831bf1823","modified":1569657164935},{"_id":"public/2019/09/11/Mac-下locate命令使用问题WARNING-The-locate-database-var-db-locate-database-does-not-exist/index.html","hash":"270266ef118995ecc90a2d5690583c5a3ddee314","modified":1569657164936},{"_id":"public/2019/09/09/mac上解决java-rmi-server-ExportException-Port-already-in-use-1099-nested-exception-is-java-net-Bi/index.html","hash":"3088f003478fdd1f16b915f7e47e8959d8e8fe74","modified":1569657164936},{"_id":"public/2019/09/09/关于-getWriter-has-already-been-called-for-this-response-的错误解决办法/index.html","hash":"721d13c5606f05438c8ae5c4dc7b11ff714cd80d","modified":1569657164936},{"_id":"public/2019/09/06/java-io-EOFException/index.html","hash":"feb310b0956b9c937ccdafa28e0570dc0c98ae90","modified":1569657164936},{"_id":"public/2019/09/06/hexo插入图片/index.html","hash":"afaaa225843fc42867084d85d811fc462ac0b5d2","modified":1569657164936},{"_id":"public/2019/09/06/读-活着-有感/index.html","hash":"31d3ef3e23a303722ad90089652fa7cdf38910ac","modified":1569657164936},{"_id":"public/2019/09/06/Filter、FilterChain、FilterConfig-介绍/index.html","hash":"6f0d80c0e3b9f37efb2fa91a54029c5582c84876","modified":1569657164936},{"_id":"public/2019/09/04/一个bug的旅程/index.html","hash":"ee16fe8b8e27e781da2f5c698eb2f40c9782f223","modified":1569657164936},{"_id":"public/2019/09/04/JSP与JavaScript/index.html","hash":"48e712f847f18c881664d8bafcdef5e49fc82d69","modified":1569657164936},{"_id":"public/2019/09/04/idea将普通Java项目改为Maven项目/index.html","hash":"1fde0b65286724f036282dd86ef610faf3472efa","modified":1569657164936},{"_id":"public/2019/09/03/idea突然有些字母不显示/index.html","hash":"b063e76ace6f09b58c6b34db347f9e9f0c66b1c4","modified":1569657164936},{"_id":"public/2019/09/03/spring-mvc-控制台输出乱码/index.html","hash":"0dfc6754a8947c320fe35bc2c726daa8978cd6b4","modified":1569657164936},{"_id":"public/2019/09/02/Spring基础知识/index.html","hash":"64c54322c6295d74ea4425bce4dc0f27d1beb39f","modified":1569657164937},{"_id":"public/2019/09/02/Git配置多个SSH-Key/index.html","hash":"858d6d3a298ed74420456ab234f015a1a9477718","modified":1569657164937},{"_id":"public/2019/09/02/泰拳要领/index.html","hash":"837318004b8c7626732b0854b8b6faa0094b4c03","modified":1569657164937},{"_id":"public/2019/08/29/tomcat9因为在清除过期缓存条目后可用空间仍不足-请考虑增加缓存的最大空间。/index.html","hash":"b8737f874fedac26b0cd1149885b24ba79c8740c","modified":1569657164937},{"_id":"public/2019/08/28/Intellij-IDEA如何配置JDK/index.html","hash":"9101bebe38286c6838cb4b791b11000ce739b3c5","modified":1569657164937},{"_id":"public/2019/08/28/Mac配置多个Java版本/index.html","hash":"c0a58fc66a50c2a7099e57895a0151703c8cc2b3","modified":1569657164937},{"_id":"public/2019/08/27/hex-编码/index.html","hash":"8acf5991fbb6d1c0b8ad69606bf1bdb332971835","modified":1569657164937},{"_id":"public/2019/08/26/手写JVM/index.html","hash":"f31492f582049d6634693cfc3e30342459ae3add","modified":1569657164937},{"_id":"public/2019/08/26/node-js教程/index.html","hash":"3f77388841b8ede33ffcf967efe5824dd2f5b845","modified":1569657164937},{"_id":"public/2019/08/26/玩物丧志/index.html","hash":"555ec5844bc347064c098781fe899adc631e44f6","modified":1569657164937},{"_id":"public/2019/08/23/mac使用brew-update无反应-解决方案更新源/index.html","hash":"b2c81235936abf7a7bd80f0176828b91e88c9d58","modified":1569657164937},{"_id":"public/2019/08/23/Mac中node卸载与安装/index.html","hash":"ffbb455ccedb9f78fc1781439047e8076672d9c0","modified":1569657164937},{"_id":"public/2019/08/19/MySQL-InnoDB-MRR-优化/index.html","hash":"05130481a9f111f7391f15188290bb47e3bbe961","modified":1569657164937},{"_id":"public/2019/08/19/数据库回表与覆盖索引/index.html","hash":"0b362aa3534c1470c133dd2c832801ab98b77772","modified":1569657164938},{"_id":"public/2019/08/09/git回滚已经PUSH的内容/index.html","hash":"15fcc23539ed18826600f4ec61a4ad6d25702178","modified":1569657164939},{"_id":"public/2019/08/03/母子分离日/index.html","hash":"b6e77fff8c033317b9ff819ceb668910c07cdaa5","modified":1569657164939},{"_id":"public/2019/07/20/曲突徙薪之恩泽-焦头烂额为上客/index.html","hash":"99ff3dd3f3aefe51d167c54c20bd2f727b90e219","modified":1569657164939},{"_id":"public/2019/06/11/vim教程/index.html","hash":"80d90861d6942e5939cbd169dc6280cf77f321a3","modified":1569657164939},{"_id":"public/2019/05/31/猪宝取名记/index.html","hash":"31aae5c5ac645137f368b87f8f069eeec9bfc435","modified":1569657164939},{"_id":"public/2019/05/28/猪宝历险记/index.html","hash":"fbd4680e186cb8dd0d8f62b0e8b3bfdb33757bd9","modified":1569657164939},{"_id":"public/2019/04/18/上线准备流程/index.html","hash":"6d4394c204338ddcb38aa897f522c9aea5c8fa2e","modified":1569657164939},{"_id":"public/2019/03/26/喜迎猪宝/index.html","hash":"fbbfd144cd58e0ac8c695161ff40ec31b4db9981","modified":1569657164939},{"_id":"public/2019/02/22/Laravel学习笔记/index.html","hash":"c636ff6f449eba2177dc11a89a230be0e811b480","modified":1569657164939},{"_id":"public/2019/02/13/过年请假/index.html","hash":"8b737ea36e9e3ed9948e7ada62573b0687f7c928","modified":1569657164940},{"_id":"public/2018/12/17/homestead-安装PHP-mongo-扩展/index.html","hash":"fa679307732d7dae7270ce8a9c68dffadcd046e1","modified":1569657164940},{"_id":"public/2018/09/11/Vagrant基本用法/index.html","hash":"4b98a202d31cc4d657450a7dc26ce4a539b0258b","modified":1569657164940},{"_id":"public/2018/07/27/Linux常用命令/index.html","hash":"5f805fcd687cf995e6a507e03fca5dd431a5d355","modified":1569657164940},{"_id":"public/2018/07/25/五笔口诀/index.html","hash":"133141417f39f17298c7849d48b5534ba1b547d6","modified":1569657164940},{"_id":"public/2018/07/16/深入解读RabbitMQ工作原理及Java中简单使用/index.html","hash":"ea96c2fd4d06be886520f3ff2fe388182290e84c","modified":1569657164940},{"_id":"public/2018/07/06/不止代码/index.html","hash":"43d96f3edd2eecf0f4e160661362a28d7d666017","modified":1569657164940},{"_id":"public/2018/07/04/AtomicInteger原理分析/index.html","hash":"3c8d440bd60951d6adc454c8fed9388e6f25138e","modified":1569657164940},{"_id":"public/2018/07/04/AtomicInteger类的理解与使用/index.html","hash":"64946588144007c4783377c523045b7a12aa5f32","modified":1569657164940},{"_id":"public/2018/07/04/IntelliJ-IDEA开发快捷键-IDEA-tool-Keyboard-shutcuts/index.html","hash":"a3c650f28f0a33ad61db393e878dc1b894a94b7e","modified":1569657164940},{"_id":"public/2018/06/20/php中unset详解/index.html","hash":"71d498d6d933f4fd6a862bb5b78c4ffc4f6ffa92","modified":1569657164940},{"_id":"public/2018/05/31/LeetCode/index.html","hash":"a99e5f02390606cdfb9cb9c45a8bcdf492fea77c","modified":1569657164941},{"_id":"public/2018/05/28/linux环境变量总结/index.html","hash":"ec64b26dabb525e562405c0305b2faeec4299687","modified":1569657164941},{"_id":"public/2018/05/11/WARNING-REMOTE-HOST-IDENTIFICATION-HAS-CHANGED/index.html","hash":"96f179eeeaad8a836c25c3f8978fa2bad03cca4d","modified":1569657164941},{"_id":"public/2018/05/09/mac下chrome快捷键/index.html","hash":"88d8b6665b78e1335c4e0931a80f19f1938b763c","modified":1569657164941},{"_id":"public/2018/05/07/hhkb配置Mac/index.html","hash":"2f6c07af6a19bd84848d16f32caf60cbe8144cda","modified":1569657164941},{"_id":"public/2018/05/05/Hexo博客备份/index.html","hash":"689d3c9f0a6e76c00dc5c5adc9be933b7e8321f5","modified":1569657164941},{"_id":"public/2018/04/28/Linux下tar-gz-tar-bz2-zip等压缩与解压缩总结/index.html","hash":"d7b1aca25c2c85076cca7fddb8125aebf4ed00d2","modified":1569657164941},{"_id":"public/2018/04/27/zip和-tar-gz的文件有什么区别/index.html","hash":"05c2c5c19e0f22c673749ad6ea7b170803ef8bfb","modified":1569657164941},{"_id":"public/2018/04/26/ubuntu16-04_The_system_is_running_in_low_graphics_mode终极解决办法/index.html","hash":"f7a2c17c196944968bc54efa340a657de6f42a0d","modified":1569657164941},{"_id":"public/2018/04/24/Linux简介/index.html","hash":"ed352e1738340dea619ee296bc6fff0718981e09","modified":1569657164941},{"_id":"public/2018/04/23/CentOS防火墙设置与端口开放的方法/index.html","hash":"860297a994b6538e6c5ef1736e8355b23f102de9","modified":1569657164941},{"_id":"public/2018/04/23/Ubuntu-远程连接22端口/index.html","hash":"3b088fd13de654ba76dba1a468b3acbe60d255af","modified":1569657164941},{"_id":"public/2018/04/20/Kotlin/index.html","hash":"855a66ab5933125e43be90adf2e244370654216e","modified":1569657164942},{"_id":"public/2018/04/20/Ubuntu-Linux下安装软件方法/index.html","hash":"fec6e5a6bb86e3077748530e8c1b3b9d99129ee2","modified":1569657164942},{"_id":"public/2018/04/20/Learn-Linux/index.html","hash":"8f98c146b52f21208f8a1dbfcbfa58cb439c21f2","modified":1569657164942},{"_id":"public/2018/04/20/php调用shell的方法/index.html","hash":"ecc160246cb67534f6b342595997491abadd7bff","modified":1569657164942},{"_id":"public/2018/04/20/My-New-Post/index.html","hash":"be621e83a08e261db2b704baa9eb2d4d05c3f6fc","modified":1569657164942},{"_id":"public/2018/03/29/learning-hexo/index.html","hash":"d33a4fa2ab8e0654f23abecaba51e9b56b4c72b9","modified":1569657164942},{"_id":"public/archives/index.html","hash":"189ccafebedd969bdec89efd7bf552551e8ff08f","modified":1569657164942},{"_id":"public/archives/page/2/index.html","hash":"badc5fe2607e7bd64f060e59b1b4b4c17d383f00","modified":1569657164942},{"_id":"public/archives/page/3/index.html","hash":"fb283ec6c85e2dc4392c707bfa2b97b58bcdddfd","modified":1569657164943},{"_id":"public/archives/page/4/index.html","hash":"e254fe70692a3964d7294f56a2c2631f18349d11","modified":1569657164943},{"_id":"public/archives/page/5/index.html","hash":"c2e0b3f321bf1119372a1a4f86a8490437c97c96","modified":1569657164943},{"_id":"public/archives/page/6/index.html","hash":"2f9c241ab9de4396d2ca3622f4b2a4a9339f9164","modified":1569657164943},{"_id":"public/archives/page/7/index.html","hash":"8bfa25fef5c99003a9554cebd5018e781ff7a65e","modified":1569657164943},{"_id":"public/archives/page/8/index.html","hash":"9112ae214f2a664a0d0692be96ce2cb300efd6b1","modified":1569657164943},{"_id":"public/archives/2018/index.html","hash":"0e5310608f46820391db646c8f278da7c86b0eb4","modified":1569657164943},{"_id":"public/archives/2018/page/2/index.html","hash":"45a6149d7e6ae6c862626e71ec193be9a5e79e99","modified":1569657164943},{"_id":"public/archives/2018/page/3/index.html","hash":"bb4a02796af0fdef5367c4d84d0b7ec9221dcbbf","modified":1569657164943},{"_id":"public/archives/2018/03/index.html","hash":"6fdec60b05b0d3db014db384a4fa3f6a1f9f7d11","modified":1569657164944},{"_id":"public/archives/2018/04/index.html","hash":"6f370b53cd5def6967a0b74cb84134a0f4309b15","modified":1569657164944},{"_id":"public/archives/2018/05/index.html","hash":"59c7bc04c1df8592908eb066ee9ae5e0b540b217","modified":1569657164944},{"_id":"public/archives/2018/04/page/2/index.html","hash":"abcc0f76544358cd5e05ff19a38593e974c51ba3","modified":1569657164944},{"_id":"public/archives/2018/06/index.html","hash":"b32a257d0dc44d1a96fc3ac9798f15ef8b9e1b74","modified":1569657164944},{"_id":"public/archives/2018/07/index.html","hash":"df00f26dcf58312b6459f53385ae6fc461b864f0","modified":1569657164944},{"_id":"public/archives/2018/09/index.html","hash":"557c90068878af35c26617de458b6d01e699df43","modified":1569657164944},{"_id":"public/archives/2018/12/index.html","hash":"754f787bb9779a4d1d1e70973f7d53e6b1228f42","modified":1569657164944},{"_id":"public/archives/2019/index.html","hash":"843a05fb82150fb809d4370f25e7d4e053c76813","modified":1569657164944},{"_id":"public/archives/2019/page/2/index.html","hash":"b1899a77b61e717226b65f98a4d32ff58dd507e6","modified":1569657164944},{"_id":"public/archives/2019/page/3/index.html","hash":"4440d80d3b1391f1e5c4aaabe5c38f5984665a15","modified":1569657164944},{"_id":"public/archives/2019/page/4/index.html","hash":"20df8419dd015cfcee177b12bb464c90c9a6fb19","modified":1569657164944},{"_id":"public/archives/2019/page/5/index.html","hash":"b23d873014587334f05b44185c0ce23745e83b2b","modified":1569657164945},{"_id":"public/archives/2019/02/index.html","hash":"8b60d373a5b9ca0e5a72c3c6572c3a8e45c02333","modified":1569657164945},{"_id":"public/archives/2019/03/index.html","hash":"3fdf1fe3f4fc92ecdb304f30a914a45ee830c249","modified":1569657164945},{"_id":"public/archives/2019/04/index.html","hash":"984d07a025ebf3fe93b31f73911d4df62b8d4621","modified":1569657164945},{"_id":"public/archives/2019/05/index.html","hash":"0047f2bb91b6a46cc560283015066367455c7acd","modified":1569657164945},{"_id":"public/archives/2019/06/index.html","hash":"d20f05cd6e847c0fa251f8343f93eb18cc7b117c","modified":1569657164945},{"_id":"public/archives/2019/07/index.html","hash":"84d039b4bb1eb230a673852ec701c4cd50b846cd","modified":1569657164945},{"_id":"public/archives/2019/08/index.html","hash":"6cb1937de55b532db1e36722d81f16ea7363272c","modified":1569657164945},{"_id":"public/archives/2019/08/page/2/index.html","hash":"da83932a4efeccc98d5328e9725b866e6f777f5e","modified":1569657164945},{"_id":"public/archives/2019/09/index.html","hash":"e0e2d2ecc3d13d90bfa432650e45a62a29e838a9","modified":1569657164945},{"_id":"public/archives/2019/09/page/2/index.html","hash":"7723241717338cdb5044292d7f2bc65ddfdd92e0","modified":1569657164946},{"_id":"public/archives/2019/09/page/3/index.html","hash":"8e35dae217fa9ad25b6b233bf5c2031110241b12","modified":1569657164946},{"_id":"public/categories/git/index.html","hash":"6fe8f715c3be758920309a6a4c7864d6d9b14c19","modified":1569657164946},{"_id":"public/categories/java/index.html","hash":"fc14cde451520543ee81692d715d4cc7aa115528","modified":1569657164946},{"_id":"public/categories/hexo/index.html","hash":"faa07ae469b3b49e487652cffba8d3fe41bc7b6c","modified":1569657164946},{"_id":"public/categories/笑话/index.html","hash":"cde9db282fbdfc60c80e093356223c6a8b69d4b8","modified":1569657164946},{"_id":"public/categories/Java/index.html","hash":"5e05700044bed6119ba61add8c82378ce4e6bb1e","modified":1569657164946},{"_id":"public/categories/linux/index.html","hash":"b6cfe690d93b7b25360a2e2c43b6bb4f59515f77","modified":1569657164946},{"_id":"public/categories/算法/index.html","hash":"1575984dba76f74a8663d3eb93364218117a5ef2","modified":1569657164946},{"_id":"public/categories/Lombok/index.html","hash":"130893b2e018e4826440efb001517f8ebed511bf","modified":1569657164946},{"_id":"public/categories/Mac/index.html","hash":"d06514c9b157da40344294996cb30b110b9b9a38","modified":1569657164946},{"_id":"public/categories/php/index.html","hash":"4389bf66f4d4939b7eb620b70ca01bc4fba49b3b","modified":1569657164946},{"_id":"public/categories/mysql/index.html","hash":"0e7b3f5ecc932f8186e3b0cc51a85f5af33a7677","modified":1569657164947},{"_id":"public/categories/spring/index.html","hash":"6fc44286ff9fd519574a5d3b1d2b6b57877811e6","modified":1569657164947},{"_id":"public/categories/异常处理/index.html","hash":"a89568537aed935059fcb9614753d0eed28897f4","modified":1569657164947},{"_id":"public/categories/虚拟机/index.html","hash":"21fb5851bd8b2ab7482e91cc4de8ba8c705d971d","modified":1569657164947},{"_id":"public/categories/技术/index.html","hash":"b91ad26037c1fbf3f569c331656397cfe8720291","modified":1569657164947},{"_id":"public/categories/idea/index.html","hash":"320bce89f7e9496b02cc4985655888be4d0b0d0f","modified":1569657164947},{"_id":"public/categories/exception/index.html","hash":"01ac0a2589d53aaed26c6c099518e916c65a4537","modified":1569657164947},{"_id":"public/categories/mac/index.html","hash":"ac03f55d3c13e174f5cbcd8f8965426f37d743e5","modified":1569657164947},{"_id":"public/categories/Tomcat/index.html","hash":"52ec08e80597767a0d27d94c7f46c168dafa5a57","modified":1569657164947},{"_id":"public/categories/育儿/index.html","hash":"ff8f9662e05d8d4e517d162b347b3d1c54721e94","modified":1569657164947},{"_id":"public/categories/生活/index.html","hash":"482c6b227aca4b70fa147692059c1bb622afbc54","modified":1569657164947},{"_id":"public/categories/成语/index.html","hash":"eba4cb06141d38d9be8abaca81c107e347dfa527","modified":1569657164947},{"_id":"public/categories/Shiro/index.html","hash":"633442deb23e8ae42ed22401ccd83641930ac36b","modified":1569657164947},{"_id":"public/categories/rabbitMQ/index.html","hash":"e520bb08a48db2c594268c7aa56dd4f09bac2e1b","modified":1569657164947},{"_id":"public/categories/读书/index.html","hash":"e85355dbbdab88b1d2917b4f664811d7fa3b983a","modified":1569657164947},{"_id":"public/index.html","hash":"9590b85c69c0a57bfb895dc65510af533603d273","modified":1569657164948},{"_id":"public/page/2/index.html","hash":"e64042fe2c1a9363c8fb21d79889dc5a758b11c7","modified":1569657164948},{"_id":"public/page/3/index.html","hash":"71d2442a806bf7f1413652bcba9e3e030c2d7676","modified":1569657164948},{"_id":"public/page/4/index.html","hash":"779ac26d6b3428f44d342e2111854f89a343b385","modified":1569657164948},{"_id":"public/page/6/index.html","hash":"739050ad2e2ea0cff8ca63ba4c7906243a88545f","modified":1569657164948},{"_id":"public/page/5/index.html","hash":"74f873b442a98afe5d149099aae626204fe66d16","modified":1569657164948},{"_id":"public/page/7/index.html","hash":"ff688632e6b4b71f43cbe870434114822b58778e","modified":1569657164948},{"_id":"public/page/8/index.html","hash":"a28cedef1731e6f5d7615f71f0fa2406d5aa1b44","modified":1569657164948},{"_id":"public/tags/AtomicInteger/index.html","hash":"5ecd7419a750d5849cfd4c8d71d9655d88c3d721","modified":1569657164948},{"_id":"public/tags/CAS/index.html","hash":"9355f52a25262e10d69e139f5711a6ff368bba5d","modified":1569657164948},{"_id":"public/tags/CentOS/index.html","hash":"9a854d0754042fe4ae428bde30fc276928a9357a","modified":1569657164948},{"_id":"public/tags/防火墙/index.html","hash":"e4958b9d4aa39c01e1fc0ab940733cb836341fb5","modified":1569657164948},{"_id":"public/tags/源码/index.html","hash":"60db3d9329ec9ad51e6caddc3acfcc4231511f31","modified":1569657164948},{"_id":"public/tags/git/index.html","hash":"2625adf50f6e01a9e418f4ce055eaf198504b3df","modified":1569657164948},{"_id":"public/tags/ssh/index.html","hash":"b3e50c141fd600bfceea9f042fb84128172d966e","modified":1569657164949},{"_id":"public/tags/linux/index.html","hash":"93f02d763e8db7bbd9416fd70f24d8410559636d","modified":1569657164949},{"_id":"public/tags/java/index.html","hash":"50885e33babbd50c0327074cfce42767afaea110","modified":1569657164949},{"_id":"public/tags/java/page/2/index.html","hash":"7710dffcf7a765940ecf1447d8a108e45c51422e","modified":1569657164949},{"_id":"public/tags/filter/index.html","hash":"6effa117a98bc78ba1aede481c5a49ce58d68cb4","modified":1569657164949},{"_id":"public/tags/idea/index.html","hash":"2e8051ca64d8740558865afe803c5306a2176f82","modified":1569657164949},{"_id":"public/tags/快捷键/index.html","hash":"604e0d287dcc130842cdea7139157e9b0c8e1d2d","modified":1569657164949},{"_id":"public/tags/Intellij-IDEA/index.html","hash":"c5c6942495abd8b1245e3d1bfd59c5d290052d85","modified":1569657164949},{"_id":"public/tags/JDK/index.html","hash":"5405ccff5e1c5e999ce9fda515bdb5d67aee2f98","modified":1569657164949},{"_id":"public/tags/hexo/index.html","hash":"1d63d4a4ccc9b627622fa5b9e1b8eb5d5f870099","modified":1569657164949},{"_id":"public/tags/kotlin/index.html","hash":"809c8ebbdcddfaac2280de4b28f125bbad9a8e04","modified":1569657164950},{"_id":"public/tags/JSP/index.html","hash":"157274735fa6672680faabcde9925dbe8bc2d5fd","modified":1569657164950},{"_id":"public/tags/JavaScript/index.html","hash":"f777a53ccc0b5ec21a96f8cc13fbf8aa4b0f46a5","modified":1569657164950},{"_id":"public/tags/ubuntu/index.html","hash":"de1e6d5ccb8260e4544e67e24ced0e5f64c8c117","modified":1569657164950},{"_id":"public/tags/LeetCode/index.html","hash":"8516d8aeb2cc5e77734e86a507a2d4db096c2272","modified":1569657164950},{"_id":"public/tags/算法/index.html","hash":"6437569f476ddfedddc5e6c9e462d01466563200","modified":1569657164950},{"_id":"public/tags/Linux/index.html","hash":"d0dd5f5456671508c87369198bdda69f870ceef9","modified":1569657164950},{"_id":"public/tags/tar/index.html","hash":"edbac55e42899f6daf9a62ebff92636dcf6cc393","modified":1569657164950},{"_id":"public/tags/压缩/index.html","hash":"637bec82018106521eac5a0f52c87b26d921a92a","modified":1569657164950},{"_id":"public/tags/解压缩/index.html","hash":"91a98d9a24ca223575be5188e14b5fa5091c0114","modified":1569657164950},{"_id":"public/tags/命令/index.html","hash":"3e895c6378a265216f5474266838ec838b181882","modified":1569657164950},{"_id":"public/tags/node/index.html","hash":"081cac6d709862b1674e59bc8daeba9e7e121b25","modified":1569657164950},{"_id":"public/tags/exception/index.html","hash":"ed25a303e0b800f87b60d107c7722149be987435","modified":1569657164951},{"_id":"public/tags/npm/index.html","hash":"abe9a546553f7f09d00980d8ffd775817b6732fb","modified":1569657164951},{"_id":"public/tags/brew/index.html","hash":"831be92b412cf8d82a7a1f900a7999625840b1e2","modified":1569657164951},{"_id":"public/tags/plugin/index.html","hash":"0473c9a6902de041c4c94dd71a918190831302bc","modified":1569657164951},{"_id":"public/tags/Mac/index.html","hash":"dfcd28c062bcd847a5ff70cf95abb6db56f57890","modified":1569657164951},{"_id":"public/tags/lombok/index.html","hash":"51e832e40a97ed48bef1277e21f5c22cb326e476","modified":1569657164951},{"_id":"public/tags/java-jdk/index.html","hash":"5af9e458b7806d7bfae917768bf208fe66eb4a04","modified":1569657164951},{"_id":"public/tags/laravel/index.html","hash":"aa029d8956135eccb7f9c131a0e4e584fa2e539e","modified":1569657164951},{"_id":"public/tags/mysql/index.html","hash":"5050accf5f9d0813cf2ee32514d5636cc3061397","modified":1569657164952},{"_id":"public/tags/spring/index.html","hash":"b4327b536529cd4ccc7f55dd5819c942ccfd24c6","modified":1569657164952},{"_id":"public/tags/vagrant/index.html","hash":"6922770aaa059800200d9e24ebfea31d0c453525","modified":1569657164952},{"_id":"public/tags/回滚/index.html","hash":"62cd32372233ea7a5b83758593f0838c7b7b8668","modified":1569657164952},{"_id":"public/tags/Spring/index.html","hash":"44a068af4e716bfcb0af6d04e78a69d8691d0461","modified":1569657164952},{"_id":"public/tags/编码/index.html","hash":"1c1895bb785a6b4468f569cd50081b91ae7ee34c","modified":1569657164952},{"_id":"public/tags/hex/index.html","hash":"b037936878a1373e0a25dd4db4111606e1895bcd","modified":1569657164952},{"_id":"public/tags/16进制/index.html","hash":"c896b10f29ebc198e5b8f8b47def063f30bea54b","modified":1569657164952},{"_id":"public/tags/键盘/index.html","hash":"85b6d2ba95e2ddf67facd8dbfa71b785fb0a4b4b","modified":1569657164952},{"_id":"public/tags/hhkb/index.html","hash":"6950246246213bf237c8bff62921f0d1924c29f3","modified":1569657164952},{"_id":"public/tags/homestead/index.html","hash":"315a258ad1273db6a6ebf7c6c961dbb68932c750","modified":1569657164952},{"_id":"public/tags/mongo/index.html","hash":"67bd52fe34cf5750412c275598d50fe96745540b","modified":1569657164952},{"_id":"public/tags/php扩展/index.html","hash":"e3ffb17257242a8b63c680fc6427c0858b5cc0aa","modified":1569657164953},{"_id":"public/tags/maven/index.html","hash":"ff6be96944ab065b4806f44c0be288206817a1fa","modified":1569657164953},{"_id":"public/tags/异常/index.html","hash":"95ba533af0c9e33496a599b468212335058388b1","modified":1569657164953},{"_id":"public/tags/环境变量/index.html","hash":"00215bd971727c3b262578bb7647fea7a7979144","modified":1569657164953},{"_id":"public/tags/mac/index.html","hash":"22539fc1da78e9b82c41a3ed11b0af3a79097254","modified":1569657164953},{"_id":"public/tags/chrome/index.html","hash":"a787c0b68e582480c1f95735ce7ea3a20b1cd00f","modified":1569657164953},{"_id":"public/tags/php/index.html","hash":"f833448164b514ab91a3d2ce436702a55eb35014","modified":1569657164953},{"_id":"public/tags/unset/index.html","hash":"4dfab46c43e423044d6d200b8d15d1c6dc45d964","modified":1569657164953},{"_id":"public/tags/shell/index.html","hash":"ba3b95b152af151731a4acf99cc2f5a265bcb719","modified":1569657164953},{"_id":"public/tags/java-tomcat/index.html","hash":"38c4adf48fc6e5dde863f5b20a462a49a8aacc0c","modified":1569657164953},{"_id":"public/tags/Tomcat/index.html","hash":"ce8333c89ca77370085cc7fc37a0e9506398d3de","modified":1569657164954},{"_id":"public/tags/生活/index.html","hash":"06644a07eae9125297fcdb74052606e922706386","modified":1569657164954},{"_id":"public/tags/bug/index.html","hash":"5d34722160e381788c5b74295c56ae524ab50658","modified":1569657164954},{"_id":"public/tags/vim/index.html","hash":"8d9c796ff76d514ad1e1e6fdc3312302201582bb","modified":1569657164954},{"_id":"public/tags/Shiro/index.html","hash":"9548f9d5c505cc13af9cfaca2c865eb791bb4d5b","modified":1569657164954},{"_id":"public/tags/育儿/index.html","hash":"cb087b0d407faa57b38c0fe39e0dd9c5de7913cd","modified":1569657164954},{"_id":"public/tags/回表/index.html","hash":"28522d0815383fdb26fd3b4f5088135c1bab84b6","modified":1569657164954},{"_id":"public/tags/覆盖索引/index.html","hash":"7832ba09439e41c183ea105c05f82d99bdd877ab","modified":1569657164954},{"_id":"public/tags/数据库/index.html","hash":"60af47810883494602dc6a9c419d984f6a5a4a4d","modified":1569657164954},{"_id":"public/tags/oracle/index.html","hash":"d8ebbf0524b637ad979d6b20e1808813f8602996","modified":1569657164954},{"_id":"public/tags/成语/index.html","hash":"dd4090be14ca8d37f4751bce35c66cc865a4dab8","modified":1569657164954},{"_id":"public/tags/泰拳/index.html","hash":"360e075124abefc3f77b6ee23cb2ec0582cc903c","modified":1569657164954},{"_id":"public/tags/运动/index.html","hash":"e90fff1378d28b17cf9e9a14300e95fca9e73758","modified":1569657164954},{"_id":"public/tags/rabbitMQ/index.html","hash":"0e77f763f1428f75fdf0282b429dbea1207ee3c7","modified":1569657164954},{"_id":"public/tags/读后感/index.html","hash":"97830cef2999db441cd7f3343148cb23176e88e2","modified":1569657164954},{"_id":"public/2019/09/27/持续集成服务-Travis-CI/index.html","hash":"c0d54e0ad1964ed1b1871372a553148f212528eb","modified":1569657164960},{"_id":"public/2019/09/27/hello-world/index.html","hash":"ab472c6be7daa9344b3b4176fd34a460501731bc","modified":1569657164960},{"_id":"public/2019/09/27/springmvc在controller方法里面跳转外网的方法/index.html","hash":"29e2e552d0c0f99308039d36551d113e28d937d7","modified":1569657164960},{"_id":"public/categories/TravisCI/index.html","hash":"516139d2a494d3e3cd034655072a3afccb1c53c7","modified":1569657164960},{"_id":"public/tags/TravisCI/index.html","hash":"3bbed8cdc28ff399d7528dfa778a2b05162cae60","modified":1569657164960},{"_id":"public/CNAME","hash":"90621995f3ffcca7fcff9bb1334110fe90641e66","modified":1569657164968},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1569657164968},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1569657164968},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1569657164968},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1569657164968},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1569657164968},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1569657164968},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1569657164968},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1569657164968},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1569657164968},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1569657164968},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1569657164968},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1569657164968},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1569657164968},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1569657164968},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1569657164968},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1569657164968},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1569657164968},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1569657164969},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1569657164969},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1569657164969},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1569657164969},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1569657164969},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1569657164969},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1569657164969},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1569657164969},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1569657164970},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1569657164970},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1569657164970},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1569657164970},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1569657164970},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1569657164970},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1569657164970},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1569657164970},{"_id":"public/2019/09/06/读-活着-有感/下载.jpeg","hash":"0028fe5a1e905c17a749c94db1be2d3e8d67e7d0","modified":1569657164970},{"_id":"public/2019/09/25/Javac原理/j.jpg","hash":"00243d68debabd98886255537e57902143066416","modified":1569657164970},{"_id":"public/uploads/avatar.JPG","hash":"e9864d8c686e1cbb7f4df5208e0ecf6da9a96365","modified":1569657165460},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1569657165460},{"_id":"public/2019/09/25/Javac原理/f.jpg","hash":"e9c8a719aca94a1a3ea572a6552abb1834cdec8b","modified":1569657165461},{"_id":"public/2019/09/11/Mac-下locate命令使用问题WARNING-The-locate-database-var-db-locate-database-does-not-exist/locate.png","hash":"48c99c70fd76ff2744b37def7bfc5a83aed366f1","modified":1569657165461},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1569657165462},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1569657165462},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1569657165462},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1569657165462},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1569657165463},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1569657165463},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1569657165463},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1569657165463},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1569657165463},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1569657165463},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1569657165463},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1569657165463},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1569657165463},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1569657165463},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1569657165463},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1569657165463},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1569657165463},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1569657165463},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1569657165463},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1569657165463},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1569657165463},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1569657165463},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1569657165464},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1569657165464},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1569657165464},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1569657165464},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1569657165464},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1569657165464},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1569657165464},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1569657165464},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1569657165464},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1569657165464},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1569657165464},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1569657165464},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1569657165465},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1569657165465},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1569657165465},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1569657165465},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1569657165465},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1569657165465},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1569657165465},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1569657165465},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1569657165466},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1569657165466},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1569657165466},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1569657165466},{"_id":"public/googlea34b5edc9a26f03a.html","hash":"07a447211c97ef93f934e72f2623d192f451ad15","modified":1569657165466},{"_id":"public/lib/fastclick/README.html","hash":"c5a4c05ca80132b7e343d5fd1d1d1a976b4ad151","modified":1569657165466},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"81057e5b518b8ab60474e1ad027e868b558f15b7","modified":1569657165466},{"_id":"public/lib/jquery_lazyload/README.html","hash":"18a600ca1aafd3bf08af52b6a6fe5f056aeed9f4","modified":1569657165466},{"_id":"public/css/main.css","hash":"426b7fd1d25043692a0f5165556c21678562186e","modified":1569657165466},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1569657165466},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1569657165466},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1569657165466},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1569657165467},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1569657165467},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1569657165467},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1569657165467},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1569657165467},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1569657165467},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1569657165467},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1569657165467},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1569657165467},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1569657165467},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1569657165467},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1569657165467},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1569657165467},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1569657165468},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1569657165468},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1569657165468},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1569657165468},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1569657165468},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1569657165468},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1569657165469},{"_id":"public/images/vmset.png","hash":"094e7f510d2831a27029720a619d0f3fd33652da","modified":1569657165528},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1569657165528},{"_id":"public/images/Filter的基本工作原理.png","hash":"9cfcaca53f7d28c49b0c314d8b12f323a91f7658","modified":1569657165531},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1569657165554}],"Category":[{"name":"git","_id":"ck139cehm0025ojfyj44ueewo"},{"name":"java","_id":"ck139cehp0029ojfyf8pwgyvl"},{"name":"hexo","_id":"ck139cehp002bojfy54be1pzp"},{"name":"笑话","_id":"ck139cehq002dojfy1eze1k2u"},{"name":"Java","_id":"ck139cehr002fojfyl0rm9jk6"},{"name":"linux","_id":"ck139cehr002hojfyil7h8abe"},{"name":"算法","_id":"ck139cehu002jojfyobp3prog"},{"name":"Mac","_id":"ck139cehx002qojfy6sc91809"},{"name":"Lombok","_id":"ck139cehx002sojfy9dxnhf6e"},{"name":"php","_id":"ck139cehy002uojfynaghg6wy"},{"name":"mysql","_id":"ck139cehy002wojfyhtnubkh4"},{"name":"spring","_id":"ck139cei20034ojfyeg9dgona"},{"name":"异常处理","_id":"ck139cei20036ojfy4tgk7vuo"},{"name":"虚拟机","_id":"ck139cei30038ojfy218d3b65"},{"name":"技术","_id":"ck139cei4003cojfyq5opducq"},{"name":"idea","_id":"ck139cei6003gojfy4gcq2elg"},{"name":"exception","_id":"ck139cei8003iojfypz76p9vi"},{"name":"mac","_id":"ck139ceia003oojfyoriycsaw"},{"name":"Tomcat","_id":"ck139ceic003uojfyxjjh3r4c"},{"name":"生活","_id":"ck139ceif0043ojfymz7co3ci"},{"name":"Shiro","_id":"ck139ceig0047ojfyynawtv7u"},{"name":"育儿","_id":"ck139ceii004fojfyg3aalv8n"},{"name":"TravisCI","_id":"ck139ceii004hojfyo28p8dhb"},{"name":"成语","_id":"ck139ceij004jojfyho323ht5"},{"name":"rabbitMQ","_id":"ck139ceil004rojfycpsu85u6"},{"name":"读书","_id":"ck139ceim004vojfyf4ajx59v"}],"Data":[],"Page":[{"title":"关于","date":"2018-12-20T10:05:19.000Z","_content":"\n`声明`\n\n*纸上得来终觉浅，绝知此事要躬行*\n\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2018-12-20 18:05:19\n---\n\n`声明`\n\n*纸上得来终觉浅，绝知此事要躬行*\n\n","updated":"2019-09-27T08:27:08.056Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck139ceca0000ojfy3cz55wis","content":"<p><code>声明</code></p>\n<p><em>纸上得来终觉浅，绝知此事要躬行</em></p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>声明</code></p>\n<p><em>纸上得来终觉浅，绝知此事要躬行</em></p>\n"},{"title":"文章分类","date":"2018-12-20T07:49:08.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2018-12-20 15:49:08\ntype: \"categories\"\n---\n","updated":"2019-09-27T08:27:08.056Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck139cece0002ojfyolkckh4c","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-12-20T09:49:07.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-12-20 17:49:07\ntype: \"tags\"\n---\n","updated":"2019-09-27T08:27:08.060Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck139cehn0026ojfyjqtqo1re","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"AtomicInteger原理分析","date":"2018-07-04T07:13:11.000Z","_content":"\nAtomicInteger通俗的讲就是:对某个内存值拷贝一个副本,\n某个线程若读到这个副本,则对其进行计算,输出结果,在写入\n内存时,再次取出内存值与该副本比较,若副本与内存值相同\n则把新的值写入内存.\n\n较为官方的解释:通过CAS(AtomicInteger)实现,\n\n## CAS算法\nCAS有三个操作数,内存值V,旧的预期值A,要修改的新值B.当且仅当预期值A和\n内存值V相同时,将内存值V修改为B,否则什么都不做.\n### 两个问题:\n\n### (1)\n CAS算法仍然可能出现冲突,例如A,B两个线程,A已经进入写内存但未完成\n，此时A读取到的副本且读取成功，AB两个线程同时进入写内存操作，必然会造\n成冲突。 CAS算法本质并非完全无锁，而是把获得锁和释放锁推迟至CPU原语实\n现，相当于尽可能的缩小了锁的范围；直接互斥地实现系统状态的改变，它的使\n用基本思想是copy-on-write——在修改完对象的副本之后再用CAS操作将副本\n替换为正本。 \n\n### (2)\n\nABA问题，若其中一个线程修改A->B->A，另外一个线程仍然读取到A，虽然值是\n预期值，但并不能说明该内存值没有变化。","source":"_posts/AtomicInteger原理分析.md","raw":"---\ntitle: AtomicInteger原理分析\ndate: 2018-07-04 15:13:11\ntags: [AtomicInteger,CAS]\n---\n\nAtomicInteger通俗的讲就是:对某个内存值拷贝一个副本,\n某个线程若读到这个副本,则对其进行计算,输出结果,在写入\n内存时,再次取出内存值与该副本比较,若副本与内存值相同\n则把新的值写入内存.\n\n较为官方的解释:通过CAS(AtomicInteger)实现,\n\n## CAS算法\nCAS有三个操作数,内存值V,旧的预期值A,要修改的新值B.当且仅当预期值A和\n内存值V相同时,将内存值V修改为B,否则什么都不做.\n### 两个问题:\n\n### (1)\n CAS算法仍然可能出现冲突,例如A,B两个线程,A已经进入写内存但未完成\n，此时A读取到的副本且读取成功，AB两个线程同时进入写内存操作，必然会造\n成冲突。 CAS算法本质并非完全无锁，而是把获得锁和释放锁推迟至CPU原语实\n现，相当于尽可能的缩小了锁的范围；直接互斥地实现系统状态的改变，它的使\n用基本思想是copy-on-write——在修改完对象的副本之后再用CAS操作将副本\n替换为正本。 \n\n### (2)\n\nABA问题，若其中一个线程修改A->B->A，另外一个线程仍然读取到A，虽然值是\n预期值，但并不能说明该内存值没有变化。","slug":"AtomicInteger原理分析","published":1,"updated":"2019-09-27T08:27:08.020Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecb0001ojfyljxmtmri","content":"<p>AtomicInteger通俗的讲就是:对某个内存值拷贝一个副本,<br>某个线程若读到这个副本,则对其进行计算,输出结果,在写入<br>内存时,再次取出内存值与该副本比较,若副本与内存值相同<br>则把新的值写入内存.</p>\n<p>较为官方的解释:通过CAS(AtomicInteger)实现,</p>\n<h2 id=\"CAS算法\"><a href=\"#CAS算法\" class=\"headerlink\" title=\"CAS算法\"></a>CAS算法</h2><p>CAS有三个操作数,内存值V,旧的预期值A,要修改的新值B.当且仅当预期值A和<br>内存值V相同时,将内存值V修改为B,否则什么都不做.</p>\n<h3 id=\"两个问题\"><a href=\"#两个问题\" class=\"headerlink\" title=\"两个问题:\"></a>两个问题:</h3><h3 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"(1)\"></a>(1)</h3><p> CAS算法仍然可能出现冲突,例如A,B两个线程,A已经进入写内存但未完成<br>，此时A读取到的副本且读取成功，AB两个线程同时进入写内存操作，必然会造<br>成冲突。 CAS算法本质并非完全无锁，而是把获得锁和释放锁推迟至CPU原语实<br>现，相当于尽可能的缩小了锁的范围；直接互斥地实现系统状态的改变，它的使<br>用基本思想是copy-on-write——在修改完对象的副本之后再用CAS操作将副本<br>替换为正本。 </p>\n<h3 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"(2)\"></a>(2)</h3><p>ABA问题，若其中一个线程修改A-&gt;B-&gt;A，另外一个线程仍然读取到A，虽然值是<br>预期值，但并不能说明该内存值没有变化。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>AtomicInteger通俗的讲就是:对某个内存值拷贝一个副本,<br>某个线程若读到这个副本,则对其进行计算,输出结果,在写入<br>内存时,再次取出内存值与该副本比较,若副本与内存值相同<br>则把新的值写入内存.</p>\n<p>较为官方的解释:通过CAS(AtomicInteger)实现,</p>\n<h2 id=\"CAS算法\"><a href=\"#CAS算法\" class=\"headerlink\" title=\"CAS算法\"></a>CAS算法</h2><p>CAS有三个操作数,内存值V,旧的预期值A,要修改的新值B.当且仅当预期值A和<br>内存值V相同时,将内存值V修改为B,否则什么都不做.</p>\n<h3 id=\"两个问题\"><a href=\"#两个问题\" class=\"headerlink\" title=\"两个问题:\"></a>两个问题:</h3><h3 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"(1)\"></a>(1)</h3><p> CAS算法仍然可能出现冲突,例如A,B两个线程,A已经进入写内存但未完成<br>，此时A读取到的副本且读取成功，AB两个线程同时进入写内存操作，必然会造<br>成冲突。 CAS算法本质并非完全无锁，而是把获得锁和释放锁推迟至CPU原语实<br>现，相当于尽可能的缩小了锁的范围；直接互斥地实现系统状态的改变，它的使<br>用基本思想是copy-on-write——在修改完对象的副本之后再用CAS操作将副本<br>替换为正本。 </p>\n<h3 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"(2)\"></a>(2)</h3><p>ABA问题，若其中一个线程修改A-&gt;B-&gt;A，另外一个线程仍然读取到A，虽然值是<br>预期值，但并不能说明该内存值没有变化。</p>\n"},{"title":"CentOS防火墙设置与端口开放的方法","date":"2018-04-23T06:42:25.000Z","_content":"\n    Centos升级到7后,内置的防火墙已经从iptables变成了firewalld,所以,端口\n    的开启还是要从两种情况来说明的,即iptables和firewalld.\n    更多内容请参考Rehat官网\n    \n### iptables\n    \n    开启防火墙(重启后永久有效) : chkconfig iptables on\n    \n    关闭防火墙(重启后永久有效) : chkconfig iptables off\n    \n    开启防火墙(即时生效,重启后失效) : service iptables start\n    \n    关闭防火墙(即时生效,重启后失效) : service iptables stop\n    \n    重启防火墙 :service iptables restartd\n    \n    查看打开的端口\n    /etc/init.d/iptables status\n    \n    打开某个端口(以8080为例)\n    \n    (1) 开启端口\n    \n    iptables -A INPUT -p tcp --dport 8080 -j ACCEPT\n    \n    (2)保存并重启防火墙\n    \n    /etc/rc.d/init.d/iptables save\n    /etc/init.d/iptables restart\n    \n    打开49152~65534之间的端口\n    \n    iptables -A INPUT -p tcp --dport 49152:65534 -j ACCEPT\n    \n    同样,这里需要对设置进行保存,并重启防火墙.\n    \n    其他打开方式\n    \n    我们还可以通过修改/etc/sysconfig/iptables文件方式开启端口,如下\n    \n    vi /etc/sysconfig/iptables\n    \n    然后再文件中增加一行\n    \n    -A RH-Firewall-1-INPUT -m state -state NEW -m tcp -p tcp -dport 8080 -j ACCEPT\n    \n    参数说明:\n    \n    -A 参数就看成是添加一条规则\n    -p 指定是什么协议,我们常用的tcp协议,当然也有udp,例如53端口的DNS\n    -dport 就是目标端口,当数据从外部进入服务器为目标端口\n    -sport 数据从服务器出去,则为数据源端口使用\n    -j 就是指定是ACCEPT -接收或者DROP不接收\n    \n### firewalld  \n\n    Centos7默认安装了firewalld,如果没有安装的话,可以使用\n    yum install firewalld firewalld-config进行安装.\n    \n    1启动防火墙\n    \n    systemctl start firewalld\n    \n    2 禁用防火墙\n    \n    systemctl stop firewalld\n    \n    3 设置开机启动\n    \n    systemctl enable firewalld\n    \n    4 停止并禁用开机启动\n    \n    systemctl disable firewalld\n    \n    5 重启防火墙\n    \n    firewall-cmd --reload\n    \n    6 查看状态\n    \n    systemctl status firewalld或者 firewall-cmd --state\n    \n    7查看版本\n    \n    firewall-cmd --version\n    \n    8查看帮助\n    \n    firewall-cmd --help\n    \n    9查看区域信息\n    \n    firewall-cmd --get-active-zones\n    \n    10查看指定接口所属区域信息\n    \n    firewall-cmd --get-zone-of-interface=eth0\n    \n    11 拒绝所有包\n    \n    firewall-cmd --panic-on\n    \n    12 取消拒绝状态\n    \n    firewall-cmd --panic-off\n    \n    13 查看是否拒绝\n    \n    firewall-cmd --query-panic\n    \n    14将接口添加到区域(默认接口都在public)\n    \n    firewall-cmd --zone=public --add-interface=eth0(永久生效再加上 --permanent 然后reload防火墙)\n    \n    15 设置默认接口区域\n    \n    firewall-cmd --set-default-zone=public(立即生效,无需重启)\n    \n    16 更新防火墙规则\n    \n    firewall-cmd --reload或firewall-cmd --complete-reload(两\n    者的区别就是第一个无需断开连接,就是firewalld特性之一动态\n    添加规则,第二个需要断开连接,类似重启服务)\n    \n    17 查看指定区域所有打开的端口  \n    \n    firewall-cmd --zone=public --list-ports\n    \n    18指定区域打开端口(记得重启防火墙)\n    \n    firewall-comd --zone=public --add-port=80/tcp(永久生效再加上 --permanent)\n    \n    说明:\n    -zone 作用域\n    -add-port=8080/tcp 添加端口,格式为:端口/通讯协议\n    -permanent #永久生效,没有此参数重启后失效\n    \n    参考文章：\n    http://havee.me/linux/2015-01/using-firewalls-on-centos-7.html\n","source":"_posts/CentOS防火墙设置与端口开放的方法.md","raw":"---\ntitle: CentOS防火墙设置与端口开放的方法\ndate: 2018-04-23 14:42:25\ntags: [linux, CentOS, 防火墙]\n---\n\n    Centos升级到7后,内置的防火墙已经从iptables变成了firewalld,所以,端口\n    的开启还是要从两种情况来说明的,即iptables和firewalld.\n    更多内容请参考Rehat官网\n    \n### iptables\n    \n    开启防火墙(重启后永久有效) : chkconfig iptables on\n    \n    关闭防火墙(重启后永久有效) : chkconfig iptables off\n    \n    开启防火墙(即时生效,重启后失效) : service iptables start\n    \n    关闭防火墙(即时生效,重启后失效) : service iptables stop\n    \n    重启防火墙 :service iptables restartd\n    \n    查看打开的端口\n    /etc/init.d/iptables status\n    \n    打开某个端口(以8080为例)\n    \n    (1) 开启端口\n    \n    iptables -A INPUT -p tcp --dport 8080 -j ACCEPT\n    \n    (2)保存并重启防火墙\n    \n    /etc/rc.d/init.d/iptables save\n    /etc/init.d/iptables restart\n    \n    打开49152~65534之间的端口\n    \n    iptables -A INPUT -p tcp --dport 49152:65534 -j ACCEPT\n    \n    同样,这里需要对设置进行保存,并重启防火墙.\n    \n    其他打开方式\n    \n    我们还可以通过修改/etc/sysconfig/iptables文件方式开启端口,如下\n    \n    vi /etc/sysconfig/iptables\n    \n    然后再文件中增加一行\n    \n    -A RH-Firewall-1-INPUT -m state -state NEW -m tcp -p tcp -dport 8080 -j ACCEPT\n    \n    参数说明:\n    \n    -A 参数就看成是添加一条规则\n    -p 指定是什么协议,我们常用的tcp协议,当然也有udp,例如53端口的DNS\n    -dport 就是目标端口,当数据从外部进入服务器为目标端口\n    -sport 数据从服务器出去,则为数据源端口使用\n    -j 就是指定是ACCEPT -接收或者DROP不接收\n    \n### firewalld  \n\n    Centos7默认安装了firewalld,如果没有安装的话,可以使用\n    yum install firewalld firewalld-config进行安装.\n    \n    1启动防火墙\n    \n    systemctl start firewalld\n    \n    2 禁用防火墙\n    \n    systemctl stop firewalld\n    \n    3 设置开机启动\n    \n    systemctl enable firewalld\n    \n    4 停止并禁用开机启动\n    \n    systemctl disable firewalld\n    \n    5 重启防火墙\n    \n    firewall-cmd --reload\n    \n    6 查看状态\n    \n    systemctl status firewalld或者 firewall-cmd --state\n    \n    7查看版本\n    \n    firewall-cmd --version\n    \n    8查看帮助\n    \n    firewall-cmd --help\n    \n    9查看区域信息\n    \n    firewall-cmd --get-active-zones\n    \n    10查看指定接口所属区域信息\n    \n    firewall-cmd --get-zone-of-interface=eth0\n    \n    11 拒绝所有包\n    \n    firewall-cmd --panic-on\n    \n    12 取消拒绝状态\n    \n    firewall-cmd --panic-off\n    \n    13 查看是否拒绝\n    \n    firewall-cmd --query-panic\n    \n    14将接口添加到区域(默认接口都在public)\n    \n    firewall-cmd --zone=public --add-interface=eth0(永久生效再加上 --permanent 然后reload防火墙)\n    \n    15 设置默认接口区域\n    \n    firewall-cmd --set-default-zone=public(立即生效,无需重启)\n    \n    16 更新防火墙规则\n    \n    firewall-cmd --reload或firewall-cmd --complete-reload(两\n    者的区别就是第一个无需断开连接,就是firewalld特性之一动态\n    添加规则,第二个需要断开连接,类似重启服务)\n    \n    17 查看指定区域所有打开的端口  \n    \n    firewall-cmd --zone=public --list-ports\n    \n    18指定区域打开端口(记得重启防火墙)\n    \n    firewall-comd --zone=public --add-port=80/tcp(永久生效再加上 --permanent)\n    \n    说明:\n    -zone 作用域\n    -add-port=8080/tcp 添加端口,格式为:端口/通讯协议\n    -permanent #永久生效,没有此参数重启后失效\n    \n    参考文章：\n    http://havee.me/linux/2015-01/using-firewalls-on-centos-7.html\n","slug":"CentOS防火墙设置与端口开放的方法","published":1,"updated":"2019-09-27T08:27:08.021Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecf0003ojfynqrmj1vz","content":"<pre><code>Centos升级到7后,内置的防火墙已经从iptables变成了firewalld,所以,端口\n的开启还是要从两种情况来说明的,即iptables和firewalld.\n更多内容请参考Rehat官网</code></pre><h3 id=\"iptables\"><a href=\"#iptables\" class=\"headerlink\" title=\"iptables\"></a>iptables</h3><pre><code>开启防火墙(重启后永久有效) : chkconfig iptables on\n\n关闭防火墙(重启后永久有效) : chkconfig iptables off\n\n开启防火墙(即时生效,重启后失效) : service iptables start\n\n关闭防火墙(即时生效,重启后失效) : service iptables stop\n\n重启防火墙 :service iptables restartd\n\n查看打开的端口\n/etc/init.d/iptables status\n\n打开某个端口(以8080为例)\n\n(1) 开启端口\n\niptables -A INPUT -p tcp --dport 8080 -j ACCEPT\n\n(2)保存并重启防火墙\n\n/etc/rc.d/init.d/iptables save\n/etc/init.d/iptables restart\n\n打开49152~65534之间的端口\n\niptables -A INPUT -p tcp --dport 49152:65534 -j ACCEPT\n\n同样,这里需要对设置进行保存,并重启防火墙.\n\n其他打开方式\n\n我们还可以通过修改/etc/sysconfig/iptables文件方式开启端口,如下\n\nvi /etc/sysconfig/iptables\n\n然后再文件中增加一行\n\n-A RH-Firewall-1-INPUT -m state -state NEW -m tcp -p tcp -dport 8080 -j ACCEPT\n\n参数说明:\n\n-A 参数就看成是添加一条规则\n-p 指定是什么协议,我们常用的tcp协议,当然也有udp,例如53端口的DNS\n-dport 就是目标端口,当数据从外部进入服务器为目标端口\n-sport 数据从服务器出去,则为数据源端口使用\n-j 就是指定是ACCEPT -接收或者DROP不接收</code></pre><h3 id=\"firewalld\"><a href=\"#firewalld\" class=\"headerlink\" title=\"firewalld\"></a>firewalld</h3><pre><code>Centos7默认安装了firewalld,如果没有安装的话,可以使用\nyum install firewalld firewalld-config进行安装.\n\n1启动防火墙\n\nsystemctl start firewalld\n\n2 禁用防火墙\n\nsystemctl stop firewalld\n\n3 设置开机启动\n\nsystemctl enable firewalld\n\n4 停止并禁用开机启动\n\nsystemctl disable firewalld\n\n5 重启防火墙\n\nfirewall-cmd --reload\n\n6 查看状态\n\nsystemctl status firewalld或者 firewall-cmd --state\n\n7查看版本\n\nfirewall-cmd --version\n\n8查看帮助\n\nfirewall-cmd --help\n\n9查看区域信息\n\nfirewall-cmd --get-active-zones\n\n10查看指定接口所属区域信息\n\nfirewall-cmd --get-zone-of-interface=eth0\n\n11 拒绝所有包\n\nfirewall-cmd --panic-on\n\n12 取消拒绝状态\n\nfirewall-cmd --panic-off\n\n13 查看是否拒绝\n\nfirewall-cmd --query-panic\n\n14将接口添加到区域(默认接口都在public)\n\nfirewall-cmd --zone=public --add-interface=eth0(永久生效再加上 --permanent 然后reload防火墙)\n\n15 设置默认接口区域\n\nfirewall-cmd --set-default-zone=public(立即生效,无需重启)\n\n16 更新防火墙规则\n\nfirewall-cmd --reload或firewall-cmd --complete-reload(两\n者的区别就是第一个无需断开连接,就是firewalld特性之一动态\n添加规则,第二个需要断开连接,类似重启服务)\n\n17 查看指定区域所有打开的端口  \n\nfirewall-cmd --zone=public --list-ports\n\n18指定区域打开端口(记得重启防火墙)\n\nfirewall-comd --zone=public --add-port=80/tcp(永久生效再加上 --permanent)\n\n说明:\n-zone 作用域\n-add-port=8080/tcp 添加端口,格式为:端口/通讯协议\n-permanent #永久生效,没有此参数重启后失效\n\n参考文章：\nhttp://havee.me/linux/2015-01/using-firewalls-on-centos-7.html</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre><code>Centos升级到7后,内置的防火墙已经从iptables变成了firewalld,所以,端口\n的开启还是要从两种情况来说明的,即iptables和firewalld.\n更多内容请参考Rehat官网</code></pre><h3 id=\"iptables\"><a href=\"#iptables\" class=\"headerlink\" title=\"iptables\"></a>iptables</h3><pre><code>开启防火墙(重启后永久有效) : chkconfig iptables on\n\n关闭防火墙(重启后永久有效) : chkconfig iptables off\n\n开启防火墙(即时生效,重启后失效) : service iptables start\n\n关闭防火墙(即时生效,重启后失效) : service iptables stop\n\n重启防火墙 :service iptables restartd\n\n查看打开的端口\n/etc/init.d/iptables status\n\n打开某个端口(以8080为例)\n\n(1) 开启端口\n\niptables -A INPUT -p tcp --dport 8080 -j ACCEPT\n\n(2)保存并重启防火墙\n\n/etc/rc.d/init.d/iptables save\n/etc/init.d/iptables restart\n\n打开49152~65534之间的端口\n\niptables -A INPUT -p tcp --dport 49152:65534 -j ACCEPT\n\n同样,这里需要对设置进行保存,并重启防火墙.\n\n其他打开方式\n\n我们还可以通过修改/etc/sysconfig/iptables文件方式开启端口,如下\n\nvi /etc/sysconfig/iptables\n\n然后再文件中增加一行\n\n-A RH-Firewall-1-INPUT -m state -state NEW -m tcp -p tcp -dport 8080 -j ACCEPT\n\n参数说明:\n\n-A 参数就看成是添加一条规则\n-p 指定是什么协议,我们常用的tcp协议,当然也有udp,例如53端口的DNS\n-dport 就是目标端口,当数据从外部进入服务器为目标端口\n-sport 数据从服务器出去,则为数据源端口使用\n-j 就是指定是ACCEPT -接收或者DROP不接收</code></pre><h3 id=\"firewalld\"><a href=\"#firewalld\" class=\"headerlink\" title=\"firewalld\"></a>firewalld</h3><pre><code>Centos7默认安装了firewalld,如果没有安装的话,可以使用\nyum install firewalld firewalld-config进行安装.\n\n1启动防火墙\n\nsystemctl start firewalld\n\n2 禁用防火墙\n\nsystemctl stop firewalld\n\n3 设置开机启动\n\nsystemctl enable firewalld\n\n4 停止并禁用开机启动\n\nsystemctl disable firewalld\n\n5 重启防火墙\n\nfirewall-cmd --reload\n\n6 查看状态\n\nsystemctl status firewalld或者 firewall-cmd --state\n\n7查看版本\n\nfirewall-cmd --version\n\n8查看帮助\n\nfirewall-cmd --help\n\n9查看区域信息\n\nfirewall-cmd --get-active-zones\n\n10查看指定接口所属区域信息\n\nfirewall-cmd --get-zone-of-interface=eth0\n\n11 拒绝所有包\n\nfirewall-cmd --panic-on\n\n12 取消拒绝状态\n\nfirewall-cmd --panic-off\n\n13 查看是否拒绝\n\nfirewall-cmd --query-panic\n\n14将接口添加到区域(默认接口都在public)\n\nfirewall-cmd --zone=public --add-interface=eth0(永久生效再加上 --permanent 然后reload防火墙)\n\n15 设置默认接口区域\n\nfirewall-cmd --set-default-zone=public(立即生效,无需重启)\n\n16 更新防火墙规则\n\nfirewall-cmd --reload或firewall-cmd --complete-reload(两\n者的区别就是第一个无需断开连接,就是firewalld特性之一动态\n添加规则,第二个需要断开连接,类似重启服务)\n\n17 查看指定区域所有打开的端口  \n\nfirewall-cmd --zone=public --list-ports\n\n18指定区域打开端口(记得重启防火墙)\n\nfirewall-comd --zone=public --add-port=80/tcp(永久生效再加上 --permanent)\n\n说明:\n-zone 作用域\n-add-port=8080/tcp 添加端口,格式为:端口/通讯协议\n-permanent #永久生效,没有此参数重启后失效\n\n参考文章：\nhttp://havee.me/linux/2015-01/using-firewalls-on-centos-7.html</code></pre>"},{"title":" AtomicInteger类的理解与使用","date":"2018-07-04T02:31:36.000Z","_content":"引用:https://blog.csdn.net/u012734441/article/details/51619751\n\n首先看两段代码，一段是Integer的，一段是AtomicInteger的，为以下：\n\n       public class Sample1 {\n       \n           private static Integer count = 0;\n       \n           synchronized public static void increment() {\n               count++;\n           }\n       \n       }\n\n以下是AtomicInteger的：\n\n    public class Sample2 {\n    \n        private static AtomicInteger count = new AtomicInteger(0);\n    \n        public static void increment() {\n            count.getAndIncrement();\n        }\n    \n    }\n\n对比发现:使用Integer时必须加上synchronized保证不会出现并发线程同时\n访问的情况,而AtomicInteger中却不用加上synchronized,在这里AtomicInteger\n是提供原子操作的.\n\nAtomicInteger是一个提供原子操作的Integer类，通过线程安全的方式操作加减。\n\n\nAtomicInteger使用场景\n\nAtomicInteger提供原子操作来进行Integer的使用，因此十分适合高并发情况下的使用。\n\n\nAtomicInteger源码部分讲解\n\n    public class AtomicInteger extends Number implements java.io.Serializable {\n        private static final long serialVersionUID = 6214790243416807050L;\n        \n        // setup to use Unsafe.compareAndSwapInt for updates\n        private static final Unsafe unsafe = Unsafe.getUnsafe();\n        private static final long valueOffset;\n        \n        static {\n            try{\n                valueOffset = unsafe.objectFieldOffset\n                    (AtomicInteger.class.getDeclaredField(\"value\"));\n            } catch (Exception e) {\n                throw new Error(ex);\n            }\n        }\n        private volatile int value;\n\n    }\n\n以上为AtomicInteger中的部分源码，在这里说下其中的value，\n这里value使用了volatile关键字，volatile在这里可以做到的\n作用是使得多个线程可以共享变量，但是问题在于使用volatile将\n使得VM优化失去作用，导致效率较低，所以要在必要的时候使用，\n因此AtomicInteger类不要随意使用，要在使用场景下使用。\n\n## AtomicInteger实例使用\n\n以下就是在多线程情况下，使用AtomicInteger的一个实例，这段代码是借用IT宅中的一段代码。\n\n public class AtomicTest {\n\n    static long randomTime() {\n        return (long) (Math.random() * 1000);\n    }\n\n    public static void main(String[] args) {\n        // 阻塞队列，能容纳100个文件\n        final BlockingQueue<File> queue = new LinkedBlockingQueue<File>(100);\n        // 线程池\n        final ExecutorService exec = Executors.newFixedThreadPool(5);\n        final File root = new File(\"D:\\\\ISO\");\n        // 完成标志\n        final File exitFile = new File(\"\");\n        // 原子整型，读个数\n        // AtomicInteger可以在并发情况下达到原子化更新，避免使用了synchronized，而且性能非常高。\n        final AtomicInteger rc = new AtomicInteger();\n        // 原子整型，写个数\n        final AtomicInteger wc = new AtomicInteger();\n        // 读线程\n        Runnable read = new Runnable() {\n            public void run() {\n                scanFile(root);\n                scanFile(exitFile);\n            }\n\n            public void scanFile(File file) {\n                if (file.isDirectory()) {\n                    File[] files = file.listFiles(new FileFilter() {\n                        public boolean accept(File pathname) {\n                            return pathname.isDirectory() || pathname.getPath().endsWith(\".iso\");\n                        }\n                    });\n                    for (File one : files)\n                 scanFile(one);\n                } else {\n                    try {\n                        // 原子整型的incrementAndGet方法，以原子方式将当前值加 1，返回更新的值\n                        int index = rc.incrementAndGet();\n                        System.out.println(\"Read0: \" + index + \" \" + file.getPath());\n                        // 添加到阻塞队列中\n                        queue.put(file);\n                    } catch (InterruptedException e) {\n\n                    }\n                }\n            }\n        };\n        // submit方法提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n        exec.submit(read);\n\n        // 四个写线程\n        for (int index = 0; index < 4; index++) {\n            // write thread\n            final int num = index;\n            Runnable write = new Runnable() {\n                String threadName = \"Write\" + num;\n\n                public void run() {\n                    while (true) {\n                        try {\n                            Thread.sleep(randomTime());\n                            // 原子整型的incrementAndGet方法，以原子方式将当前值加 1，返回更新的值\n                            int index = wc.incrementAndGet();\n                            // 获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）。\n                            File file = queue.take();\n                            // 队列已经无对象\n                            if (file == exitFile) {\n                                // 再次添加\"标志\"，以让其他线程正常退出\n                                queue.put(exitFile);\n                                break;\n                                          }\n                                                            System.out.println(threadName + \": \" + index + \" \" + file.getPath());\n                                                        } catch (InterruptedException e) {\n                                                        }\n                                                    }\n                                                }\n                                \n                                            };\n                                            exec.submit(write);\n                                        }\n                                        exec.shutdown();\n                                    }\n                                \n                                }\n\n## AtomicInteger使用总结\n\nAtomicInteger是在使用非阻塞算法实现并发控制，在一些高并发程序中非常适合，但并不能每一种场景都适合，不同场景要使用使用不同的数值类。\n\n","source":"_posts/AtomicInteger类的理解与使用.md","raw":"---\ntitle: ' AtomicInteger类的理解与使用'\ndate: 2018-07-04 10:31:36\ntags: [AtomicInteger,源码]\n---\n引用:https://blog.csdn.net/u012734441/article/details/51619751\n\n首先看两段代码，一段是Integer的，一段是AtomicInteger的，为以下：\n\n       public class Sample1 {\n       \n           private static Integer count = 0;\n       \n           synchronized public static void increment() {\n               count++;\n           }\n       \n       }\n\n以下是AtomicInteger的：\n\n    public class Sample2 {\n    \n        private static AtomicInteger count = new AtomicInteger(0);\n    \n        public static void increment() {\n            count.getAndIncrement();\n        }\n    \n    }\n\n对比发现:使用Integer时必须加上synchronized保证不会出现并发线程同时\n访问的情况,而AtomicInteger中却不用加上synchronized,在这里AtomicInteger\n是提供原子操作的.\n\nAtomicInteger是一个提供原子操作的Integer类，通过线程安全的方式操作加减。\n\n\nAtomicInteger使用场景\n\nAtomicInteger提供原子操作来进行Integer的使用，因此十分适合高并发情况下的使用。\n\n\nAtomicInteger源码部分讲解\n\n    public class AtomicInteger extends Number implements java.io.Serializable {\n        private static final long serialVersionUID = 6214790243416807050L;\n        \n        // setup to use Unsafe.compareAndSwapInt for updates\n        private static final Unsafe unsafe = Unsafe.getUnsafe();\n        private static final long valueOffset;\n        \n        static {\n            try{\n                valueOffset = unsafe.objectFieldOffset\n                    (AtomicInteger.class.getDeclaredField(\"value\"));\n            } catch (Exception e) {\n                throw new Error(ex);\n            }\n        }\n        private volatile int value;\n\n    }\n\n以上为AtomicInteger中的部分源码，在这里说下其中的value，\n这里value使用了volatile关键字，volatile在这里可以做到的\n作用是使得多个线程可以共享变量，但是问题在于使用volatile将\n使得VM优化失去作用，导致效率较低，所以要在必要的时候使用，\n因此AtomicInteger类不要随意使用，要在使用场景下使用。\n\n## AtomicInteger实例使用\n\n以下就是在多线程情况下，使用AtomicInteger的一个实例，这段代码是借用IT宅中的一段代码。\n\n public class AtomicTest {\n\n    static long randomTime() {\n        return (long) (Math.random() * 1000);\n    }\n\n    public static void main(String[] args) {\n        // 阻塞队列，能容纳100个文件\n        final BlockingQueue<File> queue = new LinkedBlockingQueue<File>(100);\n        // 线程池\n        final ExecutorService exec = Executors.newFixedThreadPool(5);\n        final File root = new File(\"D:\\\\ISO\");\n        // 完成标志\n        final File exitFile = new File(\"\");\n        // 原子整型，读个数\n        // AtomicInteger可以在并发情况下达到原子化更新，避免使用了synchronized，而且性能非常高。\n        final AtomicInteger rc = new AtomicInteger();\n        // 原子整型，写个数\n        final AtomicInteger wc = new AtomicInteger();\n        // 读线程\n        Runnable read = new Runnable() {\n            public void run() {\n                scanFile(root);\n                scanFile(exitFile);\n            }\n\n            public void scanFile(File file) {\n                if (file.isDirectory()) {\n                    File[] files = file.listFiles(new FileFilter() {\n                        public boolean accept(File pathname) {\n                            return pathname.isDirectory() || pathname.getPath().endsWith(\".iso\");\n                        }\n                    });\n                    for (File one : files)\n                 scanFile(one);\n                } else {\n                    try {\n                        // 原子整型的incrementAndGet方法，以原子方式将当前值加 1，返回更新的值\n                        int index = rc.incrementAndGet();\n                        System.out.println(\"Read0: \" + index + \" \" + file.getPath());\n                        // 添加到阻塞队列中\n                        queue.put(file);\n                    } catch (InterruptedException e) {\n\n                    }\n                }\n            }\n        };\n        // submit方法提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n        exec.submit(read);\n\n        // 四个写线程\n        for (int index = 0; index < 4; index++) {\n            // write thread\n            final int num = index;\n            Runnable write = new Runnable() {\n                String threadName = \"Write\" + num;\n\n                public void run() {\n                    while (true) {\n                        try {\n                            Thread.sleep(randomTime());\n                            // 原子整型的incrementAndGet方法，以原子方式将当前值加 1，返回更新的值\n                            int index = wc.incrementAndGet();\n                            // 获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）。\n                            File file = queue.take();\n                            // 队列已经无对象\n                            if (file == exitFile) {\n                                // 再次添加\"标志\"，以让其他线程正常退出\n                                queue.put(exitFile);\n                                break;\n                                          }\n                                                            System.out.println(threadName + \": \" + index + \" \" + file.getPath());\n                                                        } catch (InterruptedException e) {\n                                                        }\n                                                    }\n                                                }\n                                \n                                            };\n                                            exec.submit(write);\n                                        }\n                                        exec.shutdown();\n                                    }\n                                \n                                }\n\n## AtomicInteger使用总结\n\nAtomicInteger是在使用非阻塞算法实现并发控制，在一些高并发程序中非常适合，但并不能每一种场景都适合，不同场景要使用使用不同的数值类。\n\n","slug":"AtomicInteger类的理解与使用","published":1,"updated":"2019-09-27T08:27:08.020Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecg0004ojfyw42l1owh","content":"<p>引用:<a href=\"https://blog.csdn.net/u012734441/article/details/51619751\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u012734441/article/details/51619751</a></p>\n<p>首先看两段代码，一段是Integer的，一段是AtomicInteger的，为以下：</p>\n<pre><code>public class Sample1 {\n\n    private static Integer count = 0;\n\n    synchronized public static void increment() {\n        count++;\n    }\n\n}</code></pre><p>以下是AtomicInteger的：</p>\n<pre><code>public class Sample2 {\n\n    private static AtomicInteger count = new AtomicInteger(0);\n\n    public static void increment() {\n        count.getAndIncrement();\n    }\n\n}</code></pre><p>对比发现:使用Integer时必须加上synchronized保证不会出现并发线程同时<br>访问的情况,而AtomicInteger中却不用加上synchronized,在这里AtomicInteger<br>是提供原子操作的.</p>\n<p>AtomicInteger是一个提供原子操作的Integer类，通过线程安全的方式操作加减。</p>\n<p>AtomicInteger使用场景</p>\n<p>AtomicInteger提供原子操作来进行Integer的使用，因此十分适合高并发情况下的使用。</p>\n<p>AtomicInteger源码部分讲解</p>\n<pre><code>public class AtomicInteger extends Number implements java.io.Serializable {\n    private static final long serialVersionUID = 6214790243416807050L;\n\n    // setup to use Unsafe.compareAndSwapInt for updates\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\n    private static final long valueOffset;\n\n    static {\n        try{\n            valueOffset = unsafe.objectFieldOffset\n                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));\n        } catch (Exception e) {\n            throw new Error(ex);\n        }\n    }\n    private volatile int value;\n\n}</code></pre><p>以上为AtomicInteger中的部分源码，在这里说下其中的value，<br>这里value使用了volatile关键字，volatile在这里可以做到的<br>作用是使得多个线程可以共享变量，但是问题在于使用volatile将<br>使得VM优化失去作用，导致效率较低，所以要在必要的时候使用，<br>因此AtomicInteger类不要随意使用，要在使用场景下使用。</p>\n<h2 id=\"AtomicInteger实例使用\"><a href=\"#AtomicInteger实例使用\" class=\"headerlink\" title=\"AtomicInteger实例使用\"></a>AtomicInteger实例使用</h2><p>以下就是在多线程情况下，使用AtomicInteger的一个实例，这段代码是借用IT宅中的一段代码。</p>\n<p> public class AtomicTest {</p>\n<pre><code>static long randomTime() {\n    return (long) (Math.random() * 1000);\n}\n\npublic static void main(String[] args) {\n    // 阻塞队列，能容纳100个文件\n    final BlockingQueue&lt;File&gt; queue = new LinkedBlockingQueue&lt;File&gt;(100);\n    // 线程池\n    final ExecutorService exec = Executors.newFixedThreadPool(5);\n    final File root = new File(&quot;D:\\\\ISO&quot;);\n    // 完成标志\n    final File exitFile = new File(&quot;&quot;);\n    // 原子整型，读个数\n    // AtomicInteger可以在并发情况下达到原子化更新，避免使用了synchronized，而且性能非常高。\n    final AtomicInteger rc = new AtomicInteger();\n    // 原子整型，写个数\n    final AtomicInteger wc = new AtomicInteger();\n    // 读线程\n    Runnable read = new Runnable() {\n        public void run() {\n            scanFile(root);\n            scanFile(exitFile);\n        }\n\n        public void scanFile(File file) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles(new FileFilter() {\n                    public boolean accept(File pathname) {\n                        return pathname.isDirectory() || pathname.getPath().endsWith(&quot;.iso&quot;);\n                    }\n                });\n                for (File one : files)\n             scanFile(one);\n            } else {\n                try {\n                    // 原子整型的incrementAndGet方法，以原子方式将当前值加 1，返回更新的值\n                    int index = rc.incrementAndGet();\n                    System.out.println(&quot;Read0: &quot; + index + &quot; &quot; + file.getPath());\n                    // 添加到阻塞队列中\n                    queue.put(file);\n                } catch (InterruptedException e) {\n\n                }\n            }\n        }\n    };\n    // submit方法提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n    exec.submit(read);\n\n    // 四个写线程\n    for (int index = 0; index &lt; 4; index++) {\n        // write thread\n        final int num = index;\n        Runnable write = new Runnable() {\n            String threadName = &quot;Write&quot; + num;\n\n            public void run() {\n                while (true) {\n                    try {\n                        Thread.sleep(randomTime());\n                        // 原子整型的incrementAndGet方法，以原子方式将当前值加 1，返回更新的值\n                        int index = wc.incrementAndGet();\n                        // 获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）。\n                        File file = queue.take();\n                        // 队列已经无对象\n                        if (file == exitFile) {\n                            // 再次添加&quot;标志&quot;，以让其他线程正常退出\n                            queue.put(exitFile);\n                            break;\n                                      }\n                                                        System.out.println(threadName + &quot;: &quot; + index + &quot; &quot; + file.getPath());\n                                                    } catch (InterruptedException e) {\n                                                    }\n                                                }\n                                            }\n\n                                        };\n                                        exec.submit(write);\n                                    }\n                                    exec.shutdown();\n                                }\n\n                            }</code></pre><h2 id=\"AtomicInteger使用总结\"><a href=\"#AtomicInteger使用总结\" class=\"headerlink\" title=\"AtomicInteger使用总结\"></a>AtomicInteger使用总结</h2><p>AtomicInteger是在使用非阻塞算法实现并发控制，在一些高并发程序中非常适合，但并不能每一种场景都适合，不同场景要使用使用不同的数值类。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>引用:<a href=\"https://blog.csdn.net/u012734441/article/details/51619751\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u012734441/article/details/51619751</a></p>\n<p>首先看两段代码，一段是Integer的，一段是AtomicInteger的，为以下：</p>\n<pre><code>public class Sample1 {\n\n    private static Integer count = 0;\n\n    synchronized public static void increment() {\n        count++;\n    }\n\n}</code></pre><p>以下是AtomicInteger的：</p>\n<pre><code>public class Sample2 {\n\n    private static AtomicInteger count = new AtomicInteger(0);\n\n    public static void increment() {\n        count.getAndIncrement();\n    }\n\n}</code></pre><p>对比发现:使用Integer时必须加上synchronized保证不会出现并发线程同时<br>访问的情况,而AtomicInteger中却不用加上synchronized,在这里AtomicInteger<br>是提供原子操作的.</p>\n<p>AtomicInteger是一个提供原子操作的Integer类，通过线程安全的方式操作加减。</p>\n<p>AtomicInteger使用场景</p>\n<p>AtomicInteger提供原子操作来进行Integer的使用，因此十分适合高并发情况下的使用。</p>\n<p>AtomicInteger源码部分讲解</p>\n<pre><code>public class AtomicInteger extends Number implements java.io.Serializable {\n    private static final long serialVersionUID = 6214790243416807050L;\n\n    // setup to use Unsafe.compareAndSwapInt for updates\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\n    private static final long valueOffset;\n\n    static {\n        try{\n            valueOffset = unsafe.objectFieldOffset\n                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));\n        } catch (Exception e) {\n            throw new Error(ex);\n        }\n    }\n    private volatile int value;\n\n}</code></pre><p>以上为AtomicInteger中的部分源码，在这里说下其中的value，<br>这里value使用了volatile关键字，volatile在这里可以做到的<br>作用是使得多个线程可以共享变量，但是问题在于使用volatile将<br>使得VM优化失去作用，导致效率较低，所以要在必要的时候使用，<br>因此AtomicInteger类不要随意使用，要在使用场景下使用。</p>\n<h2 id=\"AtomicInteger实例使用\"><a href=\"#AtomicInteger实例使用\" class=\"headerlink\" title=\"AtomicInteger实例使用\"></a>AtomicInteger实例使用</h2><p>以下就是在多线程情况下，使用AtomicInteger的一个实例，这段代码是借用IT宅中的一段代码。</p>\n<p> public class AtomicTest {</p>\n<pre><code>static long randomTime() {\n    return (long) (Math.random() * 1000);\n}\n\npublic static void main(String[] args) {\n    // 阻塞队列，能容纳100个文件\n    final BlockingQueue&lt;File&gt; queue = new LinkedBlockingQueue&lt;File&gt;(100);\n    // 线程池\n    final ExecutorService exec = Executors.newFixedThreadPool(5);\n    final File root = new File(&quot;D:\\\\ISO&quot;);\n    // 完成标志\n    final File exitFile = new File(&quot;&quot;);\n    // 原子整型，读个数\n    // AtomicInteger可以在并发情况下达到原子化更新，避免使用了synchronized，而且性能非常高。\n    final AtomicInteger rc = new AtomicInteger();\n    // 原子整型，写个数\n    final AtomicInteger wc = new AtomicInteger();\n    // 读线程\n    Runnable read = new Runnable() {\n        public void run() {\n            scanFile(root);\n            scanFile(exitFile);\n        }\n\n        public void scanFile(File file) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles(new FileFilter() {\n                    public boolean accept(File pathname) {\n                        return pathname.isDirectory() || pathname.getPath().endsWith(&quot;.iso&quot;);\n                    }\n                });\n                for (File one : files)\n             scanFile(one);\n            } else {\n                try {\n                    // 原子整型的incrementAndGet方法，以原子方式将当前值加 1，返回更新的值\n                    int index = rc.incrementAndGet();\n                    System.out.println(&quot;Read0: &quot; + index + &quot; &quot; + file.getPath());\n                    // 添加到阻塞队列中\n                    queue.put(file);\n                } catch (InterruptedException e) {\n\n                }\n            }\n        }\n    };\n    // submit方法提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n    exec.submit(read);\n\n    // 四个写线程\n    for (int index = 0; index &lt; 4; index++) {\n        // write thread\n        final int num = index;\n        Runnable write = new Runnable() {\n            String threadName = &quot;Write&quot; + num;\n\n            public void run() {\n                while (true) {\n                    try {\n                        Thread.sleep(randomTime());\n                        // 原子整型的incrementAndGet方法，以原子方式将当前值加 1，返回更新的值\n                        int index = wc.incrementAndGet();\n                        // 获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）。\n                        File file = queue.take();\n                        // 队列已经无对象\n                        if (file == exitFile) {\n                            // 再次添加&quot;标志&quot;，以让其他线程正常退出\n                            queue.put(exitFile);\n                            break;\n                                      }\n                                                        System.out.println(threadName + &quot;: &quot; + index + &quot; &quot; + file.getPath());\n                                                    } catch (InterruptedException e) {\n                                                    }\n                                                }\n                                            }\n\n                                        };\n                                        exec.submit(write);\n                                    }\n                                    exec.shutdown();\n                                }\n\n                            }</code></pre><h2 id=\"AtomicInteger使用总结\"><a href=\"#AtomicInteger使用总结\" class=\"headerlink\" title=\"AtomicInteger使用总结\"></a>AtomicInteger使用总结</h2><p>AtomicInteger是在使用非阻塞算法实现并发控制，在一些高并发程序中非常适合，但并不能每一种场景都适合，不同场景要使用使用不同的数值类。</p>\n"},{"title":"Git配置多个SSH-Key","date":"2019-09-02T08:07:26.000Z","_content":"\n# 背景\n\n当有多个git账号时，比如：\n\na. 一个gitee，用于公司内部的工作开发；\nb. 一个github，用于自己进行一些开发活动；\n    \n\n# 解决方法\n  1. 生成一个公司用的SSH-Key\n  \n    $ ssh-keygen -t rsa -C 'xxxxx@company.com' -f ~/.ssh/gitee_id_rsa\n    \n  2. 生成一个github用的SSH-Key\n  \n    $ ssh-keygen -t rsa -C 'xxxxx@qq.com' -f ~/.ssh/github_id_rsa\n    \n  3. 在 ~/.ssh 目录下新建一个config文件，添加如下内容（其中Host和HostName填写git服务器的域名，IdentityFile指定私钥的路径）\n  \n    # gitee\n    Host gitee.com\n    HostName gitee.com\n    PreferredAuthentications publickey\n    IdentityFile ~/.ssh/gitee_id_rsa\n    # github\n    Host github.com\n    HostName github.com\n    PreferredAuthentications publickey\n    IdentityFile ~/.ssh/github_id_rsa\n    \n   4.用ssh命令分别测试\n   \n    $ ssh -T git@gitee.com\n    $ ssh -T git@github.com\n\n[参考](https://gitee.com/help/articles/4229#article-header0)  \n    ","source":"_posts/Git配置多个SSH-Key.md","raw":"---\ntitle: Git配置多个SSH-Key\ndate: 2019-09-02 16:07:26\ntags: [git,ssh]\ncategories: [git]\n---\n\n# 背景\n\n当有多个git账号时，比如：\n\na. 一个gitee，用于公司内部的工作开发；\nb. 一个github，用于自己进行一些开发活动；\n    \n\n# 解决方法\n  1. 生成一个公司用的SSH-Key\n  \n    $ ssh-keygen -t rsa -C 'xxxxx@company.com' -f ~/.ssh/gitee_id_rsa\n    \n  2. 生成一个github用的SSH-Key\n  \n    $ ssh-keygen -t rsa -C 'xxxxx@qq.com' -f ~/.ssh/github_id_rsa\n    \n  3. 在 ~/.ssh 目录下新建一个config文件，添加如下内容（其中Host和HostName填写git服务器的域名，IdentityFile指定私钥的路径）\n  \n    # gitee\n    Host gitee.com\n    HostName gitee.com\n    PreferredAuthentications publickey\n    IdentityFile ~/.ssh/gitee_id_rsa\n    # github\n    Host github.com\n    HostName github.com\n    PreferredAuthentications publickey\n    IdentityFile ~/.ssh/github_id_rsa\n    \n   4.用ssh命令分别测试\n   \n    $ ssh -T git@gitee.com\n    $ ssh -T git@github.com\n\n[参考](https://gitee.com/help/articles/4229#article-header0)  \n    ","slug":"Git配置多个SSH-Key","published":1,"updated":"2019-09-27T08:27:08.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecg0005ojfywzqbt2q3","content":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>当有多个git账号时，比如：</p>\n<p>a. 一个gitee，用于公司内部的工作开发；<br>b. 一个github，用于自己进行一些开发活动；</p>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><ol>\n<li><p>生成一个公司用的SSH-Key</p>\n<p>$ ssh-keygen -t rsa -C ‘xxxxx@company.com’ -f ~/.ssh/gitee_id_rsa</p>\n</li>\n<li><p>生成一个github用的SSH-Key</p>\n<p>$ ssh-keygen -t rsa -C ‘xxxxx@qq.com’ -f ~/.ssh/github_id_rsa</p>\n</li>\n<li><p>在 ~/.ssh 目录下新建一个config文件，添加如下内容（其中Host和HostName填写git服务器的域名，IdentityFile指定私钥的路径）</p>\n<h1 id=\"gitee\"><a href=\"#gitee\" class=\"headerlink\" title=\"gitee\"></a>gitee</h1><p>Host gitee.com<br>HostName gitee.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/gitee_id_rsa</p>\n<h1 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h1><p>Host github.com<br>HostName github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/github_id_rsa</p>\n<p>4.用ssh命令分别测试</p>\n<p>$ ssh -T <a href=\"mailto:git@gitee.com\" target=\"_blank\" rel=\"noopener\">git@gitee.com</a><br>$ ssh -T <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a></p>\n</li>\n</ol>\n<p><a href=\"https://gitee.com/help/articles/4229#article-header0\" target=\"_blank\" rel=\"noopener\">参考</a>  </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>当有多个git账号时，比如：</p>\n<p>a. 一个gitee，用于公司内部的工作开发；<br>b. 一个github，用于自己进行一些开发活动；</p>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><ol>\n<li><p>生成一个公司用的SSH-Key</p>\n<p>$ ssh-keygen -t rsa -C ‘xxxxx@company.com’ -f ~/.ssh/gitee_id_rsa</p>\n</li>\n<li><p>生成一个github用的SSH-Key</p>\n<p>$ ssh-keygen -t rsa -C ‘xxxxx@qq.com’ -f ~/.ssh/github_id_rsa</p>\n</li>\n<li><p>在 ~/.ssh 目录下新建一个config文件，添加如下内容（其中Host和HostName填写git服务器的域名，IdentityFile指定私钥的路径）</p>\n<h1 id=\"gitee\"><a href=\"#gitee\" class=\"headerlink\" title=\"gitee\"></a>gitee</h1><p>Host gitee.com<br>HostName gitee.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/gitee_id_rsa</p>\n<h1 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h1><p>Host github.com<br>HostName github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/github_id_rsa</p>\n<p>4.用ssh命令分别测试</p>\n<p>$ ssh -T <a href=\"mailto:git@gitee.com\" target=\"_blank\" rel=\"noopener\">git@gitee.com</a><br>$ ssh -T <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a></p>\n</li>\n</ol>\n<p><a href=\"https://gitee.com/help/articles/4229#article-header0\" target=\"_blank\" rel=\"noopener\">参考</a>  </p>\n"},{"title":"Filter、FilterChain、FilterConfig 介绍","date":"2019-09-06T01:52:26.000Z","_content":"\n# 一、Filter 的基本工作原理\n\n* 1、Filter 程序是一个实现了特殊接口的 Java 类，与 Servlet 类似，也是由 Servlet 容器进行调用和执行的。\n\n* 2、当在 web.xml 注册了一个 Filter 来对某个 Servlet 程序进行拦截处理时，它可以决定是否将请求继续传递给 Servlet 程序，以及对请求和响应消息是否进行修改。\n\n* 3、当 Servlet 容器开始调用某个 Servlet 程序时，如果发现已经注册了一个 Filter 程序来对该 Servlet 进行拦截，那么容器不再直接调用 Servlet 的 service 方法，而是调用 Filter 的 doFilter 方法，再由 doFilter 方法决定是否去激活 service 方法。\n\n* 4、但在 Filter.doFilter 方法中不能直接调用 Servlet 的 service 方法，而是调用 FilterChain.doFilter 方法来激活目标 Servlet 的 service 方法，FilterChain 对象是通过 Filter.doFilter 方法的参数传递进来的。\n\n* 5、只要在 Filter.doFilter 方法中调用 FilterChain.doFilter 方法的语句前后增加某些程序代码，这样就可以在 Servlet 进行响应前后实现某些特殊功能。\n\n* 6、如果在 Filter.doFilter 方法中没有调用 FilterChain.doFilter 方法，则目标 Servlet 的 service 方法不会被执行，这样通过 Filter 就可以阻止某些非法的访问请求。\n![](/images/Filter的基本工作原理.png)\n# 二、Filter 链\n\n* 1、在一个 Web 应用程序中可以注册多个 Filter 程序，每个 Filter 程序都可以对一个或一组 Servlet 程序进行拦截。如果有多个 Filter 程序都可以对某个 Servlet 程序的访问过程进行拦截，当针对该 Servlet 的访问请求到达时，Web 容器将把这多个 Filter 程序组合成一个 Filter 链（也叫过滤器链）。\n\n* 2、Filter 链中的各个 Filter 的拦截顺序与它们在 web.xml 文件中的映射顺序一致，上一个 Filter.doFilter 方法中调用 FilterChain.doFilter 方法将激活下一个 Filter的doFilter 方法，最后一个 Filter.doFilter 方法中调用的 FilterChain.doFilter 方法将激活目标 Servlet的service 方法。\n\n* 3、只要 Filter 链中任意一个 Filter 没有调用 FilterChain.doFilter 方法，则目标 Servlet 的 service 方法都不会被执行。\n\n# 三、Filter 接口\n一个 Filter 程序就是一个 Java 类，这个类必须实现 Filter 接口。javax.servlet.Filter 接口中定义了三个方法：init、doFilter、destory。\n\n## 1、init 方法\n* 在 Web 应用程序启动时，Web 服务器（Web 容器）将根据其 web.xml 文件的配置信息来创建每个注册的 Filter 的实例对象，并将其保存在内存中。\n   \n* Web 容器创建 Filter 的实例对象后，将立即调用该 Filter 对象的 init 方法。init 方法在 Filter 生命周期中仅被执行一次，Web 容器在调用 init 方法时，会传递一个包含 Filter 的配置和运行环境信息的 FilterConfig 对象。\n\n\n    public voic init(FilterConfig filterConfig) throws ServletException\n\n*   开发人员可以在 init 方法中完成与构造方法类似的初始化功能，要注意的是：如果初始化代码要使用到 FilterConfig 对象，这些代码只能在 init 方法中编写，而不能在构造方法中编写（尚未调用 init 方法，即并没有创建 FilterConfig 对象，要使用它则必然出错）。\n\n## 2、doFilter 方法\n当一个 Filter 对象能够拦截访问请求时，Servlet 容器将调用 Filter 对象的 doFilter 方法。\n\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws java.io.IOException.ServletException\n其中，参数 request 和 response 为 Web 容器或 Filter 链中上一个 Filter 传递过来的请求和响应对象；参数 chain 为代表当前 Filter 链的对象。\n\n## 3、destroy 方法\n该方法在 Web 容器卸载 Filter 对象之前被调用，也仅执行一次。可以完成与 init 方法相反的功能，释放被该 Filter 对象打开的资源，例如：关闭数据库连接和 IO 流。\n\n\n# 四、FilterChain 接口\n该接口用于定义一个 Filter 链的对象应该对外提供的方法，这个接口只定义了一个 doFilter 方法。\n\npublic void doFilter(ServletRequest request, ServletResponse response) throws java.io.IOException.ServletException\n\nFilterChain 接口的 doFilter 方法用于通知 Web 容器把请求交给 Filter 链中的下一个 Filter 去处理，如果当前调用此方法的 Filter 对象是Filter 链中的最后一个 Filter，那么将把请求交给目标 Servlet 程序去处理。\n\n# 五、FilterConfig 接口\n## 1、与普通的 Servlet 程序一样，Filter 程序也很可能需要访问 Servlet 容器。Servlet 规范将代表 ServletContext 对象和 Filter 的配置参数信息都封装到一个称为 FilterConfig 的对象中。\n\n## 2、FilterConfig 接口则用于定义 FilterConfig 对象应该对外提供的方法，以便在 Filter 程序中可以调用这些方法来获取 ServletContext 对象，以及获取在 web.xml 文件中为 Filter 设置的友好名称和初始化参数。\n\n## 3、FilterConfig接口定义的各个方法：\n   \n* getFilterName 方法，返回 <filter-name> 元素的设置值。\n  \n* getServletContext 方法，返回 FilterConfig 对象中所包装的 ServletContext 对象的引用。\n  \n* getInitParameter 方法，用于返回在 web.xml 文件中为 Filter 所设置的某个名称的初始化的参数值。\n  \n* getInitParameterNames 方法，返回一个 Enumeration 集合对象。\n  \n# 六、Filter 的注册与映射\n## 1、注册 Filter\n一个 <filter> 元素用于注册一个 Filter。其中，<filter-name> 元素是必需的，<filter-class> 元素也是必需的，<init-param> 元素是可选的，可以有多个 < init-param> 元素。\n    \n    <filter>\n        <filter-name>FirstFilter</filter-name>\n        <filter-class>FirstFilter</filter-class>\n        <init-param>\n            <param-name>encoding</param-name>\n            <param-value>GB2312</param-value>\n        </init-param>\n    </filter>\n    \n## 2、映射 Filter\n    \n    <filter-mapping> 元素用于设置一个 Filter 所负责拦截的资源。一个 Filter 拦截的资源可以通过两种方式来指定：资源的访问请求路径和 Servlet 名称。\n### 第一种：指定资源的访问路径\n    \n    <filter-mapping>\n        <filter-name>FirstFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n<url-pattern> 元素中的访问路径的设置方式遵循 Servlet 的 URL 映射规范。\n\n* /*：表示拦截所有的访问请求。\n\n* /filter/*：表示拦截 filter 目录下的所有访问请求，如：http://localhost:8888/testFilter_001/filter/xxxxxx 。\n    \n* /test.html：表示拦截根目录下以 test.html 为资源名的访问请求，访问链接只会是：http://localhost:8888/test.html。\n    \n### 第二种：指定 Servlet 的名称\n\n    <filter-mapping>\n        <filter-name>FirstFilter</filter-name>\n        <servlet-name>default></servlet-name>\n        <dispatcher>INCLUDE</dispatcher>\n        <dispatcher>REQUEST</dispatcher>\n    </filter-mapping>\n    \n（1）、<servlet-name> 元素与 <url-pattern> 元素是二选一的关系，其值是某个 Servlet 在 web.xml 文件中的注册名称。\n（2）、<dispatcher> 元素的设置值有 4 种：REQUEST、INCLUDE、FORWARD、ERROR，分别对应 Servlet 容器调用资源的 4 种方式：\n\n* 通过正常的访问请求调用；\n* 通过 RequestDispatcher.include 方法调用；\n* 通过 RequestDispatcher.forward 方法调用；\n* 作为错误响应资源调用。\n如果没有设置 <dispatcher> 子元素，则等效于 REQUEST 的情况。也可以设置多个 <dispatcher> 子元素，用于指定 Filter 对资源的多种调用方式都进行拦截。\n\n# 七、Filter 程序示例\n\nFitstFilter.java\n    \n    import java.io.IOException;\n    import java.io.PrintWriter;\n    import java.util.Enumeration;\n    import javax.servlet.Filter;\n    import javax.servlet.FilterChain;\n    import javax.servlet.FilterConfig;\n    import javax.servlet.ServletException;\n    import javax.servlet.ServletRequest;\n    import javax.servlet.ServletResponse;\n    import javax.servlet.http.HttpServletRequest;\n     \n    public class FirstFilter implements Filter {\n        private FilterConfig filterConfig = null;\n        String paramValue = null;\n     \n        @Override\n        public void init(FilterConfig filterConfig) throws ServletException {\n            this.filterConfig = filterConfig;\n            paramValue = filterConfig.getInitParameter(\"encoding\");\n        }\n        \n        @Override\n        public void doFilter(ServletRequest request, ServletResponse response,\n                FilterChain chain) throws IOException, ServletException {\n            System.out.println(\"begin headers-------------------\");\n            Enumeration<?> headerNames = ((HttpServletRequest)request).getHeaderNames();\n            \n            while(headerNames.hasMoreElements()) {\n                String headerName = (String)headerNames.nextElement();\n                System.out.println(headerName + \": \" + ((HttpServletRequest)request).getHeader(headerName));\n            }\n            System.out.println(\"end headers-------------------\");\n            \n            //在调用目标前写入响应内容\n            response.setContentType(\"text/html; charset=gb2312\");\n            PrintWriter out = response.getWriter();\n            out.println(\"IP地址为：\" + request.getRemoteHost() + \"<br>\");\n     \n            chain.doFilter(request, response);\n            \n            //在目标返回后写入响应内容\n            out.println(\"<br>名称为encoding的初始化参数的值为：\" + paramValue);\n            out.println(\"<br>当前Web程序的真实路径为：\" + filterConfig.getServletContext().getRealPath(\"/\"));\n            \n            //out.println(\"<br>修改了test.html文件！\");\n        }\n        \n        @Override\n        public void destroy() {\n            this.filterConfig = null;\n        }\n    }\n\nweb.xml\n    \n    <filter>\n        <filter-name>FirstFilter</filter-name>\n        <filter-class>FirstFilter</filter-class>\n        <init-param>\n        <param-name>encoding</param-name>\n        <param-value>GB2312</param-value>\n        </init-param>\n    </filter>\n        \n    <filter-mapping>\n        <filter-name>FirstFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\ntest.html（位于WebContent路径的filter目录中）\n    \n    <html>\n    <head>\n    <meta charset=\"UTF-8\">\n    <title>Insert title here</title>\n    </head>\n    <body>\n    这就是test.html页面的原始内容！\n    </body>\n    </html>\n    \n\n[参考](https://my.oschina.net/u/1171518/blog/265467)","source":"_posts/Filter、FilterChain、FilterConfig-介绍.md","raw":"---\ntitle: Filter、FilterChain、FilterConfig 介绍\ndate: 2019-09-06 09:52:26\ntags: [java,filter]\ncategories: [java]\n---\n\n# 一、Filter 的基本工作原理\n\n* 1、Filter 程序是一个实现了特殊接口的 Java 类，与 Servlet 类似，也是由 Servlet 容器进行调用和执行的。\n\n* 2、当在 web.xml 注册了一个 Filter 来对某个 Servlet 程序进行拦截处理时，它可以决定是否将请求继续传递给 Servlet 程序，以及对请求和响应消息是否进行修改。\n\n* 3、当 Servlet 容器开始调用某个 Servlet 程序时，如果发现已经注册了一个 Filter 程序来对该 Servlet 进行拦截，那么容器不再直接调用 Servlet 的 service 方法，而是调用 Filter 的 doFilter 方法，再由 doFilter 方法决定是否去激活 service 方法。\n\n* 4、但在 Filter.doFilter 方法中不能直接调用 Servlet 的 service 方法，而是调用 FilterChain.doFilter 方法来激活目标 Servlet 的 service 方法，FilterChain 对象是通过 Filter.doFilter 方法的参数传递进来的。\n\n* 5、只要在 Filter.doFilter 方法中调用 FilterChain.doFilter 方法的语句前后增加某些程序代码，这样就可以在 Servlet 进行响应前后实现某些特殊功能。\n\n* 6、如果在 Filter.doFilter 方法中没有调用 FilterChain.doFilter 方法，则目标 Servlet 的 service 方法不会被执行，这样通过 Filter 就可以阻止某些非法的访问请求。\n![](/images/Filter的基本工作原理.png)\n# 二、Filter 链\n\n* 1、在一个 Web 应用程序中可以注册多个 Filter 程序，每个 Filter 程序都可以对一个或一组 Servlet 程序进行拦截。如果有多个 Filter 程序都可以对某个 Servlet 程序的访问过程进行拦截，当针对该 Servlet 的访问请求到达时，Web 容器将把这多个 Filter 程序组合成一个 Filter 链（也叫过滤器链）。\n\n* 2、Filter 链中的各个 Filter 的拦截顺序与它们在 web.xml 文件中的映射顺序一致，上一个 Filter.doFilter 方法中调用 FilterChain.doFilter 方法将激活下一个 Filter的doFilter 方法，最后一个 Filter.doFilter 方法中调用的 FilterChain.doFilter 方法将激活目标 Servlet的service 方法。\n\n* 3、只要 Filter 链中任意一个 Filter 没有调用 FilterChain.doFilter 方法，则目标 Servlet 的 service 方法都不会被执行。\n\n# 三、Filter 接口\n一个 Filter 程序就是一个 Java 类，这个类必须实现 Filter 接口。javax.servlet.Filter 接口中定义了三个方法：init、doFilter、destory。\n\n## 1、init 方法\n* 在 Web 应用程序启动时，Web 服务器（Web 容器）将根据其 web.xml 文件的配置信息来创建每个注册的 Filter 的实例对象，并将其保存在内存中。\n   \n* Web 容器创建 Filter 的实例对象后，将立即调用该 Filter 对象的 init 方法。init 方法在 Filter 生命周期中仅被执行一次，Web 容器在调用 init 方法时，会传递一个包含 Filter 的配置和运行环境信息的 FilterConfig 对象。\n\n\n    public voic init(FilterConfig filterConfig) throws ServletException\n\n*   开发人员可以在 init 方法中完成与构造方法类似的初始化功能，要注意的是：如果初始化代码要使用到 FilterConfig 对象，这些代码只能在 init 方法中编写，而不能在构造方法中编写（尚未调用 init 方法，即并没有创建 FilterConfig 对象，要使用它则必然出错）。\n\n## 2、doFilter 方法\n当一个 Filter 对象能够拦截访问请求时，Servlet 容器将调用 Filter 对象的 doFilter 方法。\n\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws java.io.IOException.ServletException\n其中，参数 request 和 response 为 Web 容器或 Filter 链中上一个 Filter 传递过来的请求和响应对象；参数 chain 为代表当前 Filter 链的对象。\n\n## 3、destroy 方法\n该方法在 Web 容器卸载 Filter 对象之前被调用，也仅执行一次。可以完成与 init 方法相反的功能，释放被该 Filter 对象打开的资源，例如：关闭数据库连接和 IO 流。\n\n\n# 四、FilterChain 接口\n该接口用于定义一个 Filter 链的对象应该对外提供的方法，这个接口只定义了一个 doFilter 方法。\n\npublic void doFilter(ServletRequest request, ServletResponse response) throws java.io.IOException.ServletException\n\nFilterChain 接口的 doFilter 方法用于通知 Web 容器把请求交给 Filter 链中的下一个 Filter 去处理，如果当前调用此方法的 Filter 对象是Filter 链中的最后一个 Filter，那么将把请求交给目标 Servlet 程序去处理。\n\n# 五、FilterConfig 接口\n## 1、与普通的 Servlet 程序一样，Filter 程序也很可能需要访问 Servlet 容器。Servlet 规范将代表 ServletContext 对象和 Filter 的配置参数信息都封装到一个称为 FilterConfig 的对象中。\n\n## 2、FilterConfig 接口则用于定义 FilterConfig 对象应该对外提供的方法，以便在 Filter 程序中可以调用这些方法来获取 ServletContext 对象，以及获取在 web.xml 文件中为 Filter 设置的友好名称和初始化参数。\n\n## 3、FilterConfig接口定义的各个方法：\n   \n* getFilterName 方法，返回 <filter-name> 元素的设置值。\n  \n* getServletContext 方法，返回 FilterConfig 对象中所包装的 ServletContext 对象的引用。\n  \n* getInitParameter 方法，用于返回在 web.xml 文件中为 Filter 所设置的某个名称的初始化的参数值。\n  \n* getInitParameterNames 方法，返回一个 Enumeration 集合对象。\n  \n# 六、Filter 的注册与映射\n## 1、注册 Filter\n一个 <filter> 元素用于注册一个 Filter。其中，<filter-name> 元素是必需的，<filter-class> 元素也是必需的，<init-param> 元素是可选的，可以有多个 < init-param> 元素。\n    \n    <filter>\n        <filter-name>FirstFilter</filter-name>\n        <filter-class>FirstFilter</filter-class>\n        <init-param>\n            <param-name>encoding</param-name>\n            <param-value>GB2312</param-value>\n        </init-param>\n    </filter>\n    \n## 2、映射 Filter\n    \n    <filter-mapping> 元素用于设置一个 Filter 所负责拦截的资源。一个 Filter 拦截的资源可以通过两种方式来指定：资源的访问请求路径和 Servlet 名称。\n### 第一种：指定资源的访问路径\n    \n    <filter-mapping>\n        <filter-name>FirstFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n<url-pattern> 元素中的访问路径的设置方式遵循 Servlet 的 URL 映射规范。\n\n* /*：表示拦截所有的访问请求。\n\n* /filter/*：表示拦截 filter 目录下的所有访问请求，如：http://localhost:8888/testFilter_001/filter/xxxxxx 。\n    \n* /test.html：表示拦截根目录下以 test.html 为资源名的访问请求，访问链接只会是：http://localhost:8888/test.html。\n    \n### 第二种：指定 Servlet 的名称\n\n    <filter-mapping>\n        <filter-name>FirstFilter</filter-name>\n        <servlet-name>default></servlet-name>\n        <dispatcher>INCLUDE</dispatcher>\n        <dispatcher>REQUEST</dispatcher>\n    </filter-mapping>\n    \n（1）、<servlet-name> 元素与 <url-pattern> 元素是二选一的关系，其值是某个 Servlet 在 web.xml 文件中的注册名称。\n（2）、<dispatcher> 元素的设置值有 4 种：REQUEST、INCLUDE、FORWARD、ERROR，分别对应 Servlet 容器调用资源的 4 种方式：\n\n* 通过正常的访问请求调用；\n* 通过 RequestDispatcher.include 方法调用；\n* 通过 RequestDispatcher.forward 方法调用；\n* 作为错误响应资源调用。\n如果没有设置 <dispatcher> 子元素，则等效于 REQUEST 的情况。也可以设置多个 <dispatcher> 子元素，用于指定 Filter 对资源的多种调用方式都进行拦截。\n\n# 七、Filter 程序示例\n\nFitstFilter.java\n    \n    import java.io.IOException;\n    import java.io.PrintWriter;\n    import java.util.Enumeration;\n    import javax.servlet.Filter;\n    import javax.servlet.FilterChain;\n    import javax.servlet.FilterConfig;\n    import javax.servlet.ServletException;\n    import javax.servlet.ServletRequest;\n    import javax.servlet.ServletResponse;\n    import javax.servlet.http.HttpServletRequest;\n     \n    public class FirstFilter implements Filter {\n        private FilterConfig filterConfig = null;\n        String paramValue = null;\n     \n        @Override\n        public void init(FilterConfig filterConfig) throws ServletException {\n            this.filterConfig = filterConfig;\n            paramValue = filterConfig.getInitParameter(\"encoding\");\n        }\n        \n        @Override\n        public void doFilter(ServletRequest request, ServletResponse response,\n                FilterChain chain) throws IOException, ServletException {\n            System.out.println(\"begin headers-------------------\");\n            Enumeration<?> headerNames = ((HttpServletRequest)request).getHeaderNames();\n            \n            while(headerNames.hasMoreElements()) {\n                String headerName = (String)headerNames.nextElement();\n                System.out.println(headerName + \": \" + ((HttpServletRequest)request).getHeader(headerName));\n            }\n            System.out.println(\"end headers-------------------\");\n            \n            //在调用目标前写入响应内容\n            response.setContentType(\"text/html; charset=gb2312\");\n            PrintWriter out = response.getWriter();\n            out.println(\"IP地址为：\" + request.getRemoteHost() + \"<br>\");\n     \n            chain.doFilter(request, response);\n            \n            //在目标返回后写入响应内容\n            out.println(\"<br>名称为encoding的初始化参数的值为：\" + paramValue);\n            out.println(\"<br>当前Web程序的真实路径为：\" + filterConfig.getServletContext().getRealPath(\"/\"));\n            \n            //out.println(\"<br>修改了test.html文件！\");\n        }\n        \n        @Override\n        public void destroy() {\n            this.filterConfig = null;\n        }\n    }\n\nweb.xml\n    \n    <filter>\n        <filter-name>FirstFilter</filter-name>\n        <filter-class>FirstFilter</filter-class>\n        <init-param>\n        <param-name>encoding</param-name>\n        <param-value>GB2312</param-value>\n        </init-param>\n    </filter>\n        \n    <filter-mapping>\n        <filter-name>FirstFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\ntest.html（位于WebContent路径的filter目录中）\n    \n    <html>\n    <head>\n    <meta charset=\"UTF-8\">\n    <title>Insert title here</title>\n    </head>\n    <body>\n    这就是test.html页面的原始内容！\n    </body>\n    </html>\n    \n\n[参考](https://my.oschina.net/u/1171518/blog/265467)","slug":"Filter、FilterChain、FilterConfig-介绍","published":1,"updated":"2019-09-27T08:27:08.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cech0006ojfy92gxajyd","content":"<h1 id=\"一、Filter-的基本工作原理\"><a href=\"#一、Filter-的基本工作原理\" class=\"headerlink\" title=\"一、Filter 的基本工作原理\"></a>一、Filter 的基本工作原理</h1><ul>\n<li><p>1、Filter 程序是一个实现了特殊接口的 Java 类，与 Servlet 类似，也是由 Servlet 容器进行调用和执行的。</p>\n</li>\n<li><p>2、当在 web.xml 注册了一个 Filter 来对某个 Servlet 程序进行拦截处理时，它可以决定是否将请求继续传递给 Servlet 程序，以及对请求和响应消息是否进行修改。</p>\n</li>\n<li><p>3、当 Servlet 容器开始调用某个 Servlet 程序时，如果发现已经注册了一个 Filter 程序来对该 Servlet 进行拦截，那么容器不再直接调用 Servlet 的 service 方法，而是调用 Filter 的 doFilter 方法，再由 doFilter 方法决定是否去激活 service 方法。</p>\n</li>\n<li><p>4、但在 Filter.doFilter 方法中不能直接调用 Servlet 的 service 方法，而是调用 FilterChain.doFilter 方法来激活目标 Servlet 的 service 方法，FilterChain 对象是通过 Filter.doFilter 方法的参数传递进来的。</p>\n</li>\n<li><p>5、只要在 Filter.doFilter 方法中调用 FilterChain.doFilter 方法的语句前后增加某些程序代码，这样就可以在 Servlet 进行响应前后实现某些特殊功能。</p>\n</li>\n<li><p>6、如果在 Filter.doFilter 方法中没有调用 FilterChain.doFilter 方法，则目标 Servlet 的 service 方法不会被执行，这样通过 Filter 就可以阻止某些非法的访问请求。<br><img src=\"/images/Filter%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png\" alt></p>\n<h1 id=\"二、Filter-链\"><a href=\"#二、Filter-链\" class=\"headerlink\" title=\"二、Filter 链\"></a>二、Filter 链</h1></li>\n<li><p>1、在一个 Web 应用程序中可以注册多个 Filter 程序，每个 Filter 程序都可以对一个或一组 Servlet 程序进行拦截。如果有多个 Filter 程序都可以对某个 Servlet 程序的访问过程进行拦截，当针对该 Servlet 的访问请求到达时，Web 容器将把这多个 Filter 程序组合成一个 Filter 链（也叫过滤器链）。</p>\n</li>\n<li><p>2、Filter 链中的各个 Filter 的拦截顺序与它们在 web.xml 文件中的映射顺序一致，上一个 Filter.doFilter 方法中调用 FilterChain.doFilter 方法将激活下一个 Filter的doFilter 方法，最后一个 Filter.doFilter 方法中调用的 FilterChain.doFilter 方法将激活目标 Servlet的service 方法。</p>\n</li>\n<li><p>3、只要 Filter 链中任意一个 Filter 没有调用 FilterChain.doFilter 方法，则目标 Servlet 的 service 方法都不会被执行。</p>\n</li>\n</ul>\n<h1 id=\"三、Filter-接口\"><a href=\"#三、Filter-接口\" class=\"headerlink\" title=\"三、Filter 接口\"></a>三、Filter 接口</h1><p>一个 Filter 程序就是一个 Java 类，这个类必须实现 Filter 接口。javax.servlet.Filter 接口中定义了三个方法：init、doFilter、destory。</p>\n<h2 id=\"1、init-方法\"><a href=\"#1、init-方法\" class=\"headerlink\" title=\"1、init 方法\"></a>1、init 方法</h2><ul>\n<li><p>在 Web 应用程序启动时，Web 服务器（Web 容器）将根据其 web.xml 文件的配置信息来创建每个注册的 Filter 的实例对象，并将其保存在内存中。</p>\n</li>\n<li><p>Web 容器创建 Filter 的实例对象后，将立即调用该 Filter 对象的 init 方法。init 方法在 Filter 生命周期中仅被执行一次，Web 容器在调用 init 方法时，会传递一个包含 Filter 的配置和运行环境信息的 FilterConfig 对象。</p>\n</li>\n</ul>\n<pre><code>public voic init(FilterConfig filterConfig) throws ServletException</code></pre><ul>\n<li>开发人员可以在 init 方法中完成与构造方法类似的初始化功能，要注意的是：如果初始化代码要使用到 FilterConfig 对象，这些代码只能在 init 方法中编写，而不能在构造方法中编写（尚未调用 init 方法，即并没有创建 FilterConfig 对象，要使用它则必然出错）。</li>\n</ul>\n<h2 id=\"2、doFilter-方法\"><a href=\"#2、doFilter-方法\" class=\"headerlink\" title=\"2、doFilter 方法\"></a>2、doFilter 方法</h2><p>当一个 Filter 对象能够拦截访问请求时，Servlet 容器将调用 Filter 对象的 doFilter 方法。</p>\n<pre><code>public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws java.io.IOException.ServletException</code></pre><p>其中，参数 request 和 response 为 Web 容器或 Filter 链中上一个 Filter 传递过来的请求和响应对象；参数 chain 为代表当前 Filter 链的对象。</p>\n<h2 id=\"3、destroy-方法\"><a href=\"#3、destroy-方法\" class=\"headerlink\" title=\"3、destroy 方法\"></a>3、destroy 方法</h2><p>该方法在 Web 容器卸载 Filter 对象之前被调用，也仅执行一次。可以完成与 init 方法相反的功能，释放被该 Filter 对象打开的资源，例如：关闭数据库连接和 IO 流。</p>\n<h1 id=\"四、FilterChain-接口\"><a href=\"#四、FilterChain-接口\" class=\"headerlink\" title=\"四、FilterChain 接口\"></a>四、FilterChain 接口</h1><p>该接口用于定义一个 Filter 链的对象应该对外提供的方法，这个接口只定义了一个 doFilter 方法。</p>\n<p>public void doFilter(ServletRequest request, ServletResponse response) throws java.io.IOException.ServletException</p>\n<p>FilterChain 接口的 doFilter 方法用于通知 Web 容器把请求交给 Filter 链中的下一个 Filter 去处理，如果当前调用此方法的 Filter 对象是Filter 链中的最后一个 Filter，那么将把请求交给目标 Servlet 程序去处理。</p>\n<h1 id=\"五、FilterConfig-接口\"><a href=\"#五、FilterConfig-接口\" class=\"headerlink\" title=\"五、FilterConfig 接口\"></a>五、FilterConfig 接口</h1><h2 id=\"1、与普通的-Servlet-程序一样，Filter-程序也很可能需要访问-Servlet-容器。Servlet-规范将代表-ServletContext-对象和-Filter-的配置参数信息都封装到一个称为-FilterConfig-的对象中。\"><a href=\"#1、与普通的-Servlet-程序一样，Filter-程序也很可能需要访问-Servlet-容器。Servlet-规范将代表-ServletContext-对象和-Filter-的配置参数信息都封装到一个称为-FilterConfig-的对象中。\" class=\"headerlink\" title=\"1、与普通的 Servlet 程序一样，Filter 程序也很可能需要访问 Servlet 容器。Servlet 规范将代表 ServletContext 对象和 Filter 的配置参数信息都封装到一个称为 FilterConfig 的对象中。\"></a>1、与普通的 Servlet 程序一样，Filter 程序也很可能需要访问 Servlet 容器。Servlet 规范将代表 ServletContext 对象和 Filter 的配置参数信息都封装到一个称为 FilterConfig 的对象中。</h2><h2 id=\"2、FilterConfig-接口则用于定义-FilterConfig-对象应该对外提供的方法，以便在-Filter-程序中可以调用这些方法来获取-ServletContext-对象，以及获取在-web-xml-文件中为-Filter-设置的友好名称和初始化参数。\"><a href=\"#2、FilterConfig-接口则用于定义-FilterConfig-对象应该对外提供的方法，以便在-Filter-程序中可以调用这些方法来获取-ServletContext-对象，以及获取在-web-xml-文件中为-Filter-设置的友好名称和初始化参数。\" class=\"headerlink\" title=\"2、FilterConfig 接口则用于定义 FilterConfig 对象应该对外提供的方法，以便在 Filter 程序中可以调用这些方法来获取 ServletContext 对象，以及获取在 web.xml 文件中为 Filter 设置的友好名称和初始化参数。\"></a>2、FilterConfig 接口则用于定义 FilterConfig 对象应该对外提供的方法，以便在 Filter 程序中可以调用这些方法来获取 ServletContext 对象，以及获取在 web.xml 文件中为 Filter 设置的友好名称和初始化参数。</h2><h2 id=\"3、FilterConfig接口定义的各个方法：\"><a href=\"#3、FilterConfig接口定义的各个方法：\" class=\"headerlink\" title=\"3、FilterConfig接口定义的各个方法：\"></a>3、FilterConfig接口定义的各个方法：</h2><ul>\n<li><p>getFilterName 方法，返回 <filter-name> 元素的设置值。</filter-name></p>\n</li>\n<li><p>getServletContext 方法，返回 FilterConfig 对象中所包装的 ServletContext 对象的引用。</p>\n</li>\n<li><p>getInitParameter 方法，用于返回在 web.xml 文件中为 Filter 所设置的某个名称的初始化的参数值。</p>\n</li>\n<li><p>getInitParameterNames 方法，返回一个 Enumeration 集合对象。</p>\n</li>\n</ul>\n<h1 id=\"六、Filter-的注册与映射\"><a href=\"#六、Filter-的注册与映射\" class=\"headerlink\" title=\"六、Filter 的注册与映射\"></a>六、Filter 的注册与映射</h1><h2 id=\"1、注册-Filter\"><a href=\"#1、注册-Filter\" class=\"headerlink\" title=\"1、注册 Filter\"></a>1、注册 Filter</h2><p>一个 <filter> 元素用于注册一个 Filter。其中，<filter-name> 元素是必需的，<filter-class> 元素也是必需的，<init-param> 元素是可选的，可以有多个 &lt; init-param&gt; 元素。</init-param></filter-class></filter-name></filter></p>\n<pre><code>&lt;filter&gt;\n    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;\n    &lt;filter-class&gt;FirstFilter&lt;/filter-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;encoding&lt;/param-name&gt;\n        &lt;param-value&gt;GB2312&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/filter&gt;</code></pre><h2 id=\"2、映射-Filter\"><a href=\"#2、映射-Filter\" class=\"headerlink\" title=\"2、映射 Filter\"></a>2、映射 Filter</h2><pre><code>&lt;filter-mapping&gt; 元素用于设置一个 Filter 所负责拦截的资源。一个 Filter 拦截的资源可以通过两种方式来指定：资源的访问请求路径和 Servlet 名称。</code></pre><h3 id=\"第一种：指定资源的访问路径\"><a href=\"#第一种：指定资源的访问路径\" class=\"headerlink\" title=\"第一种：指定资源的访问路径\"></a>第一种：指定资源的访问路径</h3><pre><code>&lt;filter-mapping&gt;\n    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;\n    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&lt;/filter-mapping&gt;</code></pre><p><url-pattern> 元素中的访问路径的设置方式遵循 Servlet 的 URL 映射规范。</url-pattern></p>\n<ul>\n<li><p>/*：表示拦截所有的访问请求。</p>\n</li>\n<li><p>/filter/*：表示拦截 filter 目录下的所有访问请求，如：<a href=\"http://localhost:8888/testFilter_001/filter/xxxxxx\" target=\"_blank\" rel=\"noopener\">http://localhost:8888/testFilter_001/filter/xxxxxx</a> 。</p>\n</li>\n<li><p>/test.html：表示拦截根目录下以 test.html 为资源名的访问请求，访问链接只会是：<a href=\"http://localhost:8888/test.html。\" target=\"_blank\" rel=\"noopener\">http://localhost:8888/test.html。</a></p>\n</li>\n</ul>\n<h3 id=\"第二种：指定-Servlet-的名称\"><a href=\"#第二种：指定-Servlet-的名称\" class=\"headerlink\" title=\"第二种：指定 Servlet 的名称\"></a>第二种：指定 Servlet 的名称</h3><pre><code>&lt;filter-mapping&gt;\n    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;\n    &lt;servlet-name&gt;default&gt;&lt;/servlet-name&gt;\n    &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;\n    &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;\n&lt;/filter-mapping&gt;</code></pre><p>（1）、<servlet-name> 元素与 <url-pattern> 元素是二选一的关系，其值是某个 Servlet 在 web.xml 文件中的注册名称。<br>（2）、<dispatcher> 元素的设置值有 4 种：REQUEST、INCLUDE、FORWARD、ERROR，分别对应 Servlet 容器调用资源的 4 种方式：</dispatcher></url-pattern></servlet-name></p>\n<ul>\n<li>通过正常的访问请求调用；</li>\n<li>通过 RequestDispatcher.include 方法调用；</li>\n<li>通过 RequestDispatcher.forward 方法调用；</li>\n<li>作为错误响应资源调用。<br>如果没有设置 <dispatcher> 子元素，则等效于 REQUEST 的情况。也可以设置多个 <dispatcher> 子元素，用于指定 Filter 对资源的多种调用方式都进行拦截。</dispatcher></dispatcher></li>\n</ul>\n<h1 id=\"七、Filter-程序示例\"><a href=\"#七、Filter-程序示例\" class=\"headerlink\" title=\"七、Filter 程序示例\"></a>七、Filter 程序示例</h1><p>FitstFilter.java</p>\n<pre><code>import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Enumeration;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\n\npublic class FirstFilter implements Filter {\n    private FilterConfig filterConfig = null;\n    String paramValue = null;\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        this.filterConfig = filterConfig;\n        paramValue = filterConfig.getInitParameter(&quot;encoding&quot;);\n    }\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response,\n            FilterChain chain) throws IOException, ServletException {\n        System.out.println(&quot;begin headers-------------------&quot;);\n        Enumeration&lt;?&gt; headerNames = ((HttpServletRequest)request).getHeaderNames();\n\n        while(headerNames.hasMoreElements()) {\n            String headerName = (String)headerNames.nextElement();\n            System.out.println(headerName + &quot;: &quot; + ((HttpServletRequest)request).getHeader(headerName));\n        }\n        System.out.println(&quot;end headers-------------------&quot;);\n\n        //在调用目标前写入响应内容\n        response.setContentType(&quot;text/html; charset=gb2312&quot;);\n        PrintWriter out = response.getWriter();\n        out.println(&quot;IP地址为：&quot; + request.getRemoteHost() + &quot;&lt;br&gt;&quot;);\n\n        chain.doFilter(request, response);\n\n        //在目标返回后写入响应内容\n        out.println(&quot;&lt;br&gt;名称为encoding的初始化参数的值为：&quot; + paramValue);\n        out.println(&quot;&lt;br&gt;当前Web程序的真实路径为：&quot; + filterConfig.getServletContext().getRealPath(&quot;/&quot;));\n\n        //out.println(&quot;&lt;br&gt;修改了test.html文件！&quot;);\n    }\n\n    @Override\n    public void destroy() {\n        this.filterConfig = null;\n    }\n}</code></pre><p>web.xml</p>\n<pre><code>&lt;filter&gt;\n    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;\n    &lt;filter-class&gt;FirstFilter&lt;/filter-class&gt;\n    &lt;init-param&gt;\n    &lt;param-name&gt;encoding&lt;/param-name&gt;\n    &lt;param-value&gt;GB2312&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/filter&gt;\n\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;\n    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&lt;/filter-mapping&gt;</code></pre><p>test.html（位于WebContent路径的filter目录中）</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;title&gt;Insert title here&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n这就是test.html页面的原始内容！\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><p><a href=\"https://my.oschina.net/u/1171518/blog/265467\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、Filter-的基本工作原理\"><a href=\"#一、Filter-的基本工作原理\" class=\"headerlink\" title=\"一、Filter 的基本工作原理\"></a>一、Filter 的基本工作原理</h1><ul>\n<li><p>1、Filter 程序是一个实现了特殊接口的 Java 类，与 Servlet 类似，也是由 Servlet 容器进行调用和执行的。</p>\n</li>\n<li><p>2、当在 web.xml 注册了一个 Filter 来对某个 Servlet 程序进行拦截处理时，它可以决定是否将请求继续传递给 Servlet 程序，以及对请求和响应消息是否进行修改。</p>\n</li>\n<li><p>3、当 Servlet 容器开始调用某个 Servlet 程序时，如果发现已经注册了一个 Filter 程序来对该 Servlet 进行拦截，那么容器不再直接调用 Servlet 的 service 方法，而是调用 Filter 的 doFilter 方法，再由 doFilter 方法决定是否去激活 service 方法。</p>\n</li>\n<li><p>4、但在 Filter.doFilter 方法中不能直接调用 Servlet 的 service 方法，而是调用 FilterChain.doFilter 方法来激活目标 Servlet 的 service 方法，FilterChain 对象是通过 Filter.doFilter 方法的参数传递进来的。</p>\n</li>\n<li><p>5、只要在 Filter.doFilter 方法中调用 FilterChain.doFilter 方法的语句前后增加某些程序代码，这样就可以在 Servlet 进行响应前后实现某些特殊功能。</p>\n</li>\n<li><p>6、如果在 Filter.doFilter 方法中没有调用 FilterChain.doFilter 方法，则目标 Servlet 的 service 方法不会被执行，这样通过 Filter 就可以阻止某些非法的访问请求。<br><img src=\"/images/Filter%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png\" alt></p>\n<h1 id=\"二、Filter-链\"><a href=\"#二、Filter-链\" class=\"headerlink\" title=\"二、Filter 链\"></a>二、Filter 链</h1></li>\n<li><p>1、在一个 Web 应用程序中可以注册多个 Filter 程序，每个 Filter 程序都可以对一个或一组 Servlet 程序进行拦截。如果有多个 Filter 程序都可以对某个 Servlet 程序的访问过程进行拦截，当针对该 Servlet 的访问请求到达时，Web 容器将把这多个 Filter 程序组合成一个 Filter 链（也叫过滤器链）。</p>\n</li>\n<li><p>2、Filter 链中的各个 Filter 的拦截顺序与它们在 web.xml 文件中的映射顺序一致，上一个 Filter.doFilter 方法中调用 FilterChain.doFilter 方法将激活下一个 Filter的doFilter 方法，最后一个 Filter.doFilter 方法中调用的 FilterChain.doFilter 方法将激活目标 Servlet的service 方法。</p>\n</li>\n<li><p>3、只要 Filter 链中任意一个 Filter 没有调用 FilterChain.doFilter 方法，则目标 Servlet 的 service 方法都不会被执行。</p>\n</li>\n</ul>\n<h1 id=\"三、Filter-接口\"><a href=\"#三、Filter-接口\" class=\"headerlink\" title=\"三、Filter 接口\"></a>三、Filter 接口</h1><p>一个 Filter 程序就是一个 Java 类，这个类必须实现 Filter 接口。javax.servlet.Filter 接口中定义了三个方法：init、doFilter、destory。</p>\n<h2 id=\"1、init-方法\"><a href=\"#1、init-方法\" class=\"headerlink\" title=\"1、init 方法\"></a>1、init 方法</h2><ul>\n<li><p>在 Web 应用程序启动时，Web 服务器（Web 容器）将根据其 web.xml 文件的配置信息来创建每个注册的 Filter 的实例对象，并将其保存在内存中。</p>\n</li>\n<li><p>Web 容器创建 Filter 的实例对象后，将立即调用该 Filter 对象的 init 方法。init 方法在 Filter 生命周期中仅被执行一次，Web 容器在调用 init 方法时，会传递一个包含 Filter 的配置和运行环境信息的 FilterConfig 对象。</p>\n</li>\n</ul>\n<pre><code>public voic init(FilterConfig filterConfig) throws ServletException</code></pre><ul>\n<li>开发人员可以在 init 方法中完成与构造方法类似的初始化功能，要注意的是：如果初始化代码要使用到 FilterConfig 对象，这些代码只能在 init 方法中编写，而不能在构造方法中编写（尚未调用 init 方法，即并没有创建 FilterConfig 对象，要使用它则必然出错）。</li>\n</ul>\n<h2 id=\"2、doFilter-方法\"><a href=\"#2、doFilter-方法\" class=\"headerlink\" title=\"2、doFilter 方法\"></a>2、doFilter 方法</h2><p>当一个 Filter 对象能够拦截访问请求时，Servlet 容器将调用 Filter 对象的 doFilter 方法。</p>\n<pre><code>public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws java.io.IOException.ServletException</code></pre><p>其中，参数 request 和 response 为 Web 容器或 Filter 链中上一个 Filter 传递过来的请求和响应对象；参数 chain 为代表当前 Filter 链的对象。</p>\n<h2 id=\"3、destroy-方法\"><a href=\"#3、destroy-方法\" class=\"headerlink\" title=\"3、destroy 方法\"></a>3、destroy 方法</h2><p>该方法在 Web 容器卸载 Filter 对象之前被调用，也仅执行一次。可以完成与 init 方法相反的功能，释放被该 Filter 对象打开的资源，例如：关闭数据库连接和 IO 流。</p>\n<h1 id=\"四、FilterChain-接口\"><a href=\"#四、FilterChain-接口\" class=\"headerlink\" title=\"四、FilterChain 接口\"></a>四、FilterChain 接口</h1><p>该接口用于定义一个 Filter 链的对象应该对外提供的方法，这个接口只定义了一个 doFilter 方法。</p>\n<p>public void doFilter(ServletRequest request, ServletResponse response) throws java.io.IOException.ServletException</p>\n<p>FilterChain 接口的 doFilter 方法用于通知 Web 容器把请求交给 Filter 链中的下一个 Filter 去处理，如果当前调用此方法的 Filter 对象是Filter 链中的最后一个 Filter，那么将把请求交给目标 Servlet 程序去处理。</p>\n<h1 id=\"五、FilterConfig-接口\"><a href=\"#五、FilterConfig-接口\" class=\"headerlink\" title=\"五、FilterConfig 接口\"></a>五、FilterConfig 接口</h1><h2 id=\"1、与普通的-Servlet-程序一样，Filter-程序也很可能需要访问-Servlet-容器。Servlet-规范将代表-ServletContext-对象和-Filter-的配置参数信息都封装到一个称为-FilterConfig-的对象中。\"><a href=\"#1、与普通的-Servlet-程序一样，Filter-程序也很可能需要访问-Servlet-容器。Servlet-规范将代表-ServletContext-对象和-Filter-的配置参数信息都封装到一个称为-FilterConfig-的对象中。\" class=\"headerlink\" title=\"1、与普通的 Servlet 程序一样，Filter 程序也很可能需要访问 Servlet 容器。Servlet 规范将代表 ServletContext 对象和 Filter 的配置参数信息都封装到一个称为 FilterConfig 的对象中。\"></a>1、与普通的 Servlet 程序一样，Filter 程序也很可能需要访问 Servlet 容器。Servlet 规范将代表 ServletContext 对象和 Filter 的配置参数信息都封装到一个称为 FilterConfig 的对象中。</h2><h2 id=\"2、FilterConfig-接口则用于定义-FilterConfig-对象应该对外提供的方法，以便在-Filter-程序中可以调用这些方法来获取-ServletContext-对象，以及获取在-web-xml-文件中为-Filter-设置的友好名称和初始化参数。\"><a href=\"#2、FilterConfig-接口则用于定义-FilterConfig-对象应该对外提供的方法，以便在-Filter-程序中可以调用这些方法来获取-ServletContext-对象，以及获取在-web-xml-文件中为-Filter-设置的友好名称和初始化参数。\" class=\"headerlink\" title=\"2、FilterConfig 接口则用于定义 FilterConfig 对象应该对外提供的方法，以便在 Filter 程序中可以调用这些方法来获取 ServletContext 对象，以及获取在 web.xml 文件中为 Filter 设置的友好名称和初始化参数。\"></a>2、FilterConfig 接口则用于定义 FilterConfig 对象应该对外提供的方法，以便在 Filter 程序中可以调用这些方法来获取 ServletContext 对象，以及获取在 web.xml 文件中为 Filter 设置的友好名称和初始化参数。</h2><h2 id=\"3、FilterConfig接口定义的各个方法：\"><a href=\"#3、FilterConfig接口定义的各个方法：\" class=\"headerlink\" title=\"3、FilterConfig接口定义的各个方法：\"></a>3、FilterConfig接口定义的各个方法：</h2><ul>\n<li><p>getFilterName 方法，返回 <filter-name> 元素的设置值。</filter-name></p>\n</li>\n<li><p>getServletContext 方法，返回 FilterConfig 对象中所包装的 ServletContext 对象的引用。</p>\n</li>\n<li><p>getInitParameter 方法，用于返回在 web.xml 文件中为 Filter 所设置的某个名称的初始化的参数值。</p>\n</li>\n<li><p>getInitParameterNames 方法，返回一个 Enumeration 集合对象。</p>\n</li>\n</ul>\n<h1 id=\"六、Filter-的注册与映射\"><a href=\"#六、Filter-的注册与映射\" class=\"headerlink\" title=\"六、Filter 的注册与映射\"></a>六、Filter 的注册与映射</h1><h2 id=\"1、注册-Filter\"><a href=\"#1、注册-Filter\" class=\"headerlink\" title=\"1、注册 Filter\"></a>1、注册 Filter</h2><p>一个 <filter> 元素用于注册一个 Filter。其中，<filter-name> 元素是必需的，<filter-class> 元素也是必需的，<init-param> 元素是可选的，可以有多个 &lt; init-param&gt; 元素。</init-param></filter-class></filter-name></filter></p>\n<pre><code>&lt;filter&gt;\n    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;\n    &lt;filter-class&gt;FirstFilter&lt;/filter-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;encoding&lt;/param-name&gt;\n        &lt;param-value&gt;GB2312&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/filter&gt;</code></pre><h2 id=\"2、映射-Filter\"><a href=\"#2、映射-Filter\" class=\"headerlink\" title=\"2、映射 Filter\"></a>2、映射 Filter</h2><pre><code>&lt;filter-mapping&gt; 元素用于设置一个 Filter 所负责拦截的资源。一个 Filter 拦截的资源可以通过两种方式来指定：资源的访问请求路径和 Servlet 名称。</code></pre><h3 id=\"第一种：指定资源的访问路径\"><a href=\"#第一种：指定资源的访问路径\" class=\"headerlink\" title=\"第一种：指定资源的访问路径\"></a>第一种：指定资源的访问路径</h3><pre><code>&lt;filter-mapping&gt;\n    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;\n    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&lt;/filter-mapping&gt;</code></pre><p><url-pattern> 元素中的访问路径的设置方式遵循 Servlet 的 URL 映射规范。</url-pattern></p>\n<ul>\n<li><p>/*：表示拦截所有的访问请求。</p>\n</li>\n<li><p>/filter/*：表示拦截 filter 目录下的所有访问请求，如：<a href=\"http://localhost:8888/testFilter_001/filter/xxxxxx\" target=\"_blank\" rel=\"noopener\">http://localhost:8888/testFilter_001/filter/xxxxxx</a> 。</p>\n</li>\n<li><p>/test.html：表示拦截根目录下以 test.html 为资源名的访问请求，访问链接只会是：<a href=\"http://localhost:8888/test.html。\" target=\"_blank\" rel=\"noopener\">http://localhost:8888/test.html。</a></p>\n</li>\n</ul>\n<h3 id=\"第二种：指定-Servlet-的名称\"><a href=\"#第二种：指定-Servlet-的名称\" class=\"headerlink\" title=\"第二种：指定 Servlet 的名称\"></a>第二种：指定 Servlet 的名称</h3><pre><code>&lt;filter-mapping&gt;\n    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;\n    &lt;servlet-name&gt;default&gt;&lt;/servlet-name&gt;\n    &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;\n    &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;\n&lt;/filter-mapping&gt;</code></pre><p>（1）、<servlet-name> 元素与 <url-pattern> 元素是二选一的关系，其值是某个 Servlet 在 web.xml 文件中的注册名称。<br>（2）、<dispatcher> 元素的设置值有 4 种：REQUEST、INCLUDE、FORWARD、ERROR，分别对应 Servlet 容器调用资源的 4 种方式：</dispatcher></url-pattern></servlet-name></p>\n<ul>\n<li>通过正常的访问请求调用；</li>\n<li>通过 RequestDispatcher.include 方法调用；</li>\n<li>通过 RequestDispatcher.forward 方法调用；</li>\n<li>作为错误响应资源调用。<br>如果没有设置 <dispatcher> 子元素，则等效于 REQUEST 的情况。也可以设置多个 <dispatcher> 子元素，用于指定 Filter 对资源的多种调用方式都进行拦截。</dispatcher></dispatcher></li>\n</ul>\n<h1 id=\"七、Filter-程序示例\"><a href=\"#七、Filter-程序示例\" class=\"headerlink\" title=\"七、Filter 程序示例\"></a>七、Filter 程序示例</h1><p>FitstFilter.java</p>\n<pre><code>import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Enumeration;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\n\npublic class FirstFilter implements Filter {\n    private FilterConfig filterConfig = null;\n    String paramValue = null;\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        this.filterConfig = filterConfig;\n        paramValue = filterConfig.getInitParameter(&quot;encoding&quot;);\n    }\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response,\n            FilterChain chain) throws IOException, ServletException {\n        System.out.println(&quot;begin headers-------------------&quot;);\n        Enumeration&lt;?&gt; headerNames = ((HttpServletRequest)request).getHeaderNames();\n\n        while(headerNames.hasMoreElements()) {\n            String headerName = (String)headerNames.nextElement();\n            System.out.println(headerName + &quot;: &quot; + ((HttpServletRequest)request).getHeader(headerName));\n        }\n        System.out.println(&quot;end headers-------------------&quot;);\n\n        //在调用目标前写入响应内容\n        response.setContentType(&quot;text/html; charset=gb2312&quot;);\n        PrintWriter out = response.getWriter();\n        out.println(&quot;IP地址为：&quot; + request.getRemoteHost() + &quot;&lt;br&gt;&quot;);\n\n        chain.doFilter(request, response);\n\n        //在目标返回后写入响应内容\n        out.println(&quot;&lt;br&gt;名称为encoding的初始化参数的值为：&quot; + paramValue);\n        out.println(&quot;&lt;br&gt;当前Web程序的真实路径为：&quot; + filterConfig.getServletContext().getRealPath(&quot;/&quot;));\n\n        //out.println(&quot;&lt;br&gt;修改了test.html文件！&quot;);\n    }\n\n    @Override\n    public void destroy() {\n        this.filterConfig = null;\n    }\n}</code></pre><p>web.xml</p>\n<pre><code>&lt;filter&gt;\n    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;\n    &lt;filter-class&gt;FirstFilter&lt;/filter-class&gt;\n    &lt;init-param&gt;\n    &lt;param-name&gt;encoding&lt;/param-name&gt;\n    &lt;param-value&gt;GB2312&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/filter&gt;\n\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;\n    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&lt;/filter-mapping&gt;</code></pre><p>test.html（位于WebContent路径的filter目录中）</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;title&gt;Insert title here&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n这就是test.html页面的原始内容！\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><p><a href=\"https://my.oschina.net/u/1171518/blog/265467\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n"},{"title":"IntelliJ IDEA开发快捷键(IDEA tool Keyboard shutcuts)","date":"2018-07-04T01:46:52.000Z","_content":"\nIDEA tool Keyboard shutcuts：\n\n| Action | Mac OSX | Win/Linux|\n| :-- | :-- | :-- |\n| 注释代码(//) | Cmd + / | Ctrl + / | \n| 注释代码(/**/) | Cmd + Option + / | Ctrl + Shift + / | \n| 格式化代码 | Cmd + Option + L | Ctrl + Alt + L | \n| 清除无效包引用 | Option + Control + O | Alt + Ctrl + O | \n| 查找 | Cmd + F | Ctrl + F | \n| 查找+替换 | Cmd + R | Ctrl + R | \n| 上下移动代码 | Option + Shift + Up/Down | Alt + Shift + Up/Down | \n| 删除行 | Cmd + Delete | Ctrl + Y | \n| 扩大缩小选中范围 | Option + Up/Down| Ctrl + W/Ctrl + Shift + W |\n| 快捷生成结构体 | Cmd + Option + T | Ctrl + Alt + T |\n| 快捷覆写方法 | Cmd + O | Ctrl + O |\n| 快捷定位到行首/尾 | Cmd + Left/Right | Ctrl + Left/Right |\n| 折叠展开代码块 | Cmd + Plus,Minus | Ctrl + Plus/Minus |\n| 折叠展开全部代码块 | Cmd + Shift + Plus,Minus | Ctrl + Shift + Plus,Minus |\n| 文件方法结构 | Cmd + F12 | Ctrl + F12 |\n| 查找调用的位置 | Ctrl + Option + H | Ctrl + Alt + H |\n| 大小写转换 | Cmd + Shift + U | Ctrl + Shift + U |\n| 找到使用 | Alt+F7 | Alt+F7 |\n| 显示使用 | Ctrl+Alt+F7 | Ctrl+Alt+F7 |\n\n","source":"_posts/IntelliJ-IDEA开发快捷键-IDEA-tool-Keyboard-shutcuts.md","raw":"---\ntitle: IntelliJ IDEA开发快捷键(IDEA tool Keyboard shutcuts)\ndate: 2018-07-04 09:46:52\ntags: [idea,快捷键]\n---\n\nIDEA tool Keyboard shutcuts：\n\n| Action | Mac OSX | Win/Linux|\n| :-- | :-- | :-- |\n| 注释代码(//) | Cmd + / | Ctrl + / | \n| 注释代码(/**/) | Cmd + Option + / | Ctrl + Shift + / | \n| 格式化代码 | Cmd + Option + L | Ctrl + Alt + L | \n| 清除无效包引用 | Option + Control + O | Alt + Ctrl + O | \n| 查找 | Cmd + F | Ctrl + F | \n| 查找+替换 | Cmd + R | Ctrl + R | \n| 上下移动代码 | Option + Shift + Up/Down | Alt + Shift + Up/Down | \n| 删除行 | Cmd + Delete | Ctrl + Y | \n| 扩大缩小选中范围 | Option + Up/Down| Ctrl + W/Ctrl + Shift + W |\n| 快捷生成结构体 | Cmd + Option + T | Ctrl + Alt + T |\n| 快捷覆写方法 | Cmd + O | Ctrl + O |\n| 快捷定位到行首/尾 | Cmd + Left/Right | Ctrl + Left/Right |\n| 折叠展开代码块 | Cmd + Plus,Minus | Ctrl + Plus/Minus |\n| 折叠展开全部代码块 | Cmd + Shift + Plus,Minus | Ctrl + Shift + Plus,Minus |\n| 文件方法结构 | Cmd + F12 | Ctrl + F12 |\n| 查找调用的位置 | Ctrl + Option + H | Ctrl + Alt + H |\n| 大小写转换 | Cmd + Shift + U | Ctrl + Shift + U |\n| 找到使用 | Alt+F7 | Alt+F7 |\n| 显示使用 | Ctrl+Alt+F7 | Ctrl+Alt+F7 |\n\n","slug":"IntelliJ-IDEA开发快捷键-IDEA-tool-Keyboard-shutcuts","published":1,"updated":"2019-09-27T08:27:08.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139ceci0007ojfye06dp1pp","content":"<p>IDEA tool Keyboard shutcuts：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Action</th>\n<th align=\"left\">Mac OSX</th>\n<th align=\"left\">Win/Linux</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">注释代码(//)</td>\n<td align=\"left\">Cmd + /</td>\n<td align=\"left\">Ctrl + /</td>\n</tr>\n<tr>\n<td align=\"left\">注释代码(/**/)</td>\n<td align=\"left\">Cmd + Option + /</td>\n<td align=\"left\">Ctrl + Shift + /</td>\n</tr>\n<tr>\n<td align=\"left\">格式化代码</td>\n<td align=\"left\">Cmd + Option + L</td>\n<td align=\"left\">Ctrl + Alt + L</td>\n</tr>\n<tr>\n<td align=\"left\">清除无效包引用</td>\n<td align=\"left\">Option + Control + O</td>\n<td align=\"left\">Alt + Ctrl + O</td>\n</tr>\n<tr>\n<td align=\"left\">查找</td>\n<td align=\"left\">Cmd + F</td>\n<td align=\"left\">Ctrl + F</td>\n</tr>\n<tr>\n<td align=\"left\">查找+替换</td>\n<td align=\"left\">Cmd + R</td>\n<td align=\"left\">Ctrl + R</td>\n</tr>\n<tr>\n<td align=\"left\">上下移动代码</td>\n<td align=\"left\">Option + Shift + Up/Down</td>\n<td align=\"left\">Alt + Shift + Up/Down</td>\n</tr>\n<tr>\n<td align=\"left\">删除行</td>\n<td align=\"left\">Cmd + Delete</td>\n<td align=\"left\">Ctrl + Y</td>\n</tr>\n<tr>\n<td align=\"left\">扩大缩小选中范围</td>\n<td align=\"left\">Option + Up/Down</td>\n<td align=\"left\">Ctrl + W/Ctrl + Shift + W</td>\n</tr>\n<tr>\n<td align=\"left\">快捷生成结构体</td>\n<td align=\"left\">Cmd + Option + T</td>\n<td align=\"left\">Ctrl + Alt + T</td>\n</tr>\n<tr>\n<td align=\"left\">快捷覆写方法</td>\n<td align=\"left\">Cmd + O</td>\n<td align=\"left\">Ctrl + O</td>\n</tr>\n<tr>\n<td align=\"left\">快捷定位到行首/尾</td>\n<td align=\"left\">Cmd + Left/Right</td>\n<td align=\"left\">Ctrl + Left/Right</td>\n</tr>\n<tr>\n<td align=\"left\">折叠展开代码块</td>\n<td align=\"left\">Cmd + Plus,Minus</td>\n<td align=\"left\">Ctrl + Plus/Minus</td>\n</tr>\n<tr>\n<td align=\"left\">折叠展开全部代码块</td>\n<td align=\"left\">Cmd + Shift + Plus,Minus</td>\n<td align=\"left\">Ctrl + Shift + Plus,Minus</td>\n</tr>\n<tr>\n<td align=\"left\">文件方法结构</td>\n<td align=\"left\">Cmd + F12</td>\n<td align=\"left\">Ctrl + F12</td>\n</tr>\n<tr>\n<td align=\"left\">查找调用的位置</td>\n<td align=\"left\">Ctrl + Option + H</td>\n<td align=\"left\">Ctrl + Alt + H</td>\n</tr>\n<tr>\n<td align=\"left\">大小写转换</td>\n<td align=\"left\">Cmd + Shift + U</td>\n<td align=\"left\">Ctrl + Shift + U</td>\n</tr>\n<tr>\n<td align=\"left\">找到使用</td>\n<td align=\"left\">Alt+F7</td>\n<td align=\"left\">Alt+F7</td>\n</tr>\n<tr>\n<td align=\"left\">显示使用</td>\n<td align=\"left\">Ctrl+Alt+F7</td>\n<td align=\"left\">Ctrl+Alt+F7</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<p>IDEA tool Keyboard shutcuts：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Action</th>\n<th align=\"left\">Mac OSX</th>\n<th align=\"left\">Win/Linux</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">注释代码(//)</td>\n<td align=\"left\">Cmd + /</td>\n<td align=\"left\">Ctrl + /</td>\n</tr>\n<tr>\n<td align=\"left\">注释代码(/**/)</td>\n<td align=\"left\">Cmd + Option + /</td>\n<td align=\"left\">Ctrl + Shift + /</td>\n</tr>\n<tr>\n<td align=\"left\">格式化代码</td>\n<td align=\"left\">Cmd + Option + L</td>\n<td align=\"left\">Ctrl + Alt + L</td>\n</tr>\n<tr>\n<td align=\"left\">清除无效包引用</td>\n<td align=\"left\">Option + Control + O</td>\n<td align=\"left\">Alt + Ctrl + O</td>\n</tr>\n<tr>\n<td align=\"left\">查找</td>\n<td align=\"left\">Cmd + F</td>\n<td align=\"left\">Ctrl + F</td>\n</tr>\n<tr>\n<td align=\"left\">查找+替换</td>\n<td align=\"left\">Cmd + R</td>\n<td align=\"left\">Ctrl + R</td>\n</tr>\n<tr>\n<td align=\"left\">上下移动代码</td>\n<td align=\"left\">Option + Shift + Up/Down</td>\n<td align=\"left\">Alt + Shift + Up/Down</td>\n</tr>\n<tr>\n<td align=\"left\">删除行</td>\n<td align=\"left\">Cmd + Delete</td>\n<td align=\"left\">Ctrl + Y</td>\n</tr>\n<tr>\n<td align=\"left\">扩大缩小选中范围</td>\n<td align=\"left\">Option + Up/Down</td>\n<td align=\"left\">Ctrl + W/Ctrl + Shift + W</td>\n</tr>\n<tr>\n<td align=\"left\">快捷生成结构体</td>\n<td align=\"left\">Cmd + Option + T</td>\n<td align=\"left\">Ctrl + Alt + T</td>\n</tr>\n<tr>\n<td align=\"left\">快捷覆写方法</td>\n<td align=\"left\">Cmd + O</td>\n<td align=\"left\">Ctrl + O</td>\n</tr>\n<tr>\n<td align=\"left\">快捷定位到行首/尾</td>\n<td align=\"left\">Cmd + Left/Right</td>\n<td align=\"left\">Ctrl + Left/Right</td>\n</tr>\n<tr>\n<td align=\"left\">折叠展开代码块</td>\n<td align=\"left\">Cmd + Plus,Minus</td>\n<td align=\"left\">Ctrl + Plus/Minus</td>\n</tr>\n<tr>\n<td align=\"left\">折叠展开全部代码块</td>\n<td align=\"left\">Cmd + Shift + Plus,Minus</td>\n<td align=\"left\">Ctrl + Shift + Plus,Minus</td>\n</tr>\n<tr>\n<td align=\"left\">文件方法结构</td>\n<td align=\"left\">Cmd + F12</td>\n<td align=\"left\">Ctrl + F12</td>\n</tr>\n<tr>\n<td align=\"left\">查找调用的位置</td>\n<td align=\"left\">Ctrl + Option + H</td>\n<td align=\"left\">Ctrl + Alt + H</td>\n</tr>\n<tr>\n<td align=\"left\">大小写转换</td>\n<td align=\"left\">Cmd + Shift + U</td>\n<td align=\"left\">Ctrl + Shift + U</td>\n</tr>\n<tr>\n<td align=\"left\">找到使用</td>\n<td align=\"left\">Alt+F7</td>\n<td align=\"left\">Alt+F7</td>\n</tr>\n<tr>\n<td align=\"left\">显示使用</td>\n<td align=\"left\">Ctrl+Alt+F7</td>\n<td align=\"left\">Ctrl+Alt+F7</td>\n</tr>\n</tbody></table>\n"},{"title":"Intellij IDEA如何配置JDK","date":"2019-08-28T10:19:15.000Z","_content":"\ncommand + ; // 快捷键打开配置\n\nConfigure  --> Project Defaults  -->  Project Structure \n\n点击Project选项卡，配置相应jdk","source":"_posts/Intellij-IDEA如何配置JDK.md","raw":"---\ntitle: Intellij IDEA如何配置JDK\ndate: 2019-08-28 18:19:15\ntags: [Intellij IDEA,JDK]\n---\n\ncommand + ; // 快捷键打开配置\n\nConfigure  --> Project Defaults  -->  Project Structure \n\n点击Project选项卡，配置相应jdk","slug":"Intellij-IDEA如何配置JDK","published":1,"updated":"2019-09-27T08:27:08.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecj0008ojfyis2eofhc","content":"<p>command + ; // 快捷键打开配置</p>\n<p>Configure  –&gt; Project Defaults  –&gt;  Project Structure </p>\n<p>点击Project选项卡，配置相应jdk</p>\n","site":{"data":{}},"excerpt":"","more":"<p>command + ; // 快捷键打开配置</p>\n<p>Configure  –&gt; Project Defaults  –&gt;  Project Structure </p>\n<p>点击Project选项卡，配置相应jdk</p>\n"},{"title":"Hexo博客备份","date":"2018-05-05T03:52:33.000Z","_content":"\n## 参考：https://www.jianshu.com/p/57b5a384f234\n\n遇到的坑\n\n    CNAME必须放在source目录中不然会导致页面无法访问404\n    \n    注意千万不要合并主干否则......你懂的\n    \n    ","source":"_posts/Hexo博客备份.md","raw":"---\ntitle: Hexo博客备份\ndate: 2018-05-05 11:52:33\ntags: hexo\ncategories: \n- hexo\n---\n\n## 参考：https://www.jianshu.com/p/57b5a384f234\n\n遇到的坑\n\n    CNAME必须放在source目录中不然会导致页面无法访问404\n    \n    注意千万不要合并主干否则......你懂的\n    \n    ","slug":"Hexo博客备份","published":1,"updated":"2019-09-27T08:27:08.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139ceck0009ojfyc28a1c7q","content":"<h2 id=\"参考：https-www-jianshu-com-p-57b5a384f234\"><a href=\"#参考：https-www-jianshu-com-p-57b5a384f234\" class=\"headerlink\" title=\"参考：https://www.jianshu.com/p/57b5a384f234\"></a>参考：<a href=\"https://www.jianshu.com/p/57b5a384f234\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/57b5a384f234</a></h2><p>遇到的坑</p>\n<pre><code>CNAME必须放在source目录中不然会导致页面无法访问404\n\n注意千万不要合并主干否则......你懂的</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"参考：https-www-jianshu-com-p-57b5a384f234\"><a href=\"#参考：https-www-jianshu-com-p-57b5a384f234\" class=\"headerlink\" title=\"参考：https://www.jianshu.com/p/57b5a384f234\"></a>参考：<a href=\"https://www.jianshu.com/p/57b5a384f234\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/57b5a384f234</a></h2><p>遇到的坑</p>\n<pre><code>CNAME必须放在source目录中不然会导致页面无法访问404\n\n注意千万不要合并主干否则......你懂的</code></pre>"},{"title":"Kotlin","date":"2018-04-20T09:34:49.000Z","_content":"\n## 引用: https://baike.baidu.com/item/Kotlin/1133714?fr=aladdin\n\n    Kotlin 是一个用于现代多平台应用的静态编程语言,有JetBrains开\n    发.\n    \n    Kotlin可以编译称为Java字节码,也可以编译成JavaScript,方便在没有\n    JVM的设备上运行.\n    \n    Kotlin已正式成为Android官方支持开发语言.\n    \n## 简介\n\n    JetBrains,作为广受欢迎的java IDE intelliJ的提供商,在Apache许可\n    下已经开源其Kotlin编程语言.\n    \n## 设计目标\n    \n    创建一种兼容java的语言\n    \n    让它比java更安全,能够静态检测常见的陷阱.如:引用空指针\n    让它比java更简洁,通过支持variable type inference,higher-order\n    function(closures),extension functions,mixins and first-class\n    delegation等实现.\n    \n    让它比最成熟的竞争对手Scala语言更加简洁.\n    \n## 开发源代码\n\n    其基础编译器(他们将其改为kompiler---开创了一系列以K字打头的用语\n    ---甚至连 contributors这类词他们也用改成了kontributors)可以被独立\n    出来并嵌入到Maven Ant或Gradle工具链中,这使得在IDE中开发的代码能够\n    利用已有的机制来构建,从而尽可能的减少了在新环境中使用所受的干预,哪\n    怕与那些没有安装Kotlin插件的开发人员一起合作项目也没有问题.\n    \n    The Intellij Kotlin插件扩展了Java编译器使得Kotlin代码能够得以编写 \n    编译和调试.除此之外,关于基本的Java集合,已经有编写好的帮助函数,可以\n    更顺畅地衔接在java8中出现的集合扩展.\n    \n    有两篇文章对Kotlin与Java以及Scala分别进行了比较,对各自特性和异同进\n    行了对比.即便Scala可能还是更为强大些,Kotlin还是尝试提供比java更好\n    的函数 模式匹配 空指针预防和泛型.该语言同时支持特征(traits)和模式匹配\n    \n    Kotlin插件在当前版本的IntelliJ和Eclipse中均已能使用.\n    \n    Kotlin,类似Xtend一样,旨在提供一种更好的java而非重建整个新平台.这两种\n    语言都向下编译为字节码(虽然Xtend是首先转换成相应的java代码,再让java\n    编译器完成繁重的工作),而且两者都引入了函数和扩展函数(在某个有限范围\n    内静态地增加一个新方法到某个已有类型的能力).Xtend是基于Eclipse的,而\n    Kotlin是基于IntelliJ的,两者都提供无界面构建.能够首先演变到其他IDE的语\n    言有可能成为最后的赢家.\n    \n    \n    \n    \n    \n    \n\n","source":"_posts/Kotlin.md","raw":"---\ntitle: Kotlin\ndate: 2018-04-20 17:34:49\ntags: kotlin\n---\n\n## 引用: https://baike.baidu.com/item/Kotlin/1133714?fr=aladdin\n\n    Kotlin 是一个用于现代多平台应用的静态编程语言,有JetBrains开\n    发.\n    \n    Kotlin可以编译称为Java字节码,也可以编译成JavaScript,方便在没有\n    JVM的设备上运行.\n    \n    Kotlin已正式成为Android官方支持开发语言.\n    \n## 简介\n\n    JetBrains,作为广受欢迎的java IDE intelliJ的提供商,在Apache许可\n    下已经开源其Kotlin编程语言.\n    \n## 设计目标\n    \n    创建一种兼容java的语言\n    \n    让它比java更安全,能够静态检测常见的陷阱.如:引用空指针\n    让它比java更简洁,通过支持variable type inference,higher-order\n    function(closures),extension functions,mixins and first-class\n    delegation等实现.\n    \n    让它比最成熟的竞争对手Scala语言更加简洁.\n    \n## 开发源代码\n\n    其基础编译器(他们将其改为kompiler---开创了一系列以K字打头的用语\n    ---甚至连 contributors这类词他们也用改成了kontributors)可以被独立\n    出来并嵌入到Maven Ant或Gradle工具链中,这使得在IDE中开发的代码能够\n    利用已有的机制来构建,从而尽可能的减少了在新环境中使用所受的干预,哪\n    怕与那些没有安装Kotlin插件的开发人员一起合作项目也没有问题.\n    \n    The Intellij Kotlin插件扩展了Java编译器使得Kotlin代码能够得以编写 \n    编译和调试.除此之外,关于基本的Java集合,已经有编写好的帮助函数,可以\n    更顺畅地衔接在java8中出现的集合扩展.\n    \n    有两篇文章对Kotlin与Java以及Scala分别进行了比较,对各自特性和异同进\n    行了对比.即便Scala可能还是更为强大些,Kotlin还是尝试提供比java更好\n    的函数 模式匹配 空指针预防和泛型.该语言同时支持特征(traits)和模式匹配\n    \n    Kotlin插件在当前版本的IntelliJ和Eclipse中均已能使用.\n    \n    Kotlin,类似Xtend一样,旨在提供一种更好的java而非重建整个新平台.这两种\n    语言都向下编译为字节码(虽然Xtend是首先转换成相应的java代码,再让java\n    编译器完成繁重的工作),而且两者都引入了函数和扩展函数(在某个有限范围\n    内静态地增加一个新方法到某个已有类型的能力).Xtend是基于Eclipse的,而\n    Kotlin是基于IntelliJ的,两者都提供无界面构建.能够首先演变到其他IDE的语\n    言有可能成为最后的赢家.\n    \n    \n    \n    \n    \n    \n\n","slug":"Kotlin","published":1,"updated":"2019-09-27T08:27:08.026Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecl000aojfyutwscpk1","content":"<h2 id=\"引用-https-baike-baidu-com-item-Kotlin-1133714-fr-aladdin\"><a href=\"#引用-https-baike-baidu-com-item-Kotlin-1133714-fr-aladdin\" class=\"headerlink\" title=\"引用: https://baike.baidu.com/item/Kotlin/1133714?fr=aladdin\"></a>引用: <a href=\"https://baike.baidu.com/item/Kotlin/1133714?fr=aladdin\" target=\"_blank\" rel=\"noopener\">https://baike.baidu.com/item/Kotlin/1133714?fr=aladdin</a></h2><pre><code>Kotlin 是一个用于现代多平台应用的静态编程语言,有JetBrains开\n发.\n\nKotlin可以编译称为Java字节码,也可以编译成JavaScript,方便在没有\nJVM的设备上运行.\n\nKotlin已正式成为Android官方支持开发语言.</code></pre><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><pre><code>JetBrains,作为广受欢迎的java IDE intelliJ的提供商,在Apache许可\n下已经开源其Kotlin编程语言.</code></pre><h2 id=\"设计目标\"><a href=\"#设计目标\" class=\"headerlink\" title=\"设计目标\"></a>设计目标</h2><pre><code>创建一种兼容java的语言\n\n让它比java更安全,能够静态检测常见的陷阱.如:引用空指针\n让它比java更简洁,通过支持variable type inference,higher-order\nfunction(closures),extension functions,mixins and first-class\ndelegation等实现.\n\n让它比最成熟的竞争对手Scala语言更加简洁.</code></pre><h2 id=\"开发源代码\"><a href=\"#开发源代码\" class=\"headerlink\" title=\"开发源代码\"></a>开发源代码</h2><pre><code>其基础编译器(他们将其改为kompiler---开创了一系列以K字打头的用语\n---甚至连 contributors这类词他们也用改成了kontributors)可以被独立\n出来并嵌入到Maven Ant或Gradle工具链中,这使得在IDE中开发的代码能够\n利用已有的机制来构建,从而尽可能的减少了在新环境中使用所受的干预,哪\n怕与那些没有安装Kotlin插件的开发人员一起合作项目也没有问题.\n\nThe Intellij Kotlin插件扩展了Java编译器使得Kotlin代码能够得以编写 \n编译和调试.除此之外,关于基本的Java集合,已经有编写好的帮助函数,可以\n更顺畅地衔接在java8中出现的集合扩展.\n\n有两篇文章对Kotlin与Java以及Scala分别进行了比较,对各自特性和异同进\n行了对比.即便Scala可能还是更为强大些,Kotlin还是尝试提供比java更好\n的函数 模式匹配 空指针预防和泛型.该语言同时支持特征(traits)和模式匹配\n\nKotlin插件在当前版本的IntelliJ和Eclipse中均已能使用.\n\nKotlin,类似Xtend一样,旨在提供一种更好的java而非重建整个新平台.这两种\n语言都向下编译为字节码(虽然Xtend是首先转换成相应的java代码,再让java\n编译器完成繁重的工作),而且两者都引入了函数和扩展函数(在某个有限范围\n内静态地增加一个新方法到某个已有类型的能力).Xtend是基于Eclipse的,而\nKotlin是基于IntelliJ的,两者都提供无界面构建.能够首先演变到其他IDE的语\n言有可能成为最后的赢家.</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"引用-https-baike-baidu-com-item-Kotlin-1133714-fr-aladdin\"><a href=\"#引用-https-baike-baidu-com-item-Kotlin-1133714-fr-aladdin\" class=\"headerlink\" title=\"引用: https://baike.baidu.com/item/Kotlin/1133714?fr=aladdin\"></a>引用: <a href=\"https://baike.baidu.com/item/Kotlin/1133714?fr=aladdin\" target=\"_blank\" rel=\"noopener\">https://baike.baidu.com/item/Kotlin/1133714?fr=aladdin</a></h2><pre><code>Kotlin 是一个用于现代多平台应用的静态编程语言,有JetBrains开\n发.\n\nKotlin可以编译称为Java字节码,也可以编译成JavaScript,方便在没有\nJVM的设备上运行.\n\nKotlin已正式成为Android官方支持开发语言.</code></pre><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><pre><code>JetBrains,作为广受欢迎的java IDE intelliJ的提供商,在Apache许可\n下已经开源其Kotlin编程语言.</code></pre><h2 id=\"设计目标\"><a href=\"#设计目标\" class=\"headerlink\" title=\"设计目标\"></a>设计目标</h2><pre><code>创建一种兼容java的语言\n\n让它比java更安全,能够静态检测常见的陷阱.如:引用空指针\n让它比java更简洁,通过支持variable type inference,higher-order\nfunction(closures),extension functions,mixins and first-class\ndelegation等实现.\n\n让它比最成熟的竞争对手Scala语言更加简洁.</code></pre><h2 id=\"开发源代码\"><a href=\"#开发源代码\" class=\"headerlink\" title=\"开发源代码\"></a>开发源代码</h2><pre><code>其基础编译器(他们将其改为kompiler---开创了一系列以K字打头的用语\n---甚至连 contributors这类词他们也用改成了kontributors)可以被独立\n出来并嵌入到Maven Ant或Gradle工具链中,这使得在IDE中开发的代码能够\n利用已有的机制来构建,从而尽可能的减少了在新环境中使用所受的干预,哪\n怕与那些没有安装Kotlin插件的开发人员一起合作项目也没有问题.\n\nThe Intellij Kotlin插件扩展了Java编译器使得Kotlin代码能够得以编写 \n编译和调试.除此之外,关于基本的Java集合,已经有编写好的帮助函数,可以\n更顺畅地衔接在java8中出现的集合扩展.\n\n有两篇文章对Kotlin与Java以及Scala分别进行了比较,对各自特性和异同进\n行了对比.即便Scala可能还是更为强大些,Kotlin还是尝试提供比java更好\n的函数 模式匹配 空指针预防和泛型.该语言同时支持特征(traits)和模式匹配\n\nKotlin插件在当前版本的IntelliJ和Eclipse中均已能使用.\n\nKotlin,类似Xtend一样,旨在提供一种更好的java而非重建整个新平台.这两种\n语言都向下编译为字节码(虽然Xtend是首先转换成相应的java代码,再让java\n编译器完成繁重的工作),而且两者都引入了函数和扩展函数(在某个有限范围\n内静态地增加一个新方法到某个已有类型的能力).Xtend是基于Eclipse的,而\nKotlin是基于IntelliJ的,两者都提供无界面构建.能够首先演变到其他IDE的语\n言有可能成为最后的赢家.</code></pre>"},{"title":"JSP与JavaScript","date":"2019-09-04T09:50:42.000Z","_content":"\n某日在洗手间偶遇某大牛,聊起JSP,大牛曰:\"JSP 哦知道,JavaScript\"\n我竟无言以对!在此记录一下JSP与JavaScript的区别\n\n# 首先下结论 雷锋与雷锋塔的区别\n\n## JSP是什么\nSUN首先发展出SERVLET，其功能比较强劲，体系设计也很先进，只是，它输出HTML语句还是采用了老的CGI方式，是一句一句输出，所以，编写和修改HTML非常不方便。 后来SUN推出了类似于ASP的镶嵌型的JSP，把JSP TAG镶嵌到HTML语句中，这样，就大大简化和方便了网页的设计和修改。\n\nJSP全名为Java Server Pages，其根本是一个简化的Servlet设计，他实现了Html语法中的java扩张（以 <%, %>形式）。JSP与Servlet一样，是在服务器端执行的。通常返回给客户端的就是一个HTML文本，因此客户端只要有浏览器就能浏览。Web服务器在遇到访问JSP网页的请求时，首先执行其中的程序段，然后将执行结果连同JSP文件中的HTML代码一起返回给客户端。插入的Java程序段可以操作数据库、重新定向网页等，以实现建立动态网页所需要的功能。\n\nJSP页面由HTML代码和嵌入其中的Java代码所组成。服务器在页面被客户端请求以后对这些Java代码进行处理，然后将生成的HTML页面返回给客户端的浏览器。Java Servlet是JSP的技术基础，而且大型的Web应用程序的开发需要Java Servlet和JSP配合才能完成。JSP具备了Java技术的简单易用，完全的面向对象，具有平台无关性且安全可靠，主要面向因特网的所有特点。\n\njsp 要先翻译，注意是翻译成servlet才能执行：\n比如 test.jsp 要变成 test_jsp.java 然后编译成 test_jsp.class\n而 test_jsp.java 本身就是一个servlet.\n所以 jsp只是servlet的一个变种，方便书写html内容才出现的。\n    \n    servlet的运行机制和Applet类似，只不过它运行在服务器端。一个servlet是javax.servlet包中HttpServlet类的子类，由支持servlet的服务器完成该子类的对象，即servlet的初始化。\n    \n    扩展阅读0：jsp转化为servlet的过程：\n    \n    http://www.w3cschool.cc/jsp/jsp-architecture.html\n    \n    扩展阅读1：servlet版的Helloworld（需要装tomcat,我通常使用XAMPP集成的tomcat）\n    \n    http://blog.163.com/adoom_2010/blog/static/1820326362011710102719527/\n    \n    扩展阅读2：servlet程序中的各部分的作用、调用顺序\n    \n    http://wenku.baidu.com/link?url=U2B6Gx_C1X702ppIFJdXR23MyY85lZzJeneIDZSFCuA3bZ-ynwDFx9oYm4pNcpa4ZjmlUPnkrtwkHg0skxdo3mqOY-IAvXzzYqaCOc7DVmW\n    \n## JavaScript是什么\nJava Script 是一种基于对象的客户端脚本语言。主要目的是为了解决服务器端语言，比如Perl，遗留的速度问题，为客户提供更流畅的浏览效果。JS可以直接嵌入到html代码中进行解析执行，非常简单易学，可以产生很多动态的效果。\n\n## 二者区别\n简单地说——JS是在客户端执行的，需要浏览器支持Javascript。JSP是在服务器端执行的，需要服务器上部署支持Servlet的服务器程序。JS代码是能够直接从服务器上download得到，对外是可见的，jsp(和翻译后的servlet)代码是对外不可见的。\n\nJS与JavaScript相比：虽然JavaScript可以在客户端动态生成HTML，但是很难与服务器交互，因此不能提供复杂的服务，比如访问数据库和图像处理等等。JSP在HTML中用<%%>里面实现。JS在html中用<Script></Script>实现\n\n\n[参考1](https://zh.wikipedia.org/wiki/JavaScript)\n[参考2](https://zh.wikipedia.org/wiki/JSP)\n[参考3](https://blog.csdn.net/a2806005024/article/details/28265503)\n","source":"_posts/JSP与JavaScript.md","raw":"---\ntitle: JSP与JavaScript\ndate: 2019-09-04 17:50:42\ntags: [JSP,JavaScript]\ncategories: [笑话]\n---\n\n某日在洗手间偶遇某大牛,聊起JSP,大牛曰:\"JSP 哦知道,JavaScript\"\n我竟无言以对!在此记录一下JSP与JavaScript的区别\n\n# 首先下结论 雷锋与雷锋塔的区别\n\n## JSP是什么\nSUN首先发展出SERVLET，其功能比较强劲，体系设计也很先进，只是，它输出HTML语句还是采用了老的CGI方式，是一句一句输出，所以，编写和修改HTML非常不方便。 后来SUN推出了类似于ASP的镶嵌型的JSP，把JSP TAG镶嵌到HTML语句中，这样，就大大简化和方便了网页的设计和修改。\n\nJSP全名为Java Server Pages，其根本是一个简化的Servlet设计，他实现了Html语法中的java扩张（以 <%, %>形式）。JSP与Servlet一样，是在服务器端执行的。通常返回给客户端的就是一个HTML文本，因此客户端只要有浏览器就能浏览。Web服务器在遇到访问JSP网页的请求时，首先执行其中的程序段，然后将执行结果连同JSP文件中的HTML代码一起返回给客户端。插入的Java程序段可以操作数据库、重新定向网页等，以实现建立动态网页所需要的功能。\n\nJSP页面由HTML代码和嵌入其中的Java代码所组成。服务器在页面被客户端请求以后对这些Java代码进行处理，然后将生成的HTML页面返回给客户端的浏览器。Java Servlet是JSP的技术基础，而且大型的Web应用程序的开发需要Java Servlet和JSP配合才能完成。JSP具备了Java技术的简单易用，完全的面向对象，具有平台无关性且安全可靠，主要面向因特网的所有特点。\n\njsp 要先翻译，注意是翻译成servlet才能执行：\n比如 test.jsp 要变成 test_jsp.java 然后编译成 test_jsp.class\n而 test_jsp.java 本身就是一个servlet.\n所以 jsp只是servlet的一个变种，方便书写html内容才出现的。\n    \n    servlet的运行机制和Applet类似，只不过它运行在服务器端。一个servlet是javax.servlet包中HttpServlet类的子类，由支持servlet的服务器完成该子类的对象，即servlet的初始化。\n    \n    扩展阅读0：jsp转化为servlet的过程：\n    \n    http://www.w3cschool.cc/jsp/jsp-architecture.html\n    \n    扩展阅读1：servlet版的Helloworld（需要装tomcat,我通常使用XAMPP集成的tomcat）\n    \n    http://blog.163.com/adoom_2010/blog/static/1820326362011710102719527/\n    \n    扩展阅读2：servlet程序中的各部分的作用、调用顺序\n    \n    http://wenku.baidu.com/link?url=U2B6Gx_C1X702ppIFJdXR23MyY85lZzJeneIDZSFCuA3bZ-ynwDFx9oYm4pNcpa4ZjmlUPnkrtwkHg0skxdo3mqOY-IAvXzzYqaCOc7DVmW\n    \n## JavaScript是什么\nJava Script 是一种基于对象的客户端脚本语言。主要目的是为了解决服务器端语言，比如Perl，遗留的速度问题，为客户提供更流畅的浏览效果。JS可以直接嵌入到html代码中进行解析执行，非常简单易学，可以产生很多动态的效果。\n\n## 二者区别\n简单地说——JS是在客户端执行的，需要浏览器支持Javascript。JSP是在服务器端执行的，需要服务器上部署支持Servlet的服务器程序。JS代码是能够直接从服务器上download得到，对外是可见的，jsp(和翻译后的servlet)代码是对外不可见的。\n\nJS与JavaScript相比：虽然JavaScript可以在客户端动态生成HTML，但是很难与服务器交互，因此不能提供复杂的服务，比如访问数据库和图像处理等等。JSP在HTML中用<%%>里面实现。JS在html中用<Script></Script>实现\n\n\n[参考1](https://zh.wikipedia.org/wiki/JavaScript)\n[参考2](https://zh.wikipedia.org/wiki/JSP)\n[参考3](https://blog.csdn.net/a2806005024/article/details/28265503)\n","slug":"JSP与JavaScript","published":1,"updated":"2019-09-27T08:27:08.024Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecm000bojfyjmw5a4y0","content":"<p>某日在洗手间偶遇某大牛,聊起JSP,大牛曰:”JSP 哦知道,JavaScript”<br>我竟无言以对!在此记录一下JSP与JavaScript的区别</p>\n<h1 id=\"首先下结论-雷锋与雷锋塔的区别\"><a href=\"#首先下结论-雷锋与雷锋塔的区别\" class=\"headerlink\" title=\"首先下结论 雷锋与雷锋塔的区别\"></a>首先下结论 雷锋与雷锋塔的区别</h1><h2 id=\"JSP是什么\"><a href=\"#JSP是什么\" class=\"headerlink\" title=\"JSP是什么\"></a>JSP是什么</h2><p>SUN首先发展出SERVLET，其功能比较强劲，体系设计也很先进，只是，它输出HTML语句还是采用了老的CGI方式，是一句一句输出，所以，编写和修改HTML非常不方便。 后来SUN推出了类似于ASP的镶嵌型的JSP，把JSP TAG镶嵌到HTML语句中，这样，就大大简化和方便了网页的设计和修改。</p>\n<p>JSP全名为Java Server Pages，其根本是一个简化的Servlet设计，他实现了Html语法中的java扩张（以 &lt;%, %&gt;形式）。JSP与Servlet一样，是在服务器端执行的。通常返回给客户端的就是一个HTML文本，因此客户端只要有浏览器就能浏览。Web服务器在遇到访问JSP网页的请求时，首先执行其中的程序段，然后将执行结果连同JSP文件中的HTML代码一起返回给客户端。插入的Java程序段可以操作数据库、重新定向网页等，以实现建立动态网页所需要的功能。</p>\n<p>JSP页面由HTML代码和嵌入其中的Java代码所组成。服务器在页面被客户端请求以后对这些Java代码进行处理，然后将生成的HTML页面返回给客户端的浏览器。Java Servlet是JSP的技术基础，而且大型的Web应用程序的开发需要Java Servlet和JSP配合才能完成。JSP具备了Java技术的简单易用，完全的面向对象，具有平台无关性且安全可靠，主要面向因特网的所有特点。</p>\n<p>jsp 要先翻译，注意是翻译成servlet才能执行：<br>比如 test.jsp 要变成 test_jsp.java 然后编译成 test_jsp.class<br>而 test_jsp.java 本身就是一个servlet.<br>所以 jsp只是servlet的一个变种，方便书写html内容才出现的。</p>\n<pre><code>servlet的运行机制和Applet类似，只不过它运行在服务器端。一个servlet是javax.servlet包中HttpServlet类的子类，由支持servlet的服务器完成该子类的对象，即servlet的初始化。\n\n扩展阅读0：jsp转化为servlet的过程：\n\nhttp://www.w3cschool.cc/jsp/jsp-architecture.html\n\n扩展阅读1：servlet版的Helloworld（需要装tomcat,我通常使用XAMPP集成的tomcat）\n\nhttp://blog.163.com/adoom_2010/blog/static/1820326362011710102719527/\n\n扩展阅读2：servlet程序中的各部分的作用、调用顺序\n\nhttp://wenku.baidu.com/link?url=U2B6Gx_C1X702ppIFJdXR23MyY85lZzJeneIDZSFCuA3bZ-ynwDFx9oYm4pNcpa4ZjmlUPnkrtwkHg0skxdo3mqOY-IAvXzzYqaCOc7DVmW</code></pre><h2 id=\"JavaScript是什么\"><a href=\"#JavaScript是什么\" class=\"headerlink\" title=\"JavaScript是什么\"></a>JavaScript是什么</h2><p>Java Script 是一种基于对象的客户端脚本语言。主要目的是为了解决服务器端语言，比如Perl，遗留的速度问题，为客户提供更流畅的浏览效果。JS可以直接嵌入到html代码中进行解析执行，非常简单易学，可以产生很多动态的效果。</p>\n<h2 id=\"二者区别\"><a href=\"#二者区别\" class=\"headerlink\" title=\"二者区别\"></a>二者区别</h2><p>简单地说——JS是在客户端执行的，需要浏览器支持Javascript。JSP是在服务器端执行的，需要服务器上部署支持Servlet的服务器程序。JS代码是能够直接从服务器上download得到，对外是可见的，jsp(和翻译后的servlet)代码是对外不可见的。</p>\n<p>JS与JavaScript相比：虽然JavaScript可以在客户端动态生成HTML，但是很难与服务器交互，因此不能提供复杂的服务，比如访问数据库和图像处理等等。JSP在HTML中用&lt;%%&gt;里面实现。JS在html中用<script></script>实现</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/JavaScript\" target=\"_blank\" rel=\"noopener\">参考1</a><br><a href=\"https://zh.wikipedia.org/wiki/JSP\" target=\"_blank\" rel=\"noopener\">参考2</a><br><a href=\"https://blog.csdn.net/a2806005024/article/details/28265503\" target=\"_blank\" rel=\"noopener\">参考3</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>某日在洗手间偶遇某大牛,聊起JSP,大牛曰:”JSP 哦知道,JavaScript”<br>我竟无言以对!在此记录一下JSP与JavaScript的区别</p>\n<h1 id=\"首先下结论-雷锋与雷锋塔的区别\"><a href=\"#首先下结论-雷锋与雷锋塔的区别\" class=\"headerlink\" title=\"首先下结论 雷锋与雷锋塔的区别\"></a>首先下结论 雷锋与雷锋塔的区别</h1><h2 id=\"JSP是什么\"><a href=\"#JSP是什么\" class=\"headerlink\" title=\"JSP是什么\"></a>JSP是什么</h2><p>SUN首先发展出SERVLET，其功能比较强劲，体系设计也很先进，只是，它输出HTML语句还是采用了老的CGI方式，是一句一句输出，所以，编写和修改HTML非常不方便。 后来SUN推出了类似于ASP的镶嵌型的JSP，把JSP TAG镶嵌到HTML语句中，这样，就大大简化和方便了网页的设计和修改。</p>\n<p>JSP全名为Java Server Pages，其根本是一个简化的Servlet设计，他实现了Html语法中的java扩张（以 &lt;%, %&gt;形式）。JSP与Servlet一样，是在服务器端执行的。通常返回给客户端的就是一个HTML文本，因此客户端只要有浏览器就能浏览。Web服务器在遇到访问JSP网页的请求时，首先执行其中的程序段，然后将执行结果连同JSP文件中的HTML代码一起返回给客户端。插入的Java程序段可以操作数据库、重新定向网页等，以实现建立动态网页所需要的功能。</p>\n<p>JSP页面由HTML代码和嵌入其中的Java代码所组成。服务器在页面被客户端请求以后对这些Java代码进行处理，然后将生成的HTML页面返回给客户端的浏览器。Java Servlet是JSP的技术基础，而且大型的Web应用程序的开发需要Java Servlet和JSP配合才能完成。JSP具备了Java技术的简单易用，完全的面向对象，具有平台无关性且安全可靠，主要面向因特网的所有特点。</p>\n<p>jsp 要先翻译，注意是翻译成servlet才能执行：<br>比如 test.jsp 要变成 test_jsp.java 然后编译成 test_jsp.class<br>而 test_jsp.java 本身就是一个servlet.<br>所以 jsp只是servlet的一个变种，方便书写html内容才出现的。</p>\n<pre><code>servlet的运行机制和Applet类似，只不过它运行在服务器端。一个servlet是javax.servlet包中HttpServlet类的子类，由支持servlet的服务器完成该子类的对象，即servlet的初始化。\n\n扩展阅读0：jsp转化为servlet的过程：\n\nhttp://www.w3cschool.cc/jsp/jsp-architecture.html\n\n扩展阅读1：servlet版的Helloworld（需要装tomcat,我通常使用XAMPP集成的tomcat）\n\nhttp://blog.163.com/adoom_2010/blog/static/1820326362011710102719527/\n\n扩展阅读2：servlet程序中的各部分的作用、调用顺序\n\nhttp://wenku.baidu.com/link?url=U2B6Gx_C1X702ppIFJdXR23MyY85lZzJeneIDZSFCuA3bZ-ynwDFx9oYm4pNcpa4ZjmlUPnkrtwkHg0skxdo3mqOY-IAvXzzYqaCOc7DVmW</code></pre><h2 id=\"JavaScript是什么\"><a href=\"#JavaScript是什么\" class=\"headerlink\" title=\"JavaScript是什么\"></a>JavaScript是什么</h2><p>Java Script 是一种基于对象的客户端脚本语言。主要目的是为了解决服务器端语言，比如Perl，遗留的速度问题，为客户提供更流畅的浏览效果。JS可以直接嵌入到html代码中进行解析执行，非常简单易学，可以产生很多动态的效果。</p>\n<h2 id=\"二者区别\"><a href=\"#二者区别\" class=\"headerlink\" title=\"二者区别\"></a>二者区别</h2><p>简单地说——JS是在客户端执行的，需要浏览器支持Javascript。JSP是在服务器端执行的，需要服务器上部署支持Servlet的服务器程序。JS代码是能够直接从服务器上download得到，对外是可见的，jsp(和翻译后的servlet)代码是对外不可见的。</p>\n<p>JS与JavaScript相比：虽然JavaScript可以在客户端动态生成HTML，但是很难与服务器交互，因此不能提供复杂的服务，比如访问数据库和图像处理等等。JSP在HTML中用&lt;%%&gt;里面实现。JS在html中用<script></script>实现</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/JavaScript\" target=\"_blank\" rel=\"noopener\">参考1</a><br><a href=\"https://zh.wikipedia.org/wiki/JSP\" target=\"_blank\" rel=\"noopener\">参考2</a><br><a href=\"https://blog.csdn.net/a2806005024/article/details/28265503\" target=\"_blank\" rel=\"noopener\">参考3</a></p>\n"},{"title":"Javac原理","date":"2019-09-25T02:57:37.000Z","_content":"从Sun Javac的代码来看，编译过程大致可以分为3个过程:\n\n1. 解析与填充符号表过程。\n2. 插入式注解处理器的注解处理过程。\n3. 分析与字节码生成过程。\n![](j.jpg)\nJavac编译动作的入口是com.sun.tools.javac.main.JavaCompiler类，上述3个过程的代码逻辑集中在这个类的compile()和compile2()方法中，整个编译最关键的处理就由图中标注的8个方法来完成，下面我们具体看一下这8个方法实现了什么功能。\n![](f.jpg)\n\n# 解析与填充符号表\n解析步骤由上图中的parseFiles（）方法（过程1.1）完成，解析步骤包括了经典程序编译原理中的词法分析和语法分析两个过程。\n## 词法、语法分析\n词法分析是**将源代码的字符流转变为标记（Token）集合**，**单个字符**是**程序编写过程**的最小元素，而**标记**则是**编译过程**的最小元素，关键字、变量名、字面量、运算符都可以成为标记，如“int a=b+2”这句代码包含了6个标记，分别是int、a、=、b、+、2，虽然关键字int由3个字符构成，但是它只是一个Token，不可再拆分。在Javac的源码中，词法分析过程由com.sun.tools.javac.parser.Scanner类来实现。\n\n语法分析是**根据Token序列构造抽象语法树的过程**，抽象语法树（Abstract Syntax Tree,AST）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构（Construct），例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。\n\n在Javac的源码中，语法分析过程由com.sun.tools.javac.parser.Parser类实现，这个阶段产出的抽象语法树由com.sun.tools.javac.tree.JCTree类表示，**经过这个步骤之后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在抽象语法树之上**。\n## 填充符号表\n完成了语法分析和词法分析之后，下一步就是填充符号表的过程，也就是enterTrees（）方法（过程1.2）所做的事情。符号表（Symbol Table）**是由一组符号地址和符号信息构成的表格**，可以把它想象成哈希表中K-V值对的形式（实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等）。符号表中所登记的信息在编译的不同阶段都要用到\n。**在语义分析中，符号表所登记的内容将用于语义检查**（如检查一个名字的使用和原先的说明是否一致）和**产生中间代码**。在目标代码生成阶段，当对符号名进行地址分配时，**符号表是地址分配的依据。**\n\n在Javac源代码中，填充符号表的过程由com.sun.tools.javac.comp.Enter类实现，此过程的出口是一个待处理列表（To Do List），包含了每一个编译单元的抽象语法树的顶级节点，以及package-info.java（如果存在的话）的顶级节点。\n\n\n# 注解处理器\n在Javac源码中，*插入*式注解处理器的*初始化*过程是在\ninitPorcessAnnotations（）方法中完成的，而它的*执行过程*则是在processAnnotations（）方法中完成的，\n这个方法判断是否还有新的注解处理器需要执行，如果有的话，通过com.sun.tools.javac.processing.JavacProcessingEnvironment类的doProcessing（）方法生成一个新的JavaCompiler对象对编译的后续步骤进行处理。\n\n在JDK 1.5之后，Java语言提供了对注解（Annotation）的支持，这些注解与普通的Java代码一样，是在运行期间发挥作用的。在JDK 1.6中实现了JSR-269规范JSR-269：Pluggable Annotations Processing API（插入式注解处理API）。提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，我们可以把它看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round，也就是第一张图中的回环过程。 有了编译器注解处理的标准API后，我们的代码才有可能干涉编译器的行为，由于语法树中的任意元素，甚至包括代码注释都可以在插件之中访问到，所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间。只要有足够的创意，程序员可以使用插入式注解处理器来实现许多原本只能在编码中完成的事情。\n\n我们知道编译器在把Java程序源码编译为字节码的时候，会对Java程序源码做各方面的检查校验。这些校验主要以程序“写得对不对”为出发点，虽然也有各种WARNING的信息，但总体来讲还是较少去校验程序“写得好不好”。有鉴于此，业界出现了许多针对程序“写得好不好”的辅助校验工具，如CheckStyle、FindBug、Klocwork等。这些代码校验工具有一些是基于Java的源码进行校验，还有一些是通过扫描字节码来完成。我们将会使用注解处理器API来编写一款拥有自己编码风格的校验工具：NameCheckProcessor。\n\n## 代码实现\n要通过注解处理器API实现一个编译器插件，首先需要了解这组API的一些基本知识。我们实现注解处理器的代码需要继承抽象类javax.annotation.processing.AbstractProcessor，这个抽象类中只有一个必须覆盖的abstract方法：“process（）”，它是Javac编译器在执行注解处理器代码时要调用的过程，我们可以从这个方法的第一个参数“annotations”中获取到此注解处理器所要处理的注解集合，从第二个参数“roundEnv”中访问到当前这个Round中的语法树节点，每个语法树节点在这里表示为一个Element。在JDK 1.6新增的javax.lang.model包中定义了16类Element，包括了Java代码中最常用的元素，如：“包（PACKAGE）、枚举（ENUM）、类（CLASS）、注解（ANNOTATION_TYPE）、接口（INTERFACE）、枚举值（ENUM_CONSTANT）、字段（FIELD）、参数（PARAMETER）、本地变量（LOCAL_VARIABLE）、异常（EXCEPTION_PARAMETER）、方法（METHOD）、构造函数（CONSTRUCTOR）、静态语句块（STATIC_INIT，即static{}块）、实例语句块（INSTANCE_INIT，即{}块）、参数化类型（TYPE_PARAMETER，既泛型尖括号内的类型）和未定义的其他语法树节点（OTHER）”。除了process（）方法的传入参数之外，还有一个很常用的实例变量“processingEnv”，它是AbstractProcessor中的一个protected变量，在注解处理器初始化的时候（init（）方法执行的时候）创建，继承了AbstractProcessor的注解处理器代码可以直接访问到它。它代表了注解处理器框架提供的一个上下文环境，要创建新的代码、向编译器输出信息、获取其他工具类等都需要用到这个实例变量。注解处理器除了process（）方法及其参数之外，还有两个可以配合使用的Annotations：@SupportedAnnotationTypes和@SupportedSourceVersion，前者代表了这个注解处理器对哪些注解感兴趣，可以使用星号“*”作为通配符代表对所有的注解都感兴趣，后者指出这个注解处理器可以处理哪些版本的Java代码。\n\n每一个注解处理器在运行的时候都是单例的，如果不需要改变或生成语法树的内容，process（）方法就可以返回一个值为false的布尔值，通知编译器这个Round中的代码未发生变化，无须构造新的JavaCompiler实例，在这次实战的注解处理器中只对程序命名进行检查，不需要改变语法树的内容，因此process（）方法的返回值都是false。\n    \n    import javax.annotation.processing.*;\n    import javax.lang.model.SourceVersion;\n    import javax.lang.model.element.Element;\n    import javax.lang.model.element.TypeElement;\n    import java.util.Set;\n    \n    //可以用\"*\"表示支持所有Annotations\n    @SupportedAnnotationTypes(\"*\")\n    //只支持JDK 1.6的Java代码\n    @SupportedSourceVersion(SourceVersion.RELEASE_6)\n    public class NameCheckProcessor extends AbstractProcessor {\n        private NameChecker nameChecker;\n        /**\n         * 初始化名称检查插件\n         */\n        @Override\n        public void init(ProcessingEnvironment processingEnv){\n            super.init(processingEnv);\n            nameChecker = new NameChecker(processingEnv);\n        }\n        /**\n         * 对输入的语法树的各个节点进行名称检查\n         */\n        @Override\n        public boolean process(Set<? extends TypeElement> annotations,RoundEnvironment roundEnv){\n            if (!roundEnv.processingOver()) {\n                for (Element element:roundEnv.getRootElements())\n                nameChecker.checkNames(element);\n            }\n            return false;\n        }\n    }\n    import javax.annotation.processing.Messager;\n    import javax.annotation.processing.ProcessingEnvironment;\n    import javax.lang.model.element.*;\n    import javax.lang.model.util.ElementScanner6;\n    import javax.tools.Diagnostic;\n    import java.util.EnumSet;\n    \n    public class NameChecker {\n        private final Messager messager;\n        NameCheckScanner nameCheckScanner = new NameCheckScanner();\n    \n        NameChecker(ProcessingEnvironment processsingEnv) {\n            this.messager = processsingEnv.getMessager();\n        }\n    \n        /**\n         * 对Java程序命名进行检查,根据《Java语言规范(第3版)》第6.8节的要求,Java程序命名应当符合下列格式：\n         * <p/>\n         * <ul>\n         * <li>类或接口：符合驼式命名法,首字母大写。\n         * <li>方法：符合驼式命名法,首字母小写。\n         * <li>字段：\n         * <ul>\n         * <li>类、实例变量：符合驼式命名法,首字母小写。\n         * <li>常量：要求全部大写。\n         * </ul>\n         * </ul>\n         */\n        public void checkNames(Element element) {\n            nameCheckScanner.scan(element);\n        }\n        /**\n         * 名称检查器实现类,继承了JDK 1.6中新提供的ElementScanner6<br>\n         * 将会以Visitor模式访问抽象语法树中的元素\n         */\n        private class NameCheckScanner extends ElementScanner6<Void, Void> {\n            /**\n             * 此方法用于检查Java类\n             */\n            @Override\n            public Void visitType(TypeElement e, Void p) {\n                scan(e.getTypeParameters(), p);\n                checkCamelCase(e, true);\n                super.visitType(e, p);\n                return null;\n            }\n            /**\n             * 检查方法命名是否合法\n             */\n            @Override\n            public Void visitExecutable(ExecutableElement e, Void p) {\n                if (e.getKind() == ElementKind.METHOD) {\n                    Name name = e.getSimpleName();\n                    if\n                            (name.contentEquals(e.getEnclosingElement().getSimpleName()))\n                        messager.printMessage(Diagnostic.Kind.WARNING, \"一个普通方法'\" + name + \"'不应当与类名重复,避免与构造函数产生混淆\", e);\n                    checkCamelCase(e, false);\n                }\n                super.visitExecutable(e, p);\n                return null;\n            }\n            /**\n             * 检查变量命名是否合法\n             */\n            @Override\n            public Void visitVariable(VariableElement e, Void p) {\n                //如果这个Variable是枚举或常量,则按大写命名检查,否则按照驼式命名法规则检查\n                if (e.getKind() == ElementKind.ENUM_CONSTANT || e.getConstantValue() != null || heuristicallyConstant(e))\n                    checkAllCaps(e);\n                else\n                    checkCamelCase(e, false);\n                return null;\n            }\n    \n            /**\n             * 判断一个变量是否是常量\n             */\n            private boolean heuristicallyConstant(VariableElement e) {\n                if (e.getEnclosingElement().getKind() == ElementKind.INTERFACE)\n                    return true;\n                else if (e.getKind() == ElementKind.FIELD && e.getModifiers().containsAll(EnumSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)))\n                    return true;\n                else {\n                    return false;\n                }\n            }\n    \n            /**\n             * 检查传入的Element是否符合驼式命名法,如果不符合,则输出警告信息\n             */\n            private void checkCamelCase(Element e, boolean initialCaps) {\n                String name = e.getSimpleName().toString();\n                boolean previousUpper = false;\n                boolean conventional = true;\n                int firstCodePoint = name.codePointAt(0);\n                if (Character.isUpperCase(firstCodePoint)) {\n                    previousUpper = true;\n                    if (!initialCaps) {\n                        messager.printMessage(Diagnostic.Kind.WARNING, \"名称'\" + name + \"'应当以小写字母开头\", e);\n                        return;\n                    }\n                } else if (Character.isLowerCase(firstCodePoint)) {\n                    if (initialCaps) {\n                        messager.printMessage(Diagnostic.Kind.WARNING, \"名称'\" + name + \"'应当以大写字母开头\", e);\n                        return;\n                    }\n                } else\n                    conventional = false;\n                if (conventional) {\n                    int cp = firstCodePoint;\n                    for (int i = Character.charCount(cp); i < name.length(); i += Character.charCount(cp)) {\n                        cp = name.codePointAt(i);\n                        if (Character.isUpperCase(cp)) {\n                            if (previousUpper) {\n                                conventional = false;\n                                break;\n                            }\n                            previousUpper = true;\n                        } else\n                            previousUpper = false;\n                    }\n                }\n                if (!conventional)\n                    messager.printMessage(Diagnostic.Kind.WARNING, \"名称'\" + name + \"'应当符合驼式命名法(Camel Case Names)\", e);\n            }\n    \n            /**\n             * 大写命名检查,要求第一个字母必须是大写的英文字母,其余部分可以是下划线或大写字母\n             */\n            private void checkAllCaps(Element e) {\n                String name = e.getSimpleName().toString();\n                boolean conventional = true;\n                int firstCodePoint = name.codePointAt(0);\n                if (!Character.isUpperCase(firstCodePoint))\n                    conventional = false;\n                else {\n                    boolean previousUnderscore = false;\n                    int cp = firstCodePoint;\n                    for (int i = Character.charCount(cp); i < name.length(); i += Character.charCount(cp)) {\n                        cp = name.codePointAt(i);\n                        if (cp == (int) '_') {\n                            if (previousUnderscore) {\n                                conventional = false;\n                                break;\n                            }\n                            previousUnderscore = true;\n                        } else {\n                            previousUnderscore = false;\n                            if (!Character.isUpperCase(cp) && !Character.isDigit(cp)) {\n                                conventional = false;\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (!conventional)\n                    messager.printMessage(Diagnostic.Kind.WARNING, \"常量'\" + name + \"'应当全部以大写字母或下划线命名,并且以字母开头\", e);\n            }\n        }\n    }\n\n我们可以通过Javac命令的“-processor”参数来执行编译时需要附带的注解处理器，如果有多个注解处理器的话，用逗号分隔。还可以使用-XprintRounds和-XprintProcessorInfo参数来查看注解处理器运作的详细信息，javac -processor ***.NameCheckProcessor ***/test.java\n\n    test.java：3：警告：名称\"test\"应当符合驼式命名法（Camel Case Names）\n    public class test{\n    ^\n    test.java：5：警告：名称\"colors\"应当以大写字母开头\n    enum colors{\n    ^\n    test.java：6：警告：常量\"red\"应当全部以大写字母或下划线命名，并且以字母开头\n    red,blue,green；\n    ^\n    test.java：6：警告：常量\"blue\"应当全部以大写字母或下划线命名，并且以字母开头\n    red,blue,green；\n    ^\n    test.java：6：警告：常量\"green\"应当全部以大写字母或下划线命名，并且以字母开头\n    red,blue,green；\n    ^\n    test.java：9：警告：常量\"_FORTY_TWO\"应当全部以大写字母或下划线命名，并且以字母开头\n    static final int_FORTY_TWO=42；\n    ^\n    test.java：11：警告：名称\"NOT_A_CONSTANT\"应当以小写字母开头\n    public static int NOT_A_CONSTANT=_FORTY_TWO；\n    ^\n    test.java：13：警告：名称\"Test\"应当以小写字母开头\n    protected void Test（）{\n    ^\n    test.java：17：警告：名称\"NOTcamelCASEmethodNAME\"应当以小写字母开头\n    public void NOTcamelCASEmethodNAME（）{\n    ^\n    \nNameCheckProcessor的例子只演示了JSR-269嵌入式注解处理器API中的一部分功能，基于这组API支持的项目还有用于校验Hibernate标签使用正确性的Hibernate Validator Annotation Processorm自动为字段生成getter和setter方法的Project Lombok.\n\n# 语义分析\n语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。Javac的编译过程中，语义分析过程分为标注检查以及数据及控制流分析两个步骤，分别由上图中所示的attribute（）和flow（）方法（分别对应过程3.1和过程3.2）完成。\n\n##  标注检查\n标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。在标注检查步骤中，还有一个重要的动作称为常量折叠，如果我们在代码中写了如下定义：int a=1+2；那么在语法树上仍然能看到字面量“1”、“2”以及操作符“+”，但是在经过常量折叠之后，它们将会被折叠为字面量“3”，由于编译期间进行了常量折叠，所以在代码里面定义“a=1+2”比起直接定义“a=3”，并不会增加程序运行期哪怕仅仅一个CPU指令的运算量。\n\n## 数据及控制流分析\n在Javac的源码中，数据及控制流分析的入口是图中的flow（）方法（对应过程3.2），具体操作由com.sun.tools.javac.comp.Flow类来完成。\n\n数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只有在编译期或运行期才能进行。\n    \n    //方法一带有final修饰\n    public void foo（final int arg）{\n    final int var=0；\n    //do something\n    }\n    //方法二没有final修饰\n    public void foo（int arg）{\n    int var=0；\n    //do something\n    }\n    \n在这两个foo（）方法中，第一种方法的参数和局部变量定义使用了final修饰符，而第二种方法则没有，在代码编写时程序肯定会受到final修饰符的影响，不能再改变arg和var变量的值，但是这两段代码编译出来的Class文件是没有任何一点区别的，局部变量与字段（实例变量、类变量）是有区别的，它在常量池中没有CONSTANT_Fieldref_info的符号引用，自然就没有访问标志（Access_Flags）的信息，甚至可能连名称都不会保留下来（取决于编译时的选项），自然在Class文件中不可能知道一个局部变量是不是声明为final了。因此，将局部变量声明为final，对运行期是没有影响的，变量的不变性仅仅由编译器在编译期间保障。\n\n## 解语法糖\n在Javac的源码中，解语法糖的过程由desugar（）方法触发，在com.sun.tools.javac.comp.TransTypes类和com.sun.tools.javac.comp.Lower类中完成。\n\n语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说，使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。\n\nJava中最常用的语法糖主要是的泛型擦除（泛型并不一定都是语法糖实现，如C#的泛型就是直接由CLR支持的）、变长参数、自动装箱/拆箱,条件编译等，虚拟机运行时不支持这些语法，它们在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖。\n\n# 字节码生成\n字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面由com.sun.tools.javac.jvm.Gen类来完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。\n\n例如，实例构造器＜init＞（）方法和类构造器＜clinit＞（）方法就是在这个阶段添加到语法树之中的（注意，这里的实例构造器并不是指默认构造函数，如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、访问性（public、protected或private）与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成），这两个构造器的产生过程实际上是一个代码收敛的过程，编译器会把语句块（对于实例构造器而言是“{}”块，对于类构造器而言是“static{}”块）、变量初始化（实例变量和类变量）、调用父类的实例构造器等操作收敛到＜init＞（）和＜clinit＞（）方法之中，并且保证一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行，上面所述的动作由Gen.normalizeDefs（）方法来实现。除了生成构造器以外，还有其他的一些代码替换工作用于优化程序的实现逻辑，如把字符串的加操作替换为StringBuffer或StringBuilder的append（）操作等。\n\n完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交给com.sun.tools.javac.jvm.ClassWriter类，由这个类的writeClass（）方法输出字节码，生成最终的Class文件，到此为止整个编译过程宣告结束。\n\n[摘自](https://www.cnblogs.com/wade-luffy/p/6050331.html)\n","source":"_posts/Javac原理.md","raw":"---\ntitle: Javac原理\ndate: 2019-09-25 10:57:37\ntags: [java]\ncategories: [Java]\n---\n从Sun Javac的代码来看，编译过程大致可以分为3个过程:\n\n1. 解析与填充符号表过程。\n2. 插入式注解处理器的注解处理过程。\n3. 分析与字节码生成过程。\n![](j.jpg)\nJavac编译动作的入口是com.sun.tools.javac.main.JavaCompiler类，上述3个过程的代码逻辑集中在这个类的compile()和compile2()方法中，整个编译最关键的处理就由图中标注的8个方法来完成，下面我们具体看一下这8个方法实现了什么功能。\n![](f.jpg)\n\n# 解析与填充符号表\n解析步骤由上图中的parseFiles（）方法（过程1.1）完成，解析步骤包括了经典程序编译原理中的词法分析和语法分析两个过程。\n## 词法、语法分析\n词法分析是**将源代码的字符流转变为标记（Token）集合**，**单个字符**是**程序编写过程**的最小元素，而**标记**则是**编译过程**的最小元素，关键字、变量名、字面量、运算符都可以成为标记，如“int a=b+2”这句代码包含了6个标记，分别是int、a、=、b、+、2，虽然关键字int由3个字符构成，但是它只是一个Token，不可再拆分。在Javac的源码中，词法分析过程由com.sun.tools.javac.parser.Scanner类来实现。\n\n语法分析是**根据Token序列构造抽象语法树的过程**，抽象语法树（Abstract Syntax Tree,AST）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构（Construct），例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。\n\n在Javac的源码中，语法分析过程由com.sun.tools.javac.parser.Parser类实现，这个阶段产出的抽象语法树由com.sun.tools.javac.tree.JCTree类表示，**经过这个步骤之后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在抽象语法树之上**。\n## 填充符号表\n完成了语法分析和词法分析之后，下一步就是填充符号表的过程，也就是enterTrees（）方法（过程1.2）所做的事情。符号表（Symbol Table）**是由一组符号地址和符号信息构成的表格**，可以把它想象成哈希表中K-V值对的形式（实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等）。符号表中所登记的信息在编译的不同阶段都要用到\n。**在语义分析中，符号表所登记的内容将用于语义检查**（如检查一个名字的使用和原先的说明是否一致）和**产生中间代码**。在目标代码生成阶段，当对符号名进行地址分配时，**符号表是地址分配的依据。**\n\n在Javac源代码中，填充符号表的过程由com.sun.tools.javac.comp.Enter类实现，此过程的出口是一个待处理列表（To Do List），包含了每一个编译单元的抽象语法树的顶级节点，以及package-info.java（如果存在的话）的顶级节点。\n\n\n# 注解处理器\n在Javac源码中，*插入*式注解处理器的*初始化*过程是在\ninitPorcessAnnotations（）方法中完成的，而它的*执行过程*则是在processAnnotations（）方法中完成的，\n这个方法判断是否还有新的注解处理器需要执行，如果有的话，通过com.sun.tools.javac.processing.JavacProcessingEnvironment类的doProcessing（）方法生成一个新的JavaCompiler对象对编译的后续步骤进行处理。\n\n在JDK 1.5之后，Java语言提供了对注解（Annotation）的支持，这些注解与普通的Java代码一样，是在运行期间发挥作用的。在JDK 1.6中实现了JSR-269规范JSR-269：Pluggable Annotations Processing API（插入式注解处理API）。提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，我们可以把它看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round，也就是第一张图中的回环过程。 有了编译器注解处理的标准API后，我们的代码才有可能干涉编译器的行为，由于语法树中的任意元素，甚至包括代码注释都可以在插件之中访问到，所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间。只要有足够的创意，程序员可以使用插入式注解处理器来实现许多原本只能在编码中完成的事情。\n\n我们知道编译器在把Java程序源码编译为字节码的时候，会对Java程序源码做各方面的检查校验。这些校验主要以程序“写得对不对”为出发点，虽然也有各种WARNING的信息，但总体来讲还是较少去校验程序“写得好不好”。有鉴于此，业界出现了许多针对程序“写得好不好”的辅助校验工具，如CheckStyle、FindBug、Klocwork等。这些代码校验工具有一些是基于Java的源码进行校验，还有一些是通过扫描字节码来完成。我们将会使用注解处理器API来编写一款拥有自己编码风格的校验工具：NameCheckProcessor。\n\n## 代码实现\n要通过注解处理器API实现一个编译器插件，首先需要了解这组API的一些基本知识。我们实现注解处理器的代码需要继承抽象类javax.annotation.processing.AbstractProcessor，这个抽象类中只有一个必须覆盖的abstract方法：“process（）”，它是Javac编译器在执行注解处理器代码时要调用的过程，我们可以从这个方法的第一个参数“annotations”中获取到此注解处理器所要处理的注解集合，从第二个参数“roundEnv”中访问到当前这个Round中的语法树节点，每个语法树节点在这里表示为一个Element。在JDK 1.6新增的javax.lang.model包中定义了16类Element，包括了Java代码中最常用的元素，如：“包（PACKAGE）、枚举（ENUM）、类（CLASS）、注解（ANNOTATION_TYPE）、接口（INTERFACE）、枚举值（ENUM_CONSTANT）、字段（FIELD）、参数（PARAMETER）、本地变量（LOCAL_VARIABLE）、异常（EXCEPTION_PARAMETER）、方法（METHOD）、构造函数（CONSTRUCTOR）、静态语句块（STATIC_INIT，即static{}块）、实例语句块（INSTANCE_INIT，即{}块）、参数化类型（TYPE_PARAMETER，既泛型尖括号内的类型）和未定义的其他语法树节点（OTHER）”。除了process（）方法的传入参数之外，还有一个很常用的实例变量“processingEnv”，它是AbstractProcessor中的一个protected变量，在注解处理器初始化的时候（init（）方法执行的时候）创建，继承了AbstractProcessor的注解处理器代码可以直接访问到它。它代表了注解处理器框架提供的一个上下文环境，要创建新的代码、向编译器输出信息、获取其他工具类等都需要用到这个实例变量。注解处理器除了process（）方法及其参数之外，还有两个可以配合使用的Annotations：@SupportedAnnotationTypes和@SupportedSourceVersion，前者代表了这个注解处理器对哪些注解感兴趣，可以使用星号“*”作为通配符代表对所有的注解都感兴趣，后者指出这个注解处理器可以处理哪些版本的Java代码。\n\n每一个注解处理器在运行的时候都是单例的，如果不需要改变或生成语法树的内容，process（）方法就可以返回一个值为false的布尔值，通知编译器这个Round中的代码未发生变化，无须构造新的JavaCompiler实例，在这次实战的注解处理器中只对程序命名进行检查，不需要改变语法树的内容，因此process（）方法的返回值都是false。\n    \n    import javax.annotation.processing.*;\n    import javax.lang.model.SourceVersion;\n    import javax.lang.model.element.Element;\n    import javax.lang.model.element.TypeElement;\n    import java.util.Set;\n    \n    //可以用\"*\"表示支持所有Annotations\n    @SupportedAnnotationTypes(\"*\")\n    //只支持JDK 1.6的Java代码\n    @SupportedSourceVersion(SourceVersion.RELEASE_6)\n    public class NameCheckProcessor extends AbstractProcessor {\n        private NameChecker nameChecker;\n        /**\n         * 初始化名称检查插件\n         */\n        @Override\n        public void init(ProcessingEnvironment processingEnv){\n            super.init(processingEnv);\n            nameChecker = new NameChecker(processingEnv);\n        }\n        /**\n         * 对输入的语法树的各个节点进行名称检查\n         */\n        @Override\n        public boolean process(Set<? extends TypeElement> annotations,RoundEnvironment roundEnv){\n            if (!roundEnv.processingOver()) {\n                for (Element element:roundEnv.getRootElements())\n                nameChecker.checkNames(element);\n            }\n            return false;\n        }\n    }\n    import javax.annotation.processing.Messager;\n    import javax.annotation.processing.ProcessingEnvironment;\n    import javax.lang.model.element.*;\n    import javax.lang.model.util.ElementScanner6;\n    import javax.tools.Diagnostic;\n    import java.util.EnumSet;\n    \n    public class NameChecker {\n        private final Messager messager;\n        NameCheckScanner nameCheckScanner = new NameCheckScanner();\n    \n        NameChecker(ProcessingEnvironment processsingEnv) {\n            this.messager = processsingEnv.getMessager();\n        }\n    \n        /**\n         * 对Java程序命名进行检查,根据《Java语言规范(第3版)》第6.8节的要求,Java程序命名应当符合下列格式：\n         * <p/>\n         * <ul>\n         * <li>类或接口：符合驼式命名法,首字母大写。\n         * <li>方法：符合驼式命名法,首字母小写。\n         * <li>字段：\n         * <ul>\n         * <li>类、实例变量：符合驼式命名法,首字母小写。\n         * <li>常量：要求全部大写。\n         * </ul>\n         * </ul>\n         */\n        public void checkNames(Element element) {\n            nameCheckScanner.scan(element);\n        }\n        /**\n         * 名称检查器实现类,继承了JDK 1.6中新提供的ElementScanner6<br>\n         * 将会以Visitor模式访问抽象语法树中的元素\n         */\n        private class NameCheckScanner extends ElementScanner6<Void, Void> {\n            /**\n             * 此方法用于检查Java类\n             */\n            @Override\n            public Void visitType(TypeElement e, Void p) {\n                scan(e.getTypeParameters(), p);\n                checkCamelCase(e, true);\n                super.visitType(e, p);\n                return null;\n            }\n            /**\n             * 检查方法命名是否合法\n             */\n            @Override\n            public Void visitExecutable(ExecutableElement e, Void p) {\n                if (e.getKind() == ElementKind.METHOD) {\n                    Name name = e.getSimpleName();\n                    if\n                            (name.contentEquals(e.getEnclosingElement().getSimpleName()))\n                        messager.printMessage(Diagnostic.Kind.WARNING, \"一个普通方法'\" + name + \"'不应当与类名重复,避免与构造函数产生混淆\", e);\n                    checkCamelCase(e, false);\n                }\n                super.visitExecutable(e, p);\n                return null;\n            }\n            /**\n             * 检查变量命名是否合法\n             */\n            @Override\n            public Void visitVariable(VariableElement e, Void p) {\n                //如果这个Variable是枚举或常量,则按大写命名检查,否则按照驼式命名法规则检查\n                if (e.getKind() == ElementKind.ENUM_CONSTANT || e.getConstantValue() != null || heuristicallyConstant(e))\n                    checkAllCaps(e);\n                else\n                    checkCamelCase(e, false);\n                return null;\n            }\n    \n            /**\n             * 判断一个变量是否是常量\n             */\n            private boolean heuristicallyConstant(VariableElement e) {\n                if (e.getEnclosingElement().getKind() == ElementKind.INTERFACE)\n                    return true;\n                else if (e.getKind() == ElementKind.FIELD && e.getModifiers().containsAll(EnumSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)))\n                    return true;\n                else {\n                    return false;\n                }\n            }\n    \n            /**\n             * 检查传入的Element是否符合驼式命名法,如果不符合,则输出警告信息\n             */\n            private void checkCamelCase(Element e, boolean initialCaps) {\n                String name = e.getSimpleName().toString();\n                boolean previousUpper = false;\n                boolean conventional = true;\n                int firstCodePoint = name.codePointAt(0);\n                if (Character.isUpperCase(firstCodePoint)) {\n                    previousUpper = true;\n                    if (!initialCaps) {\n                        messager.printMessage(Diagnostic.Kind.WARNING, \"名称'\" + name + \"'应当以小写字母开头\", e);\n                        return;\n                    }\n                } else if (Character.isLowerCase(firstCodePoint)) {\n                    if (initialCaps) {\n                        messager.printMessage(Diagnostic.Kind.WARNING, \"名称'\" + name + \"'应当以大写字母开头\", e);\n                        return;\n                    }\n                } else\n                    conventional = false;\n                if (conventional) {\n                    int cp = firstCodePoint;\n                    for (int i = Character.charCount(cp); i < name.length(); i += Character.charCount(cp)) {\n                        cp = name.codePointAt(i);\n                        if (Character.isUpperCase(cp)) {\n                            if (previousUpper) {\n                                conventional = false;\n                                break;\n                            }\n                            previousUpper = true;\n                        } else\n                            previousUpper = false;\n                    }\n                }\n                if (!conventional)\n                    messager.printMessage(Diagnostic.Kind.WARNING, \"名称'\" + name + \"'应当符合驼式命名法(Camel Case Names)\", e);\n            }\n    \n            /**\n             * 大写命名检查,要求第一个字母必须是大写的英文字母,其余部分可以是下划线或大写字母\n             */\n            private void checkAllCaps(Element e) {\n                String name = e.getSimpleName().toString();\n                boolean conventional = true;\n                int firstCodePoint = name.codePointAt(0);\n                if (!Character.isUpperCase(firstCodePoint))\n                    conventional = false;\n                else {\n                    boolean previousUnderscore = false;\n                    int cp = firstCodePoint;\n                    for (int i = Character.charCount(cp); i < name.length(); i += Character.charCount(cp)) {\n                        cp = name.codePointAt(i);\n                        if (cp == (int) '_') {\n                            if (previousUnderscore) {\n                                conventional = false;\n                                break;\n                            }\n                            previousUnderscore = true;\n                        } else {\n                            previousUnderscore = false;\n                            if (!Character.isUpperCase(cp) && !Character.isDigit(cp)) {\n                                conventional = false;\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (!conventional)\n                    messager.printMessage(Diagnostic.Kind.WARNING, \"常量'\" + name + \"'应当全部以大写字母或下划线命名,并且以字母开头\", e);\n            }\n        }\n    }\n\n我们可以通过Javac命令的“-processor”参数来执行编译时需要附带的注解处理器，如果有多个注解处理器的话，用逗号分隔。还可以使用-XprintRounds和-XprintProcessorInfo参数来查看注解处理器运作的详细信息，javac -processor ***.NameCheckProcessor ***/test.java\n\n    test.java：3：警告：名称\"test\"应当符合驼式命名法（Camel Case Names）\n    public class test{\n    ^\n    test.java：5：警告：名称\"colors\"应当以大写字母开头\n    enum colors{\n    ^\n    test.java：6：警告：常量\"red\"应当全部以大写字母或下划线命名，并且以字母开头\n    red,blue,green；\n    ^\n    test.java：6：警告：常量\"blue\"应当全部以大写字母或下划线命名，并且以字母开头\n    red,blue,green；\n    ^\n    test.java：6：警告：常量\"green\"应当全部以大写字母或下划线命名，并且以字母开头\n    red,blue,green；\n    ^\n    test.java：9：警告：常量\"_FORTY_TWO\"应当全部以大写字母或下划线命名，并且以字母开头\n    static final int_FORTY_TWO=42；\n    ^\n    test.java：11：警告：名称\"NOT_A_CONSTANT\"应当以小写字母开头\n    public static int NOT_A_CONSTANT=_FORTY_TWO；\n    ^\n    test.java：13：警告：名称\"Test\"应当以小写字母开头\n    protected void Test（）{\n    ^\n    test.java：17：警告：名称\"NOTcamelCASEmethodNAME\"应当以小写字母开头\n    public void NOTcamelCASEmethodNAME（）{\n    ^\n    \nNameCheckProcessor的例子只演示了JSR-269嵌入式注解处理器API中的一部分功能，基于这组API支持的项目还有用于校验Hibernate标签使用正确性的Hibernate Validator Annotation Processorm自动为字段生成getter和setter方法的Project Lombok.\n\n# 语义分析\n语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。Javac的编译过程中，语义分析过程分为标注检查以及数据及控制流分析两个步骤，分别由上图中所示的attribute（）和flow（）方法（分别对应过程3.1和过程3.2）完成。\n\n##  标注检查\n标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。在标注检查步骤中，还有一个重要的动作称为常量折叠，如果我们在代码中写了如下定义：int a=1+2；那么在语法树上仍然能看到字面量“1”、“2”以及操作符“+”，但是在经过常量折叠之后，它们将会被折叠为字面量“3”，由于编译期间进行了常量折叠，所以在代码里面定义“a=1+2”比起直接定义“a=3”，并不会增加程序运行期哪怕仅仅一个CPU指令的运算量。\n\n## 数据及控制流分析\n在Javac的源码中，数据及控制流分析的入口是图中的flow（）方法（对应过程3.2），具体操作由com.sun.tools.javac.comp.Flow类来完成。\n\n数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只有在编译期或运行期才能进行。\n    \n    //方法一带有final修饰\n    public void foo（final int arg）{\n    final int var=0；\n    //do something\n    }\n    //方法二没有final修饰\n    public void foo（int arg）{\n    int var=0；\n    //do something\n    }\n    \n在这两个foo（）方法中，第一种方法的参数和局部变量定义使用了final修饰符，而第二种方法则没有，在代码编写时程序肯定会受到final修饰符的影响，不能再改变arg和var变量的值，但是这两段代码编译出来的Class文件是没有任何一点区别的，局部变量与字段（实例变量、类变量）是有区别的，它在常量池中没有CONSTANT_Fieldref_info的符号引用，自然就没有访问标志（Access_Flags）的信息，甚至可能连名称都不会保留下来（取决于编译时的选项），自然在Class文件中不可能知道一个局部变量是不是声明为final了。因此，将局部变量声明为final，对运行期是没有影响的，变量的不变性仅仅由编译器在编译期间保障。\n\n## 解语法糖\n在Javac的源码中，解语法糖的过程由desugar（）方法触发，在com.sun.tools.javac.comp.TransTypes类和com.sun.tools.javac.comp.Lower类中完成。\n\n语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说，使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。\n\nJava中最常用的语法糖主要是的泛型擦除（泛型并不一定都是语法糖实现，如C#的泛型就是直接由CLR支持的）、变长参数、自动装箱/拆箱,条件编译等，虚拟机运行时不支持这些语法，它们在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖。\n\n# 字节码生成\n字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面由com.sun.tools.javac.jvm.Gen类来完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。\n\n例如，实例构造器＜init＞（）方法和类构造器＜clinit＞（）方法就是在这个阶段添加到语法树之中的（注意，这里的实例构造器并不是指默认构造函数，如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、访问性（public、protected或private）与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成），这两个构造器的产生过程实际上是一个代码收敛的过程，编译器会把语句块（对于实例构造器而言是“{}”块，对于类构造器而言是“static{}”块）、变量初始化（实例变量和类变量）、调用父类的实例构造器等操作收敛到＜init＞（）和＜clinit＞（）方法之中，并且保证一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行，上面所述的动作由Gen.normalizeDefs（）方法来实现。除了生成构造器以外，还有其他的一些代码替换工作用于优化程序的实现逻辑，如把字符串的加操作替换为StringBuffer或StringBuilder的append（）操作等。\n\n完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交给com.sun.tools.javac.jvm.ClassWriter类，由这个类的writeClass（）方法输出字节码，生成最终的Class文件，到此为止整个编译过程宣告结束。\n\n[摘自](https://www.cnblogs.com/wade-luffy/p/6050331.html)\n","slug":"Javac原理","published":1,"updated":"2019-09-27T08:27:08.024Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecn000cojfydo4f4w5j","content":"<p>从Sun Javac的代码来看，编译过程大致可以分为3个过程:</p>\n<ol>\n<li>解析与填充符号表过程。</li>\n<li>插入式注解处理器的注解处理过程。</li>\n<li>分析与字节码生成过程。<br><img src=\"j.jpg\" alt><br>Javac编译动作的入口是com.sun.tools.javac.main.JavaCompiler类，上述3个过程的代码逻辑集中在这个类的compile()和compile2()方法中，整个编译最关键的处理就由图中标注的8个方法来完成，下面我们具体看一下这8个方法实现了什么功能。<br><img src=\"f.jpg\" alt></li>\n</ol>\n<h1 id=\"解析与填充符号表\"><a href=\"#解析与填充符号表\" class=\"headerlink\" title=\"解析与填充符号表\"></a>解析与填充符号表</h1><p>解析步骤由上图中的parseFiles（）方法（过程1.1）完成，解析步骤包括了经典程序编译原理中的词法分析和语法分析两个过程。</p>\n<h2 id=\"词法、语法分析\"><a href=\"#词法、语法分析\" class=\"headerlink\" title=\"词法、语法分析\"></a>词法、语法分析</h2><p>词法分析是<strong>将源代码的字符流转变为标记（Token）集合</strong>，<strong>单个字符</strong>是<strong>程序编写过程</strong>的最小元素，而<strong>标记</strong>则是<strong>编译过程</strong>的最小元素，关键字、变量名、字面量、运算符都可以成为标记，如“int a=b+2”这句代码包含了6个标记，分别是int、a、=、b、+、2，虽然关键字int由3个字符构成，但是它只是一个Token，不可再拆分。在Javac的源码中，词法分析过程由com.sun.tools.javac.parser.Scanner类来实现。</p>\n<p>语法分析是<strong>根据Token序列构造抽象语法树的过程</strong>，抽象语法树（Abstract Syntax Tree,AST）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构（Construct），例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。</p>\n<p>在Javac的源码中，语法分析过程由com.sun.tools.javac.parser.Parser类实现，这个阶段产出的抽象语法树由com.sun.tools.javac.tree.JCTree类表示，<strong>经过这个步骤之后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在抽象语法树之上</strong>。</p>\n<h2 id=\"填充符号表\"><a href=\"#填充符号表\" class=\"headerlink\" title=\"填充符号表\"></a>填充符号表</h2><p>完成了语法分析和词法分析之后，下一步就是填充符号表的过程，也就是enterTrees（）方法（过程1.2）所做的事情。符号表（Symbol Table）<strong>是由一组符号地址和符号信息构成的表格</strong>，可以把它想象成哈希表中K-V值对的形式（实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等）。符号表中所登记的信息在编译的不同阶段都要用到<br>。<strong>在语义分析中，符号表所登记的内容将用于语义检查</strong>（如检查一个名字的使用和原先的说明是否一致）和<strong>产生中间代码</strong>。在目标代码生成阶段，当对符号名进行地址分配时，<strong>符号表是地址分配的依据。</strong></p>\n<p>在Javac源代码中，填充符号表的过程由com.sun.tools.javac.comp.Enter类实现，此过程的出口是一个待处理列表（To Do List），包含了每一个编译单元的抽象语法树的顶级节点，以及package-info.java（如果存在的话）的顶级节点。</p>\n<h1 id=\"注解处理器\"><a href=\"#注解处理器\" class=\"headerlink\" title=\"注解处理器\"></a>注解处理器</h1><p>在Javac源码中，<em>插入</em>式注解处理器的<em>初始化</em>过程是在<br>initPorcessAnnotations（）方法中完成的，而它的<em>执行过程</em>则是在processAnnotations（）方法中完成的，<br>这个方法判断是否还有新的注解处理器需要执行，如果有的话，通过com.sun.tools.javac.processing.JavacProcessingEnvironment类的doProcessing（）方法生成一个新的JavaCompiler对象对编译的后续步骤进行处理。</p>\n<p>在JDK 1.5之后，Java语言提供了对注解（Annotation）的支持，这些注解与普通的Java代码一样，是在运行期间发挥作用的。在JDK 1.6中实现了JSR-269规范JSR-269：Pluggable Annotations Processing API（插入式注解处理API）。提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，我们可以把它看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round，也就是第一张图中的回环过程。 有了编译器注解处理的标准API后，我们的代码才有可能干涉编译器的行为，由于语法树中的任意元素，甚至包括代码注释都可以在插件之中访问到，所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间。只要有足够的创意，程序员可以使用插入式注解处理器来实现许多原本只能在编码中完成的事情。</p>\n<p>我们知道编译器在把Java程序源码编译为字节码的时候，会对Java程序源码做各方面的检查校验。这些校验主要以程序“写得对不对”为出发点，虽然也有各种WARNING的信息，但总体来讲还是较少去校验程序“写得好不好”。有鉴于此，业界出现了许多针对程序“写得好不好”的辅助校验工具，如CheckStyle、FindBug、Klocwork等。这些代码校验工具有一些是基于Java的源码进行校验，还有一些是通过扫描字节码来完成。我们将会使用注解处理器API来编写一款拥有自己编码风格的校验工具：NameCheckProcessor。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>要通过注解处理器API实现一个编译器插件，首先需要了解这组API的一些基本知识。我们实现注解处理器的代码需要继承抽象类javax.annotation.processing.AbstractProcessor，这个抽象类中只有一个必须覆盖的abstract方法：“process（）”，它是Javac编译器在执行注解处理器代码时要调用的过程，我们可以从这个方法的第一个参数“annotations”中获取到此注解处理器所要处理的注解集合，从第二个参数“roundEnv”中访问到当前这个Round中的语法树节点，每个语法树节点在这里表示为一个Element。在JDK 1.6新增的javax.lang.model包中定义了16类Element，包括了Java代码中最常用的元素，如：“包（PACKAGE）、枚举（ENUM）、类（CLASS）、注解（ANNOTATION_TYPE）、接口（INTERFACE）、枚举值（ENUM_CONSTANT）、字段（FIELD）、参数（PARAMETER）、本地变量（LOCAL_VARIABLE）、异常（EXCEPTION_PARAMETER）、方法（METHOD）、构造函数（CONSTRUCTOR）、静态语句块（STATIC_INIT，即static{}块）、实例语句块（INSTANCE_INIT，即{}块）、参数化类型（TYPE_PARAMETER，既泛型尖括号内的类型）和未定义的其他语法树节点（OTHER）”。除了process（）方法的传入参数之外，还有一个很常用的实例变量“processingEnv”，它是AbstractProcessor中的一个protected变量，在注解处理器初始化的时候（init（）方法执行的时候）创建，继承了AbstractProcessor的注解处理器代码可以直接访问到它。它代表了注解处理器框架提供的一个上下文环境，要创建新的代码、向编译器输出信息、获取其他工具类等都需要用到这个实例变量。注解处理器除了process（）方法及其参数之外，还有两个可以配合使用的Annotations：@SupportedAnnotationTypes和@SupportedSourceVersion，前者代表了这个注解处理器对哪些注解感兴趣，可以使用星号“*”作为通配符代表对所有的注解都感兴趣，后者指出这个注解处理器可以处理哪些版本的Java代码。</p>\n<p>每一个注解处理器在运行的时候都是单例的，如果不需要改变或生成语法树的内容，process（）方法就可以返回一个值为false的布尔值，通知编译器这个Round中的代码未发生变化，无须构造新的JavaCompiler实例，在这次实战的注解处理器中只对程序命名进行检查，不需要改变语法树的内容，因此process（）方法的返回值都是false。</p>\n<pre><code>import javax.annotation.processing.*;\nimport javax.lang.model.SourceVersion;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.TypeElement;\nimport java.util.Set;\n\n//可以用&quot;*&quot;表示支持所有Annotations\n@SupportedAnnotationTypes(&quot;*&quot;)\n//只支持JDK 1.6的Java代码\n@SupportedSourceVersion(SourceVersion.RELEASE_6)\npublic class NameCheckProcessor extends AbstractProcessor {\n    private NameChecker nameChecker;\n    /**\n     * 初始化名称检查插件\n     */\n    @Override\n    public void init(ProcessingEnvironment processingEnv){\n        super.init(processingEnv);\n        nameChecker = new NameChecker(processingEnv);\n    }\n    /**\n     * 对输入的语法树的各个节点进行名称检查\n     */\n    @Override\n    public boolean process(Set&lt;? extends TypeElement&gt; annotations,RoundEnvironment roundEnv){\n        if (!roundEnv.processingOver()) {\n            for (Element element:roundEnv.getRootElements())\n            nameChecker.checkNames(element);\n        }\n        return false;\n    }\n}\nimport javax.annotation.processing.Messager;\nimport javax.annotation.processing.ProcessingEnvironment;\nimport javax.lang.model.element.*;\nimport javax.lang.model.util.ElementScanner6;\nimport javax.tools.Diagnostic;\nimport java.util.EnumSet;\n\npublic class NameChecker {\n    private final Messager messager;\n    NameCheckScanner nameCheckScanner = new NameCheckScanner();\n\n    NameChecker(ProcessingEnvironment processsingEnv) {\n        this.messager = processsingEnv.getMessager();\n    }\n\n    /**\n     * 对Java程序命名进行检查,根据《Java语言规范(第3版)》第6.8节的要求,Java程序命名应当符合下列格式：\n     * &lt;p/&gt;\n     * &lt;ul&gt;\n     * &lt;li&gt;类或接口：符合驼式命名法,首字母大写。\n     * &lt;li&gt;方法：符合驼式命名法,首字母小写。\n     * &lt;li&gt;字段：\n     * &lt;ul&gt;\n     * &lt;li&gt;类、实例变量：符合驼式命名法,首字母小写。\n     * &lt;li&gt;常量：要求全部大写。\n     * &lt;/ul&gt;\n     * &lt;/ul&gt;\n     */\n    public void checkNames(Element element) {\n        nameCheckScanner.scan(element);\n    }\n    /**\n     * 名称检查器实现类,继承了JDK 1.6中新提供的ElementScanner6&lt;br&gt;\n     * 将会以Visitor模式访问抽象语法树中的元素\n     */\n    private class NameCheckScanner extends ElementScanner6&lt;Void, Void&gt; {\n        /**\n         * 此方法用于检查Java类\n         */\n        @Override\n        public Void visitType(TypeElement e, Void p) {\n            scan(e.getTypeParameters(), p);\n            checkCamelCase(e, true);\n            super.visitType(e, p);\n            return null;\n        }\n        /**\n         * 检查方法命名是否合法\n         */\n        @Override\n        public Void visitExecutable(ExecutableElement e, Void p) {\n            if (e.getKind() == ElementKind.METHOD) {\n                Name name = e.getSimpleName();\n                if\n                        (name.contentEquals(e.getEnclosingElement().getSimpleName()))\n                    messager.printMessage(Diagnostic.Kind.WARNING, &quot;一个普通方法&apos;&quot; + name + &quot;&apos;不应当与类名重复,避免与构造函数产生混淆&quot;, e);\n                checkCamelCase(e, false);\n            }\n            super.visitExecutable(e, p);\n            return null;\n        }\n        /**\n         * 检查变量命名是否合法\n         */\n        @Override\n        public Void visitVariable(VariableElement e, Void p) {\n            //如果这个Variable是枚举或常量,则按大写命名检查,否则按照驼式命名法规则检查\n            if (e.getKind() == ElementKind.ENUM_CONSTANT || e.getConstantValue() != null || heuristicallyConstant(e))\n                checkAllCaps(e);\n            else\n                checkCamelCase(e, false);\n            return null;\n        }\n\n        /**\n         * 判断一个变量是否是常量\n         */\n        private boolean heuristicallyConstant(VariableElement e) {\n            if (e.getEnclosingElement().getKind() == ElementKind.INTERFACE)\n                return true;\n            else if (e.getKind() == ElementKind.FIELD &amp;&amp; e.getModifiers().containsAll(EnumSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)))\n                return true;\n            else {\n                return false;\n            }\n        }\n\n        /**\n         * 检查传入的Element是否符合驼式命名法,如果不符合,则输出警告信息\n         */\n        private void checkCamelCase(Element e, boolean initialCaps) {\n            String name = e.getSimpleName().toString();\n            boolean previousUpper = false;\n            boolean conventional = true;\n            int firstCodePoint = name.codePointAt(0);\n            if (Character.isUpperCase(firstCodePoint)) {\n                previousUpper = true;\n                if (!initialCaps) {\n                    messager.printMessage(Diagnostic.Kind.WARNING, &quot;名称&apos;&quot; + name + &quot;&apos;应当以小写字母开头&quot;, e);\n                    return;\n                }\n            } else if (Character.isLowerCase(firstCodePoint)) {\n                if (initialCaps) {\n                    messager.printMessage(Diagnostic.Kind.WARNING, &quot;名称&apos;&quot; + name + &quot;&apos;应当以大写字母开头&quot;, e);\n                    return;\n                }\n            } else\n                conventional = false;\n            if (conventional) {\n                int cp = firstCodePoint;\n                for (int i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) {\n                    cp = name.codePointAt(i);\n                    if (Character.isUpperCase(cp)) {\n                        if (previousUpper) {\n                            conventional = false;\n                            break;\n                        }\n                        previousUpper = true;\n                    } else\n                        previousUpper = false;\n                }\n            }\n            if (!conventional)\n                messager.printMessage(Diagnostic.Kind.WARNING, &quot;名称&apos;&quot; + name + &quot;&apos;应当符合驼式命名法(Camel Case Names)&quot;, e);\n        }\n\n        /**\n         * 大写命名检查,要求第一个字母必须是大写的英文字母,其余部分可以是下划线或大写字母\n         */\n        private void checkAllCaps(Element e) {\n            String name = e.getSimpleName().toString();\n            boolean conventional = true;\n            int firstCodePoint = name.codePointAt(0);\n            if (!Character.isUpperCase(firstCodePoint))\n                conventional = false;\n            else {\n                boolean previousUnderscore = false;\n                int cp = firstCodePoint;\n                for (int i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) {\n                    cp = name.codePointAt(i);\n                    if (cp == (int) &apos;_&apos;) {\n                        if (previousUnderscore) {\n                            conventional = false;\n                            break;\n                        }\n                        previousUnderscore = true;\n                    } else {\n                        previousUnderscore = false;\n                        if (!Character.isUpperCase(cp) &amp;&amp; !Character.isDigit(cp)) {\n                            conventional = false;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!conventional)\n                messager.printMessage(Diagnostic.Kind.WARNING, &quot;常量&apos;&quot; + name + &quot;&apos;应当全部以大写字母或下划线命名,并且以字母开头&quot;, e);\n        }\n    }\n}</code></pre><p>我们可以通过Javac命令的“-processor”参数来执行编译时需要附带的注解处理器，如果有多个注解处理器的话，用逗号分隔。还可以使用-XprintRounds和-XprintProcessorInfo参数来查看注解处理器运作的详细信息，javac -processor <strong>*.NameCheckProcessor *</strong>/test.java</p>\n<pre><code>test.java：3：警告：名称&quot;test&quot;应当符合驼式命名法（Camel Case Names）\npublic class test{\n^\ntest.java：5：警告：名称&quot;colors&quot;应当以大写字母开头\nenum colors{\n^\ntest.java：6：警告：常量&quot;red&quot;应当全部以大写字母或下划线命名，并且以字母开头\nred,blue,green；\n^\ntest.java：6：警告：常量&quot;blue&quot;应当全部以大写字母或下划线命名，并且以字母开头\nred,blue,green；\n^\ntest.java：6：警告：常量&quot;green&quot;应当全部以大写字母或下划线命名，并且以字母开头\nred,blue,green；\n^\ntest.java：9：警告：常量&quot;_FORTY_TWO&quot;应当全部以大写字母或下划线命名，并且以字母开头\nstatic final int_FORTY_TWO=42；\n^\ntest.java：11：警告：名称&quot;NOT_A_CONSTANT&quot;应当以小写字母开头\npublic static int NOT_A_CONSTANT=_FORTY_TWO；\n^\ntest.java：13：警告：名称&quot;Test&quot;应当以小写字母开头\nprotected void Test（）{\n^\ntest.java：17：警告：名称&quot;NOTcamelCASEmethodNAME&quot;应当以小写字母开头\npublic void NOTcamelCASEmethodNAME（）{\n^</code></pre><p>NameCheckProcessor的例子只演示了JSR-269嵌入式注解处理器API中的一部分功能，基于这组API支持的项目还有用于校验Hibernate标签使用正确性的Hibernate Validator Annotation Processorm自动为字段生成getter和setter方法的Project Lombok.</p>\n<h1 id=\"语义分析\"><a href=\"#语义分析\" class=\"headerlink\" title=\"语义分析\"></a>语义分析</h1><p>语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。Javac的编译过程中，语义分析过程分为标注检查以及数据及控制流分析两个步骤，分别由上图中所示的attribute（）和flow（）方法（分别对应过程3.1和过程3.2）完成。</p>\n<h2 id=\"标注检查\"><a href=\"#标注检查\" class=\"headerlink\" title=\"标注检查\"></a>标注检查</h2><p>标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。在标注检查步骤中，还有一个重要的动作称为常量折叠，如果我们在代码中写了如下定义：int a=1+2；那么在语法树上仍然能看到字面量“1”、“2”以及操作符“+”，但是在经过常量折叠之后，它们将会被折叠为字面量“3”，由于编译期间进行了常量折叠，所以在代码里面定义“a=1+2”比起直接定义“a=3”，并不会增加程序运行期哪怕仅仅一个CPU指令的运算量。</p>\n<h2 id=\"数据及控制流分析\"><a href=\"#数据及控制流分析\" class=\"headerlink\" title=\"数据及控制流分析\"></a>数据及控制流分析</h2><p>在Javac的源码中，数据及控制流分析的入口是图中的flow（）方法（对应过程3.2），具体操作由com.sun.tools.javac.comp.Flow类来完成。</p>\n<p>数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只有在编译期或运行期才能进行。</p>\n<pre><code>//方法一带有final修饰\npublic void foo（final int arg）{\nfinal int var=0；\n//do something\n}\n//方法二没有final修饰\npublic void foo（int arg）{\nint var=0；\n//do something\n}</code></pre><p>在这两个foo（）方法中，第一种方法的参数和局部变量定义使用了final修饰符，而第二种方法则没有，在代码编写时程序肯定会受到final修饰符的影响，不能再改变arg和var变量的值，但是这两段代码编译出来的Class文件是没有任何一点区别的，局部变量与字段（实例变量、类变量）是有区别的，它在常量池中没有CONSTANT_Fieldref_info的符号引用，自然就没有访问标志（Access_Flags）的信息，甚至可能连名称都不会保留下来（取决于编译时的选项），自然在Class文件中不可能知道一个局部变量是不是声明为final了。因此，将局部变量声明为final，对运行期是没有影响的，变量的不变性仅仅由编译器在编译期间保障。</p>\n<h2 id=\"解语法糖\"><a href=\"#解语法糖\" class=\"headerlink\" title=\"解语法糖\"></a>解语法糖</h2><p>在Javac的源码中，解语法糖的过程由desugar（）方法触发，在com.sun.tools.javac.comp.TransTypes类和com.sun.tools.javac.comp.Lower类中完成。</p>\n<p>语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说，使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p>\n<p>Java中最常用的语法糖主要是的泛型擦除（泛型并不一定都是语法糖实现，如C#的泛型就是直接由CLR支持的）、变长参数、自动装箱/拆箱,条件编译等，虚拟机运行时不支持这些语法，它们在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖。</p>\n<h1 id=\"字节码生成\"><a href=\"#字节码生成\" class=\"headerlink\" title=\"字节码生成\"></a>字节码生成</h1><p>字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面由com.sun.tools.javac.jvm.Gen类来完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。</p>\n<p>例如，实例构造器＜init＞（）方法和类构造器＜clinit＞（）方法就是在这个阶段添加到语法树之中的（注意，这里的实例构造器并不是指默认构造函数，如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、访问性（public、protected或private）与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成），这两个构造器的产生过程实际上是一个代码收敛的过程，编译器会把语句块（对于实例构造器而言是“{}”块，对于类构造器而言是“static{}”块）、变量初始化（实例变量和类变量）、调用父类的实例构造器等操作收敛到＜init＞（）和＜clinit＞（）方法之中，并且保证一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行，上面所述的动作由Gen.normalizeDefs（）方法来实现。除了生成构造器以外，还有其他的一些代码替换工作用于优化程序的实现逻辑，如把字符串的加操作替换为StringBuffer或StringBuilder的append（）操作等。</p>\n<p>完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交给com.sun.tools.javac.jvm.ClassWriter类，由这个类的writeClass（）方法输出字节码，生成最终的Class文件，到此为止整个编译过程宣告结束。</p>\n<p><a href=\"https://www.cnblogs.com/wade-luffy/p/6050331.html\" target=\"_blank\" rel=\"noopener\">摘自</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>从Sun Javac的代码来看，编译过程大致可以分为3个过程:</p>\n<ol>\n<li>解析与填充符号表过程。</li>\n<li>插入式注解处理器的注解处理过程。</li>\n<li>分析与字节码生成过程。<br><img src=\"j.jpg\" alt><br>Javac编译动作的入口是com.sun.tools.javac.main.JavaCompiler类，上述3个过程的代码逻辑集中在这个类的compile()和compile2()方法中，整个编译最关键的处理就由图中标注的8个方法来完成，下面我们具体看一下这8个方法实现了什么功能。<br><img src=\"f.jpg\" alt></li>\n</ol>\n<h1 id=\"解析与填充符号表\"><a href=\"#解析与填充符号表\" class=\"headerlink\" title=\"解析与填充符号表\"></a>解析与填充符号表</h1><p>解析步骤由上图中的parseFiles（）方法（过程1.1）完成，解析步骤包括了经典程序编译原理中的词法分析和语法分析两个过程。</p>\n<h2 id=\"词法、语法分析\"><a href=\"#词法、语法分析\" class=\"headerlink\" title=\"词法、语法分析\"></a>词法、语法分析</h2><p>词法分析是<strong>将源代码的字符流转变为标记（Token）集合</strong>，<strong>单个字符</strong>是<strong>程序编写过程</strong>的最小元素，而<strong>标记</strong>则是<strong>编译过程</strong>的最小元素，关键字、变量名、字面量、运算符都可以成为标记，如“int a=b+2”这句代码包含了6个标记，分别是int、a、=、b、+、2，虽然关键字int由3个字符构成，但是它只是一个Token，不可再拆分。在Javac的源码中，词法分析过程由com.sun.tools.javac.parser.Scanner类来实现。</p>\n<p>语法分析是<strong>根据Token序列构造抽象语法树的过程</strong>，抽象语法树（Abstract Syntax Tree,AST）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构（Construct），例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。</p>\n<p>在Javac的源码中，语法分析过程由com.sun.tools.javac.parser.Parser类实现，这个阶段产出的抽象语法树由com.sun.tools.javac.tree.JCTree类表示，<strong>经过这个步骤之后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在抽象语法树之上</strong>。</p>\n<h2 id=\"填充符号表\"><a href=\"#填充符号表\" class=\"headerlink\" title=\"填充符号表\"></a>填充符号表</h2><p>完成了语法分析和词法分析之后，下一步就是填充符号表的过程，也就是enterTrees（）方法（过程1.2）所做的事情。符号表（Symbol Table）<strong>是由一组符号地址和符号信息构成的表格</strong>，可以把它想象成哈希表中K-V值对的形式（实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等）。符号表中所登记的信息在编译的不同阶段都要用到<br>。<strong>在语义分析中，符号表所登记的内容将用于语义检查</strong>（如检查一个名字的使用和原先的说明是否一致）和<strong>产生中间代码</strong>。在目标代码生成阶段，当对符号名进行地址分配时，<strong>符号表是地址分配的依据。</strong></p>\n<p>在Javac源代码中，填充符号表的过程由com.sun.tools.javac.comp.Enter类实现，此过程的出口是一个待处理列表（To Do List），包含了每一个编译单元的抽象语法树的顶级节点，以及package-info.java（如果存在的话）的顶级节点。</p>\n<h1 id=\"注解处理器\"><a href=\"#注解处理器\" class=\"headerlink\" title=\"注解处理器\"></a>注解处理器</h1><p>在Javac源码中，<em>插入</em>式注解处理器的<em>初始化</em>过程是在<br>initPorcessAnnotations（）方法中完成的，而它的<em>执行过程</em>则是在processAnnotations（）方法中完成的，<br>这个方法判断是否还有新的注解处理器需要执行，如果有的话，通过com.sun.tools.javac.processing.JavacProcessingEnvironment类的doProcessing（）方法生成一个新的JavaCompiler对象对编译的后续步骤进行处理。</p>\n<p>在JDK 1.5之后，Java语言提供了对注解（Annotation）的支持，这些注解与普通的Java代码一样，是在运行期间发挥作用的。在JDK 1.6中实现了JSR-269规范JSR-269：Pluggable Annotations Processing API（插入式注解处理API）。提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，我们可以把它看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round，也就是第一张图中的回环过程。 有了编译器注解处理的标准API后，我们的代码才有可能干涉编译器的行为，由于语法树中的任意元素，甚至包括代码注释都可以在插件之中访问到，所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间。只要有足够的创意，程序员可以使用插入式注解处理器来实现许多原本只能在编码中完成的事情。</p>\n<p>我们知道编译器在把Java程序源码编译为字节码的时候，会对Java程序源码做各方面的检查校验。这些校验主要以程序“写得对不对”为出发点，虽然也有各种WARNING的信息，但总体来讲还是较少去校验程序“写得好不好”。有鉴于此，业界出现了许多针对程序“写得好不好”的辅助校验工具，如CheckStyle、FindBug、Klocwork等。这些代码校验工具有一些是基于Java的源码进行校验，还有一些是通过扫描字节码来完成。我们将会使用注解处理器API来编写一款拥有自己编码风格的校验工具：NameCheckProcessor。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>要通过注解处理器API实现一个编译器插件，首先需要了解这组API的一些基本知识。我们实现注解处理器的代码需要继承抽象类javax.annotation.processing.AbstractProcessor，这个抽象类中只有一个必须覆盖的abstract方法：“process（）”，它是Javac编译器在执行注解处理器代码时要调用的过程，我们可以从这个方法的第一个参数“annotations”中获取到此注解处理器所要处理的注解集合，从第二个参数“roundEnv”中访问到当前这个Round中的语法树节点，每个语法树节点在这里表示为一个Element。在JDK 1.6新增的javax.lang.model包中定义了16类Element，包括了Java代码中最常用的元素，如：“包（PACKAGE）、枚举（ENUM）、类（CLASS）、注解（ANNOTATION_TYPE）、接口（INTERFACE）、枚举值（ENUM_CONSTANT）、字段（FIELD）、参数（PARAMETER）、本地变量（LOCAL_VARIABLE）、异常（EXCEPTION_PARAMETER）、方法（METHOD）、构造函数（CONSTRUCTOR）、静态语句块（STATIC_INIT，即static{}块）、实例语句块（INSTANCE_INIT，即{}块）、参数化类型（TYPE_PARAMETER，既泛型尖括号内的类型）和未定义的其他语法树节点（OTHER）”。除了process（）方法的传入参数之外，还有一个很常用的实例变量“processingEnv”，它是AbstractProcessor中的一个protected变量，在注解处理器初始化的时候（init（）方法执行的时候）创建，继承了AbstractProcessor的注解处理器代码可以直接访问到它。它代表了注解处理器框架提供的一个上下文环境，要创建新的代码、向编译器输出信息、获取其他工具类等都需要用到这个实例变量。注解处理器除了process（）方法及其参数之外，还有两个可以配合使用的Annotations：@SupportedAnnotationTypes和@SupportedSourceVersion，前者代表了这个注解处理器对哪些注解感兴趣，可以使用星号“*”作为通配符代表对所有的注解都感兴趣，后者指出这个注解处理器可以处理哪些版本的Java代码。</p>\n<p>每一个注解处理器在运行的时候都是单例的，如果不需要改变或生成语法树的内容，process（）方法就可以返回一个值为false的布尔值，通知编译器这个Round中的代码未发生变化，无须构造新的JavaCompiler实例，在这次实战的注解处理器中只对程序命名进行检查，不需要改变语法树的内容，因此process（）方法的返回值都是false。</p>\n<pre><code>import javax.annotation.processing.*;\nimport javax.lang.model.SourceVersion;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.TypeElement;\nimport java.util.Set;\n\n//可以用&quot;*&quot;表示支持所有Annotations\n@SupportedAnnotationTypes(&quot;*&quot;)\n//只支持JDK 1.6的Java代码\n@SupportedSourceVersion(SourceVersion.RELEASE_6)\npublic class NameCheckProcessor extends AbstractProcessor {\n    private NameChecker nameChecker;\n    /**\n     * 初始化名称检查插件\n     */\n    @Override\n    public void init(ProcessingEnvironment processingEnv){\n        super.init(processingEnv);\n        nameChecker = new NameChecker(processingEnv);\n    }\n    /**\n     * 对输入的语法树的各个节点进行名称检查\n     */\n    @Override\n    public boolean process(Set&lt;? extends TypeElement&gt; annotations,RoundEnvironment roundEnv){\n        if (!roundEnv.processingOver()) {\n            for (Element element:roundEnv.getRootElements())\n            nameChecker.checkNames(element);\n        }\n        return false;\n    }\n}\nimport javax.annotation.processing.Messager;\nimport javax.annotation.processing.ProcessingEnvironment;\nimport javax.lang.model.element.*;\nimport javax.lang.model.util.ElementScanner6;\nimport javax.tools.Diagnostic;\nimport java.util.EnumSet;\n\npublic class NameChecker {\n    private final Messager messager;\n    NameCheckScanner nameCheckScanner = new NameCheckScanner();\n\n    NameChecker(ProcessingEnvironment processsingEnv) {\n        this.messager = processsingEnv.getMessager();\n    }\n\n    /**\n     * 对Java程序命名进行检查,根据《Java语言规范(第3版)》第6.8节的要求,Java程序命名应当符合下列格式：\n     * &lt;p/&gt;\n     * &lt;ul&gt;\n     * &lt;li&gt;类或接口：符合驼式命名法,首字母大写。\n     * &lt;li&gt;方法：符合驼式命名法,首字母小写。\n     * &lt;li&gt;字段：\n     * &lt;ul&gt;\n     * &lt;li&gt;类、实例变量：符合驼式命名法,首字母小写。\n     * &lt;li&gt;常量：要求全部大写。\n     * &lt;/ul&gt;\n     * &lt;/ul&gt;\n     */\n    public void checkNames(Element element) {\n        nameCheckScanner.scan(element);\n    }\n    /**\n     * 名称检查器实现类,继承了JDK 1.6中新提供的ElementScanner6&lt;br&gt;\n     * 将会以Visitor模式访问抽象语法树中的元素\n     */\n    private class NameCheckScanner extends ElementScanner6&lt;Void, Void&gt; {\n        /**\n         * 此方法用于检查Java类\n         */\n        @Override\n        public Void visitType(TypeElement e, Void p) {\n            scan(e.getTypeParameters(), p);\n            checkCamelCase(e, true);\n            super.visitType(e, p);\n            return null;\n        }\n        /**\n         * 检查方法命名是否合法\n         */\n        @Override\n        public Void visitExecutable(ExecutableElement e, Void p) {\n            if (e.getKind() == ElementKind.METHOD) {\n                Name name = e.getSimpleName();\n                if\n                        (name.contentEquals(e.getEnclosingElement().getSimpleName()))\n                    messager.printMessage(Diagnostic.Kind.WARNING, &quot;一个普通方法&apos;&quot; + name + &quot;&apos;不应当与类名重复,避免与构造函数产生混淆&quot;, e);\n                checkCamelCase(e, false);\n            }\n            super.visitExecutable(e, p);\n            return null;\n        }\n        /**\n         * 检查变量命名是否合法\n         */\n        @Override\n        public Void visitVariable(VariableElement e, Void p) {\n            //如果这个Variable是枚举或常量,则按大写命名检查,否则按照驼式命名法规则检查\n            if (e.getKind() == ElementKind.ENUM_CONSTANT || e.getConstantValue() != null || heuristicallyConstant(e))\n                checkAllCaps(e);\n            else\n                checkCamelCase(e, false);\n            return null;\n        }\n\n        /**\n         * 判断一个变量是否是常量\n         */\n        private boolean heuristicallyConstant(VariableElement e) {\n            if (e.getEnclosingElement().getKind() == ElementKind.INTERFACE)\n                return true;\n            else if (e.getKind() == ElementKind.FIELD &amp;&amp; e.getModifiers().containsAll(EnumSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)))\n                return true;\n            else {\n                return false;\n            }\n        }\n\n        /**\n         * 检查传入的Element是否符合驼式命名法,如果不符合,则输出警告信息\n         */\n        private void checkCamelCase(Element e, boolean initialCaps) {\n            String name = e.getSimpleName().toString();\n            boolean previousUpper = false;\n            boolean conventional = true;\n            int firstCodePoint = name.codePointAt(0);\n            if (Character.isUpperCase(firstCodePoint)) {\n                previousUpper = true;\n                if (!initialCaps) {\n                    messager.printMessage(Diagnostic.Kind.WARNING, &quot;名称&apos;&quot; + name + &quot;&apos;应当以小写字母开头&quot;, e);\n                    return;\n                }\n            } else if (Character.isLowerCase(firstCodePoint)) {\n                if (initialCaps) {\n                    messager.printMessage(Diagnostic.Kind.WARNING, &quot;名称&apos;&quot; + name + &quot;&apos;应当以大写字母开头&quot;, e);\n                    return;\n                }\n            } else\n                conventional = false;\n            if (conventional) {\n                int cp = firstCodePoint;\n                for (int i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) {\n                    cp = name.codePointAt(i);\n                    if (Character.isUpperCase(cp)) {\n                        if (previousUpper) {\n                            conventional = false;\n                            break;\n                        }\n                        previousUpper = true;\n                    } else\n                        previousUpper = false;\n                }\n            }\n            if (!conventional)\n                messager.printMessage(Diagnostic.Kind.WARNING, &quot;名称&apos;&quot; + name + &quot;&apos;应当符合驼式命名法(Camel Case Names)&quot;, e);\n        }\n\n        /**\n         * 大写命名检查,要求第一个字母必须是大写的英文字母,其余部分可以是下划线或大写字母\n         */\n        private void checkAllCaps(Element e) {\n            String name = e.getSimpleName().toString();\n            boolean conventional = true;\n            int firstCodePoint = name.codePointAt(0);\n            if (!Character.isUpperCase(firstCodePoint))\n                conventional = false;\n            else {\n                boolean previousUnderscore = false;\n                int cp = firstCodePoint;\n                for (int i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) {\n                    cp = name.codePointAt(i);\n                    if (cp == (int) &apos;_&apos;) {\n                        if (previousUnderscore) {\n                            conventional = false;\n                            break;\n                        }\n                        previousUnderscore = true;\n                    } else {\n                        previousUnderscore = false;\n                        if (!Character.isUpperCase(cp) &amp;&amp; !Character.isDigit(cp)) {\n                            conventional = false;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!conventional)\n                messager.printMessage(Diagnostic.Kind.WARNING, &quot;常量&apos;&quot; + name + &quot;&apos;应当全部以大写字母或下划线命名,并且以字母开头&quot;, e);\n        }\n    }\n}</code></pre><p>我们可以通过Javac命令的“-processor”参数来执行编译时需要附带的注解处理器，如果有多个注解处理器的话，用逗号分隔。还可以使用-XprintRounds和-XprintProcessorInfo参数来查看注解处理器运作的详细信息，javac -processor <strong>*.NameCheckProcessor *</strong>/test.java</p>\n<pre><code>test.java：3：警告：名称&quot;test&quot;应当符合驼式命名法（Camel Case Names）\npublic class test{\n^\ntest.java：5：警告：名称&quot;colors&quot;应当以大写字母开头\nenum colors{\n^\ntest.java：6：警告：常量&quot;red&quot;应当全部以大写字母或下划线命名，并且以字母开头\nred,blue,green；\n^\ntest.java：6：警告：常量&quot;blue&quot;应当全部以大写字母或下划线命名，并且以字母开头\nred,blue,green；\n^\ntest.java：6：警告：常量&quot;green&quot;应当全部以大写字母或下划线命名，并且以字母开头\nred,blue,green；\n^\ntest.java：9：警告：常量&quot;_FORTY_TWO&quot;应当全部以大写字母或下划线命名，并且以字母开头\nstatic final int_FORTY_TWO=42；\n^\ntest.java：11：警告：名称&quot;NOT_A_CONSTANT&quot;应当以小写字母开头\npublic static int NOT_A_CONSTANT=_FORTY_TWO；\n^\ntest.java：13：警告：名称&quot;Test&quot;应当以小写字母开头\nprotected void Test（）{\n^\ntest.java：17：警告：名称&quot;NOTcamelCASEmethodNAME&quot;应当以小写字母开头\npublic void NOTcamelCASEmethodNAME（）{\n^</code></pre><p>NameCheckProcessor的例子只演示了JSR-269嵌入式注解处理器API中的一部分功能，基于这组API支持的项目还有用于校验Hibernate标签使用正确性的Hibernate Validator Annotation Processorm自动为字段生成getter和setter方法的Project Lombok.</p>\n<h1 id=\"语义分析\"><a href=\"#语义分析\" class=\"headerlink\" title=\"语义分析\"></a>语义分析</h1><p>语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。Javac的编译过程中，语义分析过程分为标注检查以及数据及控制流分析两个步骤，分别由上图中所示的attribute（）和flow（）方法（分别对应过程3.1和过程3.2）完成。</p>\n<h2 id=\"标注检查\"><a href=\"#标注检查\" class=\"headerlink\" title=\"标注检查\"></a>标注检查</h2><p>标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。在标注检查步骤中，还有一个重要的动作称为常量折叠，如果我们在代码中写了如下定义：int a=1+2；那么在语法树上仍然能看到字面量“1”、“2”以及操作符“+”，但是在经过常量折叠之后，它们将会被折叠为字面量“3”，由于编译期间进行了常量折叠，所以在代码里面定义“a=1+2”比起直接定义“a=3”，并不会增加程序运行期哪怕仅仅一个CPU指令的运算量。</p>\n<h2 id=\"数据及控制流分析\"><a href=\"#数据及控制流分析\" class=\"headerlink\" title=\"数据及控制流分析\"></a>数据及控制流分析</h2><p>在Javac的源码中，数据及控制流分析的入口是图中的flow（）方法（对应过程3.2），具体操作由com.sun.tools.javac.comp.Flow类来完成。</p>\n<p>数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只有在编译期或运行期才能进行。</p>\n<pre><code>//方法一带有final修饰\npublic void foo（final int arg）{\nfinal int var=0；\n//do something\n}\n//方法二没有final修饰\npublic void foo（int arg）{\nint var=0；\n//do something\n}</code></pre><p>在这两个foo（）方法中，第一种方法的参数和局部变量定义使用了final修饰符，而第二种方法则没有，在代码编写时程序肯定会受到final修饰符的影响，不能再改变arg和var变量的值，但是这两段代码编译出来的Class文件是没有任何一点区别的，局部变量与字段（实例变量、类变量）是有区别的，它在常量池中没有CONSTANT_Fieldref_info的符号引用，自然就没有访问标志（Access_Flags）的信息，甚至可能连名称都不会保留下来（取决于编译时的选项），自然在Class文件中不可能知道一个局部变量是不是声明为final了。因此，将局部变量声明为final，对运行期是没有影响的，变量的不变性仅仅由编译器在编译期间保障。</p>\n<h2 id=\"解语法糖\"><a href=\"#解语法糖\" class=\"headerlink\" title=\"解语法糖\"></a>解语法糖</h2><p>在Javac的源码中，解语法糖的过程由desugar（）方法触发，在com.sun.tools.javac.comp.TransTypes类和com.sun.tools.javac.comp.Lower类中完成。</p>\n<p>语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说，使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p>\n<p>Java中最常用的语法糖主要是的泛型擦除（泛型并不一定都是语法糖实现，如C#的泛型就是直接由CLR支持的）、变长参数、自动装箱/拆箱,条件编译等，虚拟机运行时不支持这些语法，它们在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖。</p>\n<h1 id=\"字节码生成\"><a href=\"#字节码生成\" class=\"headerlink\" title=\"字节码生成\"></a>字节码生成</h1><p>字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面由com.sun.tools.javac.jvm.Gen类来完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。</p>\n<p>例如，实例构造器＜init＞（）方法和类构造器＜clinit＞（）方法就是在这个阶段添加到语法树之中的（注意，这里的实例构造器并不是指默认构造函数，如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、访问性（public、protected或private）与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成），这两个构造器的产生过程实际上是一个代码收敛的过程，编译器会把语句块（对于实例构造器而言是“{}”块，对于类构造器而言是“static{}”块）、变量初始化（实例变量和类变量）、调用父类的实例构造器等操作收敛到＜init＞（）和＜clinit＞（）方法之中，并且保证一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行，上面所述的动作由Gen.normalizeDefs（）方法来实现。除了生成构造器以外，还有其他的一些代码替换工作用于优化程序的实现逻辑，如把字符串的加操作替换为StringBuffer或StringBuilder的append（）操作等。</p>\n<p>完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交给com.sun.tools.javac.jvm.ClassWriter类，由这个类的writeClass（）方法输出字节码，生成最终的Class文件，到此为止整个编译过程宣告结束。</p>\n<p><a href=\"https://www.cnblogs.com/wade-luffy/p/6050331.html\" target=\"_blank\" rel=\"noopener\">摘自</a></p>\n"},{"title":"Learn Linux","date":"2018-04-20T03:40:30.000Z","_content":"\n# 学习Linux问题与总结\n\n## 1 如何打开Ubuntu命令行工具\n\n   * 按快捷键,Ctrl+Alt+F2/F3/F4/F5/F6,后面的F2到6是或者的意思\n\n   * 然后会进入命令行的登录界面,这时候需要输入用户名和密码.\n\n   * 密码是不可见的,输入后直接回车即可\n\n## 2 如何关闭Ubuntu命令行工具(即切换到桌面)\n\n   * 按快捷键,Ctrl+Alt+F7\n\n## 3 Ubuntu下查看IP\n\n   * ifconfig -a\n\n## 4 使用locale查看系统当前编码\n\n## 5 Ubuntu设置root用户初始密码\n\n### 安装ubuntu成功后,都是普通用户权限,并没有最高root权限\n    如果需要root权限的时候,通常都会在命令前面加上sudo.有时\n    候感觉很麻烦...\n    \n    我们一般使用su命令来直接切换到root用户的,但是如果没有设\n    置root初始密码,就会抛出su : Authentication failure这样的\n    问题.所以我们只要给root用户设置一个初始密码就好了.\n    \n    输入sudo passwd命令,输入一般用户密码并设定root用户密码.\n    设定root密码成功后,输入su命令,并输入刚才设定的root密码,\n    就可以切换成root 了.提示符$代表一般用户,提示符#代表root用户\n    \n   * 总结 sudo passwd 设置初始root用户密码\n\n## 6 查看所有用户组\n\n    $cat /etc/group\n    ssl-cert:x:110:postgres\n    最前面一个字段ssl-cert是用户组名,最后一个字段postgres是用户名\n    \n## 7 查看所有用户\n\n    $sudo cat /etc/shadow\n    postgres:$6$m8anDHdE$FDY4j0CdAbgeLOM90EH1xCW/IMqHEZwM87sepyHHjUYccdmFOCVaFealGTd2zGBVfDV.AR9CWTlGz0Sw/JivL1:15910:0:99999:7:::  \n    postgres是用户名\n    \n## 8 远程连接Linux(Ubuntu配置SSH服务)端口22\n    安装OpenSSH\n    Ubuntu缺省没有安装SSH Server,使用一下命令安装:\n    \n    sudo apt-get install openssh-server openssh-client\n    \n    不过Ubuntu缺省已经安装了ssh client.\n    \n    配置完成后重启:\n    \n    sudo /etc/init.d/ssh restart\n    \n    windows客户端用putty连接命令shell模式\n    \n## 9 如何查看Linux系统版本信息\n\n### 查看Linux内核版本命令(两种方式)\n\n   * cat /proc/version \n   \n   * uname -a\n   \n### 查看Linux系统版本命令(3种方式)\n\n   * lsb_release -a \n   \n    这个命令适用于所有的Linux发行版,包括ReHat SUSE Debian...等发行版\n    \n   * cat /etc/redhat-release,\n   \n    这种方式只适合Redhat系的Linux\n    \n   * cat /etc/issue\n   \n    这种方式适用于所有的Linux发行版\n    \n## 10 ubuntu 安装 上传下载工具lrzsz\n\n    apt-get install lrzsz y\n    \n## 11 Linux中运行.sh(Shell脚本)文件\n\n    有两种方法:\n    \n    1 直接./加文件名.sh,如运行hello.sh为./hello.sh[hello.sh必须有x权限]\n    \n    2 直接sh加上文件名.sh,如运行hello.sh为sh hello.sh[hello.sh]可以没有x权限]\n    \n    步骤\n    \n    1 cd到.sh文件所在目录\n    \n    2 给.sh文件添加x执行权限,已hello.sh文件为例\n    chmod u+x hello.sh\n    \n    3 执行 ./hello.sh 或者 sh hello.sh\n    \n    备注 绝对路径执行*.sh以hello.sh 为例\n    \n    ./home/test/shell/hello.sh ,可以这样运行时因为当前登录用户是root,当前路径\n    是在/下,.代表当前路径.\n    \n    /home/test/shll/hello.sh,此路径为真实绝对路径,但此方法运行的条件是该用户对\n    hello.sh拥有执行权限,即已执行chmod u+x hello.sh\n    \n    sh/home/test/shell/hello.sh,用sh命令执行shell脚本不需要该用户拥有hello.sh的执行\n    权限即可执行.\n    \n## 12 zip 或unzip的安装和使用\n\n    Linux系统没有自带的压缩解压缩工具;需要我们自己安装;当用到zip或者unzip如果没有安装\n    就会出现unzip:Command Not Found 或 zip:Command Not Found;\n    \n    1 apt-get安装:\n    apt-get install zip\n    \n    2 yum安装\n    yum install -y unzip zip\n    \n## 13 虚拟机中CentOS无法上网(connect:network is unreachable)\n\n    表现:ping时提示connet network is unreachable\n    \n    原因: ifconfig发现网卡没有分配IP地址,考虑是DHCP的问题.\n    \n    临时解决方案: sudo dhclient,发现可以上网,重启又没有IP了,\n    \n    一劳永逸解决方案: 修改etc目录下网卡配置信息\n    vim /etc/sysconfig/network-scripts/ifcfg-[网络设备名]\n    发现最后一行的ONBOOT选项竟然是no,将其改为yes,然后就正常了.\n    \n## 14 重启系统 reboot init 6\n\n## 15 关机\n    \n    halt 立刻关机\n    \n    poweroff 立刻关机\n    \n    shutdown -h now 立刻关机(root用户使用)\n    \n    shutdown -h 10 10分钟后自动关机\n    \n    如果是通过shutdown命令设置关机的话,可以用shutdown -c命令取消重启\n    \n    推荐使用shutdown命令\n    \n## 16 centOS安装lrzsz\n    \n    yum install lrzsz\n    \n    \n    \n    \n    \n    \n    \n    \n\n\n","source":"_posts/Learn-Linux.md","raw":"---\ntitle: Learn Linux\ndate: 2018-04-20 11:40:30\ntags: [linux,ubuntu]\ncategories: \n- linux\n---\n\n# 学习Linux问题与总结\n\n## 1 如何打开Ubuntu命令行工具\n\n   * 按快捷键,Ctrl+Alt+F2/F3/F4/F5/F6,后面的F2到6是或者的意思\n\n   * 然后会进入命令行的登录界面,这时候需要输入用户名和密码.\n\n   * 密码是不可见的,输入后直接回车即可\n\n## 2 如何关闭Ubuntu命令行工具(即切换到桌面)\n\n   * 按快捷键,Ctrl+Alt+F7\n\n## 3 Ubuntu下查看IP\n\n   * ifconfig -a\n\n## 4 使用locale查看系统当前编码\n\n## 5 Ubuntu设置root用户初始密码\n\n### 安装ubuntu成功后,都是普通用户权限,并没有最高root权限\n    如果需要root权限的时候,通常都会在命令前面加上sudo.有时\n    候感觉很麻烦...\n    \n    我们一般使用su命令来直接切换到root用户的,但是如果没有设\n    置root初始密码,就会抛出su : Authentication failure这样的\n    问题.所以我们只要给root用户设置一个初始密码就好了.\n    \n    输入sudo passwd命令,输入一般用户密码并设定root用户密码.\n    设定root密码成功后,输入su命令,并输入刚才设定的root密码,\n    就可以切换成root 了.提示符$代表一般用户,提示符#代表root用户\n    \n   * 总结 sudo passwd 设置初始root用户密码\n\n## 6 查看所有用户组\n\n    $cat /etc/group\n    ssl-cert:x:110:postgres\n    最前面一个字段ssl-cert是用户组名,最后一个字段postgres是用户名\n    \n## 7 查看所有用户\n\n    $sudo cat /etc/shadow\n    postgres:$6$m8anDHdE$FDY4j0CdAbgeLOM90EH1xCW/IMqHEZwM87sepyHHjUYccdmFOCVaFealGTd2zGBVfDV.AR9CWTlGz0Sw/JivL1:15910:0:99999:7:::  \n    postgres是用户名\n    \n## 8 远程连接Linux(Ubuntu配置SSH服务)端口22\n    安装OpenSSH\n    Ubuntu缺省没有安装SSH Server,使用一下命令安装:\n    \n    sudo apt-get install openssh-server openssh-client\n    \n    不过Ubuntu缺省已经安装了ssh client.\n    \n    配置完成后重启:\n    \n    sudo /etc/init.d/ssh restart\n    \n    windows客户端用putty连接命令shell模式\n    \n## 9 如何查看Linux系统版本信息\n\n### 查看Linux内核版本命令(两种方式)\n\n   * cat /proc/version \n   \n   * uname -a\n   \n### 查看Linux系统版本命令(3种方式)\n\n   * lsb_release -a \n   \n    这个命令适用于所有的Linux发行版,包括ReHat SUSE Debian...等发行版\n    \n   * cat /etc/redhat-release,\n   \n    这种方式只适合Redhat系的Linux\n    \n   * cat /etc/issue\n   \n    这种方式适用于所有的Linux发行版\n    \n## 10 ubuntu 安装 上传下载工具lrzsz\n\n    apt-get install lrzsz y\n    \n## 11 Linux中运行.sh(Shell脚本)文件\n\n    有两种方法:\n    \n    1 直接./加文件名.sh,如运行hello.sh为./hello.sh[hello.sh必须有x权限]\n    \n    2 直接sh加上文件名.sh,如运行hello.sh为sh hello.sh[hello.sh]可以没有x权限]\n    \n    步骤\n    \n    1 cd到.sh文件所在目录\n    \n    2 给.sh文件添加x执行权限,已hello.sh文件为例\n    chmod u+x hello.sh\n    \n    3 执行 ./hello.sh 或者 sh hello.sh\n    \n    备注 绝对路径执行*.sh以hello.sh 为例\n    \n    ./home/test/shell/hello.sh ,可以这样运行时因为当前登录用户是root,当前路径\n    是在/下,.代表当前路径.\n    \n    /home/test/shll/hello.sh,此路径为真实绝对路径,但此方法运行的条件是该用户对\n    hello.sh拥有执行权限,即已执行chmod u+x hello.sh\n    \n    sh/home/test/shell/hello.sh,用sh命令执行shell脚本不需要该用户拥有hello.sh的执行\n    权限即可执行.\n    \n## 12 zip 或unzip的安装和使用\n\n    Linux系统没有自带的压缩解压缩工具;需要我们自己安装;当用到zip或者unzip如果没有安装\n    就会出现unzip:Command Not Found 或 zip:Command Not Found;\n    \n    1 apt-get安装:\n    apt-get install zip\n    \n    2 yum安装\n    yum install -y unzip zip\n    \n## 13 虚拟机中CentOS无法上网(connect:network is unreachable)\n\n    表现:ping时提示connet network is unreachable\n    \n    原因: ifconfig发现网卡没有分配IP地址,考虑是DHCP的问题.\n    \n    临时解决方案: sudo dhclient,发现可以上网,重启又没有IP了,\n    \n    一劳永逸解决方案: 修改etc目录下网卡配置信息\n    vim /etc/sysconfig/network-scripts/ifcfg-[网络设备名]\n    发现最后一行的ONBOOT选项竟然是no,将其改为yes,然后就正常了.\n    \n## 14 重启系统 reboot init 6\n\n## 15 关机\n    \n    halt 立刻关机\n    \n    poweroff 立刻关机\n    \n    shutdown -h now 立刻关机(root用户使用)\n    \n    shutdown -h 10 10分钟后自动关机\n    \n    如果是通过shutdown命令设置关机的话,可以用shutdown -c命令取消重启\n    \n    推荐使用shutdown命令\n    \n## 16 centOS安装lrzsz\n    \n    yum install lrzsz\n    \n    \n    \n    \n    \n    \n    \n    \n\n\n","slug":"Learn-Linux","published":1,"updated":"2019-09-27T08:27:08.026Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecn000dojfyqrqwnmxt","content":"<h1 id=\"学习Linux问题与总结\"><a href=\"#学习Linux问题与总结\" class=\"headerlink\" title=\"学习Linux问题与总结\"></a>学习Linux问题与总结</h1><h2 id=\"1-如何打开Ubuntu命令行工具\"><a href=\"#1-如何打开Ubuntu命令行工具\" class=\"headerlink\" title=\"1 如何打开Ubuntu命令行工具\"></a>1 如何打开Ubuntu命令行工具</h2><ul>\n<li><p>按快捷键,Ctrl+Alt+F2/F3/F4/F5/F6,后面的F2到6是或者的意思</p>\n</li>\n<li><p>然后会进入命令行的登录界面,这时候需要输入用户名和密码.</p>\n</li>\n<li><p>密码是不可见的,输入后直接回车即可</p>\n</li>\n</ul>\n<h2 id=\"2-如何关闭Ubuntu命令行工具-即切换到桌面\"><a href=\"#2-如何关闭Ubuntu命令行工具-即切换到桌面\" class=\"headerlink\" title=\"2 如何关闭Ubuntu命令行工具(即切换到桌面)\"></a>2 如何关闭Ubuntu命令行工具(即切换到桌面)</h2><ul>\n<li>按快捷键,Ctrl+Alt+F7</li>\n</ul>\n<h2 id=\"3-Ubuntu下查看IP\"><a href=\"#3-Ubuntu下查看IP\" class=\"headerlink\" title=\"3 Ubuntu下查看IP\"></a>3 Ubuntu下查看IP</h2><ul>\n<li>ifconfig -a</li>\n</ul>\n<h2 id=\"4-使用locale查看系统当前编码\"><a href=\"#4-使用locale查看系统当前编码\" class=\"headerlink\" title=\"4 使用locale查看系统当前编码\"></a>4 使用locale查看系统当前编码</h2><h2 id=\"5-Ubuntu设置root用户初始密码\"><a href=\"#5-Ubuntu设置root用户初始密码\" class=\"headerlink\" title=\"5 Ubuntu设置root用户初始密码\"></a>5 Ubuntu设置root用户初始密码</h2><h3 id=\"安装ubuntu成功后-都是普通用户权限-并没有最高root权限\"><a href=\"#安装ubuntu成功后-都是普通用户权限-并没有最高root权限\" class=\"headerlink\" title=\"安装ubuntu成功后,都是普通用户权限,并没有最高root权限\"></a>安装ubuntu成功后,都是普通用户权限,并没有最高root权限</h3><pre><code>如果需要root权限的时候,通常都会在命令前面加上sudo.有时\n候感觉很麻烦...\n\n我们一般使用su命令来直接切换到root用户的,但是如果没有设\n置root初始密码,就会抛出su : Authentication failure这样的\n问题.所以我们只要给root用户设置一个初始密码就好了.\n\n输入sudo passwd命令,输入一般用户密码并设定root用户密码.\n设定root密码成功后,输入su命令,并输入刚才设定的root密码,\n就可以切换成root 了.提示符$代表一般用户,提示符#代表root用户</code></pre><ul>\n<li>总结 sudo passwd 设置初始root用户密码</li>\n</ul>\n<h2 id=\"6-查看所有用户组\"><a href=\"#6-查看所有用户组\" class=\"headerlink\" title=\"6 查看所有用户组\"></a>6 查看所有用户组</h2><pre><code>$cat /etc/group\nssl-cert:x:110:postgres\n最前面一个字段ssl-cert是用户组名,最后一个字段postgres是用户名</code></pre><h2 id=\"7-查看所有用户\"><a href=\"#7-查看所有用户\" class=\"headerlink\" title=\"7 查看所有用户\"></a>7 查看所有用户</h2><pre><code>$sudo cat /etc/shadow\npostgres:$6$m8anDHdE$FDY4j0CdAbgeLOM90EH1xCW/IMqHEZwM87sepyHHjUYccdmFOCVaFealGTd2zGBVfDV.AR9CWTlGz0Sw/JivL1:15910:0:99999:7:::  \npostgres是用户名</code></pre><h2 id=\"8-远程连接Linux-Ubuntu配置SSH服务-端口22\"><a href=\"#8-远程连接Linux-Ubuntu配置SSH服务-端口22\" class=\"headerlink\" title=\"8 远程连接Linux(Ubuntu配置SSH服务)端口22\"></a>8 远程连接Linux(Ubuntu配置SSH服务)端口22</h2><pre><code>安装OpenSSH\nUbuntu缺省没有安装SSH Server,使用一下命令安装:\n\nsudo apt-get install openssh-server openssh-client\n\n不过Ubuntu缺省已经安装了ssh client.\n\n配置完成后重启:\n\nsudo /etc/init.d/ssh restart\n\nwindows客户端用putty连接命令shell模式</code></pre><h2 id=\"9-如何查看Linux系统版本信息\"><a href=\"#9-如何查看Linux系统版本信息\" class=\"headerlink\" title=\"9 如何查看Linux系统版本信息\"></a>9 如何查看Linux系统版本信息</h2><h3 id=\"查看Linux内核版本命令-两种方式\"><a href=\"#查看Linux内核版本命令-两种方式\" class=\"headerlink\" title=\"查看Linux内核版本命令(两种方式)\"></a>查看Linux内核版本命令(两种方式)</h3><ul>\n<li><p>cat /proc/version </p>\n</li>\n<li><p>uname -a</p>\n</li>\n</ul>\n<h3 id=\"查看Linux系统版本命令-3种方式\"><a href=\"#查看Linux系统版本命令-3种方式\" class=\"headerlink\" title=\"查看Linux系统版本命令(3种方式)\"></a>查看Linux系统版本命令(3种方式)</h3><ul>\n<li><p>lsb_release -a </p>\n<p>这个命令适用于所有的Linux发行版,包括ReHat SUSE Debian…等发行版</p>\n</li>\n<li><p>cat /etc/redhat-release,</p>\n<p>这种方式只适合Redhat系的Linux</p>\n</li>\n<li><p>cat /etc/issue</p>\n<p>这种方式适用于所有的Linux发行版</p>\n</li>\n</ul>\n<h2 id=\"10-ubuntu-安装-上传下载工具lrzsz\"><a href=\"#10-ubuntu-安装-上传下载工具lrzsz\" class=\"headerlink\" title=\"10 ubuntu 安装 上传下载工具lrzsz\"></a>10 ubuntu 安装 上传下载工具lrzsz</h2><pre><code>apt-get install lrzsz y</code></pre><h2 id=\"11-Linux中运行-sh-Shell脚本-文件\"><a href=\"#11-Linux中运行-sh-Shell脚本-文件\" class=\"headerlink\" title=\"11 Linux中运行.sh(Shell脚本)文件\"></a>11 Linux中运行.sh(Shell脚本)文件</h2><pre><code>有两种方法:\n\n1 直接./加文件名.sh,如运行hello.sh为./hello.sh[hello.sh必须有x权限]\n\n2 直接sh加上文件名.sh,如运行hello.sh为sh hello.sh[hello.sh]可以没有x权限]\n\n步骤\n\n1 cd到.sh文件所在目录\n\n2 给.sh文件添加x执行权限,已hello.sh文件为例\nchmod u+x hello.sh\n\n3 执行 ./hello.sh 或者 sh hello.sh\n\n备注 绝对路径执行*.sh以hello.sh 为例\n\n./home/test/shell/hello.sh ,可以这样运行时因为当前登录用户是root,当前路径\n是在/下,.代表当前路径.\n\n/home/test/shll/hello.sh,此路径为真实绝对路径,但此方法运行的条件是该用户对\nhello.sh拥有执行权限,即已执行chmod u+x hello.sh\n\nsh/home/test/shell/hello.sh,用sh命令执行shell脚本不需要该用户拥有hello.sh的执行\n权限即可执行.</code></pre><h2 id=\"12-zip-或unzip的安装和使用\"><a href=\"#12-zip-或unzip的安装和使用\" class=\"headerlink\" title=\"12 zip 或unzip的安装和使用\"></a>12 zip 或unzip的安装和使用</h2><pre><code>Linux系统没有自带的压缩解压缩工具;需要我们自己安装;当用到zip或者unzip如果没有安装\n就会出现unzip:Command Not Found 或 zip:Command Not Found;\n\n1 apt-get安装:\napt-get install zip\n\n2 yum安装\nyum install -y unzip zip</code></pre><h2 id=\"13-虚拟机中CentOS无法上网-connect-network-is-unreachable\"><a href=\"#13-虚拟机中CentOS无法上网-connect-network-is-unreachable\" class=\"headerlink\" title=\"13 虚拟机中CentOS无法上网(connect:network is unreachable)\"></a>13 虚拟机中CentOS无法上网(connect:network is unreachable)</h2><pre><code>表现:ping时提示connet network is unreachable\n\n原因: ifconfig发现网卡没有分配IP地址,考虑是DHCP的问题.\n\n临时解决方案: sudo dhclient,发现可以上网,重启又没有IP了,\n\n一劳永逸解决方案: 修改etc目录下网卡配置信息\nvim /etc/sysconfig/network-scripts/ifcfg-[网络设备名]\n发现最后一行的ONBOOT选项竟然是no,将其改为yes,然后就正常了.</code></pre><h2 id=\"14-重启系统-reboot-init-6\"><a href=\"#14-重启系统-reboot-init-6\" class=\"headerlink\" title=\"14 重启系统 reboot init 6\"></a>14 重启系统 reboot init 6</h2><h2 id=\"15-关机\"><a href=\"#15-关机\" class=\"headerlink\" title=\"15 关机\"></a>15 关机</h2><pre><code>halt 立刻关机\n\npoweroff 立刻关机\n\nshutdown -h now 立刻关机(root用户使用)\n\nshutdown -h 10 10分钟后自动关机\n\n如果是通过shutdown命令设置关机的话,可以用shutdown -c命令取消重启\n\n推荐使用shutdown命令</code></pre><h2 id=\"16-centOS安装lrzsz\"><a href=\"#16-centOS安装lrzsz\" class=\"headerlink\" title=\"16 centOS安装lrzsz\"></a>16 centOS安装lrzsz</h2><pre><code>yum install lrzsz</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"学习Linux问题与总结\"><a href=\"#学习Linux问题与总结\" class=\"headerlink\" title=\"学习Linux问题与总结\"></a>学习Linux问题与总结</h1><h2 id=\"1-如何打开Ubuntu命令行工具\"><a href=\"#1-如何打开Ubuntu命令行工具\" class=\"headerlink\" title=\"1 如何打开Ubuntu命令行工具\"></a>1 如何打开Ubuntu命令行工具</h2><ul>\n<li><p>按快捷键,Ctrl+Alt+F2/F3/F4/F5/F6,后面的F2到6是或者的意思</p>\n</li>\n<li><p>然后会进入命令行的登录界面,这时候需要输入用户名和密码.</p>\n</li>\n<li><p>密码是不可见的,输入后直接回车即可</p>\n</li>\n</ul>\n<h2 id=\"2-如何关闭Ubuntu命令行工具-即切换到桌面\"><a href=\"#2-如何关闭Ubuntu命令行工具-即切换到桌面\" class=\"headerlink\" title=\"2 如何关闭Ubuntu命令行工具(即切换到桌面)\"></a>2 如何关闭Ubuntu命令行工具(即切换到桌面)</h2><ul>\n<li>按快捷键,Ctrl+Alt+F7</li>\n</ul>\n<h2 id=\"3-Ubuntu下查看IP\"><a href=\"#3-Ubuntu下查看IP\" class=\"headerlink\" title=\"3 Ubuntu下查看IP\"></a>3 Ubuntu下查看IP</h2><ul>\n<li>ifconfig -a</li>\n</ul>\n<h2 id=\"4-使用locale查看系统当前编码\"><a href=\"#4-使用locale查看系统当前编码\" class=\"headerlink\" title=\"4 使用locale查看系统当前编码\"></a>4 使用locale查看系统当前编码</h2><h2 id=\"5-Ubuntu设置root用户初始密码\"><a href=\"#5-Ubuntu设置root用户初始密码\" class=\"headerlink\" title=\"5 Ubuntu设置root用户初始密码\"></a>5 Ubuntu设置root用户初始密码</h2><h3 id=\"安装ubuntu成功后-都是普通用户权限-并没有最高root权限\"><a href=\"#安装ubuntu成功后-都是普通用户权限-并没有最高root权限\" class=\"headerlink\" title=\"安装ubuntu成功后,都是普通用户权限,并没有最高root权限\"></a>安装ubuntu成功后,都是普通用户权限,并没有最高root权限</h3><pre><code>如果需要root权限的时候,通常都会在命令前面加上sudo.有时\n候感觉很麻烦...\n\n我们一般使用su命令来直接切换到root用户的,但是如果没有设\n置root初始密码,就会抛出su : Authentication failure这样的\n问题.所以我们只要给root用户设置一个初始密码就好了.\n\n输入sudo passwd命令,输入一般用户密码并设定root用户密码.\n设定root密码成功后,输入su命令,并输入刚才设定的root密码,\n就可以切换成root 了.提示符$代表一般用户,提示符#代表root用户</code></pre><ul>\n<li>总结 sudo passwd 设置初始root用户密码</li>\n</ul>\n<h2 id=\"6-查看所有用户组\"><a href=\"#6-查看所有用户组\" class=\"headerlink\" title=\"6 查看所有用户组\"></a>6 查看所有用户组</h2><pre><code>$cat /etc/group\nssl-cert:x:110:postgres\n最前面一个字段ssl-cert是用户组名,最后一个字段postgres是用户名</code></pre><h2 id=\"7-查看所有用户\"><a href=\"#7-查看所有用户\" class=\"headerlink\" title=\"7 查看所有用户\"></a>7 查看所有用户</h2><pre><code>$sudo cat /etc/shadow\npostgres:$6$m8anDHdE$FDY4j0CdAbgeLOM90EH1xCW/IMqHEZwM87sepyHHjUYccdmFOCVaFealGTd2zGBVfDV.AR9CWTlGz0Sw/JivL1:15910:0:99999:7:::  \npostgres是用户名</code></pre><h2 id=\"8-远程连接Linux-Ubuntu配置SSH服务-端口22\"><a href=\"#8-远程连接Linux-Ubuntu配置SSH服务-端口22\" class=\"headerlink\" title=\"8 远程连接Linux(Ubuntu配置SSH服务)端口22\"></a>8 远程连接Linux(Ubuntu配置SSH服务)端口22</h2><pre><code>安装OpenSSH\nUbuntu缺省没有安装SSH Server,使用一下命令安装:\n\nsudo apt-get install openssh-server openssh-client\n\n不过Ubuntu缺省已经安装了ssh client.\n\n配置完成后重启:\n\nsudo /etc/init.d/ssh restart\n\nwindows客户端用putty连接命令shell模式</code></pre><h2 id=\"9-如何查看Linux系统版本信息\"><a href=\"#9-如何查看Linux系统版本信息\" class=\"headerlink\" title=\"9 如何查看Linux系统版本信息\"></a>9 如何查看Linux系统版本信息</h2><h3 id=\"查看Linux内核版本命令-两种方式\"><a href=\"#查看Linux内核版本命令-两种方式\" class=\"headerlink\" title=\"查看Linux内核版本命令(两种方式)\"></a>查看Linux内核版本命令(两种方式)</h3><ul>\n<li><p>cat /proc/version </p>\n</li>\n<li><p>uname -a</p>\n</li>\n</ul>\n<h3 id=\"查看Linux系统版本命令-3种方式\"><a href=\"#查看Linux系统版本命令-3种方式\" class=\"headerlink\" title=\"查看Linux系统版本命令(3种方式)\"></a>查看Linux系统版本命令(3种方式)</h3><ul>\n<li><p>lsb_release -a </p>\n<p>这个命令适用于所有的Linux发行版,包括ReHat SUSE Debian…等发行版</p>\n</li>\n<li><p>cat /etc/redhat-release,</p>\n<p>这种方式只适合Redhat系的Linux</p>\n</li>\n<li><p>cat /etc/issue</p>\n<p>这种方式适用于所有的Linux发行版</p>\n</li>\n</ul>\n<h2 id=\"10-ubuntu-安装-上传下载工具lrzsz\"><a href=\"#10-ubuntu-安装-上传下载工具lrzsz\" class=\"headerlink\" title=\"10 ubuntu 安装 上传下载工具lrzsz\"></a>10 ubuntu 安装 上传下载工具lrzsz</h2><pre><code>apt-get install lrzsz y</code></pre><h2 id=\"11-Linux中运行-sh-Shell脚本-文件\"><a href=\"#11-Linux中运行-sh-Shell脚本-文件\" class=\"headerlink\" title=\"11 Linux中运行.sh(Shell脚本)文件\"></a>11 Linux中运行.sh(Shell脚本)文件</h2><pre><code>有两种方法:\n\n1 直接./加文件名.sh,如运行hello.sh为./hello.sh[hello.sh必须有x权限]\n\n2 直接sh加上文件名.sh,如运行hello.sh为sh hello.sh[hello.sh]可以没有x权限]\n\n步骤\n\n1 cd到.sh文件所在目录\n\n2 给.sh文件添加x执行权限,已hello.sh文件为例\nchmod u+x hello.sh\n\n3 执行 ./hello.sh 或者 sh hello.sh\n\n备注 绝对路径执行*.sh以hello.sh 为例\n\n./home/test/shell/hello.sh ,可以这样运行时因为当前登录用户是root,当前路径\n是在/下,.代表当前路径.\n\n/home/test/shll/hello.sh,此路径为真实绝对路径,但此方法运行的条件是该用户对\nhello.sh拥有执行权限,即已执行chmod u+x hello.sh\n\nsh/home/test/shell/hello.sh,用sh命令执行shell脚本不需要该用户拥有hello.sh的执行\n权限即可执行.</code></pre><h2 id=\"12-zip-或unzip的安装和使用\"><a href=\"#12-zip-或unzip的安装和使用\" class=\"headerlink\" title=\"12 zip 或unzip的安装和使用\"></a>12 zip 或unzip的安装和使用</h2><pre><code>Linux系统没有自带的压缩解压缩工具;需要我们自己安装;当用到zip或者unzip如果没有安装\n就会出现unzip:Command Not Found 或 zip:Command Not Found;\n\n1 apt-get安装:\napt-get install zip\n\n2 yum安装\nyum install -y unzip zip</code></pre><h2 id=\"13-虚拟机中CentOS无法上网-connect-network-is-unreachable\"><a href=\"#13-虚拟机中CentOS无法上网-connect-network-is-unreachable\" class=\"headerlink\" title=\"13 虚拟机中CentOS无法上网(connect:network is unreachable)\"></a>13 虚拟机中CentOS无法上网(connect:network is unreachable)</h2><pre><code>表现:ping时提示connet network is unreachable\n\n原因: ifconfig发现网卡没有分配IP地址,考虑是DHCP的问题.\n\n临时解决方案: sudo dhclient,发现可以上网,重启又没有IP了,\n\n一劳永逸解决方案: 修改etc目录下网卡配置信息\nvim /etc/sysconfig/network-scripts/ifcfg-[网络设备名]\n发现最后一行的ONBOOT选项竟然是no,将其改为yes,然后就正常了.</code></pre><h2 id=\"14-重启系统-reboot-init-6\"><a href=\"#14-重启系统-reboot-init-6\" class=\"headerlink\" title=\"14 重启系统 reboot init 6\"></a>14 重启系统 reboot init 6</h2><h2 id=\"15-关机\"><a href=\"#15-关机\" class=\"headerlink\" title=\"15 关机\"></a>15 关机</h2><pre><code>halt 立刻关机\n\npoweroff 立刻关机\n\nshutdown -h now 立刻关机(root用户使用)\n\nshutdown -h 10 10分钟后自动关机\n\n如果是通过shutdown命令设置关机的话,可以用shutdown -c命令取消重启\n\n推荐使用shutdown命令</code></pre><h2 id=\"16-centOS安装lrzsz\"><a href=\"#16-centOS安装lrzsz\" class=\"headerlink\" title=\"16 centOS安装lrzsz\"></a>16 centOS安装lrzsz</h2><pre><code>yum install lrzsz</code></pre>"},{"title":"LeetCode","date":"2018-05-31T01:49:47.000Z","_content":"\n## 两数之和\n\n给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。\n\n你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。\n\n示例:\n\n\n    给定 nums = [2, 7, 11, 15], target = 9\n    \n    因为 nums[0] + nums[1] = 2 + 7 = 9\n    所以返回 [0, 1]\n    \n分析:\n\n    思路一：暴力解法，两次for循环，遍历所有可能，这也是容易想到的方法，时间复杂度O(n^2),空间复杂度O(1); \n    思路二：利用哈希表，每次存储target减去当前数的差值(key)，当前值的下标(value)，当再碰到这个值时，即找到了符合要求的值。时间复杂度O(n),空间复杂度O(n);\n        \n代码:\n\n1:\n    \n    //思路一暴力解法\n    public int[] twoSum(int[] nums, int target) {\n            // write your code here\n            int[] a = new int[2];\n            for (int i = 0; i < nums.length - 1; i++){\n    \n                // 注意j等于i + 1;若j = 1则循环顺序不对\n                for (int j = i + 1; j < nums.length; j++ ){\n                    if (nums[i] + nums[j] == target){\n    \n                        a[0] = i;\n                        a[1] = j;\n                        break;\n                    }\n                }\n            }\n            return a;\n        }\n         \n2:         \n        \n    //思路二利用哈希表\n    public int[] twoSum(int[] nums, int target) {\n    \n            int[] a = new int[2];\n            HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n    \n            for (int i = 0; i < nums.length; i++){\n    \n                if (map.containsKey(nums[i])){\n    \n                    a[0] = map.get(nums[i]);\n                    a[1] = i;\n                    return a;\n                }\n                map.put(target - nums[i], i);\n            }\n    \n            return a;\n    }\n    \n## 两数相加\n\n给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。\n\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n示例：\n\n    输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n    输出：7 -> 0 -> 8\n    原因：342 + 465 = 807\n    \n### 结题思路\n\n方法: 初等数学\n\n我们是有变量来跟踪进位,并从包含最低有效位的表头开始模拟逐位相加的过程.\n\n![示例图片](https://leetcode-cn.com/problems/add-two-numbers/Figures/2/2_add_two_numbers.svg)    \n\n如图所示,对两数相加方法的可视化:342 + 465 = 807,每个节点都包含一个数字,并且数字按位逆序存储.\n\n算法\n\n就像你在纸上计算两个数字的和那样,我们首先从最低有效位也就是列表l1和l2的表头开始相加.由于每位数字都应当处于\n0...9的范围内,我们计算两个数字的和时可能会出现\"溢出\".例如:5+7 = 12.在这种情况下,我们会将当前位的数值设\n置为2,并将进位carry = 1带入下一次迭代.进位carry必定是0或者1,这是因为两个数字相加(考虑到进位)可能出现的\n的最大和为9+ 9+1=19   \n    \n伪代码如下:\n * 将x设为节点p的值.如果p已经到达l1的末尾,则将其设置为0.\n * 将y设为节点q的值,如果q已经到达l2的末尾,则将其设置为0.\n * 设定sum = x + y + carry.\n * 更新进位的值,carry = sum/10.\n * 创建一个数值为(sum mod 10) 的新节点,并将其设置为当前节点的下一个节点,然后将当前节点\n    前进到下一个节点.\n * 同时,将p和q前进到下一个节点.\n * 检查carry = 1是否成立,如果成立,则向返回列表追加一个含有数字1的新节点.\n * 返回哑节点的下一个节点.\n \n请注意我们使用哑节点来简化代码.如果没有哑节点,则必须编写额外的条件语句来初始化表头的值.\n         \n请特别注意以下的情况:\n\n| 测试用例 | 说明 |\n| :-- | :-- | \n| l1 = [0,1] l2 = [0,1,2] | 当一个列表比另一个列表长时 | \n| l1 = [] l2 = [0,1] | 当一个列表为空时,即出现空列表 | \n| l1 = [9,9] l2 = [1] | 求和运算最后可能出现额外的进位,这一点很容易被遗忘  | \n         \n复杂度分析\n\n * 时间复杂度: O(max(m,n)),假设m和n分别表示l1和l2的长度,上面的算法最多重复max(m,n)次.\n  \n * 空间复杂度: O(max(m,n)),新列表的长度最多为max(m,n) + 1.\n \n拓展\n\n如果链表中的数字不是按逆序存储的呢?例如:\n(3->4->2) + (4->6->5) = 8->0->7 \n   \n### 代码(java)    \n\n    /**\n     * Definition for singly-linked list.\n     * public class ListNode {\n     *      int val;\n     *      LsitNode next;\n     *      ListNode (int x) { val = x;}\n     * }     \n     */\n     class Solution {\n        public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n            ListNode dummyHead = new ListNode(0);\n            ListNode p = l1, q = l2, curr = dummyHead;\n            int carry =0; //进位\n            while (p != null || q != null) {\n                int x = (p != null) ? p.val : 0;\n                int y = (q != null) ? q.val : 0;\n                int sum = x + y + carry;\n                carry = sum/10;\n                curr.next = new listNode(sum%10);\n                curr = curr.next;\n                if(p != null) p=p.next;\n                if(q != null) q=q.next;\n            }\n            if(carry>0) {\n                curr.next = new ListNode(carry);\n            }\n            return dummyHead.next;\n        }\n         \n     }\n    \n    \n    ","source":"_posts/LeetCode.md","raw":"---\ntitle: LeetCode\ndate: 2018-05-31 09:49:47\ntags: [LeetCode,算法]\ncategories: \n- 算法\n---\n\n## 两数之和\n\n给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。\n\n你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。\n\n示例:\n\n\n    给定 nums = [2, 7, 11, 15], target = 9\n    \n    因为 nums[0] + nums[1] = 2 + 7 = 9\n    所以返回 [0, 1]\n    \n分析:\n\n    思路一：暴力解法，两次for循环，遍历所有可能，这也是容易想到的方法，时间复杂度O(n^2),空间复杂度O(1); \n    思路二：利用哈希表，每次存储target减去当前数的差值(key)，当前值的下标(value)，当再碰到这个值时，即找到了符合要求的值。时间复杂度O(n),空间复杂度O(n);\n        \n代码:\n\n1:\n    \n    //思路一暴力解法\n    public int[] twoSum(int[] nums, int target) {\n            // write your code here\n            int[] a = new int[2];\n            for (int i = 0; i < nums.length - 1; i++){\n    \n                // 注意j等于i + 1;若j = 1则循环顺序不对\n                for (int j = i + 1; j < nums.length; j++ ){\n                    if (nums[i] + nums[j] == target){\n    \n                        a[0] = i;\n                        a[1] = j;\n                        break;\n                    }\n                }\n            }\n            return a;\n        }\n         \n2:         \n        \n    //思路二利用哈希表\n    public int[] twoSum(int[] nums, int target) {\n    \n            int[] a = new int[2];\n            HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n    \n            for (int i = 0; i < nums.length; i++){\n    \n                if (map.containsKey(nums[i])){\n    \n                    a[0] = map.get(nums[i]);\n                    a[1] = i;\n                    return a;\n                }\n                map.put(target - nums[i], i);\n            }\n    \n            return a;\n    }\n    \n## 两数相加\n\n给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。\n\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n示例：\n\n    输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n    输出：7 -> 0 -> 8\n    原因：342 + 465 = 807\n    \n### 结题思路\n\n方法: 初等数学\n\n我们是有变量来跟踪进位,并从包含最低有效位的表头开始模拟逐位相加的过程.\n\n![示例图片](https://leetcode-cn.com/problems/add-two-numbers/Figures/2/2_add_two_numbers.svg)    \n\n如图所示,对两数相加方法的可视化:342 + 465 = 807,每个节点都包含一个数字,并且数字按位逆序存储.\n\n算法\n\n就像你在纸上计算两个数字的和那样,我们首先从最低有效位也就是列表l1和l2的表头开始相加.由于每位数字都应当处于\n0...9的范围内,我们计算两个数字的和时可能会出现\"溢出\".例如:5+7 = 12.在这种情况下,我们会将当前位的数值设\n置为2,并将进位carry = 1带入下一次迭代.进位carry必定是0或者1,这是因为两个数字相加(考虑到进位)可能出现的\n的最大和为9+ 9+1=19   \n    \n伪代码如下:\n * 将x设为节点p的值.如果p已经到达l1的末尾,则将其设置为0.\n * 将y设为节点q的值,如果q已经到达l2的末尾,则将其设置为0.\n * 设定sum = x + y + carry.\n * 更新进位的值,carry = sum/10.\n * 创建一个数值为(sum mod 10) 的新节点,并将其设置为当前节点的下一个节点,然后将当前节点\n    前进到下一个节点.\n * 同时,将p和q前进到下一个节点.\n * 检查carry = 1是否成立,如果成立,则向返回列表追加一个含有数字1的新节点.\n * 返回哑节点的下一个节点.\n \n请注意我们使用哑节点来简化代码.如果没有哑节点,则必须编写额外的条件语句来初始化表头的值.\n         \n请特别注意以下的情况:\n\n| 测试用例 | 说明 |\n| :-- | :-- | \n| l1 = [0,1] l2 = [0,1,2] | 当一个列表比另一个列表长时 | \n| l1 = [] l2 = [0,1] | 当一个列表为空时,即出现空列表 | \n| l1 = [9,9] l2 = [1] | 求和运算最后可能出现额外的进位,这一点很容易被遗忘  | \n         \n复杂度分析\n\n * 时间复杂度: O(max(m,n)),假设m和n分别表示l1和l2的长度,上面的算法最多重复max(m,n)次.\n  \n * 空间复杂度: O(max(m,n)),新列表的长度最多为max(m,n) + 1.\n \n拓展\n\n如果链表中的数字不是按逆序存储的呢?例如:\n(3->4->2) + (4->6->5) = 8->0->7 \n   \n### 代码(java)    \n\n    /**\n     * Definition for singly-linked list.\n     * public class ListNode {\n     *      int val;\n     *      LsitNode next;\n     *      ListNode (int x) { val = x;}\n     * }     \n     */\n     class Solution {\n        public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n            ListNode dummyHead = new ListNode(0);\n            ListNode p = l1, q = l2, curr = dummyHead;\n            int carry =0; //进位\n            while (p != null || q != null) {\n                int x = (p != null) ? p.val : 0;\n                int y = (q != null) ? q.val : 0;\n                int sum = x + y + carry;\n                carry = sum/10;\n                curr.next = new listNode(sum%10);\n                curr = curr.next;\n                if(p != null) p=p.next;\n                if(q != null) q=q.next;\n            }\n            if(carry>0) {\n                curr.next = new ListNode(carry);\n            }\n            return dummyHead.next;\n        }\n         \n     }\n    \n    \n    ","slug":"LeetCode","published":1,"updated":"2019-09-27T08:27:08.027Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139ceco000eojfyvngd9dhr","content":"<h2 id=\"两数之和\"><a href=\"#两数之和\" class=\"headerlink\" title=\"两数之和\"></a>两数之和</h2><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p>\n<p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p>\n<p>示例:</p>\n<pre><code>给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]</code></pre><p>分析:</p>\n<pre><code>思路一：暴力解法，两次for循环，遍历所有可能，这也是容易想到的方法，时间复杂度O(n^2),空间复杂度O(1); \n思路二：利用哈希表，每次存储target减去当前数的差值(key)，当前值的下标(value)，当再碰到这个值时，即找到了符合要求的值。时间复杂度O(n),空间复杂度O(n);</code></pre><p>代码:</p>\n<p>1:</p>\n<pre><code>//思路一暴力解法\npublic int[] twoSum(int[] nums, int target) {\n        // write your code here\n        int[] a = new int[2];\n        for (int i = 0; i &lt; nums.length - 1; i++){\n\n            // 注意j等于i + 1;若j = 1则循环顺序不对\n            for (int j = i + 1; j &lt; nums.length; j++ ){\n                if (nums[i] + nums[j] == target){\n\n                    a[0] = i;\n                    a[1] = j;\n                    break;\n                }\n            }\n        }\n        return a;\n    }</code></pre><p>2:         </p>\n<pre><code>//思路二利用哈希表\npublic int[] twoSum(int[] nums, int target) {\n\n        int[] a = new int[2];\n        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();\n\n        for (int i = 0; i &lt; nums.length; i++){\n\n            if (map.containsKey(nums[i])){\n\n                a[0] = map.get(nums[i]);\n                a[1] = i;\n                return a;\n            }\n            map.put(target - nums[i], i);\n        }\n\n        return a;\n}</code></pre><h2 id=\"两数相加\"><a href=\"#两数相加\" class=\"headerlink\" title=\"两数相加\"></a>两数相加</h2><p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p>\n<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n<p>示例：</p>\n<pre><code>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)\n输出：7 -&gt; 0 -&gt; 8\n原因：342 + 465 = 807</code></pre><h3 id=\"结题思路\"><a href=\"#结题思路\" class=\"headerlink\" title=\"结题思路\"></a>结题思路</h3><p>方法: 初等数学</p>\n<p>我们是有变量来跟踪进位,并从包含最低有效位的表头开始模拟逐位相加的过程.</p>\n<p><img src=\"https://leetcode-cn.com/problems/add-two-numbers/Figures/2/2_add_two_numbers.svg\" alt=\"示例图片\">    </p>\n<p>如图所示,对两数相加方法的可视化:342 + 465 = 807,每个节点都包含一个数字,并且数字按位逆序存储.</p>\n<p>算法</p>\n<p>就像你在纸上计算两个数字的和那样,我们首先从最低有效位也就是列表l1和l2的表头开始相加.由于每位数字都应当处于<br>0…9的范围内,我们计算两个数字的和时可能会出现”溢出”.例如:5+7 = 12.在这种情况下,我们会将当前位的数值设<br>置为2,并将进位carry = 1带入下一次迭代.进位carry必定是0或者1,这是因为两个数字相加(考虑到进位)可能出现的<br>的最大和为9+ 9+1=19   </p>\n<p>伪代码如下:</p>\n<ul>\n<li>将x设为节点p的值.如果p已经到达l1的末尾,则将其设置为0.</li>\n<li>将y设为节点q的值,如果q已经到达l2的末尾,则将其设置为0.</li>\n<li>设定sum = x + y + carry.</li>\n<li>更新进位的值,carry = sum/10.</li>\n<li>创建一个数值为(sum mod 10) 的新节点,并将其设置为当前节点的下一个节点,然后将当前节点<br> 前进到下一个节点.</li>\n<li>同时,将p和q前进到下一个节点.</li>\n<li>检查carry = 1是否成立,如果成立,则向返回列表追加一个含有数字1的新节点.</li>\n<li>返回哑节点的下一个节点.</li>\n</ul>\n<p>请注意我们使用哑节点来简化代码.如果没有哑节点,则必须编写额外的条件语句来初始化表头的值.</p>\n<p>请特别注意以下的情况:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">测试用例</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">l1 = [0,1] l2 = [0,1,2]</td>\n<td align=\"left\">当一个列表比另一个列表长时</td>\n</tr>\n<tr>\n<td align=\"left\">l1 = [] l2 = [0,1]</td>\n<td align=\"left\">当一个列表为空时,即出现空列表</td>\n</tr>\n<tr>\n<td align=\"left\">l1 = [9,9] l2 = [1]</td>\n<td align=\"left\">求和运算最后可能出现额外的进位,这一点很容易被遗忘</td>\n</tr>\n</tbody></table>\n<p>复杂度分析</p>\n<ul>\n<li><p>时间复杂度: O(max(m,n)),假设m和n分别表示l1和l2的长度,上面的算法最多重复max(m,n)次.</p>\n</li>\n<li><p>空间复杂度: O(max(m,n)),新列表的长度最多为max(m,n) + 1.</p>\n</li>\n</ul>\n<p>拓展</p>\n<p>如果链表中的数字不是按逆序存储的呢?例如:<br>(3-&gt;4-&gt;2) + (4-&gt;6-&gt;5) = 8-&gt;0-&gt;7 </p>\n<h3 id=\"代码-java\"><a href=\"#代码-java\" class=\"headerlink\" title=\"代码(java)\"></a>代码(java)</h3><pre><code>/**\n * Definition for singly-linked list.\n * public class ListNode {\n *      int val;\n *      LsitNode next;\n *      ListNode (int x) { val = x;}\n * }     \n */\n class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummyHead = new ListNode(0);\n        ListNode p = l1, q = l2, curr = dummyHead;\n        int carry =0; //进位\n        while (p != null || q != null) {\n            int x = (p != null) ? p.val : 0;\n            int y = (q != null) ? q.val : 0;\n            int sum = x + y + carry;\n            carry = sum/10;\n            curr.next = new listNode(sum%10);\n            curr = curr.next;\n            if(p != null) p=p.next;\n            if(q != null) q=q.next;\n        }\n        if(carry&gt;0) {\n            curr.next = new ListNode(carry);\n        }\n        return dummyHead.next;\n    }\n\n }</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"两数之和\"><a href=\"#两数之和\" class=\"headerlink\" title=\"两数之和\"></a>两数之和</h2><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p>\n<p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p>\n<p>示例:</p>\n<pre><code>给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]</code></pre><p>分析:</p>\n<pre><code>思路一：暴力解法，两次for循环，遍历所有可能，这也是容易想到的方法，时间复杂度O(n^2),空间复杂度O(1); \n思路二：利用哈希表，每次存储target减去当前数的差值(key)，当前值的下标(value)，当再碰到这个值时，即找到了符合要求的值。时间复杂度O(n),空间复杂度O(n);</code></pre><p>代码:</p>\n<p>1:</p>\n<pre><code>//思路一暴力解法\npublic int[] twoSum(int[] nums, int target) {\n        // write your code here\n        int[] a = new int[2];\n        for (int i = 0; i &lt; nums.length - 1; i++){\n\n            // 注意j等于i + 1;若j = 1则循环顺序不对\n            for (int j = i + 1; j &lt; nums.length; j++ ){\n                if (nums[i] + nums[j] == target){\n\n                    a[0] = i;\n                    a[1] = j;\n                    break;\n                }\n            }\n        }\n        return a;\n    }</code></pre><p>2:         </p>\n<pre><code>//思路二利用哈希表\npublic int[] twoSum(int[] nums, int target) {\n\n        int[] a = new int[2];\n        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();\n\n        for (int i = 0; i &lt; nums.length; i++){\n\n            if (map.containsKey(nums[i])){\n\n                a[0] = map.get(nums[i]);\n                a[1] = i;\n                return a;\n            }\n            map.put(target - nums[i], i);\n        }\n\n        return a;\n}</code></pre><h2 id=\"两数相加\"><a href=\"#两数相加\" class=\"headerlink\" title=\"两数相加\"></a>两数相加</h2><p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p>\n<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n<p>示例：</p>\n<pre><code>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)\n输出：7 -&gt; 0 -&gt; 8\n原因：342 + 465 = 807</code></pre><h3 id=\"结题思路\"><a href=\"#结题思路\" class=\"headerlink\" title=\"结题思路\"></a>结题思路</h3><p>方法: 初等数学</p>\n<p>我们是有变量来跟踪进位,并从包含最低有效位的表头开始模拟逐位相加的过程.</p>\n<p><img src=\"https://leetcode-cn.com/problems/add-two-numbers/Figures/2/2_add_two_numbers.svg\" alt=\"示例图片\">    </p>\n<p>如图所示,对两数相加方法的可视化:342 + 465 = 807,每个节点都包含一个数字,并且数字按位逆序存储.</p>\n<p>算法</p>\n<p>就像你在纸上计算两个数字的和那样,我们首先从最低有效位也就是列表l1和l2的表头开始相加.由于每位数字都应当处于<br>0…9的范围内,我们计算两个数字的和时可能会出现”溢出”.例如:5+7 = 12.在这种情况下,我们会将当前位的数值设<br>置为2,并将进位carry = 1带入下一次迭代.进位carry必定是0或者1,这是因为两个数字相加(考虑到进位)可能出现的<br>的最大和为9+ 9+1=19   </p>\n<p>伪代码如下:</p>\n<ul>\n<li>将x设为节点p的值.如果p已经到达l1的末尾,则将其设置为0.</li>\n<li>将y设为节点q的值,如果q已经到达l2的末尾,则将其设置为0.</li>\n<li>设定sum = x + y + carry.</li>\n<li>更新进位的值,carry = sum/10.</li>\n<li>创建一个数值为(sum mod 10) 的新节点,并将其设置为当前节点的下一个节点,然后将当前节点<br> 前进到下一个节点.</li>\n<li>同时,将p和q前进到下一个节点.</li>\n<li>检查carry = 1是否成立,如果成立,则向返回列表追加一个含有数字1的新节点.</li>\n<li>返回哑节点的下一个节点.</li>\n</ul>\n<p>请注意我们使用哑节点来简化代码.如果没有哑节点,则必须编写额外的条件语句来初始化表头的值.</p>\n<p>请特别注意以下的情况:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">测试用例</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">l1 = [0,1] l2 = [0,1,2]</td>\n<td align=\"left\">当一个列表比另一个列表长时</td>\n</tr>\n<tr>\n<td align=\"left\">l1 = [] l2 = [0,1]</td>\n<td align=\"left\">当一个列表为空时,即出现空列表</td>\n</tr>\n<tr>\n<td align=\"left\">l1 = [9,9] l2 = [1]</td>\n<td align=\"left\">求和运算最后可能出现额外的进位,这一点很容易被遗忘</td>\n</tr>\n</tbody></table>\n<p>复杂度分析</p>\n<ul>\n<li><p>时间复杂度: O(max(m,n)),假设m和n分别表示l1和l2的长度,上面的算法最多重复max(m,n)次.</p>\n</li>\n<li><p>空间复杂度: O(max(m,n)),新列表的长度最多为max(m,n) + 1.</p>\n</li>\n</ul>\n<p>拓展</p>\n<p>如果链表中的数字不是按逆序存储的呢?例如:<br>(3-&gt;4-&gt;2) + (4-&gt;6-&gt;5) = 8-&gt;0-&gt;7 </p>\n<h3 id=\"代码-java\"><a href=\"#代码-java\" class=\"headerlink\" title=\"代码(java)\"></a>代码(java)</h3><pre><code>/**\n * Definition for singly-linked list.\n * public class ListNode {\n *      int val;\n *      LsitNode next;\n *      ListNode (int x) { val = x;}\n * }     \n */\n class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummyHead = new ListNode(0);\n        ListNode p = l1, q = l2, curr = dummyHead;\n        int carry =0; //进位\n        while (p != null || q != null) {\n            int x = (p != null) ? p.val : 0;\n            int y = (q != null) ? q.val : 0;\n            int sum = x + y + carry;\n            carry = sum/10;\n            curr.next = new listNode(sum%10);\n            curr = curr.next;\n            if(p != null) p=p.next;\n            if(q != null) q=q.next;\n        }\n        if(carry&gt;0) {\n            curr.next = new ListNode(carry);\n        }\n        return dummyHead.next;\n    }\n\n }</code></pre>"},{"title":"Linux下tar.gz,tar,bz2,zip等压缩与解压缩总结","date":"2018-04-28T01:42:39.000Z","_content":"\n## tar命令基本用法:\n\ntar命令的选项有很多(用man tar可以查看到),常用的就下面几个\n\n* tar -cf all.tar *.jpg\n\n    这条命令是将所有.jpg的文件打成一个名为all.tar的包.-c是表示\n\n    生成新的包,-f指定包的文件名.\n\n* tar -rf all.tar *.gif\n    \n    这条命令是将所有.gif的文件增加到all.tar的包里面去.-r是表示增\n    \n    加文件的意思.\n    \n* tar -uf all.tar logo.gif\n\n    更新原来all.tar中logo.gif文件,-u是表示更新文件的意思\n    \n* tar -tf all.tar    \n    \n    列出all.tar中的所有文件,-u表示更新文件的意思\n    \n* tar -xf all.tar    \n\n    解出all.tar中的所有文件,-x是解开文件的意思\n    \n以上就是tar的最基本的用法,为了方便用户在打包解包的同时可以压缩或解压\n文件,tar提供了一种特殊的功能.就是tar可以在打包或解包的同时调用其他的\n压缩程序,比如调用gzip bzip2等.\n\n## 1)tar调用gzip\n\ngzip是GNU组织开发的一个压缩程序,.gz结尾的文件是gzip压缩的结果.与gzip相对\n\n的解压程序是gunzip.tar中使用-z这个参数来调用gzip\n\n* # tar -czf all.tar.gz *.jpg  \n\n将所有.jpg的文件打成一个tar包,并将其用gzip压缩,生成一个gzip压缩过的包,\n包名为all.tar.gz\n\n* # tar -xzf all.tar.gz\n\n解压包\n\n\n## 2) tar调用bzip2\n\nbzip2是一个压缩能力更强的压缩程序,.bz2结尾的文件是bzip压缩的结果.\n\n与bzip相对的解压程序是bunzip2.tar中使用-j这个参数来调用gzip.\n\n* # tar -cjf all.tar.bz2 *.jpg\n\n这条命令是将所有.jpg的文件打成一个tar包,并且将其用bzip2压缩,生成一个\nbzip2相对的压缩\n\n\n    \n    \n    \n    \n\n    \n    \n","source":"_posts/Linux下tar-gz-tar-bz2-zip等压缩与解压缩总结.md","raw":"---\ntitle: 'Linux下tar.gz,tar,bz2,zip等压缩与解压缩总结'\ndate: 2018-04-28 09:42:39\ntags: [Linux,tar,压缩,解压缩]\ncategories: \n- linux\n---\n\n## tar命令基本用法:\n\ntar命令的选项有很多(用man tar可以查看到),常用的就下面几个\n\n* tar -cf all.tar *.jpg\n\n    这条命令是将所有.jpg的文件打成一个名为all.tar的包.-c是表示\n\n    生成新的包,-f指定包的文件名.\n\n* tar -rf all.tar *.gif\n    \n    这条命令是将所有.gif的文件增加到all.tar的包里面去.-r是表示增\n    \n    加文件的意思.\n    \n* tar -uf all.tar logo.gif\n\n    更新原来all.tar中logo.gif文件,-u是表示更新文件的意思\n    \n* tar -tf all.tar    \n    \n    列出all.tar中的所有文件,-u表示更新文件的意思\n    \n* tar -xf all.tar    \n\n    解出all.tar中的所有文件,-x是解开文件的意思\n    \n以上就是tar的最基本的用法,为了方便用户在打包解包的同时可以压缩或解压\n文件,tar提供了一种特殊的功能.就是tar可以在打包或解包的同时调用其他的\n压缩程序,比如调用gzip bzip2等.\n\n## 1)tar调用gzip\n\ngzip是GNU组织开发的一个压缩程序,.gz结尾的文件是gzip压缩的结果.与gzip相对\n\n的解压程序是gunzip.tar中使用-z这个参数来调用gzip\n\n* # tar -czf all.tar.gz *.jpg  \n\n将所有.jpg的文件打成一个tar包,并将其用gzip压缩,生成一个gzip压缩过的包,\n包名为all.tar.gz\n\n* # tar -xzf all.tar.gz\n\n解压包\n\n\n## 2) tar调用bzip2\n\nbzip2是一个压缩能力更强的压缩程序,.bz2结尾的文件是bzip压缩的结果.\n\n与bzip相对的解压程序是bunzip2.tar中使用-j这个参数来调用gzip.\n\n* # tar -cjf all.tar.bz2 *.jpg\n\n这条命令是将所有.jpg的文件打成一个tar包,并且将其用bzip2压缩,生成一个\nbzip2相对的压缩\n\n\n    \n    \n    \n    \n\n    \n    \n","slug":"Linux下tar-gz-tar-bz2-zip等压缩与解压缩总结","published":1,"updated":"2019-09-27T08:27:08.027Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139ceco000fojfymrnbx7wm","content":"<h2 id=\"tar命令基本用法\"><a href=\"#tar命令基本用法\" class=\"headerlink\" title=\"tar命令基本用法:\"></a>tar命令基本用法:</h2><p>tar命令的选项有很多(用man tar可以查看到),常用的就下面几个</p>\n<ul>\n<li><p>tar -cf all.tar *.jpg</p>\n<p>  这条命令是将所有.jpg的文件打成一个名为all.tar的包.-c是表示</p>\n<p>  生成新的包,-f指定包的文件名.</p>\n</li>\n<li><p>tar -rf all.tar *.gif</p>\n<p>  这条命令是将所有.gif的文件增加到all.tar的包里面去.-r是表示增</p>\n<p>  加文件的意思.</p>\n</li>\n<li><p>tar -uf all.tar logo.gif</p>\n<p>  更新原来all.tar中logo.gif文件,-u是表示更新文件的意思</p>\n</li>\n<li><p>tar -tf all.tar    </p>\n<p>  列出all.tar中的所有文件,-u表示更新文件的意思</p>\n</li>\n<li><p>tar -xf all.tar    </p>\n<p>  解出all.tar中的所有文件,-x是解开文件的意思</p>\n</li>\n</ul>\n<p>以上就是tar的最基本的用法,为了方便用户在打包解包的同时可以压缩或解压<br>文件,tar提供了一种特殊的功能.就是tar可以在打包或解包的同时调用其他的<br>压缩程序,比如调用gzip bzip2等.</p>\n<h2 id=\"1-tar调用gzip\"><a href=\"#1-tar调用gzip\" class=\"headerlink\" title=\"1)tar调用gzip\"></a>1)tar调用gzip</h2><p>gzip是GNU组织开发的一个压缩程序,.gz结尾的文件是gzip压缩的结果.与gzip相对</p>\n<p>的解压程序是gunzip.tar中使用-z这个参数来调用gzip</p>\n<ul>\n<li><h1 id=\"tar-czf-all-tar-gz-jpg\"><a href=\"#tar-czf-all-tar-gz-jpg\" class=\"headerlink\" title=\"tar -czf all.tar.gz *.jpg\"></a>tar -czf all.tar.gz *.jpg</h1></li>\n</ul>\n<p>将所有.jpg的文件打成一个tar包,并将其用gzip压缩,生成一个gzip压缩过的包,<br>包名为all.tar.gz</p>\n<ul>\n<li><h1 id=\"tar-xzf-all-tar-gz\"><a href=\"#tar-xzf-all-tar-gz\" class=\"headerlink\" title=\"tar -xzf all.tar.gz\"></a>tar -xzf all.tar.gz</h1></li>\n</ul>\n<p>解压包</p>\n<h2 id=\"2-tar调用bzip2\"><a href=\"#2-tar调用bzip2\" class=\"headerlink\" title=\"2) tar调用bzip2\"></a>2) tar调用bzip2</h2><p>bzip2是一个压缩能力更强的压缩程序,.bz2结尾的文件是bzip压缩的结果.</p>\n<p>与bzip相对的解压程序是bunzip2.tar中使用-j这个参数来调用gzip.</p>\n<ul>\n<li><h1 id=\"tar-cjf-all-tar-bz2-jpg\"><a href=\"#tar-cjf-all-tar-bz2-jpg\" class=\"headerlink\" title=\"tar -cjf all.tar.bz2 *.jpg\"></a>tar -cjf all.tar.bz2 *.jpg</h1></li>\n</ul>\n<p>这条命令是将所有.jpg的文件打成一个tar包,并且将其用bzip2压缩,生成一个<br>bzip2相对的压缩</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"tar命令基本用法\"><a href=\"#tar命令基本用法\" class=\"headerlink\" title=\"tar命令基本用法:\"></a>tar命令基本用法:</h2><p>tar命令的选项有很多(用man tar可以查看到),常用的就下面几个</p>\n<ul>\n<li><p>tar -cf all.tar *.jpg</p>\n<p>  这条命令是将所有.jpg的文件打成一个名为all.tar的包.-c是表示</p>\n<p>  生成新的包,-f指定包的文件名.</p>\n</li>\n<li><p>tar -rf all.tar *.gif</p>\n<p>  这条命令是将所有.gif的文件增加到all.tar的包里面去.-r是表示增</p>\n<p>  加文件的意思.</p>\n</li>\n<li><p>tar -uf all.tar logo.gif</p>\n<p>  更新原来all.tar中logo.gif文件,-u是表示更新文件的意思</p>\n</li>\n<li><p>tar -tf all.tar    </p>\n<p>  列出all.tar中的所有文件,-u表示更新文件的意思</p>\n</li>\n<li><p>tar -xf all.tar    </p>\n<p>  解出all.tar中的所有文件,-x是解开文件的意思</p>\n</li>\n</ul>\n<p>以上就是tar的最基本的用法,为了方便用户在打包解包的同时可以压缩或解压<br>文件,tar提供了一种特殊的功能.就是tar可以在打包或解包的同时调用其他的<br>压缩程序,比如调用gzip bzip2等.</p>\n<h2 id=\"1-tar调用gzip\"><a href=\"#1-tar调用gzip\" class=\"headerlink\" title=\"1)tar调用gzip\"></a>1)tar调用gzip</h2><p>gzip是GNU组织开发的一个压缩程序,.gz结尾的文件是gzip压缩的结果.与gzip相对</p>\n<p>的解压程序是gunzip.tar中使用-z这个参数来调用gzip</p>\n<ul>\n<li><h1 id=\"tar-czf-all-tar-gz-jpg\"><a href=\"#tar-czf-all-tar-gz-jpg\" class=\"headerlink\" title=\"tar -czf all.tar.gz *.jpg\"></a>tar -czf all.tar.gz *.jpg</h1></li>\n</ul>\n<p>将所有.jpg的文件打成一个tar包,并将其用gzip压缩,生成一个gzip压缩过的包,<br>包名为all.tar.gz</p>\n<ul>\n<li><h1 id=\"tar-xzf-all-tar-gz\"><a href=\"#tar-xzf-all-tar-gz\" class=\"headerlink\" title=\"tar -xzf all.tar.gz\"></a>tar -xzf all.tar.gz</h1></li>\n</ul>\n<p>解压包</p>\n<h2 id=\"2-tar调用bzip2\"><a href=\"#2-tar调用bzip2\" class=\"headerlink\" title=\"2) tar调用bzip2\"></a>2) tar调用bzip2</h2><p>bzip2是一个压缩能力更强的压缩程序,.bz2结尾的文件是bzip压缩的结果.</p>\n<p>与bzip相对的解压程序是bunzip2.tar中使用-j这个参数来调用gzip.</p>\n<ul>\n<li><h1 id=\"tar-cjf-all-tar-bz2-jpg\"><a href=\"#tar-cjf-all-tar-bz2-jpg\" class=\"headerlink\" title=\"tar -cjf all.tar.bz2 *.jpg\"></a>tar -cjf all.tar.bz2 *.jpg</h1></li>\n</ul>\n<p>这条命令是将所有.jpg的文件打成一个tar包,并且将其用bzip2压缩,生成一个<br>bzip2相对的压缩</p>\n"},{"title":"Linux常用命令","date":"2018-07-27T03:41:49.000Z","_content":"# 日常操作命令\n\n## 查看当前所在的工作目录的全路径pwd\n\n    [root@localhost ~]# pwd\n    /root\n    \n## 查看当前系统的时间date\n\n    [root@localhost ~]# date +%Y-%m-%d\n    \n    date +%Y-%m-%d --date=\"-1 day\" #加减也可以 month | year\n    \n    date -s \"2016-07-28 16:12:00\" ## 修改时间\n    \n## 查看有谁在线(哪些人登陆了服务器)    \n\n    who 查看当前在线\n    \n    last 查看最近的登陆历史记录\n    \n## 关机/重启\n\n    关机(必须用root用户)\n    shutdown -h now ## 立刻关机\n    shutdown -h +10 ## 10分钟以后关机\n    shutdown -h 12:00:00 ## 12点整的时候关机\n    halt #  等于立刻关机\n    \n    重启\n    shutdown -r now\n    reboot # 等于立刻重启\n    \n## 清屏\n\n    clear ## 或者用快捷键 Ctrl + 1\n    \n## 退出当前进程\n    Ctrl + c  ##有些程序也可以用q键退出\n    \n## 挂起当前进程\n    Ctrl + z ## 进程会挂起到后台\n    bg jobid ## 进程在后台继续执行\n    fg jobid ## 让进程回到前台\n            \n## echo\n    相当于Java中System.out.println(userName)\n    a=\"test\"\n    echo a ## a\n    echo $a ## test\n                \n# 目录操作\n                \n## 查看目录信息\n    ls / ## 查看根目录下的子节点(文件夹和文件)信息\n    ls -al ## -a是显示隐藏文件 -l是以更详细的列表形式显示\n    ls -l ## 有一个别名: ll 可以直接使用ll<是两个L>\n                    \n## 切换工作目录\n    cd ~ ##切换都用户主目录\n    cd - ##切换上次所在的目录\n    cd 什么都不带,则回到用户的主目录\n    \n## 创建文件夹\n    mkdir aaa ## 这是相对路径的写法\n    mkdir /data ## 这是绝对路径的写法\n    mkdir -p aaa/bbb/ccc ## 级联创建目录\n## 删除文件夹\n    rmdir aaa ##可以删除空目录\n    rm -r aaa ## 可以把aaa整个文件夹及其中的所有子节点全部删除\n    rm -rf aaa ## 强制删除aaa\n            \n## 修改文件夹名称\n    mv aaa boy\n    mv本质上是移动\n    mv install.log aaa/ 将当前目录下的install.log移动到aaa文件夹中去\n    \n    rename 可以用来批量更改文件名\n    [root@localhost aaa]# ll\n    total 0\n    -rw-r--r--. 1 root root 0 Jul 28 17:33 1.txt\n    -rw-r--r--. 1 root root 0 Jul 28 17:33 2.txt\n    -rw-r--r--. 1 root root 0 Jul 28 17:33 3.txt\n    [root@localhost aaa]# rename .txt .txt.bak *\n    [root@localhost aaa]# ll\n    total 0\n    -rw-r--r--. 1 root root 0 Jul 28 17:33 1.txt.bak\n    -rw-r--r--. 1 root root 0 Jul 28 17:33 2.txt.bak\n    -rw-r--r--. 1 root root 0 Jul 28 17:33 3.txt.bak\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                    \n    ","source":"_posts/Linux常用命令.md","raw":"---\ntitle: Linux常用命令\ndate: 2018-07-27 11:41:49\ntags: [Linux,命令]\ncategories: \n- linux\n---\n# 日常操作命令\n\n## 查看当前所在的工作目录的全路径pwd\n\n    [root@localhost ~]# pwd\n    /root\n    \n## 查看当前系统的时间date\n\n    [root@localhost ~]# date +%Y-%m-%d\n    \n    date +%Y-%m-%d --date=\"-1 day\" #加减也可以 month | year\n    \n    date -s \"2016-07-28 16:12:00\" ## 修改时间\n    \n## 查看有谁在线(哪些人登陆了服务器)    \n\n    who 查看当前在线\n    \n    last 查看最近的登陆历史记录\n    \n## 关机/重启\n\n    关机(必须用root用户)\n    shutdown -h now ## 立刻关机\n    shutdown -h +10 ## 10分钟以后关机\n    shutdown -h 12:00:00 ## 12点整的时候关机\n    halt #  等于立刻关机\n    \n    重启\n    shutdown -r now\n    reboot # 等于立刻重启\n    \n## 清屏\n\n    clear ## 或者用快捷键 Ctrl + 1\n    \n## 退出当前进程\n    Ctrl + c  ##有些程序也可以用q键退出\n    \n## 挂起当前进程\n    Ctrl + z ## 进程会挂起到后台\n    bg jobid ## 进程在后台继续执行\n    fg jobid ## 让进程回到前台\n            \n## echo\n    相当于Java中System.out.println(userName)\n    a=\"test\"\n    echo a ## a\n    echo $a ## test\n                \n# 目录操作\n                \n## 查看目录信息\n    ls / ## 查看根目录下的子节点(文件夹和文件)信息\n    ls -al ## -a是显示隐藏文件 -l是以更详细的列表形式显示\n    ls -l ## 有一个别名: ll 可以直接使用ll<是两个L>\n                    \n## 切换工作目录\n    cd ~ ##切换都用户主目录\n    cd - ##切换上次所在的目录\n    cd 什么都不带,则回到用户的主目录\n    \n## 创建文件夹\n    mkdir aaa ## 这是相对路径的写法\n    mkdir /data ## 这是绝对路径的写法\n    mkdir -p aaa/bbb/ccc ## 级联创建目录\n## 删除文件夹\n    rmdir aaa ##可以删除空目录\n    rm -r aaa ## 可以把aaa整个文件夹及其中的所有子节点全部删除\n    rm -rf aaa ## 强制删除aaa\n            \n## 修改文件夹名称\n    mv aaa boy\n    mv本质上是移动\n    mv install.log aaa/ 将当前目录下的install.log移动到aaa文件夹中去\n    \n    rename 可以用来批量更改文件名\n    [root@localhost aaa]# ll\n    total 0\n    -rw-r--r--. 1 root root 0 Jul 28 17:33 1.txt\n    -rw-r--r--. 1 root root 0 Jul 28 17:33 2.txt\n    -rw-r--r--. 1 root root 0 Jul 28 17:33 3.txt\n    [root@localhost aaa]# rename .txt .txt.bak *\n    [root@localhost aaa]# ll\n    total 0\n    -rw-r--r--. 1 root root 0 Jul 28 17:33 1.txt.bak\n    -rw-r--r--. 1 root root 0 Jul 28 17:33 2.txt.bak\n    -rw-r--r--. 1 root root 0 Jul 28 17:33 3.txt.bak\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                    \n    ","slug":"Linux常用命令","published":1,"updated":"2019-09-27T08:27:08.028Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecp000gojfydrrtwdsa","content":"<h1 id=\"日常操作命令\"><a href=\"#日常操作命令\" class=\"headerlink\" title=\"日常操作命令\"></a>日常操作命令</h1><h2 id=\"查看当前所在的工作目录的全路径pwd\"><a href=\"#查看当前所在的工作目录的全路径pwd\" class=\"headerlink\" title=\"查看当前所在的工作目录的全路径pwd\"></a>查看当前所在的工作目录的全路径pwd</h2><pre><code>[root@localhost ~]# pwd\n/root</code></pre><h2 id=\"查看当前系统的时间date\"><a href=\"#查看当前系统的时间date\" class=\"headerlink\" title=\"查看当前系统的时间date\"></a>查看当前系统的时间date</h2><pre><code>[root@localhost ~]# date +%Y-%m-%d\n\ndate +%Y-%m-%d --date=&quot;-1 day&quot; #加减也可以 month | year\n\ndate -s &quot;2016-07-28 16:12:00&quot; ## 修改时间</code></pre><h2 id=\"查看有谁在线-哪些人登陆了服务器\"><a href=\"#查看有谁在线-哪些人登陆了服务器\" class=\"headerlink\" title=\"查看有谁在线(哪些人登陆了服务器)\"></a>查看有谁在线(哪些人登陆了服务器)</h2><pre><code>who 查看当前在线\n\nlast 查看最近的登陆历史记录</code></pre><h2 id=\"关机-重启\"><a href=\"#关机-重启\" class=\"headerlink\" title=\"关机/重启\"></a>关机/重启</h2><pre><code>关机(必须用root用户)\nshutdown -h now ## 立刻关机\nshutdown -h +10 ## 10分钟以后关机\nshutdown -h 12:00:00 ## 12点整的时候关机\nhalt #  等于立刻关机\n\n重启\nshutdown -r now\nreboot # 等于立刻重启</code></pre><h2 id=\"清屏\"><a href=\"#清屏\" class=\"headerlink\" title=\"清屏\"></a>清屏</h2><pre><code>clear ## 或者用快捷键 Ctrl + 1</code></pre><h2 id=\"退出当前进程\"><a href=\"#退出当前进程\" class=\"headerlink\" title=\"退出当前进程\"></a>退出当前进程</h2><pre><code>Ctrl + c  ##有些程序也可以用q键退出</code></pre><h2 id=\"挂起当前进程\"><a href=\"#挂起当前进程\" class=\"headerlink\" title=\"挂起当前进程\"></a>挂起当前进程</h2><pre><code>Ctrl + z ## 进程会挂起到后台\nbg jobid ## 进程在后台继续执行\nfg jobid ## 让进程回到前台</code></pre><h2 id=\"echo\"><a href=\"#echo\" class=\"headerlink\" title=\"echo\"></a>echo</h2><pre><code>相当于Java中System.out.println(userName)\na=&quot;test&quot;\necho a ## a\necho $a ## test</code></pre><h1 id=\"目录操作\"><a href=\"#目录操作\" class=\"headerlink\" title=\"目录操作\"></a>目录操作</h1><h2 id=\"查看目录信息\"><a href=\"#查看目录信息\" class=\"headerlink\" title=\"查看目录信息\"></a>查看目录信息</h2><pre><code>ls / ## 查看根目录下的子节点(文件夹和文件)信息\nls -al ## -a是显示隐藏文件 -l是以更详细的列表形式显示\nls -l ## 有一个别名: ll 可以直接使用ll&lt;是两个L&gt;</code></pre><h2 id=\"切换工作目录\"><a href=\"#切换工作目录\" class=\"headerlink\" title=\"切换工作目录\"></a>切换工作目录</h2><pre><code>cd ~ ##切换都用户主目录\ncd - ##切换上次所在的目录\ncd 什么都不带,则回到用户的主目录</code></pre><h2 id=\"创建文件夹\"><a href=\"#创建文件夹\" class=\"headerlink\" title=\"创建文件夹\"></a>创建文件夹</h2><pre><code>mkdir aaa ## 这是相对路径的写法\nmkdir /data ## 这是绝对路径的写法\nmkdir -p aaa/bbb/ccc ## 级联创建目录</code></pre><h2 id=\"删除文件夹\"><a href=\"#删除文件夹\" class=\"headerlink\" title=\"删除文件夹\"></a>删除文件夹</h2><pre><code>rmdir aaa ##可以删除空目录\nrm -r aaa ## 可以把aaa整个文件夹及其中的所有子节点全部删除\nrm -rf aaa ## 强制删除aaa</code></pre><h2 id=\"修改文件夹名称\"><a href=\"#修改文件夹名称\" class=\"headerlink\" title=\"修改文件夹名称\"></a>修改文件夹名称</h2><pre><code>mv aaa boy\nmv本质上是移动\nmv install.log aaa/ 将当前目录下的install.log移动到aaa文件夹中去\n\nrename 可以用来批量更改文件名\n[root@localhost aaa]# ll\ntotal 0\n-rw-r--r--. 1 root root 0 Jul 28 17:33 1.txt\n-rw-r--r--. 1 root root 0 Jul 28 17:33 2.txt\n-rw-r--r--. 1 root root 0 Jul 28 17:33 3.txt\n[root@localhost aaa]# rename .txt .txt.bak *\n[root@localhost aaa]# ll\ntotal 0\n-rw-r--r--. 1 root root 0 Jul 28 17:33 1.txt.bak\n-rw-r--r--. 1 root root 0 Jul 28 17:33 2.txt.bak\n-rw-r--r--. 1 root root 0 Jul 28 17:33 3.txt.bak</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"日常操作命令\"><a href=\"#日常操作命令\" class=\"headerlink\" title=\"日常操作命令\"></a>日常操作命令</h1><h2 id=\"查看当前所在的工作目录的全路径pwd\"><a href=\"#查看当前所在的工作目录的全路径pwd\" class=\"headerlink\" title=\"查看当前所在的工作目录的全路径pwd\"></a>查看当前所在的工作目录的全路径pwd</h2><pre><code>[root@localhost ~]# pwd\n/root</code></pre><h2 id=\"查看当前系统的时间date\"><a href=\"#查看当前系统的时间date\" class=\"headerlink\" title=\"查看当前系统的时间date\"></a>查看当前系统的时间date</h2><pre><code>[root@localhost ~]# date +%Y-%m-%d\n\ndate +%Y-%m-%d --date=&quot;-1 day&quot; #加减也可以 month | year\n\ndate -s &quot;2016-07-28 16:12:00&quot; ## 修改时间</code></pre><h2 id=\"查看有谁在线-哪些人登陆了服务器\"><a href=\"#查看有谁在线-哪些人登陆了服务器\" class=\"headerlink\" title=\"查看有谁在线(哪些人登陆了服务器)\"></a>查看有谁在线(哪些人登陆了服务器)</h2><pre><code>who 查看当前在线\n\nlast 查看最近的登陆历史记录</code></pre><h2 id=\"关机-重启\"><a href=\"#关机-重启\" class=\"headerlink\" title=\"关机/重启\"></a>关机/重启</h2><pre><code>关机(必须用root用户)\nshutdown -h now ## 立刻关机\nshutdown -h +10 ## 10分钟以后关机\nshutdown -h 12:00:00 ## 12点整的时候关机\nhalt #  等于立刻关机\n\n重启\nshutdown -r now\nreboot # 等于立刻重启</code></pre><h2 id=\"清屏\"><a href=\"#清屏\" class=\"headerlink\" title=\"清屏\"></a>清屏</h2><pre><code>clear ## 或者用快捷键 Ctrl + 1</code></pre><h2 id=\"退出当前进程\"><a href=\"#退出当前进程\" class=\"headerlink\" title=\"退出当前进程\"></a>退出当前进程</h2><pre><code>Ctrl + c  ##有些程序也可以用q键退出</code></pre><h2 id=\"挂起当前进程\"><a href=\"#挂起当前进程\" class=\"headerlink\" title=\"挂起当前进程\"></a>挂起当前进程</h2><pre><code>Ctrl + z ## 进程会挂起到后台\nbg jobid ## 进程在后台继续执行\nfg jobid ## 让进程回到前台</code></pre><h2 id=\"echo\"><a href=\"#echo\" class=\"headerlink\" title=\"echo\"></a>echo</h2><pre><code>相当于Java中System.out.println(userName)\na=&quot;test&quot;\necho a ## a\necho $a ## test</code></pre><h1 id=\"目录操作\"><a href=\"#目录操作\" class=\"headerlink\" title=\"目录操作\"></a>目录操作</h1><h2 id=\"查看目录信息\"><a href=\"#查看目录信息\" class=\"headerlink\" title=\"查看目录信息\"></a>查看目录信息</h2><pre><code>ls / ## 查看根目录下的子节点(文件夹和文件)信息\nls -al ## -a是显示隐藏文件 -l是以更详细的列表形式显示\nls -l ## 有一个别名: ll 可以直接使用ll&lt;是两个L&gt;</code></pre><h2 id=\"切换工作目录\"><a href=\"#切换工作目录\" class=\"headerlink\" title=\"切换工作目录\"></a>切换工作目录</h2><pre><code>cd ~ ##切换都用户主目录\ncd - ##切换上次所在的目录\ncd 什么都不带,则回到用户的主目录</code></pre><h2 id=\"创建文件夹\"><a href=\"#创建文件夹\" class=\"headerlink\" title=\"创建文件夹\"></a>创建文件夹</h2><pre><code>mkdir aaa ## 这是相对路径的写法\nmkdir /data ## 这是绝对路径的写法\nmkdir -p aaa/bbb/ccc ## 级联创建目录</code></pre><h2 id=\"删除文件夹\"><a href=\"#删除文件夹\" class=\"headerlink\" title=\"删除文件夹\"></a>删除文件夹</h2><pre><code>rmdir aaa ##可以删除空目录\nrm -r aaa ## 可以把aaa整个文件夹及其中的所有子节点全部删除\nrm -rf aaa ## 强制删除aaa</code></pre><h2 id=\"修改文件夹名称\"><a href=\"#修改文件夹名称\" class=\"headerlink\" title=\"修改文件夹名称\"></a>修改文件夹名称</h2><pre><code>mv aaa boy\nmv本质上是移动\nmv install.log aaa/ 将当前目录下的install.log移动到aaa文件夹中去\n\nrename 可以用来批量更改文件名\n[root@localhost aaa]# ll\ntotal 0\n-rw-r--r--. 1 root root 0 Jul 28 17:33 1.txt\n-rw-r--r--. 1 root root 0 Jul 28 17:33 2.txt\n-rw-r--r--. 1 root root 0 Jul 28 17:33 3.txt\n[root@localhost aaa]# rename .txt .txt.bak *\n[root@localhost aaa]# ll\ntotal 0\n-rw-r--r--. 1 root root 0 Jul 28 17:33 1.txt.bak\n-rw-r--r--. 1 root root 0 Jul 28 17:33 2.txt.bak\n-rw-r--r--. 1 root root 0 Jul 28 17:33 3.txt.bak</code></pre>"},{"title":"Linux简介","date":"2018-04-24T08:19:03.000Z","_content":"\n\tLinux内核最初是由芬兰人李纳斯.托瓦兹(Linux Torvalds)在赫尔辛基上大学时出于个人爱好而编写的.\n\tLinux是一套免费使用和自由传播的类Unix操作系统.是一个基于POSIX和UNIX的多用户 多任务 支持多线\n\t程和多CPU的操作系统.\n\n\tLinux能运行主要的UNIX工具软件 应用程序和网络协议.它支持32位和64位硬件.Linux继承了Unix以网络\n\t为核心的设计思想,是一个性能稳定的多用户网络操作系统.\n\n## Linux的发行版本\n\n\tLinux的发行版本简单说就是讲Linux内核与应用软件做一个打包.\n\t目前市面上比较知名的发行版有:\n\t\n###\tUbuntu\n###\tReaHat\n###\tCentOS\n###\tDebian\n###\tFefora\n###\tSuSE\n###\tOpenSUSE\n###\tArch Linux\n###\tSolusOS\n\n## Linux 系统启动过程\n    \nLinux系统的启动的启动过程分为5个阶段\n\n* 内核的引导\n\n* 运行init\n\n* 系统初始化\n\n* 建立终端\n\n* 用户登录系统\n\n    init 程序的类型\n    \n    * SysV:init,CentOS5之前,配置文件: /etc/initab.\n    \n    * Upstart:init,CentOS6,配置文件: /etc/inittab,/etc/init/*.conf.\n    \n    * Systemd: systemd,CenOS 7配置文件: /user/lib/systemd/system  /etc/systemd/system\n    \n    \n## 内核引导\n\n当计算机打开电源后,首先是BIOS开机自检,按照BIOS中设置的启动设备(通常是硬盘)来启动.\n操作系统接管硬件以后,首先读入/boot目录下的内核文件\n\n操作系统 -----> boot --->\n\n## 运行init    \n\ninit进程是系统所有进程的起点,你可以把它比拟成系统所有进程的老祖宗,没有这个进程,系统\n中任何进程都不会启动.\ninit程序首先需要读取配置文件 /etc/inittab.\n\n操作系统 -----> boot ---> init进程 --->运行级别\n\nLinux系统有七个运行级别\n    \n   * 0 : 系统停机状态,系统默认运行级别不能设为0,否则不能正常启动\n   \n   * 1 : 单用户工作状态,root权限,用于系统维护,禁止远程登录\n   \n   * 2 : 多用户状态(没有NFS)\n   \n   * 3 : 完全的多用户状态,登录后进入控制台命令行模式\n   \n   * 4 : 系统未使用,保留\n   \n   * 5 : X11控制台,登录后进入图形GUI模式\n   \n   * 6 : 系统正常关闭并重启,默认运行级别不能设为6,否则不能正常启动\n   \n   \n## 系统初始化   \n\n在init的配置文件中有这么一行: si:sysinit:/etc/rc.d/rc.sysint 它调用执行了\n\n/etc/rc.d/rc.sysinit 它调用执行了/etc/rc.d/rc.sysinit,而rc.sysinit是一个bash\n\nshell 的脚本 ,它主要是完成一些系统初始化的工作,rc.sysinit是每一个运行级别都\n\n要首先运行的重要脚本.\n\n它主要完成的工作有:激活交换区,检查磁盘,加载硬件模块以及其他一些需要优先执行\n\n任务.\n\n15:5:wait:/etc/rc.d/rc 5\n\n这一行表示以5为参数运行/etc/rc.d/rc, /etc/rc.d/rc是一个shell脚本,它接收5作为参数\n\n,去执行/etc/rc.d/rc5.d/目录下的所有的rc启用脚本,/etc/rc.d/rc5.d/目录中的这些启动\n\n脚本实际上都是一些连接文件,而不是真正的rc启动脚本,真正的rc启动脚本实际上都是放在\n\n/etc/rc.d/init.d/目录下\n\n而这些rc启动脚本有着类似的用法,它们一般能接受start stop restart status等参数.\n\n/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的连接文件,用于以S开头的启动脚本\n\n,将以start参数来运行. 而如果发现存在相应的脚本也存在K打头的连接,而且已经处于运\n\n行状态了(以/var/lock/subsys/下的文件为标志),则将首先以stop为参数停止这些已经启动\n\n了的守护进程,然后再重新运行.\n\n这样做是为了保证当init改变运行级别时,所有相关的守护进程将重启.\n\n至于在每个运行级别中将运行哪些守护进程,用户可以通过chkconfig或setup中的\n\n\"System Services\"来自行设定.\n\n操作系统 ---> /boot ---> init进程 ---> 运行级别 ---> /etc/init.d\n\n\n## 建立终端\n\nrc执行完毕后,返回init.这时基本系统环境已经设置好了,各种守护进程也已经启动了.\n\ninit接下来会打开6个终端,以便用户登录系统.在inittab中的以下6行就是定义了6个终\n\n端:\n\n1:2345:respawn:/sbin/mingetty tty1\n\n2:2345:respawn:/sbin/mingetty tty2\n\n3:2345:respawn:/sbin/mingetty tty3\n\n4:2345:respawn:/sbin/mingetty tty4\n\n5:2345:respawn:/sbin/mingetty tty5\n\n6:2345:respawn:/sbin/mingetty tty6\n\n从上面可以看出在2 3 4 5的运行级别中都将以 respawn 方式运行mingetty程序能打开终端\n\n设置模式.同时它会显示一个文本登录界面,这个界面就是我们经常看到的登录界面,在这个等\n\n录界面中会提示用户输入用户名,而用户输入的用户名将作为参数传给login程序来验证用户的\n\n身份\n\n## 用户登录系统\n\n一般来说,用户的登录方式有三种:\n\n* 1 命令行登录\n\n* 2 ssh登录\n\n* 3 图形界面登录\n\n操作系统 --> /boot --> init进程 --> 运行级别 --> /etc/init.d --> 用户登录\n\n对于运行级别为5的图形方式用户来说,他们的登录是通过一个图形化的登录界面.登录\n\n成功后可以直接进入 KDE 或 Gnome 等窗口管理器 \n\n而本文主要讲的是文本登录:当我们看到mingetty的登录界面时,我们就可以输入用户名\n\n和密码来登录系统了.\n\nLinux的账号验证程序是login,login会接收mingetty传来的用户名作为用户名参数.\n\n然后login会对用户名进行分析:如果用户名不是root,且存在/etc/nologin文件,login\n\n将输出nologin文件的内容,然后退出.\n\n这通常用来系统维护时防止非root用户登录.只有/etc/securetty中登记了的终端才允许\n\nroot用户登录,如果不存在这个文件,则root用户可以在任何终端上登录.\n\n/etc/usetty文件用于对用户作出附加访问限制,如果不存在这个文件,则没有其他限制\n\n## 图形模式与文字模式的切换方式\n\nLinux预设提供了六个命令 窗口终端机让我们来登录.\n\n默认我们登录的就是第一个窗口,也就是tty1,这六个窗口分别为 tt1,tt2,tt3...tt6,\n你可以按下\n\nCtrl + Alt + F1 ~ F6\n\n来切换它们\n\n如果你安装了图形界面,默认情况下是进入图形界面的,此时你就可以按Ctrl+Alt+F1~F6来\n进入其中一个命令窗口界面.当你进入命令窗口界面后再返回图形界面只要按下\n\nCtrl + Alt + F7就回来了\n\n如果你用的vmware虚拟机,命令窗口切换的快捷键位Alt+Space+F1~F6.如果你在图形界面下\n\n请按Alt+Shift+Ctrl+F1~F6切换至命令窗口.\n\n操作系统 --> /boot --> init进程 --> 运行级别 --> /etc/init.d \n                                                        |\n                                                        |\n                                       login shell <--用户登录\n\n## Linux 关机\n\n在Linux领域内大多用再服务器上,很少遇到关机的操作,毕竟服务器上跑一个服务时永无止境的,\n除非特殊情况下,不得已才会关机.\n\n正确的关机流程为 : sync > shutdown > reboot > halt\n\n关机指令为 : shutdown,你可以man shutdown来看一下邦之文档.\n\n* sync 将数据由内存同步到硬盘中\n\n* shutdown 关机指令,你可以man shutdown来看一文档\n\n* shutdown -h 10  10分钟后关机\n\n* shutdown -h now 立马关机\n\n* shutdown -h 20:25 系统会在今天20:25关机\n\n* shutdown -h +10 十分钟后关机\n\n* shutdown -r now 立马重启\n\n* shutdown -r +10 十分钟后重启\n\n* reboot 重启,等同于 shutdown -r now\n\n* halt 关闭系统,等同于 shutdown -h now 和 poweroff\n\n最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。\n关机的命令有 shutdown –h now halt poweroff 和 init 0 , 重启系统的命令有 shutdown –r now reboot init 6。\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Linux简介.md","raw":"---\ntitle: Linux简介\ndate: 2018-04-24 16:19:03\ntags: Linux\ncategories: \n- linux\n---\n\n\tLinux内核最初是由芬兰人李纳斯.托瓦兹(Linux Torvalds)在赫尔辛基上大学时出于个人爱好而编写的.\n\tLinux是一套免费使用和自由传播的类Unix操作系统.是一个基于POSIX和UNIX的多用户 多任务 支持多线\n\t程和多CPU的操作系统.\n\n\tLinux能运行主要的UNIX工具软件 应用程序和网络协议.它支持32位和64位硬件.Linux继承了Unix以网络\n\t为核心的设计思想,是一个性能稳定的多用户网络操作系统.\n\n## Linux的发行版本\n\n\tLinux的发行版本简单说就是讲Linux内核与应用软件做一个打包.\n\t目前市面上比较知名的发行版有:\n\t\n###\tUbuntu\n###\tReaHat\n###\tCentOS\n###\tDebian\n###\tFefora\n###\tSuSE\n###\tOpenSUSE\n###\tArch Linux\n###\tSolusOS\n\n## Linux 系统启动过程\n    \nLinux系统的启动的启动过程分为5个阶段\n\n* 内核的引导\n\n* 运行init\n\n* 系统初始化\n\n* 建立终端\n\n* 用户登录系统\n\n    init 程序的类型\n    \n    * SysV:init,CentOS5之前,配置文件: /etc/initab.\n    \n    * Upstart:init,CentOS6,配置文件: /etc/inittab,/etc/init/*.conf.\n    \n    * Systemd: systemd,CenOS 7配置文件: /user/lib/systemd/system  /etc/systemd/system\n    \n    \n## 内核引导\n\n当计算机打开电源后,首先是BIOS开机自检,按照BIOS中设置的启动设备(通常是硬盘)来启动.\n操作系统接管硬件以后,首先读入/boot目录下的内核文件\n\n操作系统 -----> boot --->\n\n## 运行init    \n\ninit进程是系统所有进程的起点,你可以把它比拟成系统所有进程的老祖宗,没有这个进程,系统\n中任何进程都不会启动.\ninit程序首先需要读取配置文件 /etc/inittab.\n\n操作系统 -----> boot ---> init进程 --->运行级别\n\nLinux系统有七个运行级别\n    \n   * 0 : 系统停机状态,系统默认运行级别不能设为0,否则不能正常启动\n   \n   * 1 : 单用户工作状态,root权限,用于系统维护,禁止远程登录\n   \n   * 2 : 多用户状态(没有NFS)\n   \n   * 3 : 完全的多用户状态,登录后进入控制台命令行模式\n   \n   * 4 : 系统未使用,保留\n   \n   * 5 : X11控制台,登录后进入图形GUI模式\n   \n   * 6 : 系统正常关闭并重启,默认运行级别不能设为6,否则不能正常启动\n   \n   \n## 系统初始化   \n\n在init的配置文件中有这么一行: si:sysinit:/etc/rc.d/rc.sysint 它调用执行了\n\n/etc/rc.d/rc.sysinit 它调用执行了/etc/rc.d/rc.sysinit,而rc.sysinit是一个bash\n\nshell 的脚本 ,它主要是完成一些系统初始化的工作,rc.sysinit是每一个运行级别都\n\n要首先运行的重要脚本.\n\n它主要完成的工作有:激活交换区,检查磁盘,加载硬件模块以及其他一些需要优先执行\n\n任务.\n\n15:5:wait:/etc/rc.d/rc 5\n\n这一行表示以5为参数运行/etc/rc.d/rc, /etc/rc.d/rc是一个shell脚本,它接收5作为参数\n\n,去执行/etc/rc.d/rc5.d/目录下的所有的rc启用脚本,/etc/rc.d/rc5.d/目录中的这些启动\n\n脚本实际上都是一些连接文件,而不是真正的rc启动脚本,真正的rc启动脚本实际上都是放在\n\n/etc/rc.d/init.d/目录下\n\n而这些rc启动脚本有着类似的用法,它们一般能接受start stop restart status等参数.\n\n/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的连接文件,用于以S开头的启动脚本\n\n,将以start参数来运行. 而如果发现存在相应的脚本也存在K打头的连接,而且已经处于运\n\n行状态了(以/var/lock/subsys/下的文件为标志),则将首先以stop为参数停止这些已经启动\n\n了的守护进程,然后再重新运行.\n\n这样做是为了保证当init改变运行级别时,所有相关的守护进程将重启.\n\n至于在每个运行级别中将运行哪些守护进程,用户可以通过chkconfig或setup中的\n\n\"System Services\"来自行设定.\n\n操作系统 ---> /boot ---> init进程 ---> 运行级别 ---> /etc/init.d\n\n\n## 建立终端\n\nrc执行完毕后,返回init.这时基本系统环境已经设置好了,各种守护进程也已经启动了.\n\ninit接下来会打开6个终端,以便用户登录系统.在inittab中的以下6行就是定义了6个终\n\n端:\n\n1:2345:respawn:/sbin/mingetty tty1\n\n2:2345:respawn:/sbin/mingetty tty2\n\n3:2345:respawn:/sbin/mingetty tty3\n\n4:2345:respawn:/sbin/mingetty tty4\n\n5:2345:respawn:/sbin/mingetty tty5\n\n6:2345:respawn:/sbin/mingetty tty6\n\n从上面可以看出在2 3 4 5的运行级别中都将以 respawn 方式运行mingetty程序能打开终端\n\n设置模式.同时它会显示一个文本登录界面,这个界面就是我们经常看到的登录界面,在这个等\n\n录界面中会提示用户输入用户名,而用户输入的用户名将作为参数传给login程序来验证用户的\n\n身份\n\n## 用户登录系统\n\n一般来说,用户的登录方式有三种:\n\n* 1 命令行登录\n\n* 2 ssh登录\n\n* 3 图形界面登录\n\n操作系统 --> /boot --> init进程 --> 运行级别 --> /etc/init.d --> 用户登录\n\n对于运行级别为5的图形方式用户来说,他们的登录是通过一个图形化的登录界面.登录\n\n成功后可以直接进入 KDE 或 Gnome 等窗口管理器 \n\n而本文主要讲的是文本登录:当我们看到mingetty的登录界面时,我们就可以输入用户名\n\n和密码来登录系统了.\n\nLinux的账号验证程序是login,login会接收mingetty传来的用户名作为用户名参数.\n\n然后login会对用户名进行分析:如果用户名不是root,且存在/etc/nologin文件,login\n\n将输出nologin文件的内容,然后退出.\n\n这通常用来系统维护时防止非root用户登录.只有/etc/securetty中登记了的终端才允许\n\nroot用户登录,如果不存在这个文件,则root用户可以在任何终端上登录.\n\n/etc/usetty文件用于对用户作出附加访问限制,如果不存在这个文件,则没有其他限制\n\n## 图形模式与文字模式的切换方式\n\nLinux预设提供了六个命令 窗口终端机让我们来登录.\n\n默认我们登录的就是第一个窗口,也就是tty1,这六个窗口分别为 tt1,tt2,tt3...tt6,\n你可以按下\n\nCtrl + Alt + F1 ~ F6\n\n来切换它们\n\n如果你安装了图形界面,默认情况下是进入图形界面的,此时你就可以按Ctrl+Alt+F1~F6来\n进入其中一个命令窗口界面.当你进入命令窗口界面后再返回图形界面只要按下\n\nCtrl + Alt + F7就回来了\n\n如果你用的vmware虚拟机,命令窗口切换的快捷键位Alt+Space+F1~F6.如果你在图形界面下\n\n请按Alt+Shift+Ctrl+F1~F6切换至命令窗口.\n\n操作系统 --> /boot --> init进程 --> 运行级别 --> /etc/init.d \n                                                        |\n                                                        |\n                                       login shell <--用户登录\n\n## Linux 关机\n\n在Linux领域内大多用再服务器上,很少遇到关机的操作,毕竟服务器上跑一个服务时永无止境的,\n除非特殊情况下,不得已才会关机.\n\n正确的关机流程为 : sync > shutdown > reboot > halt\n\n关机指令为 : shutdown,你可以man shutdown来看一下邦之文档.\n\n* sync 将数据由内存同步到硬盘中\n\n* shutdown 关机指令,你可以man shutdown来看一文档\n\n* shutdown -h 10  10分钟后关机\n\n* shutdown -h now 立马关机\n\n* shutdown -h 20:25 系统会在今天20:25关机\n\n* shutdown -h +10 十分钟后关机\n\n* shutdown -r now 立马重启\n\n* shutdown -r +10 十分钟后重启\n\n* reboot 重启,等同于 shutdown -r now\n\n* halt 关闭系统,等同于 shutdown -h now 和 poweroff\n\n最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。\n关机的命令有 shutdown –h now halt poweroff 和 init 0 , 重启系统的命令有 shutdown –r now reboot init 6。\n\n\n\n\n\n\n\n\n\n\n","slug":"Linux简介","published":1,"updated":"2019-09-27T08:27:08.028Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecq000hojfyw3qzkjnj","content":"<pre><code>Linux内核最初是由芬兰人李纳斯.托瓦兹(Linux Torvalds)在赫尔辛基上大学时出于个人爱好而编写的.\nLinux是一套免费使用和自由传播的类Unix操作系统.是一个基于POSIX和UNIX的多用户 多任务 支持多线\n程和多CPU的操作系统.\n\nLinux能运行主要的UNIX工具软件 应用程序和网络协议.它支持32位和64位硬件.Linux继承了Unix以网络\n为核心的设计思想,是一个性能稳定的多用户网络操作系统.</code></pre><h2 id=\"Linux的发行版本\"><a href=\"#Linux的发行版本\" class=\"headerlink\" title=\"Linux的发行版本\"></a>Linux的发行版本</h2><pre><code>Linux的发行版本简单说就是讲Linux内核与应用软件做一个打包.\n目前市面上比较知名的发行版有:</code></pre><h3 id=\"Ubuntu\"><a href=\"#Ubuntu\" class=\"headerlink\" title=\"Ubuntu\"></a>Ubuntu</h3><h3 id=\"ReaHat\"><a href=\"#ReaHat\" class=\"headerlink\" title=\"ReaHat\"></a>ReaHat</h3><h3 id=\"CentOS\"><a href=\"#CentOS\" class=\"headerlink\" title=\"CentOS\"></a>CentOS</h3><h3 id=\"Debian\"><a href=\"#Debian\" class=\"headerlink\" title=\"Debian\"></a>Debian</h3><h3 id=\"Fefora\"><a href=\"#Fefora\" class=\"headerlink\" title=\"Fefora\"></a>Fefora</h3><h3 id=\"SuSE\"><a href=\"#SuSE\" class=\"headerlink\" title=\"SuSE\"></a>SuSE</h3><h3 id=\"OpenSUSE\"><a href=\"#OpenSUSE\" class=\"headerlink\" title=\"OpenSUSE\"></a>OpenSUSE</h3><h3 id=\"Arch-Linux\"><a href=\"#Arch-Linux\" class=\"headerlink\" title=\"Arch Linux\"></a>Arch Linux</h3><h3 id=\"SolusOS\"><a href=\"#SolusOS\" class=\"headerlink\" title=\"SolusOS\"></a>SolusOS</h3><h2 id=\"Linux-系统启动过程\"><a href=\"#Linux-系统启动过程\" class=\"headerlink\" title=\"Linux 系统启动过程\"></a>Linux 系统启动过程</h2><p>Linux系统的启动的启动过程分为5个阶段</p>\n<ul>\n<li><p>内核的引导</p>\n</li>\n<li><p>运行init</p>\n</li>\n<li><p>系统初始化</p>\n</li>\n<li><p>建立终端</p>\n</li>\n<li><p>用户登录系统</p>\n<p>  init 程序的类型</p>\n<ul>\n<li><p>SysV:init,CentOS5之前,配置文件: /etc/initab.</p>\n</li>\n<li><p>Upstart:init,CentOS6,配置文件: /etc/inittab,/etc/init/*.conf.</p>\n</li>\n<li><p>Systemd: systemd,CenOS 7配置文件: /user/lib/systemd/system  /etc/systemd/system</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"内核引导\"><a href=\"#内核引导\" class=\"headerlink\" title=\"内核引导\"></a>内核引导</h2><p>当计算机打开电源后,首先是BIOS开机自检,按照BIOS中设置的启动设备(通常是硬盘)来启动.<br>操作系统接管硬件以后,首先读入/boot目录下的内核文件</p>\n<p>操作系统 —–&gt; boot —&gt;</p>\n<h2 id=\"运行init\"><a href=\"#运行init\" class=\"headerlink\" title=\"运行init\"></a>运行init</h2><p>init进程是系统所有进程的起点,你可以把它比拟成系统所有进程的老祖宗,没有这个进程,系统<br>中任何进程都不会启动.<br>init程序首先需要读取配置文件 /etc/inittab.</p>\n<p>操作系统 —–&gt; boot —&gt; init进程 —&gt;运行级别</p>\n<p>Linux系统有七个运行级别</p>\n<ul>\n<li><p>0 : 系统停机状态,系统默认运行级别不能设为0,否则不能正常启动</p>\n</li>\n<li><p>1 : 单用户工作状态,root权限,用于系统维护,禁止远程登录</p>\n</li>\n<li><p>2 : 多用户状态(没有NFS)</p>\n</li>\n<li><p>3 : 完全的多用户状态,登录后进入控制台命令行模式</p>\n</li>\n<li><p>4 : 系统未使用,保留</p>\n</li>\n<li><p>5 : X11控制台,登录后进入图形GUI模式</p>\n</li>\n<li><p>6 : 系统正常关闭并重启,默认运行级别不能设为6,否则不能正常启动</p>\n</li>\n</ul>\n<h2 id=\"系统初始化\"><a href=\"#系统初始化\" class=\"headerlink\" title=\"系统初始化\"></a>系统初始化</h2><p>在init的配置文件中有这么一行: si:sysinit:/etc/rc.d/rc.sysint 它调用执行了</p>\n<p>/etc/rc.d/rc.sysinit 它调用执行了/etc/rc.d/rc.sysinit,而rc.sysinit是一个bash</p>\n<p>shell 的脚本 ,它主要是完成一些系统初始化的工作,rc.sysinit是每一个运行级别都</p>\n<p>要首先运行的重要脚本.</p>\n<p>它主要完成的工作有:激活交换区,检查磁盘,加载硬件模块以及其他一些需要优先执行</p>\n<p>任务.</p>\n<p>15:5:wait:/etc/rc.d/rc 5</p>\n<p>这一行表示以5为参数运行/etc/rc.d/rc, /etc/rc.d/rc是一个shell脚本,它接收5作为参数</p>\n<p>,去执行/etc/rc.d/rc5.d/目录下的所有的rc启用脚本,/etc/rc.d/rc5.d/目录中的这些启动</p>\n<p>脚本实际上都是一些连接文件,而不是真正的rc启动脚本,真正的rc启动脚本实际上都是放在</p>\n<p>/etc/rc.d/init.d/目录下</p>\n<p>而这些rc启动脚本有着类似的用法,它们一般能接受start stop restart status等参数.</p>\n<p>/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的连接文件,用于以S开头的启动脚本</p>\n<p>,将以start参数来运行. 而如果发现存在相应的脚本也存在K打头的连接,而且已经处于运</p>\n<p>行状态了(以/var/lock/subsys/下的文件为标志),则将首先以stop为参数停止这些已经启动</p>\n<p>了的守护进程,然后再重新运行.</p>\n<p>这样做是为了保证当init改变运行级别时,所有相关的守护进程将重启.</p>\n<p>至于在每个运行级别中将运行哪些守护进程,用户可以通过chkconfig或setup中的</p>\n<p>“System Services”来自行设定.</p>\n<p>操作系统 —&gt; /boot —&gt; init进程 —&gt; 运行级别 —&gt; /etc/init.d</p>\n<h2 id=\"建立终端\"><a href=\"#建立终端\" class=\"headerlink\" title=\"建立终端\"></a>建立终端</h2><p>rc执行完毕后,返回init.这时基本系统环境已经设置好了,各种守护进程也已经启动了.</p>\n<p>init接下来会打开6个终端,以便用户登录系统.在inittab中的以下6行就是定义了6个终</p>\n<p>端:</p>\n<p>1:2345:respawn:/sbin/mingetty tty1</p>\n<p>2:2345:respawn:/sbin/mingetty tty2</p>\n<p>3:2345:respawn:/sbin/mingetty tty3</p>\n<p>4:2345:respawn:/sbin/mingetty tty4</p>\n<p>5:2345:respawn:/sbin/mingetty tty5</p>\n<p>6:2345:respawn:/sbin/mingetty tty6</p>\n<p>从上面可以看出在2 3 4 5的运行级别中都将以 respawn 方式运行mingetty程序能打开终端</p>\n<p>设置模式.同时它会显示一个文本登录界面,这个界面就是我们经常看到的登录界面,在这个等</p>\n<p>录界面中会提示用户输入用户名,而用户输入的用户名将作为参数传给login程序来验证用户的</p>\n<p>身份</p>\n<h2 id=\"用户登录系统\"><a href=\"#用户登录系统\" class=\"headerlink\" title=\"用户登录系统\"></a>用户登录系统</h2><p>一般来说,用户的登录方式有三种:</p>\n<ul>\n<li><p>1 命令行登录</p>\n</li>\n<li><p>2 ssh登录</p>\n</li>\n<li><p>3 图形界面登录</p>\n</li>\n</ul>\n<p>操作系统 –&gt; /boot –&gt; init进程 –&gt; 运行级别 –&gt; /etc/init.d –&gt; 用户登录</p>\n<p>对于运行级别为5的图形方式用户来说,他们的登录是通过一个图形化的登录界面.登录</p>\n<p>成功后可以直接进入 KDE 或 Gnome 等窗口管理器 </p>\n<p>而本文主要讲的是文本登录:当我们看到mingetty的登录界面时,我们就可以输入用户名</p>\n<p>和密码来登录系统了.</p>\n<p>Linux的账号验证程序是login,login会接收mingetty传来的用户名作为用户名参数.</p>\n<p>然后login会对用户名进行分析:如果用户名不是root,且存在/etc/nologin文件,login</p>\n<p>将输出nologin文件的内容,然后退出.</p>\n<p>这通常用来系统维护时防止非root用户登录.只有/etc/securetty中登记了的终端才允许</p>\n<p>root用户登录,如果不存在这个文件,则root用户可以在任何终端上登录.</p>\n<p>/etc/usetty文件用于对用户作出附加访问限制,如果不存在这个文件,则没有其他限制</p>\n<h2 id=\"图形模式与文字模式的切换方式\"><a href=\"#图形模式与文字模式的切换方式\" class=\"headerlink\" title=\"图形模式与文字模式的切换方式\"></a>图形模式与文字模式的切换方式</h2><p>Linux预设提供了六个命令 窗口终端机让我们来登录.</p>\n<p>默认我们登录的就是第一个窗口,也就是tty1,这六个窗口分别为 tt1,tt2,tt3…tt6,<br>你可以按下</p>\n<p>Ctrl + Alt + F1 ~ F6</p>\n<p>来切换它们</p>\n<p>如果你安装了图形界面,默认情况下是进入图形界面的,此时你就可以按Ctrl+Alt+F1~F6来<br>进入其中一个命令窗口界面.当你进入命令窗口界面后再返回图形界面只要按下</p>\n<p>Ctrl + Alt + F7就回来了</p>\n<p>如果你用的vmware虚拟机,命令窗口切换的快捷键位Alt+Space+F1~F6.如果你在图形界面下</p>\n<p>请按Alt+Shift+Ctrl+F1~F6切换至命令窗口.</p>\n<p>操作系统 –&gt; /boot –&gt; init进程 –&gt; 运行级别 –&gt; /etc/init.d<br>                                                        |<br>                                                        |<br>                                       login shell &lt;–用户登录</p>\n<h2 id=\"Linux-关机\"><a href=\"#Linux-关机\" class=\"headerlink\" title=\"Linux 关机\"></a>Linux 关机</h2><p>在Linux领域内大多用再服务器上,很少遇到关机的操作,毕竟服务器上跑一个服务时永无止境的,<br>除非特殊情况下,不得已才会关机.</p>\n<p>正确的关机流程为 : sync &gt; shutdown &gt; reboot &gt; halt</p>\n<p>关机指令为 : shutdown,你可以man shutdown来看一下邦之文档.</p>\n<ul>\n<li><p>sync 将数据由内存同步到硬盘中</p>\n</li>\n<li><p>shutdown 关机指令,你可以man shutdown来看一文档</p>\n</li>\n<li><p>shutdown -h 10  10分钟后关机</p>\n</li>\n<li><p>shutdown -h now 立马关机</p>\n</li>\n<li><p>shutdown -h 20:25 系统会在今天20:25关机</p>\n</li>\n<li><p>shutdown -h +10 十分钟后关机</p>\n</li>\n<li><p>shutdown -r now 立马重启</p>\n</li>\n<li><p>shutdown -r +10 十分钟后重启</p>\n</li>\n<li><p>reboot 重启,等同于 shutdown -r now</p>\n</li>\n<li><p>halt 关闭系统,等同于 shutdown -h now 和 poweroff</p>\n</li>\n</ul>\n<p>最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。<br>关机的命令有 shutdown –h now halt poweroff 和 init 0 , 重启系统的命令有 shutdown –r now reboot init 6。</p>\n","site":{"data":{}},"excerpt":"","more":"<pre><code>Linux内核最初是由芬兰人李纳斯.托瓦兹(Linux Torvalds)在赫尔辛基上大学时出于个人爱好而编写的.\nLinux是一套免费使用和自由传播的类Unix操作系统.是一个基于POSIX和UNIX的多用户 多任务 支持多线\n程和多CPU的操作系统.\n\nLinux能运行主要的UNIX工具软件 应用程序和网络协议.它支持32位和64位硬件.Linux继承了Unix以网络\n为核心的设计思想,是一个性能稳定的多用户网络操作系统.</code></pre><h2 id=\"Linux的发行版本\"><a href=\"#Linux的发行版本\" class=\"headerlink\" title=\"Linux的发行版本\"></a>Linux的发行版本</h2><pre><code>Linux的发行版本简单说就是讲Linux内核与应用软件做一个打包.\n目前市面上比较知名的发行版有:</code></pre><h3 id=\"Ubuntu\"><a href=\"#Ubuntu\" class=\"headerlink\" title=\"Ubuntu\"></a>Ubuntu</h3><h3 id=\"ReaHat\"><a href=\"#ReaHat\" class=\"headerlink\" title=\"ReaHat\"></a>ReaHat</h3><h3 id=\"CentOS\"><a href=\"#CentOS\" class=\"headerlink\" title=\"CentOS\"></a>CentOS</h3><h3 id=\"Debian\"><a href=\"#Debian\" class=\"headerlink\" title=\"Debian\"></a>Debian</h3><h3 id=\"Fefora\"><a href=\"#Fefora\" class=\"headerlink\" title=\"Fefora\"></a>Fefora</h3><h3 id=\"SuSE\"><a href=\"#SuSE\" class=\"headerlink\" title=\"SuSE\"></a>SuSE</h3><h3 id=\"OpenSUSE\"><a href=\"#OpenSUSE\" class=\"headerlink\" title=\"OpenSUSE\"></a>OpenSUSE</h3><h3 id=\"Arch-Linux\"><a href=\"#Arch-Linux\" class=\"headerlink\" title=\"Arch Linux\"></a>Arch Linux</h3><h3 id=\"SolusOS\"><a href=\"#SolusOS\" class=\"headerlink\" title=\"SolusOS\"></a>SolusOS</h3><h2 id=\"Linux-系统启动过程\"><a href=\"#Linux-系统启动过程\" class=\"headerlink\" title=\"Linux 系统启动过程\"></a>Linux 系统启动过程</h2><p>Linux系统的启动的启动过程分为5个阶段</p>\n<ul>\n<li><p>内核的引导</p>\n</li>\n<li><p>运行init</p>\n</li>\n<li><p>系统初始化</p>\n</li>\n<li><p>建立终端</p>\n</li>\n<li><p>用户登录系统</p>\n<p>  init 程序的类型</p>\n<ul>\n<li><p>SysV:init,CentOS5之前,配置文件: /etc/initab.</p>\n</li>\n<li><p>Upstart:init,CentOS6,配置文件: /etc/inittab,/etc/init/*.conf.</p>\n</li>\n<li><p>Systemd: systemd,CenOS 7配置文件: /user/lib/systemd/system  /etc/systemd/system</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"内核引导\"><a href=\"#内核引导\" class=\"headerlink\" title=\"内核引导\"></a>内核引导</h2><p>当计算机打开电源后,首先是BIOS开机自检,按照BIOS中设置的启动设备(通常是硬盘)来启动.<br>操作系统接管硬件以后,首先读入/boot目录下的内核文件</p>\n<p>操作系统 —–&gt; boot —&gt;</p>\n<h2 id=\"运行init\"><a href=\"#运行init\" class=\"headerlink\" title=\"运行init\"></a>运行init</h2><p>init进程是系统所有进程的起点,你可以把它比拟成系统所有进程的老祖宗,没有这个进程,系统<br>中任何进程都不会启动.<br>init程序首先需要读取配置文件 /etc/inittab.</p>\n<p>操作系统 —–&gt; boot —&gt; init进程 —&gt;运行级别</p>\n<p>Linux系统有七个运行级别</p>\n<ul>\n<li><p>0 : 系统停机状态,系统默认运行级别不能设为0,否则不能正常启动</p>\n</li>\n<li><p>1 : 单用户工作状态,root权限,用于系统维护,禁止远程登录</p>\n</li>\n<li><p>2 : 多用户状态(没有NFS)</p>\n</li>\n<li><p>3 : 完全的多用户状态,登录后进入控制台命令行模式</p>\n</li>\n<li><p>4 : 系统未使用,保留</p>\n</li>\n<li><p>5 : X11控制台,登录后进入图形GUI模式</p>\n</li>\n<li><p>6 : 系统正常关闭并重启,默认运行级别不能设为6,否则不能正常启动</p>\n</li>\n</ul>\n<h2 id=\"系统初始化\"><a href=\"#系统初始化\" class=\"headerlink\" title=\"系统初始化\"></a>系统初始化</h2><p>在init的配置文件中有这么一行: si:sysinit:/etc/rc.d/rc.sysint 它调用执行了</p>\n<p>/etc/rc.d/rc.sysinit 它调用执行了/etc/rc.d/rc.sysinit,而rc.sysinit是一个bash</p>\n<p>shell 的脚本 ,它主要是完成一些系统初始化的工作,rc.sysinit是每一个运行级别都</p>\n<p>要首先运行的重要脚本.</p>\n<p>它主要完成的工作有:激活交换区,检查磁盘,加载硬件模块以及其他一些需要优先执行</p>\n<p>任务.</p>\n<p>15:5:wait:/etc/rc.d/rc 5</p>\n<p>这一行表示以5为参数运行/etc/rc.d/rc, /etc/rc.d/rc是一个shell脚本,它接收5作为参数</p>\n<p>,去执行/etc/rc.d/rc5.d/目录下的所有的rc启用脚本,/etc/rc.d/rc5.d/目录中的这些启动</p>\n<p>脚本实际上都是一些连接文件,而不是真正的rc启动脚本,真正的rc启动脚本实际上都是放在</p>\n<p>/etc/rc.d/init.d/目录下</p>\n<p>而这些rc启动脚本有着类似的用法,它们一般能接受start stop restart status等参数.</p>\n<p>/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的连接文件,用于以S开头的启动脚本</p>\n<p>,将以start参数来运行. 而如果发现存在相应的脚本也存在K打头的连接,而且已经处于运</p>\n<p>行状态了(以/var/lock/subsys/下的文件为标志),则将首先以stop为参数停止这些已经启动</p>\n<p>了的守护进程,然后再重新运行.</p>\n<p>这样做是为了保证当init改变运行级别时,所有相关的守护进程将重启.</p>\n<p>至于在每个运行级别中将运行哪些守护进程,用户可以通过chkconfig或setup中的</p>\n<p>“System Services”来自行设定.</p>\n<p>操作系统 —&gt; /boot —&gt; init进程 —&gt; 运行级别 —&gt; /etc/init.d</p>\n<h2 id=\"建立终端\"><a href=\"#建立终端\" class=\"headerlink\" title=\"建立终端\"></a>建立终端</h2><p>rc执行完毕后,返回init.这时基本系统环境已经设置好了,各种守护进程也已经启动了.</p>\n<p>init接下来会打开6个终端,以便用户登录系统.在inittab中的以下6行就是定义了6个终</p>\n<p>端:</p>\n<p>1:2345:respawn:/sbin/mingetty tty1</p>\n<p>2:2345:respawn:/sbin/mingetty tty2</p>\n<p>3:2345:respawn:/sbin/mingetty tty3</p>\n<p>4:2345:respawn:/sbin/mingetty tty4</p>\n<p>5:2345:respawn:/sbin/mingetty tty5</p>\n<p>6:2345:respawn:/sbin/mingetty tty6</p>\n<p>从上面可以看出在2 3 4 5的运行级别中都将以 respawn 方式运行mingetty程序能打开终端</p>\n<p>设置模式.同时它会显示一个文本登录界面,这个界面就是我们经常看到的登录界面,在这个等</p>\n<p>录界面中会提示用户输入用户名,而用户输入的用户名将作为参数传给login程序来验证用户的</p>\n<p>身份</p>\n<h2 id=\"用户登录系统\"><a href=\"#用户登录系统\" class=\"headerlink\" title=\"用户登录系统\"></a>用户登录系统</h2><p>一般来说,用户的登录方式有三种:</p>\n<ul>\n<li><p>1 命令行登录</p>\n</li>\n<li><p>2 ssh登录</p>\n</li>\n<li><p>3 图形界面登录</p>\n</li>\n</ul>\n<p>操作系统 –&gt; /boot –&gt; init进程 –&gt; 运行级别 –&gt; /etc/init.d –&gt; 用户登录</p>\n<p>对于运行级别为5的图形方式用户来说,他们的登录是通过一个图形化的登录界面.登录</p>\n<p>成功后可以直接进入 KDE 或 Gnome 等窗口管理器 </p>\n<p>而本文主要讲的是文本登录:当我们看到mingetty的登录界面时,我们就可以输入用户名</p>\n<p>和密码来登录系统了.</p>\n<p>Linux的账号验证程序是login,login会接收mingetty传来的用户名作为用户名参数.</p>\n<p>然后login会对用户名进行分析:如果用户名不是root,且存在/etc/nologin文件,login</p>\n<p>将输出nologin文件的内容,然后退出.</p>\n<p>这通常用来系统维护时防止非root用户登录.只有/etc/securetty中登记了的终端才允许</p>\n<p>root用户登录,如果不存在这个文件,则root用户可以在任何终端上登录.</p>\n<p>/etc/usetty文件用于对用户作出附加访问限制,如果不存在这个文件,则没有其他限制</p>\n<h2 id=\"图形模式与文字模式的切换方式\"><a href=\"#图形模式与文字模式的切换方式\" class=\"headerlink\" title=\"图形模式与文字模式的切换方式\"></a>图形模式与文字模式的切换方式</h2><p>Linux预设提供了六个命令 窗口终端机让我们来登录.</p>\n<p>默认我们登录的就是第一个窗口,也就是tty1,这六个窗口分别为 tt1,tt2,tt3…tt6,<br>你可以按下</p>\n<p>Ctrl + Alt + F1 ~ F6</p>\n<p>来切换它们</p>\n<p>如果你安装了图形界面,默认情况下是进入图形界面的,此时你就可以按Ctrl+Alt+F1~F6来<br>进入其中一个命令窗口界面.当你进入命令窗口界面后再返回图形界面只要按下</p>\n<p>Ctrl + Alt + F7就回来了</p>\n<p>如果你用的vmware虚拟机,命令窗口切换的快捷键位Alt+Space+F1~F6.如果你在图形界面下</p>\n<p>请按Alt+Shift+Ctrl+F1~F6切换至命令窗口.</p>\n<p>操作系统 –&gt; /boot –&gt; init进程 –&gt; 运行级别 –&gt; /etc/init.d<br>                                                        |<br>                                                        |<br>                                       login shell &lt;–用户登录</p>\n<h2 id=\"Linux-关机\"><a href=\"#Linux-关机\" class=\"headerlink\" title=\"Linux 关机\"></a>Linux 关机</h2><p>在Linux领域内大多用再服务器上,很少遇到关机的操作,毕竟服务器上跑一个服务时永无止境的,<br>除非特殊情况下,不得已才会关机.</p>\n<p>正确的关机流程为 : sync &gt; shutdown &gt; reboot &gt; halt</p>\n<p>关机指令为 : shutdown,你可以man shutdown来看一下邦之文档.</p>\n<ul>\n<li><p>sync 将数据由内存同步到硬盘中</p>\n</li>\n<li><p>shutdown 关机指令,你可以man shutdown来看一文档</p>\n</li>\n<li><p>shutdown -h 10  10分钟后关机</p>\n</li>\n<li><p>shutdown -h now 立马关机</p>\n</li>\n<li><p>shutdown -h 20:25 系统会在今天20:25关机</p>\n</li>\n<li><p>shutdown -h +10 十分钟后关机</p>\n</li>\n<li><p>shutdown -r now 立马重启</p>\n</li>\n<li><p>shutdown -r +10 十分钟后重启</p>\n</li>\n<li><p>reboot 重启,等同于 shutdown -r now</p>\n</li>\n<li><p>halt 关闭系统,等同于 shutdown -h now 和 poweroff</p>\n</li>\n</ul>\n<p>最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。<br>关机的命令有 shutdown –h now halt poweroff 和 init 0 , 重启系统的命令有 shutdown –r now reboot init 6。</p>\n"},{"title":"Mac 下locate命令使用问题WARNING: The locate database (/var/db/locate.database) does not exist","date":"2019-09-11T01:44:23.000Z","_content":"# 问题\n![](locate.png)\n\n根据提示使用 \n\nsudo launchctl load -w /System/Library/LaunchDaemons/com.apple.locate.plist\n 并没有生效。\n\n需要执行\n\nsudo /usr/libexec/locate.updatedb 进行库更新。\n\n[参考](https://www.cnblogs.com/b-ruce/p/5911048.html)\n","source":"_posts/Mac-下locate命令使用问题WARNING-The-locate-database-var-db-locate-database-does-not-exist.md","raw":"---\ntitle: \"Mac\\_下locate命令使用问题WARNING: The locate database (/var/db/locate.database) does not exist\"\ndate: 2019-09-11 09:44:23\ntags: [Mac,exception]\ncategories: [Mac]\n---\n# 问题\n![](locate.png)\n\n根据提示使用 \n\nsudo launchctl load -w /System/Library/LaunchDaemons/com.apple.locate.plist\n 并没有生效。\n\n需要执行\n\nsudo /usr/libexec/locate.updatedb 进行库更新。\n\n[参考](https://www.cnblogs.com/b-ruce/p/5911048.html)\n","slug":"Mac-下locate命令使用问题WARNING-The-locate-database-var-db-locate-database-does-not-exist","published":1,"updated":"2019-09-27T08:27:08.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecr000iojfyrksaew9v","content":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p><img src=\"locate.png\" alt></p>\n<p>根据提示使用 </p>\n<p>sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.locate.plist<br> 并没有生效。</p>\n<p>需要执行</p>\n<p>sudo /usr/libexec/locate.updatedb 进行库更新。</p>\n<p><a href=\"https://www.cnblogs.com/b-ruce/p/5911048.html\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p><img src=\"locate.png\" alt></p>\n<p>根据提示使用 </p>\n<p>sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.locate.plist<br> 并没有生效。</p>\n<p>需要执行</p>\n<p>sudo /usr/libexec/locate.updatedb 进行库更新。</p>\n<p><a href=\"https://www.cnblogs.com/b-ruce/p/5911048.html\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n"},{"title":"Mac中node卸载与安装","date":"2019-08-23T06:35:56.000Z","_content":"\n## 卸载\n\n在终端依次输入以下命令\n\n    sudo npm uninstall npm -g\n     \n     sudo rm -rf /usr/local/lib/node /usr/local/lib/node_modules /var/db/receipts/org.nodejs.*\n     \n     sudo rm -rf /usr/local/include/node /Users/$USER/.npm\n     \n     sudo rm /usr/local/bin/node\n     \n     sudo rm /usr/local/share/man/man1/node.1\n    \n     sudo rm /usr/local/lib/dtrace/node.d\n     \n## 验证是否成功\n    \n    node -v  //not found\n    \n    npm -v //not found\n    \n## 安装\n    \n    brew search node\n    brew install node\n             \n## 遇到的坑             \n\n    Error: The `brew link` step did not complete successfully\n    The formula built, but is not symlinked into /usr/local\n    Could not symlink share/doc/node/lldb_commands.py\n    Target /usr/local/share/doc/node/lldb_commands.py\n    already exists. You may want to remove it:\n      rm '/usr/local/share/doc/node/lldb_commands.py'\n    \n    To force the link and overwrite all conflicting files:\n      brew link --overwrite node\n    \n    To list all files that would be deleted:\n      brew link --overwrite --dry-run node\n\n## 解决办法\n\n      rm '/usr/local/share/doc/node/lldb_commands.py'\n\n      brew link --overwrite node\n      \n      \n","source":"_posts/Mac中node卸载与安装.md","raw":"---\ntitle: Mac中node卸载与安装\ndate: 2019-08-23 14:35:56\ntags: [node,npm,brew]\n---\n\n## 卸载\n\n在终端依次输入以下命令\n\n    sudo npm uninstall npm -g\n     \n     sudo rm -rf /usr/local/lib/node /usr/local/lib/node_modules /var/db/receipts/org.nodejs.*\n     \n     sudo rm -rf /usr/local/include/node /Users/$USER/.npm\n     \n     sudo rm /usr/local/bin/node\n     \n     sudo rm /usr/local/share/man/man1/node.1\n    \n     sudo rm /usr/local/lib/dtrace/node.d\n     \n## 验证是否成功\n    \n    node -v  //not found\n    \n    npm -v //not found\n    \n## 安装\n    \n    brew search node\n    brew install node\n             \n## 遇到的坑             \n\n    Error: The `brew link` step did not complete successfully\n    The formula built, but is not symlinked into /usr/local\n    Could not symlink share/doc/node/lldb_commands.py\n    Target /usr/local/share/doc/node/lldb_commands.py\n    already exists. You may want to remove it:\n      rm '/usr/local/share/doc/node/lldb_commands.py'\n    \n    To force the link and overwrite all conflicting files:\n      brew link --overwrite node\n    \n    To list all files that would be deleted:\n      brew link --overwrite --dry-run node\n\n## 解决办法\n\n      rm '/usr/local/share/doc/node/lldb_commands.py'\n\n      brew link --overwrite node\n      \n      \n","slug":"Mac中node卸载与安装","published":1,"updated":"2019-09-27T08:27:08.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecr000jojfyoj24fm0m","content":"<h2 id=\"卸载\"><a href=\"#卸载\" class=\"headerlink\" title=\"卸载\"></a>卸载</h2><p>在终端依次输入以下命令</p>\n<pre><code>sudo npm uninstall npm -g\n\n sudo rm -rf /usr/local/lib/node /usr/local/lib/node_modules /var/db/receipts/org.nodejs.*\n\n sudo rm -rf /usr/local/include/node /Users/$USER/.npm\n\n sudo rm /usr/local/bin/node\n\n sudo rm /usr/local/share/man/man1/node.1\n\n sudo rm /usr/local/lib/dtrace/node.d</code></pre><h2 id=\"验证是否成功\"><a href=\"#验证是否成功\" class=\"headerlink\" title=\"验证是否成功\"></a>验证是否成功</h2><pre><code>node -v  //not found\n\nnpm -v //not found</code></pre><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><pre><code>brew search node\nbrew install node</code></pre><h2 id=\"遇到的坑\"><a href=\"#遇到的坑\" class=\"headerlink\" title=\"遇到的坑\"></a>遇到的坑</h2><pre><code>Error: The `brew link` step did not complete successfully\nThe formula built, but is not symlinked into /usr/local\nCould not symlink share/doc/node/lldb_commands.py\nTarget /usr/local/share/doc/node/lldb_commands.py\nalready exists. You may want to remove it:\n  rm &apos;/usr/local/share/doc/node/lldb_commands.py&apos;\n\nTo force the link and overwrite all conflicting files:\n  brew link --overwrite node\n\nTo list all files that would be deleted:\n  brew link --overwrite --dry-run node</code></pre><h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><pre><code>rm &apos;/usr/local/share/doc/node/lldb_commands.py&apos;\n\nbrew link --overwrite node</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"卸载\"><a href=\"#卸载\" class=\"headerlink\" title=\"卸载\"></a>卸载</h2><p>在终端依次输入以下命令</p>\n<pre><code>sudo npm uninstall npm -g\n\n sudo rm -rf /usr/local/lib/node /usr/local/lib/node_modules /var/db/receipts/org.nodejs.*\n\n sudo rm -rf /usr/local/include/node /Users/$USER/.npm\n\n sudo rm /usr/local/bin/node\n\n sudo rm /usr/local/share/man/man1/node.1\n\n sudo rm /usr/local/lib/dtrace/node.d</code></pre><h2 id=\"验证是否成功\"><a href=\"#验证是否成功\" class=\"headerlink\" title=\"验证是否成功\"></a>验证是否成功</h2><pre><code>node -v  //not found\n\nnpm -v //not found</code></pre><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><pre><code>brew search node\nbrew install node</code></pre><h2 id=\"遇到的坑\"><a href=\"#遇到的坑\" class=\"headerlink\" title=\"遇到的坑\"></a>遇到的坑</h2><pre><code>Error: The `brew link` step did not complete successfully\nThe formula built, but is not symlinked into /usr/local\nCould not symlink share/doc/node/lldb_commands.py\nTarget /usr/local/share/doc/node/lldb_commands.py\nalready exists. You may want to remove it:\n  rm &apos;/usr/local/share/doc/node/lldb_commands.py&apos;\n\nTo force the link and overwrite all conflicting files:\n  brew link --overwrite node\n\nTo list all files that would be deleted:\n  brew link --overwrite --dry-run node</code></pre><h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><pre><code>rm &apos;/usr/local/share/doc/node/lldb_commands.py&apos;\n\nbrew link --overwrite node</code></pre>"},{"title":"Lombok 看这篇就够了  ","date":"2019-09-12T06:41:50.000Z","_content":"\n# what \n[官网](https://projectlombok.org)\n官网解释:\n\nProject Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.\nNever write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.\n\n# why\n减少代码量,省去写geter,setter等\n\n# when\n## 添加下依赖:\n\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <version>1.16.8</version>\n    </dependency>\n    \n那么Lombok是做什么的呢？其实很简单，一个最简单的例子就是它能够实现通过添加注解，能够自动生成一些方法。比如这样的类:\n\n    @Getter\n    class Test{\n        private String value;\n    }\n    \n我们用Lombok提供的@Getter来注解这个类，这个类在编译的时候就会变成:\n\n    class Test{\n        private String value;\n        public String getValue(){\n            return this.value;\n        }\n    }\n\n当然Lombok也提供了很多其他的注解，这只是其中一个最典型的例子。其他的用法网上的资料已经很多了，这里就不啰嗦。\n看上去是很方便的一个功能，尤其是在很多项目里有很多bean，每次都要手写或自动生成setter getter方法，搞得代码很长而且没有啥意义，因此这个对简化代码的强迫症们还是很有吸引力的。\n但是，我们发现这个包跟一般的包有很大区别，绝大多数java包都工作在运行时，比如spring提供的那种注解，通过在运行时用反射来实现业务逻辑。Lombok这个东西工作却在编译期，在运行时是无法通过反射获取到这个注解的。\n而且由于他相当于是在编译期对代码进行了修改，因此从直观上看，源代码甚至是语法有问题的。\n一个更直接的体现就是，普通的包在引用之后一般的IDE都能够自动识别语法，但是Lombok的这些注解，一般的IDE都无法自动识别，比如我们上面的Test类，如果我们在其他地方这么调用了一下:\n    \n    Test test=new Test();\n    test.getValue();\n\nIDE的自动语法检查就会报错，说找不到这个getValue方法。因此如果要使用Lombok的话还需要配合安装相应的插件，防止IDE的自动检查报错。\n因此，可以说这个东西的设计初衷比较美好，但是用起来比较麻烦，而且破坏了代码的完整性，很多项目组(包括我自己)都不高兴用。但是他的实现原理却还是比较好玩的，随便搜了搜发现网上最多也只提到了他修改了抽象语法树，虽说从感性上可以理解，但是还是想自己手敲一敲真正去实现一下。\n\n# 原理\n翻了翻现有的资料，再加上自己的一些猜想，Lombok的基本流程应该基本是这样：\n\n* 定义编译期的注解\n* 利用JSR269 api(Pluggable Annotation Processing API )创建编译期的注解处理器\n* 利用tools.jar的javac api处理AST(抽象语法树)\n* 将功能注册进jar包\n\n## 手撸Getter\n\n由于比较习惯用maven，我这里就用maven构建一下项目，修改下当前的pom.xml文件如下：\n\n    <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n             xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n        <modelVersion>4.0.0</modelVersion>\n        <groupId>com.mythsman.test</groupId>\n        <artifactId>getter</artifactId>\n        <version>1.0-SNAPSHOT</version>\n        <packaging>jar</packaging>\n        <name>test</name>\n        <properties>\n            <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        </properties>\n        <dependencies>\n            <dependency>\n                <groupId>com.sun</groupId>\n                <artifactId>tools</artifactId>\n                <version>1.8</version>\n                <scope>system</scope>\n                <systemPath>${java.home}/../lib/tools.jar</systemPath>\n            </dependency>\n        </dependencies>\n        <build>\n            <plugins>\n                <plugin>\n                    <groupId>org.apache.maven.plugins</groupId>\n                    <artifactId>maven-compiler-plugin</artifactId>\n                    <version>3.1</version>\n                    <configuration>\n                        <source>1.8</source>\n                        <target>1.8</target>\n                    </configuration>\n                </plugin>\n            </plugins>\n        </build>\n    </project>\n    \n主要定义了下项目名，除了默认依赖的junit之外(其实并没有用)，这里添加了tools.jar包。这个包实在jdk的lib下面，因此scope是system，由于${java.home}变量表示的是jre的位置，因此还要根据这个位置找到实际的tools.jar的路径并写在systemPath里。\n由于防止在写代码的时候用到java8的一些语法，这里配置了下编译插件使其支持java8。\n\n### 创建Getter注解\n定义注解Getter.java:\n\n    package com.mythsman.test;\n    import java.lang.annotation.ElementType;\n    import java.lang.annotation.Retention;\n    import java.lang.annotation.RetentionPolicy;\n    import java.lang.annotation.Target;\n    @Target({ElementType.TYPE})\n    @Retention(RetentionPolicy.SOURCE)\n    public @interface Getter {\n    }\n\n这里的Target我选择了ElementType.TYPE表示是对类的注解，Retention选择了RententionPolicy.SOURCE，表示这个注解只在编译期起作用，在运行时将不存在。这个比较简单，稍微复杂点的是对这个注解的处理机制。像spring那种注解是通过反射来获得注解对应的元素并实现业务逻辑，但是我们显然不希望在使用Lombok这种功能的时候还要编写其他的调用代码，况且用反射也获取不到编译期才存在的注解。\n幸运的是Java早已支持了JSR269的规范，允许在编译时指定一个processor类来对编译阶段的注解进行干预，下面就来解决下这个处理器。\n\n### 创建Getter注解的处理器\n\n基本框架\n\n自定义的处理器需要继承AbstractProcessor这个类，基本的框架大体应当如下:\n\n    package com.mythsman.test;\n    import javax.annotation.processing.*;\n    import javax.lang.model.SourceVersion;\n    import javax.lang.model.element.TypeElement;\n    import java.util.Set;\n    @SupportedAnnotationTypes(\"com.mythsman.test.Getter\")\n    @SupportedSourceVersion(SourceVersion.RELEASE_8)\n    public class GetterProcessor extends AbstractProcessor {\n        @Override\n        public synchronized void init(ProcessingEnvironment processingEnv) {\n            super.init(processingEnv);\n        }\n        @Override\n        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n            return true;\n        }\n    }\n需要定义两个注解，一个表示该处理器需要处理的注解，另外一个表示该处理器支持的源码版本。然后需要着重实现两个方法，init跟process。init的主要用途是通过ProcessingEnvironment来获取编译阶段的一些环境信息;process主要是实现具体逻辑的地方，也就是对AST进行处理的地方。\n\n具体怎么做呢？\n\ninit方法\n首先我们要重写下init方法，从环境里提取一些关键的类:\n\n    private Messager messager;\n    private JavacTrees trees;\n    private TreeMaker treeMaker;\n    private Names names;\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnv) {\n        super.init(processingEnv);\n        this.messager = processingEnv.getMessager();\n        this.trees = JavacTrees.instance(processingEnv);\n        Context context = ((JavacProcessingEnvironment) processingEnv).getContext();\n        this.treeMaker = TreeMaker.instance(context);\n        this.names = Names.instance(context);\n    }\n\n我们提取了四个主要的类:\n\n* Messager主要是用来在编译期打log用的\n* JavacTrees提供了待处理的抽象语法树\n* TreeMaker封装了创建AST节点的一些方法\n* Names提供了创建标识符的方法\n\nprocess方法\nprocess方法的逻辑比较简单，但是由于这里的api对于我们来说比较陌生，因此写起来还是费了不少劲的：\n\n    @Override\n    public synchronized boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        Set<? extends Element> set = roundEnv.getElementsAnnotatedWith(Getter.class);\n        set.forEach(element -> {\n            JCTree jcTree = trees.getTree(element);\n            jcTree.accept(new TreeTranslator() {\n                @Override\n                public void visitClassDef(JCTree.JCClassDecl jcClassDecl) {\n                    List<JCTree.JCVariableDecl> jcVariableDeclList = List.nil();\n                    for (JCTree tree : jcClassDecl.defs) {\n                        if (tree.getKind().equals(Tree.Kind.VARIABLE)) {\n                            JCTree.JCVariableDecl jcVariableDecl = (JCTree.JCVariableDecl) tree;\n                            jcVariableDeclList = jcVariableDeclList.append(jcVariableDecl);\n                        }\n                    }\n                    jcVariableDeclList.forEach(jcVariableDecl -> {\n                        messager.printMessage(Diagnostic.Kind.NOTE, jcVariableDecl.getName() + \" has been processed\");\n                        jcClassDecl.defs = jcClassDecl.defs.prepend(makeGetterMethodDecl(jcVariableDecl));\n                    });\n                    super.visitClassDef(jcClassDecl);\n                }\n            });\n        });\n        return true;\n    }\n\n步骤大概是下面这样：\n\n1. 利用roundEnv的getElementsAnnotatedWith方法过滤出被Getter这个注解标记的类，并存入set\n2. 遍历这个set里的每一个元素，并生成jCTree这个语法树\n3. 创建一个TreeTranslator，并重写其中的visitClassDef方法，这个方法处理遍历语法树得到的类定义部分jcClassDecl\n    * 创建一个jcVariableDeclList保存类的成员变量\n    * 遍历jcTree的所有成员(包括成员变量和成员函数和构造函数)，过滤出其中的成员变量，并添加进jcVariableDeclList\n    * 将jcVariableDeclList的所有变量转换成需要添加的getter方法，并添加进jcClassDecl的成员中\n    * 调用默认的遍历方法遍历处理后的jcClassDecl\n4. 利用上面的TreeTranslator去处理jcTree\n\n接下来再实现makeGetterMethodDecl方法:\n\n    private JCTree.JCMethodDecl makeGetterMethodDecl(JCTree.JCVariableDecl jcVariableDecl) {\n        ListBuffer<JCTree.JCStatement> statements = new ListBuffer<>();\n        statements.append(treeMaker.Return(treeMaker.Select(treeMaker.Ident(names.fromString(\"this\")), jcVariableDecl.getName())));\n        JCTree.JCBlock body = treeMaker.Block(0, statements.toList());\n        return treeMaker.MethodDef(treeMaker.Modifiers(Flags.PUBLIC), getNewMethodName(jcVariableDecl.getName()), jcVariableDecl.vartype, List.nil(), List.nil(), List.nil(), body, null);\n    }\n    private Name getNewMethodName(Name name) {\n        String s = name.toString();\n        return names.fromString(\"get\" + s.substring(0, 1).toUpperCase() + s.substring(1, name.length()));\n    }\n        \n逻辑就是读取变量的定义，并创建对应的Getter方法，并试图用驼峰命名法。\n\n整体上难点还是集中在api的使用上，还有一些细微的注意点:\n首先，messager的printMessage方法在打印log的时候会自动过滤重复的log信息。\n其次，这里的list并不是java.util里面的list，而是一个自定义的list，这个list的用法比较坑爹，他采用的是这样的方式:\n\n    package com.sun.tools.javac.util;\n    public class List<A> extends AbstractCollection<A> implements java.util.List<A> {\n        public A head;\n        public List<A> tail;\n        \n        //...\n        \n        List(A var1, List<A> var2) {\n            this.tail = var2;\n            this.head = var1;\n        }\n        \n        public List<A> prepend(A var1) {\n            return new List(var1, this);\n        }\n        \n        public static <A> List<A> of(A var0) {\n            return new List(var0, nil());\n        }\n        \n        public List<A> append(A var1) {\n            return of(var1).prependList(this);\n        }\n        \n        public static <A> List<A> nil() {\n            return EMPTY_LIST;\n        }\n        //...\n    }\n\n挺有趣的，用这种叫cons而不是list的数据结构，添加元素的时候就把自己赋给自己的tail,新来的元素放进head。不过需要注意的是这个东西不支持链式调用，prepend之后还要将新值赋给自己。\n而且这里在创建getter方法的时候还要把参数写全写对了，尤其是添加this指针的这种用法。\n\n测试类\n上面基本就是所有功能代码了，接下来我们要写一个类来测试一下(App.java)：\n\n    package com.mythsman.test;\n    @Getter\n    public class App {\n        private String value;\n        private String value2;\n        public App(String value) {\n            this.value = value;\n        }\n        public static void main(String[] args) {\n            App app = new App(\"it works\");\n            System.out.println(app.getValue());\n        }\n    }\n\n不过，先不要急着构建，构建了肯定会失败，因为这原则上应该是两个项目。Getter.java是注解类没问题，但是GetterProcessor.java是处理器，App.java需要在编译期调用这个处理器，因此这两个东西是不能一起编译的，正确的编译方法应该是类似下面这样，写成compile.sh脚本就是：\n\n    #!/usr/bin/env bash\n    if [ -d classes ]; then\n        rm -rf classes;\n    fi\n    mkdir classes\n    javac -cp $JAVA_HOME/lib/tools.jar com/mythsman/test/Getter* -d classes/\n    javac -cp classes -d classes -processor com.mythsman.test.GetterProcessor com/mythsman/test/App.java\n    javap -p classes com/mythsman/test/App.class\n    java -cp classes com.mythsman.test.App\n    \n其实是五个步骤:\n\n1. 创建保存class文件的文件夹\n2. 导入tools.jar，编译processor并输出\n3. 编译App.java，并使用javac的-processor参数指定编译阶段的处理器GetterProcessor\n4. 用javap显示编译后的App.class文件(非必须，方便看结果)\n5. 执行测试类    \n\n好了，进入项目的根目录，当前的目录结构应该是这样的:\n\n.\n├── pom.xml\n├── src\n│   ├── main\n│   │   ├── java\n│   │   │   ├── com\n│   │   │   │   └── mythsman\n│   │   │   │       └── test\n│   │   │   │           ├── App.java\n│   │   │   │           ├── Getter.java\n│   │   │   │           └── GetterProcessor.java\n│   │   │   └── compile.sh\n\n调用compile.sh，输出如下:\n\n    Note: value has been processed\n    Note: value2 has been processed\n    Compiled from \"App.java\"\n    public class com.mythsman.test.App {\n      private java.lang.String value;\n      private java.lang.String value2;\n      public java.lang.String getValue2();\n      public java.lang.String getValue();\n      public com.mythsman.test.App(java.lang.String);\n      public static void main(java.lang.String[]);\n    }\n    it works\n\nNote行就是在GetterProcessor类里通过messager打印的log，中间的是javap反编译的结果，最后一行表示测试调用成功。\n\n### Maven构建并打包\n\n上面的测试部分其实是为了测试而测试，其实这应当是两个项目，一个是processor项目，这个项目应当被打成一个jar包，供调用者使用；另一个项目是app项目，这个项目是专门使用jar包的，他并不希望添加任何额外编译参数，就跟lombok的用法一样。\n简单来说，就是我们希望把processor打成一个包，并且在使用时不需要添加额外参数。\n那么如何在调用的时候不用加参数呢，其实我们知道java在编译的时候会去资源文件夹下读一个META-INF文件夹，这个文件夹下面除了MANIFEST.MF文件之外，还可以添加一个services文件夹，我们可以在这个文件夹下创建一个文件，文件名是javax.annotation.processing.Processor，文件内容是com.mythsman.test.GetterProcessor。\n我们知道maven在编译前会先拷贝资源文件夹，然后当他在编译时候发现了资源文件夹下的META-INF/serivces文件夹时，他就会读取里面的文件，并将文件名所代表的接口用文件内容表示的类来实现。这就相当于做了-processor参数该做的事了。\n当然这个文件我们并不希望调用者去写，而是希望在processor项目里集成，调用的时候能直接继承META-INF。\n\n好了，我们先删除App.java和compile.sh，添加下META-INF文件夹，当前目录结构应该是这样的：\n\n.\n├── pom.xml\n├── src\n│   └── main\n│       ├── java\n│       │   └── com\n│       │       └── mythsman\n│       │           └── test\n│       │               ├── Getter.java\n│       │               └── GetterProcessor.java\n│       └── resources\n│           └── META-INF\n│               └── services\n│                   └── javax.annotation.processing.Processor\n        \n    \n当然，我们还不能编译，因为processor项目并不需要把自己添加为processor(况且自己还没编译呢怎么调用自己)。。。完了，好像死循环了，自己在编译的时候不能添加services文件夹，但是又需要打的包里有services文件夹，这该怎么搞呢？\n其实很简单，配置一下maven的插件就行，打开pom.xml,在project/build/标签里添加下面的配置:\n\n    <build>\n       <resources>\n            <resource>\n                <directory>src/main/resources</directory>\n                <excludes>\n                    <exclude>META-INF/**/*</exclude>\n                </excludes>\n            </resource>\n        </resources>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-resources-plugin</artifactId>\n                <version>2.6</version>\n                <executions>\n                    <execution>\n                        <id>process-META</id>\n                        <phase>prepare-package</phase>\n                        <goals>\n                            <goal>copy-resources</goal>\n                        </goals>\n                        <configuration>\n                            <outputDirectory>target/classes</outputDirectory>\n                            <resources>\n                                <resource>\n                                    <directory>${basedir}/src/main/resources/</directory>\n                                    <includes>\n                                        <include>**/*</include>\n                                    </includes>\n                                </resource>\n                            </resources>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n            ...\n        </plugins>\n    </build>\n    \n我们知道maven构建的第一步就是调用maven-resources-plugin插件的resources命令，将resources文件夹复制到target/classes中，那么我们配置一下resources标签，过滤掉META-INF文件夹，这样在编译的时候就不会找到services的配置了。然后我们在打包前(prepare-package生命周期)再利用maven-resources-plugin插件的copy-resources命令把services文件夹重新拷贝过来不就好了么。\n这样配置好了，就可以直接执行mvn clean install打包提交到本地私服:\n\n    myths@pc:~/Desktop/test$ mvn clean install\n    [INFO] Scanning for projects...\n    [INFO] \n    [INFO] ------------------------------------------------------------------------\n    [INFO] Building test 1.0-SNAPSHOT\n    [INFO] ------------------------------------------------------------------------\n    [INFO] \n    [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ getter ---\n    [INFO] \n    [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ getter ---\n    [INFO] Using 'UTF-8' encoding to copy filtered resources.\n    [INFO] Copying 0 resource\n    [INFO] \n    [INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ getter ---\n    [INFO] Changes detected - recompiling the module!\n    [INFO] Compiling 2 source files to /home/myths/Desktop/test/target/classes\n    [INFO] \n    [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ getter ---\n    [INFO] Using 'UTF-8' encoding to copy filtered resources.\n    [INFO] skip non existing resourceDirectory /home/myths/Desktop/test/src/test/resources\n    [INFO] \n    [INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ getter ---\n    [INFO] No sources to compile\n    [INFO] \n    [INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ getter ---\n    [INFO] No tests to run.\n    [INFO] \n    [INFO] --- maven-resources-plugin:2.6:copy-resources (process-META) @ getter ---\n    [INFO] Using 'UTF-8' encoding to copy filtered resources.\n    [INFO] Copying 1 resource\n    [INFO] \n    [INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ getter ---\n    [INFO] Building jar: /home/myths/Desktop/test/target/getter-1.0-SNAPSHOT.jar\n    [INFO] \n    [INFO] --- maven-install-plugin:2.4:install (default-install) @ getter ---\n    [INFO] Installing /home/myths/Desktop/test/target/getter-1.0-SNAPSHOT.jar to /home/myths/.m2/repository/com/mythsman/test/getter/1.0-SNAPSHOT/getter-1.0-SNAPSHOT.jar\n    [INFO] Installing /home/myths/Desktop/test/pom.xml to /home/myths/.m2/repository/com/mythsman/test/getter/1.0-SNAPSHOT/getter-1.0-SNAPSHOT.pom\n    [INFO] ------------------------------------------------------------------------\n    [INFO] BUILD SUCCESS\n    [INFO] ------------------------------------------------------------------------\n    [INFO] Total time: 3.017 s\n    [INFO] Finished at: 2017-12-19T19:57:04+08:00\n    [INFO] Final Memory: 16M/201M\n    [INFO] ------------------------------------------------------------------------\n\n可以看到这里的process-META作用生效。\n\n调用jar包测试\n\n重新创建一个测试项目app：\n\n.\n├── pom.xml\n└── src\n    └── main\n        └── java\n            └── com\n                └── mythsman\n                    └── test\n                        └── App.java\n    \npom.xml:\n\n    <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n             xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n        <modelVersion>4.0.0</modelVersion>\n        <groupId>com.mythsman.test</groupId>\n        <artifactId>app</artifactId>\n        <version>1.0-SNAPSHOT</version>\n        <packaging>jar</packaging>\n        <name>main</name>\n        <url>http://maven.apache.org</url>\n        <properties>\n            <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        </properties>\n        <dependencies>\n            <dependency>\n                <groupId>com.mythsman.test</groupId>\n                <artifactId>getter</artifactId>\n                <version>1.0-SNAPSHOT</version>\n            </dependency>\n        </dependencies>\n        <build>\n            <plugins>\n                <plugin>\n                    <groupId>org.apache.maven.plugins</groupId>\n                    <artifactId>maven-compiler-plugin</artifactId>\n                    <version>3.1</version>\n                    <configuration>\n                        <source>1.8</source>\n                        <target>1.8</target>\n                    </configuration>\n                </plugin>\n            </plugins>\n        </build>\n    </project>\n\nApp.java:\n\n    package com.mythsman.test;\n    @Getter\n    public class App {\n        private String value;\n        private String value2;\n        public App(String value) {\n            this.value = value;\n        }\n        public static void main(String[] args) {\n            App app = new App(\"it works\");\n            System.out.println(app.getValue());\n        }\n    }\n    \n编译并执行:\n\nmvn clean compile && java -cp target/classes com.mythsman.test.App\n\n最后就会在构建成功后打印”it works”。\n\n\n[参考](https://zhuanlan.zhihu.com/p/32779910)\n[参考](https://yq.aliyun.com/articles/59972)\n[参考](https://juejin.im/entry/5a390ba76fb9a0451e3fed7c)\n","source":"_posts/Lombok-看这篇就够了.md","raw":"---\ntitle: 'Lombok 看这篇就够了  '\ndate: 2019-09-12 14:41:50\ntags: [java,lombok,idea,plugin]\ncategories: [Lombok]\n---\n\n# what \n[官网](https://projectlombok.org)\n官网解释:\n\nProject Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.\nNever write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.\n\n# why\n减少代码量,省去写geter,setter等\n\n# when\n## 添加下依赖:\n\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <version>1.16.8</version>\n    </dependency>\n    \n那么Lombok是做什么的呢？其实很简单，一个最简单的例子就是它能够实现通过添加注解，能够自动生成一些方法。比如这样的类:\n\n    @Getter\n    class Test{\n        private String value;\n    }\n    \n我们用Lombok提供的@Getter来注解这个类，这个类在编译的时候就会变成:\n\n    class Test{\n        private String value;\n        public String getValue(){\n            return this.value;\n        }\n    }\n\n当然Lombok也提供了很多其他的注解，这只是其中一个最典型的例子。其他的用法网上的资料已经很多了，这里就不啰嗦。\n看上去是很方便的一个功能，尤其是在很多项目里有很多bean，每次都要手写或自动生成setter getter方法，搞得代码很长而且没有啥意义，因此这个对简化代码的强迫症们还是很有吸引力的。\n但是，我们发现这个包跟一般的包有很大区别，绝大多数java包都工作在运行时，比如spring提供的那种注解，通过在运行时用反射来实现业务逻辑。Lombok这个东西工作却在编译期，在运行时是无法通过反射获取到这个注解的。\n而且由于他相当于是在编译期对代码进行了修改，因此从直观上看，源代码甚至是语法有问题的。\n一个更直接的体现就是，普通的包在引用之后一般的IDE都能够自动识别语法，但是Lombok的这些注解，一般的IDE都无法自动识别，比如我们上面的Test类，如果我们在其他地方这么调用了一下:\n    \n    Test test=new Test();\n    test.getValue();\n\nIDE的自动语法检查就会报错，说找不到这个getValue方法。因此如果要使用Lombok的话还需要配合安装相应的插件，防止IDE的自动检查报错。\n因此，可以说这个东西的设计初衷比较美好，但是用起来比较麻烦，而且破坏了代码的完整性，很多项目组(包括我自己)都不高兴用。但是他的实现原理却还是比较好玩的，随便搜了搜发现网上最多也只提到了他修改了抽象语法树，虽说从感性上可以理解，但是还是想自己手敲一敲真正去实现一下。\n\n# 原理\n翻了翻现有的资料，再加上自己的一些猜想，Lombok的基本流程应该基本是这样：\n\n* 定义编译期的注解\n* 利用JSR269 api(Pluggable Annotation Processing API )创建编译期的注解处理器\n* 利用tools.jar的javac api处理AST(抽象语法树)\n* 将功能注册进jar包\n\n## 手撸Getter\n\n由于比较习惯用maven，我这里就用maven构建一下项目，修改下当前的pom.xml文件如下：\n\n    <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n             xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n        <modelVersion>4.0.0</modelVersion>\n        <groupId>com.mythsman.test</groupId>\n        <artifactId>getter</artifactId>\n        <version>1.0-SNAPSHOT</version>\n        <packaging>jar</packaging>\n        <name>test</name>\n        <properties>\n            <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        </properties>\n        <dependencies>\n            <dependency>\n                <groupId>com.sun</groupId>\n                <artifactId>tools</artifactId>\n                <version>1.8</version>\n                <scope>system</scope>\n                <systemPath>${java.home}/../lib/tools.jar</systemPath>\n            </dependency>\n        </dependencies>\n        <build>\n            <plugins>\n                <plugin>\n                    <groupId>org.apache.maven.plugins</groupId>\n                    <artifactId>maven-compiler-plugin</artifactId>\n                    <version>3.1</version>\n                    <configuration>\n                        <source>1.8</source>\n                        <target>1.8</target>\n                    </configuration>\n                </plugin>\n            </plugins>\n        </build>\n    </project>\n    \n主要定义了下项目名，除了默认依赖的junit之外(其实并没有用)，这里添加了tools.jar包。这个包实在jdk的lib下面，因此scope是system，由于${java.home}变量表示的是jre的位置，因此还要根据这个位置找到实际的tools.jar的路径并写在systemPath里。\n由于防止在写代码的时候用到java8的一些语法，这里配置了下编译插件使其支持java8。\n\n### 创建Getter注解\n定义注解Getter.java:\n\n    package com.mythsman.test;\n    import java.lang.annotation.ElementType;\n    import java.lang.annotation.Retention;\n    import java.lang.annotation.RetentionPolicy;\n    import java.lang.annotation.Target;\n    @Target({ElementType.TYPE})\n    @Retention(RetentionPolicy.SOURCE)\n    public @interface Getter {\n    }\n\n这里的Target我选择了ElementType.TYPE表示是对类的注解，Retention选择了RententionPolicy.SOURCE，表示这个注解只在编译期起作用，在运行时将不存在。这个比较简单，稍微复杂点的是对这个注解的处理机制。像spring那种注解是通过反射来获得注解对应的元素并实现业务逻辑，但是我们显然不希望在使用Lombok这种功能的时候还要编写其他的调用代码，况且用反射也获取不到编译期才存在的注解。\n幸运的是Java早已支持了JSR269的规范，允许在编译时指定一个processor类来对编译阶段的注解进行干预，下面就来解决下这个处理器。\n\n### 创建Getter注解的处理器\n\n基本框架\n\n自定义的处理器需要继承AbstractProcessor这个类，基本的框架大体应当如下:\n\n    package com.mythsman.test;\n    import javax.annotation.processing.*;\n    import javax.lang.model.SourceVersion;\n    import javax.lang.model.element.TypeElement;\n    import java.util.Set;\n    @SupportedAnnotationTypes(\"com.mythsman.test.Getter\")\n    @SupportedSourceVersion(SourceVersion.RELEASE_8)\n    public class GetterProcessor extends AbstractProcessor {\n        @Override\n        public synchronized void init(ProcessingEnvironment processingEnv) {\n            super.init(processingEnv);\n        }\n        @Override\n        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n            return true;\n        }\n    }\n需要定义两个注解，一个表示该处理器需要处理的注解，另外一个表示该处理器支持的源码版本。然后需要着重实现两个方法，init跟process。init的主要用途是通过ProcessingEnvironment来获取编译阶段的一些环境信息;process主要是实现具体逻辑的地方，也就是对AST进行处理的地方。\n\n具体怎么做呢？\n\ninit方法\n首先我们要重写下init方法，从环境里提取一些关键的类:\n\n    private Messager messager;\n    private JavacTrees trees;\n    private TreeMaker treeMaker;\n    private Names names;\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnv) {\n        super.init(processingEnv);\n        this.messager = processingEnv.getMessager();\n        this.trees = JavacTrees.instance(processingEnv);\n        Context context = ((JavacProcessingEnvironment) processingEnv).getContext();\n        this.treeMaker = TreeMaker.instance(context);\n        this.names = Names.instance(context);\n    }\n\n我们提取了四个主要的类:\n\n* Messager主要是用来在编译期打log用的\n* JavacTrees提供了待处理的抽象语法树\n* TreeMaker封装了创建AST节点的一些方法\n* Names提供了创建标识符的方法\n\nprocess方法\nprocess方法的逻辑比较简单，但是由于这里的api对于我们来说比较陌生，因此写起来还是费了不少劲的：\n\n    @Override\n    public synchronized boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        Set<? extends Element> set = roundEnv.getElementsAnnotatedWith(Getter.class);\n        set.forEach(element -> {\n            JCTree jcTree = trees.getTree(element);\n            jcTree.accept(new TreeTranslator() {\n                @Override\n                public void visitClassDef(JCTree.JCClassDecl jcClassDecl) {\n                    List<JCTree.JCVariableDecl> jcVariableDeclList = List.nil();\n                    for (JCTree tree : jcClassDecl.defs) {\n                        if (tree.getKind().equals(Tree.Kind.VARIABLE)) {\n                            JCTree.JCVariableDecl jcVariableDecl = (JCTree.JCVariableDecl) tree;\n                            jcVariableDeclList = jcVariableDeclList.append(jcVariableDecl);\n                        }\n                    }\n                    jcVariableDeclList.forEach(jcVariableDecl -> {\n                        messager.printMessage(Diagnostic.Kind.NOTE, jcVariableDecl.getName() + \" has been processed\");\n                        jcClassDecl.defs = jcClassDecl.defs.prepend(makeGetterMethodDecl(jcVariableDecl));\n                    });\n                    super.visitClassDef(jcClassDecl);\n                }\n            });\n        });\n        return true;\n    }\n\n步骤大概是下面这样：\n\n1. 利用roundEnv的getElementsAnnotatedWith方法过滤出被Getter这个注解标记的类，并存入set\n2. 遍历这个set里的每一个元素，并生成jCTree这个语法树\n3. 创建一个TreeTranslator，并重写其中的visitClassDef方法，这个方法处理遍历语法树得到的类定义部分jcClassDecl\n    * 创建一个jcVariableDeclList保存类的成员变量\n    * 遍历jcTree的所有成员(包括成员变量和成员函数和构造函数)，过滤出其中的成员变量，并添加进jcVariableDeclList\n    * 将jcVariableDeclList的所有变量转换成需要添加的getter方法，并添加进jcClassDecl的成员中\n    * 调用默认的遍历方法遍历处理后的jcClassDecl\n4. 利用上面的TreeTranslator去处理jcTree\n\n接下来再实现makeGetterMethodDecl方法:\n\n    private JCTree.JCMethodDecl makeGetterMethodDecl(JCTree.JCVariableDecl jcVariableDecl) {\n        ListBuffer<JCTree.JCStatement> statements = new ListBuffer<>();\n        statements.append(treeMaker.Return(treeMaker.Select(treeMaker.Ident(names.fromString(\"this\")), jcVariableDecl.getName())));\n        JCTree.JCBlock body = treeMaker.Block(0, statements.toList());\n        return treeMaker.MethodDef(treeMaker.Modifiers(Flags.PUBLIC), getNewMethodName(jcVariableDecl.getName()), jcVariableDecl.vartype, List.nil(), List.nil(), List.nil(), body, null);\n    }\n    private Name getNewMethodName(Name name) {\n        String s = name.toString();\n        return names.fromString(\"get\" + s.substring(0, 1).toUpperCase() + s.substring(1, name.length()));\n    }\n        \n逻辑就是读取变量的定义，并创建对应的Getter方法，并试图用驼峰命名法。\n\n整体上难点还是集中在api的使用上，还有一些细微的注意点:\n首先，messager的printMessage方法在打印log的时候会自动过滤重复的log信息。\n其次，这里的list并不是java.util里面的list，而是一个自定义的list，这个list的用法比较坑爹，他采用的是这样的方式:\n\n    package com.sun.tools.javac.util;\n    public class List<A> extends AbstractCollection<A> implements java.util.List<A> {\n        public A head;\n        public List<A> tail;\n        \n        //...\n        \n        List(A var1, List<A> var2) {\n            this.tail = var2;\n            this.head = var1;\n        }\n        \n        public List<A> prepend(A var1) {\n            return new List(var1, this);\n        }\n        \n        public static <A> List<A> of(A var0) {\n            return new List(var0, nil());\n        }\n        \n        public List<A> append(A var1) {\n            return of(var1).prependList(this);\n        }\n        \n        public static <A> List<A> nil() {\n            return EMPTY_LIST;\n        }\n        //...\n    }\n\n挺有趣的，用这种叫cons而不是list的数据结构，添加元素的时候就把自己赋给自己的tail,新来的元素放进head。不过需要注意的是这个东西不支持链式调用，prepend之后还要将新值赋给自己。\n而且这里在创建getter方法的时候还要把参数写全写对了，尤其是添加this指针的这种用法。\n\n测试类\n上面基本就是所有功能代码了，接下来我们要写一个类来测试一下(App.java)：\n\n    package com.mythsman.test;\n    @Getter\n    public class App {\n        private String value;\n        private String value2;\n        public App(String value) {\n            this.value = value;\n        }\n        public static void main(String[] args) {\n            App app = new App(\"it works\");\n            System.out.println(app.getValue());\n        }\n    }\n\n不过，先不要急着构建，构建了肯定会失败，因为这原则上应该是两个项目。Getter.java是注解类没问题，但是GetterProcessor.java是处理器，App.java需要在编译期调用这个处理器，因此这两个东西是不能一起编译的，正确的编译方法应该是类似下面这样，写成compile.sh脚本就是：\n\n    #!/usr/bin/env bash\n    if [ -d classes ]; then\n        rm -rf classes;\n    fi\n    mkdir classes\n    javac -cp $JAVA_HOME/lib/tools.jar com/mythsman/test/Getter* -d classes/\n    javac -cp classes -d classes -processor com.mythsman.test.GetterProcessor com/mythsman/test/App.java\n    javap -p classes com/mythsman/test/App.class\n    java -cp classes com.mythsman.test.App\n    \n其实是五个步骤:\n\n1. 创建保存class文件的文件夹\n2. 导入tools.jar，编译processor并输出\n3. 编译App.java，并使用javac的-processor参数指定编译阶段的处理器GetterProcessor\n4. 用javap显示编译后的App.class文件(非必须，方便看结果)\n5. 执行测试类    \n\n好了，进入项目的根目录，当前的目录结构应该是这样的:\n\n.\n├── pom.xml\n├── src\n│   ├── main\n│   │   ├── java\n│   │   │   ├── com\n│   │   │   │   └── mythsman\n│   │   │   │       └── test\n│   │   │   │           ├── App.java\n│   │   │   │           ├── Getter.java\n│   │   │   │           └── GetterProcessor.java\n│   │   │   └── compile.sh\n\n调用compile.sh，输出如下:\n\n    Note: value has been processed\n    Note: value2 has been processed\n    Compiled from \"App.java\"\n    public class com.mythsman.test.App {\n      private java.lang.String value;\n      private java.lang.String value2;\n      public java.lang.String getValue2();\n      public java.lang.String getValue();\n      public com.mythsman.test.App(java.lang.String);\n      public static void main(java.lang.String[]);\n    }\n    it works\n\nNote行就是在GetterProcessor类里通过messager打印的log，中间的是javap反编译的结果，最后一行表示测试调用成功。\n\n### Maven构建并打包\n\n上面的测试部分其实是为了测试而测试，其实这应当是两个项目，一个是processor项目，这个项目应当被打成一个jar包，供调用者使用；另一个项目是app项目，这个项目是专门使用jar包的，他并不希望添加任何额外编译参数，就跟lombok的用法一样。\n简单来说，就是我们希望把processor打成一个包，并且在使用时不需要添加额外参数。\n那么如何在调用的时候不用加参数呢，其实我们知道java在编译的时候会去资源文件夹下读一个META-INF文件夹，这个文件夹下面除了MANIFEST.MF文件之外，还可以添加一个services文件夹，我们可以在这个文件夹下创建一个文件，文件名是javax.annotation.processing.Processor，文件内容是com.mythsman.test.GetterProcessor。\n我们知道maven在编译前会先拷贝资源文件夹，然后当他在编译时候发现了资源文件夹下的META-INF/serivces文件夹时，他就会读取里面的文件，并将文件名所代表的接口用文件内容表示的类来实现。这就相当于做了-processor参数该做的事了。\n当然这个文件我们并不希望调用者去写，而是希望在processor项目里集成，调用的时候能直接继承META-INF。\n\n好了，我们先删除App.java和compile.sh，添加下META-INF文件夹，当前目录结构应该是这样的：\n\n.\n├── pom.xml\n├── src\n│   └── main\n│       ├── java\n│       │   └── com\n│       │       └── mythsman\n│       │           └── test\n│       │               ├── Getter.java\n│       │               └── GetterProcessor.java\n│       └── resources\n│           └── META-INF\n│               └── services\n│                   └── javax.annotation.processing.Processor\n        \n    \n当然，我们还不能编译，因为processor项目并不需要把自己添加为processor(况且自己还没编译呢怎么调用自己)。。。完了，好像死循环了，自己在编译的时候不能添加services文件夹，但是又需要打的包里有services文件夹，这该怎么搞呢？\n其实很简单，配置一下maven的插件就行，打开pom.xml,在project/build/标签里添加下面的配置:\n\n    <build>\n       <resources>\n            <resource>\n                <directory>src/main/resources</directory>\n                <excludes>\n                    <exclude>META-INF/**/*</exclude>\n                </excludes>\n            </resource>\n        </resources>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-resources-plugin</artifactId>\n                <version>2.6</version>\n                <executions>\n                    <execution>\n                        <id>process-META</id>\n                        <phase>prepare-package</phase>\n                        <goals>\n                            <goal>copy-resources</goal>\n                        </goals>\n                        <configuration>\n                            <outputDirectory>target/classes</outputDirectory>\n                            <resources>\n                                <resource>\n                                    <directory>${basedir}/src/main/resources/</directory>\n                                    <includes>\n                                        <include>**/*</include>\n                                    </includes>\n                                </resource>\n                            </resources>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n            ...\n        </plugins>\n    </build>\n    \n我们知道maven构建的第一步就是调用maven-resources-plugin插件的resources命令，将resources文件夹复制到target/classes中，那么我们配置一下resources标签，过滤掉META-INF文件夹，这样在编译的时候就不会找到services的配置了。然后我们在打包前(prepare-package生命周期)再利用maven-resources-plugin插件的copy-resources命令把services文件夹重新拷贝过来不就好了么。\n这样配置好了，就可以直接执行mvn clean install打包提交到本地私服:\n\n    myths@pc:~/Desktop/test$ mvn clean install\n    [INFO] Scanning for projects...\n    [INFO] \n    [INFO] ------------------------------------------------------------------------\n    [INFO] Building test 1.0-SNAPSHOT\n    [INFO] ------------------------------------------------------------------------\n    [INFO] \n    [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ getter ---\n    [INFO] \n    [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ getter ---\n    [INFO] Using 'UTF-8' encoding to copy filtered resources.\n    [INFO] Copying 0 resource\n    [INFO] \n    [INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ getter ---\n    [INFO] Changes detected - recompiling the module!\n    [INFO] Compiling 2 source files to /home/myths/Desktop/test/target/classes\n    [INFO] \n    [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ getter ---\n    [INFO] Using 'UTF-8' encoding to copy filtered resources.\n    [INFO] skip non existing resourceDirectory /home/myths/Desktop/test/src/test/resources\n    [INFO] \n    [INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ getter ---\n    [INFO] No sources to compile\n    [INFO] \n    [INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ getter ---\n    [INFO] No tests to run.\n    [INFO] \n    [INFO] --- maven-resources-plugin:2.6:copy-resources (process-META) @ getter ---\n    [INFO] Using 'UTF-8' encoding to copy filtered resources.\n    [INFO] Copying 1 resource\n    [INFO] \n    [INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ getter ---\n    [INFO] Building jar: /home/myths/Desktop/test/target/getter-1.0-SNAPSHOT.jar\n    [INFO] \n    [INFO] --- maven-install-plugin:2.4:install (default-install) @ getter ---\n    [INFO] Installing /home/myths/Desktop/test/target/getter-1.0-SNAPSHOT.jar to /home/myths/.m2/repository/com/mythsman/test/getter/1.0-SNAPSHOT/getter-1.0-SNAPSHOT.jar\n    [INFO] Installing /home/myths/Desktop/test/pom.xml to /home/myths/.m2/repository/com/mythsman/test/getter/1.0-SNAPSHOT/getter-1.0-SNAPSHOT.pom\n    [INFO] ------------------------------------------------------------------------\n    [INFO] BUILD SUCCESS\n    [INFO] ------------------------------------------------------------------------\n    [INFO] Total time: 3.017 s\n    [INFO] Finished at: 2017-12-19T19:57:04+08:00\n    [INFO] Final Memory: 16M/201M\n    [INFO] ------------------------------------------------------------------------\n\n可以看到这里的process-META作用生效。\n\n调用jar包测试\n\n重新创建一个测试项目app：\n\n.\n├── pom.xml\n└── src\n    └── main\n        └── java\n            └── com\n                └── mythsman\n                    └── test\n                        └── App.java\n    \npom.xml:\n\n    <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n             xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n        <modelVersion>4.0.0</modelVersion>\n        <groupId>com.mythsman.test</groupId>\n        <artifactId>app</artifactId>\n        <version>1.0-SNAPSHOT</version>\n        <packaging>jar</packaging>\n        <name>main</name>\n        <url>http://maven.apache.org</url>\n        <properties>\n            <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        </properties>\n        <dependencies>\n            <dependency>\n                <groupId>com.mythsman.test</groupId>\n                <artifactId>getter</artifactId>\n                <version>1.0-SNAPSHOT</version>\n            </dependency>\n        </dependencies>\n        <build>\n            <plugins>\n                <plugin>\n                    <groupId>org.apache.maven.plugins</groupId>\n                    <artifactId>maven-compiler-plugin</artifactId>\n                    <version>3.1</version>\n                    <configuration>\n                        <source>1.8</source>\n                        <target>1.8</target>\n                    </configuration>\n                </plugin>\n            </plugins>\n        </build>\n    </project>\n\nApp.java:\n\n    package com.mythsman.test;\n    @Getter\n    public class App {\n        private String value;\n        private String value2;\n        public App(String value) {\n            this.value = value;\n        }\n        public static void main(String[] args) {\n            App app = new App(\"it works\");\n            System.out.println(app.getValue());\n        }\n    }\n    \n编译并执行:\n\nmvn clean compile && java -cp target/classes com.mythsman.test.App\n\n最后就会在构建成功后打印”it works”。\n\n\n[参考](https://zhuanlan.zhihu.com/p/32779910)\n[参考](https://yq.aliyun.com/articles/59972)\n[参考](https://juejin.im/entry/5a390ba76fb9a0451e3fed7c)\n","slug":"Lombok-看这篇就够了","published":1,"updated":"2019-09-27T08:27:08.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecs000kojfy5tebpk9c","content":"<h1 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h1><p><a href=\"https://projectlombok.org\" target=\"_blank\" rel=\"noopener\">官网</a><br>官网解释:</p>\n<p>Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.<br>Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.</p>\n<h1 id=\"why\"><a href=\"#why\" class=\"headerlink\" title=\"why\"></a>why</h1><p>减少代码量,省去写geter,setter等</p>\n<h1 id=\"when\"><a href=\"#when\" class=\"headerlink\" title=\"when\"></a>when</h1><h2 id=\"添加下依赖\"><a href=\"#添加下依赖\" class=\"headerlink\" title=\"添加下依赖:\"></a>添加下依赖:</h2><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n    &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n    &lt;version&gt;1.16.8&lt;/version&gt;\n&lt;/dependency&gt;</code></pre><p>那么Lombok是做什么的呢？其实很简单，一个最简单的例子就是它能够实现通过添加注解，能够自动生成一些方法。比如这样的类:</p>\n<pre><code>@Getter\nclass Test{\n    private String value;\n}</code></pre><p>我们用Lombok提供的@Getter来注解这个类，这个类在编译的时候就会变成:</p>\n<pre><code>class Test{\n    private String value;\n    public String getValue(){\n        return this.value;\n    }\n}</code></pre><p>当然Lombok也提供了很多其他的注解，这只是其中一个最典型的例子。其他的用法网上的资料已经很多了，这里就不啰嗦。<br>看上去是很方便的一个功能，尤其是在很多项目里有很多bean，每次都要手写或自动生成setter getter方法，搞得代码很长而且没有啥意义，因此这个对简化代码的强迫症们还是很有吸引力的。<br>但是，我们发现这个包跟一般的包有很大区别，绝大多数java包都工作在运行时，比如spring提供的那种注解，通过在运行时用反射来实现业务逻辑。Lombok这个东西工作却在编译期，在运行时是无法通过反射获取到这个注解的。<br>而且由于他相当于是在编译期对代码进行了修改，因此从直观上看，源代码甚至是语法有问题的。<br>一个更直接的体现就是，普通的包在引用之后一般的IDE都能够自动识别语法，但是Lombok的这些注解，一般的IDE都无法自动识别，比如我们上面的Test类，如果我们在其他地方这么调用了一下:</p>\n<pre><code>Test test=new Test();\ntest.getValue();</code></pre><p>IDE的自动语法检查就会报错，说找不到这个getValue方法。因此如果要使用Lombok的话还需要配合安装相应的插件，防止IDE的自动检查报错。<br>因此，可以说这个东西的设计初衷比较美好，但是用起来比较麻烦，而且破坏了代码的完整性，很多项目组(包括我自己)都不高兴用。但是他的实现原理却还是比较好玩的，随便搜了搜发现网上最多也只提到了他修改了抽象语法树，虽说从感性上可以理解，但是还是想自己手敲一敲真正去实现一下。</p>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>翻了翻现有的资料，再加上自己的一些猜想，Lombok的基本流程应该基本是这样：</p>\n<ul>\n<li>定义编译期的注解</li>\n<li>利用JSR269 api(Pluggable Annotation Processing API )创建编译期的注解处理器</li>\n<li>利用tools.jar的javac api处理AST(抽象语法树)</li>\n<li>将功能注册进jar包</li>\n</ul>\n<h2 id=\"手撸Getter\"><a href=\"#手撸Getter\" class=\"headerlink\" title=\"手撸Getter\"></a>手撸Getter</h2><p>由于比较习惯用maven，我这里就用maven构建一下项目，修改下当前的pom.xml文件如下：</p>\n<pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;com.mythsman.test&lt;/groupId&gt;\n    &lt;artifactId&gt;getter&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n    &lt;name&gt;test&lt;/name&gt;\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;/properties&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.sun&lt;/groupId&gt;\n            &lt;artifactId&gt;tools&lt;/artifactId&gt;\n            &lt;version&gt;1.8&lt;/version&gt;\n            &lt;scope&gt;system&lt;/scope&gt;\n            &lt;systemPath&gt;${java.home}/../lib/tools.jar&lt;/systemPath&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.1&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;source&gt;1.8&lt;/source&gt;\n                    &lt;target&gt;1.8&lt;/target&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n&lt;/project&gt;</code></pre><p>主要定义了下项目名，除了默认依赖的junit之外(其实并没有用)，这里添加了tools.jar包。这个包实在jdk的lib下面，因此scope是system，由于${java.home}变量表示的是jre的位置，因此还要根据这个位置找到实际的tools.jar的路径并写在systemPath里。<br>由于防止在写代码的时候用到java8的一些语法，这里配置了下编译插件使其支持java8。</p>\n<h3 id=\"创建Getter注解\"><a href=\"#创建Getter注解\" class=\"headerlink\" title=\"创建Getter注解\"></a>创建Getter注解</h3><p>定义注解Getter.java:</p>\n<pre><code>package com.mythsman.test;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Getter {\n}</code></pre><p>这里的Target我选择了ElementType.TYPE表示是对类的注解，Retention选择了RententionPolicy.SOURCE，表示这个注解只在编译期起作用，在运行时将不存在。这个比较简单，稍微复杂点的是对这个注解的处理机制。像spring那种注解是通过反射来获得注解对应的元素并实现业务逻辑，但是我们显然不希望在使用Lombok这种功能的时候还要编写其他的调用代码，况且用反射也获取不到编译期才存在的注解。<br>幸运的是Java早已支持了JSR269的规范，允许在编译时指定一个processor类来对编译阶段的注解进行干预，下面就来解决下这个处理器。</p>\n<h3 id=\"创建Getter注解的处理器\"><a href=\"#创建Getter注解的处理器\" class=\"headerlink\" title=\"创建Getter注解的处理器\"></a>创建Getter注解的处理器</h3><p>基本框架</p>\n<p>自定义的处理器需要继承AbstractProcessor这个类，基本的框架大体应当如下:</p>\n<pre><code>package com.mythsman.test;\nimport javax.annotation.processing.*;\nimport javax.lang.model.SourceVersion;\nimport javax.lang.model.element.TypeElement;\nimport java.util.Set;\n@SupportedAnnotationTypes(&quot;com.mythsman.test.Getter&quot;)\n@SupportedSourceVersion(SourceVersion.RELEASE_8)\npublic class GetterProcessor extends AbstractProcessor {\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnv) {\n        super.init(processingEnv);\n    }\n    @Override\n    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {\n        return true;\n    }\n}</code></pre><p>需要定义两个注解，一个表示该处理器需要处理的注解，另外一个表示该处理器支持的源码版本。然后需要着重实现两个方法，init跟process。init的主要用途是通过ProcessingEnvironment来获取编译阶段的一些环境信息;process主要是实现具体逻辑的地方，也就是对AST进行处理的地方。</p>\n<p>具体怎么做呢？</p>\n<p>init方法<br>首先我们要重写下init方法，从环境里提取一些关键的类:</p>\n<pre><code>private Messager messager;\nprivate JavacTrees trees;\nprivate TreeMaker treeMaker;\nprivate Names names;\n@Override\npublic synchronized void init(ProcessingEnvironment processingEnv) {\n    super.init(processingEnv);\n    this.messager = processingEnv.getMessager();\n    this.trees = JavacTrees.instance(processingEnv);\n    Context context = ((JavacProcessingEnvironment) processingEnv).getContext();\n    this.treeMaker = TreeMaker.instance(context);\n    this.names = Names.instance(context);\n}</code></pre><p>我们提取了四个主要的类:</p>\n<ul>\n<li>Messager主要是用来在编译期打log用的</li>\n<li>JavacTrees提供了待处理的抽象语法树</li>\n<li>TreeMaker封装了创建AST节点的一些方法</li>\n<li>Names提供了创建标识符的方法</li>\n</ul>\n<p>process方法<br>process方法的逻辑比较简单，但是由于这里的api对于我们来说比较陌生，因此写起来还是费了不少劲的：</p>\n<pre><code>@Override\npublic synchronized boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {\n    Set&lt;? extends Element&gt; set = roundEnv.getElementsAnnotatedWith(Getter.class);\n    set.forEach(element -&gt; {\n        JCTree jcTree = trees.getTree(element);\n        jcTree.accept(new TreeTranslator() {\n            @Override\n            public void visitClassDef(JCTree.JCClassDecl jcClassDecl) {\n                List&lt;JCTree.JCVariableDecl&gt; jcVariableDeclList = List.nil();\n                for (JCTree tree : jcClassDecl.defs) {\n                    if (tree.getKind().equals(Tree.Kind.VARIABLE)) {\n                        JCTree.JCVariableDecl jcVariableDecl = (JCTree.JCVariableDecl) tree;\n                        jcVariableDeclList = jcVariableDeclList.append(jcVariableDecl);\n                    }\n                }\n                jcVariableDeclList.forEach(jcVariableDecl -&gt; {\n                    messager.printMessage(Diagnostic.Kind.NOTE, jcVariableDecl.getName() + &quot; has been processed&quot;);\n                    jcClassDecl.defs = jcClassDecl.defs.prepend(makeGetterMethodDecl(jcVariableDecl));\n                });\n                super.visitClassDef(jcClassDecl);\n            }\n        });\n    });\n    return true;\n}</code></pre><p>步骤大概是下面这样：</p>\n<ol>\n<li>利用roundEnv的getElementsAnnotatedWith方法过滤出被Getter这个注解标记的类，并存入set</li>\n<li>遍历这个set里的每一个元素，并生成jCTree这个语法树</li>\n<li>创建一个TreeTranslator，并重写其中的visitClassDef方法，这个方法处理遍历语法树得到的类定义部分jcClassDecl<ul>\n<li>创建一个jcVariableDeclList保存类的成员变量</li>\n<li>遍历jcTree的所有成员(包括成员变量和成员函数和构造函数)，过滤出其中的成员变量，并添加进jcVariableDeclList</li>\n<li>将jcVariableDeclList的所有变量转换成需要添加的getter方法，并添加进jcClassDecl的成员中</li>\n<li>调用默认的遍历方法遍历处理后的jcClassDecl</li>\n</ul>\n</li>\n<li>利用上面的TreeTranslator去处理jcTree</li>\n</ol>\n<p>接下来再实现makeGetterMethodDecl方法:</p>\n<pre><code>private JCTree.JCMethodDecl makeGetterMethodDecl(JCTree.JCVariableDecl jcVariableDecl) {\n    ListBuffer&lt;JCTree.JCStatement&gt; statements = new ListBuffer&lt;&gt;();\n    statements.append(treeMaker.Return(treeMaker.Select(treeMaker.Ident(names.fromString(&quot;this&quot;)), jcVariableDecl.getName())));\n    JCTree.JCBlock body = treeMaker.Block(0, statements.toList());\n    return treeMaker.MethodDef(treeMaker.Modifiers(Flags.PUBLIC), getNewMethodName(jcVariableDecl.getName()), jcVariableDecl.vartype, List.nil(), List.nil(), List.nil(), body, null);\n}\nprivate Name getNewMethodName(Name name) {\n    String s = name.toString();\n    return names.fromString(&quot;get&quot; + s.substring(0, 1).toUpperCase() + s.substring(1, name.length()));\n}</code></pre><p>逻辑就是读取变量的定义，并创建对应的Getter方法，并试图用驼峰命名法。</p>\n<p>整体上难点还是集中在api的使用上，还有一些细微的注意点:<br>首先，messager的printMessage方法在打印log的时候会自动过滤重复的log信息。<br>其次，这里的list并不是java.util里面的list，而是一个自定义的list，这个list的用法比较坑爹，他采用的是这样的方式:</p>\n<pre><code>package com.sun.tools.javac.util;\npublic class List&lt;A&gt; extends AbstractCollection&lt;A&gt; implements java.util.List&lt;A&gt; {\n    public A head;\n    public List&lt;A&gt; tail;\n\n    //...\n\n    List(A var1, List&lt;A&gt; var2) {\n        this.tail = var2;\n        this.head = var1;\n    }\n\n    public List&lt;A&gt; prepend(A var1) {\n        return new List(var1, this);\n    }\n\n    public static &lt;A&gt; List&lt;A&gt; of(A var0) {\n        return new List(var0, nil());\n    }\n\n    public List&lt;A&gt; append(A var1) {\n        return of(var1).prependList(this);\n    }\n\n    public static &lt;A&gt; List&lt;A&gt; nil() {\n        return EMPTY_LIST;\n    }\n    //...\n}</code></pre><p>挺有趣的，用这种叫cons而不是list的数据结构，添加元素的时候就把自己赋给自己的tail,新来的元素放进head。不过需要注意的是这个东西不支持链式调用，prepend之后还要将新值赋给自己。<br>而且这里在创建getter方法的时候还要把参数写全写对了，尤其是添加this指针的这种用法。</p>\n<p>测试类<br>上面基本就是所有功能代码了，接下来我们要写一个类来测试一下(App.java)：</p>\n<pre><code>package com.mythsman.test;\n@Getter\npublic class App {\n    private String value;\n    private String value2;\n    public App(String value) {\n        this.value = value;\n    }\n    public static void main(String[] args) {\n        App app = new App(&quot;it works&quot;);\n        System.out.println(app.getValue());\n    }\n}</code></pre><p>不过，先不要急着构建，构建了肯定会失败，因为这原则上应该是两个项目。Getter.java是注解类没问题，但是GetterProcessor.java是处理器，App.java需要在编译期调用这个处理器，因此这两个东西是不能一起编译的，正确的编译方法应该是类似下面这样，写成compile.sh脚本就是：</p>\n<pre><code>#!/usr/bin/env bash\nif [ -d classes ]; then\n    rm -rf classes;\nfi\nmkdir classes\njavac -cp $JAVA_HOME/lib/tools.jar com/mythsman/test/Getter* -d classes/\njavac -cp classes -d classes -processor com.mythsman.test.GetterProcessor com/mythsman/test/App.java\njavap -p classes com/mythsman/test/App.class\njava -cp classes com.mythsman.test.App</code></pre><p>其实是五个步骤:</p>\n<ol>\n<li>创建保存class文件的文件夹</li>\n<li>导入tools.jar，编译processor并输出</li>\n<li>编译App.java，并使用javac的-processor参数指定编译阶段的处理器GetterProcessor</li>\n<li>用javap显示编译后的App.class文件(非必须，方便看结果)</li>\n<li>执行测试类    </li>\n</ol>\n<p>好了，进入项目的根目录，当前的目录结构应该是这样的:</p>\n<p>.<br>├── pom.xml<br>├── src<br>│   ├── main<br>│   │   ├── java<br>│   │   │   ├── com<br>│   │   │   │   └── mythsman<br>│   │   │   │       └── test<br>│   │   │   │           ├── App.java<br>│   │   │   │           ├── Getter.java<br>│   │   │   │           └── GetterProcessor.java<br>│   │   │   └── compile.sh</p>\n<p>调用compile.sh，输出如下:</p>\n<pre><code>Note: value has been processed\nNote: value2 has been processed\nCompiled from &quot;App.java&quot;\npublic class com.mythsman.test.App {\n  private java.lang.String value;\n  private java.lang.String value2;\n  public java.lang.String getValue2();\n  public java.lang.String getValue();\n  public com.mythsman.test.App(java.lang.String);\n  public static void main(java.lang.String[]);\n}\nit works</code></pre><p>Note行就是在GetterProcessor类里通过messager打印的log，中间的是javap反编译的结果，最后一行表示测试调用成功。</p>\n<h3 id=\"Maven构建并打包\"><a href=\"#Maven构建并打包\" class=\"headerlink\" title=\"Maven构建并打包\"></a>Maven构建并打包</h3><p>上面的测试部分其实是为了测试而测试，其实这应当是两个项目，一个是processor项目，这个项目应当被打成一个jar包，供调用者使用；另一个项目是app项目，这个项目是专门使用jar包的，他并不希望添加任何额外编译参数，就跟lombok的用法一样。<br>简单来说，就是我们希望把processor打成一个包，并且在使用时不需要添加额外参数。<br>那么如何在调用的时候不用加参数呢，其实我们知道java在编译的时候会去资源文件夹下读一个META-INF文件夹，这个文件夹下面除了MANIFEST.MF文件之外，还可以添加一个services文件夹，我们可以在这个文件夹下创建一个文件，文件名是javax.annotation.processing.Processor，文件内容是com.mythsman.test.GetterProcessor。<br>我们知道maven在编译前会先拷贝资源文件夹，然后当他在编译时候发现了资源文件夹下的META-INF/serivces文件夹时，他就会读取里面的文件，并将文件名所代表的接口用文件内容表示的类来实现。这就相当于做了-processor参数该做的事了。<br>当然这个文件我们并不希望调用者去写，而是希望在processor项目里集成，调用的时候能直接继承META-INF。</p>\n<p>好了，我们先删除App.java和compile.sh，添加下META-INF文件夹，当前目录结构应该是这样的：</p>\n<p>.<br>├── pom.xml<br>├── src<br>│   └── main<br>│       ├── java<br>│       │   └── com<br>│       │       └── mythsman<br>│       │           └── test<br>│       │               ├── Getter.java<br>│       │               └── GetterProcessor.java<br>│       └── resources<br>│           └── META-INF<br>│               └── services<br>│                   └── javax.annotation.processing.Processor</p>\n<p>当然，我们还不能编译，因为processor项目并不需要把自己添加为processor(况且自己还没编译呢怎么调用自己)。。。完了，好像死循环了，自己在编译的时候不能添加services文件夹，但是又需要打的包里有services文件夹，这该怎么搞呢？<br>其实很简单，配置一下maven的插件就行，打开pom.xml,在project/build/标签里添加下面的配置:</p>\n<pre><code>&lt;build&gt;\n   &lt;resources&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;src/main/resources&lt;/directory&gt;\n            &lt;excludes&gt;\n                &lt;exclude&gt;META-INF/**/*&lt;/exclude&gt;\n            &lt;/excludes&gt;\n        &lt;/resource&gt;\n    &lt;/resources&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n            &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;\n            &lt;version&gt;2.6&lt;/version&gt;\n            &lt;executions&gt;\n                &lt;execution&gt;\n                    &lt;id&gt;process-META&lt;/id&gt;\n                    &lt;phase&gt;prepare-package&lt;/phase&gt;\n                    &lt;goals&gt;\n                        &lt;goal&gt;copy-resources&lt;/goal&gt;\n                    &lt;/goals&gt;\n                    &lt;configuration&gt;\n                        &lt;outputDirectory&gt;target/classes&lt;/outputDirectory&gt;\n                        &lt;resources&gt;\n                            &lt;resource&gt;\n                                &lt;directory&gt;${basedir}/src/main/resources/&lt;/directory&gt;\n                                &lt;includes&gt;\n                                    &lt;include&gt;**/*&lt;/include&gt;\n                                &lt;/includes&gt;\n                            &lt;/resource&gt;\n                        &lt;/resources&gt;\n                    &lt;/configuration&gt;\n                &lt;/execution&gt;\n            &lt;/executions&gt;\n        &lt;/plugin&gt;\n        ...\n    &lt;/plugins&gt;\n&lt;/build&gt;</code></pre><p>我们知道maven构建的第一步就是调用maven-resources-plugin插件的resources命令，将resources文件夹复制到target/classes中，那么我们配置一下resources标签，过滤掉META-INF文件夹，这样在编译的时候就不会找到services的配置了。然后我们在打包前(prepare-package生命周期)再利用maven-resources-plugin插件的copy-resources命令把services文件夹重新拷贝过来不就好了么。<br>这样配置好了，就可以直接执行mvn clean install打包提交到本地私服:</p>\n<pre><code>myths@pc:~/Desktop/test$ mvn clean install\n[INFO] Scanning for projects...\n[INFO] \n[INFO] ------------------------------------------------------------------------\n[INFO] Building test 1.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO] \n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ getter ---\n[INFO] \n[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ getter ---\n[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.\n[INFO] Copying 0 resource\n[INFO] \n[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ getter ---\n[INFO] Changes detected - recompiling the module!\n[INFO] Compiling 2 source files to /home/myths/Desktop/test/target/classes\n[INFO] \n[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ getter ---\n[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.\n[INFO] skip non existing resourceDirectory /home/myths/Desktop/test/src/test/resources\n[INFO] \n[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ getter ---\n[INFO] No sources to compile\n[INFO] \n[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ getter ---\n[INFO] No tests to run.\n[INFO] \n[INFO] --- maven-resources-plugin:2.6:copy-resources (process-META) @ getter ---\n[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.\n[INFO] Copying 1 resource\n[INFO] \n[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ getter ---\n[INFO] Building jar: /home/myths/Desktop/test/target/getter-1.0-SNAPSHOT.jar\n[INFO] \n[INFO] --- maven-install-plugin:2.4:install (default-install) @ getter ---\n[INFO] Installing /home/myths/Desktop/test/target/getter-1.0-SNAPSHOT.jar to /home/myths/.m2/repository/com/mythsman/test/getter/1.0-SNAPSHOT/getter-1.0-SNAPSHOT.jar\n[INFO] Installing /home/myths/Desktop/test/pom.xml to /home/myths/.m2/repository/com/mythsman/test/getter/1.0-SNAPSHOT/getter-1.0-SNAPSHOT.pom\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 3.017 s\n[INFO] Finished at: 2017-12-19T19:57:04+08:00\n[INFO] Final Memory: 16M/201M\n[INFO] ------------------------------------------------------------------------</code></pre><p>可以看到这里的process-META作用生效。</p>\n<p>调用jar包测试</p>\n<p>重新创建一个测试项目app：</p>\n<p>.<br>├── pom.xml<br>└── src<br>    └── main<br>        └── java<br>            └── com<br>                └── mythsman<br>                    └── test<br>                        └── App.java</p>\n<p>pom.xml:</p>\n<pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;com.mythsman.test&lt;/groupId&gt;\n    &lt;artifactId&gt;app&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n    &lt;name&gt;main&lt;/name&gt;\n    &lt;url&gt;http://maven.apache.org&lt;/url&gt;\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;/properties&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.mythsman.test&lt;/groupId&gt;\n            &lt;artifactId&gt;getter&lt;/artifactId&gt;\n            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.1&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;source&gt;1.8&lt;/source&gt;\n                    &lt;target&gt;1.8&lt;/target&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n&lt;/project&gt;</code></pre><p>App.java:</p>\n<pre><code>package com.mythsman.test;\n@Getter\npublic class App {\n    private String value;\n    private String value2;\n    public App(String value) {\n        this.value = value;\n    }\n    public static void main(String[] args) {\n        App app = new App(&quot;it works&quot;);\n        System.out.println(app.getValue());\n    }\n}</code></pre><p>编译并执行:</p>\n<p>mvn clean compile &amp;&amp; java -cp target/classes com.mythsman.test.App</p>\n<p>最后就会在构建成功后打印”it works”。</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/32779910\" target=\"_blank\" rel=\"noopener\">参考</a><br><a href=\"https://yq.aliyun.com/articles/59972\" target=\"_blank\" rel=\"noopener\">参考</a><br><a href=\"https://juejin.im/entry/5a390ba76fb9a0451e3fed7c\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h1><p><a href=\"https://projectlombok.org\" target=\"_blank\" rel=\"noopener\">官网</a><br>官网解释:</p>\n<p>Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.<br>Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.</p>\n<h1 id=\"why\"><a href=\"#why\" class=\"headerlink\" title=\"why\"></a>why</h1><p>减少代码量,省去写geter,setter等</p>\n<h1 id=\"when\"><a href=\"#when\" class=\"headerlink\" title=\"when\"></a>when</h1><h2 id=\"添加下依赖\"><a href=\"#添加下依赖\" class=\"headerlink\" title=\"添加下依赖:\"></a>添加下依赖:</h2><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n    &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n    &lt;version&gt;1.16.8&lt;/version&gt;\n&lt;/dependency&gt;</code></pre><p>那么Lombok是做什么的呢？其实很简单，一个最简单的例子就是它能够实现通过添加注解，能够自动生成一些方法。比如这样的类:</p>\n<pre><code>@Getter\nclass Test{\n    private String value;\n}</code></pre><p>我们用Lombok提供的@Getter来注解这个类，这个类在编译的时候就会变成:</p>\n<pre><code>class Test{\n    private String value;\n    public String getValue(){\n        return this.value;\n    }\n}</code></pre><p>当然Lombok也提供了很多其他的注解，这只是其中一个最典型的例子。其他的用法网上的资料已经很多了，这里就不啰嗦。<br>看上去是很方便的一个功能，尤其是在很多项目里有很多bean，每次都要手写或自动生成setter getter方法，搞得代码很长而且没有啥意义，因此这个对简化代码的强迫症们还是很有吸引力的。<br>但是，我们发现这个包跟一般的包有很大区别，绝大多数java包都工作在运行时，比如spring提供的那种注解，通过在运行时用反射来实现业务逻辑。Lombok这个东西工作却在编译期，在运行时是无法通过反射获取到这个注解的。<br>而且由于他相当于是在编译期对代码进行了修改，因此从直观上看，源代码甚至是语法有问题的。<br>一个更直接的体现就是，普通的包在引用之后一般的IDE都能够自动识别语法，但是Lombok的这些注解，一般的IDE都无法自动识别，比如我们上面的Test类，如果我们在其他地方这么调用了一下:</p>\n<pre><code>Test test=new Test();\ntest.getValue();</code></pre><p>IDE的自动语法检查就会报错，说找不到这个getValue方法。因此如果要使用Lombok的话还需要配合安装相应的插件，防止IDE的自动检查报错。<br>因此，可以说这个东西的设计初衷比较美好，但是用起来比较麻烦，而且破坏了代码的完整性，很多项目组(包括我自己)都不高兴用。但是他的实现原理却还是比较好玩的，随便搜了搜发现网上最多也只提到了他修改了抽象语法树，虽说从感性上可以理解，但是还是想自己手敲一敲真正去实现一下。</p>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>翻了翻现有的资料，再加上自己的一些猜想，Lombok的基本流程应该基本是这样：</p>\n<ul>\n<li>定义编译期的注解</li>\n<li>利用JSR269 api(Pluggable Annotation Processing API )创建编译期的注解处理器</li>\n<li>利用tools.jar的javac api处理AST(抽象语法树)</li>\n<li>将功能注册进jar包</li>\n</ul>\n<h2 id=\"手撸Getter\"><a href=\"#手撸Getter\" class=\"headerlink\" title=\"手撸Getter\"></a>手撸Getter</h2><p>由于比较习惯用maven，我这里就用maven构建一下项目，修改下当前的pom.xml文件如下：</p>\n<pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;com.mythsman.test&lt;/groupId&gt;\n    &lt;artifactId&gt;getter&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n    &lt;name&gt;test&lt;/name&gt;\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;/properties&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.sun&lt;/groupId&gt;\n            &lt;artifactId&gt;tools&lt;/artifactId&gt;\n            &lt;version&gt;1.8&lt;/version&gt;\n            &lt;scope&gt;system&lt;/scope&gt;\n            &lt;systemPath&gt;${java.home}/../lib/tools.jar&lt;/systemPath&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.1&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;source&gt;1.8&lt;/source&gt;\n                    &lt;target&gt;1.8&lt;/target&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n&lt;/project&gt;</code></pre><p>主要定义了下项目名，除了默认依赖的junit之外(其实并没有用)，这里添加了tools.jar包。这个包实在jdk的lib下面，因此scope是system，由于${java.home}变量表示的是jre的位置，因此还要根据这个位置找到实际的tools.jar的路径并写在systemPath里。<br>由于防止在写代码的时候用到java8的一些语法，这里配置了下编译插件使其支持java8。</p>\n<h3 id=\"创建Getter注解\"><a href=\"#创建Getter注解\" class=\"headerlink\" title=\"创建Getter注解\"></a>创建Getter注解</h3><p>定义注解Getter.java:</p>\n<pre><code>package com.mythsman.test;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Getter {\n}</code></pre><p>这里的Target我选择了ElementType.TYPE表示是对类的注解，Retention选择了RententionPolicy.SOURCE，表示这个注解只在编译期起作用，在运行时将不存在。这个比较简单，稍微复杂点的是对这个注解的处理机制。像spring那种注解是通过反射来获得注解对应的元素并实现业务逻辑，但是我们显然不希望在使用Lombok这种功能的时候还要编写其他的调用代码，况且用反射也获取不到编译期才存在的注解。<br>幸运的是Java早已支持了JSR269的规范，允许在编译时指定一个processor类来对编译阶段的注解进行干预，下面就来解决下这个处理器。</p>\n<h3 id=\"创建Getter注解的处理器\"><a href=\"#创建Getter注解的处理器\" class=\"headerlink\" title=\"创建Getter注解的处理器\"></a>创建Getter注解的处理器</h3><p>基本框架</p>\n<p>自定义的处理器需要继承AbstractProcessor这个类，基本的框架大体应当如下:</p>\n<pre><code>package com.mythsman.test;\nimport javax.annotation.processing.*;\nimport javax.lang.model.SourceVersion;\nimport javax.lang.model.element.TypeElement;\nimport java.util.Set;\n@SupportedAnnotationTypes(&quot;com.mythsman.test.Getter&quot;)\n@SupportedSourceVersion(SourceVersion.RELEASE_8)\npublic class GetterProcessor extends AbstractProcessor {\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnv) {\n        super.init(processingEnv);\n    }\n    @Override\n    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {\n        return true;\n    }\n}</code></pre><p>需要定义两个注解，一个表示该处理器需要处理的注解，另外一个表示该处理器支持的源码版本。然后需要着重实现两个方法，init跟process。init的主要用途是通过ProcessingEnvironment来获取编译阶段的一些环境信息;process主要是实现具体逻辑的地方，也就是对AST进行处理的地方。</p>\n<p>具体怎么做呢？</p>\n<p>init方法<br>首先我们要重写下init方法，从环境里提取一些关键的类:</p>\n<pre><code>private Messager messager;\nprivate JavacTrees trees;\nprivate TreeMaker treeMaker;\nprivate Names names;\n@Override\npublic synchronized void init(ProcessingEnvironment processingEnv) {\n    super.init(processingEnv);\n    this.messager = processingEnv.getMessager();\n    this.trees = JavacTrees.instance(processingEnv);\n    Context context = ((JavacProcessingEnvironment) processingEnv).getContext();\n    this.treeMaker = TreeMaker.instance(context);\n    this.names = Names.instance(context);\n}</code></pre><p>我们提取了四个主要的类:</p>\n<ul>\n<li>Messager主要是用来在编译期打log用的</li>\n<li>JavacTrees提供了待处理的抽象语法树</li>\n<li>TreeMaker封装了创建AST节点的一些方法</li>\n<li>Names提供了创建标识符的方法</li>\n</ul>\n<p>process方法<br>process方法的逻辑比较简单，但是由于这里的api对于我们来说比较陌生，因此写起来还是费了不少劲的：</p>\n<pre><code>@Override\npublic synchronized boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {\n    Set&lt;? extends Element&gt; set = roundEnv.getElementsAnnotatedWith(Getter.class);\n    set.forEach(element -&gt; {\n        JCTree jcTree = trees.getTree(element);\n        jcTree.accept(new TreeTranslator() {\n            @Override\n            public void visitClassDef(JCTree.JCClassDecl jcClassDecl) {\n                List&lt;JCTree.JCVariableDecl&gt; jcVariableDeclList = List.nil();\n                for (JCTree tree : jcClassDecl.defs) {\n                    if (tree.getKind().equals(Tree.Kind.VARIABLE)) {\n                        JCTree.JCVariableDecl jcVariableDecl = (JCTree.JCVariableDecl) tree;\n                        jcVariableDeclList = jcVariableDeclList.append(jcVariableDecl);\n                    }\n                }\n                jcVariableDeclList.forEach(jcVariableDecl -&gt; {\n                    messager.printMessage(Diagnostic.Kind.NOTE, jcVariableDecl.getName() + &quot; has been processed&quot;);\n                    jcClassDecl.defs = jcClassDecl.defs.prepend(makeGetterMethodDecl(jcVariableDecl));\n                });\n                super.visitClassDef(jcClassDecl);\n            }\n        });\n    });\n    return true;\n}</code></pre><p>步骤大概是下面这样：</p>\n<ol>\n<li>利用roundEnv的getElementsAnnotatedWith方法过滤出被Getter这个注解标记的类，并存入set</li>\n<li>遍历这个set里的每一个元素，并生成jCTree这个语法树</li>\n<li>创建一个TreeTranslator，并重写其中的visitClassDef方法，这个方法处理遍历语法树得到的类定义部分jcClassDecl<ul>\n<li>创建一个jcVariableDeclList保存类的成员变量</li>\n<li>遍历jcTree的所有成员(包括成员变量和成员函数和构造函数)，过滤出其中的成员变量，并添加进jcVariableDeclList</li>\n<li>将jcVariableDeclList的所有变量转换成需要添加的getter方法，并添加进jcClassDecl的成员中</li>\n<li>调用默认的遍历方法遍历处理后的jcClassDecl</li>\n</ul>\n</li>\n<li>利用上面的TreeTranslator去处理jcTree</li>\n</ol>\n<p>接下来再实现makeGetterMethodDecl方法:</p>\n<pre><code>private JCTree.JCMethodDecl makeGetterMethodDecl(JCTree.JCVariableDecl jcVariableDecl) {\n    ListBuffer&lt;JCTree.JCStatement&gt; statements = new ListBuffer&lt;&gt;();\n    statements.append(treeMaker.Return(treeMaker.Select(treeMaker.Ident(names.fromString(&quot;this&quot;)), jcVariableDecl.getName())));\n    JCTree.JCBlock body = treeMaker.Block(0, statements.toList());\n    return treeMaker.MethodDef(treeMaker.Modifiers(Flags.PUBLIC), getNewMethodName(jcVariableDecl.getName()), jcVariableDecl.vartype, List.nil(), List.nil(), List.nil(), body, null);\n}\nprivate Name getNewMethodName(Name name) {\n    String s = name.toString();\n    return names.fromString(&quot;get&quot; + s.substring(0, 1).toUpperCase() + s.substring(1, name.length()));\n}</code></pre><p>逻辑就是读取变量的定义，并创建对应的Getter方法，并试图用驼峰命名法。</p>\n<p>整体上难点还是集中在api的使用上，还有一些细微的注意点:<br>首先，messager的printMessage方法在打印log的时候会自动过滤重复的log信息。<br>其次，这里的list并不是java.util里面的list，而是一个自定义的list，这个list的用法比较坑爹，他采用的是这样的方式:</p>\n<pre><code>package com.sun.tools.javac.util;\npublic class List&lt;A&gt; extends AbstractCollection&lt;A&gt; implements java.util.List&lt;A&gt; {\n    public A head;\n    public List&lt;A&gt; tail;\n\n    //...\n\n    List(A var1, List&lt;A&gt; var2) {\n        this.tail = var2;\n        this.head = var1;\n    }\n\n    public List&lt;A&gt; prepend(A var1) {\n        return new List(var1, this);\n    }\n\n    public static &lt;A&gt; List&lt;A&gt; of(A var0) {\n        return new List(var0, nil());\n    }\n\n    public List&lt;A&gt; append(A var1) {\n        return of(var1).prependList(this);\n    }\n\n    public static &lt;A&gt; List&lt;A&gt; nil() {\n        return EMPTY_LIST;\n    }\n    //...\n}</code></pre><p>挺有趣的，用这种叫cons而不是list的数据结构，添加元素的时候就把自己赋给自己的tail,新来的元素放进head。不过需要注意的是这个东西不支持链式调用，prepend之后还要将新值赋给自己。<br>而且这里在创建getter方法的时候还要把参数写全写对了，尤其是添加this指针的这种用法。</p>\n<p>测试类<br>上面基本就是所有功能代码了，接下来我们要写一个类来测试一下(App.java)：</p>\n<pre><code>package com.mythsman.test;\n@Getter\npublic class App {\n    private String value;\n    private String value2;\n    public App(String value) {\n        this.value = value;\n    }\n    public static void main(String[] args) {\n        App app = new App(&quot;it works&quot;);\n        System.out.println(app.getValue());\n    }\n}</code></pre><p>不过，先不要急着构建，构建了肯定会失败，因为这原则上应该是两个项目。Getter.java是注解类没问题，但是GetterProcessor.java是处理器，App.java需要在编译期调用这个处理器，因此这两个东西是不能一起编译的，正确的编译方法应该是类似下面这样，写成compile.sh脚本就是：</p>\n<pre><code>#!/usr/bin/env bash\nif [ -d classes ]; then\n    rm -rf classes;\nfi\nmkdir classes\njavac -cp $JAVA_HOME/lib/tools.jar com/mythsman/test/Getter* -d classes/\njavac -cp classes -d classes -processor com.mythsman.test.GetterProcessor com/mythsman/test/App.java\njavap -p classes com/mythsman/test/App.class\njava -cp classes com.mythsman.test.App</code></pre><p>其实是五个步骤:</p>\n<ol>\n<li>创建保存class文件的文件夹</li>\n<li>导入tools.jar，编译processor并输出</li>\n<li>编译App.java，并使用javac的-processor参数指定编译阶段的处理器GetterProcessor</li>\n<li>用javap显示编译后的App.class文件(非必须，方便看结果)</li>\n<li>执行测试类    </li>\n</ol>\n<p>好了，进入项目的根目录，当前的目录结构应该是这样的:</p>\n<p>.<br>├── pom.xml<br>├── src<br>│   ├── main<br>│   │   ├── java<br>│   │   │   ├── com<br>│   │   │   │   └── mythsman<br>│   │   │   │       └── test<br>│   │   │   │           ├── App.java<br>│   │   │   │           ├── Getter.java<br>│   │   │   │           └── GetterProcessor.java<br>│   │   │   └── compile.sh</p>\n<p>调用compile.sh，输出如下:</p>\n<pre><code>Note: value has been processed\nNote: value2 has been processed\nCompiled from &quot;App.java&quot;\npublic class com.mythsman.test.App {\n  private java.lang.String value;\n  private java.lang.String value2;\n  public java.lang.String getValue2();\n  public java.lang.String getValue();\n  public com.mythsman.test.App(java.lang.String);\n  public static void main(java.lang.String[]);\n}\nit works</code></pre><p>Note行就是在GetterProcessor类里通过messager打印的log，中间的是javap反编译的结果，最后一行表示测试调用成功。</p>\n<h3 id=\"Maven构建并打包\"><a href=\"#Maven构建并打包\" class=\"headerlink\" title=\"Maven构建并打包\"></a>Maven构建并打包</h3><p>上面的测试部分其实是为了测试而测试，其实这应当是两个项目，一个是processor项目，这个项目应当被打成一个jar包，供调用者使用；另一个项目是app项目，这个项目是专门使用jar包的，他并不希望添加任何额外编译参数，就跟lombok的用法一样。<br>简单来说，就是我们希望把processor打成一个包，并且在使用时不需要添加额外参数。<br>那么如何在调用的时候不用加参数呢，其实我们知道java在编译的时候会去资源文件夹下读一个META-INF文件夹，这个文件夹下面除了MANIFEST.MF文件之外，还可以添加一个services文件夹，我们可以在这个文件夹下创建一个文件，文件名是javax.annotation.processing.Processor，文件内容是com.mythsman.test.GetterProcessor。<br>我们知道maven在编译前会先拷贝资源文件夹，然后当他在编译时候发现了资源文件夹下的META-INF/serivces文件夹时，他就会读取里面的文件，并将文件名所代表的接口用文件内容表示的类来实现。这就相当于做了-processor参数该做的事了。<br>当然这个文件我们并不希望调用者去写，而是希望在processor项目里集成，调用的时候能直接继承META-INF。</p>\n<p>好了，我们先删除App.java和compile.sh，添加下META-INF文件夹，当前目录结构应该是这样的：</p>\n<p>.<br>├── pom.xml<br>├── src<br>│   └── main<br>│       ├── java<br>│       │   └── com<br>│       │       └── mythsman<br>│       │           └── test<br>│       │               ├── Getter.java<br>│       │               └── GetterProcessor.java<br>│       └── resources<br>│           └── META-INF<br>│               └── services<br>│                   └── javax.annotation.processing.Processor</p>\n<p>当然，我们还不能编译，因为processor项目并不需要把自己添加为processor(况且自己还没编译呢怎么调用自己)。。。完了，好像死循环了，自己在编译的时候不能添加services文件夹，但是又需要打的包里有services文件夹，这该怎么搞呢？<br>其实很简单，配置一下maven的插件就行，打开pom.xml,在project/build/标签里添加下面的配置:</p>\n<pre><code>&lt;build&gt;\n   &lt;resources&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;src/main/resources&lt;/directory&gt;\n            &lt;excludes&gt;\n                &lt;exclude&gt;META-INF/**/*&lt;/exclude&gt;\n            &lt;/excludes&gt;\n        &lt;/resource&gt;\n    &lt;/resources&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n            &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;\n            &lt;version&gt;2.6&lt;/version&gt;\n            &lt;executions&gt;\n                &lt;execution&gt;\n                    &lt;id&gt;process-META&lt;/id&gt;\n                    &lt;phase&gt;prepare-package&lt;/phase&gt;\n                    &lt;goals&gt;\n                        &lt;goal&gt;copy-resources&lt;/goal&gt;\n                    &lt;/goals&gt;\n                    &lt;configuration&gt;\n                        &lt;outputDirectory&gt;target/classes&lt;/outputDirectory&gt;\n                        &lt;resources&gt;\n                            &lt;resource&gt;\n                                &lt;directory&gt;${basedir}/src/main/resources/&lt;/directory&gt;\n                                &lt;includes&gt;\n                                    &lt;include&gt;**/*&lt;/include&gt;\n                                &lt;/includes&gt;\n                            &lt;/resource&gt;\n                        &lt;/resources&gt;\n                    &lt;/configuration&gt;\n                &lt;/execution&gt;\n            &lt;/executions&gt;\n        &lt;/plugin&gt;\n        ...\n    &lt;/plugins&gt;\n&lt;/build&gt;</code></pre><p>我们知道maven构建的第一步就是调用maven-resources-plugin插件的resources命令，将resources文件夹复制到target/classes中，那么我们配置一下resources标签，过滤掉META-INF文件夹，这样在编译的时候就不会找到services的配置了。然后我们在打包前(prepare-package生命周期)再利用maven-resources-plugin插件的copy-resources命令把services文件夹重新拷贝过来不就好了么。<br>这样配置好了，就可以直接执行mvn clean install打包提交到本地私服:</p>\n<pre><code>myths@pc:~/Desktop/test$ mvn clean install\n[INFO] Scanning for projects...\n[INFO] \n[INFO] ------------------------------------------------------------------------\n[INFO] Building test 1.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO] \n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ getter ---\n[INFO] \n[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ getter ---\n[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.\n[INFO] Copying 0 resource\n[INFO] \n[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ getter ---\n[INFO] Changes detected - recompiling the module!\n[INFO] Compiling 2 source files to /home/myths/Desktop/test/target/classes\n[INFO] \n[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ getter ---\n[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.\n[INFO] skip non existing resourceDirectory /home/myths/Desktop/test/src/test/resources\n[INFO] \n[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ getter ---\n[INFO] No sources to compile\n[INFO] \n[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ getter ---\n[INFO] No tests to run.\n[INFO] \n[INFO] --- maven-resources-plugin:2.6:copy-resources (process-META) @ getter ---\n[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.\n[INFO] Copying 1 resource\n[INFO] \n[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ getter ---\n[INFO] Building jar: /home/myths/Desktop/test/target/getter-1.0-SNAPSHOT.jar\n[INFO] \n[INFO] --- maven-install-plugin:2.4:install (default-install) @ getter ---\n[INFO] Installing /home/myths/Desktop/test/target/getter-1.0-SNAPSHOT.jar to /home/myths/.m2/repository/com/mythsman/test/getter/1.0-SNAPSHOT/getter-1.0-SNAPSHOT.jar\n[INFO] Installing /home/myths/Desktop/test/pom.xml to /home/myths/.m2/repository/com/mythsman/test/getter/1.0-SNAPSHOT/getter-1.0-SNAPSHOT.pom\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 3.017 s\n[INFO] Finished at: 2017-12-19T19:57:04+08:00\n[INFO] Final Memory: 16M/201M\n[INFO] ------------------------------------------------------------------------</code></pre><p>可以看到这里的process-META作用生效。</p>\n<p>调用jar包测试</p>\n<p>重新创建一个测试项目app：</p>\n<p>.<br>├── pom.xml<br>└── src<br>    └── main<br>        └── java<br>            └── com<br>                └── mythsman<br>                    └── test<br>                        └── App.java</p>\n<p>pom.xml:</p>\n<pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;com.mythsman.test&lt;/groupId&gt;\n    &lt;artifactId&gt;app&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n    &lt;name&gt;main&lt;/name&gt;\n    &lt;url&gt;http://maven.apache.org&lt;/url&gt;\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;/properties&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.mythsman.test&lt;/groupId&gt;\n            &lt;artifactId&gt;getter&lt;/artifactId&gt;\n            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.1&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;source&gt;1.8&lt;/source&gt;\n                    &lt;target&gt;1.8&lt;/target&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n&lt;/project&gt;</code></pre><p>App.java:</p>\n<pre><code>package com.mythsman.test;\n@Getter\npublic class App {\n    private String value;\n    private String value2;\n    public App(String value) {\n        this.value = value;\n    }\n    public static void main(String[] args) {\n        App app = new App(&quot;it works&quot;);\n        System.out.println(app.getValue());\n    }\n}</code></pre><p>编译并执行:</p>\n<p>mvn clean compile &amp;&amp; java -cp target/classes com.mythsman.test.App</p>\n<p>最后就会在构建成功后打印”it works”。</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/32779910\" target=\"_blank\" rel=\"noopener\">参考</a><br><a href=\"https://yq.aliyun.com/articles/59972\" target=\"_blank\" rel=\"noopener\">参考</a><br><a href=\"https://juejin.im/entry/5a390ba76fb9a0451e3fed7c\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n"},{"title":"Mac配置多个Java版本","date":"2019-08-28T09:58:34.000Z","_content":"\n## 一. 安装最新版的Java\n\n    # 如何没有安装 brew cask。请执行    $ brew tap caskroom/versions\n    $ brew cask install java\n    \n## 二.安装其他版本的Java\n\n    如果你需要安装其他的jdk(JDK 7 或者 JDK 6)，可以使用homebrew-cask-versions：\n    $ brew search java\n    $ brew cask install java6      # 使用cask安装其他的工具\n\n## 三.查看本地安装的Java Home\n\n    $ /usr/libexec/java_home -V #查看本地安装的java版本\n\n## 四.切换java版本【手动修改环境变量】\n\n    那问题来了，当你运行java或者 Java 程序时使用的是哪个 JDK 呢？在 OS X 下，java也就是/usr/bin/java在默认情况下指向的是已经安装的最新版本。但是你可以设置环境变量JAVA_HOME来更改其指向：\n    \n    # 查看当前的java版本\n    $ java -version          \n    java version \"1.8.0_60\"\n    Java(TM) SE Runtime Environment (build 1.8.0_60-b27)\n    Java HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode)\n    \n    # 切换版本，可切换为第三步的本地java home中的任意一个。\n    $ export JAVA_HOME=/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home java -version  \n    java version \"1.6.0_65\"\n    Java(TM) SE Runtime Environment (build 1.6.0_65-b14-466.1-11M4716)\n    Java HotSpot(TM) 64-Bit Server VM (build 20.65-b04-466.1, mixed mode)\n\n## 五.配置命令自动切换\n\n修改系统环境变量：\n\n在~/.bash_profile（如果是Zsh，修改~/.zshrc）文件中添加如下内容：\n    \n    # JDK 6  \n    export JAVA_6_HOME=\"/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home\"\n    # JDK 8\n    export JAVA_8_HOME=\"/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home\"\n    \n    export JAVA_HOME=$JAVA_8_HOME #默认JDK 8\n    \n    #alias命令动态切换JDK版本  \n    alias jdk6=\"export JAVA_HOME=$JAVA_6_HOME\"    \n    alias jdk8=\"export JAVA_HOME=$JAVA_8_HOME\"  \n\n更新配置：\n\n    $ source ~/.bash_profile #Zsh应改为 source ~/.zshrc\n\n切换java版本：\n\n    $ jdk6    #使用jdk6\n    $ java -version \n        java version \"1.6.0_65\"\n        Java(TM) SE Runtime Environment (build 1.6.0_65-b14-468)\n        Java HotSpot(TM) 64-Bit Server VM (build 20.65-b04-468, mixed mode)\n    \n    $ jdk8    #使用jdk8\n    $ java -version \n        java version \"1.8.0_101\"\n        Java(TM) SE Runtime Environment (build 1.8.0_101-b13)\n        Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)\n        \n    说明：Mac系统的环境变量，加载顺序为：\n    /etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc\n\n[参考1](https://segmentfault.com/a/1190000013131276)            \n[参考2](https://www.kancloud.cn/kancloud/ocds-guide-to-setting-up-mac)\n\n\n    ","source":"_posts/Mac配置多个Java版本.md","raw":"---\ntitle: Mac配置多个Java版本\ndate: 2019-08-28 17:58:34\ntags: [java jdk]\n---\n\n## 一. 安装最新版的Java\n\n    # 如何没有安装 brew cask。请执行    $ brew tap caskroom/versions\n    $ brew cask install java\n    \n## 二.安装其他版本的Java\n\n    如果你需要安装其他的jdk(JDK 7 或者 JDK 6)，可以使用homebrew-cask-versions：\n    $ brew search java\n    $ brew cask install java6      # 使用cask安装其他的工具\n\n## 三.查看本地安装的Java Home\n\n    $ /usr/libexec/java_home -V #查看本地安装的java版本\n\n## 四.切换java版本【手动修改环境变量】\n\n    那问题来了，当你运行java或者 Java 程序时使用的是哪个 JDK 呢？在 OS X 下，java也就是/usr/bin/java在默认情况下指向的是已经安装的最新版本。但是你可以设置环境变量JAVA_HOME来更改其指向：\n    \n    # 查看当前的java版本\n    $ java -version          \n    java version \"1.8.0_60\"\n    Java(TM) SE Runtime Environment (build 1.8.0_60-b27)\n    Java HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode)\n    \n    # 切换版本，可切换为第三步的本地java home中的任意一个。\n    $ export JAVA_HOME=/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home java -version  \n    java version \"1.6.0_65\"\n    Java(TM) SE Runtime Environment (build 1.6.0_65-b14-466.1-11M4716)\n    Java HotSpot(TM) 64-Bit Server VM (build 20.65-b04-466.1, mixed mode)\n\n## 五.配置命令自动切换\n\n修改系统环境变量：\n\n在~/.bash_profile（如果是Zsh，修改~/.zshrc）文件中添加如下内容：\n    \n    # JDK 6  \n    export JAVA_6_HOME=\"/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home\"\n    # JDK 8\n    export JAVA_8_HOME=\"/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home\"\n    \n    export JAVA_HOME=$JAVA_8_HOME #默认JDK 8\n    \n    #alias命令动态切换JDK版本  \n    alias jdk6=\"export JAVA_HOME=$JAVA_6_HOME\"    \n    alias jdk8=\"export JAVA_HOME=$JAVA_8_HOME\"  \n\n更新配置：\n\n    $ source ~/.bash_profile #Zsh应改为 source ~/.zshrc\n\n切换java版本：\n\n    $ jdk6    #使用jdk6\n    $ java -version \n        java version \"1.6.0_65\"\n        Java(TM) SE Runtime Environment (build 1.6.0_65-b14-468)\n        Java HotSpot(TM) 64-Bit Server VM (build 20.65-b04-468, mixed mode)\n    \n    $ jdk8    #使用jdk8\n    $ java -version \n        java version \"1.8.0_101\"\n        Java(TM) SE Runtime Environment (build 1.8.0_101-b13)\n        Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)\n        \n    说明：Mac系统的环境变量，加载顺序为：\n    /etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc\n\n[参考1](https://segmentfault.com/a/1190000013131276)            \n[参考2](https://www.kancloud.cn/kancloud/ocds-guide-to-setting-up-mac)\n\n\n    ","slug":"Mac配置多个Java版本","published":1,"updated":"2019-09-27T08:27:08.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecs000lojfywqv1p5bw","content":"<h2 id=\"一-安装最新版的Java\"><a href=\"#一-安装最新版的Java\" class=\"headerlink\" title=\"一. 安装最新版的Java\"></a>一. 安装最新版的Java</h2><pre><code># 如何没有安装 brew cask。请执行    $ brew tap caskroom/versions\n$ brew cask install java</code></pre><h2 id=\"二-安装其他版本的Java\"><a href=\"#二-安装其他版本的Java\" class=\"headerlink\" title=\"二.安装其他版本的Java\"></a>二.安装其他版本的Java</h2><pre><code>如果你需要安装其他的jdk(JDK 7 或者 JDK 6)，可以使用homebrew-cask-versions：\n$ brew search java\n$ brew cask install java6      # 使用cask安装其他的工具</code></pre><h2 id=\"三-查看本地安装的Java-Home\"><a href=\"#三-查看本地安装的Java-Home\" class=\"headerlink\" title=\"三.查看本地安装的Java Home\"></a>三.查看本地安装的Java Home</h2><pre><code>$ /usr/libexec/java_home -V #查看本地安装的java版本</code></pre><h2 id=\"四-切换java版本【手动修改环境变量】\"><a href=\"#四-切换java版本【手动修改环境变量】\" class=\"headerlink\" title=\"四.切换java版本【手动修改环境变量】\"></a>四.切换java版本【手动修改环境变量】</h2><pre><code>那问题来了，当你运行java或者 Java 程序时使用的是哪个 JDK 呢？在 OS X 下，java也就是/usr/bin/java在默认情况下指向的是已经安装的最新版本。但是你可以设置环境变量JAVA_HOME来更改其指向：\n\n# 查看当前的java版本\n$ java -version          \njava version &quot;1.8.0_60&quot;\nJava(TM) SE Runtime Environment (build 1.8.0_60-b27)\nJava HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode)\n\n# 切换版本，可切换为第三步的本地java home中的任意一个。\n$ export JAVA_HOME=/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home java -version  \njava version &quot;1.6.0_65&quot;\nJava(TM) SE Runtime Environment (build 1.6.0_65-b14-466.1-11M4716)\nJava HotSpot(TM) 64-Bit Server VM (build 20.65-b04-466.1, mixed mode)</code></pre><h2 id=\"五-配置命令自动切换\"><a href=\"#五-配置命令自动切换\" class=\"headerlink\" title=\"五.配置命令自动切换\"></a>五.配置命令自动切换</h2><p>修改系统环境变量：</p>\n<p>在<del>/.bash_profile（如果是Zsh，修改</del>/.zshrc）文件中添加如下内容：</p>\n<pre><code># JDK 6  \nexport JAVA_6_HOME=&quot;/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home&quot;\n# JDK 8\nexport JAVA_8_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home&quot;\n\nexport JAVA_HOME=$JAVA_8_HOME #默认JDK 8\n\n#alias命令动态切换JDK版本  \nalias jdk6=&quot;export JAVA_HOME=$JAVA_6_HOME&quot;    \nalias jdk8=&quot;export JAVA_HOME=$JAVA_8_HOME&quot;  </code></pre><p>更新配置：</p>\n<pre><code>$ source ~/.bash_profile #Zsh应改为 source ~/.zshrc</code></pre><p>切换java版本：</p>\n<pre><code>$ jdk6    #使用jdk6\n$ java -version \n    java version &quot;1.6.0_65&quot;\n    Java(TM) SE Runtime Environment (build 1.6.0_65-b14-468)\n    Java HotSpot(TM) 64-Bit Server VM (build 20.65-b04-468, mixed mode)\n\n$ jdk8    #使用jdk8\n$ java -version \n    java version &quot;1.8.0_101&quot;\n    Java(TM) SE Runtime Environment (build 1.8.0_101-b13)\n    Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)\n\n说明：Mac系统的环境变量，加载顺序为：\n/etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc</code></pre><p><a href=\"https://segmentfault.com/a/1190000013131276\" target=\"_blank\" rel=\"noopener\">参考1</a><br><a href=\"https://www.kancloud.cn/kancloud/ocds-guide-to-setting-up-mac\" target=\"_blank\" rel=\"noopener\">参考2</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一-安装最新版的Java\"><a href=\"#一-安装最新版的Java\" class=\"headerlink\" title=\"一. 安装最新版的Java\"></a>一. 安装最新版的Java</h2><pre><code># 如何没有安装 brew cask。请执行    $ brew tap caskroom/versions\n$ brew cask install java</code></pre><h2 id=\"二-安装其他版本的Java\"><a href=\"#二-安装其他版本的Java\" class=\"headerlink\" title=\"二.安装其他版本的Java\"></a>二.安装其他版本的Java</h2><pre><code>如果你需要安装其他的jdk(JDK 7 或者 JDK 6)，可以使用homebrew-cask-versions：\n$ brew search java\n$ brew cask install java6      # 使用cask安装其他的工具</code></pre><h2 id=\"三-查看本地安装的Java-Home\"><a href=\"#三-查看本地安装的Java-Home\" class=\"headerlink\" title=\"三.查看本地安装的Java Home\"></a>三.查看本地安装的Java Home</h2><pre><code>$ /usr/libexec/java_home -V #查看本地安装的java版本</code></pre><h2 id=\"四-切换java版本【手动修改环境变量】\"><a href=\"#四-切换java版本【手动修改环境变量】\" class=\"headerlink\" title=\"四.切换java版本【手动修改环境变量】\"></a>四.切换java版本【手动修改环境变量】</h2><pre><code>那问题来了，当你运行java或者 Java 程序时使用的是哪个 JDK 呢？在 OS X 下，java也就是/usr/bin/java在默认情况下指向的是已经安装的最新版本。但是你可以设置环境变量JAVA_HOME来更改其指向：\n\n# 查看当前的java版本\n$ java -version          \njava version &quot;1.8.0_60&quot;\nJava(TM) SE Runtime Environment (build 1.8.0_60-b27)\nJava HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode)\n\n# 切换版本，可切换为第三步的本地java home中的任意一个。\n$ export JAVA_HOME=/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home java -version  \njava version &quot;1.6.0_65&quot;\nJava(TM) SE Runtime Environment (build 1.6.0_65-b14-466.1-11M4716)\nJava HotSpot(TM) 64-Bit Server VM (build 20.65-b04-466.1, mixed mode)</code></pre><h2 id=\"五-配置命令自动切换\"><a href=\"#五-配置命令自动切换\" class=\"headerlink\" title=\"五.配置命令自动切换\"></a>五.配置命令自动切换</h2><p>修改系统环境变量：</p>\n<p>在<del>/.bash_profile（如果是Zsh，修改</del>/.zshrc）文件中添加如下内容：</p>\n<pre><code># JDK 6  \nexport JAVA_6_HOME=&quot;/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home&quot;\n# JDK 8\nexport JAVA_8_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home&quot;\n\nexport JAVA_HOME=$JAVA_8_HOME #默认JDK 8\n\n#alias命令动态切换JDK版本  \nalias jdk6=&quot;export JAVA_HOME=$JAVA_6_HOME&quot;    \nalias jdk8=&quot;export JAVA_HOME=$JAVA_8_HOME&quot;  </code></pre><p>更新配置：</p>\n<pre><code>$ source ~/.bash_profile #Zsh应改为 source ~/.zshrc</code></pre><p>切换java版本：</p>\n<pre><code>$ jdk6    #使用jdk6\n$ java -version \n    java version &quot;1.6.0_65&quot;\n    Java(TM) SE Runtime Environment (build 1.6.0_65-b14-468)\n    Java HotSpot(TM) 64-Bit Server VM (build 20.65-b04-468, mixed mode)\n\n$ jdk8    #使用jdk8\n$ java -version \n    java version &quot;1.8.0_101&quot;\n    Java(TM) SE Runtime Environment (build 1.8.0_101-b13)\n    Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)\n\n说明：Mac系统的环境变量，加载顺序为：\n/etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc</code></pre><p><a href=\"https://segmentfault.com/a/1190000013131276\" target=\"_blank\" rel=\"noopener\">参考1</a><br><a href=\"https://www.kancloud.cn/kancloud/ocds-guide-to-setting-up-mac\" target=\"_blank\" rel=\"noopener\">参考2</a></p>\n"},{"title":"My New Post","date":"2018-04-20T02:02:54.000Z","_content":"","source":"_posts/My-New-Post.md","raw":"---\ntitle: My New Post\ndate: 2018-04-20 10:02:54\ntags:\n---\n","slug":"My-New-Post","published":1,"updated":"2019-09-27T08:27:08.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cect000mojfy6zo67dqd","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"MySQL InnoDB MRR 优化  ","date":"2019-08-19T08:37:07.000Z","_content":"\nMRR 是 Multi-Range Read 的简写，目的是减少磁盘随机访问，将随机访问转化为较为顺序的访问。适用于 range/ref/eq_ref 类型的查询。\n\n## 实现原理：\n\n1. 在二级索引查找后，根据得到的主键到聚簇索引找出需要的数据。\n\n2. 二级索引查找得到的主键的顺序是不确定的，因为二级索引的顺序与聚簇索引的顺序不一定一致；\n\n3. 如果没有 MRR，那么在聚簇索引查找时就可能出现乱序读取数据页，这对于机械硬盘是及其不友好的。\n\n4. MRR 的优化方式：\n   \n   * 将查找到的二级索引键值放在一个缓存中；\n   * 将缓存中的键值按照 主键 进行排序；\n   * 根据排序后的主键去聚簇索引访问实际的数据文件。\n\n5. 当优化器使用了 MRR 时，执行计划的 Extra 列会出现 “Using MRR” 。\n\n6. 如果查询使用的二级索引的顺序本身与结果集的顺序一致，那么使用 MRR 后需要对得到的结果集进行排序。\n\n\n## 如何使用\n使用 MRR 还可以减少缓冲池中页被替换的次数，批量处理对键值的查询操作。\n\n可以使用命令 select @@optimizer_switch; 查看是否开启了 MRR：\n\n    index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=off,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on,use_invisible_indexes=off,skip_scan=on\n\nmrr_cost_based=on 表示是否通过 cost based 的方式来选择使用 MRR 。\n\n用 set @@optimizer_switch='mrr=on/off'; 命令开启或关闭 MRR 。\n\nselect @@read_rnd_buffer_size ; 参数用来控制键值的缓冲区大小，默认 256K，当大于该参数值时，执行器根据主键对已缓存的数据进行排序，然后再通过主键取得行数据。\n\n\n\n","source":"_posts/MySQL-InnoDB-MRR-优化.md","raw":"---\ntitle: 'MySQL InnoDB MRR 优化  '\ndate: 2019-08-19 16:37:07\ntags:\n---\n\nMRR 是 Multi-Range Read 的简写，目的是减少磁盘随机访问，将随机访问转化为较为顺序的访问。适用于 range/ref/eq_ref 类型的查询。\n\n## 实现原理：\n\n1. 在二级索引查找后，根据得到的主键到聚簇索引找出需要的数据。\n\n2. 二级索引查找得到的主键的顺序是不确定的，因为二级索引的顺序与聚簇索引的顺序不一定一致；\n\n3. 如果没有 MRR，那么在聚簇索引查找时就可能出现乱序读取数据页，这对于机械硬盘是及其不友好的。\n\n4. MRR 的优化方式：\n   \n   * 将查找到的二级索引键值放在一个缓存中；\n   * 将缓存中的键值按照 主键 进行排序；\n   * 根据排序后的主键去聚簇索引访问实际的数据文件。\n\n5. 当优化器使用了 MRR 时，执行计划的 Extra 列会出现 “Using MRR” 。\n\n6. 如果查询使用的二级索引的顺序本身与结果集的顺序一致，那么使用 MRR 后需要对得到的结果集进行排序。\n\n\n## 如何使用\n使用 MRR 还可以减少缓冲池中页被替换的次数，批量处理对键值的查询操作。\n\n可以使用命令 select @@optimizer_switch; 查看是否开启了 MRR：\n\n    index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=off,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on,use_invisible_indexes=off,skip_scan=on\n\nmrr_cost_based=on 表示是否通过 cost based 的方式来选择使用 MRR 。\n\n用 set @@optimizer_switch='mrr=on/off'; 命令开启或关闭 MRR 。\n\nselect @@read_rnd_buffer_size ; 参数用来控制键值的缓冲区大小，默认 256K，当大于该参数值时，执行器根据主键对已缓存的数据进行排序，然后再通过主键取得行数据。\n\n\n\n","slug":"MySQL-InnoDB-MRR-优化","published":1,"updated":"2019-09-27T08:27:08.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecu000nojfyjbp16gxm","content":"<p>MRR 是 Multi-Range Read 的简写，目的是减少磁盘随机访问，将随机访问转化为较为顺序的访问。适用于 range/ref/eq_ref 类型的查询。</p>\n<h2 id=\"实现原理：\"><a href=\"#实现原理：\" class=\"headerlink\" title=\"实现原理：\"></a>实现原理：</h2><ol>\n<li><p>在二级索引查找后，根据得到的主键到聚簇索引找出需要的数据。</p>\n</li>\n<li><p>二级索引查找得到的主键的顺序是不确定的，因为二级索引的顺序与聚簇索引的顺序不一定一致；</p>\n</li>\n<li><p>如果没有 MRR，那么在聚簇索引查找时就可能出现乱序读取数据页，这对于机械硬盘是及其不友好的。</p>\n</li>\n<li><p>MRR 的优化方式：</p>\n<ul>\n<li>将查找到的二级索引键值放在一个缓存中；</li>\n<li>将缓存中的键值按照 主键 进行排序；</li>\n<li>根据排序后的主键去聚簇索引访问实际的数据文件。</li>\n</ul>\n</li>\n<li><p>当优化器使用了 MRR 时，执行计划的 Extra 列会出现 “Using MRR” 。</p>\n</li>\n<li><p>如果查询使用的二级索引的顺序本身与结果集的顺序一致，那么使用 MRR 后需要对得到的结果集进行排序。</p>\n</li>\n</ol>\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><p>使用 MRR 还可以减少缓冲池中页被替换的次数，批量处理对键值的查询操作。</p>\n<p>可以使用命令 select @@optimizer_switch; 查看是否开启了 MRR：</p>\n<pre><code>index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=off,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on,use_invisible_indexes=off,skip_scan=on</code></pre><p>mrr_cost_based=on 表示是否通过 cost based 的方式来选择使用 MRR 。</p>\n<p>用 set @@optimizer_switch=’mrr=on/off’; 命令开启或关闭 MRR 。</p>\n<p>select @@read_rnd_buffer_size ; 参数用来控制键值的缓冲区大小，默认 256K，当大于该参数值时，执行器根据主键对已缓存的数据进行排序，然后再通过主键取得行数据。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>MRR 是 Multi-Range Read 的简写，目的是减少磁盘随机访问，将随机访问转化为较为顺序的访问。适用于 range/ref/eq_ref 类型的查询。</p>\n<h2 id=\"实现原理：\"><a href=\"#实现原理：\" class=\"headerlink\" title=\"实现原理：\"></a>实现原理：</h2><ol>\n<li><p>在二级索引查找后，根据得到的主键到聚簇索引找出需要的数据。</p>\n</li>\n<li><p>二级索引查找得到的主键的顺序是不确定的，因为二级索引的顺序与聚簇索引的顺序不一定一致；</p>\n</li>\n<li><p>如果没有 MRR，那么在聚簇索引查找时就可能出现乱序读取数据页，这对于机械硬盘是及其不友好的。</p>\n</li>\n<li><p>MRR 的优化方式：</p>\n<ul>\n<li>将查找到的二级索引键值放在一个缓存中；</li>\n<li>将缓存中的键值按照 主键 进行排序；</li>\n<li>根据排序后的主键去聚簇索引访问实际的数据文件。</li>\n</ul>\n</li>\n<li><p>当优化器使用了 MRR 时，执行计划的 Extra 列会出现 “Using MRR” 。</p>\n</li>\n<li><p>如果查询使用的二级索引的顺序本身与结果集的顺序一致，那么使用 MRR 后需要对得到的结果集进行排序。</p>\n</li>\n</ol>\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><p>使用 MRR 还可以减少缓冲池中页被替换的次数，批量处理对键值的查询操作。</p>\n<p>可以使用命令 select @@optimizer_switch; 查看是否开启了 MRR：</p>\n<pre><code>index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=off,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on,use_invisible_indexes=off,skip_scan=on</code></pre><p>mrr_cost_based=on 表示是否通过 cost based 的方式来选择使用 MRR 。</p>\n<p>用 set @@optimizer_switch=’mrr=on/off’; 命令开启或关闭 MRR 。</p>\n<p>select @@read_rnd_buffer_size ; 参数用来控制键值的缓冲区大小，默认 256K，当大于该参数值时，执行器根据主键对已缓存的数据进行排序，然后再通过主键取得行数据。</p>\n"},{"title":"Laravel学习笔记","date":"2019-02-22T06:43:53.000Z","_content":"\n## 阅读文档官方文档(本文以5.7为例)\n[Laravel文档]('https://laravel.com/docs/5.7')\n\n## 安装环境(Laravel Homestead)\n[Laravel Homestead文档](https://laravel.com/docs/5.7/homestead)","source":"_posts/Laravel学习笔记.md","raw":"---\ntitle: Laravel学习笔记\ndate: 2019-02-22 14:43:53\ntags: [laravel]\ncategories: \n- php\n---\n\n## 阅读文档官方文档(本文以5.7为例)\n[Laravel文档]('https://laravel.com/docs/5.7')\n\n## 安装环境(Laravel Homestead)\n[Laravel Homestead文档](https://laravel.com/docs/5.7/homestead)","slug":"Laravel学习笔记","published":1,"updated":"2019-09-27T08:27:08.026Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecu000oojfys3hazmvn","content":"<h2 id=\"阅读文档官方文档-本文以5-7为例\"><a href=\"#阅读文档官方文档-本文以5-7为例\" class=\"headerlink\" title=\"阅读文档官方文档(本文以5.7为例)\"></a>阅读文档官方文档(本文以5.7为例)</h2><p><a href=\"'https://laravel.com/docs/5.7'\">Laravel文档</a></p>\n<h2 id=\"安装环境-Laravel-Homestead\"><a href=\"#安装环境-Laravel-Homestead\" class=\"headerlink\" title=\"安装环境(Laravel Homestead)\"></a>安装环境(Laravel Homestead)</h2><p><a href=\"https://laravel.com/docs/5.7/homestead\" target=\"_blank\" rel=\"noopener\">Laravel Homestead文档</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"阅读文档官方文档-本文以5-7为例\"><a href=\"#阅读文档官方文档-本文以5-7为例\" class=\"headerlink\" title=\"阅读文档官方文档(本文以5.7为例)\"></a>阅读文档官方文档(本文以5.7为例)</h2><p><a href=\"'https://laravel.com/docs/5.7'\">Laravel文档</a></p>\n<h2 id=\"安装环境-Laravel-Homestead\"><a href=\"#安装环境-Laravel-Homestead\" class=\"headerlink\" title=\"安装环境(Laravel Homestead)\"></a>安装环境(Laravel Homestead)</h2><p><a href=\"https://laravel.com/docs/5.7/homestead\" target=\"_blank\" rel=\"noopener\">Laravel Homestead文档</a></p>\n"},{"title":"MySQL创建用户与授权  ","date":"2019-09-12T08:10:52.000Z","_content":"\n# 一. 创建用户\n\n## 命令\n    CREATE USER 'username'@'host' IDENTIFIED BY 'password';\n    \n## 说明：\n* username：你将创建的用户名\n* host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%\n* password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器\n\n## 例子：\n\n    CREATE USER 'dog'@'localhost' IDENTIFIED BY '123456';\n    CREATE USER 'pig'@'192.168.1.101_' IDENDIFIED BY '123456';\n    CREATE USER 'pig'@'%' IDENTIFIED BY '123456';\n    CREATE USER 'pig'@'%' IDENTIFIED BY '';\n    CREATE USER 'pig'@'%';\n\n# 二. 授权:\n\n## 命令:\n    \n    GRANT privileges ON databasename.tablename TO 'username'@'host'\n\n## 说明:\n    \n* privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL\n* databasename：数据库名\n* tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用*表示，如*.*\n\n## 例子:\n    \n    GRANT SELECT, INSERT ON test.user TO 'pig'@'%';\n    GRANT ALL ON *.* TO 'pig'@'%';\n            \n注意:\n用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:\n    \n    GRANT privileges ON databasename.tablename TO 'username'@'host' WITH GRANT OPTION;\n            \n# 三.设置与更改用户密码\n   命令:\n   \n    SET PASSWORD FOR 'username'@'host' = PASSWORD('newpassword');\n \n 如果是当前登陆用户用:\n \n    SET PASSWORD = PASSWORD(\"newpassword\");\n例子:\n    \n    SET PASSWORD FOR 'pig'@'%' = PASSWORD(\"123456\");\n\n# 四. 撤销用户权限\n命令:\n\n    REVOKE privilege ON databasename.tablename FROM 'username'@'host';\n说明:\nprivilege, databasename, tablename：同授权部分\n\n例子:\n\n    REVOKE SELECT ON *.* FROM 'pig'@'%';\n\n注意:\n\n假如你在给用户'pig'@'%'授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO 'pig'@'%'，则在使用REVOKE SELECT ON *.* FROM 'pig'@'%';命令并不能撤销该用户对test数据库中user表的SELECT 操作。相反，如果授权使用的是GRANT SELECT ON *.* TO 'pig'@'%';则REVOKE SELECT ON test.user FROM 'pig'@'%';命令也不能撤销该用户对test数据库中user表的Select权限。\n\n具体信息可以用命令SHOW GRANTS FOR 'pig'@'%'; 查看。\n\n# 五.删除用户\n\n    DROP USER 'username'@'host';\n\n[摘抄自](https://www.jianshu.com/p/d7b9c468f20d)\n","source":"_posts/MySQL创建用户与授权.md","raw":"---\ntitle: 'MySQL创建用户与授权  '\ndate: 2019-09-12 16:10:52\ntags: [mysql]\ncategories: [mysql]\n---\n\n# 一. 创建用户\n\n## 命令\n    CREATE USER 'username'@'host' IDENTIFIED BY 'password';\n    \n## 说明：\n* username：你将创建的用户名\n* host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%\n* password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器\n\n## 例子：\n\n    CREATE USER 'dog'@'localhost' IDENTIFIED BY '123456';\n    CREATE USER 'pig'@'192.168.1.101_' IDENDIFIED BY '123456';\n    CREATE USER 'pig'@'%' IDENTIFIED BY '123456';\n    CREATE USER 'pig'@'%' IDENTIFIED BY '';\n    CREATE USER 'pig'@'%';\n\n# 二. 授权:\n\n## 命令:\n    \n    GRANT privileges ON databasename.tablename TO 'username'@'host'\n\n## 说明:\n    \n* privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL\n* databasename：数据库名\n* tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用*表示，如*.*\n\n## 例子:\n    \n    GRANT SELECT, INSERT ON test.user TO 'pig'@'%';\n    GRANT ALL ON *.* TO 'pig'@'%';\n            \n注意:\n用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:\n    \n    GRANT privileges ON databasename.tablename TO 'username'@'host' WITH GRANT OPTION;\n            \n# 三.设置与更改用户密码\n   命令:\n   \n    SET PASSWORD FOR 'username'@'host' = PASSWORD('newpassword');\n \n 如果是当前登陆用户用:\n \n    SET PASSWORD = PASSWORD(\"newpassword\");\n例子:\n    \n    SET PASSWORD FOR 'pig'@'%' = PASSWORD(\"123456\");\n\n# 四. 撤销用户权限\n命令:\n\n    REVOKE privilege ON databasename.tablename FROM 'username'@'host';\n说明:\nprivilege, databasename, tablename：同授权部分\n\n例子:\n\n    REVOKE SELECT ON *.* FROM 'pig'@'%';\n\n注意:\n\n假如你在给用户'pig'@'%'授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO 'pig'@'%'，则在使用REVOKE SELECT ON *.* FROM 'pig'@'%';命令并不能撤销该用户对test数据库中user表的SELECT 操作。相反，如果授权使用的是GRANT SELECT ON *.* TO 'pig'@'%';则REVOKE SELECT ON test.user FROM 'pig'@'%';命令也不能撤销该用户对test数据库中user表的Select权限。\n\n具体信息可以用命令SHOW GRANTS FOR 'pig'@'%'; 查看。\n\n# 五.删除用户\n\n    DROP USER 'username'@'host';\n\n[摘抄自](https://www.jianshu.com/p/d7b9c468f20d)\n","slug":"MySQL创建用户与授权","published":1,"updated":"2019-09-27T08:27:08.032Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecv000pojfy2mt2fwh8","content":"<h1 id=\"一-创建用户\"><a href=\"#一-创建用户\" class=\"headerlink\" title=\"一. 创建用户\"></a>一. 创建用户</h1><h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><pre><code>CREATE USER &apos;username&apos;@&apos;host&apos; IDENTIFIED BY &apos;password&apos;;</code></pre><h2 id=\"说明：\"><a href=\"#说明：\" class=\"headerlink\" title=\"说明：\"></a>说明：</h2><ul>\n<li>username：你将创建的用户名</li>\n<li>host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%</li>\n<li>password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</li>\n</ul>\n<h2 id=\"例子：\"><a href=\"#例子：\" class=\"headerlink\" title=\"例子：\"></a>例子：</h2><pre><code>CREATE USER &apos;dog&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;;\nCREATE USER &apos;pig&apos;@&apos;192.168.1.101_&apos; IDENDIFIED BY &apos;123456&apos;;\nCREATE USER &apos;pig&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;\nCREATE USER &apos;pig&apos;@&apos;%&apos; IDENTIFIED BY &apos;&apos;;\nCREATE USER &apos;pig&apos;@&apos;%&apos;;</code></pre><h1 id=\"二-授权\"><a href=\"#二-授权\" class=\"headerlink\" title=\"二. 授权:\"></a>二. 授权:</h1><h2 id=\"命令-1\"><a href=\"#命令-1\" class=\"headerlink\" title=\"命令:\"></a>命令:</h2><pre><code>GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos;</code></pre><h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h2><ul>\n<li>privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL</li>\n<li>databasename：数据库名</li>\n<li>tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<em>表示，如</em>.*</li>\n</ul>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子:\"></a>例子:</h2><pre><code>GRANT SELECT, INSERT ON test.user TO &apos;pig&apos;@&apos;%&apos;;\nGRANT ALL ON *.* TO &apos;pig&apos;@&apos;%&apos;;</code></pre><p>注意:<br>用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:</p>\n<pre><code>GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos; WITH GRANT OPTION;</code></pre><h1 id=\"三-设置与更改用户密码\"><a href=\"#三-设置与更改用户密码\" class=\"headerlink\" title=\"三.设置与更改用户密码\"></a>三.设置与更改用户密码</h1><p>   命令:</p>\n<pre><code>SET PASSWORD FOR &apos;username&apos;@&apos;host&apos; = PASSWORD(&apos;newpassword&apos;);</code></pre><p> 如果是当前登陆用户用:</p>\n<pre><code>SET PASSWORD = PASSWORD(&quot;newpassword&quot;);</code></pre><p>例子:</p>\n<pre><code>SET PASSWORD FOR &apos;pig&apos;@&apos;%&apos; = PASSWORD(&quot;123456&quot;);</code></pre><h1 id=\"四-撤销用户权限\"><a href=\"#四-撤销用户权限\" class=\"headerlink\" title=\"四. 撤销用户权限\"></a>四. 撤销用户权限</h1><p>命令:</p>\n<pre><code>REVOKE privilege ON databasename.tablename FROM &apos;username&apos;@&apos;host&apos;;</code></pre><p>说明:<br>privilege, databasename, tablename：同授权部分</p>\n<p>例子:</p>\n<pre><code>REVOKE SELECT ON *.* FROM &apos;pig&apos;@&apos;%&apos;;</code></pre><p>注意:</p>\n<p>假如你在给用户‘pig’@’%’授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO ‘pig’@’%’，则在使用REVOKE SELECT ON <em>.</em> FROM ‘pig’@’%’;命令并不能撤销该用户对test数据库中user表的SELECT 操作。相反，如果授权使用的是GRANT SELECT ON <em>.</em> TO ‘pig’@’%’;则REVOKE SELECT ON test.user FROM ‘pig’@’%’;命令也不能撤销该用户对test数据库中user表的Select权限。</p>\n<p>具体信息可以用命令SHOW GRANTS FOR ‘pig’@’%’; 查看。</p>\n<h1 id=\"五-删除用户\"><a href=\"#五-删除用户\" class=\"headerlink\" title=\"五.删除用户\"></a>五.删除用户</h1><pre><code>DROP USER &apos;username&apos;@&apos;host&apos;;</code></pre><p><a href=\"https://www.jianshu.com/p/d7b9c468f20d\" target=\"_blank\" rel=\"noopener\">摘抄自</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一-创建用户\"><a href=\"#一-创建用户\" class=\"headerlink\" title=\"一. 创建用户\"></a>一. 创建用户</h1><h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><pre><code>CREATE USER &apos;username&apos;@&apos;host&apos; IDENTIFIED BY &apos;password&apos;;</code></pre><h2 id=\"说明：\"><a href=\"#说明：\" class=\"headerlink\" title=\"说明：\"></a>说明：</h2><ul>\n<li>username：你将创建的用户名</li>\n<li>host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%</li>\n<li>password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</li>\n</ul>\n<h2 id=\"例子：\"><a href=\"#例子：\" class=\"headerlink\" title=\"例子：\"></a>例子：</h2><pre><code>CREATE USER &apos;dog&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;;\nCREATE USER &apos;pig&apos;@&apos;192.168.1.101_&apos; IDENDIFIED BY &apos;123456&apos;;\nCREATE USER &apos;pig&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;\nCREATE USER &apos;pig&apos;@&apos;%&apos; IDENTIFIED BY &apos;&apos;;\nCREATE USER &apos;pig&apos;@&apos;%&apos;;</code></pre><h1 id=\"二-授权\"><a href=\"#二-授权\" class=\"headerlink\" title=\"二. 授权:\"></a>二. 授权:</h1><h2 id=\"命令-1\"><a href=\"#命令-1\" class=\"headerlink\" title=\"命令:\"></a>命令:</h2><pre><code>GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos;</code></pre><h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h2><ul>\n<li>privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL</li>\n<li>databasename：数据库名</li>\n<li>tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<em>表示，如</em>.*</li>\n</ul>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子:\"></a>例子:</h2><pre><code>GRANT SELECT, INSERT ON test.user TO &apos;pig&apos;@&apos;%&apos;;\nGRANT ALL ON *.* TO &apos;pig&apos;@&apos;%&apos;;</code></pre><p>注意:<br>用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:</p>\n<pre><code>GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos; WITH GRANT OPTION;</code></pre><h1 id=\"三-设置与更改用户密码\"><a href=\"#三-设置与更改用户密码\" class=\"headerlink\" title=\"三.设置与更改用户密码\"></a>三.设置与更改用户密码</h1><p>   命令:</p>\n<pre><code>SET PASSWORD FOR &apos;username&apos;@&apos;host&apos; = PASSWORD(&apos;newpassword&apos;);</code></pre><p> 如果是当前登陆用户用:</p>\n<pre><code>SET PASSWORD = PASSWORD(&quot;newpassword&quot;);</code></pre><p>例子:</p>\n<pre><code>SET PASSWORD FOR &apos;pig&apos;@&apos;%&apos; = PASSWORD(&quot;123456&quot;);</code></pre><h1 id=\"四-撤销用户权限\"><a href=\"#四-撤销用户权限\" class=\"headerlink\" title=\"四. 撤销用户权限\"></a>四. 撤销用户权限</h1><p>命令:</p>\n<pre><code>REVOKE privilege ON databasename.tablename FROM &apos;username&apos;@&apos;host&apos;;</code></pre><p>说明:<br>privilege, databasename, tablename：同授权部分</p>\n<p>例子:</p>\n<pre><code>REVOKE SELECT ON *.* FROM &apos;pig&apos;@&apos;%&apos;;</code></pre><p>注意:</p>\n<p>假如你在给用户‘pig’@’%’授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO ‘pig’@’%’，则在使用REVOKE SELECT ON <em>.</em> FROM ‘pig’@’%’;命令并不能撤销该用户对test数据库中user表的SELECT 操作。相反，如果授权使用的是GRANT SELECT ON <em>.</em> TO ‘pig’@’%’;则REVOKE SELECT ON test.user FROM ‘pig’@’%’;命令也不能撤销该用户对test数据库中user表的Select权限。</p>\n<p>具体信息可以用命令SHOW GRANTS FOR ‘pig’@’%’; 查看。</p>\n<h1 id=\"五-删除用户\"><a href=\"#五-删除用户\" class=\"headerlink\" title=\"五.删除用户\"></a>五.删除用户</h1><pre><code>DROP USER &apos;username&apos;@&apos;host&apos;;</code></pre><p><a href=\"https://www.jianshu.com/p/d7b9c468f20d\" target=\"_blank\" rel=\"noopener\">摘抄自</a></p>\n"},{"title":"Spring Boot 核心注解","date":"2019-09-25T06:00:45.000Z","_content":"\n# 问题：\n\n我看你上面写了熟悉 Spring Boot，那你能讲下为什么我们要用 Spring Boot 吗？\n\n# 下面我列几个最常见的三个回答：\n\n## A：Spring Boot 最主要是不用 XML 配置，可以用 Java 来配置 bean，省去了许多配置文件。\n\n我又问：Spring 本身就可以用 Java 配置代替 XML 配置，和 Spring Boot 有什么关系呢？\n\n然后对方就吱吱唔唔了……\n\n## B：Spring Boot 我们用来做 Spring Cloud 微服务。\n\n我又问：微服务和 Spring Boot 有什么关系？不用 Spring Boot 行不行？\n\n然后对方就吱吱唔唔了……\n\n## C：Spring Boot 可以打 jar 包部署，内部集成了Tomcat。\n\n这个确实是 Spring Boot 的特色，但是我还是觉得没有答到关键点上。\n\n然后我继续问，如果不考虑打 jar 包部署呢，然后就没然后了……\n\n# 为什么我们要用 Spring Boot，显然上面三个求职者没有答到关键点上，Spring Boot 最重要的功能是：自动配置。\n\n## 为什么说是自动配置？\n\nSpring Boot 的开启注解是：@SpringBootApplication，其实它就是由下面三个注解组成的：\n\n     @Configuration\n     @ComponentScan\n     @EnableAutoConfiguration\n上面三个注解，前面两个都是 Spring 自带的，和 Spring Boot 无关，所以说上面的回答的不是在点上。\n\n所以说 Spring Boot 最最核心的就是这个 **@EnableAutoConfiguration** 注解了，它能根据类路径下的 jar 包和配置动态加载配置和注入bean。\n\n举个例子，比如我在 lib 下放一个 druid 连接池的 jar 包，然后在 application.yml 文件配置 druid 相关的参数，Spring Boot 就能够自动配置所有我们需要的东西，如果我把 jar 包拿掉或者把参数去掉，那 Spring Boot 就不会自动配置。\n\n这样我们就能把许多功能做成公共的自动配置的启动器（starters），其实 druid 连接池就是这么做的，它提供了针对 Spring Boot 的启动器：druid-spring-boot-starter。\n\n有了这个自动配置的启动器，我们就能非常简单的使用它，\n\n先添加 jar 包依赖：\n\n    <dependency>\n       <groupId>com.alibaba</groupId>\n       <artifactId>druid-spring-boot-starter</artifactId>\n       <version>1.1.10</version>\n    </dependency>    \n\n再添加相关参数：\n\n    spring.datasource.url= \n    spring.datasource.username=\n    spring.datasource.password=\n    ……\n如果是传统的项目，我们要自己手动写一大堆的配置，而且还不灵活，有了这个启动器，我们就可以做到简单集成。具体大家可以看 druid-spring-boot-starter 是怎么实现的。\n\n所以，这才是 Spring Boot 的核心，这才是我们为什么使用 Spring Boot 的原因。如果答不到这个关键点，那真没有掌握到 Spring Boot 的核心所在。\n","source":"_posts/Spring-Boot-核心注解.md","raw":"---\ntitle: Spring Boot 核心注解\ndate: 2019-09-25 14:00:45\ntags: [Spring,java]\ncategories: [Java]\n---\n\n# 问题：\n\n我看你上面写了熟悉 Spring Boot，那你能讲下为什么我们要用 Spring Boot 吗？\n\n# 下面我列几个最常见的三个回答：\n\n## A：Spring Boot 最主要是不用 XML 配置，可以用 Java 来配置 bean，省去了许多配置文件。\n\n我又问：Spring 本身就可以用 Java 配置代替 XML 配置，和 Spring Boot 有什么关系呢？\n\n然后对方就吱吱唔唔了……\n\n## B：Spring Boot 我们用来做 Spring Cloud 微服务。\n\n我又问：微服务和 Spring Boot 有什么关系？不用 Spring Boot 行不行？\n\n然后对方就吱吱唔唔了……\n\n## C：Spring Boot 可以打 jar 包部署，内部集成了Tomcat。\n\n这个确实是 Spring Boot 的特色，但是我还是觉得没有答到关键点上。\n\n然后我继续问，如果不考虑打 jar 包部署呢，然后就没然后了……\n\n# 为什么我们要用 Spring Boot，显然上面三个求职者没有答到关键点上，Spring Boot 最重要的功能是：自动配置。\n\n## 为什么说是自动配置？\n\nSpring Boot 的开启注解是：@SpringBootApplication，其实它就是由下面三个注解组成的：\n\n     @Configuration\n     @ComponentScan\n     @EnableAutoConfiguration\n上面三个注解，前面两个都是 Spring 自带的，和 Spring Boot 无关，所以说上面的回答的不是在点上。\n\n所以说 Spring Boot 最最核心的就是这个 **@EnableAutoConfiguration** 注解了，它能根据类路径下的 jar 包和配置动态加载配置和注入bean。\n\n举个例子，比如我在 lib 下放一个 druid 连接池的 jar 包，然后在 application.yml 文件配置 druid 相关的参数，Spring Boot 就能够自动配置所有我们需要的东西，如果我把 jar 包拿掉或者把参数去掉，那 Spring Boot 就不会自动配置。\n\n这样我们就能把许多功能做成公共的自动配置的启动器（starters），其实 druid 连接池就是这么做的，它提供了针对 Spring Boot 的启动器：druid-spring-boot-starter。\n\n有了这个自动配置的启动器，我们就能非常简单的使用它，\n\n先添加 jar 包依赖：\n\n    <dependency>\n       <groupId>com.alibaba</groupId>\n       <artifactId>druid-spring-boot-starter</artifactId>\n       <version>1.1.10</version>\n    </dependency>    \n\n再添加相关参数：\n\n    spring.datasource.url= \n    spring.datasource.username=\n    spring.datasource.password=\n    ……\n如果是传统的项目，我们要自己手动写一大堆的配置，而且还不灵活，有了这个启动器，我们就可以做到简单集成。具体大家可以看 druid-spring-boot-starter 是怎么实现的。\n\n所以，这才是 Spring Boot 的核心，这才是我们为什么使用 Spring Boot 的原因。如果答不到这个关键点，那真没有掌握到 Spring Boot 的核心所在。\n","slug":"Spring-Boot-核心注解","published":1,"updated":"2019-09-27T08:27:08.032Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecv000qojfyksibevzk","content":"<h1 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h1><p>我看你上面写了熟悉 Spring Boot，那你能讲下为什么我们要用 Spring Boot 吗？</p>\n<h1 id=\"下面我列几个最常见的三个回答：\"><a href=\"#下面我列几个最常见的三个回答：\" class=\"headerlink\" title=\"下面我列几个最常见的三个回答：\"></a>下面我列几个最常见的三个回答：</h1><h2 id=\"A：Spring-Boot-最主要是不用-XML-配置，可以用-Java-来配置-bean，省去了许多配置文件。\"><a href=\"#A：Spring-Boot-最主要是不用-XML-配置，可以用-Java-来配置-bean，省去了许多配置文件。\" class=\"headerlink\" title=\"A：Spring Boot 最主要是不用 XML 配置，可以用 Java 来配置 bean，省去了许多配置文件。\"></a>A：Spring Boot 最主要是不用 XML 配置，可以用 Java 来配置 bean，省去了许多配置文件。</h2><p>我又问：Spring 本身就可以用 Java 配置代替 XML 配置，和 Spring Boot 有什么关系呢？</p>\n<p>然后对方就吱吱唔唔了……</p>\n<h2 id=\"B：Spring-Boot-我们用来做-Spring-Cloud-微服务。\"><a href=\"#B：Spring-Boot-我们用来做-Spring-Cloud-微服务。\" class=\"headerlink\" title=\"B：Spring Boot 我们用来做 Spring Cloud 微服务。\"></a>B：Spring Boot 我们用来做 Spring Cloud 微服务。</h2><p>我又问：微服务和 Spring Boot 有什么关系？不用 Spring Boot 行不行？</p>\n<p>然后对方就吱吱唔唔了……</p>\n<h2 id=\"C：Spring-Boot-可以打-jar-包部署，内部集成了Tomcat。\"><a href=\"#C：Spring-Boot-可以打-jar-包部署，内部集成了Tomcat。\" class=\"headerlink\" title=\"C：Spring Boot 可以打 jar 包部署，内部集成了Tomcat。\"></a>C：Spring Boot 可以打 jar 包部署，内部集成了Tomcat。</h2><p>这个确实是 Spring Boot 的特色，但是我还是觉得没有答到关键点上。</p>\n<p>然后我继续问，如果不考虑打 jar 包部署呢，然后就没然后了……</p>\n<h1 id=\"为什么我们要用-Spring-Boot，显然上面三个求职者没有答到关键点上，Spring-Boot-最重要的功能是：自动配置。\"><a href=\"#为什么我们要用-Spring-Boot，显然上面三个求职者没有答到关键点上，Spring-Boot-最重要的功能是：自动配置。\" class=\"headerlink\" title=\"为什么我们要用 Spring Boot，显然上面三个求职者没有答到关键点上，Spring Boot 最重要的功能是：自动配置。\"></a>为什么我们要用 Spring Boot，显然上面三个求职者没有答到关键点上，Spring Boot 最重要的功能是：自动配置。</h1><h2 id=\"为什么说是自动配置？\"><a href=\"#为什么说是自动配置？\" class=\"headerlink\" title=\"为什么说是自动配置？\"></a>为什么说是自动配置？</h2><p>Spring Boot 的开启注解是：@SpringBootApplication，其实它就是由下面三个注解组成的：</p>\n<pre><code>@Configuration\n@ComponentScan\n@EnableAutoConfiguration</code></pre><p>上面三个注解，前面两个都是 Spring 自带的，和 Spring Boot 无关，所以说上面的回答的不是在点上。</p>\n<p>所以说 Spring Boot 最最核心的就是这个 <strong>@EnableAutoConfiguration</strong> 注解了，它能根据类路径下的 jar 包和配置动态加载配置和注入bean。</p>\n<p>举个例子，比如我在 lib 下放一个 druid 连接池的 jar 包，然后在 application.yml 文件配置 druid 相关的参数，Spring Boot 就能够自动配置所有我们需要的东西，如果我把 jar 包拿掉或者把参数去掉，那 Spring Boot 就不会自动配置。</p>\n<p>这样我们就能把许多功能做成公共的自动配置的启动器（starters），其实 druid 连接池就是这么做的，它提供了针对 Spring Boot 的启动器：druid-spring-boot-starter。</p>\n<p>有了这个自动配置的启动器，我们就能非常简单的使用它，</p>\n<p>先添加 jar 包依赖：</p>\n<pre><code>&lt;dependency&gt;\n   &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n   &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;\n   &lt;version&gt;1.1.10&lt;/version&gt;\n&lt;/dependency&gt;    </code></pre><p>再添加相关参数：</p>\n<pre><code>spring.datasource.url= \nspring.datasource.username=\nspring.datasource.password=\n……</code></pre><p>如果是传统的项目，我们要自己手动写一大堆的配置，而且还不灵活，有了这个启动器，我们就可以做到简单集成。具体大家可以看 druid-spring-boot-starter 是怎么实现的。</p>\n<p>所以，这才是 Spring Boot 的核心，这才是我们为什么使用 Spring Boot 的原因。如果答不到这个关键点，那真没有掌握到 Spring Boot 的核心所在。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h1><p>我看你上面写了熟悉 Spring Boot，那你能讲下为什么我们要用 Spring Boot 吗？</p>\n<h1 id=\"下面我列几个最常见的三个回答：\"><a href=\"#下面我列几个最常见的三个回答：\" class=\"headerlink\" title=\"下面我列几个最常见的三个回答：\"></a>下面我列几个最常见的三个回答：</h1><h2 id=\"A：Spring-Boot-最主要是不用-XML-配置，可以用-Java-来配置-bean，省去了许多配置文件。\"><a href=\"#A：Spring-Boot-最主要是不用-XML-配置，可以用-Java-来配置-bean，省去了许多配置文件。\" class=\"headerlink\" title=\"A：Spring Boot 最主要是不用 XML 配置，可以用 Java 来配置 bean，省去了许多配置文件。\"></a>A：Spring Boot 最主要是不用 XML 配置，可以用 Java 来配置 bean，省去了许多配置文件。</h2><p>我又问：Spring 本身就可以用 Java 配置代替 XML 配置，和 Spring Boot 有什么关系呢？</p>\n<p>然后对方就吱吱唔唔了……</p>\n<h2 id=\"B：Spring-Boot-我们用来做-Spring-Cloud-微服务。\"><a href=\"#B：Spring-Boot-我们用来做-Spring-Cloud-微服务。\" class=\"headerlink\" title=\"B：Spring Boot 我们用来做 Spring Cloud 微服务。\"></a>B：Spring Boot 我们用来做 Spring Cloud 微服务。</h2><p>我又问：微服务和 Spring Boot 有什么关系？不用 Spring Boot 行不行？</p>\n<p>然后对方就吱吱唔唔了……</p>\n<h2 id=\"C：Spring-Boot-可以打-jar-包部署，内部集成了Tomcat。\"><a href=\"#C：Spring-Boot-可以打-jar-包部署，内部集成了Tomcat。\" class=\"headerlink\" title=\"C：Spring Boot 可以打 jar 包部署，内部集成了Tomcat。\"></a>C：Spring Boot 可以打 jar 包部署，内部集成了Tomcat。</h2><p>这个确实是 Spring Boot 的特色，但是我还是觉得没有答到关键点上。</p>\n<p>然后我继续问，如果不考虑打 jar 包部署呢，然后就没然后了……</p>\n<h1 id=\"为什么我们要用-Spring-Boot，显然上面三个求职者没有答到关键点上，Spring-Boot-最重要的功能是：自动配置。\"><a href=\"#为什么我们要用-Spring-Boot，显然上面三个求职者没有答到关键点上，Spring-Boot-最重要的功能是：自动配置。\" class=\"headerlink\" title=\"为什么我们要用 Spring Boot，显然上面三个求职者没有答到关键点上，Spring Boot 最重要的功能是：自动配置。\"></a>为什么我们要用 Spring Boot，显然上面三个求职者没有答到关键点上，Spring Boot 最重要的功能是：自动配置。</h1><h2 id=\"为什么说是自动配置？\"><a href=\"#为什么说是自动配置？\" class=\"headerlink\" title=\"为什么说是自动配置？\"></a>为什么说是自动配置？</h2><p>Spring Boot 的开启注解是：@SpringBootApplication，其实它就是由下面三个注解组成的：</p>\n<pre><code>@Configuration\n@ComponentScan\n@EnableAutoConfiguration</code></pre><p>上面三个注解，前面两个都是 Spring 自带的，和 Spring Boot 无关，所以说上面的回答的不是在点上。</p>\n<p>所以说 Spring Boot 最最核心的就是这个 <strong>@EnableAutoConfiguration</strong> 注解了，它能根据类路径下的 jar 包和配置动态加载配置和注入bean。</p>\n<p>举个例子，比如我在 lib 下放一个 druid 连接池的 jar 包，然后在 application.yml 文件配置 druid 相关的参数，Spring Boot 就能够自动配置所有我们需要的东西，如果我把 jar 包拿掉或者把参数去掉，那 Spring Boot 就不会自动配置。</p>\n<p>这样我们就能把许多功能做成公共的自动配置的启动器（starters），其实 druid 连接池就是这么做的，它提供了针对 Spring Boot 的启动器：druid-spring-boot-starter。</p>\n<p>有了这个自动配置的启动器，我们就能非常简单的使用它，</p>\n<p>先添加 jar 包依赖：</p>\n<pre><code>&lt;dependency&gt;\n   &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n   &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;\n   &lt;version&gt;1.1.10&lt;/version&gt;\n&lt;/dependency&gt;    </code></pre><p>再添加相关参数：</p>\n<pre><code>spring.datasource.url= \nspring.datasource.username=\nspring.datasource.password=\n……</code></pre><p>如果是传统的项目，我们要自己手动写一大堆的配置，而且还不灵活，有了这个启动器，我们就可以做到简单集成。具体大家可以看 druid-spring-boot-starter 是怎么实现的。</p>\n<p>所以，这才是 Spring Boot 的核心，这才是我们为什么使用 Spring Boot 的原因。如果答不到这个关键点，那真没有掌握到 Spring Boot 的核心所在。</p>\n"},{"title":"Ubuntu 远程连接22端口","date":"2018-04-23T02:12:42.000Z","_content":"\n## 安装OpenSSH\n\n### Ubuntu缺省没有安装SSH Server,使用以下命令安装:\n\n### sudo apt-get install openssh-server openssh-client\n\n### 配置完成后重启命令\n\n### sudo /etc/init.d/ssh restart\n","source":"_posts/Ubuntu-远程连接22端口.md","raw":"---\ntitle: Ubuntu 远程连接22端口\ndate: 2018-04-23 10:12:42\ntags: Linux\ncategories: \n- linux\n---\n\n## 安装OpenSSH\n\n### Ubuntu缺省没有安装SSH Server,使用以下命令安装:\n\n### sudo apt-get install openssh-server openssh-client\n\n### 配置完成后重启命令\n\n### sudo /etc/init.d/ssh restart\n","slug":"Ubuntu-远程连接22端口","published":1,"updated":"2019-09-27T08:27:08.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecw000rojfymftcuyiq","content":"<h2 id=\"安装OpenSSH\"><a href=\"#安装OpenSSH\" class=\"headerlink\" title=\"安装OpenSSH\"></a>安装OpenSSH</h2><h3 id=\"Ubuntu缺省没有安装SSH-Server-使用以下命令安装\"><a href=\"#Ubuntu缺省没有安装SSH-Server-使用以下命令安装\" class=\"headerlink\" title=\"Ubuntu缺省没有安装SSH Server,使用以下命令安装:\"></a>Ubuntu缺省没有安装SSH Server,使用以下命令安装:</h3><h3 id=\"sudo-apt-get-install-openssh-server-openssh-client\"><a href=\"#sudo-apt-get-install-openssh-server-openssh-client\" class=\"headerlink\" title=\"sudo apt-get install openssh-server openssh-client\"></a>sudo apt-get install openssh-server openssh-client</h3><h3 id=\"配置完成后重启命令\"><a href=\"#配置完成后重启命令\" class=\"headerlink\" title=\"配置完成后重启命令\"></a>配置完成后重启命令</h3><h3 id=\"sudo-etc-init-d-ssh-restart\"><a href=\"#sudo-etc-init-d-ssh-restart\" class=\"headerlink\" title=\"sudo /etc/init.d/ssh restart\"></a>sudo /etc/init.d/ssh restart</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"安装OpenSSH\"><a href=\"#安装OpenSSH\" class=\"headerlink\" title=\"安装OpenSSH\"></a>安装OpenSSH</h2><h3 id=\"Ubuntu缺省没有安装SSH-Server-使用以下命令安装\"><a href=\"#Ubuntu缺省没有安装SSH-Server-使用以下命令安装\" class=\"headerlink\" title=\"Ubuntu缺省没有安装SSH Server,使用以下命令安装:\"></a>Ubuntu缺省没有安装SSH Server,使用以下命令安装:</h3><h3 id=\"sudo-apt-get-install-openssh-server-openssh-client\"><a href=\"#sudo-apt-get-install-openssh-server-openssh-client\" class=\"headerlink\" title=\"sudo apt-get install openssh-server openssh-client\"></a>sudo apt-get install openssh-server openssh-client</h3><h3 id=\"配置完成后重启命令\"><a href=\"#配置完成后重启命令\" class=\"headerlink\" title=\"配置完成后重启命令\"></a>配置完成后重启命令</h3><h3 id=\"sudo-etc-init-d-ssh-restart\"><a href=\"#sudo-etc-init-d-ssh-restart\" class=\"headerlink\" title=\"sudo /etc/init.d/ssh restart\"></a>sudo /etc/init.d/ssh restart</h3>"},{"title":"Ubuntu Linux下安装软件方法","date":"2018-04-20T07:02:03.000Z","_content":"\n## 引用: https://www.linuxidc.com/Linux/2015-01/111216.htm\n\n    Linux系统中,软件通常以源代码或者编译包的形式提供.\n    \n    (1)源代码需要编译为二进制的机器码才能够使用,安装比较\n    耗时,不过您可以自行调节编译选项,决定需要的功能或组\n    件,或者针对硬件平台做一些优化.\n    \n    (2)预编译的软件包,通常是由软件的发布者进行编译,您只要\n    将软件拷贝到系统中就可以了.考虑到预编译软件包的适用性\n    ,预编译软件通常不会针对某种硬件平台优化.它所包含的功能\n    和组件也是通用的组合.\n    \n    \n## 1 deb包的安装方式\n\n    deb是debian系Linux的包管理方式,Ubuntu是属于debian系的\n    Linux发行版,所以默认支持这种软件安装方式,当下载到一个\n    deb格式的软件后,在终端输入这个命令就能安装:\n    \n    sudo dpkg -i *.deb\n    \n    或者直接双击安装.\n    \n## 2 编译安装方式\n\n    (小贴士: 使用编译安装前,需要建立编译环境,使用一下命令建立\n    基本的编译环境: sudo apt-get install bulid-essential)\n    \n    在Linux的世界,有很多软件只提供了源代码给你,需要你自己进行\n    编译安装,一般开源的软件都会使用tar.gz压缩档来进行发布,当然\n    还有其他的形式,拿到源代码的压缩文档,把它解压缩到/tmp目录下\n    ,进入/tmp/软件目录,然后执行下三个命令:\n    \n   * 1 ./configure\n   * 2 make \n   * 3 sudo make install\n    \n    在第一步./configure时可能会提示说某某软件找不到,例如提示\"libgnome\"\n    这个开发包找不到,那就把libgnome这个关键词copy,然后打开新立得软件管\n    理器,在里面搜索libgnome这个关键词,就会找到libgnome相关的项目,把前\n    面有个ubuntu符号的libgnome包(注意:同样需要安装dev包,但可以不装doc\n    包)全部安装,通过这个方法把./configure过程中缺失的开发包全部装上就\n    ok了,第一步顺利通过,第二三步基本问题不大.\n    \n## 3 apt-get安装方法\n    \n    ubuntu世界有许多软件源,在系统安装篇已经介绍过如何添加源,apt-get的基本\n    软件安装命令是:\n     \n    sudo apt-get install 软件名\n    \n## 4 新立得软件包管理 \n    打开: 系统 --系统管理--新立得软件包管理,这个工具其实跟apt一样,可以搜索\n    ,下载,安装ubuntu源里的软件,具体安装方式很简单,看看界面应该会懂,就不详细\n    介绍了.\n    \n## 5 二进制包的安装方式\n    \n    有不少开源的商业软件都会采用这种方式发布Linux软件,例如google earth,拿到\n    二进制软件后,把它放到/tmp目录,在终端下进入安装目录,在安装目录下执行:\n    \n    ./软件名\n    \n    然后按照一步步提示,就能安装该软件.例如安装realplayer播放器:你直接到官网\n    http://www.real.com/linux 下载RealPayer的安装包,安装包是.bin格式,用如下\n    命令安装:\n    \n    chomd +x RealPlayer11GOLD.bin\n    \n    ./RealPlayer11GOLD.bin\n    \n## 6 rpm包的安装方式\n    \n    rpm 包是deb包最常见的一种管理方式,但ubuntu同样可以使用rpm的软件资源.首先\n    我们安装一个rpm转deb的软件\n    \n    sudo apt-get install alien\n    \n    然后就可以对rpm格式的软件转换成deb格式了:\n    \n    alien -d *.rpm\n    \n    然后就可以用deb的安装方式进行软件安装.也可以不需转换而直接对rpm包进行安装:\n    \n    alien -i *.rpm\n    \n    更多的alien使用方法可以用-h参数查看相应说明文档.\n    \n## 7 其他安装方式\n\n    其他安装方式一般还有脚本安装方式,这类软件,你会在安装目录下发现类似后缀名的文件\n    ,如: .sh .py .run等的,有的甚至连后缀名都没有,直接一个INSTALL文件,对于这种软件,\n    可以尝试以下几种方式安装:\n    最简单的就是直接在软件目录下输入: ./软件名*(注意有一个*号,那是一般可以通配所有\n    后缀名)\n    或者: sh 软件名.sh\n    或者: python软件名.py\n    \n    TIP:如以上方法均无法安装软件,可以参考软件源代码下面的README文档.\n    \n    ","source":"_posts/Ubuntu-Linux下安装软件方法.md","raw":"---\ntitle: Ubuntu Linux下安装软件方法\ndate: 2018-04-20 15:02:03\ntags: Linux\ncategories: \n- linux\n---\n\n## 引用: https://www.linuxidc.com/Linux/2015-01/111216.htm\n\n    Linux系统中,软件通常以源代码或者编译包的形式提供.\n    \n    (1)源代码需要编译为二进制的机器码才能够使用,安装比较\n    耗时,不过您可以自行调节编译选项,决定需要的功能或组\n    件,或者针对硬件平台做一些优化.\n    \n    (2)预编译的软件包,通常是由软件的发布者进行编译,您只要\n    将软件拷贝到系统中就可以了.考虑到预编译软件包的适用性\n    ,预编译软件通常不会针对某种硬件平台优化.它所包含的功能\n    和组件也是通用的组合.\n    \n    \n## 1 deb包的安装方式\n\n    deb是debian系Linux的包管理方式,Ubuntu是属于debian系的\n    Linux发行版,所以默认支持这种软件安装方式,当下载到一个\n    deb格式的软件后,在终端输入这个命令就能安装:\n    \n    sudo dpkg -i *.deb\n    \n    或者直接双击安装.\n    \n## 2 编译安装方式\n\n    (小贴士: 使用编译安装前,需要建立编译环境,使用一下命令建立\n    基本的编译环境: sudo apt-get install bulid-essential)\n    \n    在Linux的世界,有很多软件只提供了源代码给你,需要你自己进行\n    编译安装,一般开源的软件都会使用tar.gz压缩档来进行发布,当然\n    还有其他的形式,拿到源代码的压缩文档,把它解压缩到/tmp目录下\n    ,进入/tmp/软件目录,然后执行下三个命令:\n    \n   * 1 ./configure\n   * 2 make \n   * 3 sudo make install\n    \n    在第一步./configure时可能会提示说某某软件找不到,例如提示\"libgnome\"\n    这个开发包找不到,那就把libgnome这个关键词copy,然后打开新立得软件管\n    理器,在里面搜索libgnome这个关键词,就会找到libgnome相关的项目,把前\n    面有个ubuntu符号的libgnome包(注意:同样需要安装dev包,但可以不装doc\n    包)全部安装,通过这个方法把./configure过程中缺失的开发包全部装上就\n    ok了,第一步顺利通过,第二三步基本问题不大.\n    \n## 3 apt-get安装方法\n    \n    ubuntu世界有许多软件源,在系统安装篇已经介绍过如何添加源,apt-get的基本\n    软件安装命令是:\n     \n    sudo apt-get install 软件名\n    \n## 4 新立得软件包管理 \n    打开: 系统 --系统管理--新立得软件包管理,这个工具其实跟apt一样,可以搜索\n    ,下载,安装ubuntu源里的软件,具体安装方式很简单,看看界面应该会懂,就不详细\n    介绍了.\n    \n## 5 二进制包的安装方式\n    \n    有不少开源的商业软件都会采用这种方式发布Linux软件,例如google earth,拿到\n    二进制软件后,把它放到/tmp目录,在终端下进入安装目录,在安装目录下执行:\n    \n    ./软件名\n    \n    然后按照一步步提示,就能安装该软件.例如安装realplayer播放器:你直接到官网\n    http://www.real.com/linux 下载RealPayer的安装包,安装包是.bin格式,用如下\n    命令安装:\n    \n    chomd +x RealPlayer11GOLD.bin\n    \n    ./RealPlayer11GOLD.bin\n    \n## 6 rpm包的安装方式\n    \n    rpm 包是deb包最常见的一种管理方式,但ubuntu同样可以使用rpm的软件资源.首先\n    我们安装一个rpm转deb的软件\n    \n    sudo apt-get install alien\n    \n    然后就可以对rpm格式的软件转换成deb格式了:\n    \n    alien -d *.rpm\n    \n    然后就可以用deb的安装方式进行软件安装.也可以不需转换而直接对rpm包进行安装:\n    \n    alien -i *.rpm\n    \n    更多的alien使用方法可以用-h参数查看相应说明文档.\n    \n## 7 其他安装方式\n\n    其他安装方式一般还有脚本安装方式,这类软件,你会在安装目录下发现类似后缀名的文件\n    ,如: .sh .py .run等的,有的甚至连后缀名都没有,直接一个INSTALL文件,对于这种软件,\n    可以尝试以下几种方式安装:\n    最简单的就是直接在软件目录下输入: ./软件名*(注意有一个*号,那是一般可以通配所有\n    后缀名)\n    或者: sh 软件名.sh\n    或者: python软件名.py\n    \n    TIP:如以上方法均无法安装软件,可以参考软件源代码下面的README文档.\n    \n    ","slug":"Ubuntu-Linux下安装软件方法","published":1,"updated":"2019-09-27T08:27:08.033Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecx000sojfy4td3sp4m","content":"<h2 id=\"引用-https-www-linuxidc-com-Linux-2015-01-111216-htm\"><a href=\"#引用-https-www-linuxidc-com-Linux-2015-01-111216-htm\" class=\"headerlink\" title=\"引用: https://www.linuxidc.com/Linux/2015-01/111216.htm\"></a>引用: <a href=\"https://www.linuxidc.com/Linux/2015-01/111216.htm\" target=\"_blank\" rel=\"noopener\">https://www.linuxidc.com/Linux/2015-01/111216.htm</a></h2><pre><code>Linux系统中,软件通常以源代码或者编译包的形式提供.\n\n(1)源代码需要编译为二进制的机器码才能够使用,安装比较\n耗时,不过您可以自行调节编译选项,决定需要的功能或组\n件,或者针对硬件平台做一些优化.\n\n(2)预编译的软件包,通常是由软件的发布者进行编译,您只要\n将软件拷贝到系统中就可以了.考虑到预编译软件包的适用性\n,预编译软件通常不会针对某种硬件平台优化.它所包含的功能\n和组件也是通用的组合.</code></pre><h2 id=\"1-deb包的安装方式\"><a href=\"#1-deb包的安装方式\" class=\"headerlink\" title=\"1 deb包的安装方式\"></a>1 deb包的安装方式</h2><pre><code>deb是debian系Linux的包管理方式,Ubuntu是属于debian系的\nLinux发行版,所以默认支持这种软件安装方式,当下载到一个\ndeb格式的软件后,在终端输入这个命令就能安装:\n\nsudo dpkg -i *.deb\n\n或者直接双击安装.</code></pre><h2 id=\"2-编译安装方式\"><a href=\"#2-编译安装方式\" class=\"headerlink\" title=\"2 编译安装方式\"></a>2 编译安装方式</h2><pre><code>(小贴士: 使用编译安装前,需要建立编译环境,使用一下命令建立\n基本的编译环境: sudo apt-get install bulid-essential)\n\n在Linux的世界,有很多软件只提供了源代码给你,需要你自己进行\n编译安装,一般开源的软件都会使用tar.gz压缩档来进行发布,当然\n还有其他的形式,拿到源代码的压缩文档,把它解压缩到/tmp目录下\n,进入/tmp/软件目录,然后执行下三个命令:</code></pre><ul>\n<li><p>1 ./configure</p>\n</li>\n<li><p>2 make </p>\n</li>\n<li><p>3 sudo make install</p>\n<p>在第一步./configure时可能会提示说某某软件找不到,例如提示”libgnome”<br>这个开发包找不到,那就把libgnome这个关键词copy,然后打开新立得软件管<br>理器,在里面搜索libgnome这个关键词,就会找到libgnome相关的项目,把前<br>面有个ubuntu符号的libgnome包(注意:同样需要安装dev包,但可以不装doc<br>包)全部安装,通过这个方法把./configure过程中缺失的开发包全部装上就<br>ok了,第一步顺利通过,第二三步基本问题不大.</p>\n</li>\n</ul>\n<h2 id=\"3-apt-get安装方法\"><a href=\"#3-apt-get安装方法\" class=\"headerlink\" title=\"3 apt-get安装方法\"></a>3 apt-get安装方法</h2><pre><code>ubuntu世界有许多软件源,在系统安装篇已经介绍过如何添加源,apt-get的基本\n软件安装命令是:\n\nsudo apt-get install 软件名</code></pre><h2 id=\"4-新立得软件包管理\"><a href=\"#4-新立得软件包管理\" class=\"headerlink\" title=\"4 新立得软件包管理\"></a>4 新立得软件包管理</h2><pre><code>打开: 系统 --系统管理--新立得软件包管理,这个工具其实跟apt一样,可以搜索\n,下载,安装ubuntu源里的软件,具体安装方式很简单,看看界面应该会懂,就不详细\n介绍了.</code></pre><h2 id=\"5-二进制包的安装方式\"><a href=\"#5-二进制包的安装方式\" class=\"headerlink\" title=\"5 二进制包的安装方式\"></a>5 二进制包的安装方式</h2><pre><code>有不少开源的商业软件都会采用这种方式发布Linux软件,例如google earth,拿到\n二进制软件后,把它放到/tmp目录,在终端下进入安装目录,在安装目录下执行:\n\n./软件名\n\n然后按照一步步提示,就能安装该软件.例如安装realplayer播放器:你直接到官网\nhttp://www.real.com/linux 下载RealPayer的安装包,安装包是.bin格式,用如下\n命令安装:\n\nchomd +x RealPlayer11GOLD.bin\n\n./RealPlayer11GOLD.bin</code></pre><h2 id=\"6-rpm包的安装方式\"><a href=\"#6-rpm包的安装方式\" class=\"headerlink\" title=\"6 rpm包的安装方式\"></a>6 rpm包的安装方式</h2><pre><code>rpm 包是deb包最常见的一种管理方式,但ubuntu同样可以使用rpm的软件资源.首先\n我们安装一个rpm转deb的软件\n\nsudo apt-get install alien\n\n然后就可以对rpm格式的软件转换成deb格式了:\n\nalien -d *.rpm\n\n然后就可以用deb的安装方式进行软件安装.也可以不需转换而直接对rpm包进行安装:\n\nalien -i *.rpm\n\n更多的alien使用方法可以用-h参数查看相应说明文档.</code></pre><h2 id=\"7-其他安装方式\"><a href=\"#7-其他安装方式\" class=\"headerlink\" title=\"7 其他安装方式\"></a>7 其他安装方式</h2><pre><code>其他安装方式一般还有脚本安装方式,这类软件,你会在安装目录下发现类似后缀名的文件\n,如: .sh .py .run等的,有的甚至连后缀名都没有,直接一个INSTALL文件,对于这种软件,\n可以尝试以下几种方式安装:\n最简单的就是直接在软件目录下输入: ./软件名*(注意有一个*号,那是一般可以通配所有\n后缀名)\n或者: sh 软件名.sh\n或者: python软件名.py\n\nTIP:如以上方法均无法安装软件,可以参考软件源代码下面的README文档.</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"引用-https-www-linuxidc-com-Linux-2015-01-111216-htm\"><a href=\"#引用-https-www-linuxidc-com-Linux-2015-01-111216-htm\" class=\"headerlink\" title=\"引用: https://www.linuxidc.com/Linux/2015-01/111216.htm\"></a>引用: <a href=\"https://www.linuxidc.com/Linux/2015-01/111216.htm\" target=\"_blank\" rel=\"noopener\">https://www.linuxidc.com/Linux/2015-01/111216.htm</a></h2><pre><code>Linux系统中,软件通常以源代码或者编译包的形式提供.\n\n(1)源代码需要编译为二进制的机器码才能够使用,安装比较\n耗时,不过您可以自行调节编译选项,决定需要的功能或组\n件,或者针对硬件平台做一些优化.\n\n(2)预编译的软件包,通常是由软件的发布者进行编译,您只要\n将软件拷贝到系统中就可以了.考虑到预编译软件包的适用性\n,预编译软件通常不会针对某种硬件平台优化.它所包含的功能\n和组件也是通用的组合.</code></pre><h2 id=\"1-deb包的安装方式\"><a href=\"#1-deb包的安装方式\" class=\"headerlink\" title=\"1 deb包的安装方式\"></a>1 deb包的安装方式</h2><pre><code>deb是debian系Linux的包管理方式,Ubuntu是属于debian系的\nLinux发行版,所以默认支持这种软件安装方式,当下载到一个\ndeb格式的软件后,在终端输入这个命令就能安装:\n\nsudo dpkg -i *.deb\n\n或者直接双击安装.</code></pre><h2 id=\"2-编译安装方式\"><a href=\"#2-编译安装方式\" class=\"headerlink\" title=\"2 编译安装方式\"></a>2 编译安装方式</h2><pre><code>(小贴士: 使用编译安装前,需要建立编译环境,使用一下命令建立\n基本的编译环境: sudo apt-get install bulid-essential)\n\n在Linux的世界,有很多软件只提供了源代码给你,需要你自己进行\n编译安装,一般开源的软件都会使用tar.gz压缩档来进行发布,当然\n还有其他的形式,拿到源代码的压缩文档,把它解压缩到/tmp目录下\n,进入/tmp/软件目录,然后执行下三个命令:</code></pre><ul>\n<li><p>1 ./configure</p>\n</li>\n<li><p>2 make </p>\n</li>\n<li><p>3 sudo make install</p>\n<p>在第一步./configure时可能会提示说某某软件找不到,例如提示”libgnome”<br>这个开发包找不到,那就把libgnome这个关键词copy,然后打开新立得软件管<br>理器,在里面搜索libgnome这个关键词,就会找到libgnome相关的项目,把前<br>面有个ubuntu符号的libgnome包(注意:同样需要安装dev包,但可以不装doc<br>包)全部安装,通过这个方法把./configure过程中缺失的开发包全部装上就<br>ok了,第一步顺利通过,第二三步基本问题不大.</p>\n</li>\n</ul>\n<h2 id=\"3-apt-get安装方法\"><a href=\"#3-apt-get安装方法\" class=\"headerlink\" title=\"3 apt-get安装方法\"></a>3 apt-get安装方法</h2><pre><code>ubuntu世界有许多软件源,在系统安装篇已经介绍过如何添加源,apt-get的基本\n软件安装命令是:\n\nsudo apt-get install 软件名</code></pre><h2 id=\"4-新立得软件包管理\"><a href=\"#4-新立得软件包管理\" class=\"headerlink\" title=\"4 新立得软件包管理\"></a>4 新立得软件包管理</h2><pre><code>打开: 系统 --系统管理--新立得软件包管理,这个工具其实跟apt一样,可以搜索\n,下载,安装ubuntu源里的软件,具体安装方式很简单,看看界面应该会懂,就不详细\n介绍了.</code></pre><h2 id=\"5-二进制包的安装方式\"><a href=\"#5-二进制包的安装方式\" class=\"headerlink\" title=\"5 二进制包的安装方式\"></a>5 二进制包的安装方式</h2><pre><code>有不少开源的商业软件都会采用这种方式发布Linux软件,例如google earth,拿到\n二进制软件后,把它放到/tmp目录,在终端下进入安装目录,在安装目录下执行:\n\n./软件名\n\n然后按照一步步提示,就能安装该软件.例如安装realplayer播放器:你直接到官网\nhttp://www.real.com/linux 下载RealPayer的安装包,安装包是.bin格式,用如下\n命令安装:\n\nchomd +x RealPlayer11GOLD.bin\n\n./RealPlayer11GOLD.bin</code></pre><h2 id=\"6-rpm包的安装方式\"><a href=\"#6-rpm包的安装方式\" class=\"headerlink\" title=\"6 rpm包的安装方式\"></a>6 rpm包的安装方式</h2><pre><code>rpm 包是deb包最常见的一种管理方式,但ubuntu同样可以使用rpm的软件资源.首先\n我们安装一个rpm转deb的软件\n\nsudo apt-get install alien\n\n然后就可以对rpm格式的软件转换成deb格式了:\n\nalien -d *.rpm\n\n然后就可以用deb的安装方式进行软件安装.也可以不需转换而直接对rpm包进行安装:\n\nalien -i *.rpm\n\n更多的alien使用方法可以用-h参数查看相应说明文档.</code></pre><h2 id=\"7-其他安装方式\"><a href=\"#7-其他安装方式\" class=\"headerlink\" title=\"7 其他安装方式\"></a>7 其他安装方式</h2><pre><code>其他安装方式一般还有脚本安装方式,这类软件,你会在安装目录下发现类似后缀名的文件\n,如: .sh .py .run等的,有的甚至连后缀名都没有,直接一个INSTALL文件,对于这种软件,\n可以尝试以下几种方式安装:\n最简单的就是直接在软件目录下输入: ./软件名*(注意有一个*号,那是一般可以通配所有\n后缀名)\n或者: sh 软件名.sh\n或者: python软件名.py\n\nTIP:如以上方法均无法安装软件,可以参考软件源代码下面的README文档.</code></pre>"},{"title":"Spring基础知识","date":"2019-09-02T10:16:42.000Z","_content":"\n# Spring简介\nSpring框架由Rod Johnson开发，2004年发布了Spring框架的第一版。Spring是一个从实际开发中抽取出来的框架，因此它完成了大量开发中的通用步骤，留给开发者的仅仅是与特定应用相关的部分，从而大大提高了企业应用的开发效率。\n\n## 优点\n* 低侵入式设计，代码的污染极低\n* 独立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once，Run Anywhere的承诺。\n* Spring的IoC容器降低了业务对象替换的复杂性，提高了组件之间的解耦。\n* Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式管理，从而提供了更好的复用。\n* Spring的ORM和DAO提供了与第三方持久层框架的良好整合，并简化了底层的数据库访问。\n* Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部。\n\n## 结构图\n![](https://www.runoob.com/wp-content/uploads/2015/07/673670c9a34075831373b711cb8f21b7.png)\n\n# Spring的核心机制\n\n## 管理Bean\n程序主要是通过Spring容器来访问容器中的Bean，ApplicationContext是Spring容器最常用的接口，该接口有如下两个实现类：\n\n* ClassPathXmlApplicationContext: 从类加载路径下搜索配置文件，并根据配置文件来创建Spring容器。\n\n* FileSystemXmlApplicationContext: 从文件系统的相对路径或绝对路径下去搜索配置文件，并根据配置文件来创建Spring容器。\n    \n    \n    public class BeanTest{\n        public static void main(String args[]) throws Exception{\n            ApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\");\n            Person p = ctx.getBean(\"person\", Person.class);\n            p.say();\n        }\n    }\n    \n## 依赖注入\nSpring框架的核心功能有两个：\n\n* Spring容器作为超级大工厂，负责创建、管理所有的Java对象，这些Java对象被称为Bean。\n\n* Spring容器管理容器中Bean之间的依赖关系，Spring使用一种被称为\"依赖注入\"的方式来管理Bean之间的依赖关系。\n\n使用依赖注入，不仅可以为Bean注入普通的属性值，还可以注入其他Bean的引用。依赖注入是一种优秀的解耦方式，其可以让Bean以配置文件组织在一起，而不是以硬编码的方式耦合在一起。\n\n### 理解依赖注入\nRod Johnson是第一个高度重视以配置文件来管理Java实例的协作关系的人，他给这种方式起了一个名字：控制反转（Inverse of Control，IoC）。后来Martine Fowler为这种方式起了另一个名称：依赖注入（Dependency Injection），因此不管是依赖注入，还是控制反转，其含义完全相同。当某个Java对象（调用者）需要调用另一个Java对象（被依赖对象）的方法时，在传统模式下通常有两种做法：\n\n 1. 原始做法: 调用者**主动**创建被依赖对象，然后再调用被依赖对象的方法。\n\n 2. 简单工厂模式: 调用者先找到被依赖对象的工厂，然后主动通过工厂去获取被依赖对象，最后再调用被依赖对象的方法。\n\n注意上面的**主动**二字，这必然会导致调用者与被依赖对象实现类的硬编码耦合，非常不利于项目升级的维护。使用Spring框架之后，调用者无需主动获取被依赖对象，调用者只要被动接受Spring容器为调用者的成员变量赋值即可，由此可见，使用Spring后，调用者获取被依赖对象的方式由原来的主动获取，变成了被动接受——所以Rod Johnson称之为控制反转。\n\n另外从Spring容器的角度来看，Spring容器负责将被依赖对象赋值给调用者的成员变量——相当于为调用者注入它依赖的实例，因此Martine Fowler称之为依赖注入。\n\n### 设值注入\n\n设值注入是指IoC容器通过成员变量的setter方法来注入被依赖对象。这种注入方式简单、直观，因而在Spring的依赖注入里大量使用。\n\n### 构造注入\n\n利用构造器来设置依赖关系的方式，被称为构造注入。通俗来说，就是驱动Spring在底层以反射方式执行带指定参数的构造器，当执行带参数的构造器时，就可利用构造器参数对成员变量执行初始化——这就是构造注入的本质。\n\n### 两种注入方式的对比\n\n设值注入有如下优点：\n\n* 与传统的JavaBean的写法更相似，程序开发人员更容易理解、接受。通过setter方法设定依赖关系显得更加直观、自然。\n\n* 对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。Spring在创建Bean实例时，需要同时实例化其依赖的全部实例，因而导致性能下降。而使用设值注入，则能避免这些问题。\n\n* 尤其在某些成员变量可选的情况下，多参数的构造器更加笨重。\n\n构造注入优势如下：\n\n* 构造注入可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入。\n\n* 对于依赖关系无需变化的Bean，构造注入更有用处。因为没有setter方法，所有的依赖关系全部在构造器内设定，无须担心后续的代码对依赖关系产生破坏。\n\n* 依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系，对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则。\n\n### 注意：\n\n建议采用设值注入为主，构造注入为辅的注入策略。对于依赖关系无须变化的注入，尽量采用构造注入；而其他依赖关系的注入，则考虑采用设值注入。\n\n## Spring容器中的Bean\n\n### IoC的本质\n对于开发者来说，开发者使用Spring框架主要是做两件事：①开发Bean；②配置Bean。对于Spring框架来说，它要做的就是根据配置文件来创建Bean实例，并调用Bean实例的方法完成\"依赖注入\"——这就是所谓IoC的本质。\n\n### 容器中Bean的作用域\n当通过Spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下五种作用域：\n\n1. singleton: 单例模式，在整个Spring IoC容器中，singleton作用域的Bean将只生成一个实例。\n\n2. prototype: 每次通过容器的getBean()方法获取prototype作用域的Bean时，都将产生一个新的Bean实例。\n\n3. request: 对于一次HTTP请求，request作用域的Bean将只生成一个实例，这意味着，在同一次HTTP请求内，程序每次请求该Bean，得到的总是同一个实例。只有在Web应用中使用Spring时，该作用域才真正有效。\n\n4. session：该作用域将 bean 的定义限制为 HTTP 会话。 只在web-aware Spring ApplicationContext的上下文中有效。\n\n5. global session: 每个全局的HTTP Session对应一个Bean实例。在典型的情况下，仅在使用portlet context的时候有效，同样只在Web应用中有效。\n\n### 注意\n\n如果不指定Bean的作用域，Spring默认使用singleton作用域。prototype作用域的Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成果，就可以重复使用。因此，应该尽量避免将Bean设置成prototype作用域。\n\n## 使用自动装配注入合作者Bean\n \n Spring能自动装配Bean与Bean之间的依赖关系，即无须使用ref显式指定依赖Bean，而是由Spring容器检查XML配置文件内容，根据某种规则，为调用者Bean注入被依赖的Bean。\n \n Spring自动装配可通过<beans/>元素的default-autowire属性指定，该属性对配置文件中所有的Bean起作用；也可通过对<bean/>元素的autowire属性指定，该属性只对该Bean起作用。\n \n autowire和default-autowire可以接受如下值：\n \n * no: 不使用自动装配。Bean依赖必须通过ref元素定义。这是默认配置，在较大的部署环境中不鼓励改变这个配置，显式配置合作者能够得到更清晰的依赖关系。\n \n * byName: 根据setter方法名进行自动装配。Spring容器查找容器中全部Bean，找出其id与setter方法名去掉set前缀，并小写首字母后同名的Bean来完成注入。如果没有找到匹配的Bean实例，则Spring不会进行任何注入。\n\n * byType 根据setter方法的形参类型来自动装配。Spring容器查找容器中的全部Bean，如果正好有一个Bean类型与setter方法的形参类型匹配，就自动注入这个Bean；如果找到多个这样的Bean，就抛出一个异常；如果没有找到这样的Bean，则什么都不会发生，setter方法不会被调用\n \n *  constructor: 与byType类似，区别是用于自动匹配构造器的参数。如果容器不能恰好找到一个与构造器参数类型匹配的Bean，则会抛出一个异常。\n \n * autodetect: Spring容器根据Bean内部结构，自行决定使用constructor或byType策略。如果找到一个默认的构造函数，那么就会应用byType策略。\n\n当一个Bean既使用自动装配依赖，又使用ref显式指定依赖时，则显式指定的依赖覆盖自动装配依赖；对于大型的应用，不鼓励使用自动装配。虽然使用自动装配可减少配置文件的工作量，但大大将死了依赖关系的清晰性和透明性。依赖关系的装配依赖于源文件的属性名和属性类型，导致Bean与Bean之间的耦合降低到代码层次，不利于高层次解耦。\n\n     <!--通过设置可以将Bean排除在自动装配之外-->\n     <bean id=\"\" autowire-candidate=\"false\"/>\n     \n     <!--除此之外，还可以在beans元素中指定，支持模式字符串，如下所有以abc结尾的Bean都被排除在自动装配之外-->\n     <beans default-autowire-candidates=\"*abc\"/>\n\n\n# 创建Bean的3种方式\n\n## 使用构造器创建Bean实例\n使用构造器来创建Bean实例是最常见的情况，如果不采用构造注入，Spring底层会调用Bean类的无参数构造器来创建实例，因此要求该Bean类提供无参数的构造器。\n\n采用默认的构造器创建Bean实例，Spring对Bean实例的所有属性执行默认初始化，即所有的基本类型的值初始化为0或false；所有的引用类型的值初始化为null。\n\n## 使用静态工厂方法创建Bean\n使用静态工厂方法创建Bean实例时，class属性也必须指定，但此时class属性并不是指定Bean实例的实现类，而是静态工厂类，Spring通过该属性知道由哪个工厂类来创建Bean实例。\n\n除此之外，还需要使用factory-method属性来指定静态工厂方法，Spring将调用静态工厂方法返回一个Bean实例，一旦获得了指定Bean实例，Spring后面的处理步骤与采用普通方法创建Bean实例完全一样。如果静态工厂方法需要参数，则使用<constructor-arg.../>元素指定静态工厂方法的参数。\n\n## 调用实例工厂方法创建Bean\n实例工厂方法与静态工厂方法只有一个不同：调用静态工厂方法只需使用工厂类即可，而调用实例工厂方法则需要工厂实例。使用实例工厂方法时，配置Bean实例的<bean.../>元素无须class属性，配置实例工厂方法使用factory-bean指定工厂实例。\n采用实例工厂方法创建Bean的<bean.../>元素时需要指定如下两个属性：\n\n* factory-bean: 该属性的值为工厂Bean的id。\n* factory-method: 该属性指定实例工厂的工厂方法。\n\n若调用实例工厂方法时需要传入参数，则使用<constructor-arg.../>元素确定参数值。\n\n# 协调作用域不同步的Bean\n当singleton作用域的Bean依赖于prototype作用域的Bean时，会产生不同步的现象，原因是因为当Spring容器初始化时，容器会预初始化容器中所有的singleton Bean，由于singleton Bean依赖于prototype Bean，因此Spring在初始化singleton Bean之前，会先创建prototypeBean——然后才创建singleton Bean，接下里将prototype Bean注入singleton Bean。\n解决不同步的方法有两种：\n\n* 放弃依赖注入: singleton作用域的Bean每次需要prototype作用域的Bean时，主动向容器请求新的Bean实例，即可保证每次注入的prototype Bean实例都是最新的实例。\n\n* 利用方法注入: 方法注入通常使用lookup方法注入，使用lookup方法注入可以让Spring容器重写容器中Bean的抽象或具体方法，返回查找容器中其他Bean的结果，被查找的Bean通常是一个non-singleton Bean。Spring通过使用JDK动态代理或cglib库修改客户端的二进制码，从而实现上述要求。\n\n**注意**\n\n**Spring会采用运行时动态增强的方式来实现<lookup-method.../>元素所指定的抽象方法，如果目标抽象类实现过接口，Spring会采用JDK动态代理来实现该抽象类，并为之实现抽象方法；如果目标抽象类没有实现过接口，Spring会采用cglib实现该抽象类，并为之实现抽象方法。Spring4.0的spring-core-xxx.jar包中已经集成了cglib类库。**\n\n# 两种后处理器\nSpring提供了两种常用的后处理器：\n\n* Bean后处理器: 这种后处理器会对容器中Bean进行后处理，对Bean进行额外加强。\n\n* 容器后处理器: 这种后处理器会对IoC容器进行后处理，用于增强容器功能。\n\n## Bean后处理器\nBean后处理器是一种特殊的Bean，这种特殊的Bean并不对外提供服务，它甚至可以无须id属性，它主要负责对容器中的其他Bean执行后处理，例如为容器中的目标Bean生成代理等，这种Bean称为Bean后处理器。Bean后处理器会在Bean实例创建成功之后，对Bean实例进行进一步的增强处理。Bean后处理器必须实现BeanPostProcessor接口，同时必须实现该接口的两个方法。\n\n* Object postProcessBeforeInitialization(Object bean, String name) throws BeansException: 该方法的第一个参数是系统即将进行后处理的Bean实例，第二个参数是该Bean的配置id\n\n* Object postProcessAfternitialization(Object bean, String name) throws BeansException: 该方法的第一个参数是系统即将进行后处理的Bean实例，第二个参数是该Bean的配置id\n\n容器中一旦注册了Bean后处理器，Bean后处理器就会自动启动，在容器中每个Bean创建时自动工作，Bean后处理器两个方法的回调时机如下图：\n\n![](https://www.runoob.com/wp-content/uploads/2015/07/e8970a58f831cd7613b680ef0541e7c7.jpg)\n注意一点，如果使用BeanFactory作为Spring容器，则必须手动注册Bean后处理器，程序必须获取Bean后处理器实例，然后手动注册。\n\n    BeanPostProcessor bp = (BeanPostProcessor)beanFactory.getBean(\"bp\");\n    beanFactory.addBeanPostProcessor(bp);\n    Person p = (Person)beanFactory.getBean(\"person\");\n    \n## 容器后处理器\n\nBean后处理器负责处理容器中的所有Bean实例，而容器后处理器则负责处理容器本身。容器后处理器必须实现BeanFactoryPostProcessor接口，并实现该接口的一个方法postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)实现该方法的方法体就是对Spring容器进行的处理，这种处理可以对Spring容器进行自定义扩展，当然也可以对Spring容器不进行任何处理。\n\n类似于BeanPostProcessor，ApplicationContext可自动检测到容器中的容器后处理器，并且自动注册容器后处理器。但若使用BeanFactory作为Spring容器，则必须手动调用该容器后处理器来处理BeanFactory容器。\n\n# Spring的\"零配置\"支持\n\n## 搜索Bean类\n\nSpring提供如下几个Annotation来标注Spring Bean：\n\n* @Component: 标注一个普通的Spring Bean类\n\n* @Controller: 标注一个控制器组件类\n\n* @Service: 标注一个业务逻辑组件类\n\n* @Repository: 标注一个DAO组件类\n\n在Spring配置文件中做如下配置，指定自动扫描的包：\n\n<context:component-scan base-package=\"edu.shu.spring.domain\"/>\n\n## 使用@Resource配置依赖\n@Resource位于javax.annotation包下，是来自JavaEE规范的一个Annotation，Spring直接借鉴了该Annotation，通过使用该Annotation为目标Bean指定协作者Bean。使用@Resource与<property.../>元素的ref属性有相同的效果。\n@Resource不仅可以修饰setter方法，也可以直接修饰实例变量，如果使用@Resource修饰实例变量将会更加简单，此时Spring将会直接使用JavaEE规范的Field注入，此时连setter方法都可以不要。\n\n## 使用@PostConstruct和@PreDestroy定制生命周期行为\n@PostConstruct和@PreDestroy同样位于javax.annotation包下，也是来自JavaEE规范的两个Annotation，Spring直接借鉴了它们，用于定制Spring容器中Bean的生命周期行为。它们都用于修饰方法，无须任何属性。其中前者修饰的方法时Bean的初始化方法；而后者修饰的方法时Bean销毁之前的方法。\n\n \n## Spring4.0增强的自动装配和精确装配\nSpring提供了@Autowired注解来指定自动装配，@Autowired可以修饰setter方法、普通方法、实例变量和构造器等。当使用@Autowired标注setter方法时，默认采用byType自动装配策略。在这种策略下，符合自动装配类型的候选Bean实例常常有多个，这个时候就可能引起异常，为了实现精确的自动装配，Spring提供了@Qualifier注解，通过使用@Qualifier，允许根据Bean的id来执行自动装配。\n\n\n# Spring的AOP\n\n## 为什么需要AOP\nAOP（Aspect Orient Programming）也就是面向切面编程，作为面向对象编程的一种补充，已经成为一种比较成熟的编程方式。其实AOP问世的时间并不太长，AOP和OOP互为补充，面向切面编程将程序运行过程分解成各个切面。\n\nAOP专门用于处理系统中分布于各个模块（不同方法）中的交叉关注点的问题，在JavaEE应用中，常常通过AOP来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等，AOP已经成为一种非常常用的解决方案。\n## 使用AspectJ实现AOP\nAspectJ是一个基于Java语言的AOP框架，提供了强大的AOP功能，其他很多AOP框架都借鉴或采纳其中的一些思想。其主要包括两个部分：一个部分定义了如何表达、定义AOP编程中的语法规范，通过这套语法规范，可以方便地用AOP来解决Java语言中存在的交叉关注点的问题；另一个部分是工具部分，包括编译、调试工具等。\n\n## AOP分类\nAOP实现可分为两类：\n### 静态AOP实现: AOP框架在编译阶段对程序进行修改，即实现对目标类的增强，生成静态的AOP代理类，以AspectJ为代表。\n\n### 动态AOP实现: AOP框架在运行阶段动态生成AOP代理，以实现对目标对象的增强，以Spring AOP为代表。\n\n一般来说，静态AOP实现具有较好的性能，但需要使用特殊的编译器。动态AOP实现是纯Java实现，因此无须特殊的编译器，但是通常性能略差。\n\n\n## AOP的基本概念\n关于面向切面编程的一些术语：\n\n*   切面（Aspect）: 切面用于组织多个Advice，Advice放在切面中定义。\n \n*  连接点（Joinpoint）: 程序执行过程中明确的点，如方法的调用，或者异常的抛出。在Spring AOP中，连接点总是方法的调用。\n  \n*    增强处理（Advice）: AOP框架在特定的切入点执行的增强处理。处理有\"around\"、\"before\"和\"after\"等类型\n\n*  切入点（Pointcut）: 可以插入增强处理的连接点。简而言之，当某个连接点满足指定要求时，该连接点将被添加增强处理，该连接点也就变成了切入点。\n  \n## Spring的AOP支持\nSpring中的AOP代理由Spring的IoC容器负责生成、管理，其依赖关系也由IoC容器负责管理。\n为了在应用中使用@AspectJ支持，Spring需要添加三个库：\n\n* aspectjweaver.jar\n\n* aspectjrt.jar\n\n* aopalliance.jar\n\n并在Spring配置文件中做如下配置：\n\n    <!--启动@AspectJ支持-->\n    <aop:aspectj-autoproxy/>\n    \n    <!--指定自动搜索Bean组件、自动搜索切面类-->\n    <context:component-scan base-package=\"edu.shu.sprint.service\">\n        <context:include-filter type=\"annotation\" expression=\"org.aspectj.lang.annotation.Aspect\"/>\n    </context:component-scan>\n\n\n[来源](http://codepub.cn/2015/06/21/Basic-knowledge-summary-of-Spring/)\n\n","source":"_posts/Spring基础知识.md","raw":"---\ntitle: Spring基础知识\ndate: 2019-09-02 18:16:42\ntags: [java,spring]\ncategories: [spring]\n---\n\n# Spring简介\nSpring框架由Rod Johnson开发，2004年发布了Spring框架的第一版。Spring是一个从实际开发中抽取出来的框架，因此它完成了大量开发中的通用步骤，留给开发者的仅仅是与特定应用相关的部分，从而大大提高了企业应用的开发效率。\n\n## 优点\n* 低侵入式设计，代码的污染极低\n* 独立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once，Run Anywhere的承诺。\n* Spring的IoC容器降低了业务对象替换的复杂性，提高了组件之间的解耦。\n* Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式管理，从而提供了更好的复用。\n* Spring的ORM和DAO提供了与第三方持久层框架的良好整合，并简化了底层的数据库访问。\n* Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部。\n\n## 结构图\n![](https://www.runoob.com/wp-content/uploads/2015/07/673670c9a34075831373b711cb8f21b7.png)\n\n# Spring的核心机制\n\n## 管理Bean\n程序主要是通过Spring容器来访问容器中的Bean，ApplicationContext是Spring容器最常用的接口，该接口有如下两个实现类：\n\n* ClassPathXmlApplicationContext: 从类加载路径下搜索配置文件，并根据配置文件来创建Spring容器。\n\n* FileSystemXmlApplicationContext: 从文件系统的相对路径或绝对路径下去搜索配置文件，并根据配置文件来创建Spring容器。\n    \n    \n    public class BeanTest{\n        public static void main(String args[]) throws Exception{\n            ApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\");\n            Person p = ctx.getBean(\"person\", Person.class);\n            p.say();\n        }\n    }\n    \n## 依赖注入\nSpring框架的核心功能有两个：\n\n* Spring容器作为超级大工厂，负责创建、管理所有的Java对象，这些Java对象被称为Bean。\n\n* Spring容器管理容器中Bean之间的依赖关系，Spring使用一种被称为\"依赖注入\"的方式来管理Bean之间的依赖关系。\n\n使用依赖注入，不仅可以为Bean注入普通的属性值，还可以注入其他Bean的引用。依赖注入是一种优秀的解耦方式，其可以让Bean以配置文件组织在一起，而不是以硬编码的方式耦合在一起。\n\n### 理解依赖注入\nRod Johnson是第一个高度重视以配置文件来管理Java实例的协作关系的人，他给这种方式起了一个名字：控制反转（Inverse of Control，IoC）。后来Martine Fowler为这种方式起了另一个名称：依赖注入（Dependency Injection），因此不管是依赖注入，还是控制反转，其含义完全相同。当某个Java对象（调用者）需要调用另一个Java对象（被依赖对象）的方法时，在传统模式下通常有两种做法：\n\n 1. 原始做法: 调用者**主动**创建被依赖对象，然后再调用被依赖对象的方法。\n\n 2. 简单工厂模式: 调用者先找到被依赖对象的工厂，然后主动通过工厂去获取被依赖对象，最后再调用被依赖对象的方法。\n\n注意上面的**主动**二字，这必然会导致调用者与被依赖对象实现类的硬编码耦合，非常不利于项目升级的维护。使用Spring框架之后，调用者无需主动获取被依赖对象，调用者只要被动接受Spring容器为调用者的成员变量赋值即可，由此可见，使用Spring后，调用者获取被依赖对象的方式由原来的主动获取，变成了被动接受——所以Rod Johnson称之为控制反转。\n\n另外从Spring容器的角度来看，Spring容器负责将被依赖对象赋值给调用者的成员变量——相当于为调用者注入它依赖的实例，因此Martine Fowler称之为依赖注入。\n\n### 设值注入\n\n设值注入是指IoC容器通过成员变量的setter方法来注入被依赖对象。这种注入方式简单、直观，因而在Spring的依赖注入里大量使用。\n\n### 构造注入\n\n利用构造器来设置依赖关系的方式，被称为构造注入。通俗来说，就是驱动Spring在底层以反射方式执行带指定参数的构造器，当执行带参数的构造器时，就可利用构造器参数对成员变量执行初始化——这就是构造注入的本质。\n\n### 两种注入方式的对比\n\n设值注入有如下优点：\n\n* 与传统的JavaBean的写法更相似，程序开发人员更容易理解、接受。通过setter方法设定依赖关系显得更加直观、自然。\n\n* 对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。Spring在创建Bean实例时，需要同时实例化其依赖的全部实例，因而导致性能下降。而使用设值注入，则能避免这些问题。\n\n* 尤其在某些成员变量可选的情况下，多参数的构造器更加笨重。\n\n构造注入优势如下：\n\n* 构造注入可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入。\n\n* 对于依赖关系无需变化的Bean，构造注入更有用处。因为没有setter方法，所有的依赖关系全部在构造器内设定，无须担心后续的代码对依赖关系产生破坏。\n\n* 依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系，对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则。\n\n### 注意：\n\n建议采用设值注入为主，构造注入为辅的注入策略。对于依赖关系无须变化的注入，尽量采用构造注入；而其他依赖关系的注入，则考虑采用设值注入。\n\n## Spring容器中的Bean\n\n### IoC的本质\n对于开发者来说，开发者使用Spring框架主要是做两件事：①开发Bean；②配置Bean。对于Spring框架来说，它要做的就是根据配置文件来创建Bean实例，并调用Bean实例的方法完成\"依赖注入\"——这就是所谓IoC的本质。\n\n### 容器中Bean的作用域\n当通过Spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下五种作用域：\n\n1. singleton: 单例模式，在整个Spring IoC容器中，singleton作用域的Bean将只生成一个实例。\n\n2. prototype: 每次通过容器的getBean()方法获取prototype作用域的Bean时，都将产生一个新的Bean实例。\n\n3. request: 对于一次HTTP请求，request作用域的Bean将只生成一个实例，这意味着，在同一次HTTP请求内，程序每次请求该Bean，得到的总是同一个实例。只有在Web应用中使用Spring时，该作用域才真正有效。\n\n4. session：该作用域将 bean 的定义限制为 HTTP 会话。 只在web-aware Spring ApplicationContext的上下文中有效。\n\n5. global session: 每个全局的HTTP Session对应一个Bean实例。在典型的情况下，仅在使用portlet context的时候有效，同样只在Web应用中有效。\n\n### 注意\n\n如果不指定Bean的作用域，Spring默认使用singleton作用域。prototype作用域的Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成果，就可以重复使用。因此，应该尽量避免将Bean设置成prototype作用域。\n\n## 使用自动装配注入合作者Bean\n \n Spring能自动装配Bean与Bean之间的依赖关系，即无须使用ref显式指定依赖Bean，而是由Spring容器检查XML配置文件内容，根据某种规则，为调用者Bean注入被依赖的Bean。\n \n Spring自动装配可通过<beans/>元素的default-autowire属性指定，该属性对配置文件中所有的Bean起作用；也可通过对<bean/>元素的autowire属性指定，该属性只对该Bean起作用。\n \n autowire和default-autowire可以接受如下值：\n \n * no: 不使用自动装配。Bean依赖必须通过ref元素定义。这是默认配置，在较大的部署环境中不鼓励改变这个配置，显式配置合作者能够得到更清晰的依赖关系。\n \n * byName: 根据setter方法名进行自动装配。Spring容器查找容器中全部Bean，找出其id与setter方法名去掉set前缀，并小写首字母后同名的Bean来完成注入。如果没有找到匹配的Bean实例，则Spring不会进行任何注入。\n\n * byType 根据setter方法的形参类型来自动装配。Spring容器查找容器中的全部Bean，如果正好有一个Bean类型与setter方法的形参类型匹配，就自动注入这个Bean；如果找到多个这样的Bean，就抛出一个异常；如果没有找到这样的Bean，则什么都不会发生，setter方法不会被调用\n \n *  constructor: 与byType类似，区别是用于自动匹配构造器的参数。如果容器不能恰好找到一个与构造器参数类型匹配的Bean，则会抛出一个异常。\n \n * autodetect: Spring容器根据Bean内部结构，自行决定使用constructor或byType策略。如果找到一个默认的构造函数，那么就会应用byType策略。\n\n当一个Bean既使用自动装配依赖，又使用ref显式指定依赖时，则显式指定的依赖覆盖自动装配依赖；对于大型的应用，不鼓励使用自动装配。虽然使用自动装配可减少配置文件的工作量，但大大将死了依赖关系的清晰性和透明性。依赖关系的装配依赖于源文件的属性名和属性类型，导致Bean与Bean之间的耦合降低到代码层次，不利于高层次解耦。\n\n     <!--通过设置可以将Bean排除在自动装配之外-->\n     <bean id=\"\" autowire-candidate=\"false\"/>\n     \n     <!--除此之外，还可以在beans元素中指定，支持模式字符串，如下所有以abc结尾的Bean都被排除在自动装配之外-->\n     <beans default-autowire-candidates=\"*abc\"/>\n\n\n# 创建Bean的3种方式\n\n## 使用构造器创建Bean实例\n使用构造器来创建Bean实例是最常见的情况，如果不采用构造注入，Spring底层会调用Bean类的无参数构造器来创建实例，因此要求该Bean类提供无参数的构造器。\n\n采用默认的构造器创建Bean实例，Spring对Bean实例的所有属性执行默认初始化，即所有的基本类型的值初始化为0或false；所有的引用类型的值初始化为null。\n\n## 使用静态工厂方法创建Bean\n使用静态工厂方法创建Bean实例时，class属性也必须指定，但此时class属性并不是指定Bean实例的实现类，而是静态工厂类，Spring通过该属性知道由哪个工厂类来创建Bean实例。\n\n除此之外，还需要使用factory-method属性来指定静态工厂方法，Spring将调用静态工厂方法返回一个Bean实例，一旦获得了指定Bean实例，Spring后面的处理步骤与采用普通方法创建Bean实例完全一样。如果静态工厂方法需要参数，则使用<constructor-arg.../>元素指定静态工厂方法的参数。\n\n## 调用实例工厂方法创建Bean\n实例工厂方法与静态工厂方法只有一个不同：调用静态工厂方法只需使用工厂类即可，而调用实例工厂方法则需要工厂实例。使用实例工厂方法时，配置Bean实例的<bean.../>元素无须class属性，配置实例工厂方法使用factory-bean指定工厂实例。\n采用实例工厂方法创建Bean的<bean.../>元素时需要指定如下两个属性：\n\n* factory-bean: 该属性的值为工厂Bean的id。\n* factory-method: 该属性指定实例工厂的工厂方法。\n\n若调用实例工厂方法时需要传入参数，则使用<constructor-arg.../>元素确定参数值。\n\n# 协调作用域不同步的Bean\n当singleton作用域的Bean依赖于prototype作用域的Bean时，会产生不同步的现象，原因是因为当Spring容器初始化时，容器会预初始化容器中所有的singleton Bean，由于singleton Bean依赖于prototype Bean，因此Spring在初始化singleton Bean之前，会先创建prototypeBean——然后才创建singleton Bean，接下里将prototype Bean注入singleton Bean。\n解决不同步的方法有两种：\n\n* 放弃依赖注入: singleton作用域的Bean每次需要prototype作用域的Bean时，主动向容器请求新的Bean实例，即可保证每次注入的prototype Bean实例都是最新的实例。\n\n* 利用方法注入: 方法注入通常使用lookup方法注入，使用lookup方法注入可以让Spring容器重写容器中Bean的抽象或具体方法，返回查找容器中其他Bean的结果，被查找的Bean通常是一个non-singleton Bean。Spring通过使用JDK动态代理或cglib库修改客户端的二进制码，从而实现上述要求。\n\n**注意**\n\n**Spring会采用运行时动态增强的方式来实现<lookup-method.../>元素所指定的抽象方法，如果目标抽象类实现过接口，Spring会采用JDK动态代理来实现该抽象类，并为之实现抽象方法；如果目标抽象类没有实现过接口，Spring会采用cglib实现该抽象类，并为之实现抽象方法。Spring4.0的spring-core-xxx.jar包中已经集成了cglib类库。**\n\n# 两种后处理器\nSpring提供了两种常用的后处理器：\n\n* Bean后处理器: 这种后处理器会对容器中Bean进行后处理，对Bean进行额外加强。\n\n* 容器后处理器: 这种后处理器会对IoC容器进行后处理，用于增强容器功能。\n\n## Bean后处理器\nBean后处理器是一种特殊的Bean，这种特殊的Bean并不对外提供服务，它甚至可以无须id属性，它主要负责对容器中的其他Bean执行后处理，例如为容器中的目标Bean生成代理等，这种Bean称为Bean后处理器。Bean后处理器会在Bean实例创建成功之后，对Bean实例进行进一步的增强处理。Bean后处理器必须实现BeanPostProcessor接口，同时必须实现该接口的两个方法。\n\n* Object postProcessBeforeInitialization(Object bean, String name) throws BeansException: 该方法的第一个参数是系统即将进行后处理的Bean实例，第二个参数是该Bean的配置id\n\n* Object postProcessAfternitialization(Object bean, String name) throws BeansException: 该方法的第一个参数是系统即将进行后处理的Bean实例，第二个参数是该Bean的配置id\n\n容器中一旦注册了Bean后处理器，Bean后处理器就会自动启动，在容器中每个Bean创建时自动工作，Bean后处理器两个方法的回调时机如下图：\n\n![](https://www.runoob.com/wp-content/uploads/2015/07/e8970a58f831cd7613b680ef0541e7c7.jpg)\n注意一点，如果使用BeanFactory作为Spring容器，则必须手动注册Bean后处理器，程序必须获取Bean后处理器实例，然后手动注册。\n\n    BeanPostProcessor bp = (BeanPostProcessor)beanFactory.getBean(\"bp\");\n    beanFactory.addBeanPostProcessor(bp);\n    Person p = (Person)beanFactory.getBean(\"person\");\n    \n## 容器后处理器\n\nBean后处理器负责处理容器中的所有Bean实例，而容器后处理器则负责处理容器本身。容器后处理器必须实现BeanFactoryPostProcessor接口，并实现该接口的一个方法postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)实现该方法的方法体就是对Spring容器进行的处理，这种处理可以对Spring容器进行自定义扩展，当然也可以对Spring容器不进行任何处理。\n\n类似于BeanPostProcessor，ApplicationContext可自动检测到容器中的容器后处理器，并且自动注册容器后处理器。但若使用BeanFactory作为Spring容器，则必须手动调用该容器后处理器来处理BeanFactory容器。\n\n# Spring的\"零配置\"支持\n\n## 搜索Bean类\n\nSpring提供如下几个Annotation来标注Spring Bean：\n\n* @Component: 标注一个普通的Spring Bean类\n\n* @Controller: 标注一个控制器组件类\n\n* @Service: 标注一个业务逻辑组件类\n\n* @Repository: 标注一个DAO组件类\n\n在Spring配置文件中做如下配置，指定自动扫描的包：\n\n<context:component-scan base-package=\"edu.shu.spring.domain\"/>\n\n## 使用@Resource配置依赖\n@Resource位于javax.annotation包下，是来自JavaEE规范的一个Annotation，Spring直接借鉴了该Annotation，通过使用该Annotation为目标Bean指定协作者Bean。使用@Resource与<property.../>元素的ref属性有相同的效果。\n@Resource不仅可以修饰setter方法，也可以直接修饰实例变量，如果使用@Resource修饰实例变量将会更加简单，此时Spring将会直接使用JavaEE规范的Field注入，此时连setter方法都可以不要。\n\n## 使用@PostConstruct和@PreDestroy定制生命周期行为\n@PostConstruct和@PreDestroy同样位于javax.annotation包下，也是来自JavaEE规范的两个Annotation，Spring直接借鉴了它们，用于定制Spring容器中Bean的生命周期行为。它们都用于修饰方法，无须任何属性。其中前者修饰的方法时Bean的初始化方法；而后者修饰的方法时Bean销毁之前的方法。\n\n \n## Spring4.0增强的自动装配和精确装配\nSpring提供了@Autowired注解来指定自动装配，@Autowired可以修饰setter方法、普通方法、实例变量和构造器等。当使用@Autowired标注setter方法时，默认采用byType自动装配策略。在这种策略下，符合自动装配类型的候选Bean实例常常有多个，这个时候就可能引起异常，为了实现精确的自动装配，Spring提供了@Qualifier注解，通过使用@Qualifier，允许根据Bean的id来执行自动装配。\n\n\n# Spring的AOP\n\n## 为什么需要AOP\nAOP（Aspect Orient Programming）也就是面向切面编程，作为面向对象编程的一种补充，已经成为一种比较成熟的编程方式。其实AOP问世的时间并不太长，AOP和OOP互为补充，面向切面编程将程序运行过程分解成各个切面。\n\nAOP专门用于处理系统中分布于各个模块（不同方法）中的交叉关注点的问题，在JavaEE应用中，常常通过AOP来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等，AOP已经成为一种非常常用的解决方案。\n## 使用AspectJ实现AOP\nAspectJ是一个基于Java语言的AOP框架，提供了强大的AOP功能，其他很多AOP框架都借鉴或采纳其中的一些思想。其主要包括两个部分：一个部分定义了如何表达、定义AOP编程中的语法规范，通过这套语法规范，可以方便地用AOP来解决Java语言中存在的交叉关注点的问题；另一个部分是工具部分，包括编译、调试工具等。\n\n## AOP分类\nAOP实现可分为两类：\n### 静态AOP实现: AOP框架在编译阶段对程序进行修改，即实现对目标类的增强，生成静态的AOP代理类，以AspectJ为代表。\n\n### 动态AOP实现: AOP框架在运行阶段动态生成AOP代理，以实现对目标对象的增强，以Spring AOP为代表。\n\n一般来说，静态AOP实现具有较好的性能，但需要使用特殊的编译器。动态AOP实现是纯Java实现，因此无须特殊的编译器，但是通常性能略差。\n\n\n## AOP的基本概念\n关于面向切面编程的一些术语：\n\n*   切面（Aspect）: 切面用于组织多个Advice，Advice放在切面中定义。\n \n*  连接点（Joinpoint）: 程序执行过程中明确的点，如方法的调用，或者异常的抛出。在Spring AOP中，连接点总是方法的调用。\n  \n*    增强处理（Advice）: AOP框架在特定的切入点执行的增强处理。处理有\"around\"、\"before\"和\"after\"等类型\n\n*  切入点（Pointcut）: 可以插入增强处理的连接点。简而言之，当某个连接点满足指定要求时，该连接点将被添加增强处理，该连接点也就变成了切入点。\n  \n## Spring的AOP支持\nSpring中的AOP代理由Spring的IoC容器负责生成、管理，其依赖关系也由IoC容器负责管理。\n为了在应用中使用@AspectJ支持，Spring需要添加三个库：\n\n* aspectjweaver.jar\n\n* aspectjrt.jar\n\n* aopalliance.jar\n\n并在Spring配置文件中做如下配置：\n\n    <!--启动@AspectJ支持-->\n    <aop:aspectj-autoproxy/>\n    \n    <!--指定自动搜索Bean组件、自动搜索切面类-->\n    <context:component-scan base-package=\"edu.shu.sprint.service\">\n        <context:include-filter type=\"annotation\" expression=\"org.aspectj.lang.annotation.Aspect\"/>\n    </context:component-scan>\n\n\n[来源](http://codepub.cn/2015/06/21/Basic-knowledge-summary-of-Spring/)\n\n","slug":"Spring基础知识","published":1,"updated":"2019-09-27T08:27:08.033Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecy000tojfytzteq5g9","content":"<h1 id=\"Spring简介\"><a href=\"#Spring简介\" class=\"headerlink\" title=\"Spring简介\"></a>Spring简介</h1><p>Spring框架由Rod Johnson开发，2004年发布了Spring框架的第一版。Spring是一个从实际开发中抽取出来的框架，因此它完成了大量开发中的通用步骤，留给开发者的仅仅是与特定应用相关的部分，从而大大提高了企业应用的开发效率。</p>\n<h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><ul>\n<li>低侵入式设计，代码的污染极低</li>\n<li>独立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once，Run Anywhere的承诺。</li>\n<li>Spring的IoC容器降低了业务对象替换的复杂性，提高了组件之间的解耦。</li>\n<li>Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式管理，从而提供了更好的复用。</li>\n<li>Spring的ORM和DAO提供了与第三方持久层框架的良好整合，并简化了底层的数据库访问。</li>\n<li>Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部。</li>\n</ul>\n<h2 id=\"结构图\"><a href=\"#结构图\" class=\"headerlink\" title=\"结构图\"></a>结构图</h2><p><img src=\"https://www.runoob.com/wp-content/uploads/2015/07/673670c9a34075831373b711cb8f21b7.png\" alt></p>\n<h1 id=\"Spring的核心机制\"><a href=\"#Spring的核心机制\" class=\"headerlink\" title=\"Spring的核心机制\"></a>Spring的核心机制</h1><h2 id=\"管理Bean\"><a href=\"#管理Bean\" class=\"headerlink\" title=\"管理Bean\"></a>管理Bean</h2><p>程序主要是通过Spring容器来访问容器中的Bean，ApplicationContext是Spring容器最常用的接口，该接口有如下两个实现类：</p>\n<ul>\n<li><p>ClassPathXmlApplicationContext: 从类加载路径下搜索配置文件，并根据配置文件来创建Spring容器。</p>\n</li>\n<li><p>FileSystemXmlApplicationContext: 从文件系统的相对路径或绝对路径下去搜索配置文件，并根据配置文件来创建Spring容器。</p>\n</li>\n</ul>\n<pre><code>public class BeanTest{\n    public static void main(String args[]) throws Exception{\n        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);\n        Person p = ctx.getBean(&quot;person&quot;, Person.class);\n        p.say();\n    }\n}</code></pre><h2 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h2><p>Spring框架的核心功能有两个：</p>\n<ul>\n<li><p>Spring容器作为超级大工厂，负责创建、管理所有的Java对象，这些Java对象被称为Bean。</p>\n</li>\n<li><p>Spring容器管理容器中Bean之间的依赖关系，Spring使用一种被称为”依赖注入”的方式来管理Bean之间的依赖关系。</p>\n</li>\n</ul>\n<p>使用依赖注入，不仅可以为Bean注入普通的属性值，还可以注入其他Bean的引用。依赖注入是一种优秀的解耦方式，其可以让Bean以配置文件组织在一起，而不是以硬编码的方式耦合在一起。</p>\n<h3 id=\"理解依赖注入\"><a href=\"#理解依赖注入\" class=\"headerlink\" title=\"理解依赖注入\"></a>理解依赖注入</h3><p>Rod Johnson是第一个高度重视以配置文件来管理Java实例的协作关系的人，他给这种方式起了一个名字：控制反转（Inverse of Control，IoC）。后来Martine Fowler为这种方式起了另一个名称：依赖注入（Dependency Injection），因此不管是依赖注入，还是控制反转，其含义完全相同。当某个Java对象（调用者）需要调用另一个Java对象（被依赖对象）的方法时，在传统模式下通常有两种做法：</p>\n<ol>\n<li><p>原始做法: 调用者<strong>主动</strong>创建被依赖对象，然后再调用被依赖对象的方法。</p>\n</li>\n<li><p>简单工厂模式: 调用者先找到被依赖对象的工厂，然后主动通过工厂去获取被依赖对象，最后再调用被依赖对象的方法。</p>\n</li>\n</ol>\n<p>注意上面的<strong>主动</strong>二字，这必然会导致调用者与被依赖对象实现类的硬编码耦合，非常不利于项目升级的维护。使用Spring框架之后，调用者无需主动获取被依赖对象，调用者只要被动接受Spring容器为调用者的成员变量赋值即可，由此可见，使用Spring后，调用者获取被依赖对象的方式由原来的主动获取，变成了被动接受——所以Rod Johnson称之为控制反转。</p>\n<p>另外从Spring容器的角度来看，Spring容器负责将被依赖对象赋值给调用者的成员变量——相当于为调用者注入它依赖的实例，因此Martine Fowler称之为依赖注入。</p>\n<h3 id=\"设值注入\"><a href=\"#设值注入\" class=\"headerlink\" title=\"设值注入\"></a>设值注入</h3><p>设值注入是指IoC容器通过成员变量的setter方法来注入被依赖对象。这种注入方式简单、直观，因而在Spring的依赖注入里大量使用。</p>\n<h3 id=\"构造注入\"><a href=\"#构造注入\" class=\"headerlink\" title=\"构造注入\"></a>构造注入</h3><p>利用构造器来设置依赖关系的方式，被称为构造注入。通俗来说，就是驱动Spring在底层以反射方式执行带指定参数的构造器，当执行带参数的构造器时，就可利用构造器参数对成员变量执行初始化——这就是构造注入的本质。</p>\n<h3 id=\"两种注入方式的对比\"><a href=\"#两种注入方式的对比\" class=\"headerlink\" title=\"两种注入方式的对比\"></a>两种注入方式的对比</h3><p>设值注入有如下优点：</p>\n<ul>\n<li><p>与传统的JavaBean的写法更相似，程序开发人员更容易理解、接受。通过setter方法设定依赖关系显得更加直观、自然。</p>\n</li>\n<li><p>对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。Spring在创建Bean实例时，需要同时实例化其依赖的全部实例，因而导致性能下降。而使用设值注入，则能避免这些问题。</p>\n</li>\n<li><p>尤其在某些成员变量可选的情况下，多参数的构造器更加笨重。</p>\n</li>\n</ul>\n<p>构造注入优势如下：</p>\n<ul>\n<li><p>构造注入可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入。</p>\n</li>\n<li><p>对于依赖关系无需变化的Bean，构造注入更有用处。因为没有setter方法，所有的依赖关系全部在构造器内设定，无须担心后续的代码对依赖关系产生破坏。</p>\n</li>\n<li><p>依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系，对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则。</p>\n</li>\n</ul>\n<h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h3><p>建议采用设值注入为主，构造注入为辅的注入策略。对于依赖关系无须变化的注入，尽量采用构造注入；而其他依赖关系的注入，则考虑采用设值注入。</p>\n<h2 id=\"Spring容器中的Bean\"><a href=\"#Spring容器中的Bean\" class=\"headerlink\" title=\"Spring容器中的Bean\"></a>Spring容器中的Bean</h2><h3 id=\"IoC的本质\"><a href=\"#IoC的本质\" class=\"headerlink\" title=\"IoC的本质\"></a>IoC的本质</h3><p>对于开发者来说，开发者使用Spring框架主要是做两件事：①开发Bean；②配置Bean。对于Spring框架来说，它要做的就是根据配置文件来创建Bean实例，并调用Bean实例的方法完成”依赖注入”——这就是所谓IoC的本质。</p>\n<h3 id=\"容器中Bean的作用域\"><a href=\"#容器中Bean的作用域\" class=\"headerlink\" title=\"容器中Bean的作用域\"></a>容器中Bean的作用域</h3><p>当通过Spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下五种作用域：</p>\n<ol>\n<li><p>singleton: 单例模式，在整个Spring IoC容器中，singleton作用域的Bean将只生成一个实例。</p>\n</li>\n<li><p>prototype: 每次通过容器的getBean()方法获取prototype作用域的Bean时，都将产生一个新的Bean实例。</p>\n</li>\n<li><p>request: 对于一次HTTP请求，request作用域的Bean将只生成一个实例，这意味着，在同一次HTTP请求内，程序每次请求该Bean，得到的总是同一个实例。只有在Web应用中使用Spring时，该作用域才真正有效。</p>\n</li>\n<li><p>session：该作用域将 bean 的定义限制为 HTTP 会话。 只在web-aware Spring ApplicationContext的上下文中有效。</p>\n</li>\n<li><p>global session: 每个全局的HTTP Session对应一个Bean实例。在典型的情况下，仅在使用portlet context的时候有效，同样只在Web应用中有效。</p>\n</li>\n</ol>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>如果不指定Bean的作用域，Spring默认使用singleton作用域。prototype作用域的Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成果，就可以重复使用。因此，应该尽量避免将Bean设置成prototype作用域。</p>\n<h2 id=\"使用自动装配注入合作者Bean\"><a href=\"#使用自动装配注入合作者Bean\" class=\"headerlink\" title=\"使用自动装配注入合作者Bean\"></a>使用自动装配注入合作者Bean</h2><p> Spring能自动装配Bean与Bean之间的依赖关系，即无须使用ref显式指定依赖Bean，而是由Spring容器检查XML配置文件内容，根据某种规则，为调用者Bean注入被依赖的Bean。</p>\n<p> Spring自动装配可通过<beans>元素的default-autowire属性指定，该属性对配置文件中所有的Bean起作用；也可通过对<bean>元素的autowire属性指定，该属性只对该Bean起作用。</bean></beans></p>\n<p> autowire和default-autowire可以接受如下值：</p>\n<ul>\n<li><p>no: 不使用自动装配。Bean依赖必须通过ref元素定义。这是默认配置，在较大的部署环境中不鼓励改变这个配置，显式配置合作者能够得到更清晰的依赖关系。</p>\n</li>\n<li><p>byName: 根据setter方法名进行自动装配。Spring容器查找容器中全部Bean，找出其id与setter方法名去掉set前缀，并小写首字母后同名的Bean来完成注入。如果没有找到匹配的Bean实例，则Spring不会进行任何注入。</p>\n</li>\n<li><p>byType 根据setter方法的形参类型来自动装配。Spring容器查找容器中的全部Bean，如果正好有一个Bean类型与setter方法的形参类型匹配，就自动注入这个Bean；如果找到多个这样的Bean，就抛出一个异常；如果没有找到这样的Bean，则什么都不会发生，setter方法不会被调用</p>\n</li>\n<li><p>constructor: 与byType类似，区别是用于自动匹配构造器的参数。如果容器不能恰好找到一个与构造器参数类型匹配的Bean，则会抛出一个异常。</p>\n</li>\n<li><p>autodetect: Spring容器根据Bean内部结构，自行决定使用constructor或byType策略。如果找到一个默认的构造函数，那么就会应用byType策略。</p>\n</li>\n</ul>\n<p>当一个Bean既使用自动装配依赖，又使用ref显式指定依赖时，则显式指定的依赖覆盖自动装配依赖；对于大型的应用，不鼓励使用自动装配。虽然使用自动装配可减少配置文件的工作量，但大大将死了依赖关系的清晰性和透明性。依赖关系的装配依赖于源文件的属性名和属性类型，导致Bean与Bean之间的耦合降低到代码层次，不利于高层次解耦。</p>\n<pre><code>&lt;!--通过设置可以将Bean排除在自动装配之外--&gt;\n&lt;bean id=&quot;&quot; autowire-candidate=&quot;false&quot;/&gt;\n\n&lt;!--除此之外，还可以在beans元素中指定，支持模式字符串，如下所有以abc结尾的Bean都被排除在自动装配之外--&gt;\n&lt;beans default-autowire-candidates=&quot;*abc&quot;/&gt;</code></pre><h1 id=\"创建Bean的3种方式\"><a href=\"#创建Bean的3种方式\" class=\"headerlink\" title=\"创建Bean的3种方式\"></a>创建Bean的3种方式</h1><h2 id=\"使用构造器创建Bean实例\"><a href=\"#使用构造器创建Bean实例\" class=\"headerlink\" title=\"使用构造器创建Bean实例\"></a>使用构造器创建Bean实例</h2><p>使用构造器来创建Bean实例是最常见的情况，如果不采用构造注入，Spring底层会调用Bean类的无参数构造器来创建实例，因此要求该Bean类提供无参数的构造器。</p>\n<p>采用默认的构造器创建Bean实例，Spring对Bean实例的所有属性执行默认初始化，即所有的基本类型的值初始化为0或false；所有的引用类型的值初始化为null。</p>\n<h2 id=\"使用静态工厂方法创建Bean\"><a href=\"#使用静态工厂方法创建Bean\" class=\"headerlink\" title=\"使用静态工厂方法创建Bean\"></a>使用静态工厂方法创建Bean</h2><p>使用静态工厂方法创建Bean实例时，class属性也必须指定，但此时class属性并不是指定Bean实例的实现类，而是静态工厂类，Spring通过该属性知道由哪个工厂类来创建Bean实例。</p>\n<p>除此之外，还需要使用factory-method属性来指定静态工厂方法，Spring将调用静态工厂方法返回一个Bean实例，一旦获得了指定Bean实例，Spring后面的处理步骤与采用普通方法创建Bean实例完全一样。如果静态工厂方法需要参数，则使用&lt;constructor-arg…/&gt;元素指定静态工厂方法的参数。</p>\n<h2 id=\"调用实例工厂方法创建Bean\"><a href=\"#调用实例工厂方法创建Bean\" class=\"headerlink\" title=\"调用实例工厂方法创建Bean\"></a>调用实例工厂方法创建Bean</h2><p>实例工厂方法与静态工厂方法只有一个不同：调用静态工厂方法只需使用工厂类即可，而调用实例工厂方法则需要工厂实例。使用实例工厂方法时，配置Bean实例的&lt;bean…/&gt;元素无须class属性，配置实例工厂方法使用factory-bean指定工厂实例。<br>采用实例工厂方法创建Bean的&lt;bean…/&gt;元素时需要指定如下两个属性：</p>\n<ul>\n<li>factory-bean: 该属性的值为工厂Bean的id。</li>\n<li>factory-method: 该属性指定实例工厂的工厂方法。</li>\n</ul>\n<p>若调用实例工厂方法时需要传入参数，则使用&lt;constructor-arg…/&gt;元素确定参数值。</p>\n<h1 id=\"协调作用域不同步的Bean\"><a href=\"#协调作用域不同步的Bean\" class=\"headerlink\" title=\"协调作用域不同步的Bean\"></a>协调作用域不同步的Bean</h1><p>当singleton作用域的Bean依赖于prototype作用域的Bean时，会产生不同步的现象，原因是因为当Spring容器初始化时，容器会预初始化容器中所有的singleton Bean，由于singleton Bean依赖于prototype Bean，因此Spring在初始化singleton Bean之前，会先创建prototypeBean——然后才创建singleton Bean，接下里将prototype Bean注入singleton Bean。<br>解决不同步的方法有两种：</p>\n<ul>\n<li><p>放弃依赖注入: singleton作用域的Bean每次需要prototype作用域的Bean时，主动向容器请求新的Bean实例，即可保证每次注入的prototype Bean实例都是最新的实例。</p>\n</li>\n<li><p>利用方法注入: 方法注入通常使用lookup方法注入，使用lookup方法注入可以让Spring容器重写容器中Bean的抽象或具体方法，返回查找容器中其他Bean的结果，被查找的Bean通常是一个non-singleton Bean。Spring通过使用JDK动态代理或cglib库修改客户端的二进制码，从而实现上述要求。</p>\n</li>\n</ul>\n<p><strong>注意</strong></p>\n<p><strong>Spring会采用运行时动态增强的方式来实现&lt;lookup-method…/&gt;元素所指定的抽象方法，如果目标抽象类实现过接口，Spring会采用JDK动态代理来实现该抽象类，并为之实现抽象方法；如果目标抽象类没有实现过接口，Spring会采用cglib实现该抽象类，并为之实现抽象方法。Spring4.0的spring-core-xxx.jar包中已经集成了cglib类库。</strong></p>\n<h1 id=\"两种后处理器\"><a href=\"#两种后处理器\" class=\"headerlink\" title=\"两种后处理器\"></a>两种后处理器</h1><p>Spring提供了两种常用的后处理器：</p>\n<ul>\n<li><p>Bean后处理器: 这种后处理器会对容器中Bean进行后处理，对Bean进行额外加强。</p>\n</li>\n<li><p>容器后处理器: 这种后处理器会对IoC容器进行后处理，用于增强容器功能。</p>\n</li>\n</ul>\n<h2 id=\"Bean后处理器\"><a href=\"#Bean后处理器\" class=\"headerlink\" title=\"Bean后处理器\"></a>Bean后处理器</h2><p>Bean后处理器是一种特殊的Bean，这种特殊的Bean并不对外提供服务，它甚至可以无须id属性，它主要负责对容器中的其他Bean执行后处理，例如为容器中的目标Bean生成代理等，这种Bean称为Bean后处理器。Bean后处理器会在Bean实例创建成功之后，对Bean实例进行进一步的增强处理。Bean后处理器必须实现BeanPostProcessor接口，同时必须实现该接口的两个方法。</p>\n<ul>\n<li><p>Object postProcessBeforeInitialization(Object bean, String name) throws BeansException: 该方法的第一个参数是系统即将进行后处理的Bean实例，第二个参数是该Bean的配置id</p>\n</li>\n<li><p>Object postProcessAfternitialization(Object bean, String name) throws BeansException: 该方法的第一个参数是系统即将进行后处理的Bean实例，第二个参数是该Bean的配置id</p>\n</li>\n</ul>\n<p>容器中一旦注册了Bean后处理器，Bean后处理器就会自动启动，在容器中每个Bean创建时自动工作，Bean后处理器两个方法的回调时机如下图：</p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2015/07/e8970a58f831cd7613b680ef0541e7c7.jpg\" alt><br>注意一点，如果使用BeanFactory作为Spring容器，则必须手动注册Bean后处理器，程序必须获取Bean后处理器实例，然后手动注册。</p>\n<pre><code>BeanPostProcessor bp = (BeanPostProcessor)beanFactory.getBean(&quot;bp&quot;);\nbeanFactory.addBeanPostProcessor(bp);\nPerson p = (Person)beanFactory.getBean(&quot;person&quot;);</code></pre><h2 id=\"容器后处理器\"><a href=\"#容器后处理器\" class=\"headerlink\" title=\"容器后处理器\"></a>容器后处理器</h2><p>Bean后处理器负责处理容器中的所有Bean实例，而容器后处理器则负责处理容器本身。容器后处理器必须实现BeanFactoryPostProcessor接口，并实现该接口的一个方法postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)实现该方法的方法体就是对Spring容器进行的处理，这种处理可以对Spring容器进行自定义扩展，当然也可以对Spring容器不进行任何处理。</p>\n<p>类似于BeanPostProcessor，ApplicationContext可自动检测到容器中的容器后处理器，并且自动注册容器后处理器。但若使用BeanFactory作为Spring容器，则必须手动调用该容器后处理器来处理BeanFactory容器。</p>\n<h1 id=\"Spring的”零配置”支持\"><a href=\"#Spring的”零配置”支持\" class=\"headerlink\" title=\"Spring的”零配置”支持\"></a>Spring的”零配置”支持</h1><h2 id=\"搜索Bean类\"><a href=\"#搜索Bean类\" class=\"headerlink\" title=\"搜索Bean类\"></a>搜索Bean类</h2><p>Spring提供如下几个Annotation来标注Spring Bean：</p>\n<ul>\n<li><p>@Component: 标注一个普通的Spring Bean类</p>\n</li>\n<li><p>@Controller: 标注一个控制器组件类</p>\n</li>\n<li><p>@Service: 标注一个业务逻辑组件类</p>\n</li>\n<li><p>@Repository: 标注一个DAO组件类</p>\n</li>\n</ul>\n<p>在Spring配置文件中做如下配置，指定自动扫描的包：</p>\n<p>&lt;context:component-scan base-package=”edu.shu.spring.domain”/&gt;</p>\n<h2 id=\"使用-Resource配置依赖\"><a href=\"#使用-Resource配置依赖\" class=\"headerlink\" title=\"使用@Resource配置依赖\"></a>使用@Resource配置依赖</h2><p>@Resource位于javax.annotation包下，是来自JavaEE规范的一个Annotation，Spring直接借鉴了该Annotation，通过使用该Annotation为目标Bean指定协作者Bean。使用@Resource与&lt;property…/&gt;元素的ref属性有相同的效果。<br>@Resource不仅可以修饰setter方法，也可以直接修饰实例变量，如果使用@Resource修饰实例变量将会更加简单，此时Spring将会直接使用JavaEE规范的Field注入，此时连setter方法都可以不要。</p>\n<h2 id=\"使用-PostConstruct和-PreDestroy定制生命周期行为\"><a href=\"#使用-PostConstruct和-PreDestroy定制生命周期行为\" class=\"headerlink\" title=\"使用@PostConstruct和@PreDestroy定制生命周期行为\"></a>使用@PostConstruct和@PreDestroy定制生命周期行为</h2><p>@PostConstruct和@PreDestroy同样位于javax.annotation包下，也是来自JavaEE规范的两个Annotation，Spring直接借鉴了它们，用于定制Spring容器中Bean的生命周期行为。它们都用于修饰方法，无须任何属性。其中前者修饰的方法时Bean的初始化方法；而后者修饰的方法时Bean销毁之前的方法。</p>\n<h2 id=\"Spring4-0增强的自动装配和精确装配\"><a href=\"#Spring4-0增强的自动装配和精确装配\" class=\"headerlink\" title=\"Spring4.0增强的自动装配和精确装配\"></a>Spring4.0增强的自动装配和精确装配</h2><p>Spring提供了@Autowired注解来指定自动装配，@Autowired可以修饰setter方法、普通方法、实例变量和构造器等。当使用@Autowired标注setter方法时，默认采用byType自动装配策略。在这种策略下，符合自动装配类型的候选Bean实例常常有多个，这个时候就可能引起异常，为了实现精确的自动装配，Spring提供了@Qualifier注解，通过使用@Qualifier，允许根据Bean的id来执行自动装配。</p>\n<h1 id=\"Spring的AOP\"><a href=\"#Spring的AOP\" class=\"headerlink\" title=\"Spring的AOP\"></a>Spring的AOP</h1><h2 id=\"为什么需要AOP\"><a href=\"#为什么需要AOP\" class=\"headerlink\" title=\"为什么需要AOP\"></a>为什么需要AOP</h2><p>AOP（Aspect Orient Programming）也就是面向切面编程，作为面向对象编程的一种补充，已经成为一种比较成熟的编程方式。其实AOP问世的时间并不太长，AOP和OOP互为补充，面向切面编程将程序运行过程分解成各个切面。</p>\n<p>AOP专门用于处理系统中分布于各个模块（不同方法）中的交叉关注点的问题，在JavaEE应用中，常常通过AOP来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等，AOP已经成为一种非常常用的解决方案。</p>\n<h2 id=\"使用AspectJ实现AOP\"><a href=\"#使用AspectJ实现AOP\" class=\"headerlink\" title=\"使用AspectJ实现AOP\"></a>使用AspectJ实现AOP</h2><p>AspectJ是一个基于Java语言的AOP框架，提供了强大的AOP功能，其他很多AOP框架都借鉴或采纳其中的一些思想。其主要包括两个部分：一个部分定义了如何表达、定义AOP编程中的语法规范，通过这套语法规范，可以方便地用AOP来解决Java语言中存在的交叉关注点的问题；另一个部分是工具部分，包括编译、调试工具等。</p>\n<h2 id=\"AOP分类\"><a href=\"#AOP分类\" class=\"headerlink\" title=\"AOP分类\"></a>AOP分类</h2><p>AOP实现可分为两类：</p>\n<h3 id=\"静态AOP实现-AOP框架在编译阶段对程序进行修改，即实现对目标类的增强，生成静态的AOP代理类，以AspectJ为代表。\"><a href=\"#静态AOP实现-AOP框架在编译阶段对程序进行修改，即实现对目标类的增强，生成静态的AOP代理类，以AspectJ为代表。\" class=\"headerlink\" title=\"静态AOP实现: AOP框架在编译阶段对程序进行修改，即实现对目标类的增强，生成静态的AOP代理类，以AspectJ为代表。\"></a>静态AOP实现: AOP框架在编译阶段对程序进行修改，即实现对目标类的增强，生成静态的AOP代理类，以AspectJ为代表。</h3><h3 id=\"动态AOP实现-AOP框架在运行阶段动态生成AOP代理，以实现对目标对象的增强，以Spring-AOP为代表。\"><a href=\"#动态AOP实现-AOP框架在运行阶段动态生成AOP代理，以实现对目标对象的增强，以Spring-AOP为代表。\" class=\"headerlink\" title=\"动态AOP实现: AOP框架在运行阶段动态生成AOP代理，以实现对目标对象的增强，以Spring AOP为代表。\"></a>动态AOP实现: AOP框架在运行阶段动态生成AOP代理，以实现对目标对象的增强，以Spring AOP为代表。</h3><p>一般来说，静态AOP实现具有较好的性能，但需要使用特殊的编译器。动态AOP实现是纯Java实现，因此无须特殊的编译器，但是通常性能略差。</p>\n<h2 id=\"AOP的基本概念\"><a href=\"#AOP的基本概念\" class=\"headerlink\" title=\"AOP的基本概念\"></a>AOP的基本概念</h2><p>关于面向切面编程的一些术语：</p>\n<ul>\n<li><p>切面（Aspect）: 切面用于组织多个Advice，Advice放在切面中定义。</p>\n</li>\n<li><p>连接点（Joinpoint）: 程序执行过程中明确的点，如方法的调用，或者异常的抛出。在Spring AOP中，连接点总是方法的调用。</p>\n</li>\n<li><p>增强处理（Advice）: AOP框架在特定的切入点执行的增强处理。处理有”around”、”before”和”after”等类型</p>\n</li>\n<li><p>切入点（Pointcut）: 可以插入增强处理的连接点。简而言之，当某个连接点满足指定要求时，该连接点将被添加增强处理，该连接点也就变成了切入点。</p>\n</li>\n</ul>\n<h2 id=\"Spring的AOP支持\"><a href=\"#Spring的AOP支持\" class=\"headerlink\" title=\"Spring的AOP支持\"></a>Spring的AOP支持</h2><p>Spring中的AOP代理由Spring的IoC容器负责生成、管理，其依赖关系也由IoC容器负责管理。<br>为了在应用中使用@AspectJ支持，Spring需要添加三个库：</p>\n<ul>\n<li><p>aspectjweaver.jar</p>\n</li>\n<li><p>aspectjrt.jar</p>\n</li>\n<li><p>aopalliance.jar</p>\n</li>\n</ul>\n<p>并在Spring配置文件中做如下配置：</p>\n<pre><code>&lt;!--启动@AspectJ支持--&gt;\n&lt;aop:aspectj-autoproxy/&gt;\n\n&lt;!--指定自动搜索Bean组件、自动搜索切面类--&gt;\n&lt;context:component-scan base-package=&quot;edu.shu.sprint.service&quot;&gt;\n    &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.aspectj.lang.annotation.Aspect&quot;/&gt;\n&lt;/context:component-scan&gt;</code></pre><p><a href=\"http://codepub.cn/2015/06/21/Basic-knowledge-summary-of-Spring/\" target=\"_blank\" rel=\"noopener\">来源</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Spring简介\"><a href=\"#Spring简介\" class=\"headerlink\" title=\"Spring简介\"></a>Spring简介</h1><p>Spring框架由Rod Johnson开发，2004年发布了Spring框架的第一版。Spring是一个从实际开发中抽取出来的框架，因此它完成了大量开发中的通用步骤，留给开发者的仅仅是与特定应用相关的部分，从而大大提高了企业应用的开发效率。</p>\n<h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><ul>\n<li>低侵入式设计，代码的污染极低</li>\n<li>独立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once，Run Anywhere的承诺。</li>\n<li>Spring的IoC容器降低了业务对象替换的复杂性，提高了组件之间的解耦。</li>\n<li>Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式管理，从而提供了更好的复用。</li>\n<li>Spring的ORM和DAO提供了与第三方持久层框架的良好整合，并简化了底层的数据库访问。</li>\n<li>Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部。</li>\n</ul>\n<h2 id=\"结构图\"><a href=\"#结构图\" class=\"headerlink\" title=\"结构图\"></a>结构图</h2><p><img src=\"https://www.runoob.com/wp-content/uploads/2015/07/673670c9a34075831373b711cb8f21b7.png\" alt></p>\n<h1 id=\"Spring的核心机制\"><a href=\"#Spring的核心机制\" class=\"headerlink\" title=\"Spring的核心机制\"></a>Spring的核心机制</h1><h2 id=\"管理Bean\"><a href=\"#管理Bean\" class=\"headerlink\" title=\"管理Bean\"></a>管理Bean</h2><p>程序主要是通过Spring容器来访问容器中的Bean，ApplicationContext是Spring容器最常用的接口，该接口有如下两个实现类：</p>\n<ul>\n<li><p>ClassPathXmlApplicationContext: 从类加载路径下搜索配置文件，并根据配置文件来创建Spring容器。</p>\n</li>\n<li><p>FileSystemXmlApplicationContext: 从文件系统的相对路径或绝对路径下去搜索配置文件，并根据配置文件来创建Spring容器。</p>\n</li>\n</ul>\n<pre><code>public class BeanTest{\n    public static void main(String args[]) throws Exception{\n        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);\n        Person p = ctx.getBean(&quot;person&quot;, Person.class);\n        p.say();\n    }\n}</code></pre><h2 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h2><p>Spring框架的核心功能有两个：</p>\n<ul>\n<li><p>Spring容器作为超级大工厂，负责创建、管理所有的Java对象，这些Java对象被称为Bean。</p>\n</li>\n<li><p>Spring容器管理容器中Bean之间的依赖关系，Spring使用一种被称为”依赖注入”的方式来管理Bean之间的依赖关系。</p>\n</li>\n</ul>\n<p>使用依赖注入，不仅可以为Bean注入普通的属性值，还可以注入其他Bean的引用。依赖注入是一种优秀的解耦方式，其可以让Bean以配置文件组织在一起，而不是以硬编码的方式耦合在一起。</p>\n<h3 id=\"理解依赖注入\"><a href=\"#理解依赖注入\" class=\"headerlink\" title=\"理解依赖注入\"></a>理解依赖注入</h3><p>Rod Johnson是第一个高度重视以配置文件来管理Java实例的协作关系的人，他给这种方式起了一个名字：控制反转（Inverse of Control，IoC）。后来Martine Fowler为这种方式起了另一个名称：依赖注入（Dependency Injection），因此不管是依赖注入，还是控制反转，其含义完全相同。当某个Java对象（调用者）需要调用另一个Java对象（被依赖对象）的方法时，在传统模式下通常有两种做法：</p>\n<ol>\n<li><p>原始做法: 调用者<strong>主动</strong>创建被依赖对象，然后再调用被依赖对象的方法。</p>\n</li>\n<li><p>简单工厂模式: 调用者先找到被依赖对象的工厂，然后主动通过工厂去获取被依赖对象，最后再调用被依赖对象的方法。</p>\n</li>\n</ol>\n<p>注意上面的<strong>主动</strong>二字，这必然会导致调用者与被依赖对象实现类的硬编码耦合，非常不利于项目升级的维护。使用Spring框架之后，调用者无需主动获取被依赖对象，调用者只要被动接受Spring容器为调用者的成员变量赋值即可，由此可见，使用Spring后，调用者获取被依赖对象的方式由原来的主动获取，变成了被动接受——所以Rod Johnson称之为控制反转。</p>\n<p>另外从Spring容器的角度来看，Spring容器负责将被依赖对象赋值给调用者的成员变量——相当于为调用者注入它依赖的实例，因此Martine Fowler称之为依赖注入。</p>\n<h3 id=\"设值注入\"><a href=\"#设值注入\" class=\"headerlink\" title=\"设值注入\"></a>设值注入</h3><p>设值注入是指IoC容器通过成员变量的setter方法来注入被依赖对象。这种注入方式简单、直观，因而在Spring的依赖注入里大量使用。</p>\n<h3 id=\"构造注入\"><a href=\"#构造注入\" class=\"headerlink\" title=\"构造注入\"></a>构造注入</h3><p>利用构造器来设置依赖关系的方式，被称为构造注入。通俗来说，就是驱动Spring在底层以反射方式执行带指定参数的构造器，当执行带参数的构造器时，就可利用构造器参数对成员变量执行初始化——这就是构造注入的本质。</p>\n<h3 id=\"两种注入方式的对比\"><a href=\"#两种注入方式的对比\" class=\"headerlink\" title=\"两种注入方式的对比\"></a>两种注入方式的对比</h3><p>设值注入有如下优点：</p>\n<ul>\n<li><p>与传统的JavaBean的写法更相似，程序开发人员更容易理解、接受。通过setter方法设定依赖关系显得更加直观、自然。</p>\n</li>\n<li><p>对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。Spring在创建Bean实例时，需要同时实例化其依赖的全部实例，因而导致性能下降。而使用设值注入，则能避免这些问题。</p>\n</li>\n<li><p>尤其在某些成员变量可选的情况下，多参数的构造器更加笨重。</p>\n</li>\n</ul>\n<p>构造注入优势如下：</p>\n<ul>\n<li><p>构造注入可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入。</p>\n</li>\n<li><p>对于依赖关系无需变化的Bean，构造注入更有用处。因为没有setter方法，所有的依赖关系全部在构造器内设定，无须担心后续的代码对依赖关系产生破坏。</p>\n</li>\n<li><p>依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系，对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则。</p>\n</li>\n</ul>\n<h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h3><p>建议采用设值注入为主，构造注入为辅的注入策略。对于依赖关系无须变化的注入，尽量采用构造注入；而其他依赖关系的注入，则考虑采用设值注入。</p>\n<h2 id=\"Spring容器中的Bean\"><a href=\"#Spring容器中的Bean\" class=\"headerlink\" title=\"Spring容器中的Bean\"></a>Spring容器中的Bean</h2><h3 id=\"IoC的本质\"><a href=\"#IoC的本质\" class=\"headerlink\" title=\"IoC的本质\"></a>IoC的本质</h3><p>对于开发者来说，开发者使用Spring框架主要是做两件事：①开发Bean；②配置Bean。对于Spring框架来说，它要做的就是根据配置文件来创建Bean实例，并调用Bean实例的方法完成”依赖注入”——这就是所谓IoC的本质。</p>\n<h3 id=\"容器中Bean的作用域\"><a href=\"#容器中Bean的作用域\" class=\"headerlink\" title=\"容器中Bean的作用域\"></a>容器中Bean的作用域</h3><p>当通过Spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下五种作用域：</p>\n<ol>\n<li><p>singleton: 单例模式，在整个Spring IoC容器中，singleton作用域的Bean将只生成一个实例。</p>\n</li>\n<li><p>prototype: 每次通过容器的getBean()方法获取prototype作用域的Bean时，都将产生一个新的Bean实例。</p>\n</li>\n<li><p>request: 对于一次HTTP请求，request作用域的Bean将只生成一个实例，这意味着，在同一次HTTP请求内，程序每次请求该Bean，得到的总是同一个实例。只有在Web应用中使用Spring时，该作用域才真正有效。</p>\n</li>\n<li><p>session：该作用域将 bean 的定义限制为 HTTP 会话。 只在web-aware Spring ApplicationContext的上下文中有效。</p>\n</li>\n<li><p>global session: 每个全局的HTTP Session对应一个Bean实例。在典型的情况下，仅在使用portlet context的时候有效，同样只在Web应用中有效。</p>\n</li>\n</ol>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>如果不指定Bean的作用域，Spring默认使用singleton作用域。prototype作用域的Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成果，就可以重复使用。因此，应该尽量避免将Bean设置成prototype作用域。</p>\n<h2 id=\"使用自动装配注入合作者Bean\"><a href=\"#使用自动装配注入合作者Bean\" class=\"headerlink\" title=\"使用自动装配注入合作者Bean\"></a>使用自动装配注入合作者Bean</h2><p> Spring能自动装配Bean与Bean之间的依赖关系，即无须使用ref显式指定依赖Bean，而是由Spring容器检查XML配置文件内容，根据某种规则，为调用者Bean注入被依赖的Bean。</p>\n<p> Spring自动装配可通过<beans>元素的default-autowire属性指定，该属性对配置文件中所有的Bean起作用；也可通过对<bean>元素的autowire属性指定，该属性只对该Bean起作用。</bean></beans></p>\n<p> autowire和default-autowire可以接受如下值：</p>\n<ul>\n<li><p>no: 不使用自动装配。Bean依赖必须通过ref元素定义。这是默认配置，在较大的部署环境中不鼓励改变这个配置，显式配置合作者能够得到更清晰的依赖关系。</p>\n</li>\n<li><p>byName: 根据setter方法名进行自动装配。Spring容器查找容器中全部Bean，找出其id与setter方法名去掉set前缀，并小写首字母后同名的Bean来完成注入。如果没有找到匹配的Bean实例，则Spring不会进行任何注入。</p>\n</li>\n<li><p>byType 根据setter方法的形参类型来自动装配。Spring容器查找容器中的全部Bean，如果正好有一个Bean类型与setter方法的形参类型匹配，就自动注入这个Bean；如果找到多个这样的Bean，就抛出一个异常；如果没有找到这样的Bean，则什么都不会发生，setter方法不会被调用</p>\n</li>\n<li><p>constructor: 与byType类似，区别是用于自动匹配构造器的参数。如果容器不能恰好找到一个与构造器参数类型匹配的Bean，则会抛出一个异常。</p>\n</li>\n<li><p>autodetect: Spring容器根据Bean内部结构，自行决定使用constructor或byType策略。如果找到一个默认的构造函数，那么就会应用byType策略。</p>\n</li>\n</ul>\n<p>当一个Bean既使用自动装配依赖，又使用ref显式指定依赖时，则显式指定的依赖覆盖自动装配依赖；对于大型的应用，不鼓励使用自动装配。虽然使用自动装配可减少配置文件的工作量，但大大将死了依赖关系的清晰性和透明性。依赖关系的装配依赖于源文件的属性名和属性类型，导致Bean与Bean之间的耦合降低到代码层次，不利于高层次解耦。</p>\n<pre><code>&lt;!--通过设置可以将Bean排除在自动装配之外--&gt;\n&lt;bean id=&quot;&quot; autowire-candidate=&quot;false&quot;/&gt;\n\n&lt;!--除此之外，还可以在beans元素中指定，支持模式字符串，如下所有以abc结尾的Bean都被排除在自动装配之外--&gt;\n&lt;beans default-autowire-candidates=&quot;*abc&quot;/&gt;</code></pre><h1 id=\"创建Bean的3种方式\"><a href=\"#创建Bean的3种方式\" class=\"headerlink\" title=\"创建Bean的3种方式\"></a>创建Bean的3种方式</h1><h2 id=\"使用构造器创建Bean实例\"><a href=\"#使用构造器创建Bean实例\" class=\"headerlink\" title=\"使用构造器创建Bean实例\"></a>使用构造器创建Bean实例</h2><p>使用构造器来创建Bean实例是最常见的情况，如果不采用构造注入，Spring底层会调用Bean类的无参数构造器来创建实例，因此要求该Bean类提供无参数的构造器。</p>\n<p>采用默认的构造器创建Bean实例，Spring对Bean实例的所有属性执行默认初始化，即所有的基本类型的值初始化为0或false；所有的引用类型的值初始化为null。</p>\n<h2 id=\"使用静态工厂方法创建Bean\"><a href=\"#使用静态工厂方法创建Bean\" class=\"headerlink\" title=\"使用静态工厂方法创建Bean\"></a>使用静态工厂方法创建Bean</h2><p>使用静态工厂方法创建Bean实例时，class属性也必须指定，但此时class属性并不是指定Bean实例的实现类，而是静态工厂类，Spring通过该属性知道由哪个工厂类来创建Bean实例。</p>\n<p>除此之外，还需要使用factory-method属性来指定静态工厂方法，Spring将调用静态工厂方法返回一个Bean实例，一旦获得了指定Bean实例，Spring后面的处理步骤与采用普通方法创建Bean实例完全一样。如果静态工厂方法需要参数，则使用&lt;constructor-arg…/&gt;元素指定静态工厂方法的参数。</p>\n<h2 id=\"调用实例工厂方法创建Bean\"><a href=\"#调用实例工厂方法创建Bean\" class=\"headerlink\" title=\"调用实例工厂方法创建Bean\"></a>调用实例工厂方法创建Bean</h2><p>实例工厂方法与静态工厂方法只有一个不同：调用静态工厂方法只需使用工厂类即可，而调用实例工厂方法则需要工厂实例。使用实例工厂方法时，配置Bean实例的&lt;bean…/&gt;元素无须class属性，配置实例工厂方法使用factory-bean指定工厂实例。<br>采用实例工厂方法创建Bean的&lt;bean…/&gt;元素时需要指定如下两个属性：</p>\n<ul>\n<li>factory-bean: 该属性的值为工厂Bean的id。</li>\n<li>factory-method: 该属性指定实例工厂的工厂方法。</li>\n</ul>\n<p>若调用实例工厂方法时需要传入参数，则使用&lt;constructor-arg…/&gt;元素确定参数值。</p>\n<h1 id=\"协调作用域不同步的Bean\"><a href=\"#协调作用域不同步的Bean\" class=\"headerlink\" title=\"协调作用域不同步的Bean\"></a>协调作用域不同步的Bean</h1><p>当singleton作用域的Bean依赖于prototype作用域的Bean时，会产生不同步的现象，原因是因为当Spring容器初始化时，容器会预初始化容器中所有的singleton Bean，由于singleton Bean依赖于prototype Bean，因此Spring在初始化singleton Bean之前，会先创建prototypeBean——然后才创建singleton Bean，接下里将prototype Bean注入singleton Bean。<br>解决不同步的方法有两种：</p>\n<ul>\n<li><p>放弃依赖注入: singleton作用域的Bean每次需要prototype作用域的Bean时，主动向容器请求新的Bean实例，即可保证每次注入的prototype Bean实例都是最新的实例。</p>\n</li>\n<li><p>利用方法注入: 方法注入通常使用lookup方法注入，使用lookup方法注入可以让Spring容器重写容器中Bean的抽象或具体方法，返回查找容器中其他Bean的结果，被查找的Bean通常是一个non-singleton Bean。Spring通过使用JDK动态代理或cglib库修改客户端的二进制码，从而实现上述要求。</p>\n</li>\n</ul>\n<p><strong>注意</strong></p>\n<p><strong>Spring会采用运行时动态增强的方式来实现&lt;lookup-method…/&gt;元素所指定的抽象方法，如果目标抽象类实现过接口，Spring会采用JDK动态代理来实现该抽象类，并为之实现抽象方法；如果目标抽象类没有实现过接口，Spring会采用cglib实现该抽象类，并为之实现抽象方法。Spring4.0的spring-core-xxx.jar包中已经集成了cglib类库。</strong></p>\n<h1 id=\"两种后处理器\"><a href=\"#两种后处理器\" class=\"headerlink\" title=\"两种后处理器\"></a>两种后处理器</h1><p>Spring提供了两种常用的后处理器：</p>\n<ul>\n<li><p>Bean后处理器: 这种后处理器会对容器中Bean进行后处理，对Bean进行额外加强。</p>\n</li>\n<li><p>容器后处理器: 这种后处理器会对IoC容器进行后处理，用于增强容器功能。</p>\n</li>\n</ul>\n<h2 id=\"Bean后处理器\"><a href=\"#Bean后处理器\" class=\"headerlink\" title=\"Bean后处理器\"></a>Bean后处理器</h2><p>Bean后处理器是一种特殊的Bean，这种特殊的Bean并不对外提供服务，它甚至可以无须id属性，它主要负责对容器中的其他Bean执行后处理，例如为容器中的目标Bean生成代理等，这种Bean称为Bean后处理器。Bean后处理器会在Bean实例创建成功之后，对Bean实例进行进一步的增强处理。Bean后处理器必须实现BeanPostProcessor接口，同时必须实现该接口的两个方法。</p>\n<ul>\n<li><p>Object postProcessBeforeInitialization(Object bean, String name) throws BeansException: 该方法的第一个参数是系统即将进行后处理的Bean实例，第二个参数是该Bean的配置id</p>\n</li>\n<li><p>Object postProcessAfternitialization(Object bean, String name) throws BeansException: 该方法的第一个参数是系统即将进行后处理的Bean实例，第二个参数是该Bean的配置id</p>\n</li>\n</ul>\n<p>容器中一旦注册了Bean后处理器，Bean后处理器就会自动启动，在容器中每个Bean创建时自动工作，Bean后处理器两个方法的回调时机如下图：</p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2015/07/e8970a58f831cd7613b680ef0541e7c7.jpg\" alt><br>注意一点，如果使用BeanFactory作为Spring容器，则必须手动注册Bean后处理器，程序必须获取Bean后处理器实例，然后手动注册。</p>\n<pre><code>BeanPostProcessor bp = (BeanPostProcessor)beanFactory.getBean(&quot;bp&quot;);\nbeanFactory.addBeanPostProcessor(bp);\nPerson p = (Person)beanFactory.getBean(&quot;person&quot;);</code></pre><h2 id=\"容器后处理器\"><a href=\"#容器后处理器\" class=\"headerlink\" title=\"容器后处理器\"></a>容器后处理器</h2><p>Bean后处理器负责处理容器中的所有Bean实例，而容器后处理器则负责处理容器本身。容器后处理器必须实现BeanFactoryPostProcessor接口，并实现该接口的一个方法postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)实现该方法的方法体就是对Spring容器进行的处理，这种处理可以对Spring容器进行自定义扩展，当然也可以对Spring容器不进行任何处理。</p>\n<p>类似于BeanPostProcessor，ApplicationContext可自动检测到容器中的容器后处理器，并且自动注册容器后处理器。但若使用BeanFactory作为Spring容器，则必须手动调用该容器后处理器来处理BeanFactory容器。</p>\n<h1 id=\"Spring的”零配置”支持\"><a href=\"#Spring的”零配置”支持\" class=\"headerlink\" title=\"Spring的”零配置”支持\"></a>Spring的”零配置”支持</h1><h2 id=\"搜索Bean类\"><a href=\"#搜索Bean类\" class=\"headerlink\" title=\"搜索Bean类\"></a>搜索Bean类</h2><p>Spring提供如下几个Annotation来标注Spring Bean：</p>\n<ul>\n<li><p>@Component: 标注一个普通的Spring Bean类</p>\n</li>\n<li><p>@Controller: 标注一个控制器组件类</p>\n</li>\n<li><p>@Service: 标注一个业务逻辑组件类</p>\n</li>\n<li><p>@Repository: 标注一个DAO组件类</p>\n</li>\n</ul>\n<p>在Spring配置文件中做如下配置，指定自动扫描的包：</p>\n<p>&lt;context:component-scan base-package=”edu.shu.spring.domain”/&gt;</p>\n<h2 id=\"使用-Resource配置依赖\"><a href=\"#使用-Resource配置依赖\" class=\"headerlink\" title=\"使用@Resource配置依赖\"></a>使用@Resource配置依赖</h2><p>@Resource位于javax.annotation包下，是来自JavaEE规范的一个Annotation，Spring直接借鉴了该Annotation，通过使用该Annotation为目标Bean指定协作者Bean。使用@Resource与&lt;property…/&gt;元素的ref属性有相同的效果。<br>@Resource不仅可以修饰setter方法，也可以直接修饰实例变量，如果使用@Resource修饰实例变量将会更加简单，此时Spring将会直接使用JavaEE规范的Field注入，此时连setter方法都可以不要。</p>\n<h2 id=\"使用-PostConstruct和-PreDestroy定制生命周期行为\"><a href=\"#使用-PostConstruct和-PreDestroy定制生命周期行为\" class=\"headerlink\" title=\"使用@PostConstruct和@PreDestroy定制生命周期行为\"></a>使用@PostConstruct和@PreDestroy定制生命周期行为</h2><p>@PostConstruct和@PreDestroy同样位于javax.annotation包下，也是来自JavaEE规范的两个Annotation，Spring直接借鉴了它们，用于定制Spring容器中Bean的生命周期行为。它们都用于修饰方法，无须任何属性。其中前者修饰的方法时Bean的初始化方法；而后者修饰的方法时Bean销毁之前的方法。</p>\n<h2 id=\"Spring4-0增强的自动装配和精确装配\"><a href=\"#Spring4-0增强的自动装配和精确装配\" class=\"headerlink\" title=\"Spring4.0增强的自动装配和精确装配\"></a>Spring4.0增强的自动装配和精确装配</h2><p>Spring提供了@Autowired注解来指定自动装配，@Autowired可以修饰setter方法、普通方法、实例变量和构造器等。当使用@Autowired标注setter方法时，默认采用byType自动装配策略。在这种策略下，符合自动装配类型的候选Bean实例常常有多个，这个时候就可能引起异常，为了实现精确的自动装配，Spring提供了@Qualifier注解，通过使用@Qualifier，允许根据Bean的id来执行自动装配。</p>\n<h1 id=\"Spring的AOP\"><a href=\"#Spring的AOP\" class=\"headerlink\" title=\"Spring的AOP\"></a>Spring的AOP</h1><h2 id=\"为什么需要AOP\"><a href=\"#为什么需要AOP\" class=\"headerlink\" title=\"为什么需要AOP\"></a>为什么需要AOP</h2><p>AOP（Aspect Orient Programming）也就是面向切面编程，作为面向对象编程的一种补充，已经成为一种比较成熟的编程方式。其实AOP问世的时间并不太长，AOP和OOP互为补充，面向切面编程将程序运行过程分解成各个切面。</p>\n<p>AOP专门用于处理系统中分布于各个模块（不同方法）中的交叉关注点的问题，在JavaEE应用中，常常通过AOP来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等，AOP已经成为一种非常常用的解决方案。</p>\n<h2 id=\"使用AspectJ实现AOP\"><a href=\"#使用AspectJ实现AOP\" class=\"headerlink\" title=\"使用AspectJ实现AOP\"></a>使用AspectJ实现AOP</h2><p>AspectJ是一个基于Java语言的AOP框架，提供了强大的AOP功能，其他很多AOP框架都借鉴或采纳其中的一些思想。其主要包括两个部分：一个部分定义了如何表达、定义AOP编程中的语法规范，通过这套语法规范，可以方便地用AOP来解决Java语言中存在的交叉关注点的问题；另一个部分是工具部分，包括编译、调试工具等。</p>\n<h2 id=\"AOP分类\"><a href=\"#AOP分类\" class=\"headerlink\" title=\"AOP分类\"></a>AOP分类</h2><p>AOP实现可分为两类：</p>\n<h3 id=\"静态AOP实现-AOP框架在编译阶段对程序进行修改，即实现对目标类的增强，生成静态的AOP代理类，以AspectJ为代表。\"><a href=\"#静态AOP实现-AOP框架在编译阶段对程序进行修改，即实现对目标类的增强，生成静态的AOP代理类，以AspectJ为代表。\" class=\"headerlink\" title=\"静态AOP实现: AOP框架在编译阶段对程序进行修改，即实现对目标类的增强，生成静态的AOP代理类，以AspectJ为代表。\"></a>静态AOP实现: AOP框架在编译阶段对程序进行修改，即实现对目标类的增强，生成静态的AOP代理类，以AspectJ为代表。</h3><h3 id=\"动态AOP实现-AOP框架在运行阶段动态生成AOP代理，以实现对目标对象的增强，以Spring-AOP为代表。\"><a href=\"#动态AOP实现-AOP框架在运行阶段动态生成AOP代理，以实现对目标对象的增强，以Spring-AOP为代表。\" class=\"headerlink\" title=\"动态AOP实现: AOP框架在运行阶段动态生成AOP代理，以实现对目标对象的增强，以Spring AOP为代表。\"></a>动态AOP实现: AOP框架在运行阶段动态生成AOP代理，以实现对目标对象的增强，以Spring AOP为代表。</h3><p>一般来说，静态AOP实现具有较好的性能，但需要使用特殊的编译器。动态AOP实现是纯Java实现，因此无须特殊的编译器，但是通常性能略差。</p>\n<h2 id=\"AOP的基本概念\"><a href=\"#AOP的基本概念\" class=\"headerlink\" title=\"AOP的基本概念\"></a>AOP的基本概念</h2><p>关于面向切面编程的一些术语：</p>\n<ul>\n<li><p>切面（Aspect）: 切面用于组织多个Advice，Advice放在切面中定义。</p>\n</li>\n<li><p>连接点（Joinpoint）: 程序执行过程中明确的点，如方法的调用，或者异常的抛出。在Spring AOP中，连接点总是方法的调用。</p>\n</li>\n<li><p>增强处理（Advice）: AOP框架在特定的切入点执行的增强处理。处理有”around”、”before”和”after”等类型</p>\n</li>\n<li><p>切入点（Pointcut）: 可以插入增强处理的连接点。简而言之，当某个连接点满足指定要求时，该连接点将被添加增强处理，该连接点也就变成了切入点。</p>\n</li>\n</ul>\n<h2 id=\"Spring的AOP支持\"><a href=\"#Spring的AOP支持\" class=\"headerlink\" title=\"Spring的AOP支持\"></a>Spring的AOP支持</h2><p>Spring中的AOP代理由Spring的IoC容器负责生成、管理，其依赖关系也由IoC容器负责管理。<br>为了在应用中使用@AspectJ支持，Spring需要添加三个库：</p>\n<ul>\n<li><p>aspectjweaver.jar</p>\n</li>\n<li><p>aspectjrt.jar</p>\n</li>\n<li><p>aopalliance.jar</p>\n</li>\n</ul>\n<p>并在Spring配置文件中做如下配置：</p>\n<pre><code>&lt;!--启动@AspectJ支持--&gt;\n&lt;aop:aspectj-autoproxy/&gt;\n\n&lt;!--指定自动搜索Bean组件、自动搜索切面类--&gt;\n&lt;context:component-scan base-package=&quot;edu.shu.sprint.service&quot;&gt;\n    &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.aspectj.lang.annotation.Aspect&quot;/&gt;\n&lt;/context:component-scan&gt;</code></pre><p><a href=\"http://codepub.cn/2015/06/21/Basic-knowledge-summary-of-Spring/\" target=\"_blank\" rel=\"noopener\">来源</a></p>\n"},{"title":" WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! ","date":"2018-05-11T03:36:59.000Z","_content":"\n## 参考: https://blog.csdn.net/nahancy/article/details/51052127\n\n## 问题\n\nOn branch master\nnothing to commit, working tree clean\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the DSA key sent by the remote host is\nSHA256:br9IjFspm1vxR3iA35FWE+4VTyz1hYVLIE2t1/CeyWQ.\nPlease contact your system administrator.\nAdd correct host key in /Users/xiongzixu/.ssh/known_hosts to get rid of this message.\nOffending RSA key in /Users/xiongzixu/.ssh/known_hosts:1\nDSA host key for github.com has changed and you have requested strict checking.\nHost key verification failed.\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n\n## 原因:\n找了好久发现有篇文章里面提到.ssh/known_hosts文件,原来known_hosts是记录远程主机的公钥的文件，\n之前更新了系统，而保存的公钥还是未重装系统的系统公钥，在ssh链接的时候首先会验证公钥，如果公钥不对，\n那么就会报错\n\n\n\n\n## 解决方案(3种):\n\n* 1: 使用shh-keygen 命令（强烈建议使用此方法）\n       \n     比如我们要将172.16.152.209的公钥信息清除，使用命令（请自己将172.16.152.209替换成自己的IP或域名）：\n     \n* 2: 将known_hosts文件中的与登录错误的IP的公钥删除即可，下图就是我的218机子的公钥（实则是之前系统的公钥），然后将其删除，再ssh 登录 great 登录成功了。     \n       \n\n![](https://img-blog.csdn.net/20160403214246747?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n* 3: 将known_hosts文件中的内容清空即可，但不建议使用此方法，里面还保存有其他机子的公钥。 \n     \n\n\n","source":"_posts/WARNING-REMOTE-HOST-IDENTIFICATION-HAS-CHANGED.md","raw":"---\ntitle: ' WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! '\ndate: 2018-05-11 11:36:59\ntags:\ncategories: \n- 异常处理\n---\n\n## 参考: https://blog.csdn.net/nahancy/article/details/51052127\n\n## 问题\n\nOn branch master\nnothing to commit, working tree clean\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the DSA key sent by the remote host is\nSHA256:br9IjFspm1vxR3iA35FWE+4VTyz1hYVLIE2t1/CeyWQ.\nPlease contact your system administrator.\nAdd correct host key in /Users/xiongzixu/.ssh/known_hosts to get rid of this message.\nOffending RSA key in /Users/xiongzixu/.ssh/known_hosts:1\nDSA host key for github.com has changed and you have requested strict checking.\nHost key verification failed.\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n\n## 原因:\n找了好久发现有篇文章里面提到.ssh/known_hosts文件,原来known_hosts是记录远程主机的公钥的文件，\n之前更新了系统，而保存的公钥还是未重装系统的系统公钥，在ssh链接的时候首先会验证公钥，如果公钥不对，\n那么就会报错\n\n\n\n\n## 解决方案(3种):\n\n* 1: 使用shh-keygen 命令（强烈建议使用此方法）\n       \n     比如我们要将172.16.152.209的公钥信息清除，使用命令（请自己将172.16.152.209替换成自己的IP或域名）：\n     \n* 2: 将known_hosts文件中的与登录错误的IP的公钥删除即可，下图就是我的218机子的公钥（实则是之前系统的公钥），然后将其删除，再ssh 登录 great 登录成功了。     \n       \n\n![](https://img-blog.csdn.net/20160403214246747?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n\n* 3: 将known_hosts文件中的内容清空即可，但不建议使用此方法，里面还保存有其他机子的公钥。 \n     \n\n\n","slug":"WARNING-REMOTE-HOST-IDENTIFICATION-HAS-CHANGED","published":1,"updated":"2019-09-27T08:27:08.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecy000uojfysedao90c","content":"<h2 id=\"参考-https-blog-csdn-net-nahancy-article-details-51052127\"><a href=\"#参考-https-blog-csdn-net-nahancy-article-details-51052127\" class=\"headerlink\" title=\"参考: https://blog.csdn.net/nahancy/article/details/51052127\"></a>参考: <a href=\"https://blog.csdn.net/nahancy/article/details/51052127\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/nahancy/article/details/51052127</a></h2><h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>On branch master<br>nothing to commit, working tree clean<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!<br>Someone could be eavesdropping on you right now (man-in-the-middle attack)!<br>It is also possible that a host key has just been changed.<br>The fingerprint for the DSA key sent by the remote host is<br>SHA256:br9IjFspm1vxR3iA35FWE+4VTyz1hYVLIE2t1/CeyWQ.<br>Please contact your system administrator.<br>Add correct host key in /Users/xiongzixu/.ssh/known_hosts to get rid of this message.<br>Offending RSA key in /Users/xiongzixu/.ssh/known_hosts:1<br>DSA host key for github.com has changed and you have requested strict checking.<br>Host key verification failed.<br>fatal: Could not read from remote repository.</p>\n<p>Please make sure you have the correct access rights<br>and the repository exists.</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因:\"></a>原因:</h2><p>找了好久发现有篇文章里面提到.ssh/known_hosts文件,原来known_hosts是记录远程主机的公钥的文件，<br>之前更新了系统，而保存的公钥还是未重装系统的系统公钥，在ssh链接的时候首先会验证公钥，如果公钥不对，<br>那么就会报错</p>\n<h2 id=\"解决方案-3种\"><a href=\"#解决方案-3种\" class=\"headerlink\" title=\"解决方案(3种):\"></a>解决方案(3种):</h2><ul>\n<li><p>1: 使用shh-keygen 命令（强烈建议使用此方法）</p>\n<p>   比如我们要将172.16.152.209的公钥信息清除，使用命令（请自己将172.16.152.209替换成自己的IP或域名）：</p>\n</li>\n<li><p>2: 将known_hosts文件中的与登录错误的IP的公钥删除即可，下图就是我的218机子的公钥（实则是之前系统的公钥），然后将其删除，再ssh 登录 great 登录成功了。     </p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdn.net/20160403214246747?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt></p>\n<ul>\n<li>3: 将known_hosts文件中的内容清空即可，但不建议使用此方法，里面还保存有其他机子的公钥。 </li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"参考-https-blog-csdn-net-nahancy-article-details-51052127\"><a href=\"#参考-https-blog-csdn-net-nahancy-article-details-51052127\" class=\"headerlink\" title=\"参考: https://blog.csdn.net/nahancy/article/details/51052127\"></a>参考: <a href=\"https://blog.csdn.net/nahancy/article/details/51052127\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/nahancy/article/details/51052127</a></h2><h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>On branch master<br>nothing to commit, working tree clean<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!<br>Someone could be eavesdropping on you right now (man-in-the-middle attack)!<br>It is also possible that a host key has just been changed.<br>The fingerprint for the DSA key sent by the remote host is<br>SHA256:br9IjFspm1vxR3iA35FWE+4VTyz1hYVLIE2t1/CeyWQ.<br>Please contact your system administrator.<br>Add correct host key in /Users/xiongzixu/.ssh/known_hosts to get rid of this message.<br>Offending RSA key in /Users/xiongzixu/.ssh/known_hosts:1<br>DSA host key for github.com has changed and you have requested strict checking.<br>Host key verification failed.<br>fatal: Could not read from remote repository.</p>\n<p>Please make sure you have the correct access rights<br>and the repository exists.</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因:\"></a>原因:</h2><p>找了好久发现有篇文章里面提到.ssh/known_hosts文件,原来known_hosts是记录远程主机的公钥的文件，<br>之前更新了系统，而保存的公钥还是未重装系统的系统公钥，在ssh链接的时候首先会验证公钥，如果公钥不对，<br>那么就会报错</p>\n<h2 id=\"解决方案-3种\"><a href=\"#解决方案-3种\" class=\"headerlink\" title=\"解决方案(3种):\"></a>解决方案(3种):</h2><ul>\n<li><p>1: 使用shh-keygen 命令（强烈建议使用此方法）</p>\n<p>   比如我们要将172.16.152.209的公钥信息清除，使用命令（请自己将172.16.152.209替换成自己的IP或域名）：</p>\n</li>\n<li><p>2: 将known_hosts文件中的与登录错误的IP的公钥删除即可，下图就是我的218机子的公钥（实则是之前系统的公钥），然后将其删除，再ssh 登录 great 登录成功了。     </p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdn.net/20160403214246747?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt></p>\n<ul>\n<li>3: 将known_hosts文件中的内容清空即可，但不建议使用此方法，里面还保存有其他机子的公钥。 </li>\n</ul>\n"},{"title":"Vagrant基本用法","date":"2018-09-11T08:06:18.000Z","_content":"\n## 官网: https://www.vagrantup.com/\n\n# intro 介绍\n\n## what is vagrant (流浪汉是什么)\n\n### Introduction to Vagrant (流浪汉简介)\n\n    Vagrant is a tool for building and managing virtual machine\n    environments in a single workflow. With an easy-to-use workflow\n    and focus on automaiton, Vagrant lowers development setup time,\n    increases production parity,and makes the \"works on my machine\"\n    excuse a relic of the past.\n    \n    if you are already familiar with the basics of Vagrant, the \n    documentation provides a better reference build for all available\n    features and internals.\n    \n    Vagrant是一种在单个工作流程中构建和管理虚拟环境的工具.通过易于使用的工\n    作流程并专注于自动化,Vagrant降低了开发环境的设置时间,提高了生产平价,\n    并使\"在我的假期上工作\"称为过去的遗留物.\n    \n    如果您已经熟悉Vagrant的基础知识,那么该文档可为所有可用功能和内部提供\n    更好的参考构建.\n    \n### why Vagrant (为什么选择Vagrant)    \n\n    vagrant provides easy to configure,reproducible,and portable\n    work environments built on top of industry-standard technology\n    and controlled by a single consistent workflow to help maximize \n    the productivity and flexibility of you and your team.\n    \n    To achieve its magic,Vagrant stands on the shoulders of giants.\n    Machines are provisioned on top of VirtualBox,VMware,AWS,or any\n    other provider,Then,Industry-standard providioning tools such\n    as shell scripts,Chef,or Puppet,can automatically install and\n    configure software on the virtual machine.\n    \n    Vagrant 提供易于配置,可重复和便携的工作环境,基于行和标准技术构建,并由单一\n    一致的工作流程控制,以帮助您和您的团队最大限度地提高生成力和灵魂性.\n    \n    为了实现其魔力,Vagrant站在巨人的肩膀上.在VirtualBox,VMware,AWS或\n    任何其他提供商之上配置计算机.然后,行业标准配置工具(如shell脚本,Chef或\n    Puppet)可以在虚拟机上自动安装和配置软件.\n    \n### For Developers (对于开发者)\n\n    if you are a developer,Vagarnt will isolate dependencies and\n    their configuration within a single disposable,consistent \n    environment,without sacrificing any of the tools you are\n    used to working with(editors,browsers,debuggers,etc.).Once\n    you or someone else creates a single Vagrantfile,you just \n    need to vagrant up and everything is installed and configured\n    for you to work .Other members of your team create their\n    development environments form the same configuration,so \n    whether you are working on Linux,Mac OSX,or Windows,all\n    your team members are running code in the same environment\n    ,against the same dependencies,al configured the same way.\n    Say goodbye to \"works on my machine\"bugs.\n    \n    如果您是一位开发人员,Vagrant将在一个一致的环境中隔离依赖及其配置,\n    而不会牺牲您习惯使用的任何工具(编辑器,浏览器,调试器等).一旦您或其他人\n    创建了单个Vagrant文件,您只需要运行vagrant up命令安装并配置所有内容\n    即可使用.团队的其他成员使用相同的配置创建他们的开发环境,因此无论您是在\n    Linux,Mac OS X还是Windows上工作,您的所有团队成员都在同一环境中运行\n    代码,针对相同的依赖项,所有组件都配置相同办法.告别\"在我的机器上工作\"的\n    错误.\n    \n### For Operators (对于运维)\n    \n    if you are an operations engineer or DevOps engineer,Vagrant\n    gives you a disposable environment and consisitent workflow\n    for developing and testing infrastructure management scripts.\n    you can quickly test things like shell scripts,Chef cookbooks,\n    Puppet modules,and more using local virtualization such as \n    VirtualBox or VMware.Then,with the same configuration,you can\n    test these scripts on remote clouds such as AWS or RackSpace \n    with the same workflow.Ditch your custom scripts to recycle\n    EC2 instances,stop juggling SSH prompts to various machines,\n    and start using Vagrant to bring sanity to your life.\n    \n    如果你是运维工程师或者开发运维工程师,Vagrant为您提供一次性环境和一致的\n    工作流程,用于开发和测试基础架构管理脚本.您可以使用VirtualBox或VMware\n    等本地虚拟化快速测试shell脚本,Chef cookbook,Puppet模块等内容.然后\n    ,使用相同的配置,您可以使用相同的工作流在远程云(如AWS或RackSpace)上测试\n    这些脚本.抛弃自定义脚本以回收EC2实例,停止将SSH提示传递给各种计算机,并\n    开始使用Vagrant为您的生活带来理智.\n    \n### For Designers(对于设计)\n\n    If you are a designer,Vagrant will automatically set everything\n    up that is required for that web app in order for you to focus\n    on doing what you do best:design.Once a developer configures\n    Vagrant,you do not need to worry about how to get that app running\n    ever again.No more bothering other developers to help you fix\n    your environment so you can test designs.Just check out the code\n    ,vagrant up,and start designing.\n    \n    如果你是个设计师,Vagrant 将自动设置该web应用程序所需的所有内容,以便你\n    集中精力做你最擅长的事情:设计.当开发人员配置了一次Vagrant,你再也不用\n    担心怎样去运行应用程序.不必再打扰其他开发人员来帮助你修复环境,因此你能\n    测试你的设计.仅打出单词,vagrant up ,就可以开始设计了.\n    \n    \n### For Everyone(对于任何人)         \n    \n    Vagrant is designed for erveyone as the easiest and fastest\n    way to create a virtualized environment!\n    \n    Vagrant 的设计对任何人来说都是最简单最快速的获取虚拟环境的方式.\n\n## Vagrant vs. Other Software (Vagrant 与其他软件的对比)    \n\n    Vagrant is not the only tool to manage virtual machines\n    and development environments.This section compares Vagrant\n    to these other software choices.\n    \n    Vagrant 不是唯一管理虚拟机和开发环境的工具,本节将比较Vagrant与其他\n    软件以便选择.\n    \n    Due to the bias of the comparisons,we attempt to only use\n    facts.If you find something that is invalid or out of date\n    in the comparisons,please open an issue and we'll address\n    it as soon as possible.\n    \n    由于比较的偏颇,我们试图只用事实说话,在比较中假如你发现了无效的或者过期\n    的内容,请开启一个issue,我们将尽可能的处理它.\n    \n    Use the navigation on the left to read comparisons of Vagrant\n    versus similar software.\n    \n    使用左侧导航栏去阅读Vagrant与相似软件的比较\n    \n###   CLI Tools\n      \n#### Vagrant vs CLI Tools\n\n    Virtualization software like VirtualBox and VMware come with\n    command line utilities for managing the lifecycle of machines\n    on their platform.Many people make use of these utilties for \n    managing the lifecycle of machines on their platform.Many people\n    make use of these utilities to write their own automation.\n    Vagrant actually uses many of these utilties internally.\n    \n    虚拟化软件如VirtualBox和VMware,带有命令行工具来管理平台上的机器的生命\n    周期.许多人使用这些工具来写他们自己的自动化程序.Vagrant实际上在内部用了\n    很多这样的工具.\n    \n    The difference between these CLI tool and Vagrant is that \n    Vagrant builds on top of these utilties in a number of ways \n    while still providing a consistent workflow.Vagrant supports\n    multiple provisioners to setup the machine,automatic SSH setup,\n    creating HTTP tunnels into your development environment,and more.\n    All of these can be configured using a single simple configuration\n    file.\n    \n    这些CLI工具与Vagrant的区别在于,Vagrant以多种方式在这些实用程序之上\n    构建,同时仍然提供一致的工作流.Vagrant 支持多种同步文件夹类型,设置机器\n    的多个提供程序 自动SSH设置 创建多开发环境中的HTTP隧道等.所有这些都可以\n    使用一个简单的配置文件来配置.\n    \n    Vagrant still has a number of improvements over manual scripting\n    even if you ignore all the higher-level features Vagrant provides.\n    The command-line utilities provided by vitualization software\n    often change each version or have subtle bugs with workarounds.\n    Vagrant automatically detects the version,uses the correct flags,\n    can work around known issues.So if you're using one version\n    of VirtualBox and a co-worker is using a different version,\n    Vagrant will still work consistently.\n    \n    Vagrant在手动脚本方面仍有许多改进.即使你忽略了流浪汉提供的所有高级特征.\n    虚拟化软件提供的命令行工具经常改变每个版本或有变通方法的细微错误.\n    流浪汉自动检测版本,使用正确的标志,能围绕已知问题工作.\n    因此假如你使用一个版本的VirtualBox而另一个同事使用不同的版本,Vagrant\n    仍然可以一致工作.\n    \n    For highly-specifil workflows that don't change often.it can\n    still be beneficial to maintain custom scripts .Vagrant is \n    tageted at building development environments but some \n    advanced users still use the ClI tools underneath to do \n    other manual things.\n    \n    对于不经常改变的高度特定的工作流,维护自定义脚本仍然是有益的.Vagrant\n    的目标是构建开发环境,但是一些高级用户仍然使用下面的CLI工具来完成\n    其他手动操作.\n    \n###     Docker\n\n#### Vagrant vs. Docker\n\n    Vagrant is a tool focused on providing a consistent\n    development environment workflow across multiple \n    operating systems.Docker is a container management\n    that can consistently run sofeware as long as a \n    containerization system exists.\n    \n    Vagrant是一个专注于跨多个操作系统提供一致的开发环境工作流的工具.\n    Docker是一种容器管理,只要存在容器化系统,就可以始终如一地运行软件.\n    \n    Containers are generally more lightweight than virtual\n    machines,so starting and stopping containers is extremely\n    fast. Most common development machines don't have a \n    containerization system built-in, and Docker uses a \n    virtual machine with Linux installed to provide that.\n    \n    容器一般比虚拟机更轻量级,因此开启或停止容器是非常快的.大多数常见的\n    开发及其没有内置化的容器系统,Doker使用安装了Linux的虚拟机来提供这\n    一点.\n    \n    Currently,Docker lacks support for certain operating\n    systems(such as BSD).if you target deployment is one\n    of these operating systems,Docker will not provide \n    the same prodution parity as tool like Vagrant.Vagrant \n    will allow you to run a Windows development environment\n    on Mac or Linux,as well.\n    \n    目前,Docker缺乏对某些操作系统(如:BSD)的支持.如果你的目标是部署\n    这些操作系统之一,那么Docker不会像Vagrant一样提供相同的一致产品.\n    Vagrant允许你在Mac或Linux上运行Windows开发环境.\n    \n    For microservice heavy environments,Docker can be attractive\n    because you can easily start a single Docker VM and start\n    many containers above that very quickly.This is a good use\n    case for Docker.Vagrant can do this as well with the Docker\n    provider.A primary benefit for Vagrant is a consistent\n    workflow but there are many cases where a pure-Docker\n    workflow does make sense.\n    \n    Both Vagrant and Docker have a vast library of \n    community-contributed \"images\"or\"boxes\"to choose from.\n    \n    对于微服务繁重的环境,Docker可能很有吸引力,因为您可以单个Docker\n    VM 并快速启动多个容器.这是Docker的一个很好的用例.Vagrant也可以\n    使用Docker提供程序执行此操作.Vagrant的主要好处是一致的工作流程,\n    但在很多情况下,纯Docker工作流程确实有意义.\n    \n    Vagrant和Docker都拥有庞大的社区贡献\"图像\"或\"盒子\"库供您选择.\n    \n### Terraform\n\n#### Vagrant vs. Terraform\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n\n","source":"_posts/Vagrant基本用法.md","raw":"---\ntitle: Vagrant基本用法\ndate: 2018-09-11 16:06:18\ntags: vagrant\ncategories: \n- 虚拟机\n---\n\n## 官网: https://www.vagrantup.com/\n\n# intro 介绍\n\n## what is vagrant (流浪汉是什么)\n\n### Introduction to Vagrant (流浪汉简介)\n\n    Vagrant is a tool for building and managing virtual machine\n    environments in a single workflow. With an easy-to-use workflow\n    and focus on automaiton, Vagrant lowers development setup time,\n    increases production parity,and makes the \"works on my machine\"\n    excuse a relic of the past.\n    \n    if you are already familiar with the basics of Vagrant, the \n    documentation provides a better reference build for all available\n    features and internals.\n    \n    Vagrant是一种在单个工作流程中构建和管理虚拟环境的工具.通过易于使用的工\n    作流程并专注于自动化,Vagrant降低了开发环境的设置时间,提高了生产平价,\n    并使\"在我的假期上工作\"称为过去的遗留物.\n    \n    如果您已经熟悉Vagrant的基础知识,那么该文档可为所有可用功能和内部提供\n    更好的参考构建.\n    \n### why Vagrant (为什么选择Vagrant)    \n\n    vagrant provides easy to configure,reproducible,and portable\n    work environments built on top of industry-standard technology\n    and controlled by a single consistent workflow to help maximize \n    the productivity and flexibility of you and your team.\n    \n    To achieve its magic,Vagrant stands on the shoulders of giants.\n    Machines are provisioned on top of VirtualBox,VMware,AWS,or any\n    other provider,Then,Industry-standard providioning tools such\n    as shell scripts,Chef,or Puppet,can automatically install and\n    configure software on the virtual machine.\n    \n    Vagrant 提供易于配置,可重复和便携的工作环境,基于行和标准技术构建,并由单一\n    一致的工作流程控制,以帮助您和您的团队最大限度地提高生成力和灵魂性.\n    \n    为了实现其魔力,Vagrant站在巨人的肩膀上.在VirtualBox,VMware,AWS或\n    任何其他提供商之上配置计算机.然后,行业标准配置工具(如shell脚本,Chef或\n    Puppet)可以在虚拟机上自动安装和配置软件.\n    \n### For Developers (对于开发者)\n\n    if you are a developer,Vagarnt will isolate dependencies and\n    their configuration within a single disposable,consistent \n    environment,without sacrificing any of the tools you are\n    used to working with(editors,browsers,debuggers,etc.).Once\n    you or someone else creates a single Vagrantfile,you just \n    need to vagrant up and everything is installed and configured\n    for you to work .Other members of your team create their\n    development environments form the same configuration,so \n    whether you are working on Linux,Mac OSX,or Windows,all\n    your team members are running code in the same environment\n    ,against the same dependencies,al configured the same way.\n    Say goodbye to \"works on my machine\"bugs.\n    \n    如果您是一位开发人员,Vagrant将在一个一致的环境中隔离依赖及其配置,\n    而不会牺牲您习惯使用的任何工具(编辑器,浏览器,调试器等).一旦您或其他人\n    创建了单个Vagrant文件,您只需要运行vagrant up命令安装并配置所有内容\n    即可使用.团队的其他成员使用相同的配置创建他们的开发环境,因此无论您是在\n    Linux,Mac OS X还是Windows上工作,您的所有团队成员都在同一环境中运行\n    代码,针对相同的依赖项,所有组件都配置相同办法.告别\"在我的机器上工作\"的\n    错误.\n    \n### For Operators (对于运维)\n    \n    if you are an operations engineer or DevOps engineer,Vagrant\n    gives you a disposable environment and consisitent workflow\n    for developing and testing infrastructure management scripts.\n    you can quickly test things like shell scripts,Chef cookbooks,\n    Puppet modules,and more using local virtualization such as \n    VirtualBox or VMware.Then,with the same configuration,you can\n    test these scripts on remote clouds such as AWS or RackSpace \n    with the same workflow.Ditch your custom scripts to recycle\n    EC2 instances,stop juggling SSH prompts to various machines,\n    and start using Vagrant to bring sanity to your life.\n    \n    如果你是运维工程师或者开发运维工程师,Vagrant为您提供一次性环境和一致的\n    工作流程,用于开发和测试基础架构管理脚本.您可以使用VirtualBox或VMware\n    等本地虚拟化快速测试shell脚本,Chef cookbook,Puppet模块等内容.然后\n    ,使用相同的配置,您可以使用相同的工作流在远程云(如AWS或RackSpace)上测试\n    这些脚本.抛弃自定义脚本以回收EC2实例,停止将SSH提示传递给各种计算机,并\n    开始使用Vagrant为您的生活带来理智.\n    \n### For Designers(对于设计)\n\n    If you are a designer,Vagrant will automatically set everything\n    up that is required for that web app in order for you to focus\n    on doing what you do best:design.Once a developer configures\n    Vagrant,you do not need to worry about how to get that app running\n    ever again.No more bothering other developers to help you fix\n    your environment so you can test designs.Just check out the code\n    ,vagrant up,and start designing.\n    \n    如果你是个设计师,Vagrant 将自动设置该web应用程序所需的所有内容,以便你\n    集中精力做你最擅长的事情:设计.当开发人员配置了一次Vagrant,你再也不用\n    担心怎样去运行应用程序.不必再打扰其他开发人员来帮助你修复环境,因此你能\n    测试你的设计.仅打出单词,vagrant up ,就可以开始设计了.\n    \n    \n### For Everyone(对于任何人)         \n    \n    Vagrant is designed for erveyone as the easiest and fastest\n    way to create a virtualized environment!\n    \n    Vagrant 的设计对任何人来说都是最简单最快速的获取虚拟环境的方式.\n\n## Vagrant vs. Other Software (Vagrant 与其他软件的对比)    \n\n    Vagrant is not the only tool to manage virtual machines\n    and development environments.This section compares Vagrant\n    to these other software choices.\n    \n    Vagrant 不是唯一管理虚拟机和开发环境的工具,本节将比较Vagrant与其他\n    软件以便选择.\n    \n    Due to the bias of the comparisons,we attempt to only use\n    facts.If you find something that is invalid or out of date\n    in the comparisons,please open an issue and we'll address\n    it as soon as possible.\n    \n    由于比较的偏颇,我们试图只用事实说话,在比较中假如你发现了无效的或者过期\n    的内容,请开启一个issue,我们将尽可能的处理它.\n    \n    Use the navigation on the left to read comparisons of Vagrant\n    versus similar software.\n    \n    使用左侧导航栏去阅读Vagrant与相似软件的比较\n    \n###   CLI Tools\n      \n#### Vagrant vs CLI Tools\n\n    Virtualization software like VirtualBox and VMware come with\n    command line utilities for managing the lifecycle of machines\n    on their platform.Many people make use of these utilties for \n    managing the lifecycle of machines on their platform.Many people\n    make use of these utilities to write their own automation.\n    Vagrant actually uses many of these utilties internally.\n    \n    虚拟化软件如VirtualBox和VMware,带有命令行工具来管理平台上的机器的生命\n    周期.许多人使用这些工具来写他们自己的自动化程序.Vagrant实际上在内部用了\n    很多这样的工具.\n    \n    The difference between these CLI tool and Vagrant is that \n    Vagrant builds on top of these utilties in a number of ways \n    while still providing a consistent workflow.Vagrant supports\n    multiple provisioners to setup the machine,automatic SSH setup,\n    creating HTTP tunnels into your development environment,and more.\n    All of these can be configured using a single simple configuration\n    file.\n    \n    这些CLI工具与Vagrant的区别在于,Vagrant以多种方式在这些实用程序之上\n    构建,同时仍然提供一致的工作流.Vagrant 支持多种同步文件夹类型,设置机器\n    的多个提供程序 自动SSH设置 创建多开发环境中的HTTP隧道等.所有这些都可以\n    使用一个简单的配置文件来配置.\n    \n    Vagrant still has a number of improvements over manual scripting\n    even if you ignore all the higher-level features Vagrant provides.\n    The command-line utilities provided by vitualization software\n    often change each version or have subtle bugs with workarounds.\n    Vagrant automatically detects the version,uses the correct flags,\n    can work around known issues.So if you're using one version\n    of VirtualBox and a co-worker is using a different version,\n    Vagrant will still work consistently.\n    \n    Vagrant在手动脚本方面仍有许多改进.即使你忽略了流浪汉提供的所有高级特征.\n    虚拟化软件提供的命令行工具经常改变每个版本或有变通方法的细微错误.\n    流浪汉自动检测版本,使用正确的标志,能围绕已知问题工作.\n    因此假如你使用一个版本的VirtualBox而另一个同事使用不同的版本,Vagrant\n    仍然可以一致工作.\n    \n    For highly-specifil workflows that don't change often.it can\n    still be beneficial to maintain custom scripts .Vagrant is \n    tageted at building development environments but some \n    advanced users still use the ClI tools underneath to do \n    other manual things.\n    \n    对于不经常改变的高度特定的工作流,维护自定义脚本仍然是有益的.Vagrant\n    的目标是构建开发环境,但是一些高级用户仍然使用下面的CLI工具来完成\n    其他手动操作.\n    \n###     Docker\n\n#### Vagrant vs. Docker\n\n    Vagrant is a tool focused on providing a consistent\n    development environment workflow across multiple \n    operating systems.Docker is a container management\n    that can consistently run sofeware as long as a \n    containerization system exists.\n    \n    Vagrant是一个专注于跨多个操作系统提供一致的开发环境工作流的工具.\n    Docker是一种容器管理,只要存在容器化系统,就可以始终如一地运行软件.\n    \n    Containers are generally more lightweight than virtual\n    machines,so starting and stopping containers is extremely\n    fast. Most common development machines don't have a \n    containerization system built-in, and Docker uses a \n    virtual machine with Linux installed to provide that.\n    \n    容器一般比虚拟机更轻量级,因此开启或停止容器是非常快的.大多数常见的\n    开发及其没有内置化的容器系统,Doker使用安装了Linux的虚拟机来提供这\n    一点.\n    \n    Currently,Docker lacks support for certain operating\n    systems(such as BSD).if you target deployment is one\n    of these operating systems,Docker will not provide \n    the same prodution parity as tool like Vagrant.Vagrant \n    will allow you to run a Windows development environment\n    on Mac or Linux,as well.\n    \n    目前,Docker缺乏对某些操作系统(如:BSD)的支持.如果你的目标是部署\n    这些操作系统之一,那么Docker不会像Vagrant一样提供相同的一致产品.\n    Vagrant允许你在Mac或Linux上运行Windows开发环境.\n    \n    For microservice heavy environments,Docker can be attractive\n    because you can easily start a single Docker VM and start\n    many containers above that very quickly.This is a good use\n    case for Docker.Vagrant can do this as well with the Docker\n    provider.A primary benefit for Vagrant is a consistent\n    workflow but there are many cases where a pure-Docker\n    workflow does make sense.\n    \n    Both Vagrant and Docker have a vast library of \n    community-contributed \"images\"or\"boxes\"to choose from.\n    \n    对于微服务繁重的环境,Docker可能很有吸引力,因为您可以单个Docker\n    VM 并快速启动多个容器.这是Docker的一个很好的用例.Vagrant也可以\n    使用Docker提供程序执行此操作.Vagrant的主要好处是一致的工作流程,\n    但在很多情况下,纯Docker工作流程确实有意义.\n    \n    Vagrant和Docker都拥有庞大的社区贡献\"图像\"或\"盒子\"库供您选择.\n    \n### Terraform\n\n#### Vagrant vs. Terraform\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n\n","slug":"Vagrant基本用法","published":1,"updated":"2019-09-27T08:27:08.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cecz000vojfyev4iy6lc","content":"<h2 id=\"官网-https-www-vagrantup-com\"><a href=\"#官网-https-www-vagrantup-com\" class=\"headerlink\" title=\"官网: https://www.vagrantup.com/\"></a>官网: <a href=\"https://www.vagrantup.com/\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/</a></h2><h1 id=\"intro-介绍\"><a href=\"#intro-介绍\" class=\"headerlink\" title=\"intro 介绍\"></a>intro 介绍</h1><h2 id=\"what-is-vagrant-流浪汉是什么\"><a href=\"#what-is-vagrant-流浪汉是什么\" class=\"headerlink\" title=\"what is vagrant (流浪汉是什么)\"></a>what is vagrant (流浪汉是什么)</h2><h3 id=\"Introduction-to-Vagrant-流浪汉简介\"><a href=\"#Introduction-to-Vagrant-流浪汉简介\" class=\"headerlink\" title=\"Introduction to Vagrant (流浪汉简介)\"></a>Introduction to Vagrant (流浪汉简介)</h3><pre><code>Vagrant is a tool for building and managing virtual machine\nenvironments in a single workflow. With an easy-to-use workflow\nand focus on automaiton, Vagrant lowers development setup time,\nincreases production parity,and makes the &quot;works on my machine&quot;\nexcuse a relic of the past.\n\nif you are already familiar with the basics of Vagrant, the \ndocumentation provides a better reference build for all available\nfeatures and internals.\n\nVagrant是一种在单个工作流程中构建和管理虚拟环境的工具.通过易于使用的工\n作流程并专注于自动化,Vagrant降低了开发环境的设置时间,提高了生产平价,\n并使&quot;在我的假期上工作&quot;称为过去的遗留物.\n\n如果您已经熟悉Vagrant的基础知识,那么该文档可为所有可用功能和内部提供\n更好的参考构建.</code></pre><h3 id=\"why-Vagrant-为什么选择Vagrant\"><a href=\"#why-Vagrant-为什么选择Vagrant\" class=\"headerlink\" title=\"why Vagrant (为什么选择Vagrant)\"></a>why Vagrant (为什么选择Vagrant)</h3><pre><code>vagrant provides easy to configure,reproducible,and portable\nwork environments built on top of industry-standard technology\nand controlled by a single consistent workflow to help maximize \nthe productivity and flexibility of you and your team.\n\nTo achieve its magic,Vagrant stands on the shoulders of giants.\nMachines are provisioned on top of VirtualBox,VMware,AWS,or any\nother provider,Then,Industry-standard providioning tools such\nas shell scripts,Chef,or Puppet,can automatically install and\nconfigure software on the virtual machine.\n\nVagrant 提供易于配置,可重复和便携的工作环境,基于行和标准技术构建,并由单一\n一致的工作流程控制,以帮助您和您的团队最大限度地提高生成力和灵魂性.\n\n为了实现其魔力,Vagrant站在巨人的肩膀上.在VirtualBox,VMware,AWS或\n任何其他提供商之上配置计算机.然后,行业标准配置工具(如shell脚本,Chef或\nPuppet)可以在虚拟机上自动安装和配置软件.</code></pre><h3 id=\"For-Developers-对于开发者\"><a href=\"#For-Developers-对于开发者\" class=\"headerlink\" title=\"For Developers (对于开发者)\"></a>For Developers (对于开发者)</h3><pre><code>if you are a developer,Vagarnt will isolate dependencies and\ntheir configuration within a single disposable,consistent \nenvironment,without sacrificing any of the tools you are\nused to working with(editors,browsers,debuggers,etc.).Once\nyou or someone else creates a single Vagrantfile,you just \nneed to vagrant up and everything is installed and configured\nfor you to work .Other members of your team create their\ndevelopment environments form the same configuration,so \nwhether you are working on Linux,Mac OSX,or Windows,all\nyour team members are running code in the same environment\n,against the same dependencies,al configured the same way.\nSay goodbye to &quot;works on my machine&quot;bugs.\n\n如果您是一位开发人员,Vagrant将在一个一致的环境中隔离依赖及其配置,\n而不会牺牲您习惯使用的任何工具(编辑器,浏览器,调试器等).一旦您或其他人\n创建了单个Vagrant文件,您只需要运行vagrant up命令安装并配置所有内容\n即可使用.团队的其他成员使用相同的配置创建他们的开发环境,因此无论您是在\nLinux,Mac OS X还是Windows上工作,您的所有团队成员都在同一环境中运行\n代码,针对相同的依赖项,所有组件都配置相同办法.告别&quot;在我的机器上工作&quot;的\n错误.</code></pre><h3 id=\"For-Operators-对于运维\"><a href=\"#For-Operators-对于运维\" class=\"headerlink\" title=\"For Operators (对于运维)\"></a>For Operators (对于运维)</h3><pre><code>if you are an operations engineer or DevOps engineer,Vagrant\ngives you a disposable environment and consisitent workflow\nfor developing and testing infrastructure management scripts.\nyou can quickly test things like shell scripts,Chef cookbooks,\nPuppet modules,and more using local virtualization such as \nVirtualBox or VMware.Then,with the same configuration,you can\ntest these scripts on remote clouds such as AWS or RackSpace \nwith the same workflow.Ditch your custom scripts to recycle\nEC2 instances,stop juggling SSH prompts to various machines,\nand start using Vagrant to bring sanity to your life.\n\n如果你是运维工程师或者开发运维工程师,Vagrant为您提供一次性环境和一致的\n工作流程,用于开发和测试基础架构管理脚本.您可以使用VirtualBox或VMware\n等本地虚拟化快速测试shell脚本,Chef cookbook,Puppet模块等内容.然后\n,使用相同的配置,您可以使用相同的工作流在远程云(如AWS或RackSpace)上测试\n这些脚本.抛弃自定义脚本以回收EC2实例,停止将SSH提示传递给各种计算机,并\n开始使用Vagrant为您的生活带来理智.</code></pre><h3 id=\"For-Designers-对于设计\"><a href=\"#For-Designers-对于设计\" class=\"headerlink\" title=\"For Designers(对于设计)\"></a>For Designers(对于设计)</h3><pre><code>If you are a designer,Vagrant will automatically set everything\nup that is required for that web app in order for you to focus\non doing what you do best:design.Once a developer configures\nVagrant,you do not need to worry about how to get that app running\never again.No more bothering other developers to help you fix\nyour environment so you can test designs.Just check out the code\n,vagrant up,and start designing.\n\n如果你是个设计师,Vagrant 将自动设置该web应用程序所需的所有内容,以便你\n集中精力做你最擅长的事情:设计.当开发人员配置了一次Vagrant,你再也不用\n担心怎样去运行应用程序.不必再打扰其他开发人员来帮助你修复环境,因此你能\n测试你的设计.仅打出单词,vagrant up ,就可以开始设计了.</code></pre><h3 id=\"For-Everyone-对于任何人\"><a href=\"#For-Everyone-对于任何人\" class=\"headerlink\" title=\"For Everyone(对于任何人)\"></a>For Everyone(对于任何人)</h3><pre><code>Vagrant is designed for erveyone as the easiest and fastest\nway to create a virtualized environment!\n\nVagrant 的设计对任何人来说都是最简单最快速的获取虚拟环境的方式.</code></pre><h2 id=\"Vagrant-vs-Other-Software-Vagrant-与其他软件的对比\"><a href=\"#Vagrant-vs-Other-Software-Vagrant-与其他软件的对比\" class=\"headerlink\" title=\"Vagrant vs. Other Software (Vagrant 与其他软件的对比)\"></a>Vagrant vs. Other Software (Vagrant 与其他软件的对比)</h2><pre><code>Vagrant is not the only tool to manage virtual machines\nand development environments.This section compares Vagrant\nto these other software choices.\n\nVagrant 不是唯一管理虚拟机和开发环境的工具,本节将比较Vagrant与其他\n软件以便选择.\n\nDue to the bias of the comparisons,we attempt to only use\nfacts.If you find something that is invalid or out of date\nin the comparisons,please open an issue and we&apos;ll address\nit as soon as possible.\n\n由于比较的偏颇,我们试图只用事实说话,在比较中假如你发现了无效的或者过期\n的内容,请开启一个issue,我们将尽可能的处理它.\n\nUse the navigation on the left to read comparisons of Vagrant\nversus similar software.\n\n使用左侧导航栏去阅读Vagrant与相似软件的比较</code></pre><h3 id=\"CLI-Tools\"><a href=\"#CLI-Tools\" class=\"headerlink\" title=\"CLI Tools\"></a>CLI Tools</h3><h4 id=\"Vagrant-vs-CLI-Tools\"><a href=\"#Vagrant-vs-CLI-Tools\" class=\"headerlink\" title=\"Vagrant vs CLI Tools\"></a>Vagrant vs CLI Tools</h4><pre><code>Virtualization software like VirtualBox and VMware come with\ncommand line utilities for managing the lifecycle of machines\non their platform.Many people make use of these utilties for \nmanaging the lifecycle of machines on their platform.Many people\nmake use of these utilities to write their own automation.\nVagrant actually uses many of these utilties internally.\n\n虚拟化软件如VirtualBox和VMware,带有命令行工具来管理平台上的机器的生命\n周期.许多人使用这些工具来写他们自己的自动化程序.Vagrant实际上在内部用了\n很多这样的工具.\n\nThe difference between these CLI tool and Vagrant is that \nVagrant builds on top of these utilties in a number of ways \nwhile still providing a consistent workflow.Vagrant supports\nmultiple provisioners to setup the machine,automatic SSH setup,\ncreating HTTP tunnels into your development environment,and more.\nAll of these can be configured using a single simple configuration\nfile.\n\n这些CLI工具与Vagrant的区别在于,Vagrant以多种方式在这些实用程序之上\n构建,同时仍然提供一致的工作流.Vagrant 支持多种同步文件夹类型,设置机器\n的多个提供程序 自动SSH设置 创建多开发环境中的HTTP隧道等.所有这些都可以\n使用一个简单的配置文件来配置.\n\nVagrant still has a number of improvements over manual scripting\neven if you ignore all the higher-level features Vagrant provides.\nThe command-line utilities provided by vitualization software\noften change each version or have subtle bugs with workarounds.\nVagrant automatically detects the version,uses the correct flags,\ncan work around known issues.So if you&apos;re using one version\nof VirtualBox and a co-worker is using a different version,\nVagrant will still work consistently.\n\nVagrant在手动脚本方面仍有许多改进.即使你忽略了流浪汉提供的所有高级特征.\n虚拟化软件提供的命令行工具经常改变每个版本或有变通方法的细微错误.\n流浪汉自动检测版本,使用正确的标志,能围绕已知问题工作.\n因此假如你使用一个版本的VirtualBox而另一个同事使用不同的版本,Vagrant\n仍然可以一致工作.\n\nFor highly-specifil workflows that don&apos;t change often.it can\nstill be beneficial to maintain custom scripts .Vagrant is \ntageted at building development environments but some \nadvanced users still use the ClI tools underneath to do \nother manual things.\n\n对于不经常改变的高度特定的工作流,维护自定义脚本仍然是有益的.Vagrant\n的目标是构建开发环境,但是一些高级用户仍然使用下面的CLI工具来完成\n其他手动操作.</code></pre><h3 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h3><h4 id=\"Vagrant-vs-Docker\"><a href=\"#Vagrant-vs-Docker\" class=\"headerlink\" title=\"Vagrant vs. Docker\"></a>Vagrant vs. Docker</h4><pre><code>Vagrant is a tool focused on providing a consistent\ndevelopment environment workflow across multiple \noperating systems.Docker is a container management\nthat can consistently run sofeware as long as a \ncontainerization system exists.\n\nVagrant是一个专注于跨多个操作系统提供一致的开发环境工作流的工具.\nDocker是一种容器管理,只要存在容器化系统,就可以始终如一地运行软件.\n\nContainers are generally more lightweight than virtual\nmachines,so starting and stopping containers is extremely\nfast. Most common development machines don&apos;t have a \ncontainerization system built-in, and Docker uses a \nvirtual machine with Linux installed to provide that.\n\n容器一般比虚拟机更轻量级,因此开启或停止容器是非常快的.大多数常见的\n开发及其没有内置化的容器系统,Doker使用安装了Linux的虚拟机来提供这\n一点.\n\nCurrently,Docker lacks support for certain operating\nsystems(such as BSD).if you target deployment is one\nof these operating systems,Docker will not provide \nthe same prodution parity as tool like Vagrant.Vagrant \nwill allow you to run a Windows development environment\non Mac or Linux,as well.\n\n目前,Docker缺乏对某些操作系统(如:BSD)的支持.如果你的目标是部署\n这些操作系统之一,那么Docker不会像Vagrant一样提供相同的一致产品.\nVagrant允许你在Mac或Linux上运行Windows开发环境.\n\nFor microservice heavy environments,Docker can be attractive\nbecause you can easily start a single Docker VM and start\nmany containers above that very quickly.This is a good use\ncase for Docker.Vagrant can do this as well with the Docker\nprovider.A primary benefit for Vagrant is a consistent\nworkflow but there are many cases where a pure-Docker\nworkflow does make sense.\n\nBoth Vagrant and Docker have a vast library of \ncommunity-contributed &quot;images&quot;or&quot;boxes&quot;to choose from.\n\n对于微服务繁重的环境,Docker可能很有吸引力,因为您可以单个Docker\nVM 并快速启动多个容器.这是Docker的一个很好的用例.Vagrant也可以\n使用Docker提供程序执行此操作.Vagrant的主要好处是一致的工作流程,\n但在很多情况下,纯Docker工作流程确实有意义.\n\nVagrant和Docker都拥有庞大的社区贡献&quot;图像&quot;或&quot;盒子&quot;库供您选择.</code></pre><h3 id=\"Terraform\"><a href=\"#Terraform\" class=\"headerlink\" title=\"Terraform\"></a>Terraform</h3><h4 id=\"Vagrant-vs-Terraform\"><a href=\"#Vagrant-vs-Terraform\" class=\"headerlink\" title=\"Vagrant vs. Terraform\"></a>Vagrant vs. Terraform</h4>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"官网-https-www-vagrantup-com\"><a href=\"#官网-https-www-vagrantup-com\" class=\"headerlink\" title=\"官网: https://www.vagrantup.com/\"></a>官网: <a href=\"https://www.vagrantup.com/\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/</a></h2><h1 id=\"intro-介绍\"><a href=\"#intro-介绍\" class=\"headerlink\" title=\"intro 介绍\"></a>intro 介绍</h1><h2 id=\"what-is-vagrant-流浪汉是什么\"><a href=\"#what-is-vagrant-流浪汉是什么\" class=\"headerlink\" title=\"what is vagrant (流浪汉是什么)\"></a>what is vagrant (流浪汉是什么)</h2><h3 id=\"Introduction-to-Vagrant-流浪汉简介\"><a href=\"#Introduction-to-Vagrant-流浪汉简介\" class=\"headerlink\" title=\"Introduction to Vagrant (流浪汉简介)\"></a>Introduction to Vagrant (流浪汉简介)</h3><pre><code>Vagrant is a tool for building and managing virtual machine\nenvironments in a single workflow. With an easy-to-use workflow\nand focus on automaiton, Vagrant lowers development setup time,\nincreases production parity,and makes the &quot;works on my machine&quot;\nexcuse a relic of the past.\n\nif you are already familiar with the basics of Vagrant, the \ndocumentation provides a better reference build for all available\nfeatures and internals.\n\nVagrant是一种在单个工作流程中构建和管理虚拟环境的工具.通过易于使用的工\n作流程并专注于自动化,Vagrant降低了开发环境的设置时间,提高了生产平价,\n并使&quot;在我的假期上工作&quot;称为过去的遗留物.\n\n如果您已经熟悉Vagrant的基础知识,那么该文档可为所有可用功能和内部提供\n更好的参考构建.</code></pre><h3 id=\"why-Vagrant-为什么选择Vagrant\"><a href=\"#why-Vagrant-为什么选择Vagrant\" class=\"headerlink\" title=\"why Vagrant (为什么选择Vagrant)\"></a>why Vagrant (为什么选择Vagrant)</h3><pre><code>vagrant provides easy to configure,reproducible,and portable\nwork environments built on top of industry-standard technology\nand controlled by a single consistent workflow to help maximize \nthe productivity and flexibility of you and your team.\n\nTo achieve its magic,Vagrant stands on the shoulders of giants.\nMachines are provisioned on top of VirtualBox,VMware,AWS,or any\nother provider,Then,Industry-standard providioning tools such\nas shell scripts,Chef,or Puppet,can automatically install and\nconfigure software on the virtual machine.\n\nVagrant 提供易于配置,可重复和便携的工作环境,基于行和标准技术构建,并由单一\n一致的工作流程控制,以帮助您和您的团队最大限度地提高生成力和灵魂性.\n\n为了实现其魔力,Vagrant站在巨人的肩膀上.在VirtualBox,VMware,AWS或\n任何其他提供商之上配置计算机.然后,行业标准配置工具(如shell脚本,Chef或\nPuppet)可以在虚拟机上自动安装和配置软件.</code></pre><h3 id=\"For-Developers-对于开发者\"><a href=\"#For-Developers-对于开发者\" class=\"headerlink\" title=\"For Developers (对于开发者)\"></a>For Developers (对于开发者)</h3><pre><code>if you are a developer,Vagarnt will isolate dependencies and\ntheir configuration within a single disposable,consistent \nenvironment,without sacrificing any of the tools you are\nused to working with(editors,browsers,debuggers,etc.).Once\nyou or someone else creates a single Vagrantfile,you just \nneed to vagrant up and everything is installed and configured\nfor you to work .Other members of your team create their\ndevelopment environments form the same configuration,so \nwhether you are working on Linux,Mac OSX,or Windows,all\nyour team members are running code in the same environment\n,against the same dependencies,al configured the same way.\nSay goodbye to &quot;works on my machine&quot;bugs.\n\n如果您是一位开发人员,Vagrant将在一个一致的环境中隔离依赖及其配置,\n而不会牺牲您习惯使用的任何工具(编辑器,浏览器,调试器等).一旦您或其他人\n创建了单个Vagrant文件,您只需要运行vagrant up命令安装并配置所有内容\n即可使用.团队的其他成员使用相同的配置创建他们的开发环境,因此无论您是在\nLinux,Mac OS X还是Windows上工作,您的所有团队成员都在同一环境中运行\n代码,针对相同的依赖项,所有组件都配置相同办法.告别&quot;在我的机器上工作&quot;的\n错误.</code></pre><h3 id=\"For-Operators-对于运维\"><a href=\"#For-Operators-对于运维\" class=\"headerlink\" title=\"For Operators (对于运维)\"></a>For Operators (对于运维)</h3><pre><code>if you are an operations engineer or DevOps engineer,Vagrant\ngives you a disposable environment and consisitent workflow\nfor developing and testing infrastructure management scripts.\nyou can quickly test things like shell scripts,Chef cookbooks,\nPuppet modules,and more using local virtualization such as \nVirtualBox or VMware.Then,with the same configuration,you can\ntest these scripts on remote clouds such as AWS or RackSpace \nwith the same workflow.Ditch your custom scripts to recycle\nEC2 instances,stop juggling SSH prompts to various machines,\nand start using Vagrant to bring sanity to your life.\n\n如果你是运维工程师或者开发运维工程师,Vagrant为您提供一次性环境和一致的\n工作流程,用于开发和测试基础架构管理脚本.您可以使用VirtualBox或VMware\n等本地虚拟化快速测试shell脚本,Chef cookbook,Puppet模块等内容.然后\n,使用相同的配置,您可以使用相同的工作流在远程云(如AWS或RackSpace)上测试\n这些脚本.抛弃自定义脚本以回收EC2实例,停止将SSH提示传递给各种计算机,并\n开始使用Vagrant为您的生活带来理智.</code></pre><h3 id=\"For-Designers-对于设计\"><a href=\"#For-Designers-对于设计\" class=\"headerlink\" title=\"For Designers(对于设计)\"></a>For Designers(对于设计)</h3><pre><code>If you are a designer,Vagrant will automatically set everything\nup that is required for that web app in order for you to focus\non doing what you do best:design.Once a developer configures\nVagrant,you do not need to worry about how to get that app running\never again.No more bothering other developers to help you fix\nyour environment so you can test designs.Just check out the code\n,vagrant up,and start designing.\n\n如果你是个设计师,Vagrant 将自动设置该web应用程序所需的所有内容,以便你\n集中精力做你最擅长的事情:设计.当开发人员配置了一次Vagrant,你再也不用\n担心怎样去运行应用程序.不必再打扰其他开发人员来帮助你修复环境,因此你能\n测试你的设计.仅打出单词,vagrant up ,就可以开始设计了.</code></pre><h3 id=\"For-Everyone-对于任何人\"><a href=\"#For-Everyone-对于任何人\" class=\"headerlink\" title=\"For Everyone(对于任何人)\"></a>For Everyone(对于任何人)</h3><pre><code>Vagrant is designed for erveyone as the easiest and fastest\nway to create a virtualized environment!\n\nVagrant 的设计对任何人来说都是最简单最快速的获取虚拟环境的方式.</code></pre><h2 id=\"Vagrant-vs-Other-Software-Vagrant-与其他软件的对比\"><a href=\"#Vagrant-vs-Other-Software-Vagrant-与其他软件的对比\" class=\"headerlink\" title=\"Vagrant vs. Other Software (Vagrant 与其他软件的对比)\"></a>Vagrant vs. Other Software (Vagrant 与其他软件的对比)</h2><pre><code>Vagrant is not the only tool to manage virtual machines\nand development environments.This section compares Vagrant\nto these other software choices.\n\nVagrant 不是唯一管理虚拟机和开发环境的工具,本节将比较Vagrant与其他\n软件以便选择.\n\nDue to the bias of the comparisons,we attempt to only use\nfacts.If you find something that is invalid or out of date\nin the comparisons,please open an issue and we&apos;ll address\nit as soon as possible.\n\n由于比较的偏颇,我们试图只用事实说话,在比较中假如你发现了无效的或者过期\n的内容,请开启一个issue,我们将尽可能的处理它.\n\nUse the navigation on the left to read comparisons of Vagrant\nversus similar software.\n\n使用左侧导航栏去阅读Vagrant与相似软件的比较</code></pre><h3 id=\"CLI-Tools\"><a href=\"#CLI-Tools\" class=\"headerlink\" title=\"CLI Tools\"></a>CLI Tools</h3><h4 id=\"Vagrant-vs-CLI-Tools\"><a href=\"#Vagrant-vs-CLI-Tools\" class=\"headerlink\" title=\"Vagrant vs CLI Tools\"></a>Vagrant vs CLI Tools</h4><pre><code>Virtualization software like VirtualBox and VMware come with\ncommand line utilities for managing the lifecycle of machines\non their platform.Many people make use of these utilties for \nmanaging the lifecycle of machines on their platform.Many people\nmake use of these utilities to write their own automation.\nVagrant actually uses many of these utilties internally.\n\n虚拟化软件如VirtualBox和VMware,带有命令行工具来管理平台上的机器的生命\n周期.许多人使用这些工具来写他们自己的自动化程序.Vagrant实际上在内部用了\n很多这样的工具.\n\nThe difference between these CLI tool and Vagrant is that \nVagrant builds on top of these utilties in a number of ways \nwhile still providing a consistent workflow.Vagrant supports\nmultiple provisioners to setup the machine,automatic SSH setup,\ncreating HTTP tunnels into your development environment,and more.\nAll of these can be configured using a single simple configuration\nfile.\n\n这些CLI工具与Vagrant的区别在于,Vagrant以多种方式在这些实用程序之上\n构建,同时仍然提供一致的工作流.Vagrant 支持多种同步文件夹类型,设置机器\n的多个提供程序 自动SSH设置 创建多开发环境中的HTTP隧道等.所有这些都可以\n使用一个简单的配置文件来配置.\n\nVagrant still has a number of improvements over manual scripting\neven if you ignore all the higher-level features Vagrant provides.\nThe command-line utilities provided by vitualization software\noften change each version or have subtle bugs with workarounds.\nVagrant automatically detects the version,uses the correct flags,\ncan work around known issues.So if you&apos;re using one version\nof VirtualBox and a co-worker is using a different version,\nVagrant will still work consistently.\n\nVagrant在手动脚本方面仍有许多改进.即使你忽略了流浪汉提供的所有高级特征.\n虚拟化软件提供的命令行工具经常改变每个版本或有变通方法的细微错误.\n流浪汉自动检测版本,使用正确的标志,能围绕已知问题工作.\n因此假如你使用一个版本的VirtualBox而另一个同事使用不同的版本,Vagrant\n仍然可以一致工作.\n\nFor highly-specifil workflows that don&apos;t change often.it can\nstill be beneficial to maintain custom scripts .Vagrant is \ntageted at building development environments but some \nadvanced users still use the ClI tools underneath to do \nother manual things.\n\n对于不经常改变的高度特定的工作流,维护自定义脚本仍然是有益的.Vagrant\n的目标是构建开发环境,但是一些高级用户仍然使用下面的CLI工具来完成\n其他手动操作.</code></pre><h3 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h3><h4 id=\"Vagrant-vs-Docker\"><a href=\"#Vagrant-vs-Docker\" class=\"headerlink\" title=\"Vagrant vs. Docker\"></a>Vagrant vs. Docker</h4><pre><code>Vagrant is a tool focused on providing a consistent\ndevelopment environment workflow across multiple \noperating systems.Docker is a container management\nthat can consistently run sofeware as long as a \ncontainerization system exists.\n\nVagrant是一个专注于跨多个操作系统提供一致的开发环境工作流的工具.\nDocker是一种容器管理,只要存在容器化系统,就可以始终如一地运行软件.\n\nContainers are generally more lightweight than virtual\nmachines,so starting and stopping containers is extremely\nfast. Most common development machines don&apos;t have a \ncontainerization system built-in, and Docker uses a \nvirtual machine with Linux installed to provide that.\n\n容器一般比虚拟机更轻量级,因此开启或停止容器是非常快的.大多数常见的\n开发及其没有内置化的容器系统,Doker使用安装了Linux的虚拟机来提供这\n一点.\n\nCurrently,Docker lacks support for certain operating\nsystems(such as BSD).if you target deployment is one\nof these operating systems,Docker will not provide \nthe same prodution parity as tool like Vagrant.Vagrant \nwill allow you to run a Windows development environment\non Mac or Linux,as well.\n\n目前,Docker缺乏对某些操作系统(如:BSD)的支持.如果你的目标是部署\n这些操作系统之一,那么Docker不会像Vagrant一样提供相同的一致产品.\nVagrant允许你在Mac或Linux上运行Windows开发环境.\n\nFor microservice heavy environments,Docker can be attractive\nbecause you can easily start a single Docker VM and start\nmany containers above that very quickly.This is a good use\ncase for Docker.Vagrant can do this as well with the Docker\nprovider.A primary benefit for Vagrant is a consistent\nworkflow but there are many cases where a pure-Docker\nworkflow does make sense.\n\nBoth Vagrant and Docker have a vast library of \ncommunity-contributed &quot;images&quot;or&quot;boxes&quot;to choose from.\n\n对于微服务繁重的环境,Docker可能很有吸引力,因为您可以单个Docker\nVM 并快速启动多个容器.这是Docker的一个很好的用例.Vagrant也可以\n使用Docker提供程序执行此操作.Vagrant的主要好处是一致的工作流程,\n但在很多情况下,纯Docker工作流程确实有意义.\n\nVagrant和Docker都拥有庞大的社区贡献&quot;图像&quot;或&quot;盒子&quot;库供您选择.</code></pre><h3 id=\"Terraform\"><a href=\"#Terraform\" class=\"headerlink\" title=\"Terraform\"></a>Terraform</h3><h4 id=\"Vagrant-vs-Terraform\"><a href=\"#Vagrant-vs-Terraform\" class=\"headerlink\" title=\"Vagrant vs. Terraform\"></a>Vagrant vs. Terraform</h4>"},{"title":"git回滚已经PUSH的内容","date":"2019-08-09T03:08:24.000Z","_content":"git status \n\ngit log\n\ngit reset --hard 21e5af0fd58a456caa2727934e0aaf00\n\ngit push origin 分支 --force \n\n\n\n[参考](https://blog.csdn.net/guozhaohui628/article/details/78922946)\n\n","source":"_posts/git回滚已经PUSH的内容.md","raw":"---\ntitle: git回滚已经PUSH的内容\ndate: 2019-08-09 11:08:24\ntags: [git ,回滚]\n---\ngit status \n\ngit log\n\ngit reset --hard 21e5af0fd58a456caa2727934e0aaf00\n\ngit push origin 分支 --force \n\n\n\n[参考](https://blog.csdn.net/guozhaohui628/article/details/78922946)\n\n","slug":"git回滚已经PUSH的内容","published":1,"updated":"2019-09-27T08:27:08.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139ced0000wojfyex6jrb21","content":"<p>git status </p>\n<p>git log</p>\n<p>git reset –hard 21e5af0fd58a456caa2727934e0aaf00</p>\n<p>git push origin 分支 –force </p>\n<p><a href=\"https://blog.csdn.net/guozhaohui628/article/details/78922946\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>git status </p>\n<p>git log</p>\n<p>git reset –hard 21e5af0fd58a456caa2727934e0aaf00</p>\n<p>git push origin 分支 –force </p>\n<p><a href=\"https://blog.csdn.net/guozhaohui628/article/details/78922946\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n"},{"title":"hex 编码","date":"2019-08-27T07:17:19.000Z","_content":"\n    \n","source":"_posts/hex-编码.md","raw":"---\ntitle: hex 编码\ndate: 2019-08-27 15:17:19\ntags: [编码,hex,16进制]\n---\n\n    \n","slug":"hex-编码","published":1,"updated":"2019-09-27T08:27:08.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139ced0000xojfyfvgobzpy","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2019-09-27T08:27:08.035Z","updated":"2019-09-27T08:27:08.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139ced1000yojfyonta9pbz","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"hexo插入图片","date":"2019-09-06T02:26:13.000Z","_content":"* 当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。\n  \n  ![](/images/image.jpg)\n\n* 图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。\n\n\n    post_asset_folder: true\n\n将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。\n\n    _posts/post_name/image.jpg\n    1\n    ![](image.jpg)\n    \n\n[参考] (https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/)","source":"_posts/hexo插入图片.md","raw":"---\ntitle: hexo插入图片\ndate: 2019-09-06 10:26:13\ntags: [hexo]\ncategories: [hexo]\n---\n* 当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。\n  \n  ![](/images/image.jpg)\n\n* 图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。\n\n\n    post_asset_folder: true\n\n将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。\n\n    _posts/post_name/image.jpg\n    1\n    ![](image.jpg)\n    \n\n[参考] (https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/)","slug":"hexo插入图片","published":1,"updated":"2019-09-27T08:27:08.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139ced1000zojfy5zknr7ck","content":"<ul>\n<li><p>当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。</p>\n<p><img src=\"/images/image.jpg\" alt></p>\n</li>\n<li><p>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。</p>\n</li>\n</ul>\n<pre><code>post_asset_folder: true</code></pre><p>将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。</p>\n<pre><code>_posts/post_name/image.jpg\n1\n![](image.jpg)</code></pre><p>[参考] (<a href=\"https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/\" target=\"_blank\" rel=\"noopener\">https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/</a>)</p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。</p>\n<p><img src=\"/images/image.jpg\" alt></p>\n</li>\n<li><p>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。</p>\n</li>\n</ul>\n<pre><code>post_asset_folder: true</code></pre><p>将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。</p>\n<pre><code>_posts/post_name/image.jpg\n1\n![](image.jpg)</code></pre><p>[参考] (<a href=\"https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/\" target=\"_blank\" rel=\"noopener\">https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/</a>)</p>\n"},{"title":"hhkb配置Mac","date":"2018-05-07T03:04:52.000Z","_content":"\n## 引用https://www.douban.com/note/657191565/\n\nPro2,总共有60个 按键\n\n方向键为\n\n上: Fn + [\n\n下: Fn + /\n\n左: Fn + ;\n\n右: Fn + '\n\n\n光标移动的快捷键就和Mac系统一致:\n\n上一行: ctrl+p\n\n下一行: ctrl+n\n\n跳到行首: ctrl+a\n\n\n\n\n\n","source":"_posts/hhkb配置Mac.md","raw":"---\ntitle: hhkb配置Mac\ndate: 2018-05-07 11:04:52\ntags: [键盘,hhkb]\n---\n\n## 引用https://www.douban.com/note/657191565/\n\nPro2,总共有60个 按键\n\n方向键为\n\n上: Fn + [\n\n下: Fn + /\n\n左: Fn + ;\n\n右: Fn + '\n\n\n光标移动的快捷键就和Mac系统一致:\n\n上一行: ctrl+p\n\n下一行: ctrl+n\n\n跳到行首: ctrl+a\n\n\n\n\n\n","slug":"hhkb配置Mac","published":1,"updated":"2019-09-27T08:27:08.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139ced20010ojfyryww0g0r","content":"<h2 id=\"引用https-www-douban-com-note-657191565\"><a href=\"#引用https-www-douban-com-note-657191565\" class=\"headerlink\" title=\"引用https://www.douban.com/note/657191565/\"></a>引用<a href=\"https://www.douban.com/note/657191565/\" target=\"_blank\" rel=\"noopener\">https://www.douban.com/note/657191565/</a></h2><p>Pro2,总共有60个 按键</p>\n<p>方向键为</p>\n<p>上: Fn + [</p>\n<p>下: Fn + /</p>\n<p>左: Fn + ;</p>\n<p>右: Fn + ‘</p>\n<p>光标移动的快捷键就和Mac系统一致:</p>\n<p>上一行: ctrl+p</p>\n<p>下一行: ctrl+n</p>\n<p>跳到行首: ctrl+a</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"引用https-www-douban-com-note-657191565\"><a href=\"#引用https-www-douban-com-note-657191565\" class=\"headerlink\" title=\"引用https://www.douban.com/note/657191565/\"></a>引用<a href=\"https://www.douban.com/note/657191565/\" target=\"_blank\" rel=\"noopener\">https://www.douban.com/note/657191565/</a></h2><p>Pro2,总共有60个 按键</p>\n<p>方向键为</p>\n<p>上: Fn + [</p>\n<p>下: Fn + /</p>\n<p>左: Fn + ;</p>\n<p>右: Fn + ‘</p>\n<p>光标移动的快捷键就和Mac系统一致:</p>\n<p>上一行: ctrl+p</p>\n<p>下一行: ctrl+n</p>\n<p>跳到行首: ctrl+a</p>\n"},{"title":"homestead 安装PHP mongo 扩展","date":"2018-12-17T11:51:52.000Z","_content":"\n\n# 解决痛点: homestead多个PHP版本,某个版本安装mongo扩展\n\n## 1. 进入虚拟机\n\n    vagrant ssh\n    \n## 2. 切换到管理员\n\n    sudo su     \n    \n## 3. 查看PHP版本路径 \n\n    // 选择你要安装的PHP版本(我是PHP5.6)\n    php --ini \n    或\n    find / -name php.ini\n    返回\n    /etc/php/7.1/cli/php.ini\n    /etc/php/7.1/fpm/php.ini\n    /etc/php/7.2/cli/php.ini\n    /etc/php/7.2/fpm/php.ini\n    /etc/php/7.0/cli/php.ini\n    /etc/php/7.0/fpm/php.ini\n    /etc/php/5.6/cli/php.ini\n    /etc/php/5.6/fpm/php.ini\n    \n## 4. 进入工作目录(这个随意,我习惯进入/etc/php/5.6)    \n\n    cd /etc/php/5.6\n    \n## 5.下载php mongo扩展  \n\n    git clone https://github.com/mongodb/mongo-php-driver-legacy.git\n    \n## 6. 进入下载的目录\n\n    cd mongo-php-driver-legacy/\n    \n## 7. 选择对应的扩展\n\n    // 参考文档\n    https://docs.mongodb.com/ecosystem/drivers/php/#drivers\n    \n    git branch -a\n    \n    git checkout v1.6\n    \n## 8. 编译PHP的mongo扩展\n\n    //（不同php版本的情况下phpize版本不同）\n    /usr/bin/phpize5.6 \n     \n    //（这里边也需要根据情况指定php-config的版本，且和phpize的版本保持一致。）\n    ./configure --with-php-config=/usr/bin/php-config5.6 \n\n    make && make install \n\n*  编译完成后，mongo的php扩展在module目录中，它的文件名是mongo.so*\n\n## 9. 查看php的extension_dir\n\n    /usr/bin/php5.6 -i|grep extension_dir\n    \n    返回 extension_dir => /usr/lib/php/20131226 => /usr/lib/php/20131226\n    \n* 这说明php的扩展目录是/usr/lib/php/20131226\n* 或者你用phpinfo()输出一个页面，在里面找extension_dir也可以找到*\n    \n## 10. 把mongo.so扩展模块移入php扩展目录中 \n\n    mv ./module/mongo.so /usr/lib/php/20131226  \n    \n* 注意，前提要求当前工作目录是在刚才编译的mongo-php-driver-legacy目录中\n\n## 11. 添加php配置文件的ini文件\n\n    sudo touch /etc/php/5.6/fpm/conf.d/20-mongo.ini\n    \n## 12. 使用vi编辑器写入如下内容\n\n    vim /etc/php/5.6/fpm/conf.d/20-mongo.ini\n    \n    extension=mongo.so\n    \n* 记得使用vi编辑器时使用：wq命令保存\n\n## 13. 重启PHP\n\n    service php5.6-fpm restart\n    \n    \n\n\n      \n\n    \n    ","source":"_posts/homestead-安装PHP-mongo-扩展.md","raw":"---\ntitle: homestead 安装PHP mongo 扩展\ndate: 2018-12-17 19:51:52\ntags: [homestead,mongo,php扩展]\ncategories: \n- 技术\n---\n\n\n# 解决痛点: homestead多个PHP版本,某个版本安装mongo扩展\n\n## 1. 进入虚拟机\n\n    vagrant ssh\n    \n## 2. 切换到管理员\n\n    sudo su     \n    \n## 3. 查看PHP版本路径 \n\n    // 选择你要安装的PHP版本(我是PHP5.6)\n    php --ini \n    或\n    find / -name php.ini\n    返回\n    /etc/php/7.1/cli/php.ini\n    /etc/php/7.1/fpm/php.ini\n    /etc/php/7.2/cli/php.ini\n    /etc/php/7.2/fpm/php.ini\n    /etc/php/7.0/cli/php.ini\n    /etc/php/7.0/fpm/php.ini\n    /etc/php/5.6/cli/php.ini\n    /etc/php/5.6/fpm/php.ini\n    \n## 4. 进入工作目录(这个随意,我习惯进入/etc/php/5.6)    \n\n    cd /etc/php/5.6\n    \n## 5.下载php mongo扩展  \n\n    git clone https://github.com/mongodb/mongo-php-driver-legacy.git\n    \n## 6. 进入下载的目录\n\n    cd mongo-php-driver-legacy/\n    \n## 7. 选择对应的扩展\n\n    // 参考文档\n    https://docs.mongodb.com/ecosystem/drivers/php/#drivers\n    \n    git branch -a\n    \n    git checkout v1.6\n    \n## 8. 编译PHP的mongo扩展\n\n    //（不同php版本的情况下phpize版本不同）\n    /usr/bin/phpize5.6 \n     \n    //（这里边也需要根据情况指定php-config的版本，且和phpize的版本保持一致。）\n    ./configure --with-php-config=/usr/bin/php-config5.6 \n\n    make && make install \n\n*  编译完成后，mongo的php扩展在module目录中，它的文件名是mongo.so*\n\n## 9. 查看php的extension_dir\n\n    /usr/bin/php5.6 -i|grep extension_dir\n    \n    返回 extension_dir => /usr/lib/php/20131226 => /usr/lib/php/20131226\n    \n* 这说明php的扩展目录是/usr/lib/php/20131226\n* 或者你用phpinfo()输出一个页面，在里面找extension_dir也可以找到*\n    \n## 10. 把mongo.so扩展模块移入php扩展目录中 \n\n    mv ./module/mongo.so /usr/lib/php/20131226  \n    \n* 注意，前提要求当前工作目录是在刚才编译的mongo-php-driver-legacy目录中\n\n## 11. 添加php配置文件的ini文件\n\n    sudo touch /etc/php/5.6/fpm/conf.d/20-mongo.ini\n    \n## 12. 使用vi编辑器写入如下内容\n\n    vim /etc/php/5.6/fpm/conf.d/20-mongo.ini\n    \n    extension=mongo.so\n    \n* 记得使用vi编辑器时使用：wq命令保存\n\n## 13. 重启PHP\n\n    service php5.6-fpm restart\n    \n    \n\n\n      \n\n    \n    ","slug":"homestead-安装PHP-mongo-扩展","published":1,"updated":"2019-09-27T08:27:08.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139ced30011ojfyfefo4znf","content":"<h1 id=\"解决痛点-homestead多个PHP版本-某个版本安装mongo扩展\"><a href=\"#解决痛点-homestead多个PHP版本-某个版本安装mongo扩展\" class=\"headerlink\" title=\"解决痛点: homestead多个PHP版本,某个版本安装mongo扩展\"></a>解决痛点: homestead多个PHP版本,某个版本安装mongo扩展</h1><h2 id=\"1-进入虚拟机\"><a href=\"#1-进入虚拟机\" class=\"headerlink\" title=\"1. 进入虚拟机\"></a>1. 进入虚拟机</h2><pre><code>vagrant ssh</code></pre><h2 id=\"2-切换到管理员\"><a href=\"#2-切换到管理员\" class=\"headerlink\" title=\"2. 切换到管理员\"></a>2. 切换到管理员</h2><pre><code>sudo su     </code></pre><h2 id=\"3-查看PHP版本路径\"><a href=\"#3-查看PHP版本路径\" class=\"headerlink\" title=\"3. 查看PHP版本路径\"></a>3. 查看PHP版本路径</h2><pre><code>// 选择你要安装的PHP版本(我是PHP5.6)\nphp --ini \n或\nfind / -name php.ini\n返回\n/etc/php/7.1/cli/php.ini\n/etc/php/7.1/fpm/php.ini\n/etc/php/7.2/cli/php.ini\n/etc/php/7.2/fpm/php.ini\n/etc/php/7.0/cli/php.ini\n/etc/php/7.0/fpm/php.ini\n/etc/php/5.6/cli/php.ini\n/etc/php/5.6/fpm/php.ini</code></pre><h2 id=\"4-进入工作目录-这个随意-我习惯进入-etc-php-5-6\"><a href=\"#4-进入工作目录-这个随意-我习惯进入-etc-php-5-6\" class=\"headerlink\" title=\"4. 进入工作目录(这个随意,我习惯进入/etc/php/5.6)\"></a>4. 进入工作目录(这个随意,我习惯进入/etc/php/5.6)</h2><pre><code>cd /etc/php/5.6</code></pre><h2 id=\"5-下载php-mongo扩展\"><a href=\"#5-下载php-mongo扩展\" class=\"headerlink\" title=\"5.下载php mongo扩展\"></a>5.下载php mongo扩展</h2><pre><code>git clone https://github.com/mongodb/mongo-php-driver-legacy.git</code></pre><h2 id=\"6-进入下载的目录\"><a href=\"#6-进入下载的目录\" class=\"headerlink\" title=\"6. 进入下载的目录\"></a>6. 进入下载的目录</h2><pre><code>cd mongo-php-driver-legacy/</code></pre><h2 id=\"7-选择对应的扩展\"><a href=\"#7-选择对应的扩展\" class=\"headerlink\" title=\"7. 选择对应的扩展\"></a>7. 选择对应的扩展</h2><pre><code>// 参考文档\nhttps://docs.mongodb.com/ecosystem/drivers/php/#drivers\n\ngit branch -a\n\ngit checkout v1.6</code></pre><h2 id=\"8-编译PHP的mongo扩展\"><a href=\"#8-编译PHP的mongo扩展\" class=\"headerlink\" title=\"8. 编译PHP的mongo扩展\"></a>8. 编译PHP的mongo扩展</h2><pre><code>//（不同php版本的情况下phpize版本不同）\n/usr/bin/phpize5.6 \n\n//（这里边也需要根据情况指定php-config的版本，且和phpize的版本保持一致。）\n./configure --with-php-config=/usr/bin/php-config5.6 \n\nmake &amp;&amp; make install </code></pre><ul>\n<li>编译完成后，mongo的php扩展在module目录中，它的文件名是mongo.so*</li>\n</ul>\n<h2 id=\"9-查看php的extension-dir\"><a href=\"#9-查看php的extension-dir\" class=\"headerlink\" title=\"9. 查看php的extension_dir\"></a>9. 查看php的extension_dir</h2><pre><code>/usr/bin/php5.6 -i|grep extension_dir\n\n返回 extension_dir =&gt; /usr/lib/php/20131226 =&gt; /usr/lib/php/20131226</code></pre><ul>\n<li>这说明php的扩展目录是/usr/lib/php/20131226</li>\n<li>或者你用phpinfo()输出一个页面，在里面找extension_dir也可以找到*</li>\n</ul>\n<h2 id=\"10-把mongo-so扩展模块移入php扩展目录中\"><a href=\"#10-把mongo-so扩展模块移入php扩展目录中\" class=\"headerlink\" title=\"10. 把mongo.so扩展模块移入php扩展目录中\"></a>10. 把mongo.so扩展模块移入php扩展目录中</h2><pre><code>mv ./module/mongo.so /usr/lib/php/20131226  </code></pre><ul>\n<li>注意，前提要求当前工作目录是在刚才编译的mongo-php-driver-legacy目录中</li>\n</ul>\n<h2 id=\"11-添加php配置文件的ini文件\"><a href=\"#11-添加php配置文件的ini文件\" class=\"headerlink\" title=\"11. 添加php配置文件的ini文件\"></a>11. 添加php配置文件的ini文件</h2><pre><code>sudo touch /etc/php/5.6/fpm/conf.d/20-mongo.ini</code></pre><h2 id=\"12-使用vi编辑器写入如下内容\"><a href=\"#12-使用vi编辑器写入如下内容\" class=\"headerlink\" title=\"12. 使用vi编辑器写入如下内容\"></a>12. 使用vi编辑器写入如下内容</h2><pre><code>vim /etc/php/5.6/fpm/conf.d/20-mongo.ini\n\nextension=mongo.so</code></pre><ul>\n<li>记得使用vi编辑器时使用：wq命令保存</li>\n</ul>\n<h2 id=\"13-重启PHP\"><a href=\"#13-重启PHP\" class=\"headerlink\" title=\"13. 重启PHP\"></a>13. 重启PHP</h2><pre><code>service php5.6-fpm restart</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"解决痛点-homestead多个PHP版本-某个版本安装mongo扩展\"><a href=\"#解决痛点-homestead多个PHP版本-某个版本安装mongo扩展\" class=\"headerlink\" title=\"解决痛点: homestead多个PHP版本,某个版本安装mongo扩展\"></a>解决痛点: homestead多个PHP版本,某个版本安装mongo扩展</h1><h2 id=\"1-进入虚拟机\"><a href=\"#1-进入虚拟机\" class=\"headerlink\" title=\"1. 进入虚拟机\"></a>1. 进入虚拟机</h2><pre><code>vagrant ssh</code></pre><h2 id=\"2-切换到管理员\"><a href=\"#2-切换到管理员\" class=\"headerlink\" title=\"2. 切换到管理员\"></a>2. 切换到管理员</h2><pre><code>sudo su     </code></pre><h2 id=\"3-查看PHP版本路径\"><a href=\"#3-查看PHP版本路径\" class=\"headerlink\" title=\"3. 查看PHP版本路径\"></a>3. 查看PHP版本路径</h2><pre><code>// 选择你要安装的PHP版本(我是PHP5.6)\nphp --ini \n或\nfind / -name php.ini\n返回\n/etc/php/7.1/cli/php.ini\n/etc/php/7.1/fpm/php.ini\n/etc/php/7.2/cli/php.ini\n/etc/php/7.2/fpm/php.ini\n/etc/php/7.0/cli/php.ini\n/etc/php/7.0/fpm/php.ini\n/etc/php/5.6/cli/php.ini\n/etc/php/5.6/fpm/php.ini</code></pre><h2 id=\"4-进入工作目录-这个随意-我习惯进入-etc-php-5-6\"><a href=\"#4-进入工作目录-这个随意-我习惯进入-etc-php-5-6\" class=\"headerlink\" title=\"4. 进入工作目录(这个随意,我习惯进入/etc/php/5.6)\"></a>4. 进入工作目录(这个随意,我习惯进入/etc/php/5.6)</h2><pre><code>cd /etc/php/5.6</code></pre><h2 id=\"5-下载php-mongo扩展\"><a href=\"#5-下载php-mongo扩展\" class=\"headerlink\" title=\"5.下载php mongo扩展\"></a>5.下载php mongo扩展</h2><pre><code>git clone https://github.com/mongodb/mongo-php-driver-legacy.git</code></pre><h2 id=\"6-进入下载的目录\"><a href=\"#6-进入下载的目录\" class=\"headerlink\" title=\"6. 进入下载的目录\"></a>6. 进入下载的目录</h2><pre><code>cd mongo-php-driver-legacy/</code></pre><h2 id=\"7-选择对应的扩展\"><a href=\"#7-选择对应的扩展\" class=\"headerlink\" title=\"7. 选择对应的扩展\"></a>7. 选择对应的扩展</h2><pre><code>// 参考文档\nhttps://docs.mongodb.com/ecosystem/drivers/php/#drivers\n\ngit branch -a\n\ngit checkout v1.6</code></pre><h2 id=\"8-编译PHP的mongo扩展\"><a href=\"#8-编译PHP的mongo扩展\" class=\"headerlink\" title=\"8. 编译PHP的mongo扩展\"></a>8. 编译PHP的mongo扩展</h2><pre><code>//（不同php版本的情况下phpize版本不同）\n/usr/bin/phpize5.6 \n\n//（这里边也需要根据情况指定php-config的版本，且和phpize的版本保持一致。）\n./configure --with-php-config=/usr/bin/php-config5.6 \n\nmake &amp;&amp; make install </code></pre><ul>\n<li>编译完成后，mongo的php扩展在module目录中，它的文件名是mongo.so*</li>\n</ul>\n<h2 id=\"9-查看php的extension-dir\"><a href=\"#9-查看php的extension-dir\" class=\"headerlink\" title=\"9. 查看php的extension_dir\"></a>9. 查看php的extension_dir</h2><pre><code>/usr/bin/php5.6 -i|grep extension_dir\n\n返回 extension_dir =&gt; /usr/lib/php/20131226 =&gt; /usr/lib/php/20131226</code></pre><ul>\n<li>这说明php的扩展目录是/usr/lib/php/20131226</li>\n<li>或者你用phpinfo()输出一个页面，在里面找extension_dir也可以找到*</li>\n</ul>\n<h2 id=\"10-把mongo-so扩展模块移入php扩展目录中\"><a href=\"#10-把mongo-so扩展模块移入php扩展目录中\" class=\"headerlink\" title=\"10. 把mongo.so扩展模块移入php扩展目录中\"></a>10. 把mongo.so扩展模块移入php扩展目录中</h2><pre><code>mv ./module/mongo.so /usr/lib/php/20131226  </code></pre><ul>\n<li>注意，前提要求当前工作目录是在刚才编译的mongo-php-driver-legacy目录中</li>\n</ul>\n<h2 id=\"11-添加php配置文件的ini文件\"><a href=\"#11-添加php配置文件的ini文件\" class=\"headerlink\" title=\"11. 添加php配置文件的ini文件\"></a>11. 添加php配置文件的ini文件</h2><pre><code>sudo touch /etc/php/5.6/fpm/conf.d/20-mongo.ini</code></pre><h2 id=\"12-使用vi编辑器写入如下内容\"><a href=\"#12-使用vi编辑器写入如下内容\" class=\"headerlink\" title=\"12. 使用vi编辑器写入如下内容\"></a>12. 使用vi编辑器写入如下内容</h2><pre><code>vim /etc/php/5.6/fpm/conf.d/20-mongo.ini\n\nextension=mongo.so</code></pre><ul>\n<li>记得使用vi编辑器时使用：wq命令保存</li>\n</ul>\n<h2 id=\"13-重启PHP\"><a href=\"#13-重启PHP\" class=\"headerlink\" title=\"13. 重启PHP\"></a>13. 重启PHP</h2><pre><code>service php5.6-fpm restart</code></pre>"},{"title":"idea将普通Java项目改为Maven项目","date":"2019-09-04T02:05:05.000Z","_content":"\n# 方式 1\n\n1 在项目右键 Add Framework Support\n\n2 选择maven\n\n# 方式2\n\n1.右键工程文件，新建文件pom.xml，并填写好内容。\n\n2.在pom.xml 文件上右键 Add as Maven Project。\n\n3.idea自己导入maven。\n\n\n# 怎么在pom.xml中添加项目中libs下的jar呢，而不是从本地仓库中添加？\n\n1、首先将要添加的jar包复制到项目中的libs文件夹下\n\n2、然后在pom.xml中添加如下代码：\n\n\t\t<dependency>\n\t\t\t<groupId>htmlunit</groupId>\n\t\t\t<artifactId>htmlunit</artifactId>\n\t\t\t<version>2.21-OSGi</version>\n\t\t\t<scope>system</scope>\n\t\t\t<systemPath>${project.basedir}/libs/htmlunit-2.21-OSGi.jar</systemPath>\n\t\t</dependency>\n注意scope元素和systemPath元素，其中systemPath元素指定的就是jar包在项目中的路径。\n注意libs文件夹下的这个jar包不需要Add to Build Path\n\n[参考1](https://blog.csdn.net/zhengxiangwen/article/details/50734565)\n[参考2](https://blog.csdn.net/lcgoing/article/details/86928738)\n","source":"_posts/idea将普通Java项目改为Maven项目.md","raw":"---\ntitle: idea将普通Java项目改为Maven项目\ndate: 2019-09-04 10:05:05\ntags: [idea,java,maven]\ncategories: [java]\n---\n\n# 方式 1\n\n1 在项目右键 Add Framework Support\n\n2 选择maven\n\n# 方式2\n\n1.右键工程文件，新建文件pom.xml，并填写好内容。\n\n2.在pom.xml 文件上右键 Add as Maven Project。\n\n3.idea自己导入maven。\n\n\n# 怎么在pom.xml中添加项目中libs下的jar呢，而不是从本地仓库中添加？\n\n1、首先将要添加的jar包复制到项目中的libs文件夹下\n\n2、然后在pom.xml中添加如下代码：\n\n\t\t<dependency>\n\t\t\t<groupId>htmlunit</groupId>\n\t\t\t<artifactId>htmlunit</artifactId>\n\t\t\t<version>2.21-OSGi</version>\n\t\t\t<scope>system</scope>\n\t\t\t<systemPath>${project.basedir}/libs/htmlunit-2.21-OSGi.jar</systemPath>\n\t\t</dependency>\n注意scope元素和systemPath元素，其中systemPath元素指定的就是jar包在项目中的路径。\n注意libs文件夹下的这个jar包不需要Add to Build Path\n\n[参考1](https://blog.csdn.net/zhengxiangwen/article/details/50734565)\n[参考2](https://blog.csdn.net/lcgoing/article/details/86928738)\n","slug":"idea将普通Java项目改为Maven项目","published":1,"updated":"2019-09-27T08:27:08.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139ced40012ojfykbz37j4y","content":"<h1 id=\"方式-1\"><a href=\"#方式-1\" class=\"headerlink\" title=\"方式 1\"></a>方式 1</h1><p>1 在项目右键 Add Framework Support</p>\n<p>2 选择maven</p>\n<h1 id=\"方式2\"><a href=\"#方式2\" class=\"headerlink\" title=\"方式2\"></a>方式2</h1><p>1.右键工程文件，新建文件pom.xml，并填写好内容。</p>\n<p>2.在pom.xml 文件上右键 Add as Maven Project。</p>\n<p>3.idea自己导入maven。</p>\n<h1 id=\"怎么在pom-xml中添加项目中libs下的jar呢，而不是从本地仓库中添加？\"><a href=\"#怎么在pom-xml中添加项目中libs下的jar呢，而不是从本地仓库中添加？\" class=\"headerlink\" title=\"怎么在pom.xml中添加项目中libs下的jar呢，而不是从本地仓库中添加？\"></a>怎么在pom.xml中添加项目中libs下的jar呢，而不是从本地仓库中添加？</h1><p>1、首先将要添加的jar包复制到项目中的libs文件夹下</p>\n<p>2、然后在pom.xml中添加如下代码：</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;htmlunit&lt;/groupId&gt;\n    &lt;artifactId&gt;htmlunit&lt;/artifactId&gt;\n    &lt;version&gt;2.21-OSGi&lt;/version&gt;\n    &lt;scope&gt;system&lt;/scope&gt;\n    &lt;systemPath&gt;${project.basedir}/libs/htmlunit-2.21-OSGi.jar&lt;/systemPath&gt;\n&lt;/dependency&gt;</code></pre><p>注意scope元素和systemPath元素，其中systemPath元素指定的就是jar包在项目中的路径。<br>注意libs文件夹下的这个jar包不需要Add to Build Path</p>\n<p><a href=\"https://blog.csdn.net/zhengxiangwen/article/details/50734565\" target=\"_blank\" rel=\"noopener\">参考1</a><br><a href=\"https://blog.csdn.net/lcgoing/article/details/86928738\" target=\"_blank\" rel=\"noopener\">参考2</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"方式-1\"><a href=\"#方式-1\" class=\"headerlink\" title=\"方式 1\"></a>方式 1</h1><p>1 在项目右键 Add Framework Support</p>\n<p>2 选择maven</p>\n<h1 id=\"方式2\"><a href=\"#方式2\" class=\"headerlink\" title=\"方式2\"></a>方式2</h1><p>1.右键工程文件，新建文件pom.xml，并填写好内容。</p>\n<p>2.在pom.xml 文件上右键 Add as Maven Project。</p>\n<p>3.idea自己导入maven。</p>\n<h1 id=\"怎么在pom-xml中添加项目中libs下的jar呢，而不是从本地仓库中添加？\"><a href=\"#怎么在pom-xml中添加项目中libs下的jar呢，而不是从本地仓库中添加？\" class=\"headerlink\" title=\"怎么在pom.xml中添加项目中libs下的jar呢，而不是从本地仓库中添加？\"></a>怎么在pom.xml中添加项目中libs下的jar呢，而不是从本地仓库中添加？</h1><p>1、首先将要添加的jar包复制到项目中的libs文件夹下</p>\n<p>2、然后在pom.xml中添加如下代码：</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;htmlunit&lt;/groupId&gt;\n    &lt;artifactId&gt;htmlunit&lt;/artifactId&gt;\n    &lt;version&gt;2.21-OSGi&lt;/version&gt;\n    &lt;scope&gt;system&lt;/scope&gt;\n    &lt;systemPath&gt;${project.basedir}/libs/htmlunit-2.21-OSGi.jar&lt;/systemPath&gt;\n&lt;/dependency&gt;</code></pre><p>注意scope元素和systemPath元素，其中systemPath元素指定的就是jar包在项目中的路径。<br>注意libs文件夹下的这个jar包不需要Add to Build Path</p>\n<p><a href=\"https://blog.csdn.net/zhengxiangwen/article/details/50734565\" target=\"_blank\" rel=\"noopener\">参考1</a><br><a href=\"https://blog.csdn.net/lcgoing/article/details/86928738\" target=\"_blank\" rel=\"noopener\">参考2</a></p>\n"},{"title":"idea突然有些字母不显示","date":"2019-09-03T10:24:49.000Z","_content":"## 问题\n![](https://img-blog.csdn.net/20171031204114987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUGV0ZXJzaHVzaGVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n## 解决方案\n解决方案：更换idea字体，点击apply按钮即可正常显示\n![](https://liuyanzhao.com/wp-content/uploads/2018/10/WX20181011-211337@2x.png)\n\n[参考1](https://blog.csdn.net/Petershusheng/article/details/78407839)\n\n[参考2](https://liuyanzhao.com/8867.html)\n","source":"_posts/idea突然有些字母不显示.md","raw":"---\ntitle: idea突然有些字母不显示\ndate: 2019-09-03 18:24:49\ntags: [idea]\ncategories: [idea]\n---\n## 问题\n![](https://img-blog.csdn.net/20171031204114987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUGV0ZXJzaHVzaGVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n## 解决方案\n解决方案：更换idea字体，点击apply按钮即可正常显示\n![](https://liuyanzhao.com/wp-content/uploads/2018/10/WX20181011-211337@2x.png)\n\n[参考1](https://blog.csdn.net/Petershusheng/article/details/78407839)\n\n[参考2](https://liuyanzhao.com/8867.html)\n","slug":"idea突然有些字母不显示","published":1,"updated":"2019-09-27T08:27:08.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139ced40013ojfy2gj0dyjl","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p><img src=\"https://img-blog.csdn.net/20171031204114987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUGV0ZXJzaHVzaGVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt></p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>解决方案：更换idea字体，点击apply按钮即可正常显示<br><img src=\"https://liuyanzhao.com/wp-content/uploads/2018/10/WX20181011-211337@2x.png\" alt></p>\n<p><a href=\"https://blog.csdn.net/Petershusheng/article/details/78407839\" target=\"_blank\" rel=\"noopener\">参考1</a></p>\n<p><a href=\"https://liuyanzhao.com/8867.html\" target=\"_blank\" rel=\"noopener\">参考2</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p><img src=\"https://img-blog.csdn.net/20171031204114987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUGV0ZXJzaHVzaGVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt></p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>解决方案：更换idea字体，点击apply按钮即可正常显示<br><img src=\"https://liuyanzhao.com/wp-content/uploads/2018/10/WX20181011-211337@2x.png\" alt></p>\n<p><a href=\"https://blog.csdn.net/Petershusheng/article/details/78407839\" target=\"_blank\" rel=\"noopener\">参考1</a></p>\n<p><a href=\"https://liuyanzhao.com/8867.html\" target=\"_blank\" rel=\"noopener\">参考2</a></p>\n"},{"title":" java.io.EOFException","date":"2019-09-06T02:45:51.000Z","_content":"\nCaused by: java.io.EOFException: Can not read response from server. Expected to read 4 bytes, read 0 bytes before connection was unexpectedly lost.\n\n启动ssm项目报上述错误,查了一堆答案\n\n有说改 jdbc配置的,有说改数据库的\n顺便还改了下数据库\n    \n    show variables like  'wait_timeout';\n    \n    show global variables like  '%wait%';        \n    \n    set wait_timeout=86400;\n    \n问题都没有解决\n\n最终解决方案:\n\n可能是防火墙,翻墙软件等造成的\n\n    \n","source":"_posts/java-io-EOFException.md","raw":"---\ntitle: ' java.io.EOFException'\ndate: 2019-09-06 10:45:51\ntags: [java,异常,spring]\ncategories: [exception]\n---\n\nCaused by: java.io.EOFException: Can not read response from server. Expected to read 4 bytes, read 0 bytes before connection was unexpectedly lost.\n\n启动ssm项目报上述错误,查了一堆答案\n\n有说改 jdbc配置的,有说改数据库的\n顺便还改了下数据库\n    \n    show variables like  'wait_timeout';\n    \n    show global variables like  '%wait%';        \n    \n    set wait_timeout=86400;\n    \n问题都没有解决\n\n最终解决方案:\n\n可能是防火墙,翻墙软件等造成的\n\n    \n","slug":"java-io-EOFException","published":1,"updated":"2019-09-27T08:27:08.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139ced50014ojfy4xmtcq2u","content":"<p>Caused by: java.io.EOFException: Can not read response from server. Expected to read 4 bytes, read 0 bytes before connection was unexpectedly lost.</p>\n<p>启动ssm项目报上述错误,查了一堆答案</p>\n<p>有说改 jdbc配置的,有说改数据库的<br>顺便还改了下数据库</p>\n<pre><code>show variables like  &apos;wait_timeout&apos;;\n\nshow global variables like  &apos;%wait%&apos;;        \n\nset wait_timeout=86400;</code></pre><p>问题都没有解决</p>\n<p>最终解决方案:</p>\n<p>可能是防火墙,翻墙软件等造成的</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Caused by: java.io.EOFException: Can not read response from server. Expected to read 4 bytes, read 0 bytes before connection was unexpectedly lost.</p>\n<p>启动ssm项目报上述错误,查了一堆答案</p>\n<p>有说改 jdbc配置的,有说改数据库的<br>顺便还改了下数据库</p>\n<pre><code>show variables like  &apos;wait_timeout&apos;;\n\nshow global variables like  &apos;%wait%&apos;;        \n\nset wait_timeout=86400;</code></pre><p>问题都没有解决</p>\n<p>最终解决方案:</p>\n<p>可能是防火墙,翻墙软件等造成的</p>\n"},{"title":"learning-hexo","date":"2018-03-29T11:36:43.000Z","_content":"\n## this is a test\n\n- sdlfadf\n- sfadf\n- sdfad\n\n## chapter 1\n\n## chapter 2\n","source":"_posts/learning-hexo.md","raw":"---\ntitle: learning-hexo\ndate: 2018-03-29 19:36:43\ntags: hexo\n---\n\n## this is a test\n\n- sdlfadf\n- sfadf\n- sdfad\n\n## chapter 1\n\n## chapter 2\n","slug":"learning-hexo","published":1,"updated":"2019-09-27T08:27:08.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139ced60015ojfy5876e72h","content":"<h2 id=\"this-is-a-test\"><a href=\"#this-is-a-test\" class=\"headerlink\" title=\"this is a test\"></a>this is a test</h2><ul>\n<li>sdlfadf</li>\n<li>sfadf</li>\n<li>sdfad</li>\n</ul>\n<h2 id=\"chapter-1\"><a href=\"#chapter-1\" class=\"headerlink\" title=\"chapter 1\"></a>chapter 1</h2><h2 id=\"chapter-2\"><a href=\"#chapter-2\" class=\"headerlink\" title=\"chapter 2\"></a>chapter 2</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"this-is-a-test\"><a href=\"#this-is-a-test\" class=\"headerlink\" title=\"this is a test\"></a>this is a test</h2><ul>\n<li>sdlfadf</li>\n<li>sfadf</li>\n<li>sdfad</li>\n</ul>\n<h2 id=\"chapter-1\"><a href=\"#chapter-1\" class=\"headerlink\" title=\"chapter 1\"></a>chapter 1</h2><h2 id=\"chapter-2\"><a href=\"#chapter-2\" class=\"headerlink\" title=\"chapter 2\"></a>chapter 2</h2>"},{"title":"linux环境变量总结","date":"2018-05-28T05:42:14.000Z","_content":"\n## 引用https://www.jianshu.com/p/ac2bc0ad3d74\n\nLinux是一个多用户多任务的操作系统,可以在Linux中为不同的用户设置不同的运行环境,\n具体做法是设置不同用户的环境变量.\n\n## Linux环境变量分类\n\n一 按照生命周期来分,Linux环境变量可以分为两类:\n1 永久的:需要用户修改相关的配置文件,变量永久生效.\n2 临时的:用户利用export命令,在当前终端下声明环境变量,关闭shell终端失效.\n\n二 按照作用域来分,Linux环境变量可以分为:\n1 系统环境变量:系统环境变量对系统中的所有用户都有效.\n2 用户环境变量:顾名思义,这种类型的环境变量只对特定的用户有效.\n\n## Linux设置环境变量的方法\n\n一 在/etc/profile文件中增加变量,改变量将会对Linux下所有用户有效,并且是永久的.\n\nexample:\n\n    vim /etc/profile    \n    export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib\n    \n注意:修改文件后要想马上生效还要运行$ source ~/.bash_profile不然只能在下次\n重进此用户是生效.\n\n二 在用户目录下的.bash_profile文件中增加变量[对单一用户生效(永久的)]\n用vim ~/.bash_profile文件中增加变量,改变仅会对当前用户有效,并且是\"永久的\".\n\n    vim ~/.bash.profile\n    export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib\n注意:修改文件后要想马上生效还要运行$ source ~/.bash_profile不然只能在下次\n重进此用户时生效.\n\n三 直接运行export命令定义变量[只对当前shell(bash)有效(临时的),]\n在shell的命令行下直接使用   export 变量名=变量值\n定义变量，该变量只在当前的shell（BASH）或其子shell（BASH）下是有效的，\nshell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的\n话还需要重新定义。\n\n## Linux环境变量使用\n\n一 Linux中常见的环境变量有:\n\n* PATH :指定命令的搜索路径\n\n    \n    PATH声明用法:\n    PATH=$PATH:<PATH 1>:<PATH 2>:<PATH 3>:------:<PATH n>\n    export PATH\n    你可以自己加上指定的路径,中间用冒号隔开.环境变量更改后,在用户下次登录时生效.\n    echo $path 查看当前系统path路径\n    \n* HOME: 指定用户的主工作目录(即用户登陆到Linux系统中时,默认的用户目录)    \n* HISTSIZE: 指保存历史命令记录的条数.\n* LOGNAME: 指当前用户的登陆名.\n* HOSTNAME: 指定主机的名称,许多应用程序如果用到主机名的话,通常是从这个环境\n变量中来取得的\n* SHELL: 指当前用户用的是哪种shell.\n* LANG/LANGUGE: 和语言相关的环境变量,使用多种语言的用户可以修改此环境变量.\n* MAIL: 指当前用户的邮件存放目录.\n\n注意:上述变量的名字并不固定,如:HOSTNAME在某些Linux系统中可能设置成HOST\n\n二 Linux也提供了修改和查看环境变量的命令,下面通过几个实例来说明:\n\n* echo 显示某个环境变量值 echo $PATH\n* export 设置一个新的环境变量 export HELLO=\"hello\"(可以无引号)\n* env 显示所有环境变量\n* set 显示本地定义的shell变量\n* unset 清除环境变量 unset HELLO\n* readonly 设置只读环境变量 readonly HELLO\n\n三 C程序调用环境变量函数\n\n* getenv() 返回一个环境变量.\n* setenv() 设置一个环境变量.\n* unsetenv() 清除一个环境变量.\n\n    \n    \n","source":"_posts/linux环境变量总结.md","raw":"---\ntitle: linux环境变量总结\ndate: 2018-05-28 13:42:14\ntags: [Linux,环境变量]\ncategories: \n- linux\n---\n\n## 引用https://www.jianshu.com/p/ac2bc0ad3d74\n\nLinux是一个多用户多任务的操作系统,可以在Linux中为不同的用户设置不同的运行环境,\n具体做法是设置不同用户的环境变量.\n\n## Linux环境变量分类\n\n一 按照生命周期来分,Linux环境变量可以分为两类:\n1 永久的:需要用户修改相关的配置文件,变量永久生效.\n2 临时的:用户利用export命令,在当前终端下声明环境变量,关闭shell终端失效.\n\n二 按照作用域来分,Linux环境变量可以分为:\n1 系统环境变量:系统环境变量对系统中的所有用户都有效.\n2 用户环境变量:顾名思义,这种类型的环境变量只对特定的用户有效.\n\n## Linux设置环境变量的方法\n\n一 在/etc/profile文件中增加变量,改变量将会对Linux下所有用户有效,并且是永久的.\n\nexample:\n\n    vim /etc/profile    \n    export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib\n    \n注意:修改文件后要想马上生效还要运行$ source ~/.bash_profile不然只能在下次\n重进此用户是生效.\n\n二 在用户目录下的.bash_profile文件中增加变量[对单一用户生效(永久的)]\n用vim ~/.bash_profile文件中增加变量,改变仅会对当前用户有效,并且是\"永久的\".\n\n    vim ~/.bash.profile\n    export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib\n注意:修改文件后要想马上生效还要运行$ source ~/.bash_profile不然只能在下次\n重进此用户时生效.\n\n三 直接运行export命令定义变量[只对当前shell(bash)有效(临时的),]\n在shell的命令行下直接使用   export 变量名=变量值\n定义变量，该变量只在当前的shell（BASH）或其子shell（BASH）下是有效的，\nshell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的\n话还需要重新定义。\n\n## Linux环境变量使用\n\n一 Linux中常见的环境变量有:\n\n* PATH :指定命令的搜索路径\n\n    \n    PATH声明用法:\n    PATH=$PATH:<PATH 1>:<PATH 2>:<PATH 3>:------:<PATH n>\n    export PATH\n    你可以自己加上指定的路径,中间用冒号隔开.环境变量更改后,在用户下次登录时生效.\n    echo $path 查看当前系统path路径\n    \n* HOME: 指定用户的主工作目录(即用户登陆到Linux系统中时,默认的用户目录)    \n* HISTSIZE: 指保存历史命令记录的条数.\n* LOGNAME: 指当前用户的登陆名.\n* HOSTNAME: 指定主机的名称,许多应用程序如果用到主机名的话,通常是从这个环境\n变量中来取得的\n* SHELL: 指当前用户用的是哪种shell.\n* LANG/LANGUGE: 和语言相关的环境变量,使用多种语言的用户可以修改此环境变量.\n* MAIL: 指当前用户的邮件存放目录.\n\n注意:上述变量的名字并不固定,如:HOSTNAME在某些Linux系统中可能设置成HOST\n\n二 Linux也提供了修改和查看环境变量的命令,下面通过几个实例来说明:\n\n* echo 显示某个环境变量值 echo $PATH\n* export 设置一个新的环境变量 export HELLO=\"hello\"(可以无引号)\n* env 显示所有环境变量\n* set 显示本地定义的shell变量\n* unset 清除环境变量 unset HELLO\n* readonly 设置只读环境变量 readonly HELLO\n\n三 C程序调用环境变量函数\n\n* getenv() 返回一个环境变量.\n* setenv() 设置一个环境变量.\n* unsetenv() 清除一个环境变量.\n\n    \n    \n","slug":"linux环境变量总结","published":1,"updated":"2019-09-27T08:27:08.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139ced60016ojfyvd1p0tzq","content":"<h2 id=\"引用https-www-jianshu-com-p-ac2bc0ad3d74\"><a href=\"#引用https-www-jianshu-com-p-ac2bc0ad3d74\" class=\"headerlink\" title=\"引用https://www.jianshu.com/p/ac2bc0ad3d74\"></a>引用<a href=\"https://www.jianshu.com/p/ac2bc0ad3d74\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/ac2bc0ad3d74</a></h2><p>Linux是一个多用户多任务的操作系统,可以在Linux中为不同的用户设置不同的运行环境,<br>具体做法是设置不同用户的环境变量.</p>\n<h2 id=\"Linux环境变量分类\"><a href=\"#Linux环境变量分类\" class=\"headerlink\" title=\"Linux环境变量分类\"></a>Linux环境变量分类</h2><p>一 按照生命周期来分,Linux环境变量可以分为两类:<br>1 永久的:需要用户修改相关的配置文件,变量永久生效.<br>2 临时的:用户利用export命令,在当前终端下声明环境变量,关闭shell终端失效.</p>\n<p>二 按照作用域来分,Linux环境变量可以分为:<br>1 系统环境变量:系统环境变量对系统中的所有用户都有效.<br>2 用户环境变量:顾名思义,这种类型的环境变量只对特定的用户有效.</p>\n<h2 id=\"Linux设置环境变量的方法\"><a href=\"#Linux设置环境变量的方法\" class=\"headerlink\" title=\"Linux设置环境变量的方法\"></a>Linux设置环境变量的方法</h2><p>一 在/etc/profile文件中增加变量,改变量将会对Linux下所有用户有效,并且是永久的.</p>\n<p>example:</p>\n<pre><code>vim /etc/profile    \nexport CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib</code></pre><p>注意:修改文件后要想马上生效还要运行$ source ~/.bash_profile不然只能在下次<br>重进此用户是生效.</p>\n<p>二 在用户目录下的.bash_profile文件中增加变量[对单一用户生效(永久的)]<br>用vim ~/.bash_profile文件中增加变量,改变仅会对当前用户有效,并且是”永久的”.</p>\n<pre><code>vim ~/.bash.profile\nexport CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib</code></pre><p>注意:修改文件后要想马上生效还要运行$ source ~/.bash_profile不然只能在下次<br>重进此用户时生效.</p>\n<p>三 直接运行export命令定义变量[只对当前shell(bash)有效(临时的),]<br>在shell的命令行下直接使用   export 变量名=变量值<br>定义变量，该变量只在当前的shell（BASH）或其子shell（BASH）下是有效的，<br>shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的<br>话还需要重新定义。</p>\n<h2 id=\"Linux环境变量使用\"><a href=\"#Linux环境变量使用\" class=\"headerlink\" title=\"Linux环境变量使用\"></a>Linux环境变量使用</h2><p>一 Linux中常见的环境变量有:</p>\n<ul>\n<li>PATH :指定命令的搜索路径</li>\n</ul>\n<pre><code>PATH声明用法:\nPATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:------:&lt;PATH n&gt;\nexport PATH\n你可以自己加上指定的路径,中间用冒号隔开.环境变量更改后,在用户下次登录时生效.\necho $path 查看当前系统path路径</code></pre><ul>\n<li>HOME: 指定用户的主工作目录(即用户登陆到Linux系统中时,默认的用户目录)    </li>\n<li>HISTSIZE: 指保存历史命令记录的条数.</li>\n<li>LOGNAME: 指当前用户的登陆名.</li>\n<li>HOSTNAME: 指定主机的名称,许多应用程序如果用到主机名的话,通常是从这个环境<br>变量中来取得的</li>\n<li>SHELL: 指当前用户用的是哪种shell.</li>\n<li>LANG/LANGUGE: 和语言相关的环境变量,使用多种语言的用户可以修改此环境变量.</li>\n<li>MAIL: 指当前用户的邮件存放目录.</li>\n</ul>\n<p>注意:上述变量的名字并不固定,如:HOSTNAME在某些Linux系统中可能设置成HOST</p>\n<p>二 Linux也提供了修改和查看环境变量的命令,下面通过几个实例来说明:</p>\n<ul>\n<li>echo 显示某个环境变量值 echo $PATH</li>\n<li>export 设置一个新的环境变量 export HELLO=”hello”(可以无引号)</li>\n<li>env 显示所有环境变量</li>\n<li>set 显示本地定义的shell变量</li>\n<li>unset 清除环境变量 unset HELLO</li>\n<li>readonly 设置只读环境变量 readonly HELLO</li>\n</ul>\n<p>三 C程序调用环境变量函数</p>\n<ul>\n<li>getenv() 返回一个环境变量.</li>\n<li>setenv() 设置一个环境变量.</li>\n<li>unsetenv() 清除一个环境变量.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"引用https-www-jianshu-com-p-ac2bc0ad3d74\"><a href=\"#引用https-www-jianshu-com-p-ac2bc0ad3d74\" class=\"headerlink\" title=\"引用https://www.jianshu.com/p/ac2bc0ad3d74\"></a>引用<a href=\"https://www.jianshu.com/p/ac2bc0ad3d74\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/ac2bc0ad3d74</a></h2><p>Linux是一个多用户多任务的操作系统,可以在Linux中为不同的用户设置不同的运行环境,<br>具体做法是设置不同用户的环境变量.</p>\n<h2 id=\"Linux环境变量分类\"><a href=\"#Linux环境变量分类\" class=\"headerlink\" title=\"Linux环境变量分类\"></a>Linux环境变量分类</h2><p>一 按照生命周期来分,Linux环境变量可以分为两类:<br>1 永久的:需要用户修改相关的配置文件,变量永久生效.<br>2 临时的:用户利用export命令,在当前终端下声明环境变量,关闭shell终端失效.</p>\n<p>二 按照作用域来分,Linux环境变量可以分为:<br>1 系统环境变量:系统环境变量对系统中的所有用户都有效.<br>2 用户环境变量:顾名思义,这种类型的环境变量只对特定的用户有效.</p>\n<h2 id=\"Linux设置环境变量的方法\"><a href=\"#Linux设置环境变量的方法\" class=\"headerlink\" title=\"Linux设置环境变量的方法\"></a>Linux设置环境变量的方法</h2><p>一 在/etc/profile文件中增加变量,改变量将会对Linux下所有用户有效,并且是永久的.</p>\n<p>example:</p>\n<pre><code>vim /etc/profile    \nexport CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib</code></pre><p>注意:修改文件后要想马上生效还要运行$ source ~/.bash_profile不然只能在下次<br>重进此用户是生效.</p>\n<p>二 在用户目录下的.bash_profile文件中增加变量[对单一用户生效(永久的)]<br>用vim ~/.bash_profile文件中增加变量,改变仅会对当前用户有效,并且是”永久的”.</p>\n<pre><code>vim ~/.bash.profile\nexport CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib</code></pre><p>注意:修改文件后要想马上生效还要运行$ source ~/.bash_profile不然只能在下次<br>重进此用户时生效.</p>\n<p>三 直接运行export命令定义变量[只对当前shell(bash)有效(临时的),]<br>在shell的命令行下直接使用   export 变量名=变量值<br>定义变量，该变量只在当前的shell（BASH）或其子shell（BASH）下是有效的，<br>shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的<br>话还需要重新定义。</p>\n<h2 id=\"Linux环境变量使用\"><a href=\"#Linux环境变量使用\" class=\"headerlink\" title=\"Linux环境变量使用\"></a>Linux环境变量使用</h2><p>一 Linux中常见的环境变量有:</p>\n<ul>\n<li>PATH :指定命令的搜索路径</li>\n</ul>\n<pre><code>PATH声明用法:\nPATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:------:&lt;PATH n&gt;\nexport PATH\n你可以自己加上指定的路径,中间用冒号隔开.环境变量更改后,在用户下次登录时生效.\necho $path 查看当前系统path路径</code></pre><ul>\n<li>HOME: 指定用户的主工作目录(即用户登陆到Linux系统中时,默认的用户目录)    </li>\n<li>HISTSIZE: 指保存历史命令记录的条数.</li>\n<li>LOGNAME: 指当前用户的登陆名.</li>\n<li>HOSTNAME: 指定主机的名称,许多应用程序如果用到主机名的话,通常是从这个环境<br>变量中来取得的</li>\n<li>SHELL: 指当前用户用的是哪种shell.</li>\n<li>LANG/LANGUGE: 和语言相关的环境变量,使用多种语言的用户可以修改此环境变量.</li>\n<li>MAIL: 指当前用户的邮件存放目录.</li>\n</ul>\n<p>注意:上述变量的名字并不固定,如:HOSTNAME在某些Linux系统中可能设置成HOST</p>\n<p>二 Linux也提供了修改和查看环境变量的命令,下面通过几个实例来说明:</p>\n<ul>\n<li>echo 显示某个环境变量值 echo $PATH</li>\n<li>export 设置一个新的环境变量 export HELLO=”hello”(可以无引号)</li>\n<li>env 显示所有环境变量</li>\n<li>set 显示本地定义的shell变量</li>\n<li>unset 清除环境变量 unset HELLO</li>\n<li>readonly 设置只读环境变量 readonly HELLO</li>\n</ul>\n<p>三 C程序调用环境变量函数</p>\n<ul>\n<li>getenv() 返回一个环境变量.</li>\n<li>setenv() 设置一个环境变量.</li>\n<li>unsetenv() 清除一个环境变量.</li>\n</ul>\n"},{"title":"mac上解决java.rmi.server.ExportException- Port already in use- 1099; nested exception is- java.net.Bi","date":"2019-09-09T10:39:14.000Z","_content":"\ntomcat启动报如下的错误：\n\njava.rmi.server.ExportException: Port already in use: 1099; nested exception is: java.net.BindException: Address already in use (Bind failed)\n\n解决方法有两种\n\n# 第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法\n\n# 第二种\n\n第一步：使用lsof -i tcp:1099 查看时那个应用占用了此端口\n\n第二部：使用kill pid 即可，这里的pid是第一步所查询到结果\n\n\n[原文链接](https://blog.csdn.net/u010412719/article/details/76724125)\n","source":"_posts/mac上解决java-rmi-server-ExportException-Port-already-in-use-1099-nested-exception-is-java-net-Bi.md","raw":"---\ntitle: >-\n  mac上解决java.rmi.server.ExportException- Port already in use- 1099; nested\n  exception is- java.net.Bi\ndate: 2019-09-09 18:39:14\ntags: [mac,exception]\ncategories: [exception]\n---\n\ntomcat启动报如下的错误：\n\njava.rmi.server.ExportException: Port already in use: 1099; nested exception is: java.net.BindException: Address already in use (Bind failed)\n\n解决方法有两种\n\n# 第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法\n\n# 第二种\n\n第一步：使用lsof -i tcp:1099 查看时那个应用占用了此端口\n\n第二部：使用kill pid 即可，这里的pid是第一步所查询到结果\n\n\n[原文链接](https://blog.csdn.net/u010412719/article/details/76724125)\n","slug":"mac上解决java-rmi-server-ExportException-Port-already-in-use-1099-nested-exception-is-java-net-Bi","published":1,"updated":"2019-09-27T08:27:08.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139ced70017ojfy4uib2m64","content":"<p>tomcat启动报如下的错误：</p>\n<p>java.rmi.server.ExportException: Port already in use: 1099; nested exception is: java.net.BindException: Address already in use (Bind failed)</p>\n<p>解决方法有两种</p>\n<h1 id=\"第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法\"><a href=\"#第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法\" class=\"headerlink\" title=\"第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法\"></a>第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法</h1><h1 id=\"第二种\"><a href=\"#第二种\" class=\"headerlink\" title=\"第二种\"></a>第二种</h1><p>第一步：使用lsof -i tcp:1099 查看时那个应用占用了此端口</p>\n<p>第二部：使用kill pid 即可，这里的pid是第一步所查询到结果</p>\n<p><a href=\"https://blog.csdn.net/u010412719/article/details/76724125\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>tomcat启动报如下的错误：</p>\n<p>java.rmi.server.ExportException: Port already in use: 1099; nested exception is: java.net.BindException: Address already in use (Bind failed)</p>\n<p>解决方法有两种</p>\n<h1 id=\"第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法\"><a href=\"#第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法\" class=\"headerlink\" title=\"第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法\"></a>第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法</h1><h1 id=\"第二种\"><a href=\"#第二种\" class=\"headerlink\" title=\"第二种\"></a>第二种</h1><p>第一步：使用lsof -i tcp:1099 查看时那个应用占用了此端口</p>\n<p>第二部：使用kill pid 即可，这里的pid是第一步所查询到结果</p>\n<p><a href=\"https://blog.csdn.net/u010412719/article/details/76724125\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n"},{"title":"mac下chrome快捷键","date":"2018-05-09T08:38:33.000Z","_content":"\nChrome在grwin环境下的刷新是F5,强制刷新是Ctrl+F5\n\nMac下Chrome的刷新是command+R,强制刷新为command+shift+R\n\n\noption+shift+可以打出(logo)\n\n## 引用 https://blog.csdn.net/fjh658/article/details/8860967\n\n## 标签页和窗口快捷键\n\n\n| 按键 | 作用 | \n| :-- | :-- | \n| `⌘+N` | `打开新窗口` |\n| `⌘+T` | `打开新标签` |\n| `⌘+shift+N` | `在隐身模式下打开新窗口` |\n| `按 ⌘+O，然后选择文件` | `在 Google Chrome 浏览器中打开计算机中的文件。` |\n| `按住 ⌘ 键，然后点击链接。或用鼠标中键（或鼠标滚轮）点击链接。` | `从后台在新标签页中打开链接。` |\n| `按住 ⌘+Shift 键，然后点击链接。或按住 Shift 的同时用鼠标中键（或鼠标滚轮）点击链接。` | `在新标签页中打开链接并切换到刚打开的标签页。` |\n| `按住 Shift 键，然后点击链接。` | `在新窗口中打开链接。` |\n| `⌘+Shift+T` | `重新打开上次关闭的标签页。Google Chrome 浏览器可记住最近关闭的 10 个标签页。` |\n| `将标签页拖出标签栏。\t` | `在新窗口中打开标签页。` |\n| `将标签页从标签栏拖到现有窗口中。` | `在现有窗口中打开标签页。` |\n| `同时按 ⌘+Option 和左或右箭头键。\t` | `左右切换标签页。` |\n| `⌘+W` | `关闭当前标签页或弹出窗口。` |\n| `⌘+Shift+W\t` | `关闭当前窗口。` |\n| `⌘+Y` | `打开历史记录` |\n| `按 Delete 或 ⌘-[\t` | `转到当前标签页的上一页浏览历史记录。` |\n| `按 Shift-Delete 或 ⌘-]\t。` | `转到当前标签页的下一页浏览历史记录。` |\n| `按住 Shift，然后点击窗口左上方的 + 按钮。\t` | `最大化窗口。` |\n| `⌘+M\t` | `最小化窗口。` |\n| `⌘+H` | `隐藏chrome浏览器` |\n| `⌘+option+H` | `隐藏其他所有窗口` |\n| `⌘+Q` | `关闭浏览器` |\n| `⌘+Shift+B` | `打开和关闭书签栏` |\n| `⌘+Option+B` | `打开书签管理器` |\n| `⌘-` | `打开偏好设置对话框` |\n| `⌘+Y` | `打开历史记录` |\n| `⌘+shift+J` | `打开下载内容页面` |\n| `⌘+shift+delete` | `打开清除浏览记录对话框` |\n| `⌘+shift+M` | `在多个用户之间切换` |\n| `输入搜索词,然后按Enter` | `使用默认搜索引擎进行搜索` |\n| `输入搜索引擎关键字,按空格键,再输入搜索字词,再按Enter` | `使用与关键字相关联的搜索引擎进行搜索` |\n| `首先输入搜索引擎网址,然后在系统提示时按Tab,输入搜索字词,再按Enter` | `使用与网址相关联的搜索引擎进行搜索` |\n| `输入网址，然后按 ⌘-Enter。\t` | `在新后台标签页中打开网址。` |\n| `⌘-L\t` | `突出显示网址。` |\n| `⌘-Option-F\t` | `将“?”置于地址栏中。在问号后输入搜索字词可用默认搜索引擎执行搜索。` |\n| `同时按 Option 和向左箭头键。\t` | `将光标移到地址栏中的前一个关键字词` |\n| `同时按 Option 和向右箭头键。\t` | `在地址栏中将光标移到下一个关键字词` |\n| `同时按 Shift-Option 和向左箭头键。\t` | `在地址栏中突出显示上一关键字词` |\n| `同时按 Shift-Option 和向右箭头键。\t` | `在地址栏中突出显示下一关键字词` |\n| `⌘-Delete\t` | `在地址栏中删除光标前的关键字词` |\n| `用键盘上的方向键从地址栏下拉菜单中选择一个条目，然后按 Shift-Fn-Delete。\t` | `从浏览历史记录中删除所选条目（如果可以）。` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/mac下chrome快捷键.md","raw":"---\ntitle: mac下chrome快捷键\ndate: 2018-05-09 16:38:33\ntags: [mac,chrome,快捷键]\ncategories: \n- mac\n---\n\nChrome在grwin环境下的刷新是F5,强制刷新是Ctrl+F5\n\nMac下Chrome的刷新是command+R,强制刷新为command+shift+R\n\n\noption+shift+可以打出(logo)\n\n## 引用 https://blog.csdn.net/fjh658/article/details/8860967\n\n## 标签页和窗口快捷键\n\n\n| 按键 | 作用 | \n| :-- | :-- | \n| `⌘+N` | `打开新窗口` |\n| `⌘+T` | `打开新标签` |\n| `⌘+shift+N` | `在隐身模式下打开新窗口` |\n| `按 ⌘+O，然后选择文件` | `在 Google Chrome 浏览器中打开计算机中的文件。` |\n| `按住 ⌘ 键，然后点击链接。或用鼠标中键（或鼠标滚轮）点击链接。` | `从后台在新标签页中打开链接。` |\n| `按住 ⌘+Shift 键，然后点击链接。或按住 Shift 的同时用鼠标中键（或鼠标滚轮）点击链接。` | `在新标签页中打开链接并切换到刚打开的标签页。` |\n| `按住 Shift 键，然后点击链接。` | `在新窗口中打开链接。` |\n| `⌘+Shift+T` | `重新打开上次关闭的标签页。Google Chrome 浏览器可记住最近关闭的 10 个标签页。` |\n| `将标签页拖出标签栏。\t` | `在新窗口中打开标签页。` |\n| `将标签页从标签栏拖到现有窗口中。` | `在现有窗口中打开标签页。` |\n| `同时按 ⌘+Option 和左或右箭头键。\t` | `左右切换标签页。` |\n| `⌘+W` | `关闭当前标签页或弹出窗口。` |\n| `⌘+Shift+W\t` | `关闭当前窗口。` |\n| `⌘+Y` | `打开历史记录` |\n| `按 Delete 或 ⌘-[\t` | `转到当前标签页的上一页浏览历史记录。` |\n| `按 Shift-Delete 或 ⌘-]\t。` | `转到当前标签页的下一页浏览历史记录。` |\n| `按住 Shift，然后点击窗口左上方的 + 按钮。\t` | `最大化窗口。` |\n| `⌘+M\t` | `最小化窗口。` |\n| `⌘+H` | `隐藏chrome浏览器` |\n| `⌘+option+H` | `隐藏其他所有窗口` |\n| `⌘+Q` | `关闭浏览器` |\n| `⌘+Shift+B` | `打开和关闭书签栏` |\n| `⌘+Option+B` | `打开书签管理器` |\n| `⌘-` | `打开偏好设置对话框` |\n| `⌘+Y` | `打开历史记录` |\n| `⌘+shift+J` | `打开下载内容页面` |\n| `⌘+shift+delete` | `打开清除浏览记录对话框` |\n| `⌘+shift+M` | `在多个用户之间切换` |\n| `输入搜索词,然后按Enter` | `使用默认搜索引擎进行搜索` |\n| `输入搜索引擎关键字,按空格键,再输入搜索字词,再按Enter` | `使用与关键字相关联的搜索引擎进行搜索` |\n| `首先输入搜索引擎网址,然后在系统提示时按Tab,输入搜索字词,再按Enter` | `使用与网址相关联的搜索引擎进行搜索` |\n| `输入网址，然后按 ⌘-Enter。\t` | `在新后台标签页中打开网址。` |\n| `⌘-L\t` | `突出显示网址。` |\n| `⌘-Option-F\t` | `将“?”置于地址栏中。在问号后输入搜索字词可用默认搜索引擎执行搜索。` |\n| `同时按 Option 和向左箭头键。\t` | `将光标移到地址栏中的前一个关键字词` |\n| `同时按 Option 和向右箭头键。\t` | `在地址栏中将光标移到下一个关键字词` |\n| `同时按 Shift-Option 和向左箭头键。\t` | `在地址栏中突出显示上一关键字词` |\n| `同时按 Shift-Option 和向右箭头键。\t` | `在地址栏中突出显示下一关键字词` |\n| `⌘-Delete\t` | `在地址栏中删除光标前的关键字词` |\n| `用键盘上的方向键从地址栏下拉菜单中选择一个条目，然后按 Shift-Fn-Delete。\t` | `从浏览历史记录中删除所选条目（如果可以）。` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n| `⌘+` | `tt` |\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"mac下chrome快捷键","published":1,"updated":"2019-09-27T08:27:08.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139ced80018ojfy2y9gmvhi","content":"<p>Chrome在grwin环境下的刷新是F5,强制刷新是Ctrl+F5</p>\n<p>Mac下Chrome的刷新是command+R,强制刷新为command+shift+R</p>\n<p>option+shift+可以打出(logo)</p>\n<h2 id=\"引用-https-blog-csdn-net-fjh658-article-details-8860967\"><a href=\"#引用-https-blog-csdn-net-fjh658-article-details-8860967\" class=\"headerlink\" title=\"引用 https://blog.csdn.net/fjh658/article/details/8860967\"></a>引用 <a href=\"https://blog.csdn.net/fjh658/article/details/8860967\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/fjh658/article/details/8860967</a></h2><h2 id=\"标签页和窗口快捷键\"><a href=\"#标签页和窗口快捷键\" class=\"headerlink\" title=\"标签页和窗口快捷键\"></a>标签页和窗口快捷键</h2><table>\n<thead>\n<tr>\n<th align=\"left\">按键</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>⌘+N</code></td>\n<td align=\"left\"><code>打开新窗口</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+T</code></td>\n<td align=\"left\"><code>打开新标签</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+shift+N</code></td>\n<td align=\"left\"><code>在隐身模式下打开新窗口</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>按 ⌘+O，然后选择文件</code></td>\n<td align=\"left\"><code>在 Google Chrome 浏览器中打开计算机中的文件。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>按住 ⌘ 键，然后点击链接。或用鼠标中键（或鼠标滚轮）点击链接。</code></td>\n<td align=\"left\"><code>从后台在新标签页中打开链接。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>按住 ⌘+Shift 键，然后点击链接。或按住 Shift 的同时用鼠标中键（或鼠标滚轮）点击链接。</code></td>\n<td align=\"left\"><code>在新标签页中打开链接并切换到刚打开的标签页。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>按住 Shift 键，然后点击链接。</code></td>\n<td align=\"left\"><code>在新窗口中打开链接。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+Shift+T</code></td>\n<td align=\"left\"><code>重新打开上次关闭的标签页。Google Chrome 浏览器可记住最近关闭的 10 个标签页。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>将标签页拖出标签栏。</code></td>\n<td align=\"left\"><code>在新窗口中打开标签页。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>将标签页从标签栏拖到现有窗口中。</code></td>\n<td align=\"left\"><code>在现有窗口中打开标签页。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>同时按 ⌘+Option 和左或右箭头键。</code></td>\n<td align=\"left\"><code>左右切换标签页。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+W</code></td>\n<td align=\"left\"><code>关闭当前标签页或弹出窗口。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+Shift+W</code></td>\n<td align=\"left\"><code>关闭当前窗口。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+Y</code></td>\n<td align=\"left\"><code>打开历史记录</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>按 Delete 或 ⌘-[</code></td>\n<td align=\"left\"><code>转到当前标签页的上一页浏览历史记录。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>按 Shift-Delete 或 ⌘-]    。</code></td>\n<td align=\"left\"><code>转到当前标签页的下一页浏览历史记录。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>按住 Shift，然后点击窗口左上方的 + 按钮。</code></td>\n<td align=\"left\"><code>最大化窗口。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+M</code></td>\n<td align=\"left\"><code>最小化窗口。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+H</code></td>\n<td align=\"left\"><code>隐藏chrome浏览器</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+option+H</code></td>\n<td align=\"left\"><code>隐藏其他所有窗口</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+Q</code></td>\n<td align=\"left\"><code>关闭浏览器</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+Shift+B</code></td>\n<td align=\"left\"><code>打开和关闭书签栏</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+Option+B</code></td>\n<td align=\"left\"><code>打开书签管理器</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘-</code></td>\n<td align=\"left\"><code>打开偏好设置对话框</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+Y</code></td>\n<td align=\"left\"><code>打开历史记录</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+shift+J</code></td>\n<td align=\"left\"><code>打开下载内容页面</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+shift+delete</code></td>\n<td align=\"left\"><code>打开清除浏览记录对话框</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+shift+M</code></td>\n<td align=\"left\"><code>在多个用户之间切换</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>输入搜索词,然后按Enter</code></td>\n<td align=\"left\"><code>使用默认搜索引擎进行搜索</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>输入搜索引擎关键字,按空格键,再输入搜索字词,再按Enter</code></td>\n<td align=\"left\"><code>使用与关键字相关联的搜索引擎进行搜索</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>首先输入搜索引擎网址,然后在系统提示时按Tab,输入搜索字词,再按Enter</code></td>\n<td align=\"left\"><code>使用与网址相关联的搜索引擎进行搜索</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>输入网址，然后按 ⌘-Enter。</code></td>\n<td align=\"left\"><code>在新后台标签页中打开网址。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘-L</code></td>\n<td align=\"left\"><code>突出显示网址。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘-Option-F</code></td>\n<td align=\"left\"><code>将“?”置于地址栏中。在问号后输入搜索字词可用默认搜索引擎执行搜索。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>同时按 Option 和向左箭头键。</code></td>\n<td align=\"left\"><code>将光标移到地址栏中的前一个关键字词</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>同时按 Option 和向右箭头键。</code></td>\n<td align=\"left\"><code>在地址栏中将光标移到下一个关键字词</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>同时按 Shift-Option 和向左箭头键。</code></td>\n<td align=\"left\"><code>在地址栏中突出显示上一关键字词</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>同时按 Shift-Option 和向右箭头键。</code></td>\n<td align=\"left\"><code>在地址栏中突出显示下一关键字词</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘-Delete</code></td>\n<td align=\"left\"><code>在地址栏中删除光标前的关键字词</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>用键盘上的方向键从地址栏下拉菜单中选择一个条目，然后按 Shift-Fn-Delete。</code></td>\n<td align=\"left\"><code>从浏览历史记录中删除所选条目（如果可以）。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<p>Chrome在grwin环境下的刷新是F5,强制刷新是Ctrl+F5</p>\n<p>Mac下Chrome的刷新是command+R,强制刷新为command+shift+R</p>\n<p>option+shift+可以打出(logo)</p>\n<h2 id=\"引用-https-blog-csdn-net-fjh658-article-details-8860967\"><a href=\"#引用-https-blog-csdn-net-fjh658-article-details-8860967\" class=\"headerlink\" title=\"引用 https://blog.csdn.net/fjh658/article/details/8860967\"></a>引用 <a href=\"https://blog.csdn.net/fjh658/article/details/8860967\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/fjh658/article/details/8860967</a></h2><h2 id=\"标签页和窗口快捷键\"><a href=\"#标签页和窗口快捷键\" class=\"headerlink\" title=\"标签页和窗口快捷键\"></a>标签页和窗口快捷键</h2><table>\n<thead>\n<tr>\n<th align=\"left\">按键</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>⌘+N</code></td>\n<td align=\"left\"><code>打开新窗口</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+T</code></td>\n<td align=\"left\"><code>打开新标签</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+shift+N</code></td>\n<td align=\"left\"><code>在隐身模式下打开新窗口</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>按 ⌘+O，然后选择文件</code></td>\n<td align=\"left\"><code>在 Google Chrome 浏览器中打开计算机中的文件。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>按住 ⌘ 键，然后点击链接。或用鼠标中键（或鼠标滚轮）点击链接。</code></td>\n<td align=\"left\"><code>从后台在新标签页中打开链接。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>按住 ⌘+Shift 键，然后点击链接。或按住 Shift 的同时用鼠标中键（或鼠标滚轮）点击链接。</code></td>\n<td align=\"left\"><code>在新标签页中打开链接并切换到刚打开的标签页。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>按住 Shift 键，然后点击链接。</code></td>\n<td align=\"left\"><code>在新窗口中打开链接。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+Shift+T</code></td>\n<td align=\"left\"><code>重新打开上次关闭的标签页。Google Chrome 浏览器可记住最近关闭的 10 个标签页。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>将标签页拖出标签栏。</code></td>\n<td align=\"left\"><code>在新窗口中打开标签页。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>将标签页从标签栏拖到现有窗口中。</code></td>\n<td align=\"left\"><code>在现有窗口中打开标签页。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>同时按 ⌘+Option 和左或右箭头键。</code></td>\n<td align=\"left\"><code>左右切换标签页。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+W</code></td>\n<td align=\"left\"><code>关闭当前标签页或弹出窗口。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+Shift+W</code></td>\n<td align=\"left\"><code>关闭当前窗口。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+Y</code></td>\n<td align=\"left\"><code>打开历史记录</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>按 Delete 或 ⌘-[</code></td>\n<td align=\"left\"><code>转到当前标签页的上一页浏览历史记录。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>按 Shift-Delete 或 ⌘-]    。</code></td>\n<td align=\"left\"><code>转到当前标签页的下一页浏览历史记录。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>按住 Shift，然后点击窗口左上方的 + 按钮。</code></td>\n<td align=\"left\"><code>最大化窗口。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+M</code></td>\n<td align=\"left\"><code>最小化窗口。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+H</code></td>\n<td align=\"left\"><code>隐藏chrome浏览器</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+option+H</code></td>\n<td align=\"left\"><code>隐藏其他所有窗口</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+Q</code></td>\n<td align=\"left\"><code>关闭浏览器</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+Shift+B</code></td>\n<td align=\"left\"><code>打开和关闭书签栏</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+Option+B</code></td>\n<td align=\"left\"><code>打开书签管理器</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘-</code></td>\n<td align=\"left\"><code>打开偏好设置对话框</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+Y</code></td>\n<td align=\"left\"><code>打开历史记录</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+shift+J</code></td>\n<td align=\"left\"><code>打开下载内容页面</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+shift+delete</code></td>\n<td align=\"left\"><code>打开清除浏览记录对话框</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+shift+M</code></td>\n<td align=\"left\"><code>在多个用户之间切换</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>输入搜索词,然后按Enter</code></td>\n<td align=\"left\"><code>使用默认搜索引擎进行搜索</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>输入搜索引擎关键字,按空格键,再输入搜索字词,再按Enter</code></td>\n<td align=\"left\"><code>使用与关键字相关联的搜索引擎进行搜索</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>首先输入搜索引擎网址,然后在系统提示时按Tab,输入搜索字词,再按Enter</code></td>\n<td align=\"left\"><code>使用与网址相关联的搜索引擎进行搜索</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>输入网址，然后按 ⌘-Enter。</code></td>\n<td align=\"left\"><code>在新后台标签页中打开网址。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘-L</code></td>\n<td align=\"left\"><code>突出显示网址。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘-Option-F</code></td>\n<td align=\"left\"><code>将“?”置于地址栏中。在问号后输入搜索字词可用默认搜索引擎执行搜索。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>同时按 Option 和向左箭头键。</code></td>\n<td align=\"left\"><code>将光标移到地址栏中的前一个关键字词</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>同时按 Option 和向右箭头键。</code></td>\n<td align=\"left\"><code>在地址栏中将光标移到下一个关键字词</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>同时按 Shift-Option 和向左箭头键。</code></td>\n<td align=\"left\"><code>在地址栏中突出显示上一关键字词</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>同时按 Shift-Option 和向右箭头键。</code></td>\n<td align=\"left\"><code>在地址栏中突出显示下一关键字词</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘-Delete</code></td>\n<td align=\"left\"><code>在地址栏中删除光标前的关键字词</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>用键盘上的方向键从地址栏下拉菜单中选择一个条目，然后按 Shift-Fn-Delete。</code></td>\n<td align=\"left\"><code>从浏览历史记录中删除所选条目（如果可以）。</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>⌘+</code></td>\n<td align=\"left\"><code>tt</code></td>\n</tr>\n</tbody></table>\n"},{"title":"mac使用brew update无反应,解决方案更新源","date":"2019-08-23T06:48:24.000Z","_content":"\n# 原因\n  资源访问太慢\n  \n# 解决方案\n更新源\n\n使用中科大的镜像\n替换默认源\n第一步，替换brew.git\n\n    cd \"$(brew --repo)\"\n    git remote set-url origin https://mirrors.ustc.edu.cn/brew.git\n    \n第二步：替换homebrew-core.git\n\n    cd \"$(brew --repo)/Library/Taps/homebrew/homebrew-core\"\n    git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git\n\n最后验证\n\n      brew update\n    \n","source":"_posts/mac使用brew-update无反应-解决方案更新源.md","raw":"---\ntitle: 'mac使用brew update无反应,解决方案更新源'\ndate: 2019-08-23 14:48:24\ntags: [brew,mac]\n---\n\n# 原因\n  资源访问太慢\n  \n# 解决方案\n更新源\n\n使用中科大的镜像\n替换默认源\n第一步，替换brew.git\n\n    cd \"$(brew --repo)\"\n    git remote set-url origin https://mirrors.ustc.edu.cn/brew.git\n    \n第二步：替换homebrew-core.git\n\n    cd \"$(brew --repo)/Library/Taps/homebrew/homebrew-core\"\n    git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git\n\n最后验证\n\n      brew update\n    \n","slug":"mac使用brew-update无反应-解决方案更新源","published":1,"updated":"2019-09-27T08:27:08.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139ced80019ojfyblnujekd","content":"<h1 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h1><p>  资源访问太慢</p>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><p>更新源</p>\n<p>使用中科大的镜像<br>替换默认源<br>第一步，替换brew.git</p>\n<pre><code>cd &quot;$(brew --repo)&quot;\ngit remote set-url origin https://mirrors.ustc.edu.cn/brew.git</code></pre><p>第二步：替换homebrew-core.git</p>\n<pre><code>cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;\ngit remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</code></pre><p>最后验证</p>\n<pre><code>brew update</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h1><p>  资源访问太慢</p>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><p>更新源</p>\n<p>使用中科大的镜像<br>替换默认源<br>第一步，替换brew.git</p>\n<pre><code>cd &quot;$(brew --repo)&quot;\ngit remote set-url origin https://mirrors.ustc.edu.cn/brew.git</code></pre><p>第二步：替换homebrew-core.git</p>\n<pre><code>cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;\ngit remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</code></pre><p>最后验证</p>\n<pre><code>brew update</code></pre>"},{"title":"php中unset详解","date":"2018-06-20T00:59:33.000Z","_content":"\nunset()经常会被用到,用于销毁指定的变量,但它有自己的行为模式,如果\n不仔细的话可能被中文解释给迷惑:\n\n先来看看官方文档的说法:\n\nunset ---- unset a given variable\n\nvoid unset(mixed $var [,mixed $...]);\n\nparameters:\n\nvar:The variable to be unset. //要unset的变量\n\n...Anther variable... // 其他需要unset的变量\n\nreturn Values:No value is returned.  //unset不返回值\n\n\nBecause this is a language construct and not a function,it\ncannot be called using variable functions\n\n//unset()是语言结构,不是函数,因此不能被函数变量调用,具体参照函数变量.\n\n使用function_exists('unset')返回的false,以此证明unset并不是一个函数\n,所以无法使用$fun='unset';$fun()的方式调用unset()\n\nit is possible to unset even object properties visible in current context.\n\n// 通用环境下unset可以销毁对象或者对象的可见属性(public)\n\nIt is not possible to unset $this inside on object method since PHP5\n\n// 在PHP5之前unset无法销毁对象中的$this方法\n\nwhen using unset() on inaccessible object properties,the _unset()\noverloading method will be called,if declare.\n\n当unset()无法销毁对象中的属性,例如私有属性,保护属性,那么会自动加载对象中的_unset\n方法.\n\ndescription:\n\nunset()destroys the specified variables. //unset()销毁指定的变量\n\nThe behavior of unset()inside of a function can vary depending\n\non what type of variable you are attempting to destroy.\n\n// unset()的行为在函数内部可以根据你所指定销毁的变量类型变化.\n\n\n情况一:\n\nif a globalized variable is unset() inside of a function,only the local\nvariable is destroyed.The variable in the calling environment will \nretain the same value as before unset() was called.\n\n如果在函数内使用一个global使其全局化的变量,使用unset进行销毁,那么只有局部的\n变量会被销毁,在调用环境的变量将会保留没有unset()销毁之前的调用的变量值.\n\nthe example:\n\n    <?php  \n    function destroy_foo()   \n    {  \n        global $foo;  \n        unset($foo);  \n    }  \n      \n    $foo = 'bar';  \n    destroy_foo();  \n    echo $foo;  \n    ?>  \n    \nthe above example will output:bar\n\n这是官方文档的例子,可能这样还是不太明显,把上面的例子改成下面这样,一切就很清晰了.\n\n    <?php   \n    function des(){  \n        global $foo;  \n        $foo='bars';  \n        unset($foo);  \n        echo $foo;  \n    }  \n    $foo='bar';  \n    echo \"The globalized variable is unset() inside of a function:\";  \n    des();  \n    echo \"<br/>\";  \n    echo \"The variable in the calling environment:\";  \n    echo $foo;  \n\n\n\n","source":"_posts/php中unset详解.md","raw":"---\ntitle: php中unset详解\ndate: 2018-06-20 08:59:33\ntags: [php,unset]\ncategories: \n- php\n---\n\nunset()经常会被用到,用于销毁指定的变量,但它有自己的行为模式,如果\n不仔细的话可能被中文解释给迷惑:\n\n先来看看官方文档的说法:\n\nunset ---- unset a given variable\n\nvoid unset(mixed $var [,mixed $...]);\n\nparameters:\n\nvar:The variable to be unset. //要unset的变量\n\n...Anther variable... // 其他需要unset的变量\n\nreturn Values:No value is returned.  //unset不返回值\n\n\nBecause this is a language construct and not a function,it\ncannot be called using variable functions\n\n//unset()是语言结构,不是函数,因此不能被函数变量调用,具体参照函数变量.\n\n使用function_exists('unset')返回的false,以此证明unset并不是一个函数\n,所以无法使用$fun='unset';$fun()的方式调用unset()\n\nit is possible to unset even object properties visible in current context.\n\n// 通用环境下unset可以销毁对象或者对象的可见属性(public)\n\nIt is not possible to unset $this inside on object method since PHP5\n\n// 在PHP5之前unset无法销毁对象中的$this方法\n\nwhen using unset() on inaccessible object properties,the _unset()\noverloading method will be called,if declare.\n\n当unset()无法销毁对象中的属性,例如私有属性,保护属性,那么会自动加载对象中的_unset\n方法.\n\ndescription:\n\nunset()destroys the specified variables. //unset()销毁指定的变量\n\nThe behavior of unset()inside of a function can vary depending\n\non what type of variable you are attempting to destroy.\n\n// unset()的行为在函数内部可以根据你所指定销毁的变量类型变化.\n\n\n情况一:\n\nif a globalized variable is unset() inside of a function,only the local\nvariable is destroyed.The variable in the calling environment will \nretain the same value as before unset() was called.\n\n如果在函数内使用一个global使其全局化的变量,使用unset进行销毁,那么只有局部的\n变量会被销毁,在调用环境的变量将会保留没有unset()销毁之前的调用的变量值.\n\nthe example:\n\n    <?php  \n    function destroy_foo()   \n    {  \n        global $foo;  \n        unset($foo);  \n    }  \n      \n    $foo = 'bar';  \n    destroy_foo();  \n    echo $foo;  \n    ?>  \n    \nthe above example will output:bar\n\n这是官方文档的例子,可能这样还是不太明显,把上面的例子改成下面这样,一切就很清晰了.\n\n    <?php   \n    function des(){  \n        global $foo;  \n        $foo='bars';  \n        unset($foo);  \n        echo $foo;  \n    }  \n    $foo='bar';  \n    echo \"The globalized variable is unset() inside of a function:\";  \n    des();  \n    echo \"<br/>\";  \n    echo \"The variable in the calling environment:\";  \n    echo $foo;  \n\n\n\n","slug":"php中unset详解","published":1,"updated":"2019-09-27T08:27:08.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139ced9001aojfyndw3lrw6","content":"<p>unset()经常会被用到,用于销毁指定的变量,但它有自己的行为模式,如果<br>不仔细的话可能被中文解释给迷惑:</p>\n<p>先来看看官方文档的说法:</p>\n<p>unset —- unset a given variable</p>\n<p>void unset(mixed $var [,mixed $…]);</p>\n<p>parameters:</p>\n<p>var:The variable to be unset. //要unset的变量</p>\n<p>…Anther variable… // 其他需要unset的变量</p>\n<p>return Values:No value is returned.  //unset不返回值</p>\n<p>Because this is a language construct and not a function,it<br>cannot be called using variable functions</p>\n<p>//unset()是语言结构,不是函数,因此不能被函数变量调用,具体参照函数变量.</p>\n<p>使用function_exists(‘unset’)返回的false,以此证明unset并不是一个函数<br>,所以无法使用$fun=’unset’;$fun()的方式调用unset()</p>\n<p>it is possible to unset even object properties visible in current context.</p>\n<p>// 通用环境下unset可以销毁对象或者对象的可见属性(public)</p>\n<p>It is not possible to unset $this inside on object method since PHP5</p>\n<p>// 在PHP5之前unset无法销毁对象中的$this方法</p>\n<p>when using unset() on inaccessible object properties,the _unset()<br>overloading method will be called,if declare.</p>\n<p>当unset()无法销毁对象中的属性,例如私有属性,保护属性,那么会自动加载对象中的_unset<br>方法.</p>\n<p>description:</p>\n<p>unset()destroys the specified variables. //unset()销毁指定的变量</p>\n<p>The behavior of unset()inside of a function can vary depending</p>\n<p>on what type of variable you are attempting to destroy.</p>\n<p>// unset()的行为在函数内部可以根据你所指定销毁的变量类型变化.</p>\n<p>情况一:</p>\n<p>if a globalized variable is unset() inside of a function,only the local<br>variable is destroyed.The variable in the calling environment will<br>retain the same value as before unset() was called.</p>\n<p>如果在函数内使用一个global使其全局化的变量,使用unset进行销毁,那么只有局部的<br>变量会被销毁,在调用环境的变量将会保留没有unset()销毁之前的调用的变量值.</p>\n<p>the example:</p>\n<pre><code>&lt;?php  \nfunction destroy_foo()   \n{  \n    global $foo;  \n    unset($foo);  \n}  \n\n$foo = &apos;bar&apos;;  \ndestroy_foo();  \necho $foo;  \n?&gt;  </code></pre><p>the above example will output:bar</p>\n<p>这是官方文档的例子,可能这样还是不太明显,把上面的例子改成下面这样,一切就很清晰了.</p>\n<pre><code>&lt;?php   \nfunction des(){  \n    global $foo;  \n    $foo=&apos;bars&apos;;  \n    unset($foo);  \n    echo $foo;  \n}  \n$foo=&apos;bar&apos;;  \necho &quot;The globalized variable is unset() inside of a function:&quot;;  \ndes();  \necho &quot;&lt;br/&gt;&quot;;  \necho &quot;The variable in the calling environment:&quot;;  \necho $foo;  </code></pre>","site":{"data":{}},"excerpt":"","more":"<p>unset()经常会被用到,用于销毁指定的变量,但它有自己的行为模式,如果<br>不仔细的话可能被中文解释给迷惑:</p>\n<p>先来看看官方文档的说法:</p>\n<p>unset —- unset a given variable</p>\n<p>void unset(mixed $var [,mixed $…]);</p>\n<p>parameters:</p>\n<p>var:The variable to be unset. //要unset的变量</p>\n<p>…Anther variable… // 其他需要unset的变量</p>\n<p>return Values:No value is returned.  //unset不返回值</p>\n<p>Because this is a language construct and not a function,it<br>cannot be called using variable functions</p>\n<p>//unset()是语言结构,不是函数,因此不能被函数变量调用,具体参照函数变量.</p>\n<p>使用function_exists(‘unset’)返回的false,以此证明unset并不是一个函数<br>,所以无法使用$fun=’unset’;$fun()的方式调用unset()</p>\n<p>it is possible to unset even object properties visible in current context.</p>\n<p>// 通用环境下unset可以销毁对象或者对象的可见属性(public)</p>\n<p>It is not possible to unset $this inside on object method since PHP5</p>\n<p>// 在PHP5之前unset无法销毁对象中的$this方法</p>\n<p>when using unset() on inaccessible object properties,the _unset()<br>overloading method will be called,if declare.</p>\n<p>当unset()无法销毁对象中的属性,例如私有属性,保护属性,那么会自动加载对象中的_unset<br>方法.</p>\n<p>description:</p>\n<p>unset()destroys the specified variables. //unset()销毁指定的变量</p>\n<p>The behavior of unset()inside of a function can vary depending</p>\n<p>on what type of variable you are attempting to destroy.</p>\n<p>// unset()的行为在函数内部可以根据你所指定销毁的变量类型变化.</p>\n<p>情况一:</p>\n<p>if a globalized variable is unset() inside of a function,only the local<br>variable is destroyed.The variable in the calling environment will<br>retain the same value as before unset() was called.</p>\n<p>如果在函数内使用一个global使其全局化的变量,使用unset进行销毁,那么只有局部的<br>变量会被销毁,在调用环境的变量将会保留没有unset()销毁之前的调用的变量值.</p>\n<p>the example:</p>\n<pre><code>&lt;?php  \nfunction destroy_foo()   \n{  \n    global $foo;  \n    unset($foo);  \n}  \n\n$foo = &apos;bar&apos;;  \ndestroy_foo();  \necho $foo;  \n?&gt;  </code></pre><p>the above example will output:bar</p>\n<p>这是官方文档的例子,可能这样还是不太明显,把上面的例子改成下面这样,一切就很清晰了.</p>\n<pre><code>&lt;?php   \nfunction des(){  \n    global $foo;  \n    $foo=&apos;bars&apos;;  \n    unset($foo);  \n    echo $foo;  \n}  \n$foo=&apos;bar&apos;;  \necho &quot;The globalized variable is unset() inside of a function:&quot;;  \ndes();  \necho &quot;&lt;br/&gt;&quot;;  \necho &quot;The variable in the calling environment:&quot;;  \necho $foo;  </code></pre>"},{"title":"php调用shell的方法","date":"2018-04-20T02:07:17.000Z","_content":"\n## 引用:http://www.jb51.net/article/57118.htm\n\n## 这篇文章主要介绍了PHP调用shell的方法,包括相关的原理 注意事项及函数的用法,需要的朋友可以参考下\n\n### 一 配置\n#### 查看php.ini中配置是否打开安全模式,主要是以下三个地方 \n\n* safe_mode = (这个如果是off下面两个就不用管了)\n\n* disable_functions = \n\n* safe_mode_exec_dir = \n\n### 二使用\n\n#### 由于PHP是基本是用于WEB程序开发的,所以安全性成了人们考虑的一个重要方面.于是PHP的设计者们给  PHP加了一个门:安全模式.如果运行在安全模式下,那么PHP脚本中将受到如下四个方面的限制:\n\n* 执行外部命令\n\n* 在打开文件时有些限制\n\n* 连接MYSQL数据库\n\n* 基于HTTP的认证\n\n在安全模式下,只有在特定目录中的外部程序才可以被执行,对其他程序的调用将被拒绝.这个目录可以在  PHP.ini文件中用safe_model_exex_dir指令,或在编译PHP时加上--with-exec-dir选项来指定,默认是  /usr/local/php/bin.\n\n如果你调用一个应该可以输出结果的外部命令(意思是PHP脚本没有错误),得到的却是一片空白,那么很可能   你的网管已经把PHP运行在安全模式下了.\n\n### 三如何做\n\n#### 在PHP中调用外部命令,可以用如下三种方法来实现:\n\n* 1 ) 用PHP提供的专门函数\n\n### php提供了3个专门的执行外部命令的函数: system(),exec(),passthru().\n\n\n### system()\n原型: string system(string command[,int return_var])\n\nsystem()函数和其他语言中的差不多,它执行给定的命令,输出和返回结果.第二个参数是可选的,用来得到命令执行后的状态码.\n\n例子:\n\n* system(\"/usr/local/bin/webalizer/webalizer\");\n\n### exec()\n\n原型: string exex(string command[,string array[,int return_var]])\n\nexec()函数与system()类似,也执行给定的命令,但不输出结果,而是返回结果的最后一行.虽然它只返回命令  结果的最后一行,但用第二个参数array可以得到完整的结果,方法是吧结果逐行追加到  array的结尾处.所 以如果array不是空的,在调用之前最好用unset()把它清掉.只有指定了第二个参数时,才可以用第三个参数,用来取得命令执行的状态码.\n\n例子:\n* exec(\"/bin/ls -|\");\n* exec(\"/bin/ls -|\",$res);'\n* $res是一个数据,每个元素代表结果的一行\n* exec(\"/bin/ls -|\",$res,$rc);'\n* $rc的值是命令/bin/ls -|的状态码.成功的情况下通常是0\n\n\n### passthru()\n\n  原型: void passthru(string command[,int return_var])\n  \n  passthru()只调用命令,不返回任何结果,但把命令的运行结果原样\n  地直接输出到标准输出设备上.所以passthru()函数经常用来调用像\n  pbmplus(Unix下的一个处理图片的工具,输出二进制的原始图片的流)\n  这样的程序.同样它也可以得到命令执行的状态码.\n  \n  例子\n  \n  header(\"Content-type:image/gif\");\n  passthru(\"./ppmtogif hunte.ppm\");\n\n\n","source":"_posts/php调用shell的方法.md","raw":"---\ntitle: php调用shell的方法\ndate: 2018-04-20 10:07:17\ntags: [shell,php]\ncategories: \n- linux\n---\n\n## 引用:http://www.jb51.net/article/57118.htm\n\n## 这篇文章主要介绍了PHP调用shell的方法,包括相关的原理 注意事项及函数的用法,需要的朋友可以参考下\n\n### 一 配置\n#### 查看php.ini中配置是否打开安全模式,主要是以下三个地方 \n\n* safe_mode = (这个如果是off下面两个就不用管了)\n\n* disable_functions = \n\n* safe_mode_exec_dir = \n\n### 二使用\n\n#### 由于PHP是基本是用于WEB程序开发的,所以安全性成了人们考虑的一个重要方面.于是PHP的设计者们给  PHP加了一个门:安全模式.如果运行在安全模式下,那么PHP脚本中将受到如下四个方面的限制:\n\n* 执行外部命令\n\n* 在打开文件时有些限制\n\n* 连接MYSQL数据库\n\n* 基于HTTP的认证\n\n在安全模式下,只有在特定目录中的外部程序才可以被执行,对其他程序的调用将被拒绝.这个目录可以在  PHP.ini文件中用safe_model_exex_dir指令,或在编译PHP时加上--with-exec-dir选项来指定,默认是  /usr/local/php/bin.\n\n如果你调用一个应该可以输出结果的外部命令(意思是PHP脚本没有错误),得到的却是一片空白,那么很可能   你的网管已经把PHP运行在安全模式下了.\n\n### 三如何做\n\n#### 在PHP中调用外部命令,可以用如下三种方法来实现:\n\n* 1 ) 用PHP提供的专门函数\n\n### php提供了3个专门的执行外部命令的函数: system(),exec(),passthru().\n\n\n### system()\n原型: string system(string command[,int return_var])\n\nsystem()函数和其他语言中的差不多,它执行给定的命令,输出和返回结果.第二个参数是可选的,用来得到命令执行后的状态码.\n\n例子:\n\n* system(\"/usr/local/bin/webalizer/webalizer\");\n\n### exec()\n\n原型: string exex(string command[,string array[,int return_var]])\n\nexec()函数与system()类似,也执行给定的命令,但不输出结果,而是返回结果的最后一行.虽然它只返回命令  结果的最后一行,但用第二个参数array可以得到完整的结果,方法是吧结果逐行追加到  array的结尾处.所 以如果array不是空的,在调用之前最好用unset()把它清掉.只有指定了第二个参数时,才可以用第三个参数,用来取得命令执行的状态码.\n\n例子:\n* exec(\"/bin/ls -|\");\n* exec(\"/bin/ls -|\",$res);'\n* $res是一个数据,每个元素代表结果的一行\n* exec(\"/bin/ls -|\",$res,$rc);'\n* $rc的值是命令/bin/ls -|的状态码.成功的情况下通常是0\n\n\n### passthru()\n\n  原型: void passthru(string command[,int return_var])\n  \n  passthru()只调用命令,不返回任何结果,但把命令的运行结果原样\n  地直接输出到标准输出设备上.所以passthru()函数经常用来调用像\n  pbmplus(Unix下的一个处理图片的工具,输出二进制的原始图片的流)\n  这样的程序.同样它也可以得到命令执行的状态码.\n  \n  例子\n  \n  header(\"Content-type:image/gif\");\n  passthru(\"./ppmtogif hunte.ppm\");\n\n\n","slug":"php调用shell的方法","published":1,"updated":"2019-09-27T08:27:08.043Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedd001bojfy559n125t","content":"<h2 id=\"引用-http-www-jb51-net-article-57118-htm\"><a href=\"#引用-http-www-jb51-net-article-57118-htm\" class=\"headerlink\" title=\"引用:http://www.jb51.net/article/57118.htm\"></a>引用:<a href=\"http://www.jb51.net/article/57118.htm\" target=\"_blank\" rel=\"noopener\">http://www.jb51.net/article/57118.htm</a></h2><h2 id=\"这篇文章主要介绍了PHP调用shell的方法-包括相关的原理-注意事项及函数的用法-需要的朋友可以参考下\"><a href=\"#这篇文章主要介绍了PHP调用shell的方法-包括相关的原理-注意事项及函数的用法-需要的朋友可以参考下\" class=\"headerlink\" title=\"这篇文章主要介绍了PHP调用shell的方法,包括相关的原理 注意事项及函数的用法,需要的朋友可以参考下\"></a>这篇文章主要介绍了PHP调用shell的方法,包括相关的原理 注意事项及函数的用法,需要的朋友可以参考下</h2><h3 id=\"一-配置\"><a href=\"#一-配置\" class=\"headerlink\" title=\"一 配置\"></a>一 配置</h3><h4 id=\"查看php-ini中配置是否打开安全模式-主要是以下三个地方\"><a href=\"#查看php-ini中配置是否打开安全模式-主要是以下三个地方\" class=\"headerlink\" title=\"查看php.ini中配置是否打开安全模式,主要是以下三个地方\"></a>查看php.ini中配置是否打开安全模式,主要是以下三个地方</h4><ul>\n<li><p>safe_mode = (这个如果是off下面两个就不用管了)</p>\n</li>\n<li><p>disable_functions = </p>\n</li>\n<li><p>safe_mode_exec_dir = </p>\n</li>\n</ul>\n<h3 id=\"二使用\"><a href=\"#二使用\" class=\"headerlink\" title=\"二使用\"></a>二使用</h3><h4 id=\"由于PHP是基本是用于WEB程序开发的-所以安全性成了人们考虑的一个重要方面-于是PHP的设计者们给-PHP加了一个门-安全模式-如果运行在安全模式下-那么PHP脚本中将受到如下四个方面的限制\"><a href=\"#由于PHP是基本是用于WEB程序开发的-所以安全性成了人们考虑的一个重要方面-于是PHP的设计者们给-PHP加了一个门-安全模式-如果运行在安全模式下-那么PHP脚本中将受到如下四个方面的限制\" class=\"headerlink\" title=\"由于PHP是基本是用于WEB程序开发的,所以安全性成了人们考虑的一个重要方面.于是PHP的设计者们给  PHP加了一个门:安全模式.如果运行在安全模式下,那么PHP脚本中将受到如下四个方面的限制:\"></a>由于PHP是基本是用于WEB程序开发的,所以安全性成了人们考虑的一个重要方面.于是PHP的设计者们给  PHP加了一个门:安全模式.如果运行在安全模式下,那么PHP脚本中将受到如下四个方面的限制:</h4><ul>\n<li><p>执行外部命令</p>\n</li>\n<li><p>在打开文件时有些限制</p>\n</li>\n<li><p>连接MYSQL数据库</p>\n</li>\n<li><p>基于HTTP的认证</p>\n</li>\n</ul>\n<p>在安全模式下,只有在特定目录中的外部程序才可以被执行,对其他程序的调用将被拒绝.这个目录可以在  PHP.ini文件中用safe_model_exex_dir指令,或在编译PHP时加上–with-exec-dir选项来指定,默认是  /usr/local/php/bin.</p>\n<p>如果你调用一个应该可以输出结果的外部命令(意思是PHP脚本没有错误),得到的却是一片空白,那么很可能   你的网管已经把PHP运行在安全模式下了.</p>\n<h3 id=\"三如何做\"><a href=\"#三如何做\" class=\"headerlink\" title=\"三如何做\"></a>三如何做</h3><h4 id=\"在PHP中调用外部命令-可以用如下三种方法来实现\"><a href=\"#在PHP中调用外部命令-可以用如下三种方法来实现\" class=\"headerlink\" title=\"在PHP中调用外部命令,可以用如下三种方法来实现:\"></a>在PHP中调用外部命令,可以用如下三种方法来实现:</h4><ul>\n<li>1 ) 用PHP提供的专门函数</li>\n</ul>\n<h3 id=\"php提供了3个专门的执行外部命令的函数-system-exec-passthru\"><a href=\"#php提供了3个专门的执行外部命令的函数-system-exec-passthru\" class=\"headerlink\" title=\"php提供了3个专门的执行外部命令的函数: system(),exec(),passthru().\"></a>php提供了3个专门的执行外部命令的函数: system(),exec(),passthru().</h3><h3 id=\"system\"><a href=\"#system\" class=\"headerlink\" title=\"system()\"></a>system()</h3><p>原型: string system(string command[,int return_var])</p>\n<p>system()函数和其他语言中的差不多,它执行给定的命令,输出和返回结果.第二个参数是可选的,用来得到命令执行后的状态码.</p>\n<p>例子:</p>\n<ul>\n<li>system(“/usr/local/bin/webalizer/webalizer”);</li>\n</ul>\n<h3 id=\"exec\"><a href=\"#exec\" class=\"headerlink\" title=\"exec()\"></a>exec()</h3><p>原型: string exex(string command[,string array[,int return_var]])</p>\n<p>exec()函数与system()类似,也执行给定的命令,但不输出结果,而是返回结果的最后一行.虽然它只返回命令  结果的最后一行,但用第二个参数array可以得到完整的结果,方法是吧结果逐行追加到  array的结尾处.所 以如果array不是空的,在调用之前最好用unset()把它清掉.只有指定了第二个参数时,才可以用第三个参数,用来取得命令执行的状态码.</p>\n<p>例子:</p>\n<ul>\n<li>exec(“/bin/ls -|”);</li>\n<li>exec(“/bin/ls -|”,$res);’</li>\n<li>$res是一个数据,每个元素代表结果的一行</li>\n<li>exec(“/bin/ls -|”,$res,$rc);’</li>\n<li>$rc的值是命令/bin/ls -|的状态码.成功的情况下通常是0</li>\n</ul>\n<h3 id=\"passthru\"><a href=\"#passthru\" class=\"headerlink\" title=\"passthru()\"></a>passthru()</h3><p>  原型: void passthru(string command[,int return_var])</p>\n<p>  passthru()只调用命令,不返回任何结果,但把命令的运行结果原样<br>  地直接输出到标准输出设备上.所以passthru()函数经常用来调用像<br>  pbmplus(Unix下的一个处理图片的工具,输出二进制的原始图片的流)<br>  这样的程序.同样它也可以得到命令执行的状态码.</p>\n<p>  例子</p>\n<p>  header(“Content-type:image/gif”);<br>  passthru(“./ppmtogif hunte.ppm”);</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"引用-http-www-jb51-net-article-57118-htm\"><a href=\"#引用-http-www-jb51-net-article-57118-htm\" class=\"headerlink\" title=\"引用:http://www.jb51.net/article/57118.htm\"></a>引用:<a href=\"http://www.jb51.net/article/57118.htm\" target=\"_blank\" rel=\"noopener\">http://www.jb51.net/article/57118.htm</a></h2><h2 id=\"这篇文章主要介绍了PHP调用shell的方法-包括相关的原理-注意事项及函数的用法-需要的朋友可以参考下\"><a href=\"#这篇文章主要介绍了PHP调用shell的方法-包括相关的原理-注意事项及函数的用法-需要的朋友可以参考下\" class=\"headerlink\" title=\"这篇文章主要介绍了PHP调用shell的方法,包括相关的原理 注意事项及函数的用法,需要的朋友可以参考下\"></a>这篇文章主要介绍了PHP调用shell的方法,包括相关的原理 注意事项及函数的用法,需要的朋友可以参考下</h2><h3 id=\"一-配置\"><a href=\"#一-配置\" class=\"headerlink\" title=\"一 配置\"></a>一 配置</h3><h4 id=\"查看php-ini中配置是否打开安全模式-主要是以下三个地方\"><a href=\"#查看php-ini中配置是否打开安全模式-主要是以下三个地方\" class=\"headerlink\" title=\"查看php.ini中配置是否打开安全模式,主要是以下三个地方\"></a>查看php.ini中配置是否打开安全模式,主要是以下三个地方</h4><ul>\n<li><p>safe_mode = (这个如果是off下面两个就不用管了)</p>\n</li>\n<li><p>disable_functions = </p>\n</li>\n<li><p>safe_mode_exec_dir = </p>\n</li>\n</ul>\n<h3 id=\"二使用\"><a href=\"#二使用\" class=\"headerlink\" title=\"二使用\"></a>二使用</h3><h4 id=\"由于PHP是基本是用于WEB程序开发的-所以安全性成了人们考虑的一个重要方面-于是PHP的设计者们给-PHP加了一个门-安全模式-如果运行在安全模式下-那么PHP脚本中将受到如下四个方面的限制\"><a href=\"#由于PHP是基本是用于WEB程序开发的-所以安全性成了人们考虑的一个重要方面-于是PHP的设计者们给-PHP加了一个门-安全模式-如果运行在安全模式下-那么PHP脚本中将受到如下四个方面的限制\" class=\"headerlink\" title=\"由于PHP是基本是用于WEB程序开发的,所以安全性成了人们考虑的一个重要方面.于是PHP的设计者们给  PHP加了一个门:安全模式.如果运行在安全模式下,那么PHP脚本中将受到如下四个方面的限制:\"></a>由于PHP是基本是用于WEB程序开发的,所以安全性成了人们考虑的一个重要方面.于是PHP的设计者们给  PHP加了一个门:安全模式.如果运行在安全模式下,那么PHP脚本中将受到如下四个方面的限制:</h4><ul>\n<li><p>执行外部命令</p>\n</li>\n<li><p>在打开文件时有些限制</p>\n</li>\n<li><p>连接MYSQL数据库</p>\n</li>\n<li><p>基于HTTP的认证</p>\n</li>\n</ul>\n<p>在安全模式下,只有在特定目录中的外部程序才可以被执行,对其他程序的调用将被拒绝.这个目录可以在  PHP.ini文件中用safe_model_exex_dir指令,或在编译PHP时加上–with-exec-dir选项来指定,默认是  /usr/local/php/bin.</p>\n<p>如果你调用一个应该可以输出结果的外部命令(意思是PHP脚本没有错误),得到的却是一片空白,那么很可能   你的网管已经把PHP运行在安全模式下了.</p>\n<h3 id=\"三如何做\"><a href=\"#三如何做\" class=\"headerlink\" title=\"三如何做\"></a>三如何做</h3><h4 id=\"在PHP中调用外部命令-可以用如下三种方法来实现\"><a href=\"#在PHP中调用外部命令-可以用如下三种方法来实现\" class=\"headerlink\" title=\"在PHP中调用外部命令,可以用如下三种方法来实现:\"></a>在PHP中调用外部命令,可以用如下三种方法来实现:</h4><ul>\n<li>1 ) 用PHP提供的专门函数</li>\n</ul>\n<h3 id=\"php提供了3个专门的执行外部命令的函数-system-exec-passthru\"><a href=\"#php提供了3个专门的执行外部命令的函数-system-exec-passthru\" class=\"headerlink\" title=\"php提供了3个专门的执行外部命令的函数: system(),exec(),passthru().\"></a>php提供了3个专门的执行外部命令的函数: system(),exec(),passthru().</h3><h3 id=\"system\"><a href=\"#system\" class=\"headerlink\" title=\"system()\"></a>system()</h3><p>原型: string system(string command[,int return_var])</p>\n<p>system()函数和其他语言中的差不多,它执行给定的命令,输出和返回结果.第二个参数是可选的,用来得到命令执行后的状态码.</p>\n<p>例子:</p>\n<ul>\n<li>system(“/usr/local/bin/webalizer/webalizer”);</li>\n</ul>\n<h3 id=\"exec\"><a href=\"#exec\" class=\"headerlink\" title=\"exec()\"></a>exec()</h3><p>原型: string exex(string command[,string array[,int return_var]])</p>\n<p>exec()函数与system()类似,也执行给定的命令,但不输出结果,而是返回结果的最后一行.虽然它只返回命令  结果的最后一行,但用第二个参数array可以得到完整的结果,方法是吧结果逐行追加到  array的结尾处.所 以如果array不是空的,在调用之前最好用unset()把它清掉.只有指定了第二个参数时,才可以用第三个参数,用来取得命令执行的状态码.</p>\n<p>例子:</p>\n<ul>\n<li>exec(“/bin/ls -|”);</li>\n<li>exec(“/bin/ls -|”,$res);’</li>\n<li>$res是一个数据,每个元素代表结果的一行</li>\n<li>exec(“/bin/ls -|”,$res,$rc);’</li>\n<li>$rc的值是命令/bin/ls -|的状态码.成功的情况下通常是0</li>\n</ul>\n<h3 id=\"passthru\"><a href=\"#passthru\" class=\"headerlink\" title=\"passthru()\"></a>passthru()</h3><p>  原型: void passthru(string command[,int return_var])</p>\n<p>  passthru()只调用命令,不返回任何结果,但把命令的运行结果原样<br>  地直接输出到标准输出设备上.所以passthru()函数经常用来调用像<br>  pbmplus(Unix下的一个处理图片的工具,输出二进制的原始图片的流)<br>  这样的程序.同样它也可以得到命令执行的状态码.</p>\n<p>  例子</p>\n<p>  header(“Content-type:image/gif”);<br>  passthru(“./ppmtogif hunte.ppm”);</p>\n"},{"title":"spring mvc 控制台输出乱码","date":"2019-09-03T10:18:19.000Z","_content":"1、运行环境：\n操作系统系统：Mac OS X10.12.6，语言：英文\n开发工具：IntelliJ IDEA 2017.2.2，默认编码：UTF-8\nTomcat:9.0.0.M26\n2、问题：运行Web项目时，控制台输出乱码。\n3、解决方法：\n设置Servlet的VM options(虚拟机选项)为：-Dfile.encoding=UTF-8\n![](/images/vmset.png)\n\n[来源](https://www.cnblogs.com/gdwkong/p/7457181.html)","source":"_posts/spring-mvc-控制台输出乱码.md","raw":"---\ntitle: spring mvc 控制台输出乱码\ndate: 2019-09-03 18:18:19\ntags: [Spring,Tomcat]\ncategories: [Tomcat]\n---\n1、运行环境：\n操作系统系统：Mac OS X10.12.6，语言：英文\n开发工具：IntelliJ IDEA 2017.2.2，默认编码：UTF-8\nTomcat:9.0.0.M26\n2、问题：运行Web项目时，控制台输出乱码。\n3、解决方法：\n设置Servlet的VM options(虚拟机选项)为：-Dfile.encoding=UTF-8\n![](/images/vmset.png)\n\n[来源](https://www.cnblogs.com/gdwkong/p/7457181.html)","slug":"spring-mvc-控制台输出乱码","published":1,"updated":"2019-09-27T08:27:08.043Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cede001cojfy6jivtsgq","content":"<p>1、运行环境：<br>操作系统系统：Mac OS X10.12.6，语言：英文<br>开发工具：IntelliJ IDEA 2017.2.2，默认编码：UTF-8<br>Tomcat:9.0.0.M26<br>2、问题：运行Web项目时，控制台输出乱码。<br>3、解决方法：<br>设置Servlet的VM options(虚拟机选项)为：-Dfile.encoding=UTF-8<br><img src=\"/images/vmset.png\" alt></p>\n<p><a href=\"https://www.cnblogs.com/gdwkong/p/7457181.html\" target=\"_blank\" rel=\"noopener\">来源</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1、运行环境：<br>操作系统系统：Mac OS X10.12.6，语言：英文<br>开发工具：IntelliJ IDEA 2017.2.2，默认编码：UTF-8<br>Tomcat:9.0.0.M26<br>2、问题：运行Web项目时，控制台输出乱码。<br>3、解决方法：<br>设置Servlet的VM options(虚拟机选项)为：-Dfile.encoding=UTF-8<br><img src=\"/images/vmset.png\" alt></p>\n<p><a href=\"https://www.cnblogs.com/gdwkong/p/7457181.html\" target=\"_blank\" rel=\"noopener\">来源</a></p>\n"},{"title":"tomcat9因为在清除过期缓存条目后可用空间仍不足 - 请考虑增加缓存的最大空间。","date":"2019-08-29T01:55:24.000Z","_content":"## 问题\n因为在清除过期缓存条目后可用空间仍不足 - 请考虑增加缓存的最大空间。\n\n    # 进入Tomcat安装位置\n    $CATALINA_HOME/\n    $ vim ../libexec/conf/context.xml\n    \n    将下面代码添加到 <Context> </Context>中\n    <Resources\n             cachingAllowed=\"true\"\n             cacheMaxSize=\"100000\"\n     \t/>\n","source":"_posts/tomcat9因为在清除过期缓存条目后可用空间仍不足-请考虑增加缓存的最大空间。.md","raw":"---\ntitle: tomcat9因为在清除过期缓存条目后可用空间仍不足 - 请考虑增加缓存的最大空间。\ndate: 2019-08-29 09:55:24\ntags: [java tomcat]\n---\n## 问题\n因为在清除过期缓存条目后可用空间仍不足 - 请考虑增加缓存的最大空间。\n\n    # 进入Tomcat安装位置\n    $CATALINA_HOME/\n    $ vim ../libexec/conf/context.xml\n    \n    将下面代码添加到 <Context> </Context>中\n    <Resources\n             cachingAllowed=\"true\"\n             cacheMaxSize=\"100000\"\n     \t/>\n","slug":"tomcat9因为在清除过期缓存条目后可用空间仍不足-请考虑增加缓存的最大空间。","published":1,"updated":"2019-09-27T08:27:08.044Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cede001dojfyjaxsh9lr","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>因为在清除过期缓存条目后可用空间仍不足 - 请考虑增加缓存的最大空间。</p>\n<pre><code># 进入Tomcat安装位置\n$CATALINA_HOME/\n$ vim ../libexec/conf/context.xml\n\n将下面代码添加到 &lt;Context&gt; &lt;/Context&gt;中\n&lt;Resources\n         cachingAllowed=&quot;true&quot;\n         cacheMaxSize=&quot;100000&quot;\n     /&gt;</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>因为在清除过期缓存条目后可用空间仍不足 - 请考虑增加缓存的最大空间。</p>\n<pre><code># 进入Tomcat安装位置\n$CATALINA_HOME/\n$ vim ../libexec/conf/context.xml\n\n将下面代码添加到 &lt;Context&gt; &lt;/Context&gt;中\n&lt;Resources\n         cachingAllowed=&quot;true&quot;\n         cacheMaxSize=&quot;100000&quot;\n     /&gt;</code></pre>"},{"title":"springmvc在controller方法里面跳转外网的方法  ","date":"2019-09-27T07:17:15.000Z","_content":"\n1.return new ModelAndView(new RedirectView(\"https://www.baidu.com\"));\n\n2.return  \"redirect:https://www.baidu.com/\";\n\n\n","source":"_posts/springmvc在controller方法里面跳转外网的方法.md","raw":"---\ntitle: 'springmvc在controller方法里面跳转外网的方法  '\ndate: 2019-09-27 15:17:15\ntags: [java,spring]\ncategories: [spring]\n---\n\n1.return new ModelAndView(new RedirectView(\"https://www.baidu.com\"));\n\n2.return  \"redirect:https://www.baidu.com/\";\n\n\n","slug":"springmvc在controller方法里面跳转外网的方法","published":1,"updated":"2019-09-27T08:27:08.044Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedf001eojfynvfv7iel","content":"<p>1.return new ModelAndView(new RedirectView(“<a href=\"https://www.baidu.com&quot;\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com&quot;</a>));</p>\n<p>2.return  “redirect:<a href=\"https://www.baidu.com/&quot;\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com/&quot;</a>;</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.return new ModelAndView(new RedirectView(“<a href=\"https://www.baidu.com&quot;\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com&quot;</a>));</p>\n<p>2.return  “redirect:<a href=\"https://www.baidu.com/&quot;\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com/&quot;</a>;</p>\n"},{"title":"ubuntu16.04The System is running in low-graphics mode终极解决办法","date":"2018-04-26T03:49:10.000Z","_content":"\n## 问题: The system is running in low-graphics mode\n\n## 引用: https://blog.csdn.net/gpwner/article/details/79178832\n\n大道至简,找了好多答案,最后发现这种方法最简单\n\nsudo apt update\n\nsudo apt upgrade\n\n","source":"_posts/ubuntu16-04_The_system_is_running_in_low_graphics_mode终极解决办法.md","raw":"---\ntitle: ubuntu16.04The System is running in low-graphics mode终极解决办法 \ndate: 2018-04-26 11:49:10\ntags: \n- Linux\n- ubuntu\ncategories: \n- 异常处理\n---\n\n## 问题: The system is running in low-graphics mode\n\n## 引用: https://blog.csdn.net/gpwner/article/details/79178832\n\n大道至简,找了好多答案,最后发现这种方法最简单\n\nsudo apt update\n\nsudo apt upgrade\n\n","slug":"ubuntu16-04_The_system_is_running_in_low_graphics_mode终极解决办法","published":1,"updated":"2019-09-27T08:27:08.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedf001fojfyixs02em2","content":"<h2 id=\"问题-The-system-is-running-in-low-graphics-mode\"><a href=\"#问题-The-system-is-running-in-low-graphics-mode\" class=\"headerlink\" title=\"问题: The system is running in low-graphics mode\"></a>问题: The system is running in low-graphics mode</h2><h2 id=\"引用-https-blog-csdn-net-gpwner-article-details-79178832\"><a href=\"#引用-https-blog-csdn-net-gpwner-article-details-79178832\" class=\"headerlink\" title=\"引用: https://blog.csdn.net/gpwner/article/details/79178832\"></a>引用: <a href=\"https://blog.csdn.net/gpwner/article/details/79178832\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/gpwner/article/details/79178832</a></h2><p>大道至简,找了好多答案,最后发现这种方法最简单</p>\n<p>sudo apt update</p>\n<p>sudo apt upgrade</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题-The-system-is-running-in-low-graphics-mode\"><a href=\"#问题-The-system-is-running-in-low-graphics-mode\" class=\"headerlink\" title=\"问题: The system is running in low-graphics mode\"></a>问题: The system is running in low-graphics mode</h2><h2 id=\"引用-https-blog-csdn-net-gpwner-article-details-79178832\"><a href=\"#引用-https-blog-csdn-net-gpwner-article-details-79178832\" class=\"headerlink\" title=\"引用: https://blog.csdn.net/gpwner/article/details/79178832\"></a>引用: <a href=\"https://blog.csdn.net/gpwner/article/details/79178832\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/gpwner/article/details/79178832</a></h2><p>大道至简,找了好多答案,最后发现这种方法最简单</p>\n<p>sudo apt update</p>\n<p>sudo apt upgrade</p>\n"},{"title":"vim教程","date":"2019-06-11T01:43:44.000Z","_content":"## linux下 输入命令 vimtutor 基本练习\n\n## vim使用的区域(块)选择\n    \n    ctrl+v 块选择\n    \n## 字符选择    \n\n    v 小写的v字符选择\n    \n## 行选择    \n\n    shift+v 大写V行选择\n    \n## vim的模式    \n    \n    esc  进入普通模式\n    \n    shift + : 进入命令模式\n    \n    普通模式下 a 在光标尾插入\n    普通模式下 i 在光标首插入\n\n    vim包括一般模式,插入模式,命令模式,区域选择在一般模式下,\n    选择的区域包括固定黑色,闪动黑色,闪动黑色表示光标位置.\n    在区域选择的情况下,d删除选择的区域,y复制选择的区域,p\n    粘贴选择的区域,小写p在当前行的下一行粘贴.大写P在当前行\n    的上一行粘贴.\n    \n## 在当前行首添加字符ddd    \n    \n    命令模式下\n    .s/^/ddd/g   \n    \n## 在第三行到第六行添加字符ddd    \n\n    3,6s/^/ddd/g\n    \n    \n## 在当前行尾添加字符ddd    \n    \n    .s/$/ddd/g\n    \n\n","source":"_posts/vim教程.md","raw":"---\ntitle: vim教程\ndate: 2019-06-11 09:43:44\ntags: vim\ncategories: \n- linux\n---\n## linux下 输入命令 vimtutor 基本练习\n\n## vim使用的区域(块)选择\n    \n    ctrl+v 块选择\n    \n## 字符选择    \n\n    v 小写的v字符选择\n    \n## 行选择    \n\n    shift+v 大写V行选择\n    \n## vim的模式    \n    \n    esc  进入普通模式\n    \n    shift + : 进入命令模式\n    \n    普通模式下 a 在光标尾插入\n    普通模式下 i 在光标首插入\n\n    vim包括一般模式,插入模式,命令模式,区域选择在一般模式下,\n    选择的区域包括固定黑色,闪动黑色,闪动黑色表示光标位置.\n    在区域选择的情况下,d删除选择的区域,y复制选择的区域,p\n    粘贴选择的区域,小写p在当前行的下一行粘贴.大写P在当前行\n    的上一行粘贴.\n    \n## 在当前行首添加字符ddd    \n    \n    命令模式下\n    .s/^/ddd/g   \n    \n## 在第三行到第六行添加字符ddd    \n\n    3,6s/^/ddd/g\n    \n    \n## 在当前行尾添加字符ddd    \n    \n    .s/$/ddd/g\n    \n\n","slug":"vim教程","published":1,"updated":"2019-09-27T08:27:08.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedg001gojfy0zx66tta","content":"<h2 id=\"linux下-输入命令-vimtutor-基本练习\"><a href=\"#linux下-输入命令-vimtutor-基本练习\" class=\"headerlink\" title=\"linux下 输入命令 vimtutor 基本练习\"></a>linux下 输入命令 vimtutor 基本练习</h2><h2 id=\"vim使用的区域-块-选择\"><a href=\"#vim使用的区域-块-选择\" class=\"headerlink\" title=\"vim使用的区域(块)选择\"></a>vim使用的区域(块)选择</h2><pre><code>ctrl+v 块选择</code></pre><h2 id=\"字符选择\"><a href=\"#字符选择\" class=\"headerlink\" title=\"字符选择\"></a>字符选择</h2><pre><code>v 小写的v字符选择</code></pre><h2 id=\"行选择\"><a href=\"#行选择\" class=\"headerlink\" title=\"行选择\"></a>行选择</h2><pre><code>shift+v 大写V行选择</code></pre><h2 id=\"vim的模式\"><a href=\"#vim的模式\" class=\"headerlink\" title=\"vim的模式\"></a>vim的模式</h2><pre><code>esc  进入普通模式\n\nshift + : 进入命令模式\n\n普通模式下 a 在光标尾插入\n普通模式下 i 在光标首插入\n\nvim包括一般模式,插入模式,命令模式,区域选择在一般模式下,\n选择的区域包括固定黑色,闪动黑色,闪动黑色表示光标位置.\n在区域选择的情况下,d删除选择的区域,y复制选择的区域,p\n粘贴选择的区域,小写p在当前行的下一行粘贴.大写P在当前行\n的上一行粘贴.</code></pre><h2 id=\"在当前行首添加字符ddd\"><a href=\"#在当前行首添加字符ddd\" class=\"headerlink\" title=\"在当前行首添加字符ddd\"></a>在当前行首添加字符ddd</h2><pre><code>命令模式下\n.s/^/ddd/g   </code></pre><h2 id=\"在第三行到第六行添加字符ddd\"><a href=\"#在第三行到第六行添加字符ddd\" class=\"headerlink\" title=\"在第三行到第六行添加字符ddd\"></a>在第三行到第六行添加字符ddd</h2><pre><code>3,6s/^/ddd/g</code></pre><h2 id=\"在当前行尾添加字符ddd\"><a href=\"#在当前行尾添加字符ddd\" class=\"headerlink\" title=\"在当前行尾添加字符ddd\"></a>在当前行尾添加字符ddd</h2><pre><code>.s/$/ddd/g</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"linux下-输入命令-vimtutor-基本练习\"><a href=\"#linux下-输入命令-vimtutor-基本练习\" class=\"headerlink\" title=\"linux下 输入命令 vimtutor 基本练习\"></a>linux下 输入命令 vimtutor 基本练习</h2><h2 id=\"vim使用的区域-块-选择\"><a href=\"#vim使用的区域-块-选择\" class=\"headerlink\" title=\"vim使用的区域(块)选择\"></a>vim使用的区域(块)选择</h2><pre><code>ctrl+v 块选择</code></pre><h2 id=\"字符选择\"><a href=\"#字符选择\" class=\"headerlink\" title=\"字符选择\"></a>字符选择</h2><pre><code>v 小写的v字符选择</code></pre><h2 id=\"行选择\"><a href=\"#行选择\" class=\"headerlink\" title=\"行选择\"></a>行选择</h2><pre><code>shift+v 大写V行选择</code></pre><h2 id=\"vim的模式\"><a href=\"#vim的模式\" class=\"headerlink\" title=\"vim的模式\"></a>vim的模式</h2><pre><code>esc  进入普通模式\n\nshift + : 进入命令模式\n\n普通模式下 a 在光标尾插入\n普通模式下 i 在光标首插入\n\nvim包括一般模式,插入模式,命令模式,区域选择在一般模式下,\n选择的区域包括固定黑色,闪动黑色,闪动黑色表示光标位置.\n在区域选择的情况下,d删除选择的区域,y复制选择的区域,p\n粘贴选择的区域,小写p在当前行的下一行粘贴.大写P在当前行\n的上一行粘贴.</code></pre><h2 id=\"在当前行首添加字符ddd\"><a href=\"#在当前行首添加字符ddd\" class=\"headerlink\" title=\"在当前行首添加字符ddd\"></a>在当前行首添加字符ddd</h2><pre><code>命令模式下\n.s/^/ddd/g   </code></pre><h2 id=\"在第三行到第六行添加字符ddd\"><a href=\"#在第三行到第六行添加字符ddd\" class=\"headerlink\" title=\"在第三行到第六行添加字符ddd\"></a>在第三行到第六行添加字符ddd</h2><pre><code>3,6s/^/ddd/g</code></pre><h2 id=\"在当前行尾添加字符ddd\"><a href=\"#在当前行尾添加字符ddd\" class=\"headerlink\" title=\"在当前行尾添加字符ddd\"></a>在当前行尾添加字符ddd</h2><pre><code>.s/$/ddd/g</code></pre>"},{"title":".zip和.tar.gz的文件有什么区别","date":"2018-04-27T12:22:56.000Z","_content":"\n## 转自:https://blog.csdn.net/suyu_yuan/article/details/52733117\n\n.tar.gz 压缩格式用于unix的操作系统,但在windows系统中用WinRar工具\n\n同样可以解压缩tar.gz格式的\n\nzip流行于windows系统上的压缩文件(其他系统也可以打开).zip格式开发且\n\n免费.zip支持分卷压缩,128/256-bitAES加密算法等功能.zip的含义是速度,其\n\n目标是为顶替ARC而诞生的\"职业\"压缩软件.\n\n\ntar是\"table archive\"(磁带存档)的简称,它出现在还没有软盘驱动器 硬盘和\n\n光盘驱动器的计算机早期阶段,随着时间的推移,tar命令逐渐变为一个将很多文件\n\n进行存档的工具,目前许多用于Linux操作系统的程序就是打包为tar档案文件的形式\n\n.在Linux里面,tar一般和其他没有文件管理的压缩算法文件结合使用,用tar打包整\n\n个文件目录结构成一个文件,再用gz,bzip等压缩算法压缩成一次,也是Linux常见的\n\n压缩归档的处理方法.\n\n","source":"_posts/zip和-tar-gz的文件有什么区别.md","raw":"---\ntitle: .zip和.tar.gz的文件有什么区别\ndate: 2018-04-27 20:22:56\ntags: linux\ncategories: \n- linux\n---\n\n## 转自:https://blog.csdn.net/suyu_yuan/article/details/52733117\n\n.tar.gz 压缩格式用于unix的操作系统,但在windows系统中用WinRar工具\n\n同样可以解压缩tar.gz格式的\n\nzip流行于windows系统上的压缩文件(其他系统也可以打开).zip格式开发且\n\n免费.zip支持分卷压缩,128/256-bitAES加密算法等功能.zip的含义是速度,其\n\n目标是为顶替ARC而诞生的\"职业\"压缩软件.\n\n\ntar是\"table archive\"(磁带存档)的简称,它出现在还没有软盘驱动器 硬盘和\n\n光盘驱动器的计算机早期阶段,随着时间的推移,tar命令逐渐变为一个将很多文件\n\n进行存档的工具,目前许多用于Linux操作系统的程序就是打包为tar档案文件的形式\n\n.在Linux里面,tar一般和其他没有文件管理的压缩算法文件结合使用,用tar打包整\n\n个文件目录结构成一个文件,再用gz,bzip等压缩算法压缩成一次,也是Linux常见的\n\n压缩归档的处理方法.\n\n","slug":"zip和-tar-gz的文件有什么区别","published":1,"updated":"2019-09-27T08:27:08.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedg001hojfy3wlrpimw","content":"<h2 id=\"转自-https-blog-csdn-net-suyu-yuan-article-details-52733117\"><a href=\"#转自-https-blog-csdn-net-suyu-yuan-article-details-52733117\" class=\"headerlink\" title=\"转自:https://blog.csdn.net/suyu_yuan/article/details/52733117\"></a>转自:<a href=\"https://blog.csdn.net/suyu_yuan/article/details/52733117\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/suyu_yuan/article/details/52733117</a></h2><p>.tar.gz 压缩格式用于unix的操作系统,但在windows系统中用WinRar工具</p>\n<p>同样可以解压缩tar.gz格式的</p>\n<p>zip流行于windows系统上的压缩文件(其他系统也可以打开).zip格式开发且</p>\n<p>免费.zip支持分卷压缩,128/256-bitAES加密算法等功能.zip的含义是速度,其</p>\n<p>目标是为顶替ARC而诞生的”职业”压缩软件.</p>\n<p>tar是”table archive”(磁带存档)的简称,它出现在还没有软盘驱动器 硬盘和</p>\n<p>光盘驱动器的计算机早期阶段,随着时间的推移,tar命令逐渐变为一个将很多文件</p>\n<p>进行存档的工具,目前许多用于Linux操作系统的程序就是打包为tar档案文件的形式</p>\n<p>.在Linux里面,tar一般和其他没有文件管理的压缩算法文件结合使用,用tar打包整</p>\n<p>个文件目录结构成一个文件,再用gz,bzip等压缩算法压缩成一次,也是Linux常见的</p>\n<p>压缩归档的处理方法.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"转自-https-blog-csdn-net-suyu-yuan-article-details-52733117\"><a href=\"#转自-https-blog-csdn-net-suyu-yuan-article-details-52733117\" class=\"headerlink\" title=\"转自:https://blog.csdn.net/suyu_yuan/article/details/52733117\"></a>转自:<a href=\"https://blog.csdn.net/suyu_yuan/article/details/52733117\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/suyu_yuan/article/details/52733117</a></h2><p>.tar.gz 压缩格式用于unix的操作系统,但在windows系统中用WinRar工具</p>\n<p>同样可以解压缩tar.gz格式的</p>\n<p>zip流行于windows系统上的压缩文件(其他系统也可以打开).zip格式开发且</p>\n<p>免费.zip支持分卷压缩,128/256-bitAES加密算法等功能.zip的含义是速度,其</p>\n<p>目标是为顶替ARC而诞生的”职业”压缩软件.</p>\n<p>tar是”table archive”(磁带存档)的简称,它出现在还没有软盘驱动器 硬盘和</p>\n<p>光盘驱动器的计算机早期阶段,随着时间的推移,tar命令逐渐变为一个将很多文件</p>\n<p>进行存档的工具,目前许多用于Linux操作系统的程序就是打包为tar档案文件的形式</p>\n<p>.在Linux里面,tar一般和其他没有文件管理的压缩算法文件结合使用,用tar打包整</p>\n<p>个文件目录结构成一个文件,再用gz,bzip等压缩算法压缩成一次,也是Linux常见的</p>\n<p>压缩归档的处理方法.</p>\n"},{"title":"一个bug的旅程","date":"2019-09-04T10:15:09.000Z","_content":"\n大家好我叫bug,我爸叫后台,我妈叫大前端(H5,安卓,IOS)\n听说有一个叫天堂的地方特美,我的目标就是天堂.\n\n一天我懒洋洋的躺在海边,沐浴着和煦得阳光.吃着习惯,吹着\n海风.意淫着隔壁的漂亮妹子......\n\n突然一个叫测试的家伙发现了我!追着我就跑,非说要超度\n我到天堂!\n\n天堂有个规矩:不收无名之辈\n\n两条路摆在了我面前\n\n    1: 测试拿问题页面 -> 前端 -> 前端提供接口名 参数 返回值 -> 后台\n    2: 测试拿问题页面 -> 后端 -> 前端 -> 前端提供接口名 参数 返回值 -> 后台\n    \n好吧测试是个傻子一会儿走路线1 一会儿走路线2\n\n我走路线1,很快到了天堂,天堂有好多妹子......\n","source":"_posts/一个bug的旅程.md","raw":"---\ntitle: 一个bug的旅程\ndate: 2019-09-04 18:15:09\ntags: [bug,生活]\ncategories: [生活]\n---\n\n大家好我叫bug,我爸叫后台,我妈叫大前端(H5,安卓,IOS)\n听说有一个叫天堂的地方特美,我的目标就是天堂.\n\n一天我懒洋洋的躺在海边,沐浴着和煦得阳光.吃着习惯,吹着\n海风.意淫着隔壁的漂亮妹子......\n\n突然一个叫测试的家伙发现了我!追着我就跑,非说要超度\n我到天堂!\n\n天堂有个规矩:不收无名之辈\n\n两条路摆在了我面前\n\n    1: 测试拿问题页面 -> 前端 -> 前端提供接口名 参数 返回值 -> 后台\n    2: 测试拿问题页面 -> 后端 -> 前端 -> 前端提供接口名 参数 返回值 -> 后台\n    \n好吧测试是个傻子一会儿走路线1 一会儿走路线2\n\n我走路线1,很快到了天堂,天堂有好多妹子......\n","slug":"一个bug的旅程","published":1,"updated":"2019-09-27T08:27:08.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedh001iojfyaf0lh7kd","content":"<p>大家好我叫bug,我爸叫后台,我妈叫大前端(H5,安卓,IOS)<br>听说有一个叫天堂的地方特美,我的目标就是天堂.</p>\n<p>一天我懒洋洋的躺在海边,沐浴着和煦得阳光.吃着习惯,吹着<br>海风.意淫着隔壁的漂亮妹子……</p>\n<p>突然一个叫测试的家伙发现了我!追着我就跑,非说要超度<br>我到天堂!</p>\n<p>天堂有个规矩:不收无名之辈</p>\n<p>两条路摆在了我面前</p>\n<pre><code>1: 测试拿问题页面 -&gt; 前端 -&gt; 前端提供接口名 参数 返回值 -&gt; 后台\n2: 测试拿问题页面 -&gt; 后端 -&gt; 前端 -&gt; 前端提供接口名 参数 返回值 -&gt; 后台</code></pre><p>好吧测试是个傻子一会儿走路线1 一会儿走路线2</p>\n<p>我走路线1,很快到了天堂,天堂有好多妹子……</p>\n","site":{"data":{}},"excerpt":"","more":"<p>大家好我叫bug,我爸叫后台,我妈叫大前端(H5,安卓,IOS)<br>听说有一个叫天堂的地方特美,我的目标就是天堂.</p>\n<p>一天我懒洋洋的躺在海边,沐浴着和煦得阳光.吃着习惯,吹着<br>海风.意淫着隔壁的漂亮妹子……</p>\n<p>突然一个叫测试的家伙发现了我!追着我就跑,非说要超度<br>我到天堂!</p>\n<p>天堂有个规矩:不收无名之辈</p>\n<p>两条路摆在了我面前</p>\n<pre><code>1: 测试拿问题页面 -&gt; 前端 -&gt; 前端提供接口名 参数 返回值 -&gt; 后台\n2: 测试拿问题页面 -&gt; 后端 -&gt; 前端 -&gt; 前端提供接口名 参数 返回值 -&gt; 后台</code></pre><p>好吧测试是个傻子一会儿走路线1 一会儿走路线2</p>\n<p>我走路线1,很快到了天堂,天堂有好多妹子……</p>\n"},{"title":"上线准备流程","date":"2019-04-18T07:14:54.000Z","_content":"\n# 未来校长之家上线准备流程\n\n## 准备\n\n* 搭建生产环境(PHP,Mysql,Redis等已完成)\n\n* 移动端与web端准备上线包\n\n* 清除生产垃圾数据\n\n## 核心流程图\n\n![流程示例](http://enchoufile.xiaohe.com/%E4%B8%8A%E7%BA%BF%E6%B5%81%E7%A8%8B.png)\n\n## 注意事项\n\n* [点击查看接口调用地址](http://cop.edu2035.cn/)\n\n* 超管生成基础参数非必须\n\n* 超管权限程序不可修改\n\n\n\n\n\n","source":"_posts/上线准备流程.md","raw":"---\ntitle: 上线准备流程\ndate: 2019-04-18 15:14:54\ntags:\n---\n\n# 未来校长之家上线准备流程\n\n## 准备\n\n* 搭建生产环境(PHP,Mysql,Redis等已完成)\n\n* 移动端与web端准备上线包\n\n* 清除生产垃圾数据\n\n## 核心流程图\n\n![流程示例](http://enchoufile.xiaohe.com/%E4%B8%8A%E7%BA%BF%E6%B5%81%E7%A8%8B.png)\n\n## 注意事项\n\n* [点击查看接口调用地址](http://cop.edu2035.cn/)\n\n* 超管生成基础参数非必须\n\n* 超管权限程序不可修改\n\n\n\n\n\n","slug":"上线准备流程","published":1,"updated":"2019-09-27T08:27:08.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedh001jojfyl1y9hhs2","content":"<h1 id=\"未来校长之家上线准备流程\"><a href=\"#未来校长之家上线准备流程\" class=\"headerlink\" title=\"未来校长之家上线准备流程\"></a>未来校长之家上线准备流程</h1><h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><ul>\n<li><p>搭建生产环境(PHP,Mysql,Redis等已完成)</p>\n</li>\n<li><p>移动端与web端准备上线包</p>\n</li>\n<li><p>清除生产垃圾数据</p>\n</li>\n</ul>\n<h2 id=\"核心流程图\"><a href=\"#核心流程图\" class=\"headerlink\" title=\"核心流程图\"></a>核心流程图</h2><p><img src=\"http://enchoufile.xiaohe.com/%E4%B8%8A%E7%BA%BF%E6%B5%81%E7%A8%8B.png\" alt=\"流程示例\"></p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ul>\n<li><p><a href=\"http://cop.edu2035.cn/\" target=\"_blank\" rel=\"noopener\">点击查看接口调用地址</a></p>\n</li>\n<li><p>超管生成基础参数非必须</p>\n</li>\n<li><p>超管权限程序不可修改</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"未来校长之家上线准备流程\"><a href=\"#未来校长之家上线准备流程\" class=\"headerlink\" title=\"未来校长之家上线准备流程\"></a>未来校长之家上线准备流程</h1><h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><ul>\n<li><p>搭建生产环境(PHP,Mysql,Redis等已完成)</p>\n</li>\n<li><p>移动端与web端准备上线包</p>\n</li>\n<li><p>清除生产垃圾数据</p>\n</li>\n</ul>\n<h2 id=\"核心流程图\"><a href=\"#核心流程图\" class=\"headerlink\" title=\"核心流程图\"></a>核心流程图</h2><p><img src=\"http://enchoufile.xiaohe.com/%E4%B8%8A%E7%BA%BF%E6%B5%81%E7%A8%8B.png\" alt=\"流程示例\"></p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ul>\n<li><p><a href=\"http://cop.edu2035.cn/\" target=\"_blank\" rel=\"noopener\">点击查看接口调用地址</a></p>\n</li>\n<li><p>超管生成基础参数非必须</p>\n</li>\n<li><p>超管权限程序不可修改</p>\n</li>\n</ul>\n"},{"title":"不止代码","date":"2018-07-06T06:41:42.000Z","_content":"\n不止代码理解\n\n将学到的东西真正试试,才能理解更加深刻.\n\nI hear and i forget .\nI see and i remember.\nI do and i understand.\n\n","source":"_posts/不止代码.md","raw":"---\ntitle: 不止代码\ndate: 2018-07-06 14:41:42\ntags: 生活 \ncategories: \n- 生活\n---\n\n不止代码理解\n\n将学到的东西真正试试,才能理解更加深刻.\n\nI hear and i forget .\nI see and i remember.\nI do and i understand.\n\n","slug":"不止代码","published":1,"updated":"2019-09-27T08:27:08.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedi001kojfywctap0oi","content":"<p>不止代码理解</p>\n<p>将学到的东西真正试试,才能理解更加深刻.</p>\n<p>I hear and i forget .<br>I see and i remember.<br>I do and i understand.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>不止代码理解</p>\n<p>将学到的东西真正试试,才能理解更加深刻.</p>\n<p>I hear and i forget .<br>I see and i remember.<br>I do and i understand.</p>\n"},{"title":"五笔口诀","date":"2018-07-25T09:11:17.000Z","_content":"\n五笔字型最直观,依照笔画把码编;\n键名汉字打四下,基本字根请照搬;\n一二三末取四码,顺序拆分大优先;\n不足四码要注意,交叉识别补后边\n\n## 86版五笔字根\n\n1区横起笔\n11G 王旁青头戋（兼）五一\n12F 土士二干十寸雨\n13D 大犬三（羊）古石厂\n14S 木丁西\n15A 工戈草头右框七\n2区竖起笔\n21H 目具上止卜虎皮\n22J 日早两竖与虫依\n23K 口与川，字根稀\n24L 田甲方框四车力\n25M 山由贝，下框几\n3区撇起笔\n31T 禾竹一撇双人立，反文条头共三一\n32R 白手看头三二斤\n33E 月彡（衫）乃用家衣底\n34W 人和八，三四里\n35Q 金勺缺点无尾鱼，犬旁留儿一点夕，氏无七（妻）\n4区点起笔\n41Y 言文方广在四一，高头一捺谁人去\n42U 立辛两点六门疒\n43I 水旁兴头小倒立\n44O 火业头，四点米\n45P 之字军盖道建底，摘礻（示）衤（衣）\n5区折起笔\n51N 已半巳满不出己，左框折尸心和羽\n52B 子耳了也框向上\n53V 女刀九臼山朝西\n54C 又巴马，丢矢矣\n55X 慈母无心弓和匕，幼无力\n","source":"_posts/五笔口诀.md","raw":"---\ntitle: 五笔口诀\ndate: 2018-07-25 17:11:17\ntags:\n---\n\n五笔字型最直观,依照笔画把码编;\n键名汉字打四下,基本字根请照搬;\n一二三末取四码,顺序拆分大优先;\n不足四码要注意,交叉识别补后边\n\n## 86版五笔字根\n\n1区横起笔\n11G 王旁青头戋（兼）五一\n12F 土士二干十寸雨\n13D 大犬三（羊）古石厂\n14S 木丁西\n15A 工戈草头右框七\n2区竖起笔\n21H 目具上止卜虎皮\n22J 日早两竖与虫依\n23K 口与川，字根稀\n24L 田甲方框四车力\n25M 山由贝，下框几\n3区撇起笔\n31T 禾竹一撇双人立，反文条头共三一\n32R 白手看头三二斤\n33E 月彡（衫）乃用家衣底\n34W 人和八，三四里\n35Q 金勺缺点无尾鱼，犬旁留儿一点夕，氏无七（妻）\n4区点起笔\n41Y 言文方广在四一，高头一捺谁人去\n42U 立辛两点六门疒\n43I 水旁兴头小倒立\n44O 火业头，四点米\n45P 之字军盖道建底，摘礻（示）衤（衣）\n5区折起笔\n51N 已半巳满不出己，左框折尸心和羽\n52B 子耳了也框向上\n53V 女刀九臼山朝西\n54C 又巴马，丢矢矣\n55X 慈母无心弓和匕，幼无力\n","slug":"五笔口诀","published":1,"updated":"2019-09-27T08:27:08.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedi001lojfy1m943hie","content":"<p>五笔字型最直观,依照笔画把码编;<br>键名汉字打四下,基本字根请照搬;<br>一二三末取四码,顺序拆分大优先;<br>不足四码要注意,交叉识别补后边</p>\n<h2 id=\"86版五笔字根\"><a href=\"#86版五笔字根\" class=\"headerlink\" title=\"86版五笔字根\"></a>86版五笔字根</h2><p>1区横起笔<br>11G 王旁青头戋（兼）五一<br>12F 土士二干十寸雨<br>13D 大犬三（羊）古石厂<br>14S 木丁西<br>15A 工戈草头右框七<br>2区竖起笔<br>21H 目具上止卜虎皮<br>22J 日早两竖与虫依<br>23K 口与川，字根稀<br>24L 田甲方框四车力<br>25M 山由贝，下框几<br>3区撇起笔<br>31T 禾竹一撇双人立，反文条头共三一<br>32R 白手看头三二斤<br>33E 月彡（衫）乃用家衣底<br>34W 人和八，三四里<br>35Q 金勺缺点无尾鱼，犬旁留儿一点夕，氏无七（妻）<br>4区点起笔<br>41Y 言文方广在四一，高头一捺谁人去<br>42U 立辛两点六门疒<br>43I 水旁兴头小倒立<br>44O 火业头，四点米<br>45P 之字军盖道建底，摘礻（示）衤（衣）<br>5区折起笔<br>51N 已半巳满不出己，左框折尸心和羽<br>52B 子耳了也框向上<br>53V 女刀九臼山朝西<br>54C 又巴马，丢矢矣<br>55X 慈母无心弓和匕，幼无力</p>\n","site":{"data":{}},"excerpt":"","more":"<p>五笔字型最直观,依照笔画把码编;<br>键名汉字打四下,基本字根请照搬;<br>一二三末取四码,顺序拆分大优先;<br>不足四码要注意,交叉识别补后边</p>\n<h2 id=\"86版五笔字根\"><a href=\"#86版五笔字根\" class=\"headerlink\" title=\"86版五笔字根\"></a>86版五笔字根</h2><p>1区横起笔<br>11G 王旁青头戋（兼）五一<br>12F 土士二干十寸雨<br>13D 大犬三（羊）古石厂<br>14S 木丁西<br>15A 工戈草头右框七<br>2区竖起笔<br>21H 目具上止卜虎皮<br>22J 日早两竖与虫依<br>23K 口与川，字根稀<br>24L 田甲方框四车力<br>25M 山由贝，下框几<br>3区撇起笔<br>31T 禾竹一撇双人立，反文条头共三一<br>32R 白手看头三二斤<br>33E 月彡（衫）乃用家衣底<br>34W 人和八，三四里<br>35Q 金勺缺点无尾鱼，犬旁留儿一点夕，氏无七（妻）<br>4区点起笔<br>41Y 言文方广在四一，高头一捺谁人去<br>42U 立辛两点六门疒<br>43I 水旁兴头小倒立<br>44O 火业头，四点米<br>45P 之字军盖道建底，摘礻（示）衤（衣）<br>5区折起笔<br>51N 已半巳满不出己，左框折尸心和羽<br>52B 子耳了也框向上<br>53V 女刀九臼山朝西<br>54C 又巴马，丢矢矣<br>55X 慈母无心弓和匕，幼无力</p>\n"},{"title":"初识Shiro","date":"2019-09-12T05:56:37.000Z","_content":"\n# what \n\n# why\n\n# when\n\n","source":"_posts/初识Shiro.md","raw":"---\ntitle: 初识Shiro\ndate: 2019-09-12 13:56:37\ntags: [Shiro,java]\ncategories: [Shiro]\n---\n\n# what \n\n# why\n\n# when\n\n","slug":"初识Shiro","published":1,"updated":"2019-09-27T08:27:08.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedj001mojfybbs7r94x","content":"<h1 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h1><h1 id=\"why\"><a href=\"#why\" class=\"headerlink\" title=\"why\"></a>why</h1><h1 id=\"when\"><a href=\"#when\" class=\"headerlink\" title=\"when\"></a>when</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h1><h1 id=\"why\"><a href=\"#why\" class=\"headerlink\" title=\"why\"></a>why</h1><h1 id=\"when\"><a href=\"#when\" class=\"headerlink\" title=\"when\"></a>when</h1>"},{"title":"关于 getWriter() has already been called for this response 的错误解决办法","date":"2019-09-09T05:46:37.000Z","_content":"\n上篇Filter、FilterChain、FilterConfig 介绍\n文中的代码若在多个filter中执行则会报错\" getWriter() has already been called for this response \"\n\n解决方案为在doFilter() 之前将流关闭.\n\n     public void doFilter(ServletRequest request, ServletResponse response,\n                             FilterChain chain) throws IOException, ServletException {\n            System.out.println(\"begin headers-------------------\");\n            Enumeration<?> headerNames = ((HttpServletRequest)request).getHeaderNames();\n    \n            while(headerNames.hasMoreElements()) {\n                String headerName = (String)headerNames.nextElement();\n                System.out.println(headerName + \": \" + ((HttpServletRequest)request).getHeader(headerName));\n            }\n            System.out.println(\"end headers-------------------\");\n    \n            //在调用目标前写入响应内容\n            response.setContentType(\"text/html; charset=utf-8\");\n            PrintWriter out = response.getWriter();\n            out.println(\"IP地址为：\" + request.getRemoteHost() + \"<br>\");\n    \n    \n            //在目标返回后写入响应内容\n            out.println(\"<br>名称为encoding的初始化参数的值为：\" + paramValue);\n            out.println(\"<br>当前Web程序的真实路径为：\" + filterConfig.getServletContext().getRealPath(\"/\"));\n            out.close(); // 不关闭则会报错 getWriter() has already been called for this response\n            chain.doFilter(request, response);\n        }\n\n\n","source":"_posts/关于-getWriter-has-already-been-called-for-this-response-的错误解决办法.md","raw":"---\ntitle: 关于 getWriter() has already been called for this response 的错误解决办法\ndate: 2019-09-09 13:46:37\ntags: [java,exception]\ncategories: [exception]\n---\n\n上篇Filter、FilterChain、FilterConfig 介绍\n文中的代码若在多个filter中执行则会报错\" getWriter() has already been called for this response \"\n\n解决方案为在doFilter() 之前将流关闭.\n\n     public void doFilter(ServletRequest request, ServletResponse response,\n                             FilterChain chain) throws IOException, ServletException {\n            System.out.println(\"begin headers-------------------\");\n            Enumeration<?> headerNames = ((HttpServletRequest)request).getHeaderNames();\n    \n            while(headerNames.hasMoreElements()) {\n                String headerName = (String)headerNames.nextElement();\n                System.out.println(headerName + \": \" + ((HttpServletRequest)request).getHeader(headerName));\n            }\n            System.out.println(\"end headers-------------------\");\n    \n            //在调用目标前写入响应内容\n            response.setContentType(\"text/html; charset=utf-8\");\n            PrintWriter out = response.getWriter();\n            out.println(\"IP地址为：\" + request.getRemoteHost() + \"<br>\");\n    \n    \n            //在目标返回后写入响应内容\n            out.println(\"<br>名称为encoding的初始化参数的值为：\" + paramValue);\n            out.println(\"<br>当前Web程序的真实路径为：\" + filterConfig.getServletContext().getRealPath(\"/\"));\n            out.close(); // 不关闭则会报错 getWriter() has already been called for this response\n            chain.doFilter(request, response);\n        }\n\n\n","slug":"关于-getWriter-has-already-been-called-for-this-response-的错误解决办法","published":1,"updated":"2019-09-27T08:27:08.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedk001nojfyxpacfngq","content":"<p>上篇Filter、FilterChain、FilterConfig 介绍<br>文中的代码若在多个filter中执行则会报错” getWriter() has already been called for this response “</p>\n<p>解决方案为在doFilter() 之前将流关闭.</p>\n<pre><code>public void doFilter(ServletRequest request, ServletResponse response,\n                        FilterChain chain) throws IOException, ServletException {\n       System.out.println(&quot;begin headers-------------------&quot;);\n       Enumeration&lt;?&gt; headerNames = ((HttpServletRequest)request).getHeaderNames();\n\n       while(headerNames.hasMoreElements()) {\n           String headerName = (String)headerNames.nextElement();\n           System.out.println(headerName + &quot;: &quot; + ((HttpServletRequest)request).getHeader(headerName));\n       }\n       System.out.println(&quot;end headers-------------------&quot;);\n\n       //在调用目标前写入响应内容\n       response.setContentType(&quot;text/html; charset=utf-8&quot;);\n       PrintWriter out = response.getWriter();\n       out.println(&quot;IP地址为：&quot; + request.getRemoteHost() + &quot;&lt;br&gt;&quot;);\n\n\n       //在目标返回后写入响应内容\n       out.println(&quot;&lt;br&gt;名称为encoding的初始化参数的值为：&quot; + paramValue);\n       out.println(&quot;&lt;br&gt;当前Web程序的真实路径为：&quot; + filterConfig.getServletContext().getRealPath(&quot;/&quot;));\n       out.close(); // 不关闭则会报错 getWriter() has already been called for this response\n       chain.doFilter(request, response);\n   }</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>上篇Filter、FilterChain、FilterConfig 介绍<br>文中的代码若在多个filter中执行则会报错” getWriter() has already been called for this response “</p>\n<p>解决方案为在doFilter() 之前将流关闭.</p>\n<pre><code>public void doFilter(ServletRequest request, ServletResponse response,\n                        FilterChain chain) throws IOException, ServletException {\n       System.out.println(&quot;begin headers-------------------&quot;);\n       Enumeration&lt;?&gt; headerNames = ((HttpServletRequest)request).getHeaderNames();\n\n       while(headerNames.hasMoreElements()) {\n           String headerName = (String)headerNames.nextElement();\n           System.out.println(headerName + &quot;: &quot; + ((HttpServletRequest)request).getHeader(headerName));\n       }\n       System.out.println(&quot;end headers-------------------&quot;);\n\n       //在调用目标前写入响应内容\n       response.setContentType(&quot;text/html; charset=utf-8&quot;);\n       PrintWriter out = response.getWriter();\n       out.println(&quot;IP地址为：&quot; + request.getRemoteHost() + &quot;&lt;br&gt;&quot;);\n\n\n       //在目标返回后写入响应内容\n       out.println(&quot;&lt;br&gt;名称为encoding的初始化参数的值为：&quot; + paramValue);\n       out.println(&quot;&lt;br&gt;当前Web程序的真实路径为：&quot; + filterConfig.getServletContext().getRealPath(&quot;/&quot;));\n       out.close(); // 不关闭则会报错 getWriter() has already been called for this response\n       chain.doFilter(request, response);\n   }</code></pre>"},{"title":"使用 lombok 简化 Java 代码  ","date":"2019-09-25T02:27:07.000Z","_content":"\n# 一个典型的 Java 类\n\n    public class A {\n    \n      private int a;\n    \n      private String b;\n    \n      public int getA() {\n        return a;\n      }\n    \n      public String getB() {\n        return b;\n      }\n    \n      public void setA(int a) {\n        this.a = a;\n      }\n    \n      public void setB(String b) {\n        this.b = b;\n      }\n    \n    }\n\n对于这样一个简单的 Java 类，我们通常需要给每个属性写getter和setter，而这种实际上没有什么太大的意义。当然，如果有的公司或团队使用代码行数评估工作量，还是多写几行吧；同时，可以考虑一下我们团队。\n\n# 使用 lombok，简化代码\n为了简化getter与setter，lombok 提供了一种机制，帮助我们自动生成这些样板代码。以上的代码，如果使用lombok的话，将变得很简单：\n\n    @lombok.Getter\n    @lombok.Setter\n    public class A {\n    \n        private int a;\n    \n        private String b;\n    \n    }\n\n顾名思义，lombok.Getter就是生成getter，lombok.Setter就是生成setter。但是，这样真的就可以了么？编译下，让我们看看生成的二进制代码。(请自行下载lombok.jar)\n\n    命令行> javac -cp lombok.jar A.java\n    命令行> javap -c A.class\n\n输出结果略。可以看到完全一样。\n\n更进一步，如果在编译的时候，加入-g:none选项，甚至可以看到生成的文件完全一样。\n\n# 简单使用\n    \n虽然我们可以在编译的时候，加入classpath，但是，一般来说，在各类IDE中使用，还是需要特殊处理一下。\n\n## Maven\n加上依赖就好。同时，由于lombok只在编译期才处理，所以并不需要在运行时有这个依赖，可以把scope定义为provided。\n\n    <dependencies>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <version>1.16.8</version>\n            <scope>provided</scope>\n        </dependency>\n    </dependencies>\n\n值得注意的是，maven的maven-compiler-plugin低版本和lombok高版本不兼容，目前已知maven-compiler-plugin的2.3.X与lombok的1.6.X不兼容。这个需要了解lombok的原理才能进一步说明。\n\n## Eclipse\n由于eclipse的默认编译器并不是javac，所以，需要额外安装，基本就是改下引导参数，可以直接运行jar包，或者手动在eclipse.ini里加上参数-Xbootclasspath/a:lombok.jar -javaagent:lombok.jar。\n\n## IDEA IntelliJ\n    \n虽然IDEA IntelliJ默认使用javac作为编译器，理论上可以不装插件。可是，跳转等特性也随之没了。所以，还是安装个插件吧，直接去仓库里搜索lombok就成。\n\n如果项目中使用高级配置，需要额外注意一下。虽然在编译的时候，lombok配置文件可以在任何能找到的目录，但是，lombok-intellij插件默认并不支持在任何目录，如果有配置文件，建议放在java的源代码根目录中。    \n\n# 更多 lombok 注解\n| 注解 | 解释 |\n| :-- | :-- |\n| @val | 如果你要定义一个final的变量，并且不想写类型，这个可以帮到你。但是，在实际项目中，完全没有使用到。|\n| @NonNull | 这个在参数中使用，如果调用时传了null，就直接抛空指针。 |\n| @Data | @ToString、@EqualsAndHashCode、@Getter、@Setter和@RequiredArgsConstructor注解的集合。|\n| @Getter与@Setter|作用于属性和类上，自动生成属性的getXXX()和setXXX()方法。若在类上，则对所有属性有效。并可通过AccessLevel参数控制方法的访问级别。|\n|@ToString|作用于类，自动重写类的ToString()方法。常用的参数有exclude（指定方法中不包含的属性）、callSuper（方法中是否包含父类ToString()方法返回的值）|\n|@EqualsAndHashCode|作用于类，自动重写类的equals()、hashCode()方法。常用的参数有exclude（指定方法中不包含的属性）、callSuper（方法中是否包含父类ToString()方法返回的值）|\n|@NoArgsConstructor, @RequiredArgsConstructor和@AllArgsConstructor|作用于类，@NoArgsConstructor自动生成不带参数的构造方法；@RequiredArgsConstructor自动生成带参数的构造方法，主要针对一些需要特殊处理的属性，比如未初始化的final属性；@AllArgsConstructor自动生成包含所有属性的构造方法。|\n|@Synchronized|作用于方法，可锁定指定的对象，如果不指定，则默认创建创建一个对象锁定。|\n|@Log，或者直接@Slf4j| 作用于类，具体包含@CommonsLog、@Log、@Log4j、@Log4j2、@Slf4j和@XSlf4j，分别对用不同的日志系统。利用此类注解，可为类创建一个log属性。|\n\n## sonar源码审查\n\nsonar是一个源码审查工具。最新版5.X已经支持lombok的全部注解，不再认为是没有使用的变量。但是，旧的4.X还是认为没有使用这些变量。可以后向移植这些包，或者应用单独的补丁。\n\n[摘自](https://segmentfault.com/a/1190000005133786)\n\n[sonar](https://docs.sonarqube.org/latest/)\n\n                  \n\n \n\n               \n\n \n\n                                                                  \n\n\n\n                    \n\n \n\n           \n\n \n\n                  \n\n  \n","source":"_posts/使用-lombok-简化-Java-代码.md","raw":"---\ntitle: '使用 lombok 简化 Java 代码  '\ndate: 2019-09-25 10:27:07\ntags: [java,lombok]\ncategories: [Lombok]\n---\n\n# 一个典型的 Java 类\n\n    public class A {\n    \n      private int a;\n    \n      private String b;\n    \n      public int getA() {\n        return a;\n      }\n    \n      public String getB() {\n        return b;\n      }\n    \n      public void setA(int a) {\n        this.a = a;\n      }\n    \n      public void setB(String b) {\n        this.b = b;\n      }\n    \n    }\n\n对于这样一个简单的 Java 类，我们通常需要给每个属性写getter和setter，而这种实际上没有什么太大的意义。当然，如果有的公司或团队使用代码行数评估工作量，还是多写几行吧；同时，可以考虑一下我们团队。\n\n# 使用 lombok，简化代码\n为了简化getter与setter，lombok 提供了一种机制，帮助我们自动生成这些样板代码。以上的代码，如果使用lombok的话，将变得很简单：\n\n    @lombok.Getter\n    @lombok.Setter\n    public class A {\n    \n        private int a;\n    \n        private String b;\n    \n    }\n\n顾名思义，lombok.Getter就是生成getter，lombok.Setter就是生成setter。但是，这样真的就可以了么？编译下，让我们看看生成的二进制代码。(请自行下载lombok.jar)\n\n    命令行> javac -cp lombok.jar A.java\n    命令行> javap -c A.class\n\n输出结果略。可以看到完全一样。\n\n更进一步，如果在编译的时候，加入-g:none选项，甚至可以看到生成的文件完全一样。\n\n# 简单使用\n    \n虽然我们可以在编译的时候，加入classpath，但是，一般来说，在各类IDE中使用，还是需要特殊处理一下。\n\n## Maven\n加上依赖就好。同时，由于lombok只在编译期才处理，所以并不需要在运行时有这个依赖，可以把scope定义为provided。\n\n    <dependencies>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <version>1.16.8</version>\n            <scope>provided</scope>\n        </dependency>\n    </dependencies>\n\n值得注意的是，maven的maven-compiler-plugin低版本和lombok高版本不兼容，目前已知maven-compiler-plugin的2.3.X与lombok的1.6.X不兼容。这个需要了解lombok的原理才能进一步说明。\n\n## Eclipse\n由于eclipse的默认编译器并不是javac，所以，需要额外安装，基本就是改下引导参数，可以直接运行jar包，或者手动在eclipse.ini里加上参数-Xbootclasspath/a:lombok.jar -javaagent:lombok.jar。\n\n## IDEA IntelliJ\n    \n虽然IDEA IntelliJ默认使用javac作为编译器，理论上可以不装插件。可是，跳转等特性也随之没了。所以，还是安装个插件吧，直接去仓库里搜索lombok就成。\n\n如果项目中使用高级配置，需要额外注意一下。虽然在编译的时候，lombok配置文件可以在任何能找到的目录，但是，lombok-intellij插件默认并不支持在任何目录，如果有配置文件，建议放在java的源代码根目录中。    \n\n# 更多 lombok 注解\n| 注解 | 解释 |\n| :-- | :-- |\n| @val | 如果你要定义一个final的变量，并且不想写类型，这个可以帮到你。但是，在实际项目中，完全没有使用到。|\n| @NonNull | 这个在参数中使用，如果调用时传了null，就直接抛空指针。 |\n| @Data | @ToString、@EqualsAndHashCode、@Getter、@Setter和@RequiredArgsConstructor注解的集合。|\n| @Getter与@Setter|作用于属性和类上，自动生成属性的getXXX()和setXXX()方法。若在类上，则对所有属性有效。并可通过AccessLevel参数控制方法的访问级别。|\n|@ToString|作用于类，自动重写类的ToString()方法。常用的参数有exclude（指定方法中不包含的属性）、callSuper（方法中是否包含父类ToString()方法返回的值）|\n|@EqualsAndHashCode|作用于类，自动重写类的equals()、hashCode()方法。常用的参数有exclude（指定方法中不包含的属性）、callSuper（方法中是否包含父类ToString()方法返回的值）|\n|@NoArgsConstructor, @RequiredArgsConstructor和@AllArgsConstructor|作用于类，@NoArgsConstructor自动生成不带参数的构造方法；@RequiredArgsConstructor自动生成带参数的构造方法，主要针对一些需要特殊处理的属性，比如未初始化的final属性；@AllArgsConstructor自动生成包含所有属性的构造方法。|\n|@Synchronized|作用于方法，可锁定指定的对象，如果不指定，则默认创建创建一个对象锁定。|\n|@Log，或者直接@Slf4j| 作用于类，具体包含@CommonsLog、@Log、@Log4j、@Log4j2、@Slf4j和@XSlf4j，分别对用不同的日志系统。利用此类注解，可为类创建一个log属性。|\n\n## sonar源码审查\n\nsonar是一个源码审查工具。最新版5.X已经支持lombok的全部注解，不再认为是没有使用的变量。但是，旧的4.X还是认为没有使用这些变量。可以后向移植这些包，或者应用单独的补丁。\n\n[摘自](https://segmentfault.com/a/1190000005133786)\n\n[sonar](https://docs.sonarqube.org/latest/)\n\n                  \n\n \n\n               \n\n \n\n                                                                  \n\n\n\n                    \n\n \n\n           \n\n \n\n                  \n\n  \n","slug":"使用-lombok-简化-Java-代码","published":1,"updated":"2019-09-27T08:27:08.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedl001oojfy9upjax3z","content":"<h1 id=\"一个典型的-Java-类\"><a href=\"#一个典型的-Java-类\" class=\"headerlink\" title=\"一个典型的 Java 类\"></a>一个典型的 Java 类</h1><pre><code>public class A {\n\n  private int a;\n\n  private String b;\n\n  public int getA() {\n    return a;\n  }\n\n  public String getB() {\n    return b;\n  }\n\n  public void setA(int a) {\n    this.a = a;\n  }\n\n  public void setB(String b) {\n    this.b = b;\n  }\n\n}</code></pre><p>对于这样一个简单的 Java 类，我们通常需要给每个属性写getter和setter，而这种实际上没有什么太大的意义。当然，如果有的公司或团队使用代码行数评估工作量，还是多写几行吧；同时，可以考虑一下我们团队。</p>\n<h1 id=\"使用-lombok，简化代码\"><a href=\"#使用-lombok，简化代码\" class=\"headerlink\" title=\"使用 lombok，简化代码\"></a>使用 lombok，简化代码</h1><p>为了简化getter与setter，lombok 提供了一种机制，帮助我们自动生成这些样板代码。以上的代码，如果使用lombok的话，将变得很简单：</p>\n<pre><code>@lombok.Getter\n@lombok.Setter\npublic class A {\n\n    private int a;\n\n    private String b;\n\n}</code></pre><p>顾名思义，lombok.Getter就是生成getter，lombok.Setter就是生成setter。但是，这样真的就可以了么？编译下，让我们看看生成的二进制代码。(请自行下载lombok.jar)</p>\n<pre><code>命令行&gt; javac -cp lombok.jar A.java\n命令行&gt; javap -c A.class</code></pre><p>输出结果略。可以看到完全一样。</p>\n<p>更进一步，如果在编译的时候，加入-g:none选项，甚至可以看到生成的文件完全一样。</p>\n<h1 id=\"简单使用\"><a href=\"#简单使用\" class=\"headerlink\" title=\"简单使用\"></a>简单使用</h1><p>虽然我们可以在编译的时候，加入classpath，但是，一般来说，在各类IDE中使用，还是需要特殊处理一下。</p>\n<h2 id=\"Maven\"><a href=\"#Maven\" class=\"headerlink\" title=\"Maven\"></a>Maven</h2><p>加上依赖就好。同时，由于lombok只在编译期才处理，所以并不需要在运行时有这个依赖，可以把scope定义为provided。</p>\n<pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n        &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n        &lt;version&gt;1.16.8&lt;/version&gt;\n        &lt;scope&gt;provided&lt;/scope&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;</code></pre><p>值得注意的是，maven的maven-compiler-plugin低版本和lombok高版本不兼容，目前已知maven-compiler-plugin的2.3.X与lombok的1.6.X不兼容。这个需要了解lombok的原理才能进一步说明。</p>\n<h2 id=\"Eclipse\"><a href=\"#Eclipse\" class=\"headerlink\" title=\"Eclipse\"></a>Eclipse</h2><p>由于eclipse的默认编译器并不是javac，所以，需要额外安装，基本就是改下引导参数，可以直接运行jar包，或者手动在eclipse.ini里加上参数-Xbootclasspath/a:lombok.jar -javaagent:lombok.jar。</p>\n<h2 id=\"IDEA-IntelliJ\"><a href=\"#IDEA-IntelliJ\" class=\"headerlink\" title=\"IDEA IntelliJ\"></a>IDEA IntelliJ</h2><p>虽然IDEA IntelliJ默认使用javac作为编译器，理论上可以不装插件。可是，跳转等特性也随之没了。所以，还是安装个插件吧，直接去仓库里搜索lombok就成。</p>\n<p>如果项目中使用高级配置，需要额外注意一下。虽然在编译的时候，lombok配置文件可以在任何能找到的目录，但是，lombok-intellij插件默认并不支持在任何目录，如果有配置文件，建议放在java的源代码根目录中。    </p>\n<h1 id=\"更多-lombok-注解\"><a href=\"#更多-lombok-注解\" class=\"headerlink\" title=\"更多 lombok 注解\"></a>更多 lombok 注解</h1><table>\n<thead>\n<tr>\n<th align=\"left\">注解</th>\n<th align=\"left\">解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">@val</td>\n<td align=\"left\">如果你要定义一个final的变量，并且不想写类型，这个可以帮到你。但是，在实际项目中，完全没有使用到。</td>\n</tr>\n<tr>\n<td align=\"left\">@NonNull</td>\n<td align=\"left\">这个在参数中使用，如果调用时传了null，就直接抛空指针。</td>\n</tr>\n<tr>\n<td align=\"left\">@Data</td>\n<td align=\"left\">@ToString、@EqualsAndHashCode、@Getter、@Setter和@RequiredArgsConstructor注解的集合。</td>\n</tr>\n<tr>\n<td align=\"left\">@Getter与@Setter</td>\n<td align=\"left\">作用于属性和类上，自动生成属性的getXXX()和setXXX()方法。若在类上，则对所有属性有效。并可通过AccessLevel参数控制方法的访问级别。</td>\n</tr>\n<tr>\n<td align=\"left\">@ToString</td>\n<td align=\"left\">作用于类，自动重写类的ToString()方法。常用的参数有exclude（指定方法中不包含的属性）、callSuper（方法中是否包含父类ToString()方法返回的值）</td>\n</tr>\n<tr>\n<td align=\"left\">@EqualsAndHashCode</td>\n<td align=\"left\">作用于类，自动重写类的equals()、hashCode()方法。常用的参数有exclude（指定方法中不包含的属性）、callSuper（方法中是否包含父类ToString()方法返回的值）</td>\n</tr>\n<tr>\n<td align=\"left\">@NoArgsConstructor, @RequiredArgsConstructor和@AllArgsConstructor</td>\n<td align=\"left\">作用于类，@NoArgsConstructor自动生成不带参数的构造方法；@RequiredArgsConstructor自动生成带参数的构造方法，主要针对一些需要特殊处理的属性，比如未初始化的final属性；@AllArgsConstructor自动生成包含所有属性的构造方法。</td>\n</tr>\n<tr>\n<td align=\"left\">@Synchronized</td>\n<td align=\"left\">作用于方法，可锁定指定的对象，如果不指定，则默认创建创建一个对象锁定。</td>\n</tr>\n<tr>\n<td align=\"left\">@Log，或者直接@Slf4j</td>\n<td align=\"left\">作用于类，具体包含@CommonsLog、@Log、@Log4j、@Log4j2、@Slf4j和@XSlf4j，分别对用不同的日志系统。利用此类注解，可为类创建一个log属性。</td>\n</tr>\n</tbody></table>\n<h2 id=\"sonar源码审查\"><a href=\"#sonar源码审查\" class=\"headerlink\" title=\"sonar源码审查\"></a>sonar源码审查</h2><p>sonar是一个源码审查工具。最新版5.X已经支持lombok的全部注解，不再认为是没有使用的变量。但是，旧的4.X还是认为没有使用这些变量。可以后向移植这些包，或者应用单独的补丁。</p>\n<p><a href=\"https://segmentfault.com/a/1190000005133786\" target=\"_blank\" rel=\"noopener\">摘自</a></p>\n<p><a href=\"https://docs.sonarqube.org/latest/\" target=\"_blank\" rel=\"noopener\">sonar</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一个典型的-Java-类\"><a href=\"#一个典型的-Java-类\" class=\"headerlink\" title=\"一个典型的 Java 类\"></a>一个典型的 Java 类</h1><pre><code>public class A {\n\n  private int a;\n\n  private String b;\n\n  public int getA() {\n    return a;\n  }\n\n  public String getB() {\n    return b;\n  }\n\n  public void setA(int a) {\n    this.a = a;\n  }\n\n  public void setB(String b) {\n    this.b = b;\n  }\n\n}</code></pre><p>对于这样一个简单的 Java 类，我们通常需要给每个属性写getter和setter，而这种实际上没有什么太大的意义。当然，如果有的公司或团队使用代码行数评估工作量，还是多写几行吧；同时，可以考虑一下我们团队。</p>\n<h1 id=\"使用-lombok，简化代码\"><a href=\"#使用-lombok，简化代码\" class=\"headerlink\" title=\"使用 lombok，简化代码\"></a>使用 lombok，简化代码</h1><p>为了简化getter与setter，lombok 提供了一种机制，帮助我们自动生成这些样板代码。以上的代码，如果使用lombok的话，将变得很简单：</p>\n<pre><code>@lombok.Getter\n@lombok.Setter\npublic class A {\n\n    private int a;\n\n    private String b;\n\n}</code></pre><p>顾名思义，lombok.Getter就是生成getter，lombok.Setter就是生成setter。但是，这样真的就可以了么？编译下，让我们看看生成的二进制代码。(请自行下载lombok.jar)</p>\n<pre><code>命令行&gt; javac -cp lombok.jar A.java\n命令行&gt; javap -c A.class</code></pre><p>输出结果略。可以看到完全一样。</p>\n<p>更进一步，如果在编译的时候，加入-g:none选项，甚至可以看到生成的文件完全一样。</p>\n<h1 id=\"简单使用\"><a href=\"#简单使用\" class=\"headerlink\" title=\"简单使用\"></a>简单使用</h1><p>虽然我们可以在编译的时候，加入classpath，但是，一般来说，在各类IDE中使用，还是需要特殊处理一下。</p>\n<h2 id=\"Maven\"><a href=\"#Maven\" class=\"headerlink\" title=\"Maven\"></a>Maven</h2><p>加上依赖就好。同时，由于lombok只在编译期才处理，所以并不需要在运行时有这个依赖，可以把scope定义为provided。</p>\n<pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n        &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n        &lt;version&gt;1.16.8&lt;/version&gt;\n        &lt;scope&gt;provided&lt;/scope&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;</code></pre><p>值得注意的是，maven的maven-compiler-plugin低版本和lombok高版本不兼容，目前已知maven-compiler-plugin的2.3.X与lombok的1.6.X不兼容。这个需要了解lombok的原理才能进一步说明。</p>\n<h2 id=\"Eclipse\"><a href=\"#Eclipse\" class=\"headerlink\" title=\"Eclipse\"></a>Eclipse</h2><p>由于eclipse的默认编译器并不是javac，所以，需要额外安装，基本就是改下引导参数，可以直接运行jar包，或者手动在eclipse.ini里加上参数-Xbootclasspath/a:lombok.jar -javaagent:lombok.jar。</p>\n<h2 id=\"IDEA-IntelliJ\"><a href=\"#IDEA-IntelliJ\" class=\"headerlink\" title=\"IDEA IntelliJ\"></a>IDEA IntelliJ</h2><p>虽然IDEA IntelliJ默认使用javac作为编译器，理论上可以不装插件。可是，跳转等特性也随之没了。所以，还是安装个插件吧，直接去仓库里搜索lombok就成。</p>\n<p>如果项目中使用高级配置，需要额外注意一下。虽然在编译的时候，lombok配置文件可以在任何能找到的目录，但是，lombok-intellij插件默认并不支持在任何目录，如果有配置文件，建议放在java的源代码根目录中。    </p>\n<h1 id=\"更多-lombok-注解\"><a href=\"#更多-lombok-注解\" class=\"headerlink\" title=\"更多 lombok 注解\"></a>更多 lombok 注解</h1><table>\n<thead>\n<tr>\n<th align=\"left\">注解</th>\n<th align=\"left\">解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">@val</td>\n<td align=\"left\">如果你要定义一个final的变量，并且不想写类型，这个可以帮到你。但是，在实际项目中，完全没有使用到。</td>\n</tr>\n<tr>\n<td align=\"left\">@NonNull</td>\n<td align=\"left\">这个在参数中使用，如果调用时传了null，就直接抛空指针。</td>\n</tr>\n<tr>\n<td align=\"left\">@Data</td>\n<td align=\"left\">@ToString、@EqualsAndHashCode、@Getter、@Setter和@RequiredArgsConstructor注解的集合。</td>\n</tr>\n<tr>\n<td align=\"left\">@Getter与@Setter</td>\n<td align=\"left\">作用于属性和类上，自动生成属性的getXXX()和setXXX()方法。若在类上，则对所有属性有效。并可通过AccessLevel参数控制方法的访问级别。</td>\n</tr>\n<tr>\n<td align=\"left\">@ToString</td>\n<td align=\"left\">作用于类，自动重写类的ToString()方法。常用的参数有exclude（指定方法中不包含的属性）、callSuper（方法中是否包含父类ToString()方法返回的值）</td>\n</tr>\n<tr>\n<td align=\"left\">@EqualsAndHashCode</td>\n<td align=\"left\">作用于类，自动重写类的equals()、hashCode()方法。常用的参数有exclude（指定方法中不包含的属性）、callSuper（方法中是否包含父类ToString()方法返回的值）</td>\n</tr>\n<tr>\n<td align=\"left\">@NoArgsConstructor, @RequiredArgsConstructor和@AllArgsConstructor</td>\n<td align=\"left\">作用于类，@NoArgsConstructor自动生成不带参数的构造方法；@RequiredArgsConstructor自动生成带参数的构造方法，主要针对一些需要特殊处理的属性，比如未初始化的final属性；@AllArgsConstructor自动生成包含所有属性的构造方法。</td>\n</tr>\n<tr>\n<td align=\"left\">@Synchronized</td>\n<td align=\"left\">作用于方法，可锁定指定的对象，如果不指定，则默认创建创建一个对象锁定。</td>\n</tr>\n<tr>\n<td align=\"left\">@Log，或者直接@Slf4j</td>\n<td align=\"left\">作用于类，具体包含@CommonsLog、@Log、@Log4j、@Log4j2、@Slf4j和@XSlf4j，分别对用不同的日志系统。利用此类注解，可为类创建一个log属性。</td>\n</tr>\n</tbody></table>\n<h2 id=\"sonar源码审查\"><a href=\"#sonar源码审查\" class=\"headerlink\" title=\"sonar源码审查\"></a>sonar源码审查</h2><p>sonar是一个源码审查工具。最新版5.X已经支持lombok的全部注解，不再认为是没有使用的变量。但是，旧的4.X还是认为没有使用这些变量。可以后向移植这些包，或者应用单独的补丁。</p>\n<p><a href=\"https://segmentfault.com/a/1190000005133786\" target=\"_blank\" rel=\"noopener\">摘自</a></p>\n<p><a href=\"https://docs.sonarqube.org/latest/\" target=\"_blank\" rel=\"noopener\">sonar</a></p>\n"},{"title":"喜迎猪宝","date":"2019-03-26T01:37:20.000Z","_content":"\n# 2019年三月十三日农历二月初七\n\n今天是个特殊的日子,阳光明媚,春风和煦,孩子你来到了我们身边.\n\n在过了预产期三天后,在我们得知你有可能超过八斤之后,在你妈妈\n日渐痛苦(因为你太沉了,累的你妈妈睡不好觉,腰疼,翻身困难,吃饭泛酸水\n等等),我和你妈还是想顺产,但当你超过预产期又有可能因为羊水\n浑浊而感染时,我们坚定的认为得刨了!\n\n三月十二号早上我跟你妈还有你芳芳姨一块去人民医院咨询住院事宜,\n很幸运,接待的医生很热情!当天还有二十几个出院的!医院床位充足,\n医生在了解了你的情况之后表示:随时可以住院!\n\n中午我跟你妈美美的吃了一顿你奶奶做的家常饭!你妈又在你姥姥家洗了个澡,姥姥还给你妈搓的澡!\n下午我们就拎着大包小包住院了!住院过程很顺利,不过爸妈还是来的有点儿晚,这时候\n双人间已经满了,没办法我们只能住三人间,害的你妈跟我抱怨\"应该上午来的时候办手续\"!\n\n我们住在了三床,隔壁2床是一个顺产的小姑娘!环境说不上多不好,但跟家里比是差多了,我跟你妈都\n有些不适应!医生警告\"不允许离开三层住院部\",可在爸爸在楼下买东西看到别的出来吃饭的孕妇后,\n果断的决定带你妈回家吃饭,可能的话还想在家过夜.\n\n护士很负责任,吃饭途中就给我们打了电话,询问去处,答曰:吃饭!护士严厉警告:\n不许出楼,答曰:是是是,前后打了三四通电话,老爸真有点后悔带你妈回家!\n\n上午妈妈进了手术室,在一片手忙脚乱中(包括准备手术铺盖,准备你的抱被.....)\n等待的过程是漫长的,爸爸想了很多,各种担心,担心妈妈下不了手术台,担心你有啥问题......\n爸爸长这么大,经历了大大小小无数次考试,但从来没有像今天这样紧张!\n\n大约过了一个半小时吧!姥姥突然叫爸爸过去抱你,原来你跟妈妈不是一个门出来,\n而爸爸一直在妈妈进去的门口等!你被护士抱着交给了爸爸,你是那么的软,抱被\n半遮着你的脸,爸爸看不真切你的脸,倒是伸出的小手给了个特写,又细又长,帅!\n\n爸爸把你抱到楼上观察室观察,(前一天睡前妈妈还特意跟爸爸交代一定要亲手抱你上楼,\n然后寸步不离的看着你,洗澡等,目的就是怕把你弄丢!上手术室前又交代了一遍,伟大的妈妈.\n你长大可得要对你妈好啊!)然后就下楼等你妈妈出来.\n\n你妈终于出手术室了,豆大的一滴泪挂在她的眼角,她没有一声呻吟,表情坚毅!\n爸爸从心里佩服你妈,她是个坚强的女子!女儿本柔,为母则刚!爸爸还是第一次\n从你妈妈身上感触到这种坚强!\n\n这次迎接你到来的有,姥姥,姥爷,奶奶,妈妈,爸爸.因为妈妈是剖腹产,出手术室\n后要换床,需要人抬,咱们家来人少,主要也是没经验.所以抬妈妈有些困难,还好\n隔壁床有两位叔叔帮忙一块儿抬的妈妈.他们都是咱们家的大恩人,虽然爸爸也\n记不清他们了,但爸爸希望你做个好人,做个助人为乐的人.顺便涨了个经验,生孩子\n家里可得多来点儿人!\n\n\n\n\n\n\n\n    \n","source":"_posts/喜迎猪宝.md","raw":"---\ntitle: 喜迎猪宝\ndate: 2019-03-26 09:37:20\ntags: 生活\ncategories: \n- 生活\n---\n\n# 2019年三月十三日农历二月初七\n\n今天是个特殊的日子,阳光明媚,春风和煦,孩子你来到了我们身边.\n\n在过了预产期三天后,在我们得知你有可能超过八斤之后,在你妈妈\n日渐痛苦(因为你太沉了,累的你妈妈睡不好觉,腰疼,翻身困难,吃饭泛酸水\n等等),我和你妈还是想顺产,但当你超过预产期又有可能因为羊水\n浑浊而感染时,我们坚定的认为得刨了!\n\n三月十二号早上我跟你妈还有你芳芳姨一块去人民医院咨询住院事宜,\n很幸运,接待的医生很热情!当天还有二十几个出院的!医院床位充足,\n医生在了解了你的情况之后表示:随时可以住院!\n\n中午我跟你妈美美的吃了一顿你奶奶做的家常饭!你妈又在你姥姥家洗了个澡,姥姥还给你妈搓的澡!\n下午我们就拎着大包小包住院了!住院过程很顺利,不过爸妈还是来的有点儿晚,这时候\n双人间已经满了,没办法我们只能住三人间,害的你妈跟我抱怨\"应该上午来的时候办手续\"!\n\n我们住在了三床,隔壁2床是一个顺产的小姑娘!环境说不上多不好,但跟家里比是差多了,我跟你妈都\n有些不适应!医生警告\"不允许离开三层住院部\",可在爸爸在楼下买东西看到别的出来吃饭的孕妇后,\n果断的决定带你妈回家吃饭,可能的话还想在家过夜.\n\n护士很负责任,吃饭途中就给我们打了电话,询问去处,答曰:吃饭!护士严厉警告:\n不许出楼,答曰:是是是,前后打了三四通电话,老爸真有点后悔带你妈回家!\n\n上午妈妈进了手术室,在一片手忙脚乱中(包括准备手术铺盖,准备你的抱被.....)\n等待的过程是漫长的,爸爸想了很多,各种担心,担心妈妈下不了手术台,担心你有啥问题......\n爸爸长这么大,经历了大大小小无数次考试,但从来没有像今天这样紧张!\n\n大约过了一个半小时吧!姥姥突然叫爸爸过去抱你,原来你跟妈妈不是一个门出来,\n而爸爸一直在妈妈进去的门口等!你被护士抱着交给了爸爸,你是那么的软,抱被\n半遮着你的脸,爸爸看不真切你的脸,倒是伸出的小手给了个特写,又细又长,帅!\n\n爸爸把你抱到楼上观察室观察,(前一天睡前妈妈还特意跟爸爸交代一定要亲手抱你上楼,\n然后寸步不离的看着你,洗澡等,目的就是怕把你弄丢!上手术室前又交代了一遍,伟大的妈妈.\n你长大可得要对你妈好啊!)然后就下楼等你妈妈出来.\n\n你妈终于出手术室了,豆大的一滴泪挂在她的眼角,她没有一声呻吟,表情坚毅!\n爸爸从心里佩服你妈,她是个坚强的女子!女儿本柔,为母则刚!爸爸还是第一次\n从你妈妈身上感触到这种坚强!\n\n这次迎接你到来的有,姥姥,姥爷,奶奶,妈妈,爸爸.因为妈妈是剖腹产,出手术室\n后要换床,需要人抬,咱们家来人少,主要也是没经验.所以抬妈妈有些困难,还好\n隔壁床有两位叔叔帮忙一块儿抬的妈妈.他们都是咱们家的大恩人,虽然爸爸也\n记不清他们了,但爸爸希望你做个好人,做个助人为乐的人.顺便涨了个经验,生孩子\n家里可得多来点儿人!\n\n\n\n\n\n\n\n    \n","slug":"喜迎猪宝","published":1,"updated":"2019-09-27T08:27:08.049Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedl001pojfy3ytw2fwb","content":"<h1 id=\"2019年三月十三日农历二月初七\"><a href=\"#2019年三月十三日农历二月初七\" class=\"headerlink\" title=\"2019年三月十三日农历二月初七\"></a>2019年三月十三日农历二月初七</h1><p>今天是个特殊的日子,阳光明媚,春风和煦,孩子你来到了我们身边.</p>\n<p>在过了预产期三天后,在我们得知你有可能超过八斤之后,在你妈妈<br>日渐痛苦(因为你太沉了,累的你妈妈睡不好觉,腰疼,翻身困难,吃饭泛酸水<br>等等),我和你妈还是想顺产,但当你超过预产期又有可能因为羊水<br>浑浊而感染时,我们坚定的认为得刨了!</p>\n<p>三月十二号早上我跟你妈还有你芳芳姨一块去人民医院咨询住院事宜,<br>很幸运,接待的医生很热情!当天还有二十几个出院的!医院床位充足,<br>医生在了解了你的情况之后表示:随时可以住院!</p>\n<p>中午我跟你妈美美的吃了一顿你奶奶做的家常饭!你妈又在你姥姥家洗了个澡,姥姥还给你妈搓的澡!<br>下午我们就拎着大包小包住院了!住院过程很顺利,不过爸妈还是来的有点儿晚,这时候<br>双人间已经满了,没办法我们只能住三人间,害的你妈跟我抱怨”应该上午来的时候办手续”!</p>\n<p>我们住在了三床,隔壁2床是一个顺产的小姑娘!环境说不上多不好,但跟家里比是差多了,我跟你妈都<br>有些不适应!医生警告”不允许离开三层住院部”,可在爸爸在楼下买东西看到别的出来吃饭的孕妇后,<br>果断的决定带你妈回家吃饭,可能的话还想在家过夜.</p>\n<p>护士很负责任,吃饭途中就给我们打了电话,询问去处,答曰:吃饭!护士严厉警告:<br>不许出楼,答曰:是是是,前后打了三四通电话,老爸真有点后悔带你妈回家!</p>\n<p>上午妈妈进了手术室,在一片手忙脚乱中(包括准备手术铺盖,准备你的抱被…..)<br>等待的过程是漫长的,爸爸想了很多,各种担心,担心妈妈下不了手术台,担心你有啥问题……<br>爸爸长这么大,经历了大大小小无数次考试,但从来没有像今天这样紧张!</p>\n<p>大约过了一个半小时吧!姥姥突然叫爸爸过去抱你,原来你跟妈妈不是一个门出来,<br>而爸爸一直在妈妈进去的门口等!你被护士抱着交给了爸爸,你是那么的软,抱被<br>半遮着你的脸,爸爸看不真切你的脸,倒是伸出的小手给了个特写,又细又长,帅!</p>\n<p>爸爸把你抱到楼上观察室观察,(前一天睡前妈妈还特意跟爸爸交代一定要亲手抱你上楼,<br>然后寸步不离的看着你,洗澡等,目的就是怕把你弄丢!上手术室前又交代了一遍,伟大的妈妈.<br>你长大可得要对你妈好啊!)然后就下楼等你妈妈出来.</p>\n<p>你妈终于出手术室了,豆大的一滴泪挂在她的眼角,她没有一声呻吟,表情坚毅!<br>爸爸从心里佩服你妈,她是个坚强的女子!女儿本柔,为母则刚!爸爸还是第一次<br>从你妈妈身上感触到这种坚强!</p>\n<p>这次迎接你到来的有,姥姥,姥爷,奶奶,妈妈,爸爸.因为妈妈是剖腹产,出手术室<br>后要换床,需要人抬,咱们家来人少,主要也是没经验.所以抬妈妈有些困难,还好<br>隔壁床有两位叔叔帮忙一块儿抬的妈妈.他们都是咱们家的大恩人,虽然爸爸也<br>记不清他们了,但爸爸希望你做个好人,做个助人为乐的人.顺便涨了个经验,生孩子<br>家里可得多来点儿人!</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"2019年三月十三日农历二月初七\"><a href=\"#2019年三月十三日农历二月初七\" class=\"headerlink\" title=\"2019年三月十三日农历二月初七\"></a>2019年三月十三日农历二月初七</h1><p>今天是个特殊的日子,阳光明媚,春风和煦,孩子你来到了我们身边.</p>\n<p>在过了预产期三天后,在我们得知你有可能超过八斤之后,在你妈妈<br>日渐痛苦(因为你太沉了,累的你妈妈睡不好觉,腰疼,翻身困难,吃饭泛酸水<br>等等),我和你妈还是想顺产,但当你超过预产期又有可能因为羊水<br>浑浊而感染时,我们坚定的认为得刨了!</p>\n<p>三月十二号早上我跟你妈还有你芳芳姨一块去人民医院咨询住院事宜,<br>很幸运,接待的医生很热情!当天还有二十几个出院的!医院床位充足,<br>医生在了解了你的情况之后表示:随时可以住院!</p>\n<p>中午我跟你妈美美的吃了一顿你奶奶做的家常饭!你妈又在你姥姥家洗了个澡,姥姥还给你妈搓的澡!<br>下午我们就拎着大包小包住院了!住院过程很顺利,不过爸妈还是来的有点儿晚,这时候<br>双人间已经满了,没办法我们只能住三人间,害的你妈跟我抱怨”应该上午来的时候办手续”!</p>\n<p>我们住在了三床,隔壁2床是一个顺产的小姑娘!环境说不上多不好,但跟家里比是差多了,我跟你妈都<br>有些不适应!医生警告”不允许离开三层住院部”,可在爸爸在楼下买东西看到别的出来吃饭的孕妇后,<br>果断的决定带你妈回家吃饭,可能的话还想在家过夜.</p>\n<p>护士很负责任,吃饭途中就给我们打了电话,询问去处,答曰:吃饭!护士严厉警告:<br>不许出楼,答曰:是是是,前后打了三四通电话,老爸真有点后悔带你妈回家!</p>\n<p>上午妈妈进了手术室,在一片手忙脚乱中(包括准备手术铺盖,准备你的抱被…..)<br>等待的过程是漫长的,爸爸想了很多,各种担心,担心妈妈下不了手术台,担心你有啥问题……<br>爸爸长这么大,经历了大大小小无数次考试,但从来没有像今天这样紧张!</p>\n<p>大约过了一个半小时吧!姥姥突然叫爸爸过去抱你,原来你跟妈妈不是一个门出来,<br>而爸爸一直在妈妈进去的门口等!你被护士抱着交给了爸爸,你是那么的软,抱被<br>半遮着你的脸,爸爸看不真切你的脸,倒是伸出的小手给了个特写,又细又长,帅!</p>\n<p>爸爸把你抱到楼上观察室观察,(前一天睡前妈妈还特意跟爸爸交代一定要亲手抱你上楼,<br>然后寸步不离的看着你,洗澡等,目的就是怕把你弄丢!上手术室前又交代了一遍,伟大的妈妈.<br>你长大可得要对你妈好啊!)然后就下楼等你妈妈出来.</p>\n<p>你妈终于出手术室了,豆大的一滴泪挂在她的眼角,她没有一声呻吟,表情坚毅!<br>爸爸从心里佩服你妈,她是个坚强的女子!女儿本柔,为母则刚!爸爸还是第一次<br>从你妈妈身上感触到这种坚强!</p>\n<p>这次迎接你到来的有,姥姥,姥爷,奶奶,妈妈,爸爸.因为妈妈是剖腹产,出手术室<br>后要换床,需要人抬,咱们家来人少,主要也是没经验.所以抬妈妈有些困难,还好<br>隔壁床有两位叔叔帮忙一块儿抬的妈妈.他们都是咱们家的大恩人,虽然爸爸也<br>记不清他们了,但爸爸希望你做个好人,做个助人为乐的人.顺便涨了个经验,生孩子<br>家里可得多来点儿人!</p>\n"},{"title":"手写JVM","date":"2019-08-26T09:20:45.000Z","_content":"","source":"_posts/手写JVM.md","raw":"---\ntitle: 手写JVM\ndate: 2019-08-26 17:20:45\ntags:\n---\n","slug":"手写JVM","published":1,"updated":"2019-09-27T08:27:08.049Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedm001qojfyxwk1ns5s","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"如何培养孩子的逻辑思维","date":"2019-09-27T03:03:57.000Z","_content":"\n# 逻辑思维能力重要吗？\n  \n答案必然是肯定的，因为它不仅是学好数学必须具备的能力，同时也是学好其他学科，处理日常生活问题所必须具备的能力。\n\n换句话说就是：逻辑思维，其可以成为“做好任何事情”的必要条件.\n\n\n# what\n\n它是一种人类思维的高级形式，即我们所说的“抽象思维”。而一个人想具备很强的逻辑思维能力，往往需要从小开始培养。\n\n# why\n\n肥宅以为:逻辑思维就是智商最重要的方面之一,甚至之一也可以去掉.\n\n# how\n\n## 背景\n\n美国的很多学校，他们从学前班开始就有关于训练孩子逻辑思维能力的数学内容\n\n但在国内，我们对孩子逻辑思维的培养还存在一定的误区，学校往往喜欢让学生做题，找到考试的捷径，却忽视了对数学本质的讲解。\n\n所以当我们没有将数学应用在生活中，这些定理和公式也会随着时间的流逝慢慢被淡忘。\n\n所以将数学应用在生活中也就是锻炼逻辑思维的必要过程\n\n## 那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。\n\n### 动作思维阶段（0-3岁）\n不到3岁的孩子以动作思维为主，思维在动作中进行。比如桌上放着一个苹果，宝宝矮小够不着，怎么办呢?这时候宝宝发现他旁边有凳子，于是把凳子搬过来，自己爬上去，成功地把苹果拿到手。\n孩子学会借助别的东西来达到自己的目的，是从不断的操作过程中理解的。 孩子最初的动作往往是杂乱无章、漫无目的的，以后在不断的操作过程中了解了动作与结果之间的关系。\n\n### 具体形象思维阶段（3-6岁）\n3-6岁的孩子具体形象思维占优势，他们缺少立体感和空间感。这也是为什么用数字加减，孩子反应不过来，但是用实物举例子，就容易理解。\n在这个阶段，家长要注意增加孩子的经验，丰富孩子的词汇，多给孩子动手的机会。有些家长和老师片面地、刻板地教孩子多识字、写字、计算等，对孩子的思维发展并没有好处。\n\n### 抽象逻辑思维能力（6-11岁）\n6-11岁是培养孩子抽象逻辑思维能力的关键时期。在这一时期要培养孩子正确的思维程序和科学的思维方法。\n\n比如，一只狗有4条腿，两只狗有8条腿，三只狗有多少条腿?像这些问题，就是属于抽象逻辑思维能力题。家长要注意让孩子学会独立思考，不要给孩子现成的答案。    \n## 那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。\n\n### 一、丰富孩子的词汇，教孩子说话用词达意\n语言是思维的外壳，尽早教孩子准确用词，不但能防止别人曲解、误解他的意思，而且促使他思维活跃、思路清晰。家长对孩子的话要多问几个为什么，对他的表达要多作分析，这可以使孩子用词准确、鲜明、生动。    \n### 二、有意识地对孩子设疑，给孩子留下思考的时间\n孩子回答问题往往是凭直觉，如果家长满足于孩子的这点“小聪明”，那么，他们会习惯对问题不假思索地做出回答，没有足够的时间让大脑启动思维“程序”。\n\n所以，当孩子遇到问题的时候，家长最好不要急于让他说答案，而是让他多问几个为什么，多想几种解决的方案，多几次对自己的否定，然后在否定中寻找最佳答案。\n### 三、利用游戏促进孩子思维能力的发展\n在日常生活中，可以进行分类和归类的游戏。也可以进行比较动、植物或其他事物、训练理解力和创造力的游戏等。\n\n比如收衣服时，让孩子将不同的袜子分类卷起来；去动物园时，告诉孩子如何通过牙齿区别食草和食肉的动物，并让他分辨；给孩子一些零钱，让孩子去买东西……\n\n对孩子而言，说过的话，玩过的游戏或许会忘记，但日复一日默默培养起来的逻辑思维能力会伴随他们终身，使他们在生活和工作中表现得更为优秀出色。\n\n\n    \n\n\n\n","source":"_posts/如何培养孩子的逻辑思维.md","raw":"---\ntitle: 如何培养孩子的逻辑思维\ndate: 2019-09-27 11:03:57\ntags: [育儿]\ncategories: [育儿]\n---\n\n# 逻辑思维能力重要吗？\n  \n答案必然是肯定的，因为它不仅是学好数学必须具备的能力，同时也是学好其他学科，处理日常生活问题所必须具备的能力。\n\n换句话说就是：逻辑思维，其可以成为“做好任何事情”的必要条件.\n\n\n# what\n\n它是一种人类思维的高级形式，即我们所说的“抽象思维”。而一个人想具备很强的逻辑思维能力，往往需要从小开始培养。\n\n# why\n\n肥宅以为:逻辑思维就是智商最重要的方面之一,甚至之一也可以去掉.\n\n# how\n\n## 背景\n\n美国的很多学校，他们从学前班开始就有关于训练孩子逻辑思维能力的数学内容\n\n但在国内，我们对孩子逻辑思维的培养还存在一定的误区，学校往往喜欢让学生做题，找到考试的捷径，却忽视了对数学本质的讲解。\n\n所以当我们没有将数学应用在生活中，这些定理和公式也会随着时间的流逝慢慢被淡忘。\n\n所以将数学应用在生活中也就是锻炼逻辑思维的必要过程\n\n## 那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。\n\n### 动作思维阶段（0-3岁）\n不到3岁的孩子以动作思维为主，思维在动作中进行。比如桌上放着一个苹果，宝宝矮小够不着，怎么办呢?这时候宝宝发现他旁边有凳子，于是把凳子搬过来，自己爬上去，成功地把苹果拿到手。\n孩子学会借助别的东西来达到自己的目的，是从不断的操作过程中理解的。 孩子最初的动作往往是杂乱无章、漫无目的的，以后在不断的操作过程中了解了动作与结果之间的关系。\n\n### 具体形象思维阶段（3-6岁）\n3-6岁的孩子具体形象思维占优势，他们缺少立体感和空间感。这也是为什么用数字加减，孩子反应不过来，但是用实物举例子，就容易理解。\n在这个阶段，家长要注意增加孩子的经验，丰富孩子的词汇，多给孩子动手的机会。有些家长和老师片面地、刻板地教孩子多识字、写字、计算等，对孩子的思维发展并没有好处。\n\n### 抽象逻辑思维能力（6-11岁）\n6-11岁是培养孩子抽象逻辑思维能力的关键时期。在这一时期要培养孩子正确的思维程序和科学的思维方法。\n\n比如，一只狗有4条腿，两只狗有8条腿，三只狗有多少条腿?像这些问题，就是属于抽象逻辑思维能力题。家长要注意让孩子学会独立思考，不要给孩子现成的答案。    \n## 那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。\n\n### 一、丰富孩子的词汇，教孩子说话用词达意\n语言是思维的外壳，尽早教孩子准确用词，不但能防止别人曲解、误解他的意思，而且促使他思维活跃、思路清晰。家长对孩子的话要多问几个为什么，对他的表达要多作分析，这可以使孩子用词准确、鲜明、生动。    \n### 二、有意识地对孩子设疑，给孩子留下思考的时间\n孩子回答问题往往是凭直觉，如果家长满足于孩子的这点“小聪明”，那么，他们会习惯对问题不假思索地做出回答，没有足够的时间让大脑启动思维“程序”。\n\n所以，当孩子遇到问题的时候，家长最好不要急于让他说答案，而是让他多问几个为什么，多想几种解决的方案，多几次对自己的否定，然后在否定中寻找最佳答案。\n### 三、利用游戏促进孩子思维能力的发展\n在日常生活中，可以进行分类和归类的游戏。也可以进行比较动、植物或其他事物、训练理解力和创造力的游戏等。\n\n比如收衣服时，让孩子将不同的袜子分类卷起来；去动物园时，告诉孩子如何通过牙齿区别食草和食肉的动物，并让他分辨；给孩子一些零钱，让孩子去买东西……\n\n对孩子而言，说过的话，玩过的游戏或许会忘记，但日复一日默默培养起来的逻辑思维能力会伴随他们终身，使他们在生活和工作中表现得更为优秀出色。\n\n\n    \n\n\n\n","slug":"如何培养孩子的逻辑思维","published":1,"updated":"2019-09-27T08:27:08.049Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedm001rojfyp2w9zplj","content":"<h1 id=\"逻辑思维能力重要吗？\"><a href=\"#逻辑思维能力重要吗？\" class=\"headerlink\" title=\"逻辑思维能力重要吗？\"></a>逻辑思维能力重要吗？</h1><p>答案必然是肯定的，因为它不仅是学好数学必须具备的能力，同时也是学好其他学科，处理日常生活问题所必须具备的能力。</p>\n<p>换句话说就是：逻辑思维，其可以成为“做好任何事情”的必要条件.</p>\n<h1 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h1><p>它是一种人类思维的高级形式，即我们所说的“抽象思维”。而一个人想具备很强的逻辑思维能力，往往需要从小开始培养。</p>\n<h1 id=\"why\"><a href=\"#why\" class=\"headerlink\" title=\"why\"></a>why</h1><p>肥宅以为:逻辑思维就是智商最重要的方面之一,甚至之一也可以去掉.</p>\n<h1 id=\"how\"><a href=\"#how\" class=\"headerlink\" title=\"how\"></a>how</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>美国的很多学校，他们从学前班开始就有关于训练孩子逻辑思维能力的数学内容</p>\n<p>但在国内，我们对孩子逻辑思维的培养还存在一定的误区，学校往往喜欢让学生做题，找到考试的捷径，却忽视了对数学本质的讲解。</p>\n<p>所以当我们没有将数学应用在生活中，这些定理和公式也会随着时间的流逝慢慢被淡忘。</p>\n<p>所以将数学应用在生活中也就是锻炼逻辑思维的必要过程</p>\n<h2 id=\"那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。\"><a href=\"#那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。\" class=\"headerlink\" title=\"那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。\"></a>那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。</h2><h3 id=\"动作思维阶段（0-3岁）\"><a href=\"#动作思维阶段（0-3岁）\" class=\"headerlink\" title=\"动作思维阶段（0-3岁）\"></a>动作思维阶段（0-3岁）</h3><p>不到3岁的孩子以动作思维为主，思维在动作中进行。比如桌上放着一个苹果，宝宝矮小够不着，怎么办呢?这时候宝宝发现他旁边有凳子，于是把凳子搬过来，自己爬上去，成功地把苹果拿到手。<br>孩子学会借助别的东西来达到自己的目的，是从不断的操作过程中理解的。 孩子最初的动作往往是杂乱无章、漫无目的的，以后在不断的操作过程中了解了动作与结果之间的关系。</p>\n<h3 id=\"具体形象思维阶段（3-6岁）\"><a href=\"#具体形象思维阶段（3-6岁）\" class=\"headerlink\" title=\"具体形象思维阶段（3-6岁）\"></a>具体形象思维阶段（3-6岁）</h3><p>3-6岁的孩子具体形象思维占优势，他们缺少立体感和空间感。这也是为什么用数字加减，孩子反应不过来，但是用实物举例子，就容易理解。<br>在这个阶段，家长要注意增加孩子的经验，丰富孩子的词汇，多给孩子动手的机会。有些家长和老师片面地、刻板地教孩子多识字、写字、计算等，对孩子的思维发展并没有好处。</p>\n<h3 id=\"抽象逻辑思维能力（6-11岁）\"><a href=\"#抽象逻辑思维能力（6-11岁）\" class=\"headerlink\" title=\"抽象逻辑思维能力（6-11岁）\"></a>抽象逻辑思维能力（6-11岁）</h3><p>6-11岁是培养孩子抽象逻辑思维能力的关键时期。在这一时期要培养孩子正确的思维程序和科学的思维方法。</p>\n<p>比如，一只狗有4条腿，两只狗有8条腿，三只狗有多少条腿?像这些问题，就是属于抽象逻辑思维能力题。家长要注意让孩子学会独立思考，不要给孩子现成的答案。    </p>\n<h2 id=\"那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。\"><a href=\"#那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。\" class=\"headerlink\" title=\"那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。\"></a>那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。</h2><h3 id=\"一、丰富孩子的词汇，教孩子说话用词达意\"><a href=\"#一、丰富孩子的词汇，教孩子说话用词达意\" class=\"headerlink\" title=\"一、丰富孩子的词汇，教孩子说话用词达意\"></a>一、丰富孩子的词汇，教孩子说话用词达意</h3><p>语言是思维的外壳，尽早教孩子准确用词，不但能防止别人曲解、误解他的意思，而且促使他思维活跃、思路清晰。家长对孩子的话要多问几个为什么，对他的表达要多作分析，这可以使孩子用词准确、鲜明、生动。    </p>\n<h3 id=\"二、有意识地对孩子设疑，给孩子留下思考的时间\"><a href=\"#二、有意识地对孩子设疑，给孩子留下思考的时间\" class=\"headerlink\" title=\"二、有意识地对孩子设疑，给孩子留下思考的时间\"></a>二、有意识地对孩子设疑，给孩子留下思考的时间</h3><p>孩子回答问题往往是凭直觉，如果家长满足于孩子的这点“小聪明”，那么，他们会习惯对问题不假思索地做出回答，没有足够的时间让大脑启动思维“程序”。</p>\n<p>所以，当孩子遇到问题的时候，家长最好不要急于让他说答案，而是让他多问几个为什么，多想几种解决的方案，多几次对自己的否定，然后在否定中寻找最佳答案。</p>\n<h3 id=\"三、利用游戏促进孩子思维能力的发展\"><a href=\"#三、利用游戏促进孩子思维能力的发展\" class=\"headerlink\" title=\"三、利用游戏促进孩子思维能力的发展\"></a>三、利用游戏促进孩子思维能力的发展</h3><p>在日常生活中，可以进行分类和归类的游戏。也可以进行比较动、植物或其他事物、训练理解力和创造力的游戏等。</p>\n<p>比如收衣服时，让孩子将不同的袜子分类卷起来；去动物园时，告诉孩子如何通过牙齿区别食草和食肉的动物，并让他分辨；给孩子一些零钱，让孩子去买东西……</p>\n<p>对孩子而言，说过的话，玩过的游戏或许会忘记，但日复一日默默培养起来的逻辑思维能力会伴随他们终身，使他们在生活和工作中表现得更为优秀出色。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"逻辑思维能力重要吗？\"><a href=\"#逻辑思维能力重要吗？\" class=\"headerlink\" title=\"逻辑思维能力重要吗？\"></a>逻辑思维能力重要吗？</h1><p>答案必然是肯定的，因为它不仅是学好数学必须具备的能力，同时也是学好其他学科，处理日常生活问题所必须具备的能力。</p>\n<p>换句话说就是：逻辑思维，其可以成为“做好任何事情”的必要条件.</p>\n<h1 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h1><p>它是一种人类思维的高级形式，即我们所说的“抽象思维”。而一个人想具备很强的逻辑思维能力，往往需要从小开始培养。</p>\n<h1 id=\"why\"><a href=\"#why\" class=\"headerlink\" title=\"why\"></a>why</h1><p>肥宅以为:逻辑思维就是智商最重要的方面之一,甚至之一也可以去掉.</p>\n<h1 id=\"how\"><a href=\"#how\" class=\"headerlink\" title=\"how\"></a>how</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>美国的很多学校，他们从学前班开始就有关于训练孩子逻辑思维能力的数学内容</p>\n<p>但在国内，我们对孩子逻辑思维的培养还存在一定的误区，学校往往喜欢让学生做题，找到考试的捷径，却忽视了对数学本质的讲解。</p>\n<p>所以当我们没有将数学应用在生活中，这些定理和公式也会随着时间的流逝慢慢被淡忘。</p>\n<p>所以将数学应用在生活中也就是锻炼逻辑思维的必要过程</p>\n<h2 id=\"那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。\"><a href=\"#那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。\" class=\"headerlink\" title=\"那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。\"></a>那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。</h2><h3 id=\"动作思维阶段（0-3岁）\"><a href=\"#动作思维阶段（0-3岁）\" class=\"headerlink\" title=\"动作思维阶段（0-3岁）\"></a>动作思维阶段（0-3岁）</h3><p>不到3岁的孩子以动作思维为主，思维在动作中进行。比如桌上放着一个苹果，宝宝矮小够不着，怎么办呢?这时候宝宝发现他旁边有凳子，于是把凳子搬过来，自己爬上去，成功地把苹果拿到手。<br>孩子学会借助别的东西来达到自己的目的，是从不断的操作过程中理解的。 孩子最初的动作往往是杂乱无章、漫无目的的，以后在不断的操作过程中了解了动作与结果之间的关系。</p>\n<h3 id=\"具体形象思维阶段（3-6岁）\"><a href=\"#具体形象思维阶段（3-6岁）\" class=\"headerlink\" title=\"具体形象思维阶段（3-6岁）\"></a>具体形象思维阶段（3-6岁）</h3><p>3-6岁的孩子具体形象思维占优势，他们缺少立体感和空间感。这也是为什么用数字加减，孩子反应不过来，但是用实物举例子，就容易理解。<br>在这个阶段，家长要注意增加孩子的经验，丰富孩子的词汇，多给孩子动手的机会。有些家长和老师片面地、刻板地教孩子多识字、写字、计算等，对孩子的思维发展并没有好处。</p>\n<h3 id=\"抽象逻辑思维能力（6-11岁）\"><a href=\"#抽象逻辑思维能力（6-11岁）\" class=\"headerlink\" title=\"抽象逻辑思维能力（6-11岁）\"></a>抽象逻辑思维能力（6-11岁）</h3><p>6-11岁是培养孩子抽象逻辑思维能力的关键时期。在这一时期要培养孩子正确的思维程序和科学的思维方法。</p>\n<p>比如，一只狗有4条腿，两只狗有8条腿，三只狗有多少条腿?像这些问题，就是属于抽象逻辑思维能力题。家长要注意让孩子学会独立思考，不要给孩子现成的答案。    </p>\n<h2 id=\"那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。\"><a href=\"#那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。\" class=\"headerlink\" title=\"那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。\"></a>那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。</h2><h3 id=\"一、丰富孩子的词汇，教孩子说话用词达意\"><a href=\"#一、丰富孩子的词汇，教孩子说话用词达意\" class=\"headerlink\" title=\"一、丰富孩子的词汇，教孩子说话用词达意\"></a>一、丰富孩子的词汇，教孩子说话用词达意</h3><p>语言是思维的外壳，尽早教孩子准确用词，不但能防止别人曲解、误解他的意思，而且促使他思维活跃、思路清晰。家长对孩子的话要多问几个为什么，对他的表达要多作分析，这可以使孩子用词准确、鲜明、生动。    </p>\n<h3 id=\"二、有意识地对孩子设疑，给孩子留下思考的时间\"><a href=\"#二、有意识地对孩子设疑，给孩子留下思考的时间\" class=\"headerlink\" title=\"二、有意识地对孩子设疑，给孩子留下思考的时间\"></a>二、有意识地对孩子设疑，给孩子留下思考的时间</h3><p>孩子回答问题往往是凭直觉，如果家长满足于孩子的这点“小聪明”，那么，他们会习惯对问题不假思索地做出回答，没有足够的时间让大脑启动思维“程序”。</p>\n<p>所以，当孩子遇到问题的时候，家长最好不要急于让他说答案，而是让他多问几个为什么，多想几种解决的方案，多几次对自己的否定，然后在否定中寻找最佳答案。</p>\n<h3 id=\"三、利用游戏促进孩子思维能力的发展\"><a href=\"#三、利用游戏促进孩子思维能力的发展\" class=\"headerlink\" title=\"三、利用游戏促进孩子思维能力的发展\"></a>三、利用游戏促进孩子思维能力的发展</h3><p>在日常生活中，可以进行分类和归类的游戏。也可以进行比较动、植物或其他事物、训练理解力和创造力的游戏等。</p>\n<p>比如收衣服时，让孩子将不同的袜子分类卷起来；去动物园时，告诉孩子如何通过牙齿区别食草和食肉的动物，并让他分辨；给孩子一些零钱，让孩子去买东西……</p>\n<p>对孩子而言，说过的话，玩过的游戏或许会忘记，但日复一日默默培养起来的逻辑思维能力会伴随他们终身，使他们在生活和工作中表现得更为优秀出色。</p>\n"},{"title":"持续集成服务 Travis CI","date":"2019-09-27T07:27:00.000Z","_content":"\n[官网](https://www.travis-ci.org/dashboard)\n[参考](https://liusir.me/2019/09/21/hexo-基于TravisCI实现hexo博客持续继承)\n[参考](http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html)\n","source":"_posts/持续集成服务-Travis-CI.md","raw":"---\ntitle: 持续集成服务 Travis CI\ndate: 2019-09-27 15:27:00\ntags: [TravisCI]\ncategories: [TravisCI]\n---\n\n[官网](https://www.travis-ci.org/dashboard)\n[参考](https://liusir.me/2019/09/21/hexo-基于TravisCI实现hexo博客持续继承)\n[参考](http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html)\n","slug":"持续集成服务-Travis-CI","published":1,"updated":"2019-09-27T08:27:08.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedn001sojfy6d3e8upf","content":"<p><a href=\"https://www.travis-ci.org/dashboard\" target=\"_blank\" rel=\"noopener\">官网</a><br><a href=\"https://liusir.me/2019/09/21/hexo-基于TravisCI实现hexo博客持续继承\" target=\"_blank\" rel=\"noopener\">参考</a><br><a href=\"http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.travis-ci.org/dashboard\" target=\"_blank\" rel=\"noopener\">官网</a><br><a href=\"https://liusir.me/2019/09/21/hexo-基于TravisCI实现hexo博客持续继承\" target=\"_blank\" rel=\"noopener\">参考</a><br><a href=\"http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n"},{"title":"数据库回表与覆盖索引","date":"2019-08-19T07:06:43.000Z","_content":"\n## 回表\n\noracle中有有一个很明显的物理ID,叫做rowid,这个是全局唯一的.\nrowid是物理结构上的,在每条记录insert到数据库中时都会有\n一个唯一的物理记录.\n\n回表:当查询数据时,在索引中查找到该行索引后,根据索引\n获得该行的rowid,根据rowid再查询表中数据就是回表.\n\ndemo\n    \n    SELECT c1,c2,c3  FROM TEST_TABLE WHERE c1=1  \n    如果c1列建立了索引。首先会从索引里面根据c1=1 查找出c1的rowid，然后根据rowid去找到数据块中对应的数据，将c1，c2,c3 查出来。\n    \n    如果c1没有建立索引，那就需要进行全表扫描。到数据块中扫描一番，这样性能不好。\n\n## 覆盖索引(不需要回表操作)\n\nMySQL可以利用索引返回SELECT 列表中的字段。而不必根据索引再次读取数据文件。包含所有满足查询需要的数据的索引成为覆盖索引(Covering Index)\n。也就是平时所说的不需要回表操作。\n    \n判断标准：\n\n在查询前面使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为using index,MySQL查询优化器在执行查询前会决定是否有索引覆盖查询。\n 也就是说当前查询所需要的数据直接就可以在索引里面查得到。有时候根据业务，建立多列索引，使用覆盖索引，可以取得相当好的性能优化\n\n## 回表为什么慢\n回表是磁盘IO,而磁盘IO远远慢于内存操作\n主要原因还是随机IO，增加了磁盘 IO的次数，\n所以mysql针对大表扫描都有MRR优化策略.\n    \n[参考](http://getby.cn/sql__db/2016/0928/93.html)    \n\n\n\n","source":"_posts/数据库回表与覆盖索引.md","raw":"---\ntitle: 数据库回表与覆盖索引\ndate: 2019-08-19 15:06:43\ntags: [回表,覆盖索引,数据库,oracle,mysql]\n---\n\n## 回表\n\noracle中有有一个很明显的物理ID,叫做rowid,这个是全局唯一的.\nrowid是物理结构上的,在每条记录insert到数据库中时都会有\n一个唯一的物理记录.\n\n回表:当查询数据时,在索引中查找到该行索引后,根据索引\n获得该行的rowid,根据rowid再查询表中数据就是回表.\n\ndemo\n    \n    SELECT c1,c2,c3  FROM TEST_TABLE WHERE c1=1  \n    如果c1列建立了索引。首先会从索引里面根据c1=1 查找出c1的rowid，然后根据rowid去找到数据块中对应的数据，将c1，c2,c3 查出来。\n    \n    如果c1没有建立索引，那就需要进行全表扫描。到数据块中扫描一番，这样性能不好。\n\n## 覆盖索引(不需要回表操作)\n\nMySQL可以利用索引返回SELECT 列表中的字段。而不必根据索引再次读取数据文件。包含所有满足查询需要的数据的索引成为覆盖索引(Covering Index)\n。也就是平时所说的不需要回表操作。\n    \n判断标准：\n\n在查询前面使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为using index,MySQL查询优化器在执行查询前会决定是否有索引覆盖查询。\n 也就是说当前查询所需要的数据直接就可以在索引里面查得到。有时候根据业务，建立多列索引，使用覆盖索引，可以取得相当好的性能优化\n\n## 回表为什么慢\n回表是磁盘IO,而磁盘IO远远慢于内存操作\n主要原因还是随机IO，增加了磁盘 IO的次数，\n所以mysql针对大表扫描都有MRR优化策略.\n    \n[参考](http://getby.cn/sql__db/2016/0928/93.html)    \n\n\n\n","slug":"数据库回表与覆盖索引","published":1,"updated":"2019-09-27T08:27:08.051Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedn001tojfyrtcnm48r","content":"<h2 id=\"回表\"><a href=\"#回表\" class=\"headerlink\" title=\"回表\"></a>回表</h2><p>oracle中有有一个很明显的物理ID,叫做rowid,这个是全局唯一的.<br>rowid是物理结构上的,在每条记录insert到数据库中时都会有<br>一个唯一的物理记录.</p>\n<p>回表:当查询数据时,在索引中查找到该行索引后,根据索引<br>获得该行的rowid,根据rowid再查询表中数据就是回表.</p>\n<p>demo</p>\n<pre><code>SELECT c1,c2,c3  FROM TEST_TABLE WHERE c1=1  \n如果c1列建立了索引。首先会从索引里面根据c1=1 查找出c1的rowid，然后根据rowid去找到数据块中对应的数据，将c1，c2,c3 查出来。\n\n如果c1没有建立索引，那就需要进行全表扫描。到数据块中扫描一番，这样性能不好。</code></pre><h2 id=\"覆盖索引-不需要回表操作\"><a href=\"#覆盖索引-不需要回表操作\" class=\"headerlink\" title=\"覆盖索引(不需要回表操作)\"></a>覆盖索引(不需要回表操作)</h2><p>MySQL可以利用索引返回SELECT 列表中的字段。而不必根据索引再次读取数据文件。包含所有满足查询需要的数据的索引成为覆盖索引(Covering Index)<br>。也就是平时所说的不需要回表操作。</p>\n<p>判断标准：</p>\n<p>在查询前面使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为using index,MySQL查询优化器在执行查询前会决定是否有索引覆盖查询。<br> 也就是说当前查询所需要的数据直接就可以在索引里面查得到。有时候根据业务，建立多列索引，使用覆盖索引，可以取得相当好的性能优化</p>\n<h2 id=\"回表为什么慢\"><a href=\"#回表为什么慢\" class=\"headerlink\" title=\"回表为什么慢\"></a>回表为什么慢</h2><p>回表是磁盘IO,而磁盘IO远远慢于内存操作<br>主要原因还是随机IO，增加了磁盘 IO的次数，<br>所以mysql针对大表扫描都有MRR优化策略.</p>\n<p><a href=\"http://getby.cn/sql__db/2016/0928/93.html\" target=\"_blank\" rel=\"noopener\">参考</a>    </p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"回表\"><a href=\"#回表\" class=\"headerlink\" title=\"回表\"></a>回表</h2><p>oracle中有有一个很明显的物理ID,叫做rowid,这个是全局唯一的.<br>rowid是物理结构上的,在每条记录insert到数据库中时都会有<br>一个唯一的物理记录.</p>\n<p>回表:当查询数据时,在索引中查找到该行索引后,根据索引<br>获得该行的rowid,根据rowid再查询表中数据就是回表.</p>\n<p>demo</p>\n<pre><code>SELECT c1,c2,c3  FROM TEST_TABLE WHERE c1=1  \n如果c1列建立了索引。首先会从索引里面根据c1=1 查找出c1的rowid，然后根据rowid去找到数据块中对应的数据，将c1，c2,c3 查出来。\n\n如果c1没有建立索引，那就需要进行全表扫描。到数据块中扫描一番，这样性能不好。</code></pre><h2 id=\"覆盖索引-不需要回表操作\"><a href=\"#覆盖索引-不需要回表操作\" class=\"headerlink\" title=\"覆盖索引(不需要回表操作)\"></a>覆盖索引(不需要回表操作)</h2><p>MySQL可以利用索引返回SELECT 列表中的字段。而不必根据索引再次读取数据文件。包含所有满足查询需要的数据的索引成为覆盖索引(Covering Index)<br>。也就是平时所说的不需要回表操作。</p>\n<p>判断标准：</p>\n<p>在查询前面使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为using index,MySQL查询优化器在执行查询前会决定是否有索引覆盖查询。<br> 也就是说当前查询所需要的数据直接就可以在索引里面查得到。有时候根据业务，建立多列索引，使用覆盖索引，可以取得相当好的性能优化</p>\n<h2 id=\"回表为什么慢\"><a href=\"#回表为什么慢\" class=\"headerlink\" title=\"回表为什么慢\"></a>回表为什么慢</h2><p>回表是磁盘IO,而磁盘IO远远慢于内存操作<br>主要原因还是随机IO，增加了磁盘 IO的次数，<br>所以mysql针对大表扫描都有MRR优化策略.</p>\n<p><a href=\"http://getby.cn/sql__db/2016/0928/93.html\" target=\"_blank\" rel=\"noopener\">参考</a>    </p>\n"},{"title":"曲突徙薪之恩泽,焦头烂额为上客","date":"2019-07-20T08:35:42.000Z","_content":"\n## 曲突徙薪\n\n客有过主人者(1),见其灶直突(2),旁有积薪(3),客谓主人:\"更为曲突(4),\n远徙其薪(5),不者且有火患\".主人默然不应.俄而果失火,邻里共救之,幸而\n得息.于是杀牛置酒,谢其邻人,灼烂者在于上行(6),余各以功次坐,而不录\n言曲突者(7),人谓主人曰:\"向使听客之言(8),不费牛酒,终亡火患.今论功\n而请宾,曲突徙薪亡恩泽,焦头烂额为上客耶?\"主人乃寤而请之(9).\n\n――节选自班固《汉书·霍光传》\n\n注释\n⑴过：拜访，探望。\n\n⑵突：烟囱。\n\n⑶薪：柴草。\n\n⑷更：改。\n\n⑸徙(xǐ)：搬走。\n\n⑹灼：烧炙。烂：烧伤。行(háng)：座次。\n\n⑺录：采，取，这里有邀请的意思。\n\n⑻向使：向：原先。使：假使。\n\n⑼寤(wù)：醒悟，明白\n\n有一位客人到主人家拜访，见主人家炉灶的烟囱是直的，旁边又堆有柴薪，这位客人便对主人说：‘您的烟囱应改为弯曲的，并将柴薪搬到远处去，不然的话，将会发生火灾！’主人默然，不予理会。不久，主人家果然失火，邻居们共同抢救，幸而将火扑灭。于是，主人家杀牛摆酒，对邻居表示感谢，在救火中烧伤的被请到上座，其余则各按出力大小依次就坐，却没有请那位建议他改弯烟囱的人。有人对这家主人说：‘当初要是听了那位客人的劝告，就不用杀牛摆酒，终究不会有火灾。如今论功请客酬谢，建议改弯烟囱、移走柴薪的人没有功劳，而在救火时被烧得焦头烂额的人才是上客吗？’主人这才醒悟，将那位客人请来。\n    \n“曲突徙薪之恩泽,焦头烂额为上客”：建议改弯烟囱、移走柴薪的人没有功劳，而在救火时被烧得焦头烂额的人成了上客\n     \n\n\n","source":"_posts/曲突徙薪之恩泽-焦头烂额为上客.md","raw":"---\ntitle: '曲突徙薪之恩泽,焦头烂额为上客'\ndate: 2019-07-20 16:35:42\ntags: 成语\ncategories: \n- 成语\n---\n\n## 曲突徙薪\n\n客有过主人者(1),见其灶直突(2),旁有积薪(3),客谓主人:\"更为曲突(4),\n远徙其薪(5),不者且有火患\".主人默然不应.俄而果失火,邻里共救之,幸而\n得息.于是杀牛置酒,谢其邻人,灼烂者在于上行(6),余各以功次坐,而不录\n言曲突者(7),人谓主人曰:\"向使听客之言(8),不费牛酒,终亡火患.今论功\n而请宾,曲突徙薪亡恩泽,焦头烂额为上客耶?\"主人乃寤而请之(9).\n\n――节选自班固《汉书·霍光传》\n\n注释\n⑴过：拜访，探望。\n\n⑵突：烟囱。\n\n⑶薪：柴草。\n\n⑷更：改。\n\n⑸徙(xǐ)：搬走。\n\n⑹灼：烧炙。烂：烧伤。行(háng)：座次。\n\n⑺录：采，取，这里有邀请的意思。\n\n⑻向使：向：原先。使：假使。\n\n⑼寤(wù)：醒悟，明白\n\n有一位客人到主人家拜访，见主人家炉灶的烟囱是直的，旁边又堆有柴薪，这位客人便对主人说：‘您的烟囱应改为弯曲的，并将柴薪搬到远处去，不然的话，将会发生火灾！’主人默然，不予理会。不久，主人家果然失火，邻居们共同抢救，幸而将火扑灭。于是，主人家杀牛摆酒，对邻居表示感谢，在救火中烧伤的被请到上座，其余则各按出力大小依次就坐，却没有请那位建议他改弯烟囱的人。有人对这家主人说：‘当初要是听了那位客人的劝告，就不用杀牛摆酒，终究不会有火灾。如今论功请客酬谢，建议改弯烟囱、移走柴薪的人没有功劳，而在救火时被烧得焦头烂额的人才是上客吗？’主人这才醒悟，将那位客人请来。\n    \n“曲突徙薪之恩泽,焦头烂额为上客”：建议改弯烟囱、移走柴薪的人没有功劳，而在救火时被烧得焦头烂额的人成了上客\n     \n\n\n","slug":"曲突徙薪之恩泽-焦头烂额为上客","published":1,"updated":"2019-09-27T08:27:08.051Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedo001uojfy96n6mo8u","content":"<h2 id=\"曲突徙薪\"><a href=\"#曲突徙薪\" class=\"headerlink\" title=\"曲突徙薪\"></a>曲突徙薪</h2><p>客有过主人者(1),见其灶直突(2),旁有积薪(3),客谓主人:”更为曲突(4),<br>远徙其薪(5),不者且有火患”.主人默然不应.俄而果失火,邻里共救之,幸而<br>得息.于是杀牛置酒,谢其邻人,灼烂者在于上行(6),余各以功次坐,而不录<br>言曲突者(7),人谓主人曰:”向使听客之言(8),不费牛酒,终亡火患.今论功<br>而请宾,曲突徙薪亡恩泽,焦头烂额为上客耶?”主人乃寤而请之(9).</p>\n<p>――节选自班固《汉书·霍光传》</p>\n<p>注释<br>⑴过：拜访，探望。</p>\n<p>⑵突：烟囱。</p>\n<p>⑶薪：柴草。</p>\n<p>⑷更：改。</p>\n<p>⑸徙(xǐ)：搬走。</p>\n<p>⑹灼：烧炙。烂：烧伤。行(háng)：座次。</p>\n<p>⑺录：采，取，这里有邀请的意思。</p>\n<p>⑻向使：向：原先。使：假使。</p>\n<p>⑼寤(wù)：醒悟，明白</p>\n<p>有一位客人到主人家拜访，见主人家炉灶的烟囱是直的，旁边又堆有柴薪，这位客人便对主人说：‘您的烟囱应改为弯曲的，并将柴薪搬到远处去，不然的话，将会发生火灾！’主人默然，不予理会。不久，主人家果然失火，邻居们共同抢救，幸而将火扑灭。于是，主人家杀牛摆酒，对邻居表示感谢，在救火中烧伤的被请到上座，其余则各按出力大小依次就坐，却没有请那位建议他改弯烟囱的人。有人对这家主人说：‘当初要是听了那位客人的劝告，就不用杀牛摆酒，终究不会有火灾。如今论功请客酬谢，建议改弯烟囱、移走柴薪的人没有功劳，而在救火时被烧得焦头烂额的人才是上客吗？’主人这才醒悟，将那位客人请来。</p>\n<p>“曲突徙薪之恩泽,焦头烂额为上客”：建议改弯烟囱、移走柴薪的人没有功劳，而在救火时被烧得焦头烂额的人成了上客</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"曲突徙薪\"><a href=\"#曲突徙薪\" class=\"headerlink\" title=\"曲突徙薪\"></a>曲突徙薪</h2><p>客有过主人者(1),见其灶直突(2),旁有积薪(3),客谓主人:”更为曲突(4),<br>远徙其薪(5),不者且有火患”.主人默然不应.俄而果失火,邻里共救之,幸而<br>得息.于是杀牛置酒,谢其邻人,灼烂者在于上行(6),余各以功次坐,而不录<br>言曲突者(7),人谓主人曰:”向使听客之言(8),不费牛酒,终亡火患.今论功<br>而请宾,曲突徙薪亡恩泽,焦头烂额为上客耶?”主人乃寤而请之(9).</p>\n<p>――节选自班固《汉书·霍光传》</p>\n<p>注释<br>⑴过：拜访，探望。</p>\n<p>⑵突：烟囱。</p>\n<p>⑶薪：柴草。</p>\n<p>⑷更：改。</p>\n<p>⑸徙(xǐ)：搬走。</p>\n<p>⑹灼：烧炙。烂：烧伤。行(háng)：座次。</p>\n<p>⑺录：采，取，这里有邀请的意思。</p>\n<p>⑻向使：向：原先。使：假使。</p>\n<p>⑼寤(wù)：醒悟，明白</p>\n<p>有一位客人到主人家拜访，见主人家炉灶的烟囱是直的，旁边又堆有柴薪，这位客人便对主人说：‘您的烟囱应改为弯曲的，并将柴薪搬到远处去，不然的话，将会发生火灾！’主人默然，不予理会。不久，主人家果然失火，邻居们共同抢救，幸而将火扑灭。于是，主人家杀牛摆酒，对邻居表示感谢，在救火中烧伤的被请到上座，其余则各按出力大小依次就坐，却没有请那位建议他改弯烟囱的人。有人对这家主人说：‘当初要是听了那位客人的劝告，就不用杀牛摆酒，终究不会有火灾。如今论功请客酬谢，建议改弯烟囱、移走柴薪的人没有功劳，而在救火时被烧得焦头烂额的人才是上客吗？’主人这才醒悟，将那位客人请来。</p>\n<p>“曲突徙薪之恩泽,焦头烂额为上客”：建议改弯烟囱、移走柴薪的人没有功劳，而在救火时被烧得焦头烂额的人成了上客</p>\n"},{"title":"泰拳要领","date":"2019-09-02T01:57:22.000Z","_content":"\n上周六送弟弟去学泰拳,偷师了几招.在此记录一下\n\n* 收拳要收到脸上(护头)\n\n* 鞭腿腿是直的\n\n* 提膝打击支撑腿是直的\n\n* 鞭腿支撑腿略微忘左上走一点\n\n* 打沙袋一定带护具 拳套等\n\n教练演示着实震撼,以后让儿子也学!\n","source":"_posts/泰拳要领.md","raw":"---\ntitle: 泰拳要领\ndate: 2019-09-02 09:57:22\ntags: [生活,泰拳,运动]\ncategories: [生活] \n---\n\n上周六送弟弟去学泰拳,偷师了几招.在此记录一下\n\n* 收拳要收到脸上(护头)\n\n* 鞭腿腿是直的\n\n* 提膝打击支撑腿是直的\n\n* 鞭腿支撑腿略微忘左上走一点\n\n* 打沙袋一定带护具 拳套等\n\n教练演示着实震撼,以后让儿子也学!\n","slug":"泰拳要领","published":1,"updated":"2019-09-27T08:27:08.052Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedp001vojfy515h3itf","content":"<p>上周六送弟弟去学泰拳,偷师了几招.在此记录一下</p>\n<ul>\n<li><p>收拳要收到脸上(护头)</p>\n</li>\n<li><p>鞭腿腿是直的</p>\n</li>\n<li><p>提膝打击支撑腿是直的</p>\n</li>\n<li><p>鞭腿支撑腿略微忘左上走一点</p>\n</li>\n<li><p>打沙袋一定带护具 拳套等</p>\n</li>\n</ul>\n<p>教练演示着实震撼,以后让儿子也学!</p>\n","site":{"data":{}},"excerpt":"","more":"<p>上周六送弟弟去学泰拳,偷师了几招.在此记录一下</p>\n<ul>\n<li><p>收拳要收到脸上(护头)</p>\n</li>\n<li><p>鞭腿腿是直的</p>\n</li>\n<li><p>提膝打击支撑腿是直的</p>\n</li>\n<li><p>鞭腿支撑腿略微忘左上走一点</p>\n</li>\n<li><p>打沙袋一定带护具 拳套等</p>\n</li>\n</ul>\n<p>教练演示着实震撼,以后让儿子也学!</p>\n"},{"title":"母子分离日","date":"2019-08-03T06:11:23.000Z","_content":"早上跟媳妇儿视频,看到了镜头中的儿子.小家伙又长高了,真可爱!\n7:30过一点儿,媳妇儿要去上班了,儿子眼中有了我从未见过的东西!\n我第一次发现这家伙眼中流露出的不舍!小家伙开始要找妈妈了!\n第一次对妈妈的离去表现出了不情愿!\n看来以后上班得偷偷去了!\n\n昨天升级Ipaid,今早上班发现还在升级中,果断拔掉数据线!升级失败\nipaid也开不了机了!郁闷,点背喝凉水都塞牙缝!本想潇洒的翘个二郎腿\n不知是桌子太矮还是大腿太长亦或自己太傻逼,竟然磕到了桌子上!疼死\n老子了!IPAID也开不机!自己捣鼓了一下没搞定\n\n去四楼找修手机的看看!这哥们蒙我!”你这一点儿都开不了机”要价70\n真贵!好吧我太穷…6s换电池好点儿的要130!毅然不修走了!看到他的电脑竟然能\n识别我的IPAID,感觉我自己也能搞定.\n\n回来查资料首先\nhome键跟电源键一块儿按住约5秒进入维护模式\nitunes 更新到最新版\n点击恢复...傻瓜示下一步\n\n中间遇见未知错误2015,崩溃难道我真的要花70块钱亦或大老远跑趟西单?!\n当然不,以锲而不舍的程序员造bug精神,继续上网找资料!\n\n哎呦! 有可能是数据线的问题!好吧我的这跟山寨线有时候还真是充不上电\n换根试试! \n好了...\n人生处处有惊喜啊...\n","source":"_posts/母子分离日.md","raw":"---\ntitle: 母子分离日\ndate: 2019-08-03 14:11:23\ntags:\ncategories: \n- 生活\n---\n早上跟媳妇儿视频,看到了镜头中的儿子.小家伙又长高了,真可爱!\n7:30过一点儿,媳妇儿要去上班了,儿子眼中有了我从未见过的东西!\n我第一次发现这家伙眼中流露出的不舍!小家伙开始要找妈妈了!\n第一次对妈妈的离去表现出了不情愿!\n看来以后上班得偷偷去了!\n\n昨天升级Ipaid,今早上班发现还在升级中,果断拔掉数据线!升级失败\nipaid也开不了机了!郁闷,点背喝凉水都塞牙缝!本想潇洒的翘个二郎腿\n不知是桌子太矮还是大腿太长亦或自己太傻逼,竟然磕到了桌子上!疼死\n老子了!IPAID也开不机!自己捣鼓了一下没搞定\n\n去四楼找修手机的看看!这哥们蒙我!”你这一点儿都开不了机”要价70\n真贵!好吧我太穷…6s换电池好点儿的要130!毅然不修走了!看到他的电脑竟然能\n识别我的IPAID,感觉我自己也能搞定.\n\n回来查资料首先\nhome键跟电源键一块儿按住约5秒进入维护模式\nitunes 更新到最新版\n点击恢复...傻瓜示下一步\n\n中间遇见未知错误2015,崩溃难道我真的要花70块钱亦或大老远跑趟西单?!\n当然不,以锲而不舍的程序员造bug精神,继续上网找资料!\n\n哎呦! 有可能是数据线的问题!好吧我的这跟山寨线有时候还真是充不上电\n换根试试! \n好了...\n人生处处有惊喜啊...\n","slug":"母子分离日","published":1,"updated":"2019-09-27T08:27:08.052Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedp001wojfy042optrx","content":"<p>早上跟媳妇儿视频,看到了镜头中的儿子.小家伙又长高了,真可爱!<br>7:30过一点儿,媳妇儿要去上班了,儿子眼中有了我从未见过的东西!<br>我第一次发现这家伙眼中流露出的不舍!小家伙开始要找妈妈了!<br>第一次对妈妈的离去表现出了不情愿!<br>看来以后上班得偷偷去了!</p>\n<p>昨天升级Ipaid,今早上班发现还在升级中,果断拔掉数据线!升级失败<br>ipaid也开不了机了!郁闷,点背喝凉水都塞牙缝!本想潇洒的翘个二郎腿<br>不知是桌子太矮还是大腿太长亦或自己太傻逼,竟然磕到了桌子上!疼死<br>老子了!IPAID也开不机!自己捣鼓了一下没搞定</p>\n<p>去四楼找修手机的看看!这哥们蒙我!”你这一点儿都开不了机”要价70<br>真贵!好吧我太穷…6s换电池好点儿的要130!毅然不修走了!看到他的电脑竟然能<br>识别我的IPAID,感觉我自己也能搞定.</p>\n<p>回来查资料首先<br>home键跟电源键一块儿按住约5秒进入维护模式<br>itunes 更新到最新版<br>点击恢复…傻瓜示下一步</p>\n<p>中间遇见未知错误2015,崩溃难道我真的要花70块钱亦或大老远跑趟西单?!<br>当然不,以锲而不舍的程序员造bug精神,继续上网找资料!</p>\n<p>哎呦! 有可能是数据线的问题!好吧我的这跟山寨线有时候还真是充不上电<br>换根试试!<br>好了…<br>人生处处有惊喜啊…</p>\n","site":{"data":{}},"excerpt":"","more":"<p>早上跟媳妇儿视频,看到了镜头中的儿子.小家伙又长高了,真可爱!<br>7:30过一点儿,媳妇儿要去上班了,儿子眼中有了我从未见过的东西!<br>我第一次发现这家伙眼中流露出的不舍!小家伙开始要找妈妈了!<br>第一次对妈妈的离去表现出了不情愿!<br>看来以后上班得偷偷去了!</p>\n<p>昨天升级Ipaid,今早上班发现还在升级中,果断拔掉数据线!升级失败<br>ipaid也开不了机了!郁闷,点背喝凉水都塞牙缝!本想潇洒的翘个二郎腿<br>不知是桌子太矮还是大腿太长亦或自己太傻逼,竟然磕到了桌子上!疼死<br>老子了!IPAID也开不机!自己捣鼓了一下没搞定</p>\n<p>去四楼找修手机的看看!这哥们蒙我!”你这一点儿都开不了机”要价70<br>真贵!好吧我太穷…6s换电池好点儿的要130!毅然不修走了!看到他的电脑竟然能<br>识别我的IPAID,感觉我自己也能搞定.</p>\n<p>回来查资料首先<br>home键跟电源键一块儿按住约5秒进入维护模式<br>itunes 更新到最新版<br>点击恢复…傻瓜示下一步</p>\n<p>中间遇见未知错误2015,崩溃难道我真的要花70块钱亦或大老远跑趟西单?!<br>当然不,以锲而不舍的程序员造bug精神,继续上网找资料!</p>\n<p>哎呦! 有可能是数据线的问题!好吧我的这跟山寨线有时候还真是充不上电<br>换根试试!<br>好了…<br>人生处处有惊喜啊…</p>\n"},{"title":"猪宝历险记","date":"2019-05-28T09:42:53.000Z","_content":"\n接上篇<<喜迎猪宝>>\n\n爸爸刚安顿好妈妈就有一个年长一些的护士将爸爸叫到了一旁,\n说\"孩子刚来时好好的,大约过了半小时出现了呼吸急促的现象,\n正常新生儿一般每分钟40次左右,你家孩子都70次了\".\n\n爸爸当时就蒙了!担心你有危险!询问护士该如何做,此时护士\n叫来了新生儿科主任,主任将你抱到了新生儿科,与爸爸的焦急\n相比,主任倒没那么担心,爸爸心中暗责主任的冷血,反过来\n想也许你这种情况也很常见!\n\n进了新生儿科你就被抱到了NICU,爸爸此时还没有真正看过你\n的脸,抱你的途中怕你着凉脸一直是遮着的\n接待爸爸的是李芳医生,人很和气!她给爸爸介绍\n说出现这种情况的原因可能是因为剖腹产,新生儿由于没有\n经过产道挤压,肺没有充分扩张,还以为自己在妈妈肚子里,\n还有一个原因是巨大儿有可能出现这种情况,\n而孩子正好两条你都符合!\n\n说了一些治疗手段,主要是给你吸氧,增加肺部扩张,若疗效不\n好就要打一种刺激肺部扩张的药......\n\n途中医生给爸爸看了你的一个小视频,看的爸爸很是揪心,视频\n中你呼吸急促,鼻翼抖动明显,脸色发紫,胸腔随着每次呼吸\n而剧烈抖动.孩子你在跟命运抗争,为生存而奋斗!爸爸在心\n里给你鼓劲,一定要好起来啊,小家伙.\n\n爸爸向医生要你的视频,医生答应的很好,可最后也没有给爸爸!\n\n医生跟爸爸交代这种情况有三天到五天的危险期!一般一周也\n就好的差不多了!爸爸好像有了底气,但又担心危险期的你!\n可能是看出了爸爸的担心,医生又跟爸爸说前48个小时最危险,\n过了就问题不大.其实最危险的是前24小时......\n\n整个治理过程家长都不能见到孩子,每周一三五可以向医生询问\n病情,每天09:00-11:00  16:00-17:00 可以去送奶.\n\n安顿好了你,爸爸就回去照顾妈妈. \n最可怜的还是你妈,10月怀胎一朝分娩.中途各种心酸暂且不表.\n看着临床的孩子陆续抱过来,而你又迟迟不到妈妈身边,爸爸\n知道得告诉妈妈了,不过爸爸耍了个小心机,没有把你的真实\n情况说明,只是说你有点儿呼吸急促,医生让观察观察.\n\n当天晚上爸爸一夜不眠!想到视频中你的样子,想到你正在跟\n命运的抗争,想到你在里面吃啥,哭了有人哄吗......\n爸爸静静的望着隔壁6楼的窗户,想着里面的你当时的境况\n,五味杂陈......\n\n第二天早上爸爸去儿科送湿纸巾,刚送完,就收到了你姥爷的\n电话,询问爸爸为什么车门是开着的? 爸爸这是才意识到刚才\n拿东西时,忘记了关车门!原来人在遇到大事时真的会六神无主\n.爸爸要向你学习,与命运抗争,当下给自己鼓劲儿,我不能倒,\n我还有孩子在NICU,媳妇儿还需要照顾,我必须振作,加油,一切\n都会好起来的.\n\n你也是真争气,医生告诉爸爸昨天下午,你就呼吸正常了,不过\n还是要观察几天.至此爸爸跟妈妈总算松了口气.\n\n\n\n\n\n\n\n","source":"_posts/猪宝历险记.md","raw":"---\ntitle: 猪宝历险记\ndate: 2019-05-28 17:42:53\ntags:\ncategories: \n- 生活\n---\n\n接上篇<<喜迎猪宝>>\n\n爸爸刚安顿好妈妈就有一个年长一些的护士将爸爸叫到了一旁,\n说\"孩子刚来时好好的,大约过了半小时出现了呼吸急促的现象,\n正常新生儿一般每分钟40次左右,你家孩子都70次了\".\n\n爸爸当时就蒙了!担心你有危险!询问护士该如何做,此时护士\n叫来了新生儿科主任,主任将你抱到了新生儿科,与爸爸的焦急\n相比,主任倒没那么担心,爸爸心中暗责主任的冷血,反过来\n想也许你这种情况也很常见!\n\n进了新生儿科你就被抱到了NICU,爸爸此时还没有真正看过你\n的脸,抱你的途中怕你着凉脸一直是遮着的\n接待爸爸的是李芳医生,人很和气!她给爸爸介绍\n说出现这种情况的原因可能是因为剖腹产,新生儿由于没有\n经过产道挤压,肺没有充分扩张,还以为自己在妈妈肚子里,\n还有一个原因是巨大儿有可能出现这种情况,\n而孩子正好两条你都符合!\n\n说了一些治疗手段,主要是给你吸氧,增加肺部扩张,若疗效不\n好就要打一种刺激肺部扩张的药......\n\n途中医生给爸爸看了你的一个小视频,看的爸爸很是揪心,视频\n中你呼吸急促,鼻翼抖动明显,脸色发紫,胸腔随着每次呼吸\n而剧烈抖动.孩子你在跟命运抗争,为生存而奋斗!爸爸在心\n里给你鼓劲,一定要好起来啊,小家伙.\n\n爸爸向医生要你的视频,医生答应的很好,可最后也没有给爸爸!\n\n医生跟爸爸交代这种情况有三天到五天的危险期!一般一周也\n就好的差不多了!爸爸好像有了底气,但又担心危险期的你!\n可能是看出了爸爸的担心,医生又跟爸爸说前48个小时最危险,\n过了就问题不大.其实最危险的是前24小时......\n\n整个治理过程家长都不能见到孩子,每周一三五可以向医生询问\n病情,每天09:00-11:00  16:00-17:00 可以去送奶.\n\n安顿好了你,爸爸就回去照顾妈妈. \n最可怜的还是你妈,10月怀胎一朝分娩.中途各种心酸暂且不表.\n看着临床的孩子陆续抱过来,而你又迟迟不到妈妈身边,爸爸\n知道得告诉妈妈了,不过爸爸耍了个小心机,没有把你的真实\n情况说明,只是说你有点儿呼吸急促,医生让观察观察.\n\n当天晚上爸爸一夜不眠!想到视频中你的样子,想到你正在跟\n命运的抗争,想到你在里面吃啥,哭了有人哄吗......\n爸爸静静的望着隔壁6楼的窗户,想着里面的你当时的境况\n,五味杂陈......\n\n第二天早上爸爸去儿科送湿纸巾,刚送完,就收到了你姥爷的\n电话,询问爸爸为什么车门是开着的? 爸爸这是才意识到刚才\n拿东西时,忘记了关车门!原来人在遇到大事时真的会六神无主\n.爸爸要向你学习,与命运抗争,当下给自己鼓劲儿,我不能倒,\n我还有孩子在NICU,媳妇儿还需要照顾,我必须振作,加油,一切\n都会好起来的.\n\n你也是真争气,医生告诉爸爸昨天下午,你就呼吸正常了,不过\n还是要观察几天.至此爸爸跟妈妈总算松了口气.\n\n\n\n\n\n\n\n","slug":"猪宝历险记","published":1,"updated":"2019-09-27T08:27:08.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedp001xojfy8aachd1t","content":"<p>接上篇&lt;&lt;喜迎猪宝&gt;&gt;</p>\n<p>爸爸刚安顿好妈妈就有一个年长一些的护士将爸爸叫到了一旁,<br>说”孩子刚来时好好的,大约过了半小时出现了呼吸急促的现象,<br>正常新生儿一般每分钟40次左右,你家孩子都70次了”.</p>\n<p>爸爸当时就蒙了!担心你有危险!询问护士该如何做,此时护士<br>叫来了新生儿科主任,主任将你抱到了新生儿科,与爸爸的焦急<br>相比,主任倒没那么担心,爸爸心中暗责主任的冷血,反过来<br>想也许你这种情况也很常见!</p>\n<p>进了新生儿科你就被抱到了NICU,爸爸此时还没有真正看过你<br>的脸,抱你的途中怕你着凉脸一直是遮着的<br>接待爸爸的是李芳医生,人很和气!她给爸爸介绍<br>说出现这种情况的原因可能是因为剖腹产,新生儿由于没有<br>经过产道挤压,肺没有充分扩张,还以为自己在妈妈肚子里,<br>还有一个原因是巨大儿有可能出现这种情况,<br>而孩子正好两条你都符合!</p>\n<p>说了一些治疗手段,主要是给你吸氧,增加肺部扩张,若疗效不<br>好就要打一种刺激肺部扩张的药……</p>\n<p>途中医生给爸爸看了你的一个小视频,看的爸爸很是揪心,视频<br>中你呼吸急促,鼻翼抖动明显,脸色发紫,胸腔随着每次呼吸<br>而剧烈抖动.孩子你在跟命运抗争,为生存而奋斗!爸爸在心<br>里给你鼓劲,一定要好起来啊,小家伙.</p>\n<p>爸爸向医生要你的视频,医生答应的很好,可最后也没有给爸爸!</p>\n<p>医生跟爸爸交代这种情况有三天到五天的危险期!一般一周也<br>就好的差不多了!爸爸好像有了底气,但又担心危险期的你!<br>可能是看出了爸爸的担心,医生又跟爸爸说前48个小时最危险,<br>过了就问题不大.其实最危险的是前24小时……</p>\n<p>整个治理过程家长都不能见到孩子,每周一三五可以向医生询问<br>病情,每天09:00-11:00  16:00-17:00 可以去送奶.</p>\n<p>安顿好了你,爸爸就回去照顾妈妈.<br>最可怜的还是你妈,10月怀胎一朝分娩.中途各种心酸暂且不表.<br>看着临床的孩子陆续抱过来,而你又迟迟不到妈妈身边,爸爸<br>知道得告诉妈妈了,不过爸爸耍了个小心机,没有把你的真实<br>情况说明,只是说你有点儿呼吸急促,医生让观察观察.</p>\n<p>当天晚上爸爸一夜不眠!想到视频中你的样子,想到你正在跟<br>命运的抗争,想到你在里面吃啥,哭了有人哄吗……<br>爸爸静静的望着隔壁6楼的窗户,想着里面的你当时的境况<br>,五味杂陈……</p>\n<p>第二天早上爸爸去儿科送湿纸巾,刚送完,就收到了你姥爷的<br>电话,询问爸爸为什么车门是开着的? 爸爸这是才意识到刚才<br>拿东西时,忘记了关车门!原来人在遇到大事时真的会六神无主<br>.爸爸要向你学习,与命运抗争,当下给自己鼓劲儿,我不能倒,<br>我还有孩子在NICU,媳妇儿还需要照顾,我必须振作,加油,一切<br>都会好起来的.</p>\n<p>你也是真争气,医生告诉爸爸昨天下午,你就呼吸正常了,不过<br>还是要观察几天.至此爸爸跟妈妈总算松了口气.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>接上篇&lt;&lt;喜迎猪宝&gt;&gt;</p>\n<p>爸爸刚安顿好妈妈就有一个年长一些的护士将爸爸叫到了一旁,<br>说”孩子刚来时好好的,大约过了半小时出现了呼吸急促的现象,<br>正常新生儿一般每分钟40次左右,你家孩子都70次了”.</p>\n<p>爸爸当时就蒙了!担心你有危险!询问护士该如何做,此时护士<br>叫来了新生儿科主任,主任将你抱到了新生儿科,与爸爸的焦急<br>相比,主任倒没那么担心,爸爸心中暗责主任的冷血,反过来<br>想也许你这种情况也很常见!</p>\n<p>进了新生儿科你就被抱到了NICU,爸爸此时还没有真正看过你<br>的脸,抱你的途中怕你着凉脸一直是遮着的<br>接待爸爸的是李芳医生,人很和气!她给爸爸介绍<br>说出现这种情况的原因可能是因为剖腹产,新生儿由于没有<br>经过产道挤压,肺没有充分扩张,还以为自己在妈妈肚子里,<br>还有一个原因是巨大儿有可能出现这种情况,<br>而孩子正好两条你都符合!</p>\n<p>说了一些治疗手段,主要是给你吸氧,增加肺部扩张,若疗效不<br>好就要打一种刺激肺部扩张的药……</p>\n<p>途中医生给爸爸看了你的一个小视频,看的爸爸很是揪心,视频<br>中你呼吸急促,鼻翼抖动明显,脸色发紫,胸腔随着每次呼吸<br>而剧烈抖动.孩子你在跟命运抗争,为生存而奋斗!爸爸在心<br>里给你鼓劲,一定要好起来啊,小家伙.</p>\n<p>爸爸向医生要你的视频,医生答应的很好,可最后也没有给爸爸!</p>\n<p>医生跟爸爸交代这种情况有三天到五天的危险期!一般一周也<br>就好的差不多了!爸爸好像有了底气,但又担心危险期的你!<br>可能是看出了爸爸的担心,医生又跟爸爸说前48个小时最危险,<br>过了就问题不大.其实最危险的是前24小时……</p>\n<p>整个治理过程家长都不能见到孩子,每周一三五可以向医生询问<br>病情,每天09:00-11:00  16:00-17:00 可以去送奶.</p>\n<p>安顿好了你,爸爸就回去照顾妈妈.<br>最可怜的还是你妈,10月怀胎一朝分娩.中途各种心酸暂且不表.<br>看着临床的孩子陆续抱过来,而你又迟迟不到妈妈身边,爸爸<br>知道得告诉妈妈了,不过爸爸耍了个小心机,没有把你的真实<br>情况说明,只是说你有点儿呼吸急促,医生让观察观察.</p>\n<p>当天晚上爸爸一夜不眠!想到视频中你的样子,想到你正在跟<br>命运的抗争,想到你在里面吃啥,哭了有人哄吗……<br>爸爸静静的望着隔壁6楼的窗户,想着里面的你当时的境况<br>,五味杂陈……</p>\n<p>第二天早上爸爸去儿科送湿纸巾,刚送完,就收到了你姥爷的<br>电话,询问爸爸为什么车门是开着的? 爸爸这是才意识到刚才<br>拿东西时,忘记了关车门!原来人在遇到大事时真的会六神无主<br>.爸爸要向你学习,与命运抗争,当下给自己鼓劲儿,我不能倒,<br>我还有孩子在NICU,媳妇儿还需要照顾,我必须振作,加油,一切<br>都会好起来的.</p>\n<p>你也是真争气,医生告诉爸爸昨天下午,你就呼吸正常了,不过<br>还是要观察几天.至此爸爸跟妈妈总算松了口气.</p>\n"},{"title":"玩物丧志","date":"2019-08-26T02:09:39.000Z","_content":"\n曾闻古训戒禽荒，一鹤谁知便丧邦。荥泽当时遍磷火，可能骑鹤返仙乡？\n\n谨以此致自己被玩儿的岁月!\n","source":"_posts/玩物丧志.md","raw":"---\ntitle: 玩物丧志\ndate: 2019-08-26 10:09:39\ntags:\n---\n\n曾闻古训戒禽荒，一鹤谁知便丧邦。荥泽当时遍磷火，可能骑鹤返仙乡？\n\n谨以此致自己被玩儿的岁月!\n","slug":"玩物丧志","published":1,"updated":"2019-09-27T08:27:08.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedq001yojfy0md28pmz","content":"<p>曾闻古训戒禽荒，一鹤谁知便丧邦。荥泽当时遍磷火，可能骑鹤返仙乡？</p>\n<p>谨以此致自己被玩儿的岁月!</p>\n","site":{"data":{}},"excerpt":"","more":"<p>曾闻古训戒禽荒，一鹤谁知便丧邦。荥泽当时遍磷火，可能骑鹤返仙乡？</p>\n<p>谨以此致自己被玩儿的岁月!</p>\n"},{"title":"深入解读RabbitMQ工作原理及Java中简单使用","date":"2018-07-16T02:29:44.000Z","_content":"\n## 引用: https://mp.weixin.qq.com/s/ryu-zD3U62m32BZdByNxng http://www.cnblogs.com/vipstone/ \n\n## RabbitMQ简介\n在介绍RabbitMQ之前首先介绍一下MQ ,MQ是什么?\n\nMQ全称是Message Queue.可以理解为消息队列的意思.简单的说就是消息以\n管道的方式进行传递\n\nRabbitMQ是一个实现了AMQP(Advanced Message Queuing Protocol)\n高级消息队列协议的消息队列服务,用Erlang语音写成.\n\n## 使用场景\n在我们秒杀抢购商品的时候,系统会提醒我们稍等排队中,而不是像几年前一样\n页面卡死或报错给用户.\n\n像这种排队结算就是用到了消息队列机制,放入通道里面一个一个结算处理,而不\n是某个时间段突然涌入大批量的查询新增把数据库给搞宕机.所以RabbitMQ本质\n上起到的作用就是削峰填谷,为业务保驾护航.\n\n## 为什么选择RabbitMQ\n现在市面上有很多MQ可以选择,比如ActiveMQ ZeroMQ Appche Qpid,那问\n题来了为啥要选择RabbitMQ?\n\n1: 除了Qpid,RabbitMQ是唯一一个实现了AMQP标准的消息服务器;\n2: 可靠性,RabbitMQ的持久化支持,保证了消息的稳定性;\n3: 高并发,RabbitMQ使用了Erlang开发语言,Erlang是为电话交换机开发的语言,\n天生自带高并发光环,和高可用特性;\n4: 集群部署简单,正是因为Erlang使得RabbitMQ集群部署变得超级简单;\n5: 社区活跃度高,根据网上资料来看,RabbitMQ也是首选;\n\n## 工作机制\n\n### 生产者 消费者和代理\n\n在了解消息通讯之前首先要了解3个概念:生产者 消费者和代理.\n\n生产者:消息的创建者,负责创建和推送数据到消息服务器;\n\n消费者:消息的接收方,用于处理数据和确认消息;\n\n代理者:就是RabbitMQ本身,用于扮演\"快递\"的角色,本身不生产消息,\n只是扮演\"快递\"的角色.\n\n### 消息发送原理\n首先你必须连接到Rabbit才能发布和消费消息,那怎么连接和发送消息呢?\n\n你的应用程序和Rabbit Server之间会创建一个TCP连接,一旦TCP打开,\n并通过认证,认证就是你试图连接Rabbit之前发送的Rabbit服务器连接\n信息和用户名和密码,有点像程序连接数据库,使用Java有两种连接认证\n的方式,后面代码会详细介绍,一旦认证通过你的应用程序和Rabbit就创建\n了一条AMQP信道(Channel).\n\n信道是创建在\"真实\"TCP上的虚拟连接,AMQP命令都是通过信道发送出去的,\n每个信道都会有唯一的ID,不论是发布消息,订阅队列或者介绍消息都是通过\n信道完成的.\n\n### 为什么不通过TCP直接发送命令?\n\n对于操作系统来说创建和销毁TCP会话是非常昂贵的开销,假设高峰期每秒\n有成千上万条连接,每个连接都要创建一条TCP会话,这就造成了TCP连接的\n巨大浪费,而且操作系统每秒能创建的TCP也是有限的,因此很快就会遇到系统\n瓶颈.\n\n如果我们每个请求都使用一条TCP连接,既满足了性能的需要,又能确保每个\n连接的私密性,这就是引入信道概念的原因.\n\n\n## 你必须知道的RabbitMQ\n\n想要真正的了解Rabbit有些名词是你必须知道的.\n\n包括:ConnectionFactory(连接管理器) Channel(信道) \nExchange(交换器) Queue(队列) RoutingKey(路由键)\nBindingKey(绑定键)\n\nConnectionFactory(连接管理器): 应用程序与Rabbit之间\n建立连接的管理器,程序代码中使用;\n\nChannel(信道) :消息推送使用的通道;\n\nExchange(交换器) :用于接受 分配消息;\n\nQueue(队列): 用于存储生产者的消息;\n\nRoutingKey(路由键): 用于把生成者的数据分配到交换器上;\n\nbingdingKey(绑定键): 用于把交换器的消息绑带到队列上;\n\n![示例图片](https://mmbiz.qpic.cn/mmbiz_gif/WwPkUCFX4x6A5PeoEjBet8tpwnyOsaoWhdsqr2n1dLrSfJlaofbVayxUTemicQlbFmiaEHUMY83AIOsIXTaNicPwQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n## 消息持久化\nRabbit队列和交换器有一个不可告人的秘密,就是默认情况下重启\n服务器会导致消息丢失,那么怎么保证Rabbit在重启的时候不丢失呢?\n答案就是消息持久化.\n\n当你把消息发送到Rabbit服务器的时候,你需要选择你是否要进行持久化,但这并\n不能保证Rabbit能重崩溃中恢复,想要Rabbit消息能恢复必须要满足3个条件:\n\n投递消息的时候durable设置为true,消息持久化;\n\n消息已经到达持久化交换器上;\n\n消息已经到达持久化的队列;\n\n### 持久化工作原理\n\nRabbit会将你的持久化消息写入磁盘上的持久化日志文件,等消息被消费后,Rabbit\n会把这条消息标识为等待垃圾回收.\n\n### 持久化的缺点\n\n消息持久化的优点显而易见,但缺点也很明显,那就是性能,因为要写入硬盘要比\n写入内存性能低很多,从而降低了服务器的吞吐量,尽管使用SSD硬盘可以使事情\n得到缓解,但他仍然吸干了Rabbit的性能,当消息成千上万条要写入磁盘的时候\n,性能是很低的.\n\n所以使用者要根据自己的的情况,选择适合自己的方式.\n\n## 虚拟主机\n\n每个Rabbit都能创建很多vhost,我们称之为虚拟主机,每个虚拟主机其实都是\nmini版的RabbitMQ,拥有自己的队列,交换器和绑定,拥有自己的权限机制.\n\n## 环境搭建\n\n如果你是在Windows10上去安装那就更简单了，先放下载地址：\n\nErlang/Rabbit Server百度网盘链接：https://pan.baidu.com/s/1TnKDV-ZuXLiIgyK8c8f9dg 密码：wct9\n\n当然也可去Erlang和Rabbit官网去下，就是速度比较慢。我的百度云Rabbit最新版本：3.7.6，Erlang版本：20.2，注意：不要下载最新的Erlang，在Windows10上打开扩展插件有问题，打不开。\n\n1.安装Erlang；\n\n2.安装Rabbit Server；\n\n3.进入安装目录sbin下，使用命令“rabbitmq-plugins enable                                     rabbitmq_management”启动网页管理插件；\n\n4.重启Rabbit服务；\n\n使用：http://localhost:15672进行测试，默认的登陆账号为：guest，密码为：guest\n\n## 重复安装Rabbit Server的坑\n如果不是第一次在Windows上安装Rabbit Server一定要把Rabbit和Erlang卸载干净\n之后，找到注册表：HKEY_LOCAL_MACHINESOFTWAREEricssonErlangErlSrv 删除\n其下的所有项。\n\n不然会出现Rabbit安装之后启动不了的情况，理论上卸载的顺序也是先Rabbit在Erlang。\n\n## 代码实现\n\njava版实现,使用maven项目.\n\n项目创建成功之后,添加Rabbit Client jar包,只需要在pom.xml里面配置,如下信息:\n\n    <dependency>\n        <groupId>com.rabbitmq</groupId>\n        <artifactId>amqp-client</artifactId>\n        <version>4.7.0</version>\n    </dependency>\n\njava实现代码分为两个类,第一个是创建Rabbit连接,第二是应用类使用最简单的方式\n发布和消费消息.\n\n### Rabbit的连接,两种方式:\n\n方式一:\n\n    public static Connection GetRabbitConnection() {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setUsername(Config.UserName);\n        factory.setPassword(Config.Password);\n        factory.setVirtualHost(Config.VHost);\n        factory.setHost(Config.Host);\n        factory.setPort(Config.Port);\n        Connection conn = null;\n        try {\n            conn = factory.newConnection();\n        } catch (Exception e) {\n            e.printStackTrace(); \n        } \n        \n        return conn;\n    }\n\n方式二:\n\n    public static Connection GetRabbitConnection() {\n        ConnectionFactory factory = new ConnectionFactory();\n        \n        // 连接格式：amqp://userName:password@hostName:portNumber/virtualHost\n        String uri = String.format(\n                \"amqp://%s:%s@%s:%d%s\", \n                Config.UserName, \n                Config.Password,\n                Config.Host, \n                Config.Port,\n                Config.VHost);\n        Connection conn = null;\n        try {\n            factory.setUri(uri);\n            factory.setVirtualHost(Config.VHost);\n            conn = factory.newConnection();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }                \n        return conn;\n    }\n\n### 第二部分: 应用类,使用最简单的方式发布和消费消息\n\n    public static void main(String[] args) {\n        Publisher(); // 推送消息\n        \n        Consumer(); // 消费消息\n    }\n    \n    /**\n    * 推送消息\n    */\n    public static void Publisher() {\n        // 创建一个连接\n        Connection conn = ConnectionFactoryUtil.GetRabbitConnection();\n        if (conn != null) {\n            try{\n                // 创建通道\n                Channel channel = conn.createChannel();\n                // 声明队列【参数说明：参数一：队列名称，参数二：是否持久化；参数三：是否独占模式；参数四：消费者断开连接时是否删除队列；参数五：消息其他参数】\n                channel.queueDeclare(Config.QueueName, false, false, false, null);\n                String content = \n                    String.format(\"当前时间: %s\",new Date().getTime());\n                // 发送内容【参数说明：参数一：交换机名称；参数二：队列名称，参数三：消息的其他属性；参数四：消息主体】\n                channel.basicPublish(\"\", Config.QueueName, null, content.getBytes(\"UTF-8\"));\n                System.out.println(\"已发送消息：\" + content);\n                // 关闭连接\n                channel.close();\n                conn.close();\n            } catch(Exception e) {\n                e.printStackTrace();\n            }\n        } \n    }\n\n    /**\n    * 消费消息\n    */\n    public static void Consumer() {\n        // 创建一个连接\n        Connection conn = ConnectionFactoryUtil.GetRabbitConnection();\n        if(conn != null) {\n            try {\n                // 创建通道\n                Channel channel = conn.createChannel();\n                // 声明队列[参数说明:1:队列名称,2:是否持久化,3:是否独占模式,4:消费者断开连接时是否删除队列,5:消息其他参数]\n                channel.queueDelare(Config.QueueName,false,false,false,null);\n                \n                //创建订阅器,并接受消息\n                channel.basicConsume(Config.QueueName,false,\"\",new DefaultConsumer(channel) {\n                    @Overrride\n                    public void handleDelivery(\n                        String consumerTag,\n                        Envelope envelope,\n                        AMQP.BasicPropeties properties,\n                        byte[] body) throws IOException {\n                        String routingKey = envelope.getRoutingkey(); // 队列名称\n                        String contentType = properties.getContentType(); // 内容类型\n                        String content = new String(body,\"utf-8\"); // 消息正文\n                        System.out.println(\"消息正文:\" + content);\n                        channel.basicAck(envelope.getDeliveryTag(),false); // 手动确认消息(参数1:该消息的index;2:是否批量应答,true批量确认小于index的消息)\n                    }\n                        \n                });\n            \n            } catch(Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n代码里面已经写了很详细的注释，在这里也不过多的介绍了。\n\n执行效果，如图：\n\n![示例图片](https://mmbiz.qpic.cn/mmbiz_png/WwPkUCFX4x6A5PeoEjBet8tpwnyOsaoWtlqQAptMtgjn6YQXj1cJxNGyc0puMV6EVf1dwtNhCzjDqfj85XCsibA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/深入解读RabbitMQ工作原理及Java中简单使用.md","raw":"---\ntitle: 深入解读RabbitMQ工作原理及Java中简单使用\ndate: 2018-07-16 10:29:44\ntags: [rabbitMQ,java]\ncategories: \n- rabbitMQ\n---\n\n## 引用: https://mp.weixin.qq.com/s/ryu-zD3U62m32BZdByNxng http://www.cnblogs.com/vipstone/ \n\n## RabbitMQ简介\n在介绍RabbitMQ之前首先介绍一下MQ ,MQ是什么?\n\nMQ全称是Message Queue.可以理解为消息队列的意思.简单的说就是消息以\n管道的方式进行传递\n\nRabbitMQ是一个实现了AMQP(Advanced Message Queuing Protocol)\n高级消息队列协议的消息队列服务,用Erlang语音写成.\n\n## 使用场景\n在我们秒杀抢购商品的时候,系统会提醒我们稍等排队中,而不是像几年前一样\n页面卡死或报错给用户.\n\n像这种排队结算就是用到了消息队列机制,放入通道里面一个一个结算处理,而不\n是某个时间段突然涌入大批量的查询新增把数据库给搞宕机.所以RabbitMQ本质\n上起到的作用就是削峰填谷,为业务保驾护航.\n\n## 为什么选择RabbitMQ\n现在市面上有很多MQ可以选择,比如ActiveMQ ZeroMQ Appche Qpid,那问\n题来了为啥要选择RabbitMQ?\n\n1: 除了Qpid,RabbitMQ是唯一一个实现了AMQP标准的消息服务器;\n2: 可靠性,RabbitMQ的持久化支持,保证了消息的稳定性;\n3: 高并发,RabbitMQ使用了Erlang开发语言,Erlang是为电话交换机开发的语言,\n天生自带高并发光环,和高可用特性;\n4: 集群部署简单,正是因为Erlang使得RabbitMQ集群部署变得超级简单;\n5: 社区活跃度高,根据网上资料来看,RabbitMQ也是首选;\n\n## 工作机制\n\n### 生产者 消费者和代理\n\n在了解消息通讯之前首先要了解3个概念:生产者 消费者和代理.\n\n生产者:消息的创建者,负责创建和推送数据到消息服务器;\n\n消费者:消息的接收方,用于处理数据和确认消息;\n\n代理者:就是RabbitMQ本身,用于扮演\"快递\"的角色,本身不生产消息,\n只是扮演\"快递\"的角色.\n\n### 消息发送原理\n首先你必须连接到Rabbit才能发布和消费消息,那怎么连接和发送消息呢?\n\n你的应用程序和Rabbit Server之间会创建一个TCP连接,一旦TCP打开,\n并通过认证,认证就是你试图连接Rabbit之前发送的Rabbit服务器连接\n信息和用户名和密码,有点像程序连接数据库,使用Java有两种连接认证\n的方式,后面代码会详细介绍,一旦认证通过你的应用程序和Rabbit就创建\n了一条AMQP信道(Channel).\n\n信道是创建在\"真实\"TCP上的虚拟连接,AMQP命令都是通过信道发送出去的,\n每个信道都会有唯一的ID,不论是发布消息,订阅队列或者介绍消息都是通过\n信道完成的.\n\n### 为什么不通过TCP直接发送命令?\n\n对于操作系统来说创建和销毁TCP会话是非常昂贵的开销,假设高峰期每秒\n有成千上万条连接,每个连接都要创建一条TCP会话,这就造成了TCP连接的\n巨大浪费,而且操作系统每秒能创建的TCP也是有限的,因此很快就会遇到系统\n瓶颈.\n\n如果我们每个请求都使用一条TCP连接,既满足了性能的需要,又能确保每个\n连接的私密性,这就是引入信道概念的原因.\n\n\n## 你必须知道的RabbitMQ\n\n想要真正的了解Rabbit有些名词是你必须知道的.\n\n包括:ConnectionFactory(连接管理器) Channel(信道) \nExchange(交换器) Queue(队列) RoutingKey(路由键)\nBindingKey(绑定键)\n\nConnectionFactory(连接管理器): 应用程序与Rabbit之间\n建立连接的管理器,程序代码中使用;\n\nChannel(信道) :消息推送使用的通道;\n\nExchange(交换器) :用于接受 分配消息;\n\nQueue(队列): 用于存储生产者的消息;\n\nRoutingKey(路由键): 用于把生成者的数据分配到交换器上;\n\nbingdingKey(绑定键): 用于把交换器的消息绑带到队列上;\n\n![示例图片](https://mmbiz.qpic.cn/mmbiz_gif/WwPkUCFX4x6A5PeoEjBet8tpwnyOsaoWhdsqr2n1dLrSfJlaofbVayxUTemicQlbFmiaEHUMY83AIOsIXTaNicPwQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n## 消息持久化\nRabbit队列和交换器有一个不可告人的秘密,就是默认情况下重启\n服务器会导致消息丢失,那么怎么保证Rabbit在重启的时候不丢失呢?\n答案就是消息持久化.\n\n当你把消息发送到Rabbit服务器的时候,你需要选择你是否要进行持久化,但这并\n不能保证Rabbit能重崩溃中恢复,想要Rabbit消息能恢复必须要满足3个条件:\n\n投递消息的时候durable设置为true,消息持久化;\n\n消息已经到达持久化交换器上;\n\n消息已经到达持久化的队列;\n\n### 持久化工作原理\n\nRabbit会将你的持久化消息写入磁盘上的持久化日志文件,等消息被消费后,Rabbit\n会把这条消息标识为等待垃圾回收.\n\n### 持久化的缺点\n\n消息持久化的优点显而易见,但缺点也很明显,那就是性能,因为要写入硬盘要比\n写入内存性能低很多,从而降低了服务器的吞吐量,尽管使用SSD硬盘可以使事情\n得到缓解,但他仍然吸干了Rabbit的性能,当消息成千上万条要写入磁盘的时候\n,性能是很低的.\n\n所以使用者要根据自己的的情况,选择适合自己的方式.\n\n## 虚拟主机\n\n每个Rabbit都能创建很多vhost,我们称之为虚拟主机,每个虚拟主机其实都是\nmini版的RabbitMQ,拥有自己的队列,交换器和绑定,拥有自己的权限机制.\n\n## 环境搭建\n\n如果你是在Windows10上去安装那就更简单了，先放下载地址：\n\nErlang/Rabbit Server百度网盘链接：https://pan.baidu.com/s/1TnKDV-ZuXLiIgyK8c8f9dg 密码：wct9\n\n当然也可去Erlang和Rabbit官网去下，就是速度比较慢。我的百度云Rabbit最新版本：3.7.6，Erlang版本：20.2，注意：不要下载最新的Erlang，在Windows10上打开扩展插件有问题，打不开。\n\n1.安装Erlang；\n\n2.安装Rabbit Server；\n\n3.进入安装目录sbin下，使用命令“rabbitmq-plugins enable                                     rabbitmq_management”启动网页管理插件；\n\n4.重启Rabbit服务；\n\n使用：http://localhost:15672进行测试，默认的登陆账号为：guest，密码为：guest\n\n## 重复安装Rabbit Server的坑\n如果不是第一次在Windows上安装Rabbit Server一定要把Rabbit和Erlang卸载干净\n之后，找到注册表：HKEY_LOCAL_MACHINESOFTWAREEricssonErlangErlSrv 删除\n其下的所有项。\n\n不然会出现Rabbit安装之后启动不了的情况，理论上卸载的顺序也是先Rabbit在Erlang。\n\n## 代码实现\n\njava版实现,使用maven项目.\n\n项目创建成功之后,添加Rabbit Client jar包,只需要在pom.xml里面配置,如下信息:\n\n    <dependency>\n        <groupId>com.rabbitmq</groupId>\n        <artifactId>amqp-client</artifactId>\n        <version>4.7.0</version>\n    </dependency>\n\njava实现代码分为两个类,第一个是创建Rabbit连接,第二是应用类使用最简单的方式\n发布和消费消息.\n\n### Rabbit的连接,两种方式:\n\n方式一:\n\n    public static Connection GetRabbitConnection() {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setUsername(Config.UserName);\n        factory.setPassword(Config.Password);\n        factory.setVirtualHost(Config.VHost);\n        factory.setHost(Config.Host);\n        factory.setPort(Config.Port);\n        Connection conn = null;\n        try {\n            conn = factory.newConnection();\n        } catch (Exception e) {\n            e.printStackTrace(); \n        } \n        \n        return conn;\n    }\n\n方式二:\n\n    public static Connection GetRabbitConnection() {\n        ConnectionFactory factory = new ConnectionFactory();\n        \n        // 连接格式：amqp://userName:password@hostName:portNumber/virtualHost\n        String uri = String.format(\n                \"amqp://%s:%s@%s:%d%s\", \n                Config.UserName, \n                Config.Password,\n                Config.Host, \n                Config.Port,\n                Config.VHost);\n        Connection conn = null;\n        try {\n            factory.setUri(uri);\n            factory.setVirtualHost(Config.VHost);\n            conn = factory.newConnection();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }                \n        return conn;\n    }\n\n### 第二部分: 应用类,使用最简单的方式发布和消费消息\n\n    public static void main(String[] args) {\n        Publisher(); // 推送消息\n        \n        Consumer(); // 消费消息\n    }\n    \n    /**\n    * 推送消息\n    */\n    public static void Publisher() {\n        // 创建一个连接\n        Connection conn = ConnectionFactoryUtil.GetRabbitConnection();\n        if (conn != null) {\n            try{\n                // 创建通道\n                Channel channel = conn.createChannel();\n                // 声明队列【参数说明：参数一：队列名称，参数二：是否持久化；参数三：是否独占模式；参数四：消费者断开连接时是否删除队列；参数五：消息其他参数】\n                channel.queueDeclare(Config.QueueName, false, false, false, null);\n                String content = \n                    String.format(\"当前时间: %s\",new Date().getTime());\n                // 发送内容【参数说明：参数一：交换机名称；参数二：队列名称，参数三：消息的其他属性；参数四：消息主体】\n                channel.basicPublish(\"\", Config.QueueName, null, content.getBytes(\"UTF-8\"));\n                System.out.println(\"已发送消息：\" + content);\n                // 关闭连接\n                channel.close();\n                conn.close();\n            } catch(Exception e) {\n                e.printStackTrace();\n            }\n        } \n    }\n\n    /**\n    * 消费消息\n    */\n    public static void Consumer() {\n        // 创建一个连接\n        Connection conn = ConnectionFactoryUtil.GetRabbitConnection();\n        if(conn != null) {\n            try {\n                // 创建通道\n                Channel channel = conn.createChannel();\n                // 声明队列[参数说明:1:队列名称,2:是否持久化,3:是否独占模式,4:消费者断开连接时是否删除队列,5:消息其他参数]\n                channel.queueDelare(Config.QueueName,false,false,false,null);\n                \n                //创建订阅器,并接受消息\n                channel.basicConsume(Config.QueueName,false,\"\",new DefaultConsumer(channel) {\n                    @Overrride\n                    public void handleDelivery(\n                        String consumerTag,\n                        Envelope envelope,\n                        AMQP.BasicPropeties properties,\n                        byte[] body) throws IOException {\n                        String routingKey = envelope.getRoutingkey(); // 队列名称\n                        String contentType = properties.getContentType(); // 内容类型\n                        String content = new String(body,\"utf-8\"); // 消息正文\n                        System.out.println(\"消息正文:\" + content);\n                        channel.basicAck(envelope.getDeliveryTag(),false); // 手动确认消息(参数1:该消息的index;2:是否批量应答,true批量确认小于index的消息)\n                    }\n                        \n                });\n            \n            } catch(Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n代码里面已经写了很详细的注释，在这里也不过多的介绍了。\n\n执行效果，如图：\n\n![示例图片](https://mmbiz.qpic.cn/mmbiz_png/WwPkUCFX4x6A5PeoEjBet8tpwnyOsaoWtlqQAptMtgjn6YQXj1cJxNGyc0puMV6EVf1dwtNhCzjDqfj85XCsibA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"深入解读RabbitMQ工作原理及Java中简单使用","published":1,"updated":"2019-09-27T08:27:08.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedq001zojfy74koa75m","content":"<h2 id=\"引用-https-mp-weixin-qq-com-s-ryu-zD3U62m32BZdByNxng-http-www-cnblogs-com-vipstone\"><a href=\"#引用-https-mp-weixin-qq-com-s-ryu-zD3U62m32BZdByNxng-http-www-cnblogs-com-vipstone\" class=\"headerlink\" title=\"引用: https://mp.weixin.qq.com/s/ryu-zD3U62m32BZdByNxng http://www.cnblogs.com/vipstone/\"></a>引用: <a href=\"https://mp.weixin.qq.com/s/ryu-zD3U62m32BZdByNxng\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/ryu-zD3U62m32BZdByNxng</a> <a href=\"http://www.cnblogs.com/vipstone/\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/vipstone/</a></h2><h2 id=\"RabbitMQ简介\"><a href=\"#RabbitMQ简介\" class=\"headerlink\" title=\"RabbitMQ简介\"></a>RabbitMQ简介</h2><p>在介绍RabbitMQ之前首先介绍一下MQ ,MQ是什么?</p>\n<p>MQ全称是Message Queue.可以理解为消息队列的意思.简单的说就是消息以<br>管道的方式进行传递</p>\n<p>RabbitMQ是一个实现了AMQP(Advanced Message Queuing Protocol)<br>高级消息队列协议的消息队列服务,用Erlang语音写成.</p>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>在我们秒杀抢购商品的时候,系统会提醒我们稍等排队中,而不是像几年前一样<br>页面卡死或报错给用户.</p>\n<p>像这种排队结算就是用到了消息队列机制,放入通道里面一个一个结算处理,而不<br>是某个时间段突然涌入大批量的查询新增把数据库给搞宕机.所以RabbitMQ本质<br>上起到的作用就是削峰填谷,为业务保驾护航.</p>\n<h2 id=\"为什么选择RabbitMQ\"><a href=\"#为什么选择RabbitMQ\" class=\"headerlink\" title=\"为什么选择RabbitMQ\"></a>为什么选择RabbitMQ</h2><p>现在市面上有很多MQ可以选择,比如ActiveMQ ZeroMQ Appche Qpid,那问<br>题来了为啥要选择RabbitMQ?</p>\n<p>1: 除了Qpid,RabbitMQ是唯一一个实现了AMQP标准的消息服务器;<br>2: 可靠性,RabbitMQ的持久化支持,保证了消息的稳定性;<br>3: 高并发,RabbitMQ使用了Erlang开发语言,Erlang是为电话交换机开发的语言,<br>天生自带高并发光环,和高可用特性;<br>4: 集群部署简单,正是因为Erlang使得RabbitMQ集群部署变得超级简单;<br>5: 社区活跃度高,根据网上资料来看,RabbitMQ也是首选;</p>\n<h2 id=\"工作机制\"><a href=\"#工作机制\" class=\"headerlink\" title=\"工作机制\"></a>工作机制</h2><h3 id=\"生产者-消费者和代理\"><a href=\"#生产者-消费者和代理\" class=\"headerlink\" title=\"生产者 消费者和代理\"></a>生产者 消费者和代理</h3><p>在了解消息通讯之前首先要了解3个概念:生产者 消费者和代理.</p>\n<p>生产者:消息的创建者,负责创建和推送数据到消息服务器;</p>\n<p>消费者:消息的接收方,用于处理数据和确认消息;</p>\n<p>代理者:就是RabbitMQ本身,用于扮演”快递”的角色,本身不生产消息,<br>只是扮演”快递”的角色.</p>\n<h3 id=\"消息发送原理\"><a href=\"#消息发送原理\" class=\"headerlink\" title=\"消息发送原理\"></a>消息发送原理</h3><p>首先你必须连接到Rabbit才能发布和消费消息,那怎么连接和发送消息呢?</p>\n<p>你的应用程序和Rabbit Server之间会创建一个TCP连接,一旦TCP打开,<br>并通过认证,认证就是你试图连接Rabbit之前发送的Rabbit服务器连接<br>信息和用户名和密码,有点像程序连接数据库,使用Java有两种连接认证<br>的方式,后面代码会详细介绍,一旦认证通过你的应用程序和Rabbit就创建<br>了一条AMQP信道(Channel).</p>\n<p>信道是创建在”真实”TCP上的虚拟连接,AMQP命令都是通过信道发送出去的,<br>每个信道都会有唯一的ID,不论是发布消息,订阅队列或者介绍消息都是通过<br>信道完成的.</p>\n<h3 id=\"为什么不通过TCP直接发送命令\"><a href=\"#为什么不通过TCP直接发送命令\" class=\"headerlink\" title=\"为什么不通过TCP直接发送命令?\"></a>为什么不通过TCP直接发送命令?</h3><p>对于操作系统来说创建和销毁TCP会话是非常昂贵的开销,假设高峰期每秒<br>有成千上万条连接,每个连接都要创建一条TCP会话,这就造成了TCP连接的<br>巨大浪费,而且操作系统每秒能创建的TCP也是有限的,因此很快就会遇到系统<br>瓶颈.</p>\n<p>如果我们每个请求都使用一条TCP连接,既满足了性能的需要,又能确保每个<br>连接的私密性,这就是引入信道概念的原因.</p>\n<h2 id=\"你必须知道的RabbitMQ\"><a href=\"#你必须知道的RabbitMQ\" class=\"headerlink\" title=\"你必须知道的RabbitMQ\"></a>你必须知道的RabbitMQ</h2><p>想要真正的了解Rabbit有些名词是你必须知道的.</p>\n<p>包括:ConnectionFactory(连接管理器) Channel(信道)<br>Exchange(交换器) Queue(队列) RoutingKey(路由键)<br>BindingKey(绑定键)</p>\n<p>ConnectionFactory(连接管理器): 应用程序与Rabbit之间<br>建立连接的管理器,程序代码中使用;</p>\n<p>Channel(信道) :消息推送使用的通道;</p>\n<p>Exchange(交换器) :用于接受 分配消息;</p>\n<p>Queue(队列): 用于存储生产者的消息;</p>\n<p>RoutingKey(路由键): 用于把生成者的数据分配到交换器上;</p>\n<p>bingdingKey(绑定键): 用于把交换器的消息绑带到队列上;</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_gif/WwPkUCFX4x6A5PeoEjBet8tpwnyOsaoWhdsqr2n1dLrSfJlaofbVayxUTemicQlbFmiaEHUMY83AIOsIXTaNicPwQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1\" alt=\"示例图片\"></p>\n<h2 id=\"消息持久化\"><a href=\"#消息持久化\" class=\"headerlink\" title=\"消息持久化\"></a>消息持久化</h2><p>Rabbit队列和交换器有一个不可告人的秘密,就是默认情况下重启<br>服务器会导致消息丢失,那么怎么保证Rabbit在重启的时候不丢失呢?<br>答案就是消息持久化.</p>\n<p>当你把消息发送到Rabbit服务器的时候,你需要选择你是否要进行持久化,但这并<br>不能保证Rabbit能重崩溃中恢复,想要Rabbit消息能恢复必须要满足3个条件:</p>\n<p>投递消息的时候durable设置为true,消息持久化;</p>\n<p>消息已经到达持久化交换器上;</p>\n<p>消息已经到达持久化的队列;</p>\n<h3 id=\"持久化工作原理\"><a href=\"#持久化工作原理\" class=\"headerlink\" title=\"持久化工作原理\"></a>持久化工作原理</h3><p>Rabbit会将你的持久化消息写入磁盘上的持久化日志文件,等消息被消费后,Rabbit<br>会把这条消息标识为等待垃圾回收.</p>\n<h3 id=\"持久化的缺点\"><a href=\"#持久化的缺点\" class=\"headerlink\" title=\"持久化的缺点\"></a>持久化的缺点</h3><p>消息持久化的优点显而易见,但缺点也很明显,那就是性能,因为要写入硬盘要比<br>写入内存性能低很多,从而降低了服务器的吞吐量,尽管使用SSD硬盘可以使事情<br>得到缓解,但他仍然吸干了Rabbit的性能,当消息成千上万条要写入磁盘的时候<br>,性能是很低的.</p>\n<p>所以使用者要根据自己的的情况,选择适合自己的方式.</p>\n<h2 id=\"虚拟主机\"><a href=\"#虚拟主机\" class=\"headerlink\" title=\"虚拟主机\"></a>虚拟主机</h2><p>每个Rabbit都能创建很多vhost,我们称之为虚拟主机,每个虚拟主机其实都是<br>mini版的RabbitMQ,拥有自己的队列,交换器和绑定,拥有自己的权限机制.</p>\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><p>如果你是在Windows10上去安装那就更简单了，先放下载地址：</p>\n<p>Erlang/Rabbit Server百度网盘链接：<a href=\"https://pan.baidu.com/s/1TnKDV-ZuXLiIgyK8c8f9dg\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1TnKDV-ZuXLiIgyK8c8f9dg</a> 密码：wct9</p>\n<p>当然也可去Erlang和Rabbit官网去下，就是速度比较慢。我的百度云Rabbit最新版本：3.7.6，Erlang版本：20.2，注意：不要下载最新的Erlang，在Windows10上打开扩展插件有问题，打不开。</p>\n<p>1.安装Erlang；</p>\n<p>2.安装Rabbit Server；</p>\n<p>3.进入安装目录sbin下，使用命令“rabbitmq-plugins enable                                     rabbitmq_management”启动网页管理插件；</p>\n<p>4.重启Rabbit服务；</p>\n<p>使用：<a href=\"http://localhost:15672进行测试，默认的登陆账号为：guest，密码为：guest\" target=\"_blank\" rel=\"noopener\">http://localhost:15672进行测试，默认的登陆账号为：guest，密码为：guest</a></p>\n<h2 id=\"重复安装Rabbit-Server的坑\"><a href=\"#重复安装Rabbit-Server的坑\" class=\"headerlink\" title=\"重复安装Rabbit Server的坑\"></a>重复安装Rabbit Server的坑</h2><p>如果不是第一次在Windows上安装Rabbit Server一定要把Rabbit和Erlang卸载干净<br>之后，找到注册表：HKEY_LOCAL_MACHINESOFTWAREEricssonErlangErlSrv 删除<br>其下的所有项。</p>\n<p>不然会出现Rabbit安装之后启动不了的情况，理论上卸载的顺序也是先Rabbit在Erlang。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>java版实现,使用maven项目.</p>\n<p>项目创建成功之后,添加Rabbit Client jar包,只需要在pom.xml里面配置,如下信息:</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;\n    &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;\n    &lt;version&gt;4.7.0&lt;/version&gt;\n&lt;/dependency&gt;</code></pre><p>java实现代码分为两个类,第一个是创建Rabbit连接,第二是应用类使用最简单的方式<br>发布和消费消息.</p>\n<h3 id=\"Rabbit的连接-两种方式\"><a href=\"#Rabbit的连接-两种方式\" class=\"headerlink\" title=\"Rabbit的连接,两种方式:\"></a>Rabbit的连接,两种方式:</h3><p>方式一:</p>\n<pre><code>public static Connection GetRabbitConnection() {\n    ConnectionFactory factory = new ConnectionFactory();\n    factory.setUsername(Config.UserName);\n    factory.setPassword(Config.Password);\n    factory.setVirtualHost(Config.VHost);\n    factory.setHost(Config.Host);\n    factory.setPort(Config.Port);\n    Connection conn = null;\n    try {\n        conn = factory.newConnection();\n    } catch (Exception e) {\n        e.printStackTrace(); \n    } \n\n    return conn;\n}</code></pre><p>方式二:</p>\n<pre><code>public static Connection GetRabbitConnection() {\n    ConnectionFactory factory = new ConnectionFactory();\n\n    // 连接格式：amqp://userName:password@hostName:portNumber/virtualHost\n    String uri = String.format(\n            &quot;amqp://%s:%s@%s:%d%s&quot;, \n            Config.UserName, \n            Config.Password,\n            Config.Host, \n            Config.Port,\n            Config.VHost);\n    Connection conn = null;\n    try {\n        factory.setUri(uri);\n        factory.setVirtualHost(Config.VHost);\n        conn = factory.newConnection();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }                \n    return conn;\n}</code></pre><h3 id=\"第二部分-应用类-使用最简单的方式发布和消费消息\"><a href=\"#第二部分-应用类-使用最简单的方式发布和消费消息\" class=\"headerlink\" title=\"第二部分: 应用类,使用最简单的方式发布和消费消息\"></a>第二部分: 应用类,使用最简单的方式发布和消费消息</h3><pre><code>public static void main(String[] args) {\n    Publisher(); // 推送消息\n\n    Consumer(); // 消费消息\n}\n\n/**\n* 推送消息\n*/\npublic static void Publisher() {\n    // 创建一个连接\n    Connection conn = ConnectionFactoryUtil.GetRabbitConnection();\n    if (conn != null) {\n        try{\n            // 创建通道\n            Channel channel = conn.createChannel();\n            // 声明队列【参数说明：参数一：队列名称，参数二：是否持久化；参数三：是否独占模式；参数四：消费者断开连接时是否删除队列；参数五：消息其他参数】\n            channel.queueDeclare(Config.QueueName, false, false, false, null);\n            String content = \n                String.format(&quot;当前时间: %s&quot;,new Date().getTime());\n            // 发送内容【参数说明：参数一：交换机名称；参数二：队列名称，参数三：消息的其他属性；参数四：消息主体】\n            channel.basicPublish(&quot;&quot;, Config.QueueName, null, content.getBytes(&quot;UTF-8&quot;));\n            System.out.println(&quot;已发送消息：&quot; + content);\n            // 关闭连接\n            channel.close();\n            conn.close();\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    } \n}\n\n/**\n* 消费消息\n*/\npublic static void Consumer() {\n    // 创建一个连接\n    Connection conn = ConnectionFactoryUtil.GetRabbitConnection();\n    if(conn != null) {\n        try {\n            // 创建通道\n            Channel channel = conn.createChannel();\n            // 声明队列[参数说明:1:队列名称,2:是否持久化,3:是否独占模式,4:消费者断开连接时是否删除队列,5:消息其他参数]\n            channel.queueDelare(Config.QueueName,false,false,false,null);\n\n            //创建订阅器,并接受消息\n            channel.basicConsume(Config.QueueName,false,&quot;&quot;,new DefaultConsumer(channel) {\n                @Overrride\n                public void handleDelivery(\n                    String consumerTag,\n                    Envelope envelope,\n                    AMQP.BasicPropeties properties,\n                    byte[] body) throws IOException {\n                    String routingKey = envelope.getRoutingkey(); // 队列名称\n                    String contentType = properties.getContentType(); // 内容类型\n                    String content = new String(body,&quot;utf-8&quot;); // 消息正文\n                    System.out.println(&quot;消息正文:&quot; + content);\n                    channel.basicAck(envelope.getDeliveryTag(),false); // 手动确认消息(参数1:该消息的index;2:是否批量应答,true批量确认小于index的消息)\n                }\n\n            });\n\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre><p>代码里面已经写了很详细的注释，在这里也不过多的介绍了。</p>\n<p>执行效果，如图：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/WwPkUCFX4x6A5PeoEjBet8tpwnyOsaoWtlqQAptMtgjn6YQXj1cJxNGyc0puMV6EVf1dwtNhCzjDqfj85XCsibA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1\" alt=\"示例图片\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"引用-https-mp-weixin-qq-com-s-ryu-zD3U62m32BZdByNxng-http-www-cnblogs-com-vipstone\"><a href=\"#引用-https-mp-weixin-qq-com-s-ryu-zD3U62m32BZdByNxng-http-www-cnblogs-com-vipstone\" class=\"headerlink\" title=\"引用: https://mp.weixin.qq.com/s/ryu-zD3U62m32BZdByNxng http://www.cnblogs.com/vipstone/\"></a>引用: <a href=\"https://mp.weixin.qq.com/s/ryu-zD3U62m32BZdByNxng\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/ryu-zD3U62m32BZdByNxng</a> <a href=\"http://www.cnblogs.com/vipstone/\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/vipstone/</a></h2><h2 id=\"RabbitMQ简介\"><a href=\"#RabbitMQ简介\" class=\"headerlink\" title=\"RabbitMQ简介\"></a>RabbitMQ简介</h2><p>在介绍RabbitMQ之前首先介绍一下MQ ,MQ是什么?</p>\n<p>MQ全称是Message Queue.可以理解为消息队列的意思.简单的说就是消息以<br>管道的方式进行传递</p>\n<p>RabbitMQ是一个实现了AMQP(Advanced Message Queuing Protocol)<br>高级消息队列协议的消息队列服务,用Erlang语音写成.</p>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>在我们秒杀抢购商品的时候,系统会提醒我们稍等排队中,而不是像几年前一样<br>页面卡死或报错给用户.</p>\n<p>像这种排队结算就是用到了消息队列机制,放入通道里面一个一个结算处理,而不<br>是某个时间段突然涌入大批量的查询新增把数据库给搞宕机.所以RabbitMQ本质<br>上起到的作用就是削峰填谷,为业务保驾护航.</p>\n<h2 id=\"为什么选择RabbitMQ\"><a href=\"#为什么选择RabbitMQ\" class=\"headerlink\" title=\"为什么选择RabbitMQ\"></a>为什么选择RabbitMQ</h2><p>现在市面上有很多MQ可以选择,比如ActiveMQ ZeroMQ Appche Qpid,那问<br>题来了为啥要选择RabbitMQ?</p>\n<p>1: 除了Qpid,RabbitMQ是唯一一个实现了AMQP标准的消息服务器;<br>2: 可靠性,RabbitMQ的持久化支持,保证了消息的稳定性;<br>3: 高并发,RabbitMQ使用了Erlang开发语言,Erlang是为电话交换机开发的语言,<br>天生自带高并发光环,和高可用特性;<br>4: 集群部署简单,正是因为Erlang使得RabbitMQ集群部署变得超级简单;<br>5: 社区活跃度高,根据网上资料来看,RabbitMQ也是首选;</p>\n<h2 id=\"工作机制\"><a href=\"#工作机制\" class=\"headerlink\" title=\"工作机制\"></a>工作机制</h2><h3 id=\"生产者-消费者和代理\"><a href=\"#生产者-消费者和代理\" class=\"headerlink\" title=\"生产者 消费者和代理\"></a>生产者 消费者和代理</h3><p>在了解消息通讯之前首先要了解3个概念:生产者 消费者和代理.</p>\n<p>生产者:消息的创建者,负责创建和推送数据到消息服务器;</p>\n<p>消费者:消息的接收方,用于处理数据和确认消息;</p>\n<p>代理者:就是RabbitMQ本身,用于扮演”快递”的角色,本身不生产消息,<br>只是扮演”快递”的角色.</p>\n<h3 id=\"消息发送原理\"><a href=\"#消息发送原理\" class=\"headerlink\" title=\"消息发送原理\"></a>消息发送原理</h3><p>首先你必须连接到Rabbit才能发布和消费消息,那怎么连接和发送消息呢?</p>\n<p>你的应用程序和Rabbit Server之间会创建一个TCP连接,一旦TCP打开,<br>并通过认证,认证就是你试图连接Rabbit之前发送的Rabbit服务器连接<br>信息和用户名和密码,有点像程序连接数据库,使用Java有两种连接认证<br>的方式,后面代码会详细介绍,一旦认证通过你的应用程序和Rabbit就创建<br>了一条AMQP信道(Channel).</p>\n<p>信道是创建在”真实”TCP上的虚拟连接,AMQP命令都是通过信道发送出去的,<br>每个信道都会有唯一的ID,不论是发布消息,订阅队列或者介绍消息都是通过<br>信道完成的.</p>\n<h3 id=\"为什么不通过TCP直接发送命令\"><a href=\"#为什么不通过TCP直接发送命令\" class=\"headerlink\" title=\"为什么不通过TCP直接发送命令?\"></a>为什么不通过TCP直接发送命令?</h3><p>对于操作系统来说创建和销毁TCP会话是非常昂贵的开销,假设高峰期每秒<br>有成千上万条连接,每个连接都要创建一条TCP会话,这就造成了TCP连接的<br>巨大浪费,而且操作系统每秒能创建的TCP也是有限的,因此很快就会遇到系统<br>瓶颈.</p>\n<p>如果我们每个请求都使用一条TCP连接,既满足了性能的需要,又能确保每个<br>连接的私密性,这就是引入信道概念的原因.</p>\n<h2 id=\"你必须知道的RabbitMQ\"><a href=\"#你必须知道的RabbitMQ\" class=\"headerlink\" title=\"你必须知道的RabbitMQ\"></a>你必须知道的RabbitMQ</h2><p>想要真正的了解Rabbit有些名词是你必须知道的.</p>\n<p>包括:ConnectionFactory(连接管理器) Channel(信道)<br>Exchange(交换器) Queue(队列) RoutingKey(路由键)<br>BindingKey(绑定键)</p>\n<p>ConnectionFactory(连接管理器): 应用程序与Rabbit之间<br>建立连接的管理器,程序代码中使用;</p>\n<p>Channel(信道) :消息推送使用的通道;</p>\n<p>Exchange(交换器) :用于接受 分配消息;</p>\n<p>Queue(队列): 用于存储生产者的消息;</p>\n<p>RoutingKey(路由键): 用于把生成者的数据分配到交换器上;</p>\n<p>bingdingKey(绑定键): 用于把交换器的消息绑带到队列上;</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_gif/WwPkUCFX4x6A5PeoEjBet8tpwnyOsaoWhdsqr2n1dLrSfJlaofbVayxUTemicQlbFmiaEHUMY83AIOsIXTaNicPwQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1\" alt=\"示例图片\"></p>\n<h2 id=\"消息持久化\"><a href=\"#消息持久化\" class=\"headerlink\" title=\"消息持久化\"></a>消息持久化</h2><p>Rabbit队列和交换器有一个不可告人的秘密,就是默认情况下重启<br>服务器会导致消息丢失,那么怎么保证Rabbit在重启的时候不丢失呢?<br>答案就是消息持久化.</p>\n<p>当你把消息发送到Rabbit服务器的时候,你需要选择你是否要进行持久化,但这并<br>不能保证Rabbit能重崩溃中恢复,想要Rabbit消息能恢复必须要满足3个条件:</p>\n<p>投递消息的时候durable设置为true,消息持久化;</p>\n<p>消息已经到达持久化交换器上;</p>\n<p>消息已经到达持久化的队列;</p>\n<h3 id=\"持久化工作原理\"><a href=\"#持久化工作原理\" class=\"headerlink\" title=\"持久化工作原理\"></a>持久化工作原理</h3><p>Rabbit会将你的持久化消息写入磁盘上的持久化日志文件,等消息被消费后,Rabbit<br>会把这条消息标识为等待垃圾回收.</p>\n<h3 id=\"持久化的缺点\"><a href=\"#持久化的缺点\" class=\"headerlink\" title=\"持久化的缺点\"></a>持久化的缺点</h3><p>消息持久化的优点显而易见,但缺点也很明显,那就是性能,因为要写入硬盘要比<br>写入内存性能低很多,从而降低了服务器的吞吐量,尽管使用SSD硬盘可以使事情<br>得到缓解,但他仍然吸干了Rabbit的性能,当消息成千上万条要写入磁盘的时候<br>,性能是很低的.</p>\n<p>所以使用者要根据自己的的情况,选择适合自己的方式.</p>\n<h2 id=\"虚拟主机\"><a href=\"#虚拟主机\" class=\"headerlink\" title=\"虚拟主机\"></a>虚拟主机</h2><p>每个Rabbit都能创建很多vhost,我们称之为虚拟主机,每个虚拟主机其实都是<br>mini版的RabbitMQ,拥有自己的队列,交换器和绑定,拥有自己的权限机制.</p>\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><p>如果你是在Windows10上去安装那就更简单了，先放下载地址：</p>\n<p>Erlang/Rabbit Server百度网盘链接：<a href=\"https://pan.baidu.com/s/1TnKDV-ZuXLiIgyK8c8f9dg\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1TnKDV-ZuXLiIgyK8c8f9dg</a> 密码：wct9</p>\n<p>当然也可去Erlang和Rabbit官网去下，就是速度比较慢。我的百度云Rabbit最新版本：3.7.6，Erlang版本：20.2，注意：不要下载最新的Erlang，在Windows10上打开扩展插件有问题，打不开。</p>\n<p>1.安装Erlang；</p>\n<p>2.安装Rabbit Server；</p>\n<p>3.进入安装目录sbin下，使用命令“rabbitmq-plugins enable                                     rabbitmq_management”启动网页管理插件；</p>\n<p>4.重启Rabbit服务；</p>\n<p>使用：<a href=\"http://localhost:15672进行测试，默认的登陆账号为：guest，密码为：guest\" target=\"_blank\" rel=\"noopener\">http://localhost:15672进行测试，默认的登陆账号为：guest，密码为：guest</a></p>\n<h2 id=\"重复安装Rabbit-Server的坑\"><a href=\"#重复安装Rabbit-Server的坑\" class=\"headerlink\" title=\"重复安装Rabbit Server的坑\"></a>重复安装Rabbit Server的坑</h2><p>如果不是第一次在Windows上安装Rabbit Server一定要把Rabbit和Erlang卸载干净<br>之后，找到注册表：HKEY_LOCAL_MACHINESOFTWAREEricssonErlangErlSrv 删除<br>其下的所有项。</p>\n<p>不然会出现Rabbit安装之后启动不了的情况，理论上卸载的顺序也是先Rabbit在Erlang。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>java版实现,使用maven项目.</p>\n<p>项目创建成功之后,添加Rabbit Client jar包,只需要在pom.xml里面配置,如下信息:</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;\n    &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;\n    &lt;version&gt;4.7.0&lt;/version&gt;\n&lt;/dependency&gt;</code></pre><p>java实现代码分为两个类,第一个是创建Rabbit连接,第二是应用类使用最简单的方式<br>发布和消费消息.</p>\n<h3 id=\"Rabbit的连接-两种方式\"><a href=\"#Rabbit的连接-两种方式\" class=\"headerlink\" title=\"Rabbit的连接,两种方式:\"></a>Rabbit的连接,两种方式:</h3><p>方式一:</p>\n<pre><code>public static Connection GetRabbitConnection() {\n    ConnectionFactory factory = new ConnectionFactory();\n    factory.setUsername(Config.UserName);\n    factory.setPassword(Config.Password);\n    factory.setVirtualHost(Config.VHost);\n    factory.setHost(Config.Host);\n    factory.setPort(Config.Port);\n    Connection conn = null;\n    try {\n        conn = factory.newConnection();\n    } catch (Exception e) {\n        e.printStackTrace(); \n    } \n\n    return conn;\n}</code></pre><p>方式二:</p>\n<pre><code>public static Connection GetRabbitConnection() {\n    ConnectionFactory factory = new ConnectionFactory();\n\n    // 连接格式：amqp://userName:password@hostName:portNumber/virtualHost\n    String uri = String.format(\n            &quot;amqp://%s:%s@%s:%d%s&quot;, \n            Config.UserName, \n            Config.Password,\n            Config.Host, \n            Config.Port,\n            Config.VHost);\n    Connection conn = null;\n    try {\n        factory.setUri(uri);\n        factory.setVirtualHost(Config.VHost);\n        conn = factory.newConnection();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }                \n    return conn;\n}</code></pre><h3 id=\"第二部分-应用类-使用最简单的方式发布和消费消息\"><a href=\"#第二部分-应用类-使用最简单的方式发布和消费消息\" class=\"headerlink\" title=\"第二部分: 应用类,使用最简单的方式发布和消费消息\"></a>第二部分: 应用类,使用最简单的方式发布和消费消息</h3><pre><code>public static void main(String[] args) {\n    Publisher(); // 推送消息\n\n    Consumer(); // 消费消息\n}\n\n/**\n* 推送消息\n*/\npublic static void Publisher() {\n    // 创建一个连接\n    Connection conn = ConnectionFactoryUtil.GetRabbitConnection();\n    if (conn != null) {\n        try{\n            // 创建通道\n            Channel channel = conn.createChannel();\n            // 声明队列【参数说明：参数一：队列名称，参数二：是否持久化；参数三：是否独占模式；参数四：消费者断开连接时是否删除队列；参数五：消息其他参数】\n            channel.queueDeclare(Config.QueueName, false, false, false, null);\n            String content = \n                String.format(&quot;当前时间: %s&quot;,new Date().getTime());\n            // 发送内容【参数说明：参数一：交换机名称；参数二：队列名称，参数三：消息的其他属性；参数四：消息主体】\n            channel.basicPublish(&quot;&quot;, Config.QueueName, null, content.getBytes(&quot;UTF-8&quot;));\n            System.out.println(&quot;已发送消息：&quot; + content);\n            // 关闭连接\n            channel.close();\n            conn.close();\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    } \n}\n\n/**\n* 消费消息\n*/\npublic static void Consumer() {\n    // 创建一个连接\n    Connection conn = ConnectionFactoryUtil.GetRabbitConnection();\n    if(conn != null) {\n        try {\n            // 创建通道\n            Channel channel = conn.createChannel();\n            // 声明队列[参数说明:1:队列名称,2:是否持久化,3:是否独占模式,4:消费者断开连接时是否删除队列,5:消息其他参数]\n            channel.queueDelare(Config.QueueName,false,false,false,null);\n\n            //创建订阅器,并接受消息\n            channel.basicConsume(Config.QueueName,false,&quot;&quot;,new DefaultConsumer(channel) {\n                @Overrride\n                public void handleDelivery(\n                    String consumerTag,\n                    Envelope envelope,\n                    AMQP.BasicPropeties properties,\n                    byte[] body) throws IOException {\n                    String routingKey = envelope.getRoutingkey(); // 队列名称\n                    String contentType = properties.getContentType(); // 内容类型\n                    String content = new String(body,&quot;utf-8&quot;); // 消息正文\n                    System.out.println(&quot;消息正文:&quot; + content);\n                    channel.basicAck(envelope.getDeliveryTag(),false); // 手动确认消息(参数1:该消息的index;2:是否批量应答,true批量确认小于index的消息)\n                }\n\n            });\n\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre><p>代码里面已经写了很详细的注释，在这里也不过多的介绍了。</p>\n<p>执行效果，如图：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/WwPkUCFX4x6A5PeoEjBet8tpwnyOsaoWtlqQAptMtgjn6YQXj1cJxNGyc0puMV6EVf1dwtNhCzjDqfj85XCsibA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1\" alt=\"示例图片\"></p>\n"},{"title":"猪宝起名记","date":"2019-05-31T09:37:50.000Z","_content":"\n接上篇<<猪宝历险记>>\n\n好吧孩子,这几天除了担心你,还在忙活着一件事给你取名.爸爸\n妈妈想了很多,在此一一记录.希望你长大后更能理解自己名字\n的由来.\n\n从怀孕开始爸妈就开始想你的名字\n\n* 卓恩\n\n这是第一个爸妈意向很大的名字,由来英文JUNE(六月)谐音而来\n你是六月来到的爸妈身边,即有此意.对了爸爸一开始想的是朱恩\n后来还是你二叔觉得卓恩好.爸爸也觉得这名字不错,可由于你一向\n喜欢韩国欧巴的妈妈觉得这名字有点韩流,就给否了.\n\n* 给予\n\n这是爸爸意向差不多最大的一个名字,有三重意思:1是希望你可以\n做个能帮助别人的人,2是谐音爸妈的家乡冀豫,3是希望你健健康康\n可思来想去还是怕以后小朋友叫不好你的名字老叫你gei yu!\n又给否了\n\n* 春风 小名小野\n\n出自野火烧不尽,春风吹又生!这名字是爸爸一厢情愿\n你妈特别反对,觉得老掉牙!可爸爸觉得挺好,朴素,辨识度高\n寓意也好,希望你以后坚韧,茁壮成长!一场春风一场暖,长大\n当个大暖男!当然咱们家你妈说了算.\n\n由于火爆当下的抖音,爸妈又刷出了几个名字\n* 予桐\n* 锦汐\n* 若凌\n都由于意向不大没有采纳.\n\n中途还有个搞笑的小名叫抖爆,解释为抖音爆款!\n\n言归正传,如何起个好名字?\n\n爸爸跟妈妈的理解为\n\n* 寓意好,(女诗经 男楚辞 文论语 武周易 )最好有点出处.\n\n* 响亮 郎朗上口.最好都为二声,或第一个字四声,第二个字二声.\n\n* 好写 不要生僻字,最好小学毕业的人都认知.\n\n* 独特 最好叫的人不多,名字毕竟是个IP.好多人都叫则辨识度太低.\n\n* 作为传统的中国人,还是希望跟五行八卦相配合的.\n\n\n\n* 出处:李白 侠客行 \n\n* 响亮:都为二声,跟咱这姓氏配合也算郎朗上口.\n\n* 好写:小学毕业肯定认识,笔画也不多.\n\n* 独特:好吧奶奶给你上社保的时候就有工作人员夸,说这名字好,之前没见过,爸爸不甘寂寞,上省公安厅查,全省独一份!\n\n* 跟你的八字五行还是比较配合的,网上测了一下99分.\n\n小名是你10岁的小叔叔起的.家里人一致认为这个名字好听,\n爸爸也觉得这名字干净,纯洁,有力量.\n\n中途也有人建议花钱找大师起名.爸爸不信这一套!爸爸认为孩子的\n名字最好是父母来起.因为没有人比父母对你的名字更上心.经过\n父母深思熟虑起的名字是最有力量的.这个是啥大师都比不了的.\n\n参考的资料有:\n\n* [给孩子起名字]( https://bookdown.org/baydap/papasdiary/kids-name.html)\n\n* [如何给孩子起名？](\nhttps://www.zhihu.com/question/20436604?sort=created\n)\n\n* [象形字典](\nhttp://www.vividict.com/WordInfo.aspx?id=2432\n)\n\n* [象形字典](\nhttp://www.vividict.com/WordInfo.aspx?id=908\n)\n\n\n\n","source":"_posts/猪宝取名记.md","raw":"---\ntitle: 猪宝起名记\ndate: 2019-05-31 17:37:50\ntags:\ncategories: \n- 生活\n---\n\n接上篇<<猪宝历险记>>\n\n好吧孩子,这几天除了担心你,还在忙活着一件事给你取名.爸爸\n妈妈想了很多,在此一一记录.希望你长大后更能理解自己名字\n的由来.\n\n从怀孕开始爸妈就开始想你的名字\n\n* 卓恩\n\n这是第一个爸妈意向很大的名字,由来英文JUNE(六月)谐音而来\n你是六月来到的爸妈身边,即有此意.对了爸爸一开始想的是朱恩\n后来还是你二叔觉得卓恩好.爸爸也觉得这名字不错,可由于你一向\n喜欢韩国欧巴的妈妈觉得这名字有点韩流,就给否了.\n\n* 给予\n\n这是爸爸意向差不多最大的一个名字,有三重意思:1是希望你可以\n做个能帮助别人的人,2是谐音爸妈的家乡冀豫,3是希望你健健康康\n可思来想去还是怕以后小朋友叫不好你的名字老叫你gei yu!\n又给否了\n\n* 春风 小名小野\n\n出自野火烧不尽,春风吹又生!这名字是爸爸一厢情愿\n你妈特别反对,觉得老掉牙!可爸爸觉得挺好,朴素,辨识度高\n寓意也好,希望你以后坚韧,茁壮成长!一场春风一场暖,长大\n当个大暖男!当然咱们家你妈说了算.\n\n由于火爆当下的抖音,爸妈又刷出了几个名字\n* 予桐\n* 锦汐\n* 若凌\n都由于意向不大没有采纳.\n\n中途还有个搞笑的小名叫抖爆,解释为抖音爆款!\n\n言归正传,如何起个好名字?\n\n爸爸跟妈妈的理解为\n\n* 寓意好,(女诗经 男楚辞 文论语 武周易 )最好有点出处.\n\n* 响亮 郎朗上口.最好都为二声,或第一个字四声,第二个字二声.\n\n* 好写 不要生僻字,最好小学毕业的人都认知.\n\n* 独特 最好叫的人不多,名字毕竟是个IP.好多人都叫则辨识度太低.\n\n* 作为传统的中国人,还是希望跟五行八卦相配合的.\n\n\n\n* 出处:李白 侠客行 \n\n* 响亮:都为二声,跟咱这姓氏配合也算郎朗上口.\n\n* 好写:小学毕业肯定认识,笔画也不多.\n\n* 独特:好吧奶奶给你上社保的时候就有工作人员夸,说这名字好,之前没见过,爸爸不甘寂寞,上省公安厅查,全省独一份!\n\n* 跟你的八字五行还是比较配合的,网上测了一下99分.\n\n小名是你10岁的小叔叔起的.家里人一致认为这个名字好听,\n爸爸也觉得这名字干净,纯洁,有力量.\n\n中途也有人建议花钱找大师起名.爸爸不信这一套!爸爸认为孩子的\n名字最好是父母来起.因为没有人比父母对你的名字更上心.经过\n父母深思熟虑起的名字是最有力量的.这个是啥大师都比不了的.\n\n参考的资料有:\n\n* [给孩子起名字]( https://bookdown.org/baydap/papasdiary/kids-name.html)\n\n* [如何给孩子起名？](\nhttps://www.zhihu.com/question/20436604?sort=created\n)\n\n* [象形字典](\nhttp://www.vividict.com/WordInfo.aspx?id=2432\n)\n\n* [象形字典](\nhttp://www.vividict.com/WordInfo.aspx?id=908\n)\n\n\n\n","slug":"猪宝取名记","published":1,"updated":"2019-09-27T08:27:08.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cedr0020ojfykcdp2v7i","content":"<p>接上篇&lt;&lt;猪宝历险记&gt;&gt;</p>\n<p>好吧孩子,这几天除了担心你,还在忙活着一件事给你取名.爸爸<br>妈妈想了很多,在此一一记录.希望你长大后更能理解自己名字<br>的由来.</p>\n<p>从怀孕开始爸妈就开始想你的名字</p>\n<ul>\n<li>卓恩</li>\n</ul>\n<p>这是第一个爸妈意向很大的名字,由来英文JUNE(六月)谐音而来<br>你是六月来到的爸妈身边,即有此意.对了爸爸一开始想的是朱恩<br>后来还是你二叔觉得卓恩好.爸爸也觉得这名字不错,可由于你一向<br>喜欢韩国欧巴的妈妈觉得这名字有点韩流,就给否了.</p>\n<ul>\n<li>给予</li>\n</ul>\n<p>这是爸爸意向差不多最大的一个名字,有三重意思:1是希望你可以<br>做个能帮助别人的人,2是谐音爸妈的家乡冀豫,3是希望你健健康康<br>可思来想去还是怕以后小朋友叫不好你的名字老叫你gei yu!<br>又给否了</p>\n<ul>\n<li>春风 小名小野</li>\n</ul>\n<p>出自野火烧不尽,春风吹又生!这名字是爸爸一厢情愿<br>你妈特别反对,觉得老掉牙!可爸爸觉得挺好,朴素,辨识度高<br>寓意也好,希望你以后坚韧,茁壮成长!一场春风一场暖,长大<br>当个大暖男!当然咱们家你妈说了算.</p>\n<p>由于火爆当下的抖音,爸妈又刷出了几个名字</p>\n<ul>\n<li>予桐</li>\n<li>锦汐</li>\n<li>若凌<br>都由于意向不大没有采纳.</li>\n</ul>\n<p>中途还有个搞笑的小名叫抖爆,解释为抖音爆款!</p>\n<p>言归正传,如何起个好名字?</p>\n<p>爸爸跟妈妈的理解为</p>\n<ul>\n<li><p>寓意好,(女诗经 男楚辞 文论语 武周易 )最好有点出处.</p>\n</li>\n<li><p>响亮 郎朗上口.最好都为二声,或第一个字四声,第二个字二声.</p>\n</li>\n<li><p>好写 不要生僻字,最好小学毕业的人都认知.</p>\n</li>\n<li><p>独特 最好叫的人不多,名字毕竟是个IP.好多人都叫则辨识度太低.</p>\n</li>\n<li><p>作为传统的中国人,还是希望跟五行八卦相配合的.</p>\n</li>\n</ul>\n<ul>\n<li><p>出处:李白 侠客行 </p>\n</li>\n<li><p>响亮:都为二声,跟咱这姓氏配合也算郎朗上口.</p>\n</li>\n<li><p>好写:小学毕业肯定认识,笔画也不多.</p>\n</li>\n<li><p>独特:好吧奶奶给你上社保的时候就有工作人员夸,说这名字好,之前没见过,爸爸不甘寂寞,上省公安厅查,全省独一份!</p>\n</li>\n<li><p>跟你的八字五行还是比较配合的,网上测了一下99分.</p>\n</li>\n</ul>\n<p>小名是你10岁的小叔叔起的.家里人一致认为这个名字好听,<br>爸爸也觉得这名字干净,纯洁,有力量.</p>\n<p>中途也有人建议花钱找大师起名.爸爸不信这一套!爸爸认为孩子的<br>名字最好是父母来起.因为没有人比父母对你的名字更上心.经过<br>父母深思熟虑起的名字是最有力量的.这个是啥大师都比不了的.</p>\n<p>参考的资料有:</p>\n<ul>\n<li><p><a href=\"https://bookdown.org/baydap/papasdiary/kids-name.html\" target=\"_blank\" rel=\"noopener\">给孩子起名字</a></p>\n</li>\n<li><p><a href=\"https://www.zhihu.com/question/20436604?sort=created\" target=\"_blank\" rel=\"noopener\">如何给孩子起名？</a></p>\n</li>\n<li><p><a href=\"http://www.vividict.com/WordInfo.aspx?id=2432\" target=\"_blank\" rel=\"noopener\">象形字典</a></p>\n</li>\n<li><p><a href=\"http://www.vividict.com/WordInfo.aspx?id=908\" target=\"_blank\" rel=\"noopener\">象形字典</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>接上篇&lt;&lt;猪宝历险记&gt;&gt;</p>\n<p>好吧孩子,这几天除了担心你,还在忙活着一件事给你取名.爸爸<br>妈妈想了很多,在此一一记录.希望你长大后更能理解自己名字<br>的由来.</p>\n<p>从怀孕开始爸妈就开始想你的名字</p>\n<ul>\n<li>卓恩</li>\n</ul>\n<p>这是第一个爸妈意向很大的名字,由来英文JUNE(六月)谐音而来<br>你是六月来到的爸妈身边,即有此意.对了爸爸一开始想的是朱恩<br>后来还是你二叔觉得卓恩好.爸爸也觉得这名字不错,可由于你一向<br>喜欢韩国欧巴的妈妈觉得这名字有点韩流,就给否了.</p>\n<ul>\n<li>给予</li>\n</ul>\n<p>这是爸爸意向差不多最大的一个名字,有三重意思:1是希望你可以<br>做个能帮助别人的人,2是谐音爸妈的家乡冀豫,3是希望你健健康康<br>可思来想去还是怕以后小朋友叫不好你的名字老叫你gei yu!<br>又给否了</p>\n<ul>\n<li>春风 小名小野</li>\n</ul>\n<p>出自野火烧不尽,春风吹又生!这名字是爸爸一厢情愿<br>你妈特别反对,觉得老掉牙!可爸爸觉得挺好,朴素,辨识度高<br>寓意也好,希望你以后坚韧,茁壮成长!一场春风一场暖,长大<br>当个大暖男!当然咱们家你妈说了算.</p>\n<p>由于火爆当下的抖音,爸妈又刷出了几个名字</p>\n<ul>\n<li>予桐</li>\n<li>锦汐</li>\n<li>若凌<br>都由于意向不大没有采纳.</li>\n</ul>\n<p>中途还有个搞笑的小名叫抖爆,解释为抖音爆款!</p>\n<p>言归正传,如何起个好名字?</p>\n<p>爸爸跟妈妈的理解为</p>\n<ul>\n<li><p>寓意好,(女诗经 男楚辞 文论语 武周易 )最好有点出处.</p>\n</li>\n<li><p>响亮 郎朗上口.最好都为二声,或第一个字四声,第二个字二声.</p>\n</li>\n<li><p>好写 不要生僻字,最好小学毕业的人都认知.</p>\n</li>\n<li><p>独特 最好叫的人不多,名字毕竟是个IP.好多人都叫则辨识度太低.</p>\n</li>\n<li><p>作为传统的中国人,还是希望跟五行八卦相配合的.</p>\n</li>\n</ul>\n<ul>\n<li><p>出处:李白 侠客行 </p>\n</li>\n<li><p>响亮:都为二声,跟咱这姓氏配合也算郎朗上口.</p>\n</li>\n<li><p>好写:小学毕业肯定认识,笔画也不多.</p>\n</li>\n<li><p>独特:好吧奶奶给你上社保的时候就有工作人员夸,说这名字好,之前没见过,爸爸不甘寂寞,上省公安厅查,全省独一份!</p>\n</li>\n<li><p>跟你的八字五行还是比较配合的,网上测了一下99分.</p>\n</li>\n</ul>\n<p>小名是你10岁的小叔叔起的.家里人一致认为这个名字好听,<br>爸爸也觉得这名字干净,纯洁,有力量.</p>\n<p>中途也有人建议花钱找大师起名.爸爸不信这一套!爸爸认为孩子的<br>名字最好是父母来起.因为没有人比父母对你的名字更上心.经过<br>父母深思熟虑起的名字是最有力量的.这个是啥大师都比不了的.</p>\n<p>参考的资料有:</p>\n<ul>\n<li><p><a href=\"https://bookdown.org/baydap/papasdiary/kids-name.html\" target=\"_blank\" rel=\"noopener\">给孩子起名字</a></p>\n</li>\n<li><p><a href=\"https://www.zhihu.com/question/20436604?sort=created\" target=\"_blank\" rel=\"noopener\">如何给孩子起名？</a></p>\n</li>\n<li><p><a href=\"http://www.vividict.com/WordInfo.aspx?id=2432\" target=\"_blank\" rel=\"noopener\">象形字典</a></p>\n</li>\n<li><p><a href=\"http://www.vividict.com/WordInfo.aspx?id=908\" target=\"_blank\" rel=\"noopener\">象形字典</a></p>\n</li>\n</ul>\n"},{"title":"设计模式之Builder模式  ","date":"2019-09-19T10:24:08.000Z","_content":"","source":"_posts/设计模式之Builder模式.md","raw":"---\ntitle: '设计模式之Builder模式  '\ndate: 2019-09-19 18:24:08\ntags:\ncategories:\n---\n","slug":"设计模式之Builder模式","published":1,"updated":"2019-09-27T08:27:08.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139ceds0021ojfyv4fk90xn","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"读《活着》有感","date":"2019-09-06T02:05:22.000Z","_content":"\n![](下载.jpeg)\n\n* 余华文笔真好,很有代入感\n\n* 富贵就是那个时代的缩影\n\n* 选择比努力重要\n\n* 人首先要尊重自己!\n\n* 凡事多替自己想想,富贵儿子死的真冤!\n\n* 珍惜今天吧    \n\n\n\n","source":"_posts/读-活着-有感.md","raw":"---\ntitle: 读《活着》有感\ndate: 2019-09-06 10:05:22\ntags: [读后感]\ncategories: [读书]\n---\n\n![](下载.jpeg)\n\n* 余华文笔真好,很有代入感\n\n* 富贵就是那个时代的缩影\n\n* 选择比努力重要\n\n* 人首先要尊重自己!\n\n* 凡事多替自己想想,富贵儿子死的真冤!\n\n* 珍惜今天吧    \n\n\n\n","slug":"读-活着-有感","published":1,"updated":"2019-09-27T08:27:08.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139ceds0022ojfy98t118kd","content":"<p><img src=\"%E4%B8%8B%E8%BD%BD.jpeg\" alt></p>\n<ul>\n<li><p>余华文笔真好,很有代入感</p>\n</li>\n<li><p>富贵就是那个时代的缩影</p>\n</li>\n<li><p>选择比努力重要</p>\n</li>\n<li><p>人首先要尊重自己!</p>\n</li>\n<li><p>凡事多替自己想想,富贵儿子死的真冤!</p>\n</li>\n<li><p>珍惜今天吧    </p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"%E4%B8%8B%E8%BD%BD.jpeg\" alt></p>\n<ul>\n<li><p>余华文笔真好,很有代入感</p>\n</li>\n<li><p>富贵就是那个时代的缩影</p>\n</li>\n<li><p>选择比努力重要</p>\n</li>\n<li><p>人首先要尊重自己!</p>\n</li>\n<li><p>凡事多替自己想想,富贵儿子死的真冤!</p>\n</li>\n<li><p>珍惜今天吧    </p>\n</li>\n</ul>\n"},{"title":"过年请假","date":"2019-02-13T09:15:57.000Z","_content":"\n\n    年关将至，抢票不易!然小禾佑我，得票一张。\n    忧喜交集,喜与孕妻朝欢暮,又忧公司业务急!\n    遂背Mac,随时call我!\n    恭祝:新春吉祥如意，事事顺达，阖家幸福。\n    \n\n    ","source":"_posts/过年请假.md","raw":"---\ntitle: 过年请假\ndate: 2019-02-13 17:15:57\ntags:\ncategories: \n- 生活\n---\n\n\n    年关将至，抢票不易!然小禾佑我，得票一张。\n    忧喜交集,喜与孕妻朝欢暮,又忧公司业务急!\n    遂背Mac,随时call我!\n    恭祝:新春吉祥如意，事事顺达，阖家幸福。\n    \n\n    ","slug":"过年请假","published":1,"updated":"2019-09-27T08:27:08.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139ceds0023ojfy9o1mo6ua","content":"<pre><code>年关将至，抢票不易!然小禾佑我，得票一张。\n忧喜交集,喜与孕妻朝欢暮,又忧公司业务急!\n遂背Mac,随时call我!\n恭祝:新春吉祥如意，事事顺达，阖家幸福。</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre><code>年关将至，抢票不易!然小禾佑我，得票一张。\n忧喜交集,喜与孕妻朝欢暮,又忧公司业务急!\n遂背Mac,随时call我!\n恭祝:新春吉祥如意，事事顺达，阖家幸福。</code></pre>"},{"title":"node.js教程","date":"2019-08-26T06:08:08.000Z","_content":"\n# 简介\n* 简单的说 Node.js 就是运行在服务端的 JavaScript。\n  \n* Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。\n  \n* Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。\n  \n## 查看版本\n    \n    node -v\n    v12.9.0\n\n## Hello World\n   \n   vim helloWorld.js\n   \n   console.log(\"Hello World\");\n   \n   node helloWorld.js\n   \n## 交互模式\n\n    $ node\n    > console.log('Hello World!');\n    Hello World!\n    \n# Node.js 安装配置\n\n    Mac安装\n    brew install node\n\n# Node.js 创建第一个应用\n    \n## 步骤一、引入 required 模块\n\n我们使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下:\n\n    var http = require(\"http\");\n    \n## 步骤二、创建服务器\n接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。\n\n实例如下，在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：\n\n    var http = require('http');\n    http.createServer(function (request, response) {\n    \n        // 发送 HTTP 头部 \n        // HTTP 状态值: 200 : OK\n        // 内容类型: text/plain\n        response.writeHead(200, {'Content-Type': 'text/plain'});\n    \n        // 发送响应数据 \"Hello World\"\n        response.end('Hello World\\n');\n    }).listen(8888);\n    \n    // 终端打印如下信息\n    console.log('Server running at http://127.0.0.1:8888/');\n\n以上代码我们完成了一个可以工作的 HTTP 服务器。\n\n使用 node 命令执行以上的代码：\n\n    node server.js\n    Server running at http://127.0.0.1:8888/\n\n接下来，打开浏览器访问 http://127.0.0.1:8888/，你会看到一个写着 \"Hello World\"的网页。\n\n## 分析Node.js 的 HTTP 服务器：\n   \n* 第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。\n\n* 接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。\n\n\n# NPM 使用介绍\n\nNPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：\n\n* 允许用户从NPM服务器下载别人编写的第三方包到本地使用。\n\n* 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。\n\n* 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。\n\n## 查看版本\n\n    $ npm -v\n    6.10.3\n\n## 升级\n\n    $ sudo npm install npm -g\n\n如果是 Window 系统使用以下命令即可：\n\n    npm install npm -g\n使用淘宝镜像的命令：\n\n    npm install -g cnpm --registry=https://registry.npm.taobao.org\n    \n## 使用 npm 命令安装模块\nnpm 安装 Node.js 模块语法格式如下：\n\n    $ npm install <Module Name>\n以下实例，我们使用 npm 命令安装常用的 Node.js web框架模块 express:\n\n    $ npm install express\n安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 require('express') 的方式就好，无需指定第三方包路径。\n\n    var express = require('express');\n    \n## 全局安装与本地安装\nnpm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，比如\n\n    npm install express          # 本地安装\n    npm install express -g   # 全局安装\n\n如果出现以下错误：\n\n    npm err! Error: connect ECONNREFUSED 127.0.0.1:8087 \n    \n解决办法为：\n\n    $ npm config set proxy null\n\n## 本地安装\n\n* 1.将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。\n\n* 2.可以通过 require() 来引入本地安装的包。\n\n## 全局安装\n\n* 1.将安装包放在 /usr/local 下或者你 node 的安装目录。\n* 2.可以直接在命令行里使用。\n\n如果你希望具备两者功能，则需要在两个地方安装它或使用 npm link。\n接下来我们使用全局方式安装 express\n\n    $ npm install express -g\n\n## 查看安装信息\n\n你可以使用以下命令来查看所有全局安装的模块：\n    \n    $ npm list -g\n    \n    ├─┬ cnpm@4.3.2\n    │ ├── auto-correct@1.0.0\n    │ ├── bagpipe@0.3.5\n    │ ├── colors@1.1.2\n    │ ├─┬ commander@2.9.0\n    │ │ └── graceful-readlink@1.0.1\n    │ ├─┬ cross-spawn@0.2.9\n    │ │ └── lru-cache@2.7.3\n    ……\n\n如果要查看某个模块的版本号，可以使用命令如下：\n\n    $ npm list grunt\n    \n    projectName@projectVersion /path/to/project/folder\n    └── grunt@0.4.1\n    \n## 使用 package.json\npackage.json 位于模块的目录下，用于定义包的属性。接下来让我们来看下 express 包的 package.json 文件，位于 node_modules/express/package.json 内容：\n\n## Package.json 属性说明\n\n    name - 包名。\n    \n    version - 包的版本号。\n    \n    description - 包的描述。\n    \n    homepage - 包的官网 url 。\n    \n    author - 包的作者姓名。\n    \n    contributors - 包的其他贡献者姓名。\n    \n    dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。\n    \n    repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。\n    \n    main - main 字段指定了程序的主入口文件，require('moduleName') 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。\n    \n    keywords - 关键字\n    \n## 卸载模块\n\n我们可以使用以下命令来卸载 Node.js 模块。\n\n    $ npm uninstall express\n\n卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看：\n\n    $ npm ls\n    \n## 更新模块\n\n    $ npm update express\n    \n## 搜索模块\n    \n    $ npm search express\n    \n## 创建模块\n\n创建模块，package.json 文件是必不可少的。我们可以使用 NPM 生成 package.json 文件，生成的文件包含了基本的结果。\n\n    $ npm init\n    This utility will walk you through creating a package.json file.\n    It only covers the most common items, and tries to guess sensible defaults.\n    \n    See `npm help json` for definitive documentation on these fields\n    and exactly what they do.\n    \n    Use `npm install <pkg> --save` afterwards to install a package and\n    save it as a dependency in the package.json file.\n    \n    Press ^C at any time to quit.\n    name: (node_modules) runoob                   # 模块名\n    version: (1.0.0) \n    description: Node.js 测试模块(www.runoob.com)  # 描述\n    entry point: (index.js) \n    test command: make test\n    git repository: https://github.com/runoob/runoob.git  # Github 地址\n    keywords: \n    author: \n    license: (ISC) \n    About to write to ……/node_modules/package.json:      # 生成地址\n    \n    {\n      \"name\": \"runoob\",\n      \"version\": \"1.0.0\",\n      \"description\": \"Node.js 测试模块(www.runoob.com)\",\n      ……\n    }\n    \n    \n    Is this ok? (yes) yes\n    \n以上的信息，你需要根据你自己的情况输入。在最后输入 \"yes\" 后会生成 package.json 文件。\n\n接下来我们可以使用以下命令在 npm 资源库中注册用户（使用邮箱注册）：\n\n    $ npm adduser\n    Username: mcmohd\n    Password:\n    Email: (this IS public) mcmohd@gmail.com\n\n接下来我们就用以下命令来发布模块：\n\n    $ npm publish\n如果你以上的步骤都操作正确，你就可以跟其他模块一样使用 npm 来安装。\n\n## 版本号\n使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。\n\n语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。\n\n* 如果只是修复bug，需要更新Z位。\n* 如果是新增了功能，但是向下兼容，需要更新Y位。\n* 如果有大变动，向下不兼容，需要更新X位。\n\n版本号有了这个保证后，在申明第三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如\"argv\": \"0.0.x\"表示依赖于0.0.x系列的最新版argv。                    \n        \nNPM支持的所有版本号范围指定方式可以查看[官方文档](https://docs.npmjs.com/)。\n\n## NPM 常用命令\n使用npm help可查看所有命令。\n\n* NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。\n\n* 使用npm help <command>可查看某条命令的详细帮助，例如npm help install。\n\n* 在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。\n\n* 使用npm update <package>可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。\n\n* 使用npm update <package> -g可以把全局安装的对应命令行程序更新至最新版。\n\n* 使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。\n\n* 使用npm unpublish <package>@<version>可以撤销发布自己发布过的某个版本代码。\n\n## 使用淘宝 NPM 镜像\n大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。\n\n淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。\n\n你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:\n\n    $ npm install -g cnpm --registry=https://registry.npm.taobao.org\n这样就可以使用 cnpm 命令来安装模块了：\n\n    $ cnpm install [name]\n\n    \n# Node.js REPL(交互式解释器)\nNode.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。\n\nNode 自带了交互式解释器，可以执行以下任务：\n\n* 读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。\n  \n* 执行 - 执行输入的数据结构\n  \n* 打印 - 输出结果\n  \n* 循环 - 循环操作以上步骤直到用户***两次***按下  **ctrl-c**  按钮退出。\n  \nNode 的交互式解释器可以很好的调试 Javascript 代码。\n\n## 启动 Node 的终端：\n    \n    $ node\n    Welcome to Node.js v12.9.0.\n    Type \".help\" for more information.\n    >\n    \n## 简单的表达式运算\n这时我们就可以在 > 后输入简单的表达式，并按下回车键来计算结果。\n\n    $ node\n    > 1 +4\n    5\n    > 5 / 2\n    2.5\n    > 3 * 6\n    18\n    > 4 - 1\n    3\n    > 1 + ( 2 * 3 ) - 4\n    3\n    >\n## 使用变量\n你可以将数据存储在变量中，并在你需要的时候使用它。\n\n变量声明需要使用 var 关键字，如果没有使用 var 关键字变量会直接打印出来。\n\n使用 var 关键字的变量可以使用 console.log() 来输出变量。\n\n    $ node\n    > x = 10\n    10\n    > var y = 10\n    undefined\n    > x + y\n    20\n    > console.log(\"Hello World\")\n    Hello World\n    undefined\n    > console.log(\"www.runoob.com\")\n    www.runoob.com\n    undefined\n    \n## 多行表达式\nNode REPL 支持输入多行表达式，这就有点类似 JavaScript。接下来让我们来执行一个 do-while 循环：\n\n    $ node\n    > var x = 0\n    undefined\n    > do {\n    ... x++;\n    ... console.log(\"x: \" + x);\n    ... } while ( x < 5 );\n    x: 1\n    x: 2\n    x: 3\n    x: 4\n    x: 5\n    undefined\n    >\n... 三个点的符号是系统自动生成的，你回车换行后即可。Node 会自动检测是否为连续的表达式。\n    \n## 下划线(_)变量\n你可以使用下划线(_)获取上一个表达式的运算结果：\n    \n    $ node\n    > var x = 10\n    undefined\n    > var y = 20\n    undefined\n    > x + y\n    30\n    > var sum = _\n    undefined\n    > console.log(sum)\n    30\n    undefined\n    >\n    \n## REPL 命令\n\n* ctrl + c - 退出当前终端。\n  \n* ctrl + c 按下两次 - 退出 Node REPL。\n  \n* ctrl + d - 退出 Node REPL.\n  \n* 向上/向下 键 - 查看输入的历史命令\n  \n* tab 键 - 列出当前命令\n  \n* .help - 列出使用命令\n  \n* .break - 退出多行表达式\n  \n* .clear - 退出多行表达式\n  \n* .save filename - 保存当前的 Node REPL 会话到指定文件\n  \n* .load filename - 载入当前 Node REPL 会话的文件内容。\n  \n## 停止 REPL\n前面我们已经提到按下两次 ctrl + c 键就能退出 REPL:\n\n    $ node\n    >\n    (^C again to quit)\n    >      \n    \n# Node.js 回调函数\n\nNode.js 异步编程的直接体现就是回调。\n\n异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。\n\n回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。\n\n例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。\n\n回调函数一般作为函数的最后一个参数出现：\n\n    function foo1(name, age, callback) { }\n    function foo2(value, callback1, callback2) { }\n    \n## 阻塞代码实例\n    \n创建一个文件 input.txt ，内容如下：\n\n        菜鸟教程官网地址：www.runoob.com\n\n创建 main.js 文件, 代码如下：\n\n    var fs = require(\"fs\");\n    var data = fs.readFileSync('input.txt');\n    console.log(data.toString());\n    console.log(\"程序执行结束!\");\n\n以上代码执行结果如下：\n\n    $ node main.js\n    菜鸟教程官网地址：www.runoob.com\n\n    程序执行结束!\n    \n## 非阻塞代码实例\n创建一个文件 input.txt ，内容如下：\n\n    菜鸟教程官网地址：www.runoob.com\n    \n创建 main.js 文件, 代码如下：\n\n    fs.readFile('input.txt', function (err, data) {\n        if (err) return console.error(err);\n        console.log(data.toString());\n    });\n    \n    console.log(\"程序执行结束!\");\n    \n以上代码执行结果如下：\n\n    $ node main.js\n    程序执行结束!\n    菜鸟教程官网地址：www.runoob.com\n    \n以上两个实例我们了解了阻塞与非阻塞调用的不同。第一个实例在文件读取完后才执行完程序。 第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。\n\n因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。\n\n# Node.js 事件循环\n\n* Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。    \n\n* Node.js 几乎每一个 API 都是支持回调函数的。\n\n* Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。\n  \n* Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.\n  \n## 事件驱动程序\n\nNode.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。\n\n当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。\n\n这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）\n\n在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。\n\n![](https://www.runoob.com/wp-content/uploads/2015/09/event_loop.jpg)\n\n整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。\n\nNode.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：\n\n    // 引入 events 模块\n    var events = require('events');\n    // 创建 eventEmitter 对象\n    var eventEmitter = new events.EventEmitter();\n\n以下程序绑定事件处理程序：\n\n    // 绑定事件及事件的处理程序\n    eventEmitter.on('eventName', eventHandler);\n\n我们可以通过程序触发事件：\n\n    // 触发事件\n    eventEmitter.emit('eventName');\n        \n## 实例\n创建 main.js 文件，代码如下所示：\n\n    // 引入 events 模块\n    var events = require('events');\n    // 创建 eventEmitter 对象\n    var eventEmitter = new events.EventEmitter();\n    \n    // 创建事件处理程序\n    var connectHandler = function connected() {\n       console.log('连接成功。');\n      \n       // 触发 data_received 事件 \n       eventEmitter.emit('data_received');\n    } \n    \n    // 绑定 connection 事件处理程序\n    eventEmitter.on('connection', connectHandler);\n     \n    // 使用匿名函数绑定 data_received 事件\n    eventEmitter.on('data_received', function(){\n       console.log('数据接收成功。');\n    });    \n    \n    // 触发 connection 事件 \n    eventEmitter.emit('connection');\n    \n    console.log(\"程序执行完毕。\");\n\n接下来让我们执行以上代码：\n\n    $ node main.js\n    连接成功。\n    数据接收成功。\n    程序执行完毕。\n    \n## Node 应用程序是如何工作的？\n在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。\n\n接下来让我们来重新看下前面的实例，创建一个 input.txt ,文件内容如下：\n\n    菜鸟教程官网地址：www.runoob.com\n创建 main.js 文件，代码如下：\n\n    var fs = require(\"fs\");\n    \n    fs.readFile('input.txt', function (err, data) {\n       if (err){\n          console.log(err.stack);\n          return;\n       }\n       console.log(data.toString());\n    });\n    console.log(\"程序执行完毕\");\n以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。\n\n如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。\n\n执行以上代码，执行结果如下：\n    \n    程序执行完毕\n    菜鸟教程官网地址：www.runoob.com      \n接下来我们删除 input.txt 文件，执行结果如下所示：\n\n    程序执行完毕\n    Error: ENOENT, open 'input.txt'\n因为文件 input.txt 不存在，所以输出了错误信息。\n\n# Node.js EventEmitter\n          \nNode.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。\n\nNode.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。\n\n## EventEmitter 类\nevents 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。\n\n你可以通过require(\"events\");来访问该模块。\n\n    // 引入 events 模块\n    var events = require('events');\n    // 创建 eventEmitter 对象\n    var eventEmitter = new events.EventEmitter();\nEventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。\n\n### 下面我们用一个简单的例子说明 EventEmitter 的用法：\n    \n    //event.js 文件\n    var EventEmitter = require('events').EventEmitter; \n    var event = new EventEmitter(); \n    event.on('some_event', function() { \n        console.log('some_event 事件触发'); \n    }); \n    setTimeout(function() { \n        event.emit('some_event'); \n    }, 1000); \n          \n执行结果如下：\n\n运行这段代码，1 秒后控制台输出了 'some_event 事件触发'。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。\n\n    $ node event.js \n    some_event 事件触发          \nEventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。\n\n当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。\n\n让我们以下面的例子解释这个过程：\n\n    //event.js 文件\n    var events = require('events'); \n    var emitter = new events.EventEmitter(); \n    emitter.on('someEvent', function(arg1, arg2) { \n        console.log('listener1', arg1, arg2); \n    }); \n    emitter.on('someEvent', function(arg1, arg2) { \n        console.log('listener2', arg1, arg2); \n    }); \n    emitter.emit('someEvent', 'arg1 参数', 'arg2 参数'); \n    \n执行以上代码，运行的结果如下：\n\n    $ node event.js \n    listener1 arg1 参数 arg2 参数\n    listener2 arg1 参数 arg2 参数    \n\n以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。\n\n运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。\n\nEventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。\n    \n## 方法\n\n### 1. addListener(event, listener)\n为指定事件添加一个监听器到监听器数组的尾部。\n\n### 2. on(event, listener)\n为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。\n    \n    server.on('connection', function (stream) {\n      console.log('someone connected!');\n    });\n    \n### 3. once(event, listener)\n为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。\n\n    server.once('connection', function (stream) {\n      console.log('Ah, we have our first user!');\n    });\n\n### 4. removeListener(event, listener)\n移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。\n\n它接受两个参数，第一个是事件名称，第二个是回调函数名称。\n\n    var callback = function(stream) {\n      console.log('someone connected!');\n    };\n    server.on('connection', callback);\n    // ...\n    server.removeListener('connection', callback);\n    \n### 5. removeAllListeners([event])\n移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。\n\n### 6. setMaxListeners(n)\n默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。\n\n### 7. listeners(event)\n返回指定事件的监听器数组。\n\n### 8. emit(event, [arg1], [arg2], [...])\n按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。\n\n## 类方法\n### listenerCount(emitter, event)\n返回指定事件的监听器数量。\n    \n    events.EventEmitter.listenerCount(emitter, eventName) //已废弃，不推荐\n    events.emitter.listenerCount(eventName) //推荐\n    \n## 事件\n### newListener \n* event - 字符串，事件名称\n\n* listener - 处理事件函数\n\n该事件在添加新监听器时被触发。\n\n### removeListener\n* event - 字符串，事件名称\n  \n* listener - 处理事件函数\n  \n从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。\n  \n## 实例\n以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。\n\n创建 main.js 文件，代码如下：\n\n    var events = require('events');\n    var eventEmitter = new events.EventEmitter();\n    \n    // 监听器 #1\n    var listener1 = function listener1() {\n       console.log('监听器 listener1 执行。');\n    }\n    \n    // 监听器 #2\n    var listener2 = function listener2() {\n      console.log('监听器 listener2 执行。');\n    }\n    \n    // 绑定 connection 事件，处理函数为 listener1 \n    eventEmitter.addListener('connection', listener1);\n    \n    // 绑定 connection 事件，处理函数为 listener2\n    eventEmitter.on('connection', listener2);\n    \n    var eventListeners = eventEmitter.listenerCount('connection');\n    console.log(eventListeners + \" 个监听器监听连接事件。\");\n    \n    // 处理 connection 事件 \n    eventEmitter.emit('connection');\n    \n    // 移除监绑定的 listener1 函数\n    eventEmitter.removeListener('connection', listener1);\n    console.log(\"listener1 不再受监听。\");\n    \n    // 触发连接事件\n    eventEmitter.emit('connection');\n    \n    eventListeners = eventEmitter.listenerCount('connection');\n    console.log(eventListeners + \" 个监听器监听连接事件。\");\n    \n    console.log(\"程序执行完毕。\");\n\n以上代码，执行结果如下所示：\n\n    $ node main.js  \n    2 个监听器监听连接事件。\n    监听器 listener1 执行。\n    监听器 listener2 执行。\n    listener1 不再受监听。\n    监听器 listener2 执行。\n    1 个监听器监听连接事件。\n    程序执行完毕。\n## error 事件\n\nEventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。\n\n当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。\n\n我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：\n\n    var events = require('events'); \n    var emitter = new events.EventEmitter(); \n    emitter.emit('error'); \n运行时会显示以下错误：\n\n    node.js:201 \n    throw e; // process.nextTick error, or 'error' event on first tick \n    ^ \n    Error: Uncaught, unspecified 'error' event. \n    at EventEmitter.emit (events.js:50:15) \n    at Object.<anonymous> (/home/byvoid/error.js:5:9) \n    at Module._compile (module.js:441:26) \n    at Object..js (module.js:459:10) \n    at Module.load (module.js:348:31) \n    at Function._load (module.js:308:12) \n    at Array.0 (module.js:479:10) \n    at EventEmitter._tickCallback (node.js:192:40)    \n    \n## 继承 EventEmitter\n大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。\n\n为什么要这样做呢？原因有两点：\n\n首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。\n\n其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。\n\n\n# Node.js Buffer(缓冲区)\nJavaScript 语言自身只有字符串数据类型，没有二进制数据类型。\n\n但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。\n\n在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。\n\n>> 在v6.0之前创建Buffer对象直接使用new Buffer()构造函数来创建对象实例，但是Buffer对内存的权限操作相比很大，可以直接捕获一些敏感信息，所以在v6.0以后，官方文档里面建议使用 Buffer.from() 接口去创建Buffer对象。    \n\n## Buffer 与字符编码\nBuffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。\n\n    const buf = Buffer.from('runoob', 'ascii');\n    \n    // 输出 72756e6f6f62\n    console.log(buf.toString('hex'));\n    \n    // 输出 cnVub29i\n    console.log(buf.toString('base64'));\n    \nNode.js 目前支持的字符编码包括：\n\n* ascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。\n  \n* utf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。\n  \n* utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。\n  \n* ucs2 - utf16le 的别名。\n  \n* base64 - Base64 编码。\n  \n* latin1 - 一种把 Buffer 编码成一字节编码的字符串的方式。\n  \n* binary - latin1 的别名。\n  \n* hex - 将每个字节编码为两个十六进制字符。\n  \n## 创建 Buffer 类\n\nBuffer 提供了以下 API 来创建 Buffer 类：\n\n* Buffer.alloc(size[, fill[, encoding]])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0\n\n* Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据\n\n* Buffer.allocUnsafeSlow(size)\n\n* Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）\n\n* Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。\n\n* Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例\n\n* Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例\n\n    / 创建一个长度为 10、且用 0 填充的 Buffer。\n    const buf1 = Buffer.alloc(10);\n    \n    // 创建一个长度为 10、且用 0x1 填充的 Buffer。 \n    const buf2 = Buffer.alloc(10, 1);\n    \n    // 创建一个长度为 10、且未初始化的 Buffer。\n    // 这个方法比调用 Buffer.alloc() 更快，\n    // 但返回的 Buffer 实例可能包含旧数据，\n    // 因此需要使用 fill() 或 write() 重写。\n    const buf3 = Buffer.allocUnsafe(10);\n    \n    // 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。\n    const buf4 = Buffer.from([1, 2, 3]);\n    \n    // 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。\n    const buf5 = Buffer.from('tést');\n    \n    // 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。\n    const buf6 = Buffer.from('tést', 'latin1');\n    \n## 写入缓冲区\n### 语法\n    buf.write(string[, offset[, length]][, encoding])\n\n### 参数\n参数描述如下：\n\n* string - 写入缓冲区的字符串。\n\n* offset - 缓冲区开始写入的索引值，默认为 0 。\n\n* length - 写入的字节数，默认为 buffer.length\n\n* encoding - 使用的编码。默认为 'utf8' 。\n\n根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。\n\n### 返回值\n\n返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。\n\n### 实例\n    buf = Buffer.alloc(256);\n    len = buf.write(\"www.runoob.com\");\n    \n    console.log(\"写入字节数 : \"+  len);\n\n执行以上代码，输出结果为：\n\n    $node main.js\n    写入字节数 : 14\n\n## 从缓冲区读取数据\n\n### 读取 Node 缓冲区数据的语法如下所示：\n    \n    buf.toString([encoding[, start[, end]]])\n\n### 参数\n参数描述如下：\n\n* encoding - 使用的编码。默认为 'utf8' 。\n\n* start - 指定开始读取的索引位置，默认为 0。\n\n* end - 结束位置，默认为缓冲区的末尾。\n\n### 返回\n解码缓冲区数据并使用指定的编码返回字符串。\n\n### 实例\n\n    buf = Buffer.alloc(26);\n    for (var i = 0 ; i < 26 ; i++) {\n      buf[i] = i + 97;\n    }\n    \n    console.log( buf.toString('ascii'));       // 输出: abcdefghijklmnopqrstuvwxyz\n    console.log( buf.toString('ascii',0,5));   // 输出: abcde\n    console.log( buf.toString('utf8',0,5));    // 输出: abcde\n    console.log( buf.toString(undefined,0,5)); // 使用 'utf8' 编码, 并输出: abcde\n    \n执行以上代码，输出结果为：\n\n    $ node main.js\n    abcdefghijklmnopqrstuvwxyz\n    abcde\n    abcde\n    abcde\n\n## 将 Buffer 转换为 JSON 对象\n\n### 语法\n\n    buf.toJSON()\n\n当字符串化一个 Buffer 实例时，JSON.stringify() 会隐式地调用该 toJSON()。\n\n### 返回值\n\n返回 JSON 对象。\n\n### 实例\n\n    const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);\n    const json = JSON.stringify(buf);\n    \n    // 输出: {\"type\":\"Buffer\",\"data\":[1,2,3,4,5]}\n    console.log(json);\n    \n    const copy = JSON.parse(json, (key, value) => {\n      return value && value.type === 'Buffer' ?\n        Buffer.from(value.data) :\n        value;\n    });\n    \n    // 输出: <Buffer 01 02 03 04 05>\n    console.log(copy);\n\n执行以上代码，输出结果为：\n\n    {\"type\":\"Buffer\",\"data\":[1,2,3,4,5]}\n    <Buffer 01 02 03 04 05>\n    \n## 缓冲区合并\n\n### 语法\n\n    Buffer.concat(list[, totalLength])\n\n### 参数\n参数描述如下：\n\n* list - 用于合并的 Buffer 对象数组列表。\n\n* totalLength - 指定合并后Buffer对象的总长度。\n\n### 返回值\n\n返回一个多个成员合并的新 Buffer 对象。\n\n### 实例\n\n    var buffer1 = Buffer.from(('菜鸟教程'));\n    var buffer2 = Buffer.from(('www.runoob.com'));\n    var buffer3 = Buffer.concat([buffer1,buffer2]);\n    console.log(\"buffer3 内容: \" + buffer3.toString());\n\n执行以上代码，输出结果为：\n\n    buffer3 内容: 菜鸟教程www.runoob.com\n\n## 缓冲区比较\n\n### 语法\nNode Buffer 比较的函数语法如下所示, 该方法在 Node.js v0.12.2 版本引入    \n    \n    buf.compare(otherBuffer);\n\n### 参数\n参数描述如下：\n\n* otherBuffer - 与 buf 对象比较的另外一个 Buffer 对象。\n\n### 返回值\n\n返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。\n\n### 实例 \n    \n    var buffer1 = Buffer.from('ABC');\n    var buffer2 = Buffer.from('ABCD');\n    var result = buffer1.compare(buffer2);\n    \n    if(result < 0) {\n       console.log(buffer1 + \" 在 \" + buffer2 + \"之前\");\n    }else if(result == 0){\n       console.log(buffer1 + \" 与 \" + buffer2 + \"相同\");\n    }else {\n       console.log(buffer1 + \" 在 \" + buffer2 + \"之后\");\n    }\n\n执行以上代码，输出结果为：\n\n    ABC在ABCD之前\n\n## 拷贝缓冲区\n\n### 语法\n    buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])\n\n* targetBuffer - 要拷贝的 Buffer 对象。\n\n* targetStart - 数字, 可选, 默认: 0\n\n* sourceStart - 数字, 可选, 默认: 0\n\n* sourceEnd - 数字, 可选, 默认: buffer.length\n\n### 返回值\n没有返回值。\n\n### 实例\n\n    var buf1 = Buffer.from('abcdefghijkl');\n    var buf2 = Buffer.from('RUNOOB');\n    \n    //将 buf2 插入到 buf1 指定位置上\n    buf2.copy(buf1, 2);\n    \n    console.log(buf1.toString());\n\n执行以上代码，输出结果为：\n\n    abRUNOOBijkl\n\n## 缓冲区裁剪\nNode 缓冲区裁剪语法如下所示：\n\n    buf.slice([start[, end]])\n   \n参数\n参数描述如下：\n\n* start - 数字, 可选, 默认: 0\n\n* end - 数字, 可选, 默认: buffer.length\n\n返回值\n返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。\n\n实例\n\n    var buffer1 = Buffer.from('runoob');\n    // 剪切缓冲区\n    var buffer2 = buffer1.slice(0,2);\n    console.log(\"buffer2 content: \" + buffer2.toString());\n    执行\n\n执行以上代码，输出结果为：\n\n    buffer2 content: ru\n    \n## 缓冲区长度\n    \n    buf.length;\n返回值\n返回 Buffer 对象所占据的内存长度。\n\n实例\n    \n    var buffer = Buffer.from('www.runoob.com');\n    //  缓冲区长度\n    console.log(\"buffer length: \" + buffer.length);\n\n执行以上代码，输出结果为：\n\n    buffer length: 14\n\n\n# Node.js Stream(流)\nStream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。\n\nNode.js，Stream 有四种流类型：\n\n* Readable - 可读操作。\n\n* Writable - 可写操作。\n  \n* Duplex - 可读可写操作.\n  \n* Transform - 操作被写入数据，然后读出结果。\n  \n所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：\n\n* data - 当有数据可读时触发。\n  \n* end - 没有更多的数据可读时触发。\n  \n* error - 在接收和写入过程中发生错误时触发。\n  \n* finish - 所有数据已被写入到底层系统时触发。\n  \n## 从流中读取数据\n  \n创建 input.txt 文件，内容如下：\n\n    菜鸟教程官网地址：www.runoob.com\n\n    var fs = require(\"fs\");\n    var data = '';\n    \n    // 创建可读流\n    var readerStream = fs.createReadStream('input.txt');\n    \n    // 设置编码为 utf8。\n    readerStream.setEncoding('UTF8');\n    \n    // 处理流事件 --> data, end, and error\n    readerStream.on('data', function(chunk) {\n       data += chunk;\n    });\n    \n    readerStream.on('end',function(){\n       console.log(data);\n    });\n    \n    readerStream.on('error', function(err){\n       console.log(err.stack);\n    });\n    \n    console.log(\"程序执行完毕\");\n\n以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下：\n\n    $ node main.js \n    程序执行完毕\n    写入完成。\n\n查看 output.txt 文件的内容：\n\n    $ cat output.txt \n    菜鸟教程官网地址：www.runoob.com\n    \n## 管道流\n管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。    \n    \n设置 input.txt 文件内容如下：\n    \n    菜鸟教程官网地址：www.runoob.com\n    管道流操作实例\n\n创建 main.js 文件, 代码如下：\n\n    var fs = require(\"fs\");\n    \n    // 创建一个可读流\n    var readerStream = fs.createReadStream('input.txt');\n    \n    // 创建一个可写流\n    var writerStream = fs.createWriteStream('output.txt');\n    \n    // 管道读写操作\n    // 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中\n    readerStream.pipe(writerStream);\n    \n    console.log(\"程序执行完毕\");\n\n代码执行结果如下：\n\n    $ node main.js \n    程序执行完毕\n\n查看 output.txt 文件的内容：\n\n    $ cat output.txt \n    菜鸟教程官网地址：www.runoob.com\n    管道流操作实例\n    \n##     链式流\n链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。\n\n接下来我们就是用管道和链式来压缩和解压文件。\n\n创建 compress.js 文件, 代码如下：\n    \n    var fs = require(\"fs\");\n    var zlib = require('zlib');\n    \n    // 压缩 input.txt 文件为 input.txt.gz\n    fs.createReadStream('input.txt')\n      .pipe(zlib.createGzip())\n      .pipe(fs.createWriteStream('input.txt.gz'));\n      \n    console.log(\"文件压缩完成。\");\n    \n代码执行结果如下：\n\n    $ node compress.js \n    文件压缩完成。\n\n执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。\n\n接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下：\n\n    var fs = require(\"fs\");\n    var zlib = require('zlib');\n    \n    // 解压 input.txt.gz 文件为 input.txt\n    fs.createReadStream('input.txt.gz')\n      .pipe(zlib.createGunzip())\n      .pipe(fs.createWriteStream('input.txt'));\n      \n    console.log(\"文件解压完成。\");\n    \n代码执行结果如下：\n\n    $ node decompress.js \n    文件解压完成。\n\n# Node.js模块系统\n\n为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。\n\n模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。\n\n\n## 创建模块\n\n在 Node.js 中，创建一个模块非常简单，如下我们创建一个 main.js 文件，代码如下:\n\n    var hello = require('./hello');\n    hello.world();\n\n以上实例中，代码 require('./hello') 引入了当前目录下的 hello.js 文件（./ 为当前目录，node.js 默认后缀为 js）。\n\nNode.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。\n\n接下来我们就来创建 hello.js 文件，代码如下：\n\n    exports.world = function() {\n      console.log('Hello World');\n    }\n\n在以上示例中，hello.js 通过 exports 对象把 world 作为模块的访问接口，在 main.js 中通过 require('./hello') 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。\n\n有时候我们只是想把一个对象封装到模块中，格式如下：\n    \n    module.exports = function() {\n      // ...\n    }\n例如:\n\n    //hello.js \n    function Hello() { \n        var name; \n        this.setName = function(thyName) { \n            name = thyName; \n        }; \n        this.sayHello = function() { \n            console.log('Hello ' + name); \n        }; \n    }; \n    module.exports = Hello;\n    \n这样就可以直接获得这个对象了：\n\n    //main.js \n    var Hello = require('./hello'); \n    hello = new Hello(); \n    hello.setName('BYVoid'); \n    hello.sayHello(); \n    \n模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。    \n\n## 服务端的模块放在哪里\n\n也许你已经注意到，我们已经在代码中使用了模块了。像这样：\n\n    var http = require(\"http\");\n    \n    ...\n    \n    http.createServer(...);\n    \nNode.js 中自带了一个叫做 http 的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。\n\n这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。\n\nNode.js 的 require 方法中的文件查找策略如下：\n\n由于 Node.js 中存在 4 类模块（原生模块和3种文件模块），尽管 require 方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。如下图所示：    \n\n![](https://www.runoob.com/wp-content/uploads/2014/03/nodejs-require.jpg)\n\n## 从文件模块缓存中加载\n\n尽管原生模块与文件模块的优先级不同，但是都会优先从文件模块的缓存中加载已经存在的模块。\n\n## 从原生模块加载\n\n原生模块的优先级仅次于文件模块缓存的优先级。require 方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个 http/http.js/http.node/http.json 文件，require(\"http\") 都不会从这些文件中加载，而是从原生模块中加载。\n\n原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。\n\n## 从文件加载\n\n当文件模块缓存中不存在，而且不是原生模块的时候，Node.js 会解析 require 方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。\n\nrequire方法接受以下几种参数的传递：    \n    \n* http、fs、path等，原生模块。\n\n* ./mod或../mod，相对路径的文件模块。\n\n* /pathtomodule/mod，绝对路径的文件模块。\n\n* mod，非原生模块的文件模块。\n\n在路径 Y 下执行 require(X) 语句执行顺序：\n\n    1. 如果 X 是内置模块\n       a. 返回内置模块\n       b. 停止执行\n    2. 如果 X 以 '/' 开头\n       a. 设置 Y 为文件根路径\n    3. 如果 X 以 './' 或 '/' or '../' 开头\n       a. LOAD_AS_FILE(Y + X)\n       b. LOAD_AS_DIRECTORY(Y + X)\n    4. LOAD_NODE_MODULES(X, dirname(Y))\n    5. 抛出异常 \"not found\"\n    \n    LOAD_AS_FILE(X)\n    1. 如果 X 是一个文件, 将 X 作为 JavaScript 文本载入并停止执行。\n    2. 如果 X.js 是一个文件, 将 X.js 作为 JavaScript 文本载入并停止执行。\n    3. 如果 X.json 是一个文件, 解析 X.json 为 JavaScript 对象并停止执行。\n    4. 如果 X.node 是一个文件, 将 X.node 作为二进制插件载入并停止执行。\n    \n    LOAD_INDEX(X)\n    1. 如果 X/index.js 是一个文件,  将 X/index.js 作为 JavaScript 文本载入并停止执行。\n    2. 如果 X/index.json 是一个文件, 解析 X/index.json 为 JavaScript 对象并停止执行。\n    3. 如果 X/index.node 是一个文件,  将 X/index.node 作为二进制插件载入并停止执行。\n    \n    LOAD_AS_DIRECTORY(X)\n    1. 如果 X/package.json 是一个文件,\n       a. 解析 X/package.json, 并查找 \"main\" 字段。\n       b. let M = X + (json main 字段)\n       c. LOAD_AS_FILE(M)\n       d. LOAD_INDEX(M)\n    2. LOAD_INDEX(X)\n    \n    LOAD_NODE_MODULES(X, START)\n    1. let DIRS=NODE_MODULES_PATHS(START)\n    2. for each DIR in DIRS:\n       a. LOAD_AS_FILE(DIR/X)\n       b. LOAD_AS_DIRECTORY(DIR/X)\n    \n    NODE_MODULES_PATHS(START)\n    1. let PARTS = path split(START)\n    2. let I = count of PARTS - 1\n    3. let DIRS = []\n    4. while I >= 0,\n       a. if PARTS[I] = \"node_modules\" CONTINUE\n       b. DIR = path join(PARTS[0 .. I] + \"node_modules\")\n       c. DIRS = DIRS + DIR\n       d. let I = I - 1\n    5. return DIRS\n    \nexports 和 module.exports 的使用\n\n如果要对外暴露属性或方法，就用 exports 就行，要暴露对象(类似class，包含了很多属性和方法)，就用 module.exports。    \n\n# Node.js 函数\n在JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。\n\nNode.js中函数的使用与Javascript类似，举例来说，你可以这样做：\n    \n    function say(word) {\n      console.log(word);\n    }\n    \n    function execute(someFunction, value) {\n      someFunction(value);\n    }\n    \n    execute(say, \"Hello\");\n\n以上代码中，我们把 say 函数作为execute函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！\n\n这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。\n\n当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。\n\n## 匿名函数\n\n我们可以把一个函数作为变量传递。但是我们不一定要绕这个\"先定义，再传递\"的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：\n\n    function execute(someFunction, value) {\n      someFunction(value);\n    }\n    \n我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。\n\n用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做匿名函数 。\n\n## 函数传递是如何让HTTP服务器工作的\n带着这些知识，我们再来看看我们简约而不简单的HTTP服务器：\n\n    var http = require(\"http\");\n    \n    http.createServer(function(request, response) {\n      response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n      response.write(\"Hello World\");\n      response.end();\n    }).listen(8888);\n\n现在它看上去应该清晰了很多：我们向 createServer 函数传递了一个匿名函数。\n\n用这样的代码也可以达到同样的目的：\n\n    var http = require(\"http\");\n    \n    function onRequest(request, response) {\n      response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n      response.write(\"Hello World\");\n      response.end();\n    }\n    \n    http.createServer(onRequest).listen(8888);\n\n# Node.js 路由\n我们要为路由提供请求的 URL 和其他需要的 GET 及 POST 参数，随后路由需要根据这些数据来执行相应的代码。\n\n因此，我们需要查看 HTTP 请求，从中提取出请求的 URL 以及 GET/POST 参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。\n\n我们需要的所有数据都会包含在 request 对象中，该对象作为 onRequest() 回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的 Node.JS 模块，它们分别是 url 和 querystring 模块。\n\n    url.parse(string).query\n                                               |\n               url.parse(string).pathname      |\n                           |                   |\n                           |                   |\n                         ------ -------------------\n    http://localhost:8888/start?foo=bar&hello=world\n                                    ---       -----\n                                     |          |\n                                     |          |\n                  querystring.parse(queryString)[\"foo\"]    |\n                                                |\n                             querystring.parse(queryString)[\"hello\"]\n\n当然我们也可以用 querystring 模块来解析 POST 请求体中的参数，稍后会有演示。\n\n现在我们来给 onRequest() 函数加上一些逻辑，用来找出浏览器请求的 URL 路径：\n\n**server.js 文件代码：**\n\n    var http = require(\"http\");\n    var url = require(\"url\");\n     \n    function start() {\n      function onRequest(request, response) {\n        var pathname = url.parse(request.url).pathname;\n        console.log(\"Request for \" + pathname + \" received.\");\n        response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n        response.write(\"Hello World\");\n        response.end();\n      }\n     \n      http.createServer(onRequest).listen(8888);\n      console.log(\"Server has started.\");\n    }\n     \n    exports.start = start;\n\n好了，我们的应用现在可以通过请求的 URL 路径来区别不同请求了--这使我们得以使用路由（还未完成）来将请求以 URL 路径为基准映射到处理程序上。\n\n在我们所要构建的应用中，这意味着来自 /start 和 /upload 的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。\n\n现在我们可以来编写路由了，建立一个名为 router.js 的文件，添加以下内容：\n**router.js**\n    \n    function route(pathname) {\n      console.log(\"About to route a request for \" + pathname);\n    }\n     \n    exports.route = route;\n\n如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。\n\n我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块。\n\n首先，我们来扩展一下服务器的 start() 函数，以便将路由函数作为参数传递过去，server.js 文件代码如下\n    \n    var http = require(\"http\");\n    var url = require(\"url\");\n     \n    function start(route) {\n      function onRequest(request, response) {\n        var pathname = url.parse(request.url).pathname;\n        console.log(\"Request for \" + pathname + \" received.\");\n     \n        route(pathname);\n     \n        response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n        response.write(\"Hello World\");\n        response.end();\n      }\n     \n      http.createServer(onRequest).listen(8888);\n      console.log(\"Server has started.\");\n    }\n     \n    exports.start = start;\n    \n同时，我们会相应扩展 index.js，使得路由函数可以被注入到服务器中：\n\n**index.js 文件代码：**\n\n    var server = require(\"./server\");\n    var router = require(\"./router\");\n     \n    server.start(router.route);\n\n在这里，我们传递的函数依旧什么也没做。\n\n如果现在启动应用（node index.js，始终记得这个命令行），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：\n\n    $ node index.js\n    Server has started.        \n\n    以上输出已经去掉了比较烦人的 /favicon.ico 请求相关的部分。\n    \n    浏览器访问 http://127.0.0.1:8888/，输出结果如下：\n\n# Node.js 全局对象\navaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。\n\n在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。\n\n在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。\n\n## 全局对象与全局变量\nglobal 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量：\n\n* 在最外层定义的变量；\n\n* 全局对象的属性；\n\n* 隐式定义的变量（未定义直接赋值的变量）。\n\n你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注 意的是，在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。\n\n注意： 最好不要使用 var 定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险。\n\n## __filename\n\n_filename 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。\n\n**实例**\n创建文件 main.js ，代码如下所示：\n\n    // 输出全局变量 __filename 的值\n    console.log( __filename );\n执行 main.js 文件，代码如下所示:\n\n    $ node main.js\n    /web/com/runoob/nodejs/main.js\n    \n## __dirname\n    \n__dirname 表示当前执行脚本所在的目录。\n\n**实例**    \n\n创建文件 main.js ，代码如下所示：\n\n    // 输出全局变量 __dirname 的值\n    console.log( __dirname );\n执行 main.js 文件，代码如下所示:\n    \n    $ node main.js\n    /web/com/runoob/nodejs\n    \n## setTimeout(cb, ms)\nsetTimeout(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout() 只执行一次指定函数。\n\n返回一个代表定时器的句柄值。\n\n**实例**    \n\n创建文件 main.js ，代码如下所示：\n\n    function printHello(){\n       console.log( \"Hello, World!\");\n    }\n    // 两秒后执行以上函数\n    setTimeout(printHello, 2000);\n\n执行 main.js 文件，代码如下所示:\n\n    $ node main.js\n    Hello, World!    \n    \n## clearTimeout(t)\n    \nclearTimeout( t ) 全局函数用于停止一个之前通过 setTimeout() 创建的定时器。 参数 t 是通过 setTimeout() 函数创建的定时器。    \n\n实例\n创建文件 main.js ，代码如下所示：\n\n    function printHello(){\n       console.log( \"Hello, World!\");\n    }\n    // 两秒后执行以上函数\n    var t = setTimeout(printHello, 2000);\n    \n    // 清除定时器\n    clearTimeout(t);\n    \n执行 main.js 文件，代码如下所示:\n\n    $ node main.js    \n\n## setInterval(cb, ms)\nsetInterval(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。\n\n返回一个代表定时器的句柄值。可以使用 clearInterval(t) 函数来清除定时器。\n\nsetInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。\n\n实例\n创建文件 main.js ，代码如下所示：\n\n    function printHello(){\n       console.log( \"Hello, World!\");\n    }\n    // 两秒后执行以上函数\n    setInterval(printHello, 2000);\n    \n执行 main.js 文件，代码如下所示:\n\n    $ node main.js\n    Hello, World!\n    Hello, World!\n    Hello, World!\n    Hello, World!\n    Hello, World!\n    Hello, World!\n    Hello, World!\n\n以上程序每隔两秒就会输出一次\"Hello, World!\"，且会永久执行下去，直到你按下 ctrl + c 按钮。\n\n## console\nconsole 用于提供控制台标准输出，它是由 Internet Explorer 的 JScript 引擎提供的调试工具，后来逐渐成为浏览器的实施标准。\n\nNode.js 沿用了这个标准，提供与习惯行为一致的 console 对象，用于向标准输出流（stdout）或标准错误流（stderr）输出字符。\n\n### console.log([data][, ...])\n向标准输出流打印字符并以换行符结束。该方法接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。\n\n### console.info([data][, ...])\n该命令的作用是返回信息性消息，这个命令与console.log差别并不大，除了在chrome中只会输出文字外，其余的会显示一个蓝色的惊叹号。\n\n### console.error([data][, ...])\n输出错误消息的。控制台在出现错误时会显示是红色的叉子。\n\n### console.warn([data][, ...])\n输出警告消息。控制台出现有黄色的惊叹号。\n\n### console.dir(obj[, options])\n用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。\n\n### console.time(label)\n输出时间，表示计时开始。\n\n### console.timeEnd(label)\n结束时间，表示计时结束。\n\n### console.trace(message[, ...])\n当前执行的代码在堆栈中的调用路径，这个测试函数运行很有帮助，只要给想测试的函数里面加入 console.trace 就行了。\n\n### console.assert(value[, message][, ...])\n用于判断某个表达式或变量是否为真，接收两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。\n\nconsole.log()：向标准输出流打印字符并以换行符结束。\nconsole.log 接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。\n\n第一个参数是一个字符串，如果没有 参数，只打印一个换行。\n\n\n    console.log('Hello world'); \n    console.log('byvoid%diovyb'); \n    console.log('byvoid%diovyb', 1991); \n    运行结果为：\n    \n    Hello world \n    byvoid%diovyb \n    byvoid1991iovyb \n    \n    console.error()：与console.log() 用法相同，只是向标准错误流输出。\n    console.trace()：向标准错误流输出当前的调用栈。\n\n    console.trace();\n    \n    运行结果为：\n    \n    Trace: \n    at Object.<anonymous> (/home/byvoid/consoletrace.js:1:71) \n    at Module._compile (module.js:441:26) \n    at Object..js (module.js:459:10) \n    at Module.load (module.js:348:31) \n    at Function._load (module.js:308:12) \n    at Array.0 (module.js:479:10) \n    at EventEmitter._tickCallback (node.js:192:40)\n\n    console.info(\"程序开始执行：\");\n    \n    var counter = 10;\n    console.log(\"计数: %d\", counter);\n    \n    console.time(\"获取数据\");\n    //\n    // 执行一些代码\n    // \n    console.timeEnd('获取数据');\n    \n    console.info(\"程序执行完毕。\")\n\n    程序开始执行：\n    计数: 10\n    获取数据: 0ms\n    程序执行完毕\n\n## process\nprocess 是一个全局变量，即 global 对象的属性。\n\n它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要 和它打交道。下面将会介绍 process 对象的一些最常用的成员方法。\n\n### exit\n当进程准备退出时触发。\n\n### beforeExit\n当 node 清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时 node 退出，但是 'beforeExit' 的监听器可以异步调用，这样 node 就会继续执行。\n\n### uncaughtException\n当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。\n\n### Signal 事件\n当进程接收到信号时就触发。信号列表详见标准的 POSIX 信号名，如 SIGINT、SIGUSR1 等。\n\n### 实例 ###\n\n创建文件 main.js ，代码如下所示：\n\n    process.on('exit', function(code) {\n    \n      // 以下代码永远不会执行\n      setTimeout(function() {\n        console.log(\"该代码不会执行\");\n      }, 0);\n      \n      console.log('退出码为:', code);\n    });\n    console.log(\"程序执行结束\");\n\n执行 main.js 文件，代码如下所示:\n\n    $ node main.js\n    程序执行结束\n    退出码为: 0\n\n### 退出状态码\n| 状态码 | 名称&描述 |\n| :-- | :-- |\n| 1 | Uncaught Fatal Exception <br> 有未捕获异常，并且没有被域或 uncaughtException 处理函数处理。|\n| 2 | Unused <br> 保留 | \n| 3 | Internal JavaScript Parse Error  <br> JavaScript的源码启动 Node 进程时引起解析错误。非常罕见，仅会在开发 Node 时才会有。 | \n| 4 | Internal JavaScript Evaluation Failure  <br> JavaScript 的源码启动 Node 进程，评估时返回函数失败。非常罕见，仅会在开发 Node 时才会有。| \n| 5 | Fatal Error  <br> V8 里致命的不可恢复的错误。通常会打印到 stderr ，内容为： FATAL ERROR | \n| 6 | Non-function Internal Exception Handler  <br> 未捕获异常，内部异常处理函数不知为何设置为on-function，并且不能被调用。| \n| 7 | Internal Exception Handler Run-Time Failure  <br> 未捕获的异常， 并且异常处理函数处理时自己抛出了异常。例如，如果 process.on('uncaughtException') 或 domain.on('error') 抛出了异常。 | \n| 8 | Unused  <br> 保留 | \n| 9 | Invalid Argument  <br> 可能是给了未知的参数，或者给的参数没有值。| \n| 10 | Internal JavaScript Run-Time Failure  <br> JavaScript的源码启动 Node 进程时抛出错误，非常罕见，仅会在开发 Node 时才会有。 | \n| 12 | Invalid Debug Argument   <br> 设置了参数--debug 和/或 --debug-brk，但是选择了错误端口。 | \n| 128 | Signal Exits  <br> 如果 Node 接收到致命信号，比如SIGKILL 或 SIGHUP，那么退出代码就是128 加信号代码。这是标准的 Unix 做法，退出信号代码放在高位。 | \n\n### Process 属性\nProcess 提供了很多有用的属性，便于我们更好的控制系统的交互：\n\n|序号|属性&描述|\n|:--| :-- |\n|1| stdout <br> 标准输出流。|\n|2| stderr <br> 标准错误流。|\n|3| stdin <br> 标准输入流。|\n|4| argv <br> argv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。|\n|5| execPath <br> 返回执行当前脚本的 Node 二进制文件的绝对路径。|\n|6| execArgv <br> 返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。|\n|7| env <br> 返回一个对象，成员为当前 shell 的环境变量|\n|8| exitCode <br> 进程退出时的代码，如果进程优通过 process.exit() 退出，不需要指定退出码。|\n|9| version <br> Node 的版本，比如v0.10.18。|\n|10| versions <br> 一个属性，包含了 node 的版本和依赖.|\n|11| config <br> 一个包含用来编译当前 node 执行文件的 javascript 配置选项的对象。它与运行 ./configure 脚本生成的 \"config.gypi\" 文件相同。|\n|12| pid <br> 当前进程的进程号。|\n|13| title <br> 进程名，默认值为\"node\"，可以自定义该值。|\n|14| arch <br> 当前 CPU 的架构：'arm'、'ia32' 或者 'x64'。|\n|15| platform <br> 运行程序所在的平台系统 'darwin', 'freebsd', 'linux', 'sunos' 或 'win32'|\n|16| mainModule<br> require.main 的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。|\n\n***实例***\n创建文件 main.js ，代码如下所示：\n\n    // 输出到终端\n    process.stdout.write(\"Hello World!\" + \"\\n\");\n    \n    // 通过参数读取\n    process.argv.forEach(function(val, index, array) {\n       console.log(index + ': ' + val);\n    });\n    \n    // 获取执行路径\n    console.log(process.execPath);\n    \n    \n    // 平台信息\n    console.log(process.platform);\n\n执行 main.js 文件，代码如下所示:\n\n    $ node main.js\n    Hello World!\n    0: node\n    1: /web/www/node/main.js\n    /usr/local/node/0.10.36/bin/node\n    darwin\n\n**方法参考手册**\nProcess 提供了很多有用的方法，便于我们更好的控制系统的交互：\n\n|序号|方法 & 描述|\n|:--|:--|\n|1| abort() <br> 这将导致node触发abort事件。会让node退出并生成一个核心文件 |\n|2| chdir(directory) <br> 改变当前工作进程的目录，如果操作失败抛出异常。 |\n|3| cwd() <br> 返回当前进程的工作目录 |\n|4| exit([code]) <br> 使用指定的 code 结束进程。如果忽略，将会使用 code 0。 |\n|5| getgid() <br> 取进程的群组标识（参见 getgid(2)）。获取到得时群组的数字 id，而不是名字. 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。 |\n|6| setgid(id) <br> 设置进程的群组标识（参见 setgid(2)）。可以接收数字 ID 或者群组名。如果指定了群组名，会阻塞等待解析为数字 ID 。                    注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。 |\n|7| getuid() <br> 获取进程的用户标识(参见 getuid(2))。这是数字的用户 id，不是用户名。                  注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。 |\n|8| setuid(id) <br> 设置进程的用户标识（参见setuid(2)）。接收数字 ID或字符串名字。果指定了群组名，会阻塞等待解析为数字 ID 。                    注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。 |\n|9| getgroups() <br> 返回进程的群组 iD 数组。POSIX 系统没有保证一定有，但是 node.js 保证有。                     注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。 |\n|10| setgroups(groups) <br> 设置进程的群组 ID。这是授权操作，所以你需要有 root 权限，或者有 CAP_SETGID 能力。                            注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。 |\n|11| initgroups(user, extra_group) <br> 读取 /etc/group ，并初始化群组访问列表，使用成员所在的所有群组。这是授权操作，所以你需要有 root 权限，或者有 CAP_SETGID 能力。                                        注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。 |\n|12| kill(pid[, signal]) <br> 发送信号给进程. pid 是进程id，并且 signal 是发送的信号的字符串描述。信号名是字符串，比如 'SIGINT' 或 'SIGHUP'。如果忽略，信号会是 'SIGTERM'。 |\n|13| memoryUsage() <br> 返回一个对象，描述了 Node 进程所用的内存状况，单位为字节。 |\n|14| nextTick(callback) <br> 一旦当前事件循环结束，调用回调函数。 |\n|15| umask([mask]) <br> 设置或读取进程文件的掩码。子进程从父进程继承掩码。如果mask 参数有效，返回旧的掩码。否则，返回当前掩码。 |\n|16| uptime() <br> 返回 Node 已经运行的秒数。 |\n|17| hrtime() <br> 返回当前进程的高分辨时间，形式为 [seconds, nanoseconds]数组。它是相对于过去的任意事件。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。                   你可以将之前的结果传递给当前的 process.hrtime() ，会返回两者间的时间差，用来基准和测量时间间隔。 |\n\n## 实例\n\n创建文件 main.js ，代码如下所示：\n\n    // 输出当前目录\n    console.log('当前目录: ' + process.cwd());\n    \n    // 输出当前版本\n    console.log('当前版本: ' + process.version);\n    \n    // 输出内存使用情况\n    console.log(process.memoryUsage());\n\n执行 main.js 文件，代码如下所示:\n\n    $ node main.js\n    当前目录: /web/com/runoob/nodejs\n    当前版本: v0.10.36\n    { rss: 12541952, heapTotal: 4083456, heapUsed: 2157056 }\n\n\n#  Node.js 常用工具\nutil 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。\n\nutil.inherits\nutil.inherits(constructor, superConstructor) 是一个实现对象间原型继承的函数。\n\nJavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有提供对象继承的语言级别特性，而是通过原型复制来实现的。\n\n在这里我们只介绍 util.inherits 的用法，示例如下\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    \n   ","source":"_posts/node-js教程.md","raw":"---\ntitle: node.js教程\ndate: 2019-08-26 14:08:08\ntags: [node ]\n---\n\n# 简介\n* 简单的说 Node.js 就是运行在服务端的 JavaScript。\n  \n* Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。\n  \n* Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。\n  \n## 查看版本\n    \n    node -v\n    v12.9.0\n\n## Hello World\n   \n   vim helloWorld.js\n   \n   console.log(\"Hello World\");\n   \n   node helloWorld.js\n   \n## 交互模式\n\n    $ node\n    > console.log('Hello World!');\n    Hello World!\n    \n# Node.js 安装配置\n\n    Mac安装\n    brew install node\n\n# Node.js 创建第一个应用\n    \n## 步骤一、引入 required 模块\n\n我们使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下:\n\n    var http = require(\"http\");\n    \n## 步骤二、创建服务器\n接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。\n\n实例如下，在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：\n\n    var http = require('http');\n    http.createServer(function (request, response) {\n    \n        // 发送 HTTP 头部 \n        // HTTP 状态值: 200 : OK\n        // 内容类型: text/plain\n        response.writeHead(200, {'Content-Type': 'text/plain'});\n    \n        // 发送响应数据 \"Hello World\"\n        response.end('Hello World\\n');\n    }).listen(8888);\n    \n    // 终端打印如下信息\n    console.log('Server running at http://127.0.0.1:8888/');\n\n以上代码我们完成了一个可以工作的 HTTP 服务器。\n\n使用 node 命令执行以上的代码：\n\n    node server.js\n    Server running at http://127.0.0.1:8888/\n\n接下来，打开浏览器访问 http://127.0.0.1:8888/，你会看到一个写着 \"Hello World\"的网页。\n\n## 分析Node.js 的 HTTP 服务器：\n   \n* 第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。\n\n* 接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。\n\n\n# NPM 使用介绍\n\nNPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：\n\n* 允许用户从NPM服务器下载别人编写的第三方包到本地使用。\n\n* 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。\n\n* 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。\n\n## 查看版本\n\n    $ npm -v\n    6.10.3\n\n## 升级\n\n    $ sudo npm install npm -g\n\n如果是 Window 系统使用以下命令即可：\n\n    npm install npm -g\n使用淘宝镜像的命令：\n\n    npm install -g cnpm --registry=https://registry.npm.taobao.org\n    \n## 使用 npm 命令安装模块\nnpm 安装 Node.js 模块语法格式如下：\n\n    $ npm install <Module Name>\n以下实例，我们使用 npm 命令安装常用的 Node.js web框架模块 express:\n\n    $ npm install express\n安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 require('express') 的方式就好，无需指定第三方包路径。\n\n    var express = require('express');\n    \n## 全局安装与本地安装\nnpm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，比如\n\n    npm install express          # 本地安装\n    npm install express -g   # 全局安装\n\n如果出现以下错误：\n\n    npm err! Error: connect ECONNREFUSED 127.0.0.1:8087 \n    \n解决办法为：\n\n    $ npm config set proxy null\n\n## 本地安装\n\n* 1.将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。\n\n* 2.可以通过 require() 来引入本地安装的包。\n\n## 全局安装\n\n* 1.将安装包放在 /usr/local 下或者你 node 的安装目录。\n* 2.可以直接在命令行里使用。\n\n如果你希望具备两者功能，则需要在两个地方安装它或使用 npm link。\n接下来我们使用全局方式安装 express\n\n    $ npm install express -g\n\n## 查看安装信息\n\n你可以使用以下命令来查看所有全局安装的模块：\n    \n    $ npm list -g\n    \n    ├─┬ cnpm@4.3.2\n    │ ├── auto-correct@1.0.0\n    │ ├── bagpipe@0.3.5\n    │ ├── colors@1.1.2\n    │ ├─┬ commander@2.9.0\n    │ │ └── graceful-readlink@1.0.1\n    │ ├─┬ cross-spawn@0.2.9\n    │ │ └── lru-cache@2.7.3\n    ……\n\n如果要查看某个模块的版本号，可以使用命令如下：\n\n    $ npm list grunt\n    \n    projectName@projectVersion /path/to/project/folder\n    └── grunt@0.4.1\n    \n## 使用 package.json\npackage.json 位于模块的目录下，用于定义包的属性。接下来让我们来看下 express 包的 package.json 文件，位于 node_modules/express/package.json 内容：\n\n## Package.json 属性说明\n\n    name - 包名。\n    \n    version - 包的版本号。\n    \n    description - 包的描述。\n    \n    homepage - 包的官网 url 。\n    \n    author - 包的作者姓名。\n    \n    contributors - 包的其他贡献者姓名。\n    \n    dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。\n    \n    repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。\n    \n    main - main 字段指定了程序的主入口文件，require('moduleName') 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。\n    \n    keywords - 关键字\n    \n## 卸载模块\n\n我们可以使用以下命令来卸载 Node.js 模块。\n\n    $ npm uninstall express\n\n卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看：\n\n    $ npm ls\n    \n## 更新模块\n\n    $ npm update express\n    \n## 搜索模块\n    \n    $ npm search express\n    \n## 创建模块\n\n创建模块，package.json 文件是必不可少的。我们可以使用 NPM 生成 package.json 文件，生成的文件包含了基本的结果。\n\n    $ npm init\n    This utility will walk you through creating a package.json file.\n    It only covers the most common items, and tries to guess sensible defaults.\n    \n    See `npm help json` for definitive documentation on these fields\n    and exactly what they do.\n    \n    Use `npm install <pkg> --save` afterwards to install a package and\n    save it as a dependency in the package.json file.\n    \n    Press ^C at any time to quit.\n    name: (node_modules) runoob                   # 模块名\n    version: (1.0.0) \n    description: Node.js 测试模块(www.runoob.com)  # 描述\n    entry point: (index.js) \n    test command: make test\n    git repository: https://github.com/runoob/runoob.git  # Github 地址\n    keywords: \n    author: \n    license: (ISC) \n    About to write to ……/node_modules/package.json:      # 生成地址\n    \n    {\n      \"name\": \"runoob\",\n      \"version\": \"1.0.0\",\n      \"description\": \"Node.js 测试模块(www.runoob.com)\",\n      ……\n    }\n    \n    \n    Is this ok? (yes) yes\n    \n以上的信息，你需要根据你自己的情况输入。在最后输入 \"yes\" 后会生成 package.json 文件。\n\n接下来我们可以使用以下命令在 npm 资源库中注册用户（使用邮箱注册）：\n\n    $ npm adduser\n    Username: mcmohd\n    Password:\n    Email: (this IS public) mcmohd@gmail.com\n\n接下来我们就用以下命令来发布模块：\n\n    $ npm publish\n如果你以上的步骤都操作正确，你就可以跟其他模块一样使用 npm 来安装。\n\n## 版本号\n使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。\n\n语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。\n\n* 如果只是修复bug，需要更新Z位。\n* 如果是新增了功能，但是向下兼容，需要更新Y位。\n* 如果有大变动，向下不兼容，需要更新X位。\n\n版本号有了这个保证后，在申明第三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如\"argv\": \"0.0.x\"表示依赖于0.0.x系列的最新版argv。                    \n        \nNPM支持的所有版本号范围指定方式可以查看[官方文档](https://docs.npmjs.com/)。\n\n## NPM 常用命令\n使用npm help可查看所有命令。\n\n* NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。\n\n* 使用npm help <command>可查看某条命令的详细帮助，例如npm help install。\n\n* 在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。\n\n* 使用npm update <package>可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。\n\n* 使用npm update <package> -g可以把全局安装的对应命令行程序更新至最新版。\n\n* 使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。\n\n* 使用npm unpublish <package>@<version>可以撤销发布自己发布过的某个版本代码。\n\n## 使用淘宝 NPM 镜像\n大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。\n\n淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。\n\n你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:\n\n    $ npm install -g cnpm --registry=https://registry.npm.taobao.org\n这样就可以使用 cnpm 命令来安装模块了：\n\n    $ cnpm install [name]\n\n    \n# Node.js REPL(交互式解释器)\nNode.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。\n\nNode 自带了交互式解释器，可以执行以下任务：\n\n* 读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。\n  \n* 执行 - 执行输入的数据结构\n  \n* 打印 - 输出结果\n  \n* 循环 - 循环操作以上步骤直到用户***两次***按下  **ctrl-c**  按钮退出。\n  \nNode 的交互式解释器可以很好的调试 Javascript 代码。\n\n## 启动 Node 的终端：\n    \n    $ node\n    Welcome to Node.js v12.9.0.\n    Type \".help\" for more information.\n    >\n    \n## 简单的表达式运算\n这时我们就可以在 > 后输入简单的表达式，并按下回车键来计算结果。\n\n    $ node\n    > 1 +4\n    5\n    > 5 / 2\n    2.5\n    > 3 * 6\n    18\n    > 4 - 1\n    3\n    > 1 + ( 2 * 3 ) - 4\n    3\n    >\n## 使用变量\n你可以将数据存储在变量中，并在你需要的时候使用它。\n\n变量声明需要使用 var 关键字，如果没有使用 var 关键字变量会直接打印出来。\n\n使用 var 关键字的变量可以使用 console.log() 来输出变量。\n\n    $ node\n    > x = 10\n    10\n    > var y = 10\n    undefined\n    > x + y\n    20\n    > console.log(\"Hello World\")\n    Hello World\n    undefined\n    > console.log(\"www.runoob.com\")\n    www.runoob.com\n    undefined\n    \n## 多行表达式\nNode REPL 支持输入多行表达式，这就有点类似 JavaScript。接下来让我们来执行一个 do-while 循环：\n\n    $ node\n    > var x = 0\n    undefined\n    > do {\n    ... x++;\n    ... console.log(\"x: \" + x);\n    ... } while ( x < 5 );\n    x: 1\n    x: 2\n    x: 3\n    x: 4\n    x: 5\n    undefined\n    >\n... 三个点的符号是系统自动生成的，你回车换行后即可。Node 会自动检测是否为连续的表达式。\n    \n## 下划线(_)变量\n你可以使用下划线(_)获取上一个表达式的运算结果：\n    \n    $ node\n    > var x = 10\n    undefined\n    > var y = 20\n    undefined\n    > x + y\n    30\n    > var sum = _\n    undefined\n    > console.log(sum)\n    30\n    undefined\n    >\n    \n## REPL 命令\n\n* ctrl + c - 退出当前终端。\n  \n* ctrl + c 按下两次 - 退出 Node REPL。\n  \n* ctrl + d - 退出 Node REPL.\n  \n* 向上/向下 键 - 查看输入的历史命令\n  \n* tab 键 - 列出当前命令\n  \n* .help - 列出使用命令\n  \n* .break - 退出多行表达式\n  \n* .clear - 退出多行表达式\n  \n* .save filename - 保存当前的 Node REPL 会话到指定文件\n  \n* .load filename - 载入当前 Node REPL 会话的文件内容。\n  \n## 停止 REPL\n前面我们已经提到按下两次 ctrl + c 键就能退出 REPL:\n\n    $ node\n    >\n    (^C again to quit)\n    >      \n    \n# Node.js 回调函数\n\nNode.js 异步编程的直接体现就是回调。\n\n异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。\n\n回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。\n\n例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。\n\n回调函数一般作为函数的最后一个参数出现：\n\n    function foo1(name, age, callback) { }\n    function foo2(value, callback1, callback2) { }\n    \n## 阻塞代码实例\n    \n创建一个文件 input.txt ，内容如下：\n\n        菜鸟教程官网地址：www.runoob.com\n\n创建 main.js 文件, 代码如下：\n\n    var fs = require(\"fs\");\n    var data = fs.readFileSync('input.txt');\n    console.log(data.toString());\n    console.log(\"程序执行结束!\");\n\n以上代码执行结果如下：\n\n    $ node main.js\n    菜鸟教程官网地址：www.runoob.com\n\n    程序执行结束!\n    \n## 非阻塞代码实例\n创建一个文件 input.txt ，内容如下：\n\n    菜鸟教程官网地址：www.runoob.com\n    \n创建 main.js 文件, 代码如下：\n\n    fs.readFile('input.txt', function (err, data) {\n        if (err) return console.error(err);\n        console.log(data.toString());\n    });\n    \n    console.log(\"程序执行结束!\");\n    \n以上代码执行结果如下：\n\n    $ node main.js\n    程序执行结束!\n    菜鸟教程官网地址：www.runoob.com\n    \n以上两个实例我们了解了阻塞与非阻塞调用的不同。第一个实例在文件读取完后才执行完程序。 第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。\n\n因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。\n\n# Node.js 事件循环\n\n* Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。    \n\n* Node.js 几乎每一个 API 都是支持回调函数的。\n\n* Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。\n  \n* Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.\n  \n## 事件驱动程序\n\nNode.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。\n\n当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。\n\n这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）\n\n在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。\n\n![](https://www.runoob.com/wp-content/uploads/2015/09/event_loop.jpg)\n\n整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。\n\nNode.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：\n\n    // 引入 events 模块\n    var events = require('events');\n    // 创建 eventEmitter 对象\n    var eventEmitter = new events.EventEmitter();\n\n以下程序绑定事件处理程序：\n\n    // 绑定事件及事件的处理程序\n    eventEmitter.on('eventName', eventHandler);\n\n我们可以通过程序触发事件：\n\n    // 触发事件\n    eventEmitter.emit('eventName');\n        \n## 实例\n创建 main.js 文件，代码如下所示：\n\n    // 引入 events 模块\n    var events = require('events');\n    // 创建 eventEmitter 对象\n    var eventEmitter = new events.EventEmitter();\n    \n    // 创建事件处理程序\n    var connectHandler = function connected() {\n       console.log('连接成功。');\n      \n       // 触发 data_received 事件 \n       eventEmitter.emit('data_received');\n    } \n    \n    // 绑定 connection 事件处理程序\n    eventEmitter.on('connection', connectHandler);\n     \n    // 使用匿名函数绑定 data_received 事件\n    eventEmitter.on('data_received', function(){\n       console.log('数据接收成功。');\n    });    \n    \n    // 触发 connection 事件 \n    eventEmitter.emit('connection');\n    \n    console.log(\"程序执行完毕。\");\n\n接下来让我们执行以上代码：\n\n    $ node main.js\n    连接成功。\n    数据接收成功。\n    程序执行完毕。\n    \n## Node 应用程序是如何工作的？\n在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。\n\n接下来让我们来重新看下前面的实例，创建一个 input.txt ,文件内容如下：\n\n    菜鸟教程官网地址：www.runoob.com\n创建 main.js 文件，代码如下：\n\n    var fs = require(\"fs\");\n    \n    fs.readFile('input.txt', function (err, data) {\n       if (err){\n          console.log(err.stack);\n          return;\n       }\n       console.log(data.toString());\n    });\n    console.log(\"程序执行完毕\");\n以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。\n\n如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。\n\n执行以上代码，执行结果如下：\n    \n    程序执行完毕\n    菜鸟教程官网地址：www.runoob.com      \n接下来我们删除 input.txt 文件，执行结果如下所示：\n\n    程序执行完毕\n    Error: ENOENT, open 'input.txt'\n因为文件 input.txt 不存在，所以输出了错误信息。\n\n# Node.js EventEmitter\n          \nNode.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。\n\nNode.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。\n\n## EventEmitter 类\nevents 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。\n\n你可以通过require(\"events\");来访问该模块。\n\n    // 引入 events 模块\n    var events = require('events');\n    // 创建 eventEmitter 对象\n    var eventEmitter = new events.EventEmitter();\nEventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。\n\n### 下面我们用一个简单的例子说明 EventEmitter 的用法：\n    \n    //event.js 文件\n    var EventEmitter = require('events').EventEmitter; \n    var event = new EventEmitter(); \n    event.on('some_event', function() { \n        console.log('some_event 事件触发'); \n    }); \n    setTimeout(function() { \n        event.emit('some_event'); \n    }, 1000); \n          \n执行结果如下：\n\n运行这段代码，1 秒后控制台输出了 'some_event 事件触发'。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。\n\n    $ node event.js \n    some_event 事件触发          \nEventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。\n\n当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。\n\n让我们以下面的例子解释这个过程：\n\n    //event.js 文件\n    var events = require('events'); \n    var emitter = new events.EventEmitter(); \n    emitter.on('someEvent', function(arg1, arg2) { \n        console.log('listener1', arg1, arg2); \n    }); \n    emitter.on('someEvent', function(arg1, arg2) { \n        console.log('listener2', arg1, arg2); \n    }); \n    emitter.emit('someEvent', 'arg1 参数', 'arg2 参数'); \n    \n执行以上代码，运行的结果如下：\n\n    $ node event.js \n    listener1 arg1 参数 arg2 参数\n    listener2 arg1 参数 arg2 参数    \n\n以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。\n\n运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。\n\nEventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。\n    \n## 方法\n\n### 1. addListener(event, listener)\n为指定事件添加一个监听器到监听器数组的尾部。\n\n### 2. on(event, listener)\n为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。\n    \n    server.on('connection', function (stream) {\n      console.log('someone connected!');\n    });\n    \n### 3. once(event, listener)\n为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。\n\n    server.once('connection', function (stream) {\n      console.log('Ah, we have our first user!');\n    });\n\n### 4. removeListener(event, listener)\n移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。\n\n它接受两个参数，第一个是事件名称，第二个是回调函数名称。\n\n    var callback = function(stream) {\n      console.log('someone connected!');\n    };\n    server.on('connection', callback);\n    // ...\n    server.removeListener('connection', callback);\n    \n### 5. removeAllListeners([event])\n移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。\n\n### 6. setMaxListeners(n)\n默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。\n\n### 7. listeners(event)\n返回指定事件的监听器数组。\n\n### 8. emit(event, [arg1], [arg2], [...])\n按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。\n\n## 类方法\n### listenerCount(emitter, event)\n返回指定事件的监听器数量。\n    \n    events.EventEmitter.listenerCount(emitter, eventName) //已废弃，不推荐\n    events.emitter.listenerCount(eventName) //推荐\n    \n## 事件\n### newListener \n* event - 字符串，事件名称\n\n* listener - 处理事件函数\n\n该事件在添加新监听器时被触发。\n\n### removeListener\n* event - 字符串，事件名称\n  \n* listener - 处理事件函数\n  \n从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。\n  \n## 实例\n以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。\n\n创建 main.js 文件，代码如下：\n\n    var events = require('events');\n    var eventEmitter = new events.EventEmitter();\n    \n    // 监听器 #1\n    var listener1 = function listener1() {\n       console.log('监听器 listener1 执行。');\n    }\n    \n    // 监听器 #2\n    var listener2 = function listener2() {\n      console.log('监听器 listener2 执行。');\n    }\n    \n    // 绑定 connection 事件，处理函数为 listener1 \n    eventEmitter.addListener('connection', listener1);\n    \n    // 绑定 connection 事件，处理函数为 listener2\n    eventEmitter.on('connection', listener2);\n    \n    var eventListeners = eventEmitter.listenerCount('connection');\n    console.log(eventListeners + \" 个监听器监听连接事件。\");\n    \n    // 处理 connection 事件 \n    eventEmitter.emit('connection');\n    \n    // 移除监绑定的 listener1 函数\n    eventEmitter.removeListener('connection', listener1);\n    console.log(\"listener1 不再受监听。\");\n    \n    // 触发连接事件\n    eventEmitter.emit('connection');\n    \n    eventListeners = eventEmitter.listenerCount('connection');\n    console.log(eventListeners + \" 个监听器监听连接事件。\");\n    \n    console.log(\"程序执行完毕。\");\n\n以上代码，执行结果如下所示：\n\n    $ node main.js  \n    2 个监听器监听连接事件。\n    监听器 listener1 执行。\n    监听器 listener2 执行。\n    listener1 不再受监听。\n    监听器 listener2 执行。\n    1 个监听器监听连接事件。\n    程序执行完毕。\n## error 事件\n\nEventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。\n\n当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。\n\n我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：\n\n    var events = require('events'); \n    var emitter = new events.EventEmitter(); \n    emitter.emit('error'); \n运行时会显示以下错误：\n\n    node.js:201 \n    throw e; // process.nextTick error, or 'error' event on first tick \n    ^ \n    Error: Uncaught, unspecified 'error' event. \n    at EventEmitter.emit (events.js:50:15) \n    at Object.<anonymous> (/home/byvoid/error.js:5:9) \n    at Module._compile (module.js:441:26) \n    at Object..js (module.js:459:10) \n    at Module.load (module.js:348:31) \n    at Function._load (module.js:308:12) \n    at Array.0 (module.js:479:10) \n    at EventEmitter._tickCallback (node.js:192:40)    \n    \n## 继承 EventEmitter\n大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。\n\n为什么要这样做呢？原因有两点：\n\n首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。\n\n其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。\n\n\n# Node.js Buffer(缓冲区)\nJavaScript 语言自身只有字符串数据类型，没有二进制数据类型。\n\n但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。\n\n在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。\n\n>> 在v6.0之前创建Buffer对象直接使用new Buffer()构造函数来创建对象实例，但是Buffer对内存的权限操作相比很大，可以直接捕获一些敏感信息，所以在v6.0以后，官方文档里面建议使用 Buffer.from() 接口去创建Buffer对象。    \n\n## Buffer 与字符编码\nBuffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。\n\n    const buf = Buffer.from('runoob', 'ascii');\n    \n    // 输出 72756e6f6f62\n    console.log(buf.toString('hex'));\n    \n    // 输出 cnVub29i\n    console.log(buf.toString('base64'));\n    \nNode.js 目前支持的字符编码包括：\n\n* ascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。\n  \n* utf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。\n  \n* utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。\n  \n* ucs2 - utf16le 的别名。\n  \n* base64 - Base64 编码。\n  \n* latin1 - 一种把 Buffer 编码成一字节编码的字符串的方式。\n  \n* binary - latin1 的别名。\n  \n* hex - 将每个字节编码为两个十六进制字符。\n  \n## 创建 Buffer 类\n\nBuffer 提供了以下 API 来创建 Buffer 类：\n\n* Buffer.alloc(size[, fill[, encoding]])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0\n\n* Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据\n\n* Buffer.allocUnsafeSlow(size)\n\n* Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）\n\n* Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。\n\n* Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例\n\n* Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例\n\n    / 创建一个长度为 10、且用 0 填充的 Buffer。\n    const buf1 = Buffer.alloc(10);\n    \n    // 创建一个长度为 10、且用 0x1 填充的 Buffer。 \n    const buf2 = Buffer.alloc(10, 1);\n    \n    // 创建一个长度为 10、且未初始化的 Buffer。\n    // 这个方法比调用 Buffer.alloc() 更快，\n    // 但返回的 Buffer 实例可能包含旧数据，\n    // 因此需要使用 fill() 或 write() 重写。\n    const buf3 = Buffer.allocUnsafe(10);\n    \n    // 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。\n    const buf4 = Buffer.from([1, 2, 3]);\n    \n    // 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。\n    const buf5 = Buffer.from('tést');\n    \n    // 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。\n    const buf6 = Buffer.from('tést', 'latin1');\n    \n## 写入缓冲区\n### 语法\n    buf.write(string[, offset[, length]][, encoding])\n\n### 参数\n参数描述如下：\n\n* string - 写入缓冲区的字符串。\n\n* offset - 缓冲区开始写入的索引值，默认为 0 。\n\n* length - 写入的字节数，默认为 buffer.length\n\n* encoding - 使用的编码。默认为 'utf8' 。\n\n根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。\n\n### 返回值\n\n返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。\n\n### 实例\n    buf = Buffer.alloc(256);\n    len = buf.write(\"www.runoob.com\");\n    \n    console.log(\"写入字节数 : \"+  len);\n\n执行以上代码，输出结果为：\n\n    $node main.js\n    写入字节数 : 14\n\n## 从缓冲区读取数据\n\n### 读取 Node 缓冲区数据的语法如下所示：\n    \n    buf.toString([encoding[, start[, end]]])\n\n### 参数\n参数描述如下：\n\n* encoding - 使用的编码。默认为 'utf8' 。\n\n* start - 指定开始读取的索引位置，默认为 0。\n\n* end - 结束位置，默认为缓冲区的末尾。\n\n### 返回\n解码缓冲区数据并使用指定的编码返回字符串。\n\n### 实例\n\n    buf = Buffer.alloc(26);\n    for (var i = 0 ; i < 26 ; i++) {\n      buf[i] = i + 97;\n    }\n    \n    console.log( buf.toString('ascii'));       // 输出: abcdefghijklmnopqrstuvwxyz\n    console.log( buf.toString('ascii',0,5));   // 输出: abcde\n    console.log( buf.toString('utf8',0,5));    // 输出: abcde\n    console.log( buf.toString(undefined,0,5)); // 使用 'utf8' 编码, 并输出: abcde\n    \n执行以上代码，输出结果为：\n\n    $ node main.js\n    abcdefghijklmnopqrstuvwxyz\n    abcde\n    abcde\n    abcde\n\n## 将 Buffer 转换为 JSON 对象\n\n### 语法\n\n    buf.toJSON()\n\n当字符串化一个 Buffer 实例时，JSON.stringify() 会隐式地调用该 toJSON()。\n\n### 返回值\n\n返回 JSON 对象。\n\n### 实例\n\n    const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);\n    const json = JSON.stringify(buf);\n    \n    // 输出: {\"type\":\"Buffer\",\"data\":[1,2,3,4,5]}\n    console.log(json);\n    \n    const copy = JSON.parse(json, (key, value) => {\n      return value && value.type === 'Buffer' ?\n        Buffer.from(value.data) :\n        value;\n    });\n    \n    // 输出: <Buffer 01 02 03 04 05>\n    console.log(copy);\n\n执行以上代码，输出结果为：\n\n    {\"type\":\"Buffer\",\"data\":[1,2,3,4,5]}\n    <Buffer 01 02 03 04 05>\n    \n## 缓冲区合并\n\n### 语法\n\n    Buffer.concat(list[, totalLength])\n\n### 参数\n参数描述如下：\n\n* list - 用于合并的 Buffer 对象数组列表。\n\n* totalLength - 指定合并后Buffer对象的总长度。\n\n### 返回值\n\n返回一个多个成员合并的新 Buffer 对象。\n\n### 实例\n\n    var buffer1 = Buffer.from(('菜鸟教程'));\n    var buffer2 = Buffer.from(('www.runoob.com'));\n    var buffer3 = Buffer.concat([buffer1,buffer2]);\n    console.log(\"buffer3 内容: \" + buffer3.toString());\n\n执行以上代码，输出结果为：\n\n    buffer3 内容: 菜鸟教程www.runoob.com\n\n## 缓冲区比较\n\n### 语法\nNode Buffer 比较的函数语法如下所示, 该方法在 Node.js v0.12.2 版本引入    \n    \n    buf.compare(otherBuffer);\n\n### 参数\n参数描述如下：\n\n* otherBuffer - 与 buf 对象比较的另外一个 Buffer 对象。\n\n### 返回值\n\n返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。\n\n### 实例 \n    \n    var buffer1 = Buffer.from('ABC');\n    var buffer2 = Buffer.from('ABCD');\n    var result = buffer1.compare(buffer2);\n    \n    if(result < 0) {\n       console.log(buffer1 + \" 在 \" + buffer2 + \"之前\");\n    }else if(result == 0){\n       console.log(buffer1 + \" 与 \" + buffer2 + \"相同\");\n    }else {\n       console.log(buffer1 + \" 在 \" + buffer2 + \"之后\");\n    }\n\n执行以上代码，输出结果为：\n\n    ABC在ABCD之前\n\n## 拷贝缓冲区\n\n### 语法\n    buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])\n\n* targetBuffer - 要拷贝的 Buffer 对象。\n\n* targetStart - 数字, 可选, 默认: 0\n\n* sourceStart - 数字, 可选, 默认: 0\n\n* sourceEnd - 数字, 可选, 默认: buffer.length\n\n### 返回值\n没有返回值。\n\n### 实例\n\n    var buf1 = Buffer.from('abcdefghijkl');\n    var buf2 = Buffer.from('RUNOOB');\n    \n    //将 buf2 插入到 buf1 指定位置上\n    buf2.copy(buf1, 2);\n    \n    console.log(buf1.toString());\n\n执行以上代码，输出结果为：\n\n    abRUNOOBijkl\n\n## 缓冲区裁剪\nNode 缓冲区裁剪语法如下所示：\n\n    buf.slice([start[, end]])\n   \n参数\n参数描述如下：\n\n* start - 数字, 可选, 默认: 0\n\n* end - 数字, 可选, 默认: buffer.length\n\n返回值\n返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。\n\n实例\n\n    var buffer1 = Buffer.from('runoob');\n    // 剪切缓冲区\n    var buffer2 = buffer1.slice(0,2);\n    console.log(\"buffer2 content: \" + buffer2.toString());\n    执行\n\n执行以上代码，输出结果为：\n\n    buffer2 content: ru\n    \n## 缓冲区长度\n    \n    buf.length;\n返回值\n返回 Buffer 对象所占据的内存长度。\n\n实例\n    \n    var buffer = Buffer.from('www.runoob.com');\n    //  缓冲区长度\n    console.log(\"buffer length: \" + buffer.length);\n\n执行以上代码，输出结果为：\n\n    buffer length: 14\n\n\n# Node.js Stream(流)\nStream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。\n\nNode.js，Stream 有四种流类型：\n\n* Readable - 可读操作。\n\n* Writable - 可写操作。\n  \n* Duplex - 可读可写操作.\n  \n* Transform - 操作被写入数据，然后读出结果。\n  \n所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：\n\n* data - 当有数据可读时触发。\n  \n* end - 没有更多的数据可读时触发。\n  \n* error - 在接收和写入过程中发生错误时触发。\n  \n* finish - 所有数据已被写入到底层系统时触发。\n  \n## 从流中读取数据\n  \n创建 input.txt 文件，内容如下：\n\n    菜鸟教程官网地址：www.runoob.com\n\n    var fs = require(\"fs\");\n    var data = '';\n    \n    // 创建可读流\n    var readerStream = fs.createReadStream('input.txt');\n    \n    // 设置编码为 utf8。\n    readerStream.setEncoding('UTF8');\n    \n    // 处理流事件 --> data, end, and error\n    readerStream.on('data', function(chunk) {\n       data += chunk;\n    });\n    \n    readerStream.on('end',function(){\n       console.log(data);\n    });\n    \n    readerStream.on('error', function(err){\n       console.log(err.stack);\n    });\n    \n    console.log(\"程序执行完毕\");\n\n以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下：\n\n    $ node main.js \n    程序执行完毕\n    写入完成。\n\n查看 output.txt 文件的内容：\n\n    $ cat output.txt \n    菜鸟教程官网地址：www.runoob.com\n    \n## 管道流\n管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。    \n    \n设置 input.txt 文件内容如下：\n    \n    菜鸟教程官网地址：www.runoob.com\n    管道流操作实例\n\n创建 main.js 文件, 代码如下：\n\n    var fs = require(\"fs\");\n    \n    // 创建一个可读流\n    var readerStream = fs.createReadStream('input.txt');\n    \n    // 创建一个可写流\n    var writerStream = fs.createWriteStream('output.txt');\n    \n    // 管道读写操作\n    // 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中\n    readerStream.pipe(writerStream);\n    \n    console.log(\"程序执行完毕\");\n\n代码执行结果如下：\n\n    $ node main.js \n    程序执行完毕\n\n查看 output.txt 文件的内容：\n\n    $ cat output.txt \n    菜鸟教程官网地址：www.runoob.com\n    管道流操作实例\n    \n##     链式流\n链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。\n\n接下来我们就是用管道和链式来压缩和解压文件。\n\n创建 compress.js 文件, 代码如下：\n    \n    var fs = require(\"fs\");\n    var zlib = require('zlib');\n    \n    // 压缩 input.txt 文件为 input.txt.gz\n    fs.createReadStream('input.txt')\n      .pipe(zlib.createGzip())\n      .pipe(fs.createWriteStream('input.txt.gz'));\n      \n    console.log(\"文件压缩完成。\");\n    \n代码执行结果如下：\n\n    $ node compress.js \n    文件压缩完成。\n\n执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。\n\n接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下：\n\n    var fs = require(\"fs\");\n    var zlib = require('zlib');\n    \n    // 解压 input.txt.gz 文件为 input.txt\n    fs.createReadStream('input.txt.gz')\n      .pipe(zlib.createGunzip())\n      .pipe(fs.createWriteStream('input.txt'));\n      \n    console.log(\"文件解压完成。\");\n    \n代码执行结果如下：\n\n    $ node decompress.js \n    文件解压完成。\n\n# Node.js模块系统\n\n为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。\n\n模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。\n\n\n## 创建模块\n\n在 Node.js 中，创建一个模块非常简单，如下我们创建一个 main.js 文件，代码如下:\n\n    var hello = require('./hello');\n    hello.world();\n\n以上实例中，代码 require('./hello') 引入了当前目录下的 hello.js 文件（./ 为当前目录，node.js 默认后缀为 js）。\n\nNode.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。\n\n接下来我们就来创建 hello.js 文件，代码如下：\n\n    exports.world = function() {\n      console.log('Hello World');\n    }\n\n在以上示例中，hello.js 通过 exports 对象把 world 作为模块的访问接口，在 main.js 中通过 require('./hello') 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。\n\n有时候我们只是想把一个对象封装到模块中，格式如下：\n    \n    module.exports = function() {\n      // ...\n    }\n例如:\n\n    //hello.js \n    function Hello() { \n        var name; \n        this.setName = function(thyName) { \n            name = thyName; \n        }; \n        this.sayHello = function() { \n            console.log('Hello ' + name); \n        }; \n    }; \n    module.exports = Hello;\n    \n这样就可以直接获得这个对象了：\n\n    //main.js \n    var Hello = require('./hello'); \n    hello = new Hello(); \n    hello.setName('BYVoid'); \n    hello.sayHello(); \n    \n模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。    \n\n## 服务端的模块放在哪里\n\n也许你已经注意到，我们已经在代码中使用了模块了。像这样：\n\n    var http = require(\"http\");\n    \n    ...\n    \n    http.createServer(...);\n    \nNode.js 中自带了一个叫做 http 的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。\n\n这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。\n\nNode.js 的 require 方法中的文件查找策略如下：\n\n由于 Node.js 中存在 4 类模块（原生模块和3种文件模块），尽管 require 方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。如下图所示：    \n\n![](https://www.runoob.com/wp-content/uploads/2014/03/nodejs-require.jpg)\n\n## 从文件模块缓存中加载\n\n尽管原生模块与文件模块的优先级不同，但是都会优先从文件模块的缓存中加载已经存在的模块。\n\n## 从原生模块加载\n\n原生模块的优先级仅次于文件模块缓存的优先级。require 方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个 http/http.js/http.node/http.json 文件，require(\"http\") 都不会从这些文件中加载，而是从原生模块中加载。\n\n原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。\n\n## 从文件加载\n\n当文件模块缓存中不存在，而且不是原生模块的时候，Node.js 会解析 require 方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。\n\nrequire方法接受以下几种参数的传递：    \n    \n* http、fs、path等，原生模块。\n\n* ./mod或../mod，相对路径的文件模块。\n\n* /pathtomodule/mod，绝对路径的文件模块。\n\n* mod，非原生模块的文件模块。\n\n在路径 Y 下执行 require(X) 语句执行顺序：\n\n    1. 如果 X 是内置模块\n       a. 返回内置模块\n       b. 停止执行\n    2. 如果 X 以 '/' 开头\n       a. 设置 Y 为文件根路径\n    3. 如果 X 以 './' 或 '/' or '../' 开头\n       a. LOAD_AS_FILE(Y + X)\n       b. LOAD_AS_DIRECTORY(Y + X)\n    4. LOAD_NODE_MODULES(X, dirname(Y))\n    5. 抛出异常 \"not found\"\n    \n    LOAD_AS_FILE(X)\n    1. 如果 X 是一个文件, 将 X 作为 JavaScript 文本载入并停止执行。\n    2. 如果 X.js 是一个文件, 将 X.js 作为 JavaScript 文本载入并停止执行。\n    3. 如果 X.json 是一个文件, 解析 X.json 为 JavaScript 对象并停止执行。\n    4. 如果 X.node 是一个文件, 将 X.node 作为二进制插件载入并停止执行。\n    \n    LOAD_INDEX(X)\n    1. 如果 X/index.js 是一个文件,  将 X/index.js 作为 JavaScript 文本载入并停止执行。\n    2. 如果 X/index.json 是一个文件, 解析 X/index.json 为 JavaScript 对象并停止执行。\n    3. 如果 X/index.node 是一个文件,  将 X/index.node 作为二进制插件载入并停止执行。\n    \n    LOAD_AS_DIRECTORY(X)\n    1. 如果 X/package.json 是一个文件,\n       a. 解析 X/package.json, 并查找 \"main\" 字段。\n       b. let M = X + (json main 字段)\n       c. LOAD_AS_FILE(M)\n       d. LOAD_INDEX(M)\n    2. LOAD_INDEX(X)\n    \n    LOAD_NODE_MODULES(X, START)\n    1. let DIRS=NODE_MODULES_PATHS(START)\n    2. for each DIR in DIRS:\n       a. LOAD_AS_FILE(DIR/X)\n       b. LOAD_AS_DIRECTORY(DIR/X)\n    \n    NODE_MODULES_PATHS(START)\n    1. let PARTS = path split(START)\n    2. let I = count of PARTS - 1\n    3. let DIRS = []\n    4. while I >= 0,\n       a. if PARTS[I] = \"node_modules\" CONTINUE\n       b. DIR = path join(PARTS[0 .. I] + \"node_modules\")\n       c. DIRS = DIRS + DIR\n       d. let I = I - 1\n    5. return DIRS\n    \nexports 和 module.exports 的使用\n\n如果要对外暴露属性或方法，就用 exports 就行，要暴露对象(类似class，包含了很多属性和方法)，就用 module.exports。    \n\n# Node.js 函数\n在JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。\n\nNode.js中函数的使用与Javascript类似，举例来说，你可以这样做：\n    \n    function say(word) {\n      console.log(word);\n    }\n    \n    function execute(someFunction, value) {\n      someFunction(value);\n    }\n    \n    execute(say, \"Hello\");\n\n以上代码中，我们把 say 函数作为execute函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！\n\n这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。\n\n当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。\n\n## 匿名函数\n\n我们可以把一个函数作为变量传递。但是我们不一定要绕这个\"先定义，再传递\"的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：\n\n    function execute(someFunction, value) {\n      someFunction(value);\n    }\n    \n我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。\n\n用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做匿名函数 。\n\n## 函数传递是如何让HTTP服务器工作的\n带着这些知识，我们再来看看我们简约而不简单的HTTP服务器：\n\n    var http = require(\"http\");\n    \n    http.createServer(function(request, response) {\n      response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n      response.write(\"Hello World\");\n      response.end();\n    }).listen(8888);\n\n现在它看上去应该清晰了很多：我们向 createServer 函数传递了一个匿名函数。\n\n用这样的代码也可以达到同样的目的：\n\n    var http = require(\"http\");\n    \n    function onRequest(request, response) {\n      response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n      response.write(\"Hello World\");\n      response.end();\n    }\n    \n    http.createServer(onRequest).listen(8888);\n\n# Node.js 路由\n我们要为路由提供请求的 URL 和其他需要的 GET 及 POST 参数，随后路由需要根据这些数据来执行相应的代码。\n\n因此，我们需要查看 HTTP 请求，从中提取出请求的 URL 以及 GET/POST 参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。\n\n我们需要的所有数据都会包含在 request 对象中，该对象作为 onRequest() 回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的 Node.JS 模块，它们分别是 url 和 querystring 模块。\n\n    url.parse(string).query\n                                               |\n               url.parse(string).pathname      |\n                           |                   |\n                           |                   |\n                         ------ -------------------\n    http://localhost:8888/start?foo=bar&hello=world\n                                    ---       -----\n                                     |          |\n                                     |          |\n                  querystring.parse(queryString)[\"foo\"]    |\n                                                |\n                             querystring.parse(queryString)[\"hello\"]\n\n当然我们也可以用 querystring 模块来解析 POST 请求体中的参数，稍后会有演示。\n\n现在我们来给 onRequest() 函数加上一些逻辑，用来找出浏览器请求的 URL 路径：\n\n**server.js 文件代码：**\n\n    var http = require(\"http\");\n    var url = require(\"url\");\n     \n    function start() {\n      function onRequest(request, response) {\n        var pathname = url.parse(request.url).pathname;\n        console.log(\"Request for \" + pathname + \" received.\");\n        response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n        response.write(\"Hello World\");\n        response.end();\n      }\n     \n      http.createServer(onRequest).listen(8888);\n      console.log(\"Server has started.\");\n    }\n     \n    exports.start = start;\n\n好了，我们的应用现在可以通过请求的 URL 路径来区别不同请求了--这使我们得以使用路由（还未完成）来将请求以 URL 路径为基准映射到处理程序上。\n\n在我们所要构建的应用中，这意味着来自 /start 和 /upload 的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。\n\n现在我们可以来编写路由了，建立一个名为 router.js 的文件，添加以下内容：\n**router.js**\n    \n    function route(pathname) {\n      console.log(\"About to route a request for \" + pathname);\n    }\n     \n    exports.route = route;\n\n如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。\n\n我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块。\n\n首先，我们来扩展一下服务器的 start() 函数，以便将路由函数作为参数传递过去，server.js 文件代码如下\n    \n    var http = require(\"http\");\n    var url = require(\"url\");\n     \n    function start(route) {\n      function onRequest(request, response) {\n        var pathname = url.parse(request.url).pathname;\n        console.log(\"Request for \" + pathname + \" received.\");\n     \n        route(pathname);\n     \n        response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n        response.write(\"Hello World\");\n        response.end();\n      }\n     \n      http.createServer(onRequest).listen(8888);\n      console.log(\"Server has started.\");\n    }\n     \n    exports.start = start;\n    \n同时，我们会相应扩展 index.js，使得路由函数可以被注入到服务器中：\n\n**index.js 文件代码：**\n\n    var server = require(\"./server\");\n    var router = require(\"./router\");\n     \n    server.start(router.route);\n\n在这里，我们传递的函数依旧什么也没做。\n\n如果现在启动应用（node index.js，始终记得这个命令行），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：\n\n    $ node index.js\n    Server has started.        \n\n    以上输出已经去掉了比较烦人的 /favicon.ico 请求相关的部分。\n    \n    浏览器访问 http://127.0.0.1:8888/，输出结果如下：\n\n# Node.js 全局对象\navaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。\n\n在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。\n\n在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。\n\n## 全局对象与全局变量\nglobal 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量：\n\n* 在最外层定义的变量；\n\n* 全局对象的属性；\n\n* 隐式定义的变量（未定义直接赋值的变量）。\n\n你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注 意的是，在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。\n\n注意： 最好不要使用 var 定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险。\n\n## __filename\n\n_filename 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。\n\n**实例**\n创建文件 main.js ，代码如下所示：\n\n    // 输出全局变量 __filename 的值\n    console.log( __filename );\n执行 main.js 文件，代码如下所示:\n\n    $ node main.js\n    /web/com/runoob/nodejs/main.js\n    \n## __dirname\n    \n__dirname 表示当前执行脚本所在的目录。\n\n**实例**    \n\n创建文件 main.js ，代码如下所示：\n\n    // 输出全局变量 __dirname 的值\n    console.log( __dirname );\n执行 main.js 文件，代码如下所示:\n    \n    $ node main.js\n    /web/com/runoob/nodejs\n    \n## setTimeout(cb, ms)\nsetTimeout(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout() 只执行一次指定函数。\n\n返回一个代表定时器的句柄值。\n\n**实例**    \n\n创建文件 main.js ，代码如下所示：\n\n    function printHello(){\n       console.log( \"Hello, World!\");\n    }\n    // 两秒后执行以上函数\n    setTimeout(printHello, 2000);\n\n执行 main.js 文件，代码如下所示:\n\n    $ node main.js\n    Hello, World!    \n    \n## clearTimeout(t)\n    \nclearTimeout( t ) 全局函数用于停止一个之前通过 setTimeout() 创建的定时器。 参数 t 是通过 setTimeout() 函数创建的定时器。    \n\n实例\n创建文件 main.js ，代码如下所示：\n\n    function printHello(){\n       console.log( \"Hello, World!\");\n    }\n    // 两秒后执行以上函数\n    var t = setTimeout(printHello, 2000);\n    \n    // 清除定时器\n    clearTimeout(t);\n    \n执行 main.js 文件，代码如下所示:\n\n    $ node main.js    \n\n## setInterval(cb, ms)\nsetInterval(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。\n\n返回一个代表定时器的句柄值。可以使用 clearInterval(t) 函数来清除定时器。\n\nsetInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。\n\n实例\n创建文件 main.js ，代码如下所示：\n\n    function printHello(){\n       console.log( \"Hello, World!\");\n    }\n    // 两秒后执行以上函数\n    setInterval(printHello, 2000);\n    \n执行 main.js 文件，代码如下所示:\n\n    $ node main.js\n    Hello, World!\n    Hello, World!\n    Hello, World!\n    Hello, World!\n    Hello, World!\n    Hello, World!\n    Hello, World!\n\n以上程序每隔两秒就会输出一次\"Hello, World!\"，且会永久执行下去，直到你按下 ctrl + c 按钮。\n\n## console\nconsole 用于提供控制台标准输出，它是由 Internet Explorer 的 JScript 引擎提供的调试工具，后来逐渐成为浏览器的实施标准。\n\nNode.js 沿用了这个标准，提供与习惯行为一致的 console 对象，用于向标准输出流（stdout）或标准错误流（stderr）输出字符。\n\n### console.log([data][, ...])\n向标准输出流打印字符并以换行符结束。该方法接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。\n\n### console.info([data][, ...])\n该命令的作用是返回信息性消息，这个命令与console.log差别并不大，除了在chrome中只会输出文字外，其余的会显示一个蓝色的惊叹号。\n\n### console.error([data][, ...])\n输出错误消息的。控制台在出现错误时会显示是红色的叉子。\n\n### console.warn([data][, ...])\n输出警告消息。控制台出现有黄色的惊叹号。\n\n### console.dir(obj[, options])\n用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。\n\n### console.time(label)\n输出时间，表示计时开始。\n\n### console.timeEnd(label)\n结束时间，表示计时结束。\n\n### console.trace(message[, ...])\n当前执行的代码在堆栈中的调用路径，这个测试函数运行很有帮助，只要给想测试的函数里面加入 console.trace 就行了。\n\n### console.assert(value[, message][, ...])\n用于判断某个表达式或变量是否为真，接收两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。\n\nconsole.log()：向标准输出流打印字符并以换行符结束。\nconsole.log 接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。\n\n第一个参数是一个字符串，如果没有 参数，只打印一个换行。\n\n\n    console.log('Hello world'); \n    console.log('byvoid%diovyb'); \n    console.log('byvoid%diovyb', 1991); \n    运行结果为：\n    \n    Hello world \n    byvoid%diovyb \n    byvoid1991iovyb \n    \n    console.error()：与console.log() 用法相同，只是向标准错误流输出。\n    console.trace()：向标准错误流输出当前的调用栈。\n\n    console.trace();\n    \n    运行结果为：\n    \n    Trace: \n    at Object.<anonymous> (/home/byvoid/consoletrace.js:1:71) \n    at Module._compile (module.js:441:26) \n    at Object..js (module.js:459:10) \n    at Module.load (module.js:348:31) \n    at Function._load (module.js:308:12) \n    at Array.0 (module.js:479:10) \n    at EventEmitter._tickCallback (node.js:192:40)\n\n    console.info(\"程序开始执行：\");\n    \n    var counter = 10;\n    console.log(\"计数: %d\", counter);\n    \n    console.time(\"获取数据\");\n    //\n    // 执行一些代码\n    // \n    console.timeEnd('获取数据');\n    \n    console.info(\"程序执行完毕。\")\n\n    程序开始执行：\n    计数: 10\n    获取数据: 0ms\n    程序执行完毕\n\n## process\nprocess 是一个全局变量，即 global 对象的属性。\n\n它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要 和它打交道。下面将会介绍 process 对象的一些最常用的成员方法。\n\n### exit\n当进程准备退出时触发。\n\n### beforeExit\n当 node 清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时 node 退出，但是 'beforeExit' 的监听器可以异步调用，这样 node 就会继续执行。\n\n### uncaughtException\n当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。\n\n### Signal 事件\n当进程接收到信号时就触发。信号列表详见标准的 POSIX 信号名，如 SIGINT、SIGUSR1 等。\n\n### 实例 ###\n\n创建文件 main.js ，代码如下所示：\n\n    process.on('exit', function(code) {\n    \n      // 以下代码永远不会执行\n      setTimeout(function() {\n        console.log(\"该代码不会执行\");\n      }, 0);\n      \n      console.log('退出码为:', code);\n    });\n    console.log(\"程序执行结束\");\n\n执行 main.js 文件，代码如下所示:\n\n    $ node main.js\n    程序执行结束\n    退出码为: 0\n\n### 退出状态码\n| 状态码 | 名称&描述 |\n| :-- | :-- |\n| 1 | Uncaught Fatal Exception <br> 有未捕获异常，并且没有被域或 uncaughtException 处理函数处理。|\n| 2 | Unused <br> 保留 | \n| 3 | Internal JavaScript Parse Error  <br> JavaScript的源码启动 Node 进程时引起解析错误。非常罕见，仅会在开发 Node 时才会有。 | \n| 4 | Internal JavaScript Evaluation Failure  <br> JavaScript 的源码启动 Node 进程，评估时返回函数失败。非常罕见，仅会在开发 Node 时才会有。| \n| 5 | Fatal Error  <br> V8 里致命的不可恢复的错误。通常会打印到 stderr ，内容为： FATAL ERROR | \n| 6 | Non-function Internal Exception Handler  <br> 未捕获异常，内部异常处理函数不知为何设置为on-function，并且不能被调用。| \n| 7 | Internal Exception Handler Run-Time Failure  <br> 未捕获的异常， 并且异常处理函数处理时自己抛出了异常。例如，如果 process.on('uncaughtException') 或 domain.on('error') 抛出了异常。 | \n| 8 | Unused  <br> 保留 | \n| 9 | Invalid Argument  <br> 可能是给了未知的参数，或者给的参数没有值。| \n| 10 | Internal JavaScript Run-Time Failure  <br> JavaScript的源码启动 Node 进程时抛出错误，非常罕见，仅会在开发 Node 时才会有。 | \n| 12 | Invalid Debug Argument   <br> 设置了参数--debug 和/或 --debug-brk，但是选择了错误端口。 | \n| 128 | Signal Exits  <br> 如果 Node 接收到致命信号，比如SIGKILL 或 SIGHUP，那么退出代码就是128 加信号代码。这是标准的 Unix 做法，退出信号代码放在高位。 | \n\n### Process 属性\nProcess 提供了很多有用的属性，便于我们更好的控制系统的交互：\n\n|序号|属性&描述|\n|:--| :-- |\n|1| stdout <br> 标准输出流。|\n|2| stderr <br> 标准错误流。|\n|3| stdin <br> 标准输入流。|\n|4| argv <br> argv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。|\n|5| execPath <br> 返回执行当前脚本的 Node 二进制文件的绝对路径。|\n|6| execArgv <br> 返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。|\n|7| env <br> 返回一个对象，成员为当前 shell 的环境变量|\n|8| exitCode <br> 进程退出时的代码，如果进程优通过 process.exit() 退出，不需要指定退出码。|\n|9| version <br> Node 的版本，比如v0.10.18。|\n|10| versions <br> 一个属性，包含了 node 的版本和依赖.|\n|11| config <br> 一个包含用来编译当前 node 执行文件的 javascript 配置选项的对象。它与运行 ./configure 脚本生成的 \"config.gypi\" 文件相同。|\n|12| pid <br> 当前进程的进程号。|\n|13| title <br> 进程名，默认值为\"node\"，可以自定义该值。|\n|14| arch <br> 当前 CPU 的架构：'arm'、'ia32' 或者 'x64'。|\n|15| platform <br> 运行程序所在的平台系统 'darwin', 'freebsd', 'linux', 'sunos' 或 'win32'|\n|16| mainModule<br> require.main 的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。|\n\n***实例***\n创建文件 main.js ，代码如下所示：\n\n    // 输出到终端\n    process.stdout.write(\"Hello World!\" + \"\\n\");\n    \n    // 通过参数读取\n    process.argv.forEach(function(val, index, array) {\n       console.log(index + ': ' + val);\n    });\n    \n    // 获取执行路径\n    console.log(process.execPath);\n    \n    \n    // 平台信息\n    console.log(process.platform);\n\n执行 main.js 文件，代码如下所示:\n\n    $ node main.js\n    Hello World!\n    0: node\n    1: /web/www/node/main.js\n    /usr/local/node/0.10.36/bin/node\n    darwin\n\n**方法参考手册**\nProcess 提供了很多有用的方法，便于我们更好的控制系统的交互：\n\n|序号|方法 & 描述|\n|:--|:--|\n|1| abort() <br> 这将导致node触发abort事件。会让node退出并生成一个核心文件 |\n|2| chdir(directory) <br> 改变当前工作进程的目录，如果操作失败抛出异常。 |\n|3| cwd() <br> 返回当前进程的工作目录 |\n|4| exit([code]) <br> 使用指定的 code 结束进程。如果忽略，将会使用 code 0。 |\n|5| getgid() <br> 取进程的群组标识（参见 getgid(2)）。获取到得时群组的数字 id，而不是名字. 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。 |\n|6| setgid(id) <br> 设置进程的群组标识（参见 setgid(2)）。可以接收数字 ID 或者群组名。如果指定了群组名，会阻塞等待解析为数字 ID 。                    注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。 |\n|7| getuid() <br> 获取进程的用户标识(参见 getuid(2))。这是数字的用户 id，不是用户名。                  注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。 |\n|8| setuid(id) <br> 设置进程的用户标识（参见setuid(2)）。接收数字 ID或字符串名字。果指定了群组名，会阻塞等待解析为数字 ID 。                    注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。 |\n|9| getgroups() <br> 返回进程的群组 iD 数组。POSIX 系统没有保证一定有，但是 node.js 保证有。                     注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。 |\n|10| setgroups(groups) <br> 设置进程的群组 ID。这是授权操作，所以你需要有 root 权限，或者有 CAP_SETGID 能力。                            注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。 |\n|11| initgroups(user, extra_group) <br> 读取 /etc/group ，并初始化群组访问列表，使用成员所在的所有群组。这是授权操作，所以你需要有 root 权限，或者有 CAP_SETGID 能力。                                        注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。 |\n|12| kill(pid[, signal]) <br> 发送信号给进程. pid 是进程id，并且 signal 是发送的信号的字符串描述。信号名是字符串，比如 'SIGINT' 或 'SIGHUP'。如果忽略，信号会是 'SIGTERM'。 |\n|13| memoryUsage() <br> 返回一个对象，描述了 Node 进程所用的内存状况，单位为字节。 |\n|14| nextTick(callback) <br> 一旦当前事件循环结束，调用回调函数。 |\n|15| umask([mask]) <br> 设置或读取进程文件的掩码。子进程从父进程继承掩码。如果mask 参数有效，返回旧的掩码。否则，返回当前掩码。 |\n|16| uptime() <br> 返回 Node 已经运行的秒数。 |\n|17| hrtime() <br> 返回当前进程的高分辨时间，形式为 [seconds, nanoseconds]数组。它是相对于过去的任意事件。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。                   你可以将之前的结果传递给当前的 process.hrtime() ，会返回两者间的时间差，用来基准和测量时间间隔。 |\n\n## 实例\n\n创建文件 main.js ，代码如下所示：\n\n    // 输出当前目录\n    console.log('当前目录: ' + process.cwd());\n    \n    // 输出当前版本\n    console.log('当前版本: ' + process.version);\n    \n    // 输出内存使用情况\n    console.log(process.memoryUsage());\n\n执行 main.js 文件，代码如下所示:\n\n    $ node main.js\n    当前目录: /web/com/runoob/nodejs\n    当前版本: v0.10.36\n    { rss: 12541952, heapTotal: 4083456, heapUsed: 2157056 }\n\n\n#  Node.js 常用工具\nutil 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。\n\nutil.inherits\nutil.inherits(constructor, superConstructor) 是一个实现对象间原型继承的函数。\n\nJavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有提供对象继承的语言级别特性，而是通过原型复制来实现的。\n\n在这里我们只介绍 util.inherits 的用法，示例如下\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    \n   ","slug":"node-js教程","published":1,"updated":"2019-09-27T08:27:08.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck139cehn0027ojfyfta52rev","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><ul>\n<li><p>简单的说 Node.js 就是运行在服务端的 JavaScript。</p>\n</li>\n<li><p>Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。</p>\n</li>\n<li><p>Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</p>\n</li>\n</ul>\n<h2 id=\"查看版本\"><a href=\"#查看版本\" class=\"headerlink\" title=\"查看版本\"></a>查看版本</h2><pre><code>node -v\nv12.9.0</code></pre><h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h2><p>   vim helloWorld.js</p>\n<p>   console.log(“Hello World”);</p>\n<p>   node helloWorld.js</p>\n<h2 id=\"交互模式\"><a href=\"#交互模式\" class=\"headerlink\" title=\"交互模式\"></a>交互模式</h2><pre><code>$ node\n&gt; console.log(&apos;Hello World!&apos;);\nHello World!</code></pre><h1 id=\"Node-js-安装配置\"><a href=\"#Node-js-安装配置\" class=\"headerlink\" title=\"Node.js 安装配置\"></a>Node.js 安装配置</h1><pre><code>Mac安装\nbrew install node</code></pre><h1 id=\"Node-js-创建第一个应用\"><a href=\"#Node-js-创建第一个应用\" class=\"headerlink\" title=\"Node.js 创建第一个应用\"></a>Node.js 创建第一个应用</h1><h2 id=\"步骤一、引入-required-模块\"><a href=\"#步骤一、引入-required-模块\" class=\"headerlink\" title=\"步骤一、引入 required 模块\"></a>步骤一、引入 required 模块</h2><p>我们使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下:</p>\n<pre><code>var http = require(&quot;http&quot;);</code></pre><h2 id=\"步骤二、创建服务器\"><a href=\"#步骤二、创建服务器\" class=\"headerlink\" title=\"步骤二、创建服务器\"></a>步骤二、创建服务器</h2><p>接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。</p>\n<p>实例如下，在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：</p>\n<pre><code>var http = require(&apos;http&apos;);\nhttp.createServer(function (request, response) {\n\n    // 发送 HTTP 头部 \n    // HTTP 状态值: 200 : OK\n    // 内容类型: text/plain\n    response.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;});\n\n    // 发送响应数据 &quot;Hello World&quot;\n    response.end(&apos;Hello World\\n&apos;);\n}).listen(8888);\n\n// 终端打印如下信息\nconsole.log(&apos;Server running at http://127.0.0.1:8888/&apos;);</code></pre><p>以上代码我们完成了一个可以工作的 HTTP 服务器。</p>\n<p>使用 node 命令执行以上的代码：</p>\n<pre><code>node server.js\nServer running at http://127.0.0.1:8888/</code></pre><p>接下来，打开浏览器访问 <a href=\"http://127.0.0.1:8888/，你会看到一个写着\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8888/，你会看到一个写着</a> “Hello World”的网页。</p>\n<h2 id=\"分析Node-js-的-HTTP-服务器：\"><a href=\"#分析Node-js-的-HTTP-服务器：\" class=\"headerlink\" title=\"分析Node.js 的 HTTP 服务器：\"></a>分析Node.js 的 HTTP 服务器：</h2><ul>\n<li><p>第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。</p>\n</li>\n<li><p>接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。</p>\n</li>\n</ul>\n<h1 id=\"NPM-使用介绍\"><a href=\"#NPM-使用介绍\" class=\"headerlink\" title=\"NPM 使用介绍\"></a>NPM 使用介绍</h1><p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p>\n<ul>\n<li><p>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</p>\n</li>\n<li><p>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</p>\n</li>\n<li><p>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</p>\n</li>\n</ul>\n<h2 id=\"查看版本-1\"><a href=\"#查看版本-1\" class=\"headerlink\" title=\"查看版本\"></a>查看版本</h2><pre><code>$ npm -v\n6.10.3</code></pre><h2 id=\"升级\"><a href=\"#升级\" class=\"headerlink\" title=\"升级\"></a>升级</h2><pre><code>$ sudo npm install npm -g</code></pre><p>如果是 Window 系统使用以下命令即可：</p>\n<pre><code>npm install npm -g</code></pre><p>使用淘宝镜像的命令：</p>\n<pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><h2 id=\"使用-npm-命令安装模块\"><a href=\"#使用-npm-命令安装模块\" class=\"headerlink\" title=\"使用 npm 命令安装模块\"></a>使用 npm 命令安装模块</h2><p>npm 安装 Node.js 模块语法格式如下：</p>\n<pre><code>$ npm install &lt;Module Name&gt;</code></pre><p>以下实例，我们使用 npm 命令安装常用的 Node.js web框架模块 express:</p>\n<pre><code>$ npm install express</code></pre><p>安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 require(‘express’) 的方式就好，无需指定第三方包路径。</p>\n<pre><code>var express = require(&apos;express&apos;);</code></pre><h2 id=\"全局安装与本地安装\"><a href=\"#全局安装与本地安装\" class=\"headerlink\" title=\"全局安装与本地安装\"></a>全局安装与本地安装</h2><p>npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，比如</p>\n<pre><code>npm install express          # 本地安装\nnpm install express -g   # 全局安装</code></pre><p>如果出现以下错误：</p>\n<pre><code>npm err! Error: connect ECONNREFUSED 127.0.0.1:8087 </code></pre><p>解决办法为：</p>\n<pre><code>$ npm config set proxy null</code></pre><h2 id=\"本地安装\"><a href=\"#本地安装\" class=\"headerlink\" title=\"本地安装\"></a>本地安装</h2><ul>\n<li><p>1.将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</p>\n</li>\n<li><p>2.可以通过 require() 来引入本地安装的包。</p>\n</li>\n</ul>\n<h2 id=\"全局安装\"><a href=\"#全局安装\" class=\"headerlink\" title=\"全局安装\"></a>全局安装</h2><ul>\n<li>1.将安装包放在 /usr/local 下或者你 node 的安装目录。</li>\n<li>2.可以直接在命令行里使用。</li>\n</ul>\n<p>如果你希望具备两者功能，则需要在两个地方安装它或使用 npm link。<br>接下来我们使用全局方式安装 express</p>\n<pre><code>$ npm install express -g</code></pre><h2 id=\"查看安装信息\"><a href=\"#查看安装信息\" class=\"headerlink\" title=\"查看安装信息\"></a>查看安装信息</h2><p>你可以使用以下命令来查看所有全局安装的模块：</p>\n<pre><code>$ npm list -g\n\n├─┬ cnpm@4.3.2\n│ ├── auto-correct@1.0.0\n│ ├── bagpipe@0.3.5\n│ ├── colors@1.1.2\n│ ├─┬ commander@2.9.0\n│ │ └── graceful-readlink@1.0.1\n│ ├─┬ cross-spawn@0.2.9\n│ │ └── lru-cache@2.7.3\n……</code></pre><p>如果要查看某个模块的版本号，可以使用命令如下：</p>\n<pre><code>$ npm list grunt\n\nprojectName@projectVersion /path/to/project/folder\n└── grunt@0.4.1</code></pre><h2 id=\"使用-package-json\"><a href=\"#使用-package-json\" class=\"headerlink\" title=\"使用 package.json\"></a>使用 package.json</h2><p>package.json 位于模块的目录下，用于定义包的属性。接下来让我们来看下 express 包的 package.json 文件，位于 node_modules/express/package.json 内容：</p>\n<h2 id=\"Package-json-属性说明\"><a href=\"#Package-json-属性说明\" class=\"headerlink\" title=\"Package.json 属性说明\"></a>Package.json 属性说明</h2><pre><code>name - 包名。\n\nversion - 包的版本号。\n\ndescription - 包的描述。\n\nhomepage - 包的官网 url 。\n\nauthor - 包的作者姓名。\n\ncontributors - 包的其他贡献者姓名。\n\ndependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。\n\nrepository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。\n\nmain - main 字段指定了程序的主入口文件，require(&apos;moduleName&apos;) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。\n\nkeywords - 关键字</code></pre><h2 id=\"卸载模块\"><a href=\"#卸载模块\" class=\"headerlink\" title=\"卸载模块\"></a>卸载模块</h2><p>我们可以使用以下命令来卸载 Node.js 模块。</p>\n<pre><code>$ npm uninstall express</code></pre><p>卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看：</p>\n<pre><code>$ npm ls</code></pre><h2 id=\"更新模块\"><a href=\"#更新模块\" class=\"headerlink\" title=\"更新模块\"></a>更新模块</h2><pre><code>$ npm update express</code></pre><h2 id=\"搜索模块\"><a href=\"#搜索模块\" class=\"headerlink\" title=\"搜索模块\"></a>搜索模块</h2><pre><code>$ npm search express</code></pre><h2 id=\"创建模块\"><a href=\"#创建模块\" class=\"headerlink\" title=\"创建模块\"></a>创建模块</h2><p>创建模块，package.json 文件是必不可少的。我们可以使用 NPM 生成 package.json 文件，生成的文件包含了基本的结果。</p>\n<pre><code>$ npm init\nThis utility will walk you through creating a package.json file.\nIt only covers the most common items, and tries to guess sensible defaults.\n\nSee `npm help json` for definitive documentation on these fields\nand exactly what they do.\n\nUse `npm install &lt;pkg&gt; --save` afterwards to install a package and\nsave it as a dependency in the package.json file.\n\nPress ^C at any time to quit.\nname: (node_modules) runoob                   # 模块名\nversion: (1.0.0) \ndescription: Node.js 测试模块(www.runoob.com)  # 描述\nentry point: (index.js) \ntest command: make test\ngit repository: https://github.com/runoob/runoob.git  # Github 地址\nkeywords: \nauthor: \nlicense: (ISC) \nAbout to write to ……/node_modules/package.json:      # 生成地址\n\n{\n  &quot;name&quot;: &quot;runoob&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;Node.js 测试模块(www.runoob.com)&quot;,\n  ……\n}\n\n\nIs this ok? (yes) yes</code></pre><p>以上的信息，你需要根据你自己的情况输入。在最后输入 “yes” 后会生成 package.json 文件。</p>\n<p>接下来我们可以使用以下命令在 npm 资源库中注册用户（使用邮箱注册）：</p>\n<pre><code>$ npm adduser\nUsername: mcmohd\nPassword:\nEmail: (this IS public) mcmohd@gmail.com</code></pre><p>接下来我们就用以下命令来发布模块：</p>\n<pre><code>$ npm publish</code></pre><p>如果你以上的步骤都操作正确，你就可以跟其他模块一样使用 npm 来安装。</p>\n<h2 id=\"版本号\"><a href=\"#版本号\" class=\"headerlink\" title=\"版本号\"></a>版本号</h2><p>使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。</p>\n<p>语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。</p>\n<ul>\n<li>如果只是修复bug，需要更新Z位。</li>\n<li>如果是新增了功能，但是向下兼容，需要更新Y位。</li>\n<li>如果有大变动，向下不兼容，需要更新X位。</li>\n</ul>\n<p>版本号有了这个保证后，在申明第三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如”argv”: “0.0.x”表示依赖于0.0.x系列的最新版argv。                    </p>\n<p>NPM支持的所有版本号范围指定方式可以查看<a href=\"https://docs.npmjs.com/\" target=\"_blank\" rel=\"noopener\">官方文档</a>。</p>\n<h2 id=\"NPM-常用命令\"><a href=\"#NPM-常用命令\" class=\"headerlink\" title=\"NPM 常用命令\"></a>NPM 常用命令</h2><p>使用npm help可查看所有命令。</p>\n<ul>\n<li><p>NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。</p>\n</li>\n<li><p>使用npm help <command>可查看某条命令的详细帮助，例如npm help install。</p>\n</li>\n<li><p>在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。</p>\n</li>\n<li><p>使用npm update <package>可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。</package></p>\n</li>\n<li><p>使用npm update <package> -g可以把全局安装的对应命令行程序更新至最新版。</package></p>\n</li>\n<li><p>使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</p>\n</li>\n<li><p>使用npm unpublish <package>@<version>可以撤销发布自己发布过的某个版本代码。</version></package></p>\n</li>\n</ul>\n<h2 id=\"使用淘宝-NPM-镜像\"><a href=\"#使用淘宝-NPM-镜像\" class=\"headerlink\" title=\"使用淘宝 NPM 镜像\"></a>使用淘宝 NPM 镜像</h2><p>大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。</p>\n<p>淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。</p>\n<p>你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:</p>\n<pre><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>这样就可以使用 cnpm 命令来安装模块了：</p>\n<pre><code>$ cnpm install [name]</code></pre><h1 id=\"Node-js-REPL-交互式解释器\"><a href=\"#Node-js-REPL-交互式解释器\" class=\"headerlink\" title=\"Node.js REPL(交互式解释器)\"></a>Node.js REPL(交互式解释器)</h1><p>Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。</p>\n<p>Node 自带了交互式解释器，可以执行以下任务：</p>\n<ul>\n<li><p>读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。</p>\n</li>\n<li><p>执行 - 执行输入的数据结构</p>\n</li>\n<li><p>打印 - 输出结果</p>\n</li>\n<li><p>循环 - 循环操作以上步骤直到用户<strong><em>两次</em></strong>按下  <strong>ctrl-c</strong>  按钮退出。</p>\n</li>\n</ul>\n<p>Node 的交互式解释器可以很好的调试 Javascript 代码。</p>\n<h2 id=\"启动-Node-的终端：\"><a href=\"#启动-Node-的终端：\" class=\"headerlink\" title=\"启动 Node 的终端：\"></a>启动 Node 的终端：</h2><pre><code>$ node\nWelcome to Node.js v12.9.0.\nType &quot;.help&quot; for more information.\n&gt;</code></pre><h2 id=\"简单的表达式运算\"><a href=\"#简单的表达式运算\" class=\"headerlink\" title=\"简单的表达式运算\"></a>简单的表达式运算</h2><p>这时我们就可以在 &gt; 后输入简单的表达式，并按下回车键来计算结果。</p>\n<pre><code>$ node\n&gt; 1 +4\n5\n&gt; 5 / 2\n2.5\n&gt; 3 * 6\n18\n&gt; 4 - 1\n3\n&gt; 1 + ( 2 * 3 ) - 4\n3\n&gt;</code></pre><h2 id=\"使用变量\"><a href=\"#使用变量\" class=\"headerlink\" title=\"使用变量\"></a>使用变量</h2><p>你可以将数据存储在变量中，并在你需要的时候使用它。</p>\n<p>变量声明需要使用 var 关键字，如果没有使用 var 关键字变量会直接打印出来。</p>\n<p>使用 var 关键字的变量可以使用 console.log() 来输出变量。</p>\n<pre><code>$ node\n&gt; x = 10\n10\n&gt; var y = 10\nundefined\n&gt; x + y\n20\n&gt; console.log(&quot;Hello World&quot;)\nHello World\nundefined\n&gt; console.log(&quot;www.runoob.com&quot;)\nwww.runoob.com\nundefined</code></pre><h2 id=\"多行表达式\"><a href=\"#多行表达式\" class=\"headerlink\" title=\"多行表达式\"></a>多行表达式</h2><p>Node REPL 支持输入多行表达式，这就有点类似 JavaScript。接下来让我们来执行一个 do-while 循环：</p>\n<pre><code>$ node\n&gt; var x = 0\nundefined\n&gt; do {\n... x++;\n... console.log(&quot;x: &quot; + x);\n... } while ( x &lt; 5 );\nx: 1\nx: 2\nx: 3\nx: 4\nx: 5\nundefined\n&gt;</code></pre><p>… 三个点的符号是系统自动生成的，你回车换行后即可。Node 会自动检测是否为连续的表达式。</p>\n<h2 id=\"下划线-变量\"><a href=\"#下划线-变量\" class=\"headerlink\" title=\"下划线(_)变量\"></a>下划线(_)变量</h2><p>你可以使用下划线(_)获取上一个表达式的运算结果：</p>\n<pre><code>$ node\n&gt; var x = 10\nundefined\n&gt; var y = 20\nundefined\n&gt; x + y\n30\n&gt; var sum = _\nundefined\n&gt; console.log(sum)\n30\nundefined\n&gt;</code></pre><h2 id=\"REPL-命令\"><a href=\"#REPL-命令\" class=\"headerlink\" title=\"REPL 命令\"></a>REPL 命令</h2><ul>\n<li><p>ctrl + c - 退出当前终端。</p>\n</li>\n<li><p>ctrl + c 按下两次 - 退出 Node REPL。</p>\n</li>\n<li><p>ctrl + d - 退出 Node REPL.</p>\n</li>\n<li><p>向上/向下 键 - 查看输入的历史命令</p>\n</li>\n<li><p>tab 键 - 列出当前命令</p>\n</li>\n<li><p>.help - 列出使用命令</p>\n</li>\n<li><p>.break - 退出多行表达式</p>\n</li>\n<li><p>.clear - 退出多行表达式</p>\n</li>\n<li><p>.save filename - 保存当前的 Node REPL 会话到指定文件</p>\n</li>\n<li><p>.load filename - 载入当前 Node REPL 会话的文件内容。</p>\n</li>\n</ul>\n<h2 id=\"停止-REPL\"><a href=\"#停止-REPL\" class=\"headerlink\" title=\"停止 REPL\"></a>停止 REPL</h2><p>前面我们已经提到按下两次 ctrl + c 键就能退出 REPL:</p>\n<pre><code>$ node\n&gt;\n(^C again to quit)\n&gt;      </code></pre><h1 id=\"Node-js-回调函数\"><a href=\"#Node-js-回调函数\" class=\"headerlink\" title=\"Node.js 回调函数\"></a>Node.js 回调函数</h1><p>Node.js 异步编程的直接体现就是回调。</p>\n<p>异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。</p>\n<p>回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。</p>\n<p>例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。</p>\n<p>回调函数一般作为函数的最后一个参数出现：</p>\n<pre><code>function foo1(name, age, callback) { }\nfunction foo2(value, callback1, callback2) { }</code></pre><h2 id=\"阻塞代码实例\"><a href=\"#阻塞代码实例\" class=\"headerlink\" title=\"阻塞代码实例\"></a>阻塞代码实例</h2><p>创建一个文件 input.txt ，内容如下：</p>\n<pre><code>菜鸟教程官网地址：www.runoob.com</code></pre><p>创建 main.js 文件, 代码如下：</p>\n<pre><code>var fs = require(&quot;fs&quot;);\nvar data = fs.readFileSync(&apos;input.txt&apos;);\nconsole.log(data.toString());\nconsole.log(&quot;程序执行结束!&quot;);</code></pre><p>以上代码执行结果如下：</p>\n<pre><code>$ node main.js\n菜鸟教程官网地址：www.runoob.com\n\n程序执行结束!</code></pre><h2 id=\"非阻塞代码实例\"><a href=\"#非阻塞代码实例\" class=\"headerlink\" title=\"非阻塞代码实例\"></a>非阻塞代码实例</h2><p>创建一个文件 input.txt ，内容如下：</p>\n<pre><code>菜鸟教程官网地址：www.runoob.com</code></pre><p>创建 main.js 文件, 代码如下：</p>\n<pre><code>fs.readFile(&apos;input.txt&apos;, function (err, data) {\n    if (err) return console.error(err);\n    console.log(data.toString());\n});\n\nconsole.log(&quot;程序执行结束!&quot;);</code></pre><p>以上代码执行结果如下：</p>\n<pre><code>$ node main.js\n程序执行结束!\n菜鸟教程官网地址：www.runoob.com</code></pre><p>以上两个实例我们了解了阻塞与非阻塞调用的不同。第一个实例在文件读取完后才执行完程序。 第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。</p>\n<p>因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。</p>\n<h1 id=\"Node-js-事件循环\"><a href=\"#Node-js-事件循环\" class=\"headerlink\" title=\"Node.js 事件循环\"></a>Node.js 事件循环</h1><ul>\n<li><p>Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。    </p>\n</li>\n<li><p>Node.js 几乎每一个 API 都是支持回调函数的。</p>\n</li>\n<li><p>Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。</p>\n</li>\n<li><p>Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.</p>\n</li>\n</ul>\n<h2 id=\"事件驱动程序\"><a href=\"#事件驱动程序\" class=\"headerlink\" title=\"事件驱动程序\"></a>事件驱动程序</h2><p>Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。</p>\n<p>当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。</p>\n<p>这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）</p>\n<p>在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。</p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2015/09/event_loop.jpg\" alt></p>\n<p>整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。</p>\n<p>Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：</p>\n<pre><code>// 引入 events 模块\nvar events = require(&apos;events&apos;);\n// 创建 eventEmitter 对象\nvar eventEmitter = new events.EventEmitter();</code></pre><p>以下程序绑定事件处理程序：</p>\n<pre><code>// 绑定事件及事件的处理程序\neventEmitter.on(&apos;eventName&apos;, eventHandler);</code></pre><p>我们可以通过程序触发事件：</p>\n<pre><code>// 触发事件\neventEmitter.emit(&apos;eventName&apos;);</code></pre><h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>创建 main.js 文件，代码如下所示：</p>\n<pre><code>// 引入 events 模块\nvar events = require(&apos;events&apos;);\n// 创建 eventEmitter 对象\nvar eventEmitter = new events.EventEmitter();\n\n// 创建事件处理程序\nvar connectHandler = function connected() {\n   console.log(&apos;连接成功。&apos;);\n\n   // 触发 data_received 事件 \n   eventEmitter.emit(&apos;data_received&apos;);\n} \n\n// 绑定 connection 事件处理程序\neventEmitter.on(&apos;connection&apos;, connectHandler);\n\n// 使用匿名函数绑定 data_received 事件\neventEmitter.on(&apos;data_received&apos;, function(){\n   console.log(&apos;数据接收成功。&apos;);\n});    \n\n// 触发 connection 事件 \neventEmitter.emit(&apos;connection&apos;);\n\nconsole.log(&quot;程序执行完毕。&quot;);</code></pre><p>接下来让我们执行以上代码：</p>\n<pre><code>$ node main.js\n连接成功。\n数据接收成功。\n程序执行完毕。</code></pre><h2 id=\"Node-应用程序是如何工作的？\"><a href=\"#Node-应用程序是如何工作的？\" class=\"headerlink\" title=\"Node 应用程序是如何工作的？\"></a>Node 应用程序是如何工作的？</h2><p>在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。</p>\n<p>接下来让我们来重新看下前面的实例，创建一个 input.txt ,文件内容如下：</p>\n<pre><code>菜鸟教程官网地址：www.runoob.com</code></pre><p>创建 main.js 文件，代码如下：</p>\n<pre><code>var fs = require(&quot;fs&quot;);\n\nfs.readFile(&apos;input.txt&apos;, function (err, data) {\n   if (err){\n      console.log(err.stack);\n      return;\n   }\n   console.log(data.toString());\n});\nconsole.log(&quot;程序执行完毕&quot;);</code></pre><p>以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。</p>\n<p>如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。</p>\n<p>执行以上代码，执行结果如下：</p>\n<pre><code>程序执行完毕\n菜鸟教程官网地址：www.runoob.com      </code></pre><p>接下来我们删除 input.txt 文件，执行结果如下所示：</p>\n<pre><code>程序执行完毕\nError: ENOENT, open &apos;input.txt&apos;</code></pre><p>因为文件 input.txt 不存在，所以输出了错误信息。</p>\n<h1 id=\"Node-js-EventEmitter\"><a href=\"#Node-js-EventEmitter\" class=\"headerlink\" title=\"Node.js EventEmitter\"></a>Node.js EventEmitter</h1><p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。</p>\n<p>Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p>\n<h2 id=\"EventEmitter-类\"><a href=\"#EventEmitter-类\" class=\"headerlink\" title=\"EventEmitter 类\"></a>EventEmitter 类</h2><p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。</p>\n<p>你可以通过require(“events”);来访问该模块。</p>\n<pre><code>// 引入 events 模块\nvar events = require(&apos;events&apos;);\n// 创建 eventEmitter 对象\nvar eventEmitter = new events.EventEmitter();</code></pre><p>EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。</p>\n<h3 id=\"下面我们用一个简单的例子说明-EventEmitter-的用法：\"><a href=\"#下面我们用一个简单的例子说明-EventEmitter-的用法：\" class=\"headerlink\" title=\"下面我们用一个简单的例子说明 EventEmitter 的用法：\"></a>下面我们用一个简单的例子说明 EventEmitter 的用法：</h3><pre><code>//event.js 文件\nvar EventEmitter = require(&apos;events&apos;).EventEmitter; \nvar event = new EventEmitter(); \nevent.on(&apos;some_event&apos;, function() { \n    console.log(&apos;some_event 事件触发&apos;); \n}); \nsetTimeout(function() { \n    event.emit(&apos;some_event&apos;); \n}, 1000); </code></pre><p>执行结果如下：</p>\n<p>运行这段代码，1 秒后控制台输出了 ‘some_event 事件触发’。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。</p>\n<pre><code>$ node event.js \nsome_event 事件触发          </code></pre><p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。</p>\n<p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p>\n<p>让我们以下面的例子解释这个过程：</p>\n<pre><code>//event.js 文件\nvar events = require(&apos;events&apos;); \nvar emitter = new events.EventEmitter(); \nemitter.on(&apos;someEvent&apos;, function(arg1, arg2) { \n    console.log(&apos;listener1&apos;, arg1, arg2); \n}); \nemitter.on(&apos;someEvent&apos;, function(arg1, arg2) { \n    console.log(&apos;listener2&apos;, arg1, arg2); \n}); \nemitter.emit(&apos;someEvent&apos;, &apos;arg1 参数&apos;, &apos;arg2 参数&apos;); </code></pre><p>执行以上代码，运行的结果如下：</p>\n<pre><code>$ node event.js \nlistener1 arg1 参数 arg2 参数\nlistener2 arg1 参数 arg2 参数    </code></pre><p>以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。</p>\n<p>运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。</p>\n<p>EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"1-addListener-event-listener\"><a href=\"#1-addListener-event-listener\" class=\"headerlink\" title=\"1. addListener(event, listener)\"></a>1. addListener(event, listener)</h3><p>为指定事件添加一个监听器到监听器数组的尾部。</p>\n<h3 id=\"2-on-event-listener\"><a href=\"#2-on-event-listener\" class=\"headerlink\" title=\"2. on(event, listener)\"></a>2. on(event, listener)</h3><p>为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。</p>\n<pre><code>server.on(&apos;connection&apos;, function (stream) {\n  console.log(&apos;someone connected!&apos;);\n});</code></pre><h3 id=\"3-once-event-listener\"><a href=\"#3-once-event-listener\" class=\"headerlink\" title=\"3. once(event, listener)\"></a>3. once(event, listener)</h3><p>为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。</p>\n<pre><code>server.once(&apos;connection&apos;, function (stream) {\n  console.log(&apos;Ah, we have our first user!&apos;);\n});</code></pre><h3 id=\"4-removeListener-event-listener\"><a href=\"#4-removeListener-event-listener\" class=\"headerlink\" title=\"4. removeListener(event, listener)\"></a>4. removeListener(event, listener)</h3><p>移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。</p>\n<p>它接受两个参数，第一个是事件名称，第二个是回调函数名称。</p>\n<pre><code>var callback = function(stream) {\n  console.log(&apos;someone connected!&apos;);\n};\nserver.on(&apos;connection&apos;, callback);\n// ...\nserver.removeListener(&apos;connection&apos;, callback);</code></pre><h3 id=\"5-removeAllListeners-event\"><a href=\"#5-removeAllListeners-event\" class=\"headerlink\" title=\"5. removeAllListeners([event])\"></a>5. removeAllListeners([event])</h3><p>移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。</p>\n<h3 id=\"6-setMaxListeners-n\"><a href=\"#6-setMaxListeners-n\" class=\"headerlink\" title=\"6. setMaxListeners(n)\"></a>6. setMaxListeners(n)</h3><p>默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。</p>\n<h3 id=\"7-listeners-event\"><a href=\"#7-listeners-event\" class=\"headerlink\" title=\"7. listeners(event)\"></a>7. listeners(event)</h3><p>返回指定事件的监听器数组。</p>\n<h3 id=\"8-emit-event-arg1-arg2-…\"><a href=\"#8-emit-event-arg1-arg2-…\" class=\"headerlink\" title=\"8. emit(event, [arg1], [arg2], […])\"></a>8. emit(event, [arg1], [arg2], […])</h3><p>按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</p>\n<h2 id=\"类方法\"><a href=\"#类方法\" class=\"headerlink\" title=\"类方法\"></a>类方法</h2><h3 id=\"listenerCount-emitter-event\"><a href=\"#listenerCount-emitter-event\" class=\"headerlink\" title=\"listenerCount(emitter, event)\"></a>listenerCount(emitter, event)</h3><p>返回指定事件的监听器数量。</p>\n<pre><code>events.EventEmitter.listenerCount(emitter, eventName) //已废弃，不推荐\nevents.emitter.listenerCount(eventName) //推荐</code></pre><h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><h3 id=\"newListener\"><a href=\"#newListener\" class=\"headerlink\" title=\"newListener\"></a>newListener</h3><ul>\n<li><p>event - 字符串，事件名称</p>\n</li>\n<li><p>listener - 处理事件函数</p>\n</li>\n</ul>\n<p>该事件在添加新监听器时被触发。</p>\n<h3 id=\"removeListener\"><a href=\"#removeListener\" class=\"headerlink\" title=\"removeListener\"></a>removeListener</h3><ul>\n<li><p>event - 字符串，事件名称</p>\n</li>\n<li><p>listener - 处理事件函数</p>\n</li>\n</ul>\n<p>从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。</p>\n<h2 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。</p>\n<p>创建 main.js 文件，代码如下：</p>\n<pre><code>var events = require(&apos;events&apos;);\nvar eventEmitter = new events.EventEmitter();\n\n// 监听器 #1\nvar listener1 = function listener1() {\n   console.log(&apos;监听器 listener1 执行。&apos;);\n}\n\n// 监听器 #2\nvar listener2 = function listener2() {\n  console.log(&apos;监听器 listener2 执行。&apos;);\n}\n\n// 绑定 connection 事件，处理函数为 listener1 \neventEmitter.addListener(&apos;connection&apos;, listener1);\n\n// 绑定 connection 事件，处理函数为 listener2\neventEmitter.on(&apos;connection&apos;, listener2);\n\nvar eventListeners = eventEmitter.listenerCount(&apos;connection&apos;);\nconsole.log(eventListeners + &quot; 个监听器监听连接事件。&quot;);\n\n// 处理 connection 事件 \neventEmitter.emit(&apos;connection&apos;);\n\n// 移除监绑定的 listener1 函数\neventEmitter.removeListener(&apos;connection&apos;, listener1);\nconsole.log(&quot;listener1 不再受监听。&quot;);\n\n// 触发连接事件\neventEmitter.emit(&apos;connection&apos;);\n\neventListeners = eventEmitter.listenerCount(&apos;connection&apos;);\nconsole.log(eventListeners + &quot; 个监听器监听连接事件。&quot;);\n\nconsole.log(&quot;程序执行完毕。&quot;);</code></pre><p>以上代码，执行结果如下所示：</p>\n<pre><code>$ node main.js  \n2 个监听器监听连接事件。\n监听器 listener1 执行。\n监听器 listener2 执行。\nlistener1 不再受监听。\n监听器 listener2 执行。\n1 个监听器监听连接事件。\n程序执行完毕。</code></pre><h2 id=\"error-事件\"><a href=\"#error-事件\" class=\"headerlink\" title=\"error 事件\"></a>error 事件</h2><p>EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。</p>\n<p>当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p>\n<p>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：</p>\n<pre><code>var events = require(&apos;events&apos;); \nvar emitter = new events.EventEmitter(); \nemitter.emit(&apos;error&apos;); </code></pre><p>运行时会显示以下错误：</p>\n<pre><code>node.js:201 \nthrow e; // process.nextTick error, or &apos;error&apos; event on first tick \n^ \nError: Uncaught, unspecified &apos;error&apos; event. \nat EventEmitter.emit (events.js:50:15) \nat Object.&lt;anonymous&gt; (/home/byvoid/error.js:5:9) \nat Module._compile (module.js:441:26) \nat Object..js (module.js:459:10) \nat Module.load (module.js:348:31) \nat Function._load (module.js:308:12) \nat Array.0 (module.js:479:10) \nat EventEmitter._tickCallback (node.js:192:40)    </code></pre><h2 id=\"继承-EventEmitter\"><a href=\"#继承-EventEmitter\" class=\"headerlink\" title=\"继承 EventEmitter\"></a>继承 EventEmitter</h2><p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p>\n<p>为什么要这样做呢？原因有两点：</p>\n<p>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。</p>\n<p>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p>\n<h1 id=\"Node-js-Buffer-缓冲区\"><a href=\"#Node-js-Buffer-缓冲区\" class=\"headerlink\" title=\"Node.js Buffer(缓冲区)\"></a>Node.js Buffer(缓冲区)</h1><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。</p>\n<p>但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。</p>\n<p>在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。</p>\n<blockquote>\n<blockquote>\n<p>在v6.0之前创建Buffer对象直接使用new Buffer()构造函数来创建对象实例，但是Buffer对内存的权限操作相比很大，可以直接捕获一些敏感信息，所以在v6.0以后，官方文档里面建议使用 Buffer.from() 接口去创建Buffer对象。    </p>\n</blockquote>\n</blockquote>\n<h2 id=\"Buffer-与字符编码\"><a href=\"#Buffer-与字符编码\" class=\"headerlink\" title=\"Buffer 与字符编码\"></a>Buffer 与字符编码</h2><p>Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。</p>\n<pre><code>const buf = Buffer.from(&apos;runoob&apos;, &apos;ascii&apos;);\n\n// 输出 72756e6f6f62\nconsole.log(buf.toString(&apos;hex&apos;));\n\n// 输出 cnVub29i\nconsole.log(buf.toString(&apos;base64&apos;));</code></pre><p>Node.js 目前支持的字符编码包括：</p>\n<ul>\n<li><p>ascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。</p>\n</li>\n<li><p>utf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。</p>\n</li>\n<li><p>utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。</p>\n</li>\n<li><p>ucs2 - utf16le 的别名。</p>\n</li>\n<li><p>base64 - Base64 编码。</p>\n</li>\n<li><p>latin1 - 一种把 Buffer 编码成一字节编码的字符串的方式。</p>\n</li>\n<li><p>binary - latin1 的别名。</p>\n</li>\n<li><p>hex - 将每个字节编码为两个十六进制字符。</p>\n</li>\n</ul>\n<h2 id=\"创建-Buffer-类\"><a href=\"#创建-Buffer-类\" class=\"headerlink\" title=\"创建 Buffer 类\"></a>创建 Buffer 类</h2><p>Buffer 提供了以下 API 来创建 Buffer 类：</p>\n<ul>\n<li><p>Buffer.alloc(size[, fill[, encoding]])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0</p>\n</li>\n<li><p>Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据</p>\n</li>\n<li><p>Buffer.allocUnsafeSlow(size)</p>\n</li>\n<li><p>Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）</p>\n</li>\n<li><p>Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。</p>\n</li>\n<li><p>Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例</p>\n</li>\n<li><p>Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例</p>\n<p>  / 创建一个长度为 10、且用 0 填充的 Buffer。<br>  const buf1 = Buffer.alloc(10);</p>\n<p>  // 创建一个长度为 10、且用 0x1 填充的 Buffer。<br>  const buf2 = Buffer.alloc(10, 1);</p>\n<p>  // 创建一个长度为 10、且未初始化的 Buffer。<br>  // 这个方法比调用 Buffer.alloc() 更快，<br>  // 但返回的 Buffer 实例可能包含旧数据，<br>  // 因此需要使用 fill() 或 write() 重写。<br>  const buf3 = Buffer.allocUnsafe(10);</p>\n<p>  // 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。<br>  const buf4 = Buffer.from([1, 2, 3]);</p>\n<p>  // 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。<br>  const buf5 = Buffer.from(‘tést’);</p>\n<p>  // 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。<br>  const buf6 = Buffer.from(‘tést’, ‘latin1’);</p>\n</li>\n</ul>\n<h2 id=\"写入缓冲区\"><a href=\"#写入缓冲区\" class=\"headerlink\" title=\"写入缓冲区\"></a>写入缓冲区</h2><h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre><code>buf.write(string[, offset[, length]][, encoding])</code></pre><h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>参数描述如下：</p>\n<ul>\n<li><p>string - 写入缓冲区的字符串。</p>\n</li>\n<li><p>offset - 缓冲区开始写入的索引值，默认为 0 。</p>\n</li>\n<li><p>length - 写入的字节数，默认为 buffer.length</p>\n</li>\n<li><p>encoding - 使用的编码。默认为 ‘utf8’ 。</p>\n</li>\n</ul>\n<p>根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。</p>\n<h3 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。</p>\n<h3 id=\"实例-2\"><a href=\"#实例-2\" class=\"headerlink\" title=\"实例\"></a>实例</h3><pre><code>buf = Buffer.alloc(256);\nlen = buf.write(&quot;www.runoob.com&quot;);\n\nconsole.log(&quot;写入字节数 : &quot;+  len);</code></pre><p>执行以上代码，输出结果为：</p>\n<pre><code>$node main.js\n写入字节数 : 14</code></pre><h2 id=\"从缓冲区读取数据\"><a href=\"#从缓冲区读取数据\" class=\"headerlink\" title=\"从缓冲区读取数据\"></a>从缓冲区读取数据</h2><h3 id=\"读取-Node-缓冲区数据的语法如下所示：\"><a href=\"#读取-Node-缓冲区数据的语法如下所示：\" class=\"headerlink\" title=\"读取 Node 缓冲区数据的语法如下所示：\"></a>读取 Node 缓冲区数据的语法如下所示：</h3><pre><code>buf.toString([encoding[, start[, end]]])</code></pre><h3 id=\"参数-1\"><a href=\"#参数-1\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>参数描述如下：</p>\n<ul>\n<li><p>encoding - 使用的编码。默认为 ‘utf8’ 。</p>\n</li>\n<li><p>start - 指定开始读取的索引位置，默认为 0。</p>\n</li>\n<li><p>end - 结束位置，默认为缓冲区的末尾。</p>\n</li>\n</ul>\n<h3 id=\"返回\"><a href=\"#返回\" class=\"headerlink\" title=\"返回\"></a>返回</h3><p>解码缓冲区数据并使用指定的编码返回字符串。</p>\n<h3 id=\"实例-3\"><a href=\"#实例-3\" class=\"headerlink\" title=\"实例\"></a>实例</h3><pre><code>buf = Buffer.alloc(26);\nfor (var i = 0 ; i &lt; 26 ; i++) {\n  buf[i] = i + 97;\n}\n\nconsole.log( buf.toString(&apos;ascii&apos;));       // 输出: abcdefghijklmnopqrstuvwxyz\nconsole.log( buf.toString(&apos;ascii&apos;,0,5));   // 输出: abcde\nconsole.log( buf.toString(&apos;utf8&apos;,0,5));    // 输出: abcde\nconsole.log( buf.toString(undefined,0,5)); // 使用 &apos;utf8&apos; 编码, 并输出: abcde</code></pre><p>执行以上代码，输出结果为：</p>\n<pre><code>$ node main.js\nabcdefghijklmnopqrstuvwxyz\nabcde\nabcde\nabcde</code></pre><h2 id=\"将-Buffer-转换为-JSON-对象\"><a href=\"#将-Buffer-转换为-JSON-对象\" class=\"headerlink\" title=\"将 Buffer 转换为 JSON 对象\"></a>将 Buffer 转换为 JSON 对象</h2><h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre><code>buf.toJSON()</code></pre><p>当字符串化一个 Buffer 实例时，JSON.stringify() 会隐式地调用该 toJSON()。</p>\n<h3 id=\"返回值-1\"><a href=\"#返回值-1\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>返回 JSON 对象。</p>\n<h3 id=\"实例-4\"><a href=\"#实例-4\" class=\"headerlink\" title=\"实例\"></a>实例</h3><pre><code>const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);\nconst json = JSON.stringify(buf);\n\n// 输出: {&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]}\nconsole.log(json);\n\nconst copy = JSON.parse(json, (key, value) =&gt; {\n  return value &amp;&amp; value.type === &apos;Buffer&apos; ?\n    Buffer.from(value.data) :\n    value;\n});\n\n// 输出: &lt;Buffer 01 02 03 04 05&gt;\nconsole.log(copy);</code></pre><p>执行以上代码，输出结果为：</p>\n<pre><code>{&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]}\n&lt;Buffer 01 02 03 04 05&gt;</code></pre><h2 id=\"缓冲区合并\"><a href=\"#缓冲区合并\" class=\"headerlink\" title=\"缓冲区合并\"></a>缓冲区合并</h2><h3 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre><code>Buffer.concat(list[, totalLength])</code></pre><h3 id=\"参数-2\"><a href=\"#参数-2\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>参数描述如下：</p>\n<ul>\n<li><p>list - 用于合并的 Buffer 对象数组列表。</p>\n</li>\n<li><p>totalLength - 指定合并后Buffer对象的总长度。</p>\n</li>\n</ul>\n<h3 id=\"返回值-2\"><a href=\"#返回值-2\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>返回一个多个成员合并的新 Buffer 对象。</p>\n<h3 id=\"实例-5\"><a href=\"#实例-5\" class=\"headerlink\" title=\"实例\"></a>实例</h3><pre><code>var buffer1 = Buffer.from((&apos;菜鸟教程&apos;));\nvar buffer2 = Buffer.from((&apos;www.runoob.com&apos;));\nvar buffer3 = Buffer.concat([buffer1,buffer2]);\nconsole.log(&quot;buffer3 内容: &quot; + buffer3.toString());</code></pre><p>执行以上代码，输出结果为：</p>\n<pre><code>buffer3 内容: 菜鸟教程www.runoob.com</code></pre><h2 id=\"缓冲区比较\"><a href=\"#缓冲区比较\" class=\"headerlink\" title=\"缓冲区比较\"></a>缓冲区比较</h2><h3 id=\"语法-3\"><a href=\"#语法-3\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>Node Buffer 比较的函数语法如下所示, 该方法在 Node.js v0.12.2 版本引入    </p>\n<pre><code>buf.compare(otherBuffer);</code></pre><h3 id=\"参数-3\"><a href=\"#参数-3\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>参数描述如下：</p>\n<ul>\n<li>otherBuffer - 与 buf 对象比较的另外一个 Buffer 对象。</li>\n</ul>\n<h3 id=\"返回值-3\"><a href=\"#返回值-3\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。</p>\n<h3 id=\"实例-6\"><a href=\"#实例-6\" class=\"headerlink\" title=\"实例\"></a>实例</h3><pre><code>var buffer1 = Buffer.from(&apos;ABC&apos;);\nvar buffer2 = Buffer.from(&apos;ABCD&apos;);\nvar result = buffer1.compare(buffer2);\n\nif(result &lt; 0) {\n   console.log(buffer1 + &quot; 在 &quot; + buffer2 + &quot;之前&quot;);\n}else if(result == 0){\n   console.log(buffer1 + &quot; 与 &quot; + buffer2 + &quot;相同&quot;);\n}else {\n   console.log(buffer1 + &quot; 在 &quot; + buffer2 + &quot;之后&quot;);\n}</code></pre><p>执行以上代码，输出结果为：</p>\n<pre><code>ABC在ABCD之前</code></pre><h2 id=\"拷贝缓冲区\"><a href=\"#拷贝缓冲区\" class=\"headerlink\" title=\"拷贝缓冲区\"></a>拷贝缓冲区</h2><h3 id=\"语法-4\"><a href=\"#语法-4\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre><code>buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</code></pre><ul>\n<li><p>targetBuffer - 要拷贝的 Buffer 对象。</p>\n</li>\n<li><p>targetStart - 数字, 可选, 默认: 0</p>\n</li>\n<li><p>sourceStart - 数字, 可选, 默认: 0</p>\n</li>\n<li><p>sourceEnd - 数字, 可选, 默认: buffer.length</p>\n</li>\n</ul>\n<h3 id=\"返回值-4\"><a href=\"#返回值-4\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>没有返回值。</p>\n<h3 id=\"实例-7\"><a href=\"#实例-7\" class=\"headerlink\" title=\"实例\"></a>实例</h3><pre><code>var buf1 = Buffer.from(&apos;abcdefghijkl&apos;);\nvar buf2 = Buffer.from(&apos;RUNOOB&apos;);\n\n//将 buf2 插入到 buf1 指定位置上\nbuf2.copy(buf1, 2);\n\nconsole.log(buf1.toString());</code></pre><p>执行以上代码，输出结果为：</p>\n<pre><code>abRUNOOBijkl</code></pre><h2 id=\"缓冲区裁剪\"><a href=\"#缓冲区裁剪\" class=\"headerlink\" title=\"缓冲区裁剪\"></a>缓冲区裁剪</h2><p>Node 缓冲区裁剪语法如下所示：</p>\n<pre><code>buf.slice([start[, end]])</code></pre><p>参数<br>参数描述如下：</p>\n<ul>\n<li><p>start - 数字, 可选, 默认: 0</p>\n</li>\n<li><p>end - 数字, 可选, 默认: buffer.length</p>\n</li>\n</ul>\n<p>返回值<br>返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。</p>\n<p>实例</p>\n<pre><code>var buffer1 = Buffer.from(&apos;runoob&apos;);\n// 剪切缓冲区\nvar buffer2 = buffer1.slice(0,2);\nconsole.log(&quot;buffer2 content: &quot; + buffer2.toString());\n执行</code></pre><p>执行以上代码，输出结果为：</p>\n<pre><code>buffer2 content: ru</code></pre><h2 id=\"缓冲区长度\"><a href=\"#缓冲区长度\" class=\"headerlink\" title=\"缓冲区长度\"></a>缓冲区长度</h2><pre><code>buf.length;</code></pre><p>返回值<br>返回 Buffer 对象所占据的内存长度。</p>\n<p>实例</p>\n<pre><code>var buffer = Buffer.from(&apos;www.runoob.com&apos;);\n//  缓冲区长度\nconsole.log(&quot;buffer length: &quot; + buffer.length);</code></pre><p>执行以上代码，输出结果为：</p>\n<pre><code>buffer length: 14</code></pre><h1 id=\"Node-js-Stream-流\"><a href=\"#Node-js-Stream-流\" class=\"headerlink\" title=\"Node.js Stream(流)\"></a>Node.js Stream(流)</h1><p>Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。</p>\n<p>Node.js，Stream 有四种流类型：</p>\n<ul>\n<li><p>Readable - 可读操作。</p>\n</li>\n<li><p>Writable - 可写操作。</p>\n</li>\n<li><p>Duplex - 可读可写操作.</p>\n</li>\n<li><p>Transform - 操作被写入数据，然后读出结果。</p>\n</li>\n</ul>\n<p>所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：</p>\n<ul>\n<li><p>data - 当有数据可读时触发。</p>\n</li>\n<li><p>end - 没有更多的数据可读时触发。</p>\n</li>\n<li><p>error - 在接收和写入过程中发生错误时触发。</p>\n</li>\n<li><p>finish - 所有数据已被写入到底层系统时触发。</p>\n</li>\n</ul>\n<h2 id=\"从流中读取数据\"><a href=\"#从流中读取数据\" class=\"headerlink\" title=\"从流中读取数据\"></a>从流中读取数据</h2><p>创建 input.txt 文件，内容如下：</p>\n<pre><code>菜鸟教程官网地址：www.runoob.com\n\nvar fs = require(&quot;fs&quot;);\nvar data = &apos;&apos;;\n\n// 创建可读流\nvar readerStream = fs.createReadStream(&apos;input.txt&apos;);\n\n// 设置编码为 utf8。\nreaderStream.setEncoding(&apos;UTF8&apos;);\n\n// 处理流事件 --&gt; data, end, and error\nreaderStream.on(&apos;data&apos;, function(chunk) {\n   data += chunk;\n});\n\nreaderStream.on(&apos;end&apos;,function(){\n   console.log(data);\n});\n\nreaderStream.on(&apos;error&apos;, function(err){\n   console.log(err.stack);\n});\n\nconsole.log(&quot;程序执行完毕&quot;);</code></pre><p>以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下：</p>\n<pre><code>$ node main.js \n程序执行完毕\n写入完成。</code></pre><p>查看 output.txt 文件的内容：</p>\n<pre><code>$ cat output.txt \n菜鸟教程官网地址：www.runoob.com</code></pre><h2 id=\"管道流\"><a href=\"#管道流\" class=\"headerlink\" title=\"管道流\"></a>管道流</h2><p>管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。    </p>\n<p>设置 input.txt 文件内容如下：</p>\n<pre><code>菜鸟教程官网地址：www.runoob.com\n管道流操作实例</code></pre><p>创建 main.js 文件, 代码如下：</p>\n<pre><code>var fs = require(&quot;fs&quot;);\n\n// 创建一个可读流\nvar readerStream = fs.createReadStream(&apos;input.txt&apos;);\n\n// 创建一个可写流\nvar writerStream = fs.createWriteStream(&apos;output.txt&apos;);\n\n// 管道读写操作\n// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中\nreaderStream.pipe(writerStream);\n\nconsole.log(&quot;程序执行完毕&quot;);</code></pre><p>代码执行结果如下：</p>\n<pre><code>$ node main.js \n程序执行完毕</code></pre><p>查看 output.txt 文件的内容：</p>\n<pre><code>$ cat output.txt \n菜鸟教程官网地址：www.runoob.com\n管道流操作实例</code></pre><h2 id=\"链式流\"><a href=\"#链式流\" class=\"headerlink\" title=\"链式流\"></a>链式流</h2><p>链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。</p>\n<p>接下来我们就是用管道和链式来压缩和解压文件。</p>\n<p>创建 compress.js 文件, 代码如下：</p>\n<pre><code>var fs = require(&quot;fs&quot;);\nvar zlib = require(&apos;zlib&apos;);\n\n// 压缩 input.txt 文件为 input.txt.gz\nfs.createReadStream(&apos;input.txt&apos;)\n  .pipe(zlib.createGzip())\n  .pipe(fs.createWriteStream(&apos;input.txt.gz&apos;));\n\nconsole.log(&quot;文件压缩完成。&quot;);</code></pre><p>代码执行结果如下：</p>\n<pre><code>$ node compress.js \n文件压缩完成。</code></pre><p>执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。</p>\n<p>接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下：</p>\n<pre><code>var fs = require(&quot;fs&quot;);\nvar zlib = require(&apos;zlib&apos;);\n\n// 解压 input.txt.gz 文件为 input.txt\nfs.createReadStream(&apos;input.txt.gz&apos;)\n  .pipe(zlib.createGunzip())\n  .pipe(fs.createWriteStream(&apos;input.txt&apos;));\n\nconsole.log(&quot;文件解压完成。&quot;);</code></pre><p>代码执行结果如下：</p>\n<pre><code>$ node decompress.js \n文件解压完成。</code></pre><h1 id=\"Node-js模块系统\"><a href=\"#Node-js模块系统\" class=\"headerlink\" title=\"Node.js模块系统\"></a>Node.js模块系统</h1><p>为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。</p>\n<p>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。</p>\n<h2 id=\"创建模块-1\"><a href=\"#创建模块-1\" class=\"headerlink\" title=\"创建模块\"></a>创建模块</h2><p>在 Node.js 中，创建一个模块非常简单，如下我们创建一个 main.js 文件，代码如下:</p>\n<pre><code>var hello = require(&apos;./hello&apos;);\nhello.world();</code></pre><p>以上实例中，代码 require(‘./hello’) 引入了当前目录下的 hello.js 文件（./ 为当前目录，node.js 默认后缀为 js）。</p>\n<p>Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。</p>\n<p>接下来我们就来创建 hello.js 文件，代码如下：</p>\n<pre><code>exports.world = function() {\n  console.log(&apos;Hello World&apos;);\n}</code></pre><p>在以上示例中，hello.js 通过 exports 对象把 world 作为模块的访问接口，在 main.js 中通过 require(‘./hello’) 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。</p>\n<p>有时候我们只是想把一个对象封装到模块中，格式如下：</p>\n<pre><code>module.exports = function() {\n  // ...\n}</code></pre><p>例如:</p>\n<pre><code>//hello.js \nfunction Hello() { \n    var name; \n    this.setName = function(thyName) { \n        name = thyName; \n    }; \n    this.sayHello = function() { \n        console.log(&apos;Hello &apos; + name); \n    }; \n}; \nmodule.exports = Hello;</code></pre><p>这样就可以直接获得这个对象了：</p>\n<pre><code>//main.js \nvar Hello = require(&apos;./hello&apos;); \nhello = new Hello(); \nhello.setName(&apos;BYVoid&apos;); \nhello.sayHello(); </code></pre><p>模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。    </p>\n<h2 id=\"服务端的模块放在哪里\"><a href=\"#服务端的模块放在哪里\" class=\"headerlink\" title=\"服务端的模块放在哪里\"></a>服务端的模块放在哪里</h2><p>也许你已经注意到，我们已经在代码中使用了模块了。像这样：</p>\n<pre><code>var http = require(&quot;http&quot;);\n\n...\n\nhttp.createServer(...);</code></pre><p>Node.js 中自带了一个叫做 http 的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。</p>\n<p>这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。</p>\n<p>Node.js 的 require 方法中的文件查找策略如下：</p>\n<p>由于 Node.js 中存在 4 类模块（原生模块和3种文件模块），尽管 require 方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。如下图所示：    </p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2014/03/nodejs-require.jpg\" alt></p>\n<h2 id=\"从文件模块缓存中加载\"><a href=\"#从文件模块缓存中加载\" class=\"headerlink\" title=\"从文件模块缓存中加载\"></a>从文件模块缓存中加载</h2><p>尽管原生模块与文件模块的优先级不同，但是都会优先从文件模块的缓存中加载已经存在的模块。</p>\n<h2 id=\"从原生模块加载\"><a href=\"#从原生模块加载\" class=\"headerlink\" title=\"从原生模块加载\"></a>从原生模块加载</h2><p>原生模块的优先级仅次于文件模块缓存的优先级。require 方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个 http/http.js/http.node/http.json 文件，require(“http”) 都不会从这些文件中加载，而是从原生模块中加载。</p>\n<p>原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。</p>\n<h2 id=\"从文件加载\"><a href=\"#从文件加载\" class=\"headerlink\" title=\"从文件加载\"></a>从文件加载</h2><p>当文件模块缓存中不存在，而且不是原生模块的时候，Node.js 会解析 require 方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。</p>\n<p>require方法接受以下几种参数的传递：    </p>\n<ul>\n<li><p>http、fs、path等，原生模块。</p>\n</li>\n<li><p>./mod或../mod，相对路径的文件模块。</p>\n</li>\n<li><p>/pathtomodule/mod，绝对路径的文件模块。</p>\n</li>\n<li><p>mod，非原生模块的文件模块。</p>\n</li>\n</ul>\n<p>在路径 Y 下执行 require(X) 语句执行顺序：</p>\n<pre><code>1. 如果 X 是内置模块\n   a. 返回内置模块\n   b. 停止执行\n2. 如果 X 以 &apos;/&apos; 开头\n   a. 设置 Y 为文件根路径\n3. 如果 X 以 &apos;./&apos; 或 &apos;/&apos; or &apos;../&apos; 开头\n   a. LOAD_AS_FILE(Y + X)\n   b. LOAD_AS_DIRECTORY(Y + X)\n4. LOAD_NODE_MODULES(X, dirname(Y))\n5. 抛出异常 &quot;not found&quot;\n\nLOAD_AS_FILE(X)\n1. 如果 X 是一个文件, 将 X 作为 JavaScript 文本载入并停止执行。\n2. 如果 X.js 是一个文件, 将 X.js 作为 JavaScript 文本载入并停止执行。\n3. 如果 X.json 是一个文件, 解析 X.json 为 JavaScript 对象并停止执行。\n4. 如果 X.node 是一个文件, 将 X.node 作为二进制插件载入并停止执行。\n\nLOAD_INDEX(X)\n1. 如果 X/index.js 是一个文件,  将 X/index.js 作为 JavaScript 文本载入并停止执行。\n2. 如果 X/index.json 是一个文件, 解析 X/index.json 为 JavaScript 对象并停止执行。\n3. 如果 X/index.node 是一个文件,  将 X/index.node 作为二进制插件载入并停止执行。\n\nLOAD_AS_DIRECTORY(X)\n1. 如果 X/package.json 是一个文件,\n   a. 解析 X/package.json, 并查找 &quot;main&quot; 字段。\n   b. let M = X + (json main 字段)\n   c. LOAD_AS_FILE(M)\n   d. LOAD_INDEX(M)\n2. LOAD_INDEX(X)\n\nLOAD_NODE_MODULES(X, START)\n1. let DIRS=NODE_MODULES_PATHS(START)\n2. for each DIR in DIRS:\n   a. LOAD_AS_FILE(DIR/X)\n   b. LOAD_AS_DIRECTORY(DIR/X)\n\nNODE_MODULES_PATHS(START)\n1. let PARTS = path split(START)\n2. let I = count of PARTS - 1\n3. let DIRS = []\n4. while I &gt;= 0,\n   a. if PARTS[I] = &quot;node_modules&quot; CONTINUE\n   b. DIR = path join(PARTS[0 .. I] + &quot;node_modules&quot;)\n   c. DIRS = DIRS + DIR\n   d. let I = I - 1\n5. return DIRS</code></pre><p>exports 和 module.exports 的使用</p>\n<p>如果要对外暴露属性或方法，就用 exports 就行，要暴露对象(类似class，包含了很多属性和方法)，就用 module.exports。    </p>\n<h1 id=\"Node-js-函数\"><a href=\"#Node-js-函数\" class=\"headerlink\" title=\"Node.js 函数\"></a>Node.js 函数</h1><p>在JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。</p>\n<p>Node.js中函数的使用与Javascript类似，举例来说，你可以这样做：</p>\n<pre><code>function say(word) {\n  console.log(word);\n}\n\nfunction execute(someFunction, value) {\n  someFunction(value);\n}\n\nexecute(say, &quot;Hello&quot;);</code></pre><p>以上代码中，我们把 say 函数作为execute函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！</p>\n<p>这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。</p>\n<p>当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。</p>\n<h2 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h2><p>我们可以把一个函数作为变量传递。但是我们不一定要绕这个”先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：</p>\n<pre><code>function execute(someFunction, value) {\n  someFunction(value);\n}</code></pre><p>我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。</p>\n<p>用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做匿名函数 。</p>\n<h2 id=\"函数传递是如何让HTTP服务器工作的\"><a href=\"#函数传递是如何让HTTP服务器工作的\" class=\"headerlink\" title=\"函数传递是如何让HTTP服务器工作的\"></a>函数传递是如何让HTTP服务器工作的</h2><p>带着这些知识，我们再来看看我们简约而不简单的HTTP服务器：</p>\n<pre><code>var http = require(&quot;http&quot;);\n\nhttp.createServer(function(request, response) {\n  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});\n  response.write(&quot;Hello World&quot;);\n  response.end();\n}).listen(8888);</code></pre><p>现在它看上去应该清晰了很多：我们向 createServer 函数传递了一个匿名函数。</p>\n<p>用这样的代码也可以达到同样的目的：</p>\n<pre><code>var http = require(&quot;http&quot;);\n\nfunction onRequest(request, response) {\n  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});\n  response.write(&quot;Hello World&quot;);\n  response.end();\n}\n\nhttp.createServer(onRequest).listen(8888);</code></pre><h1 id=\"Node-js-路由\"><a href=\"#Node-js-路由\" class=\"headerlink\" title=\"Node.js 路由\"></a>Node.js 路由</h1><p>我们要为路由提供请求的 URL 和其他需要的 GET 及 POST 参数，随后路由需要根据这些数据来执行相应的代码。</p>\n<p>因此，我们需要查看 HTTP 请求，从中提取出请求的 URL 以及 GET/POST 参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。</p>\n<p>我们需要的所有数据都会包含在 request 对象中，该对象作为 onRequest() 回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的 Node.JS 模块，它们分别是 url 和 querystring 模块。</p>\n<pre><code>url.parse(string).query\n                                           |\n           url.parse(string).pathname      |\n                       |                   |\n                       |                   |\n                     ------ -------------------\nhttp://localhost:8888/start?foo=bar&amp;hello=world\n                                ---       -----\n                                 |          |\n                                 |          |\n              querystring.parse(queryString)[&quot;foo&quot;]    |\n                                            |\n                         querystring.parse(queryString)[&quot;hello&quot;]</code></pre><p>当然我们也可以用 querystring 模块来解析 POST 请求体中的参数，稍后会有演示。</p>\n<p>现在我们来给 onRequest() 函数加上一些逻辑，用来找出浏览器请求的 URL 路径：</p>\n<p><strong>server.js 文件代码：</strong></p>\n<pre><code>var http = require(&quot;http&quot;);\nvar url = require(&quot;url&quot;);\n\nfunction start() {\n  function onRequest(request, response) {\n    var pathname = url.parse(request.url).pathname;\n    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);\n    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});\n    response.write(&quot;Hello World&quot;);\n    response.end();\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(&quot;Server has started.&quot;);\n}\n\nexports.start = start;</code></pre><p>好了，我们的应用现在可以通过请求的 URL 路径来区别不同请求了–这使我们得以使用路由（还未完成）来将请求以 URL 路径为基准映射到处理程序上。</p>\n<p>在我们所要构建的应用中，这意味着来自 /start 和 /upload 的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。</p>\n<p>现在我们可以来编写路由了，建立一个名为 router.js 的文件，添加以下内容：<br><strong>router.js</strong></p>\n<pre><code>function route(pathname) {\n  console.log(&quot;About to route a request for &quot; + pathname);\n}\n\nexports.route = route;</code></pre><p>如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。</p>\n<p>我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块。</p>\n<p>首先，我们来扩展一下服务器的 start() 函数，以便将路由函数作为参数传递过去，server.js 文件代码如下</p>\n<pre><code>var http = require(&quot;http&quot;);\nvar url = require(&quot;url&quot;);\n\nfunction start(route) {\n  function onRequest(request, response) {\n    var pathname = url.parse(request.url).pathname;\n    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);\n\n    route(pathname);\n\n    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});\n    response.write(&quot;Hello World&quot;);\n    response.end();\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(&quot;Server has started.&quot;);\n}\n\nexports.start = start;</code></pre><p>同时，我们会相应扩展 index.js，使得路由函数可以被注入到服务器中：</p>\n<p><strong>index.js 文件代码：</strong></p>\n<pre><code>var server = require(&quot;./server&quot;);\nvar router = require(&quot;./router&quot;);\n\nserver.start(router.route);</code></pre><p>在这里，我们传递的函数依旧什么也没做。</p>\n<p>如果现在启动应用（node index.js，始终记得这个命令行），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：</p>\n<pre><code>$ node index.js\nServer has started.        \n\n以上输出已经去掉了比较烦人的 /favicon.ico 请求相关的部分。\n\n浏览器访问 http://127.0.0.1:8888/，输出结果如下：</code></pre><h1 id=\"Node-js-全局对象\"><a href=\"#Node-js-全局对象\" class=\"headerlink\" title=\"Node.js 全局对象\"></a>Node.js 全局对象</h1><p>avaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。</p>\n<p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p>\n<p>在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</p>\n<h2 id=\"全局对象与全局变量\"><a href=\"#全局对象与全局变量\" class=\"headerlink\" title=\"全局对象与全局变量\"></a>全局对象与全局变量</h2><p>global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量：</p>\n<ul>\n<li><p>在最外层定义的变量；</p>\n</li>\n<li><p>全局对象的属性；</p>\n</li>\n<li><p>隐式定义的变量（未定义直接赋值的变量）。</p>\n</li>\n</ul>\n<p>你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注 意的是，在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。</p>\n<p>注意： 最好不要使用 var 定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险。</p>\n<h2 id=\"filename\"><a href=\"#filename\" class=\"headerlink\" title=\"__filename\"></a>__filename</h2><p>_filename 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。</p>\n<p><strong>实例</strong><br>创建文件 main.js ，代码如下所示：</p>\n<pre><code>// 输出全局变量 __filename 的值\nconsole.log( __filename );</code></pre><p>执行 main.js 文件，代码如下所示:</p>\n<pre><code>$ node main.js\n/web/com/runoob/nodejs/main.js</code></pre><h2 id=\"dirname\"><a href=\"#dirname\" class=\"headerlink\" title=\"__dirname\"></a>__dirname</h2><p>__dirname 表示当前执行脚本所在的目录。</p>\n<p><strong>实例</strong>    </p>\n<p>创建文件 main.js ，代码如下所示：</p>\n<pre><code>// 输出全局变量 __dirname 的值\nconsole.log( __dirname );</code></pre><p>执行 main.js 文件，代码如下所示:</p>\n<pre><code>$ node main.js\n/web/com/runoob/nodejs</code></pre><h2 id=\"setTimeout-cb-ms\"><a href=\"#setTimeout-cb-ms\" class=\"headerlink\" title=\"setTimeout(cb, ms)\"></a>setTimeout(cb, ms)</h2><p>setTimeout(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout() 只执行一次指定函数。</p>\n<p>返回一个代表定时器的句柄值。</p>\n<p><strong>实例</strong>    </p>\n<p>创建文件 main.js ，代码如下所示：</p>\n<pre><code>function printHello(){\n   console.log( &quot;Hello, World!&quot;);\n}\n// 两秒后执行以上函数\nsetTimeout(printHello, 2000);</code></pre><p>执行 main.js 文件，代码如下所示:</p>\n<pre><code>$ node main.js\nHello, World!    </code></pre><h2 id=\"clearTimeout-t\"><a href=\"#clearTimeout-t\" class=\"headerlink\" title=\"clearTimeout(t)\"></a>clearTimeout(t)</h2><p>clearTimeout( t ) 全局函数用于停止一个之前通过 setTimeout() 创建的定时器。 参数 t 是通过 setTimeout() 函数创建的定时器。    </p>\n<p>实例<br>创建文件 main.js ，代码如下所示：</p>\n<pre><code>function printHello(){\n   console.log( &quot;Hello, World!&quot;);\n}\n// 两秒后执行以上函数\nvar t = setTimeout(printHello, 2000);\n\n// 清除定时器\nclearTimeout(t);</code></pre><p>执行 main.js 文件，代码如下所示:</p>\n<pre><code>$ node main.js    </code></pre><h2 id=\"setInterval-cb-ms\"><a href=\"#setInterval-cb-ms\" class=\"headerlink\" title=\"setInterval(cb, ms)\"></a>setInterval(cb, ms)</h2><p>setInterval(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。</p>\n<p>返回一个代表定时器的句柄值。可以使用 clearInterval(t) 函数来清除定时器。</p>\n<p>setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。</p>\n<p>实例<br>创建文件 main.js ，代码如下所示：</p>\n<pre><code>function printHello(){\n   console.log( &quot;Hello, World!&quot;);\n}\n// 两秒后执行以上函数\nsetInterval(printHello, 2000);</code></pre><p>执行 main.js 文件，代码如下所示:</p>\n<pre><code>$ node main.js\nHello, World!\nHello, World!\nHello, World!\nHello, World!\nHello, World!\nHello, World!\nHello, World!</code></pre><p>以上程序每隔两秒就会输出一次”Hello, World!”，且会永久执行下去，直到你按下 ctrl + c 按钮。</p>\n<h2 id=\"console\"><a href=\"#console\" class=\"headerlink\" title=\"console\"></a>console</h2><p>console 用于提供控制台标准输出，它是由 Internet Explorer 的 JScript 引擎提供的调试工具，后来逐渐成为浏览器的实施标准。</p>\n<p>Node.js 沿用了这个标准，提供与习惯行为一致的 console 对象，用于向标准输出流（stdout）或标准错误流（stderr）输出字符。</p>\n<h3 id=\"console-log-data-…\"><a href=\"#console-log-data-…\" class=\"headerlink\" title=\"console.log([data][, …])\"></a>console.log([data][, …])</h3><p>向标准输出流打印字符并以换行符结束。该方法接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。</p>\n<h3 id=\"console-info-data-…\"><a href=\"#console-info-data-…\" class=\"headerlink\" title=\"console.info([data][, …])\"></a>console.info([data][, …])</h3><p>该命令的作用是返回信息性消息，这个命令与console.log差别并不大，除了在chrome中只会输出文字外，其余的会显示一个蓝色的惊叹号。</p>\n<h3 id=\"console-error-data-…\"><a href=\"#console-error-data-…\" class=\"headerlink\" title=\"console.error([data][, …])\"></a>console.error([data][, …])</h3><p>输出错误消息的。控制台在出现错误时会显示是红色的叉子。</p>\n<h3 id=\"console-warn-data-…\"><a href=\"#console-warn-data-…\" class=\"headerlink\" title=\"console.warn([data][, …])\"></a>console.warn([data][, …])</h3><p>输出警告消息。控制台出现有黄色的惊叹号。</p>\n<h3 id=\"console-dir-obj-options\"><a href=\"#console-dir-obj-options\" class=\"headerlink\" title=\"console.dir(obj[, options])\"></a>console.dir(obj[, options])</h3><p>用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</p>\n<h3 id=\"console-time-label\"><a href=\"#console-time-label\" class=\"headerlink\" title=\"console.time(label)\"></a>console.time(label)</h3><p>输出时间，表示计时开始。</p>\n<h3 id=\"console-timeEnd-label\"><a href=\"#console-timeEnd-label\" class=\"headerlink\" title=\"console.timeEnd(label)\"></a>console.timeEnd(label)</h3><p>结束时间，表示计时结束。</p>\n<h3 id=\"console-trace-message-…\"><a href=\"#console-trace-message-…\" class=\"headerlink\" title=\"console.trace(message[, …])\"></a>console.trace(message[, …])</h3><p>当前执行的代码在堆栈中的调用路径，这个测试函数运行很有帮助，只要给想测试的函数里面加入 console.trace 就行了。</p>\n<h3 id=\"console-assert-value-message-…\"><a href=\"#console-assert-value-message-…\" class=\"headerlink\" title=\"console.assert(value[, message][, …])\"></a>console.assert(value[, message][, …])</h3><p>用于判断某个表达式或变量是否为真，接收两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。</p>\n<p>console.log()：向标准输出流打印字符并以换行符结束。<br>console.log 接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。</p>\n<p>第一个参数是一个字符串，如果没有 参数，只打印一个换行。</p>\n<pre><code>console.log(&apos;Hello world&apos;); \nconsole.log(&apos;byvoid%diovyb&apos;); \nconsole.log(&apos;byvoid%diovyb&apos;, 1991); \n运行结果为：\n\nHello world \nbyvoid%diovyb \nbyvoid1991iovyb \n\nconsole.error()：与console.log() 用法相同，只是向标准错误流输出。\nconsole.trace()：向标准错误流输出当前的调用栈。\n\nconsole.trace();\n\n运行结果为：\n\nTrace: \nat Object.&lt;anonymous&gt; (/home/byvoid/consoletrace.js:1:71) \nat Module._compile (module.js:441:26) \nat Object..js (module.js:459:10) \nat Module.load (module.js:348:31) \nat Function._load (module.js:308:12) \nat Array.0 (module.js:479:10) \nat EventEmitter._tickCallback (node.js:192:40)\n\nconsole.info(&quot;程序开始执行：&quot;);\n\nvar counter = 10;\nconsole.log(&quot;计数: %d&quot;, counter);\n\nconsole.time(&quot;获取数据&quot;);\n//\n// 执行一些代码\n// \nconsole.timeEnd(&apos;获取数据&apos;);\n\nconsole.info(&quot;程序执行完毕。&quot;)\n\n程序开始执行：\n计数: 10\n获取数据: 0ms\n程序执行完毕</code></pre><h2 id=\"process\"><a href=\"#process\" class=\"headerlink\" title=\"process\"></a>process</h2><p>process 是一个全局变量，即 global 对象的属性。</p>\n<p>它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要 和它打交道。下面将会介绍 process 对象的一些最常用的成员方法。</p>\n<h3 id=\"exit\"><a href=\"#exit\" class=\"headerlink\" title=\"exit\"></a>exit</h3><p>当进程准备退出时触发。</p>\n<h3 id=\"beforeExit\"><a href=\"#beforeExit\" class=\"headerlink\" title=\"beforeExit\"></a>beforeExit</h3><p>当 node 清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时 node 退出，但是 ‘beforeExit’ 的监听器可以异步调用，这样 node 就会继续执行。</p>\n<h3 id=\"uncaughtException\"><a href=\"#uncaughtException\" class=\"headerlink\" title=\"uncaughtException\"></a>uncaughtException</h3><p>当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。</p>\n<h3 id=\"Signal-事件\"><a href=\"#Signal-事件\" class=\"headerlink\" title=\"Signal 事件\"></a>Signal 事件</h3><p>当进程接收到信号时就触发。信号列表详见标准的 POSIX 信号名，如 SIGINT、SIGUSR1 等。</p>\n<h3 id=\"实例-8\"><a href=\"#实例-8\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>创建文件 main.js ，代码如下所示：</p>\n<pre><code>process.on(&apos;exit&apos;, function(code) {\n\n  // 以下代码永远不会执行\n  setTimeout(function() {\n    console.log(&quot;该代码不会执行&quot;);\n  }, 0);\n\n  console.log(&apos;退出码为:&apos;, code);\n});\nconsole.log(&quot;程序执行结束&quot;);</code></pre><p>执行 main.js 文件，代码如下所示:</p>\n<pre><code>$ node main.js\n程序执行结束\n退出码为: 0</code></pre><h3 id=\"退出状态码\"><a href=\"#退出状态码\" class=\"headerlink\" title=\"退出状态码\"></a>退出状态码</h3><table>\n<thead>\n<tr>\n<th align=\"left\">状态码</th>\n<th align=\"left\">名称&amp;描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">Uncaught Fatal Exception <br> 有未捕获异常，并且没有被域或 uncaughtException 处理函数处理。</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">Unused <br> 保留</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">Internal JavaScript Parse Error  <br> JavaScript的源码启动 Node 进程时引起解析错误。非常罕见，仅会在开发 Node 时才会有。</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">Internal JavaScript Evaluation Failure  <br> JavaScript 的源码启动 Node 进程，评估时返回函数失败。非常罕见，仅会在开发 Node 时才会有。</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">Fatal Error  <br> V8 里致命的不可恢复的错误。通常会打印到 stderr ，内容为： FATAL ERROR</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">Non-function Internal Exception Handler  <br> 未捕获异常，内部异常处理函数不知为何设置为on-function，并且不能被调用。</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">Internal Exception Handler Run-Time Failure  <br> 未捕获的异常， 并且异常处理函数处理时自己抛出了异常。例如，如果 process.on(‘uncaughtException’) 或 domain.on(‘error’) 抛出了异常。</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">Unused  <br> 保留</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">Invalid Argument  <br> 可能是给了未知的参数，或者给的参数没有值。</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">Internal JavaScript Run-Time Failure  <br> JavaScript的源码启动 Node 进程时抛出错误，非常罕见，仅会在开发 Node 时才会有。</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">Invalid Debug Argument   <br> 设置了参数–debug 和/或 –debug-brk，但是选择了错误端口。</td>\n</tr>\n<tr>\n<td align=\"left\">128</td>\n<td align=\"left\">Signal Exits  <br> 如果 Node 接收到致命信号，比如SIGKILL 或 SIGHUP，那么退出代码就是128 加信号代码。这是标准的 Unix 做法，退出信号代码放在高位。</td>\n</tr>\n</tbody></table>\n<h3 id=\"Process-属性\"><a href=\"#Process-属性\" class=\"headerlink\" title=\"Process 属性\"></a>Process 属性</h3><p>Process 提供了很多有用的属性，便于我们更好的控制系统的交互：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">属性&amp;描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">stdout <br> 标准输出流。</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">stderr <br> 标准错误流。</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">stdin <br> 标准输入流。</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">argv <br> argv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">execPath <br> 返回执行当前脚本的 Node 二进制文件的绝对路径。</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">execArgv <br> 返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">env <br> 返回一个对象，成员为当前 shell 的环境变量</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">exitCode <br> 进程退出时的代码，如果进程优通过 process.exit() 退出，不需要指定退出码。</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">version <br> Node 的版本，比如v0.10.18。</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">versions <br> 一个属性，包含了 node 的版本和依赖.</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">config <br> 一个包含用来编译当前 node 执行文件的 javascript 配置选项的对象。它与运行 ./configure 脚本生成的 “config.gypi” 文件相同。</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">pid <br> 当前进程的进程号。</td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">title <br> 进程名，默认值为”node”，可以自定义该值。</td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">arch <br> 当前 CPU 的架构：’arm’、’ia32’ 或者 ‘x64’。</td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">platform <br> 运行程序所在的平台系统 ‘darwin’, ‘freebsd’, ‘linux’, ‘sunos’ 或 ‘win32’</td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">mainModule<br> require.main 的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。</td>\n</tr>\n</tbody></table>\n<p><strong><em>实例</em></strong><br>创建文件 main.js ，代码如下所示：</p>\n<pre><code>// 输出到终端\nprocess.stdout.write(&quot;Hello World!&quot; + &quot;\\n&quot;);\n\n// 通过参数读取\nprocess.argv.forEach(function(val, index, array) {\n   console.log(index + &apos;: &apos; + val);\n});\n\n// 获取执行路径\nconsole.log(process.execPath);\n\n\n// 平台信息\nconsole.log(process.platform);</code></pre><p>执行 main.js 文件，代码如下所示:</p>\n<pre><code>$ node main.js\nHello World!\n0: node\n1: /web/www/node/main.js\n/usr/local/node/0.10.36/bin/node\ndarwin</code></pre><p><strong>方法参考手册</strong><br>Process 提供了很多有用的方法，便于我们更好的控制系统的交互：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">方法 &amp; 描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">abort() <br> 这将导致node触发abort事件。会让node退出并生成一个核心文件</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">chdir(directory) <br> 改变当前工作进程的目录，如果操作失败抛出异常。</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">cwd() <br> 返回当前进程的工作目录</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">exit([code]) <br> 使用指定的 code 结束进程。如果忽略，将会使用 code 0。</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">getgid() <br> 取进程的群组标识（参见 getgid(2)）。获取到得时群组的数字 id，而不是名字. 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">setgid(id) <br> 设置进程的群组标识（参见 setgid(2)）。可以接收数字 ID 或者群组名。如果指定了群组名，会阻塞等待解析为数字 ID 。                    注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">getuid() <br> 获取进程的用户标识(参见 getuid(2))。这是数字的用户 id，不是用户名。                  注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">setuid(id) <br> 设置进程的用户标识（参见setuid(2)）。接收数字 ID或字符串名字。果指定了群组名，会阻塞等待解析为数字 ID 。                    注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">getgroups() <br> 返回进程的群组 iD 数组。POSIX 系统没有保证一定有，但是 node.js 保证有。                     注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">setgroups(groups) <br> 设置进程的群组 ID。这是授权操作，所以你需要有 root 权限，或者有 CAP_SETGID 能力。                            注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">initgroups(user, extra_group) <br> 读取 /etc/group ，并初始化群组访问列表，使用成员所在的所有群组。这是授权操作，所以你需要有 root 权限，或者有 CAP_SETGID 能力。                                        注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">kill(pid[, signal]) <br> 发送信号给进程. pid 是进程id，并且 signal 是发送的信号的字符串描述。信号名是字符串，比如 ‘SIGINT’ 或 ‘SIGHUP’。如果忽略，信号会是 ‘SIGTERM’。</td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">memoryUsage() <br> 返回一个对象，描述了 Node 进程所用的内存状况，单位为字节。</td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">nextTick(callback) <br> 一旦当前事件循环结束，调用回调函数。</td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">umask([mask]) <br> 设置或读取进程文件的掩码。子进程从父进程继承掩码。如果mask 参数有效，返回旧的掩码。否则，返回当前掩码。</td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">uptime() <br> 返回 Node 已经运行的秒数。</td>\n</tr>\n<tr>\n<td align=\"left\">17</td>\n<td align=\"left\">hrtime() <br> 返回当前进程的高分辨时间，形式为 [seconds, nanoseconds]数组。它是相对于过去的任意事件。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。                   你可以将之前的结果传递给当前的 process.hrtime() ，会返回两者间的时间差，用来基准和测量时间间隔。</td>\n</tr>\n</tbody></table>\n<h2 id=\"实例-9\"><a href=\"#实例-9\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>创建文件 main.js ，代码如下所示：</p>\n<pre><code>// 输出当前目录\nconsole.log(&apos;当前目录: &apos; + process.cwd());\n\n// 输出当前版本\nconsole.log(&apos;当前版本: &apos; + process.version);\n\n// 输出内存使用情况\nconsole.log(process.memoryUsage());</code></pre><p>执行 main.js 文件，代码如下所示:</p>\n<pre><code>$ node main.js\n当前目录: /web/com/runoob/nodejs\n当前版本: v0.10.36\n{ rss: 12541952, heapTotal: 4083456, heapUsed: 2157056 }</code></pre><h1 id=\"Node-js-常用工具\"><a href=\"#Node-js-常用工具\" class=\"headerlink\" title=\"Node.js 常用工具\"></a>Node.js 常用工具</h1><p>util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。</p>\n<p>util.inherits<br>util.inherits(constructor, superConstructor) 是一个实现对象间原型继承的函数。</p>\n<p>JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有提供对象继承的语言级别特性，而是通过原型复制来实现的。</p>\n<p>在这里我们只介绍 util.inherits 的用法，示例如下</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><ul>\n<li><p>简单的说 Node.js 就是运行在服务端的 JavaScript。</p>\n</li>\n<li><p>Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。</p>\n</li>\n<li><p>Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</p>\n</li>\n</ul>\n<h2 id=\"查看版本\"><a href=\"#查看版本\" class=\"headerlink\" title=\"查看版本\"></a>查看版本</h2><pre><code>node -v\nv12.9.0</code></pre><h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h2><p>   vim helloWorld.js</p>\n<p>   console.log(“Hello World”);</p>\n<p>   node helloWorld.js</p>\n<h2 id=\"交互模式\"><a href=\"#交互模式\" class=\"headerlink\" title=\"交互模式\"></a>交互模式</h2><pre><code>$ node\n&gt; console.log(&apos;Hello World!&apos;);\nHello World!</code></pre><h1 id=\"Node-js-安装配置\"><a href=\"#Node-js-安装配置\" class=\"headerlink\" title=\"Node.js 安装配置\"></a>Node.js 安装配置</h1><pre><code>Mac安装\nbrew install node</code></pre><h1 id=\"Node-js-创建第一个应用\"><a href=\"#Node-js-创建第一个应用\" class=\"headerlink\" title=\"Node.js 创建第一个应用\"></a>Node.js 创建第一个应用</h1><h2 id=\"步骤一、引入-required-模块\"><a href=\"#步骤一、引入-required-模块\" class=\"headerlink\" title=\"步骤一、引入 required 模块\"></a>步骤一、引入 required 模块</h2><p>我们使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下:</p>\n<pre><code>var http = require(&quot;http&quot;);</code></pre><h2 id=\"步骤二、创建服务器\"><a href=\"#步骤二、创建服务器\" class=\"headerlink\" title=\"步骤二、创建服务器\"></a>步骤二、创建服务器</h2><p>接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。</p>\n<p>实例如下，在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：</p>\n<pre><code>var http = require(&apos;http&apos;);\nhttp.createServer(function (request, response) {\n\n    // 发送 HTTP 头部 \n    // HTTP 状态值: 200 : OK\n    // 内容类型: text/plain\n    response.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;});\n\n    // 发送响应数据 &quot;Hello World&quot;\n    response.end(&apos;Hello World\\n&apos;);\n}).listen(8888);\n\n// 终端打印如下信息\nconsole.log(&apos;Server running at http://127.0.0.1:8888/&apos;);</code></pre><p>以上代码我们完成了一个可以工作的 HTTP 服务器。</p>\n<p>使用 node 命令执行以上的代码：</p>\n<pre><code>node server.js\nServer running at http://127.0.0.1:8888/</code></pre><p>接下来，打开浏览器访问 <a href=\"http://127.0.0.1:8888/，你会看到一个写着\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8888/，你会看到一个写着</a> “Hello World”的网页。</p>\n<h2 id=\"分析Node-js-的-HTTP-服务器：\"><a href=\"#分析Node-js-的-HTTP-服务器：\" class=\"headerlink\" title=\"分析Node.js 的 HTTP 服务器：\"></a>分析Node.js 的 HTTP 服务器：</h2><ul>\n<li><p>第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。</p>\n</li>\n<li><p>接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。</p>\n</li>\n</ul>\n<h1 id=\"NPM-使用介绍\"><a href=\"#NPM-使用介绍\" class=\"headerlink\" title=\"NPM 使用介绍\"></a>NPM 使用介绍</h1><p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p>\n<ul>\n<li><p>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</p>\n</li>\n<li><p>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</p>\n</li>\n<li><p>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</p>\n</li>\n</ul>\n<h2 id=\"查看版本-1\"><a href=\"#查看版本-1\" class=\"headerlink\" title=\"查看版本\"></a>查看版本</h2><pre><code>$ npm -v\n6.10.3</code></pre><h2 id=\"升级\"><a href=\"#升级\" class=\"headerlink\" title=\"升级\"></a>升级</h2><pre><code>$ sudo npm install npm -g</code></pre><p>如果是 Window 系统使用以下命令即可：</p>\n<pre><code>npm install npm -g</code></pre><p>使用淘宝镜像的命令：</p>\n<pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><h2 id=\"使用-npm-命令安装模块\"><a href=\"#使用-npm-命令安装模块\" class=\"headerlink\" title=\"使用 npm 命令安装模块\"></a>使用 npm 命令安装模块</h2><p>npm 安装 Node.js 模块语法格式如下：</p>\n<pre><code>$ npm install &lt;Module Name&gt;</code></pre><p>以下实例，我们使用 npm 命令安装常用的 Node.js web框架模块 express:</p>\n<pre><code>$ npm install express</code></pre><p>安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 require(‘express’) 的方式就好，无需指定第三方包路径。</p>\n<pre><code>var express = require(&apos;express&apos;);</code></pre><h2 id=\"全局安装与本地安装\"><a href=\"#全局安装与本地安装\" class=\"headerlink\" title=\"全局安装与本地安装\"></a>全局安装与本地安装</h2><p>npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，比如</p>\n<pre><code>npm install express          # 本地安装\nnpm install express -g   # 全局安装</code></pre><p>如果出现以下错误：</p>\n<pre><code>npm err! Error: connect ECONNREFUSED 127.0.0.1:8087 </code></pre><p>解决办法为：</p>\n<pre><code>$ npm config set proxy null</code></pre><h2 id=\"本地安装\"><a href=\"#本地安装\" class=\"headerlink\" title=\"本地安装\"></a>本地安装</h2><ul>\n<li><p>1.将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</p>\n</li>\n<li><p>2.可以通过 require() 来引入本地安装的包。</p>\n</li>\n</ul>\n<h2 id=\"全局安装\"><a href=\"#全局安装\" class=\"headerlink\" title=\"全局安装\"></a>全局安装</h2><ul>\n<li>1.将安装包放在 /usr/local 下或者你 node 的安装目录。</li>\n<li>2.可以直接在命令行里使用。</li>\n</ul>\n<p>如果你希望具备两者功能，则需要在两个地方安装它或使用 npm link。<br>接下来我们使用全局方式安装 express</p>\n<pre><code>$ npm install express -g</code></pre><h2 id=\"查看安装信息\"><a href=\"#查看安装信息\" class=\"headerlink\" title=\"查看安装信息\"></a>查看安装信息</h2><p>你可以使用以下命令来查看所有全局安装的模块：</p>\n<pre><code>$ npm list -g\n\n├─┬ cnpm@4.3.2\n│ ├── auto-correct@1.0.0\n│ ├── bagpipe@0.3.5\n│ ├── colors@1.1.2\n│ ├─┬ commander@2.9.0\n│ │ └── graceful-readlink@1.0.1\n│ ├─┬ cross-spawn@0.2.9\n│ │ └── lru-cache@2.7.3\n……</code></pre><p>如果要查看某个模块的版本号，可以使用命令如下：</p>\n<pre><code>$ npm list grunt\n\nprojectName@projectVersion /path/to/project/folder\n└── grunt@0.4.1</code></pre><h2 id=\"使用-package-json\"><a href=\"#使用-package-json\" class=\"headerlink\" title=\"使用 package.json\"></a>使用 package.json</h2><p>package.json 位于模块的目录下，用于定义包的属性。接下来让我们来看下 express 包的 package.json 文件，位于 node_modules/express/package.json 内容：</p>\n<h2 id=\"Package-json-属性说明\"><a href=\"#Package-json-属性说明\" class=\"headerlink\" title=\"Package.json 属性说明\"></a>Package.json 属性说明</h2><pre><code>name - 包名。\n\nversion - 包的版本号。\n\ndescription - 包的描述。\n\nhomepage - 包的官网 url 。\n\nauthor - 包的作者姓名。\n\ncontributors - 包的其他贡献者姓名。\n\ndependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。\n\nrepository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。\n\nmain - main 字段指定了程序的主入口文件，require(&apos;moduleName&apos;) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。\n\nkeywords - 关键字</code></pre><h2 id=\"卸载模块\"><a href=\"#卸载模块\" class=\"headerlink\" title=\"卸载模块\"></a>卸载模块</h2><p>我们可以使用以下命令来卸载 Node.js 模块。</p>\n<pre><code>$ npm uninstall express</code></pre><p>卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看：</p>\n<pre><code>$ npm ls</code></pre><h2 id=\"更新模块\"><a href=\"#更新模块\" class=\"headerlink\" title=\"更新模块\"></a>更新模块</h2><pre><code>$ npm update express</code></pre><h2 id=\"搜索模块\"><a href=\"#搜索模块\" class=\"headerlink\" title=\"搜索模块\"></a>搜索模块</h2><pre><code>$ npm search express</code></pre><h2 id=\"创建模块\"><a href=\"#创建模块\" class=\"headerlink\" title=\"创建模块\"></a>创建模块</h2><p>创建模块，package.json 文件是必不可少的。我们可以使用 NPM 生成 package.json 文件，生成的文件包含了基本的结果。</p>\n<pre><code>$ npm init\nThis utility will walk you through creating a package.json file.\nIt only covers the most common items, and tries to guess sensible defaults.\n\nSee `npm help json` for definitive documentation on these fields\nand exactly what they do.\n\nUse `npm install &lt;pkg&gt; --save` afterwards to install a package and\nsave it as a dependency in the package.json file.\n\nPress ^C at any time to quit.\nname: (node_modules) runoob                   # 模块名\nversion: (1.0.0) \ndescription: Node.js 测试模块(www.runoob.com)  # 描述\nentry point: (index.js) \ntest command: make test\ngit repository: https://github.com/runoob/runoob.git  # Github 地址\nkeywords: \nauthor: \nlicense: (ISC) \nAbout to write to ……/node_modules/package.json:      # 生成地址\n\n{\n  &quot;name&quot;: &quot;runoob&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;Node.js 测试模块(www.runoob.com)&quot;,\n  ……\n}\n\n\nIs this ok? (yes) yes</code></pre><p>以上的信息，你需要根据你自己的情况输入。在最后输入 “yes” 后会生成 package.json 文件。</p>\n<p>接下来我们可以使用以下命令在 npm 资源库中注册用户（使用邮箱注册）：</p>\n<pre><code>$ npm adduser\nUsername: mcmohd\nPassword:\nEmail: (this IS public) mcmohd@gmail.com</code></pre><p>接下来我们就用以下命令来发布模块：</p>\n<pre><code>$ npm publish</code></pre><p>如果你以上的步骤都操作正确，你就可以跟其他模块一样使用 npm 来安装。</p>\n<h2 id=\"版本号\"><a href=\"#版本号\" class=\"headerlink\" title=\"版本号\"></a>版本号</h2><p>使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。</p>\n<p>语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。</p>\n<ul>\n<li>如果只是修复bug，需要更新Z位。</li>\n<li>如果是新增了功能，但是向下兼容，需要更新Y位。</li>\n<li>如果有大变动，向下不兼容，需要更新X位。</li>\n</ul>\n<p>版本号有了这个保证后，在申明第三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如”argv”: “0.0.x”表示依赖于0.0.x系列的最新版argv。                    </p>\n<p>NPM支持的所有版本号范围指定方式可以查看<a href=\"https://docs.npmjs.com/\" target=\"_blank\" rel=\"noopener\">官方文档</a>。</p>\n<h2 id=\"NPM-常用命令\"><a href=\"#NPM-常用命令\" class=\"headerlink\" title=\"NPM 常用命令\"></a>NPM 常用命令</h2><p>使用npm help可查看所有命令。</p>\n<ul>\n<li><p>NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。</p>\n</li>\n<li><p>使用npm help <command>可查看某条命令的详细帮助，例如npm help install。</p>\n</li>\n<li><p>在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。</p>\n</li>\n<li><p>使用npm update <package>可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。</package></p>\n</li>\n<li><p>使用npm update <package> -g可以把全局安装的对应命令行程序更新至最新版。</package></p>\n</li>\n<li><p>使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</p>\n</li>\n<li><p>使用npm unpublish <package>@<version>可以撤销发布自己发布过的某个版本代码。</version></package></p>\n</li>\n</ul>\n<h2 id=\"使用淘宝-NPM-镜像\"><a href=\"#使用淘宝-NPM-镜像\" class=\"headerlink\" title=\"使用淘宝 NPM 镜像\"></a>使用淘宝 NPM 镜像</h2><p>大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。</p>\n<p>淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。</p>\n<p>你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:</p>\n<pre><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>这样就可以使用 cnpm 命令来安装模块了：</p>\n<pre><code>$ cnpm install [name]</code></pre><h1 id=\"Node-js-REPL-交互式解释器\"><a href=\"#Node-js-REPL-交互式解释器\" class=\"headerlink\" title=\"Node.js REPL(交互式解释器)\"></a>Node.js REPL(交互式解释器)</h1><p>Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。</p>\n<p>Node 自带了交互式解释器，可以执行以下任务：</p>\n<ul>\n<li><p>读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。</p>\n</li>\n<li><p>执行 - 执行输入的数据结构</p>\n</li>\n<li><p>打印 - 输出结果</p>\n</li>\n<li><p>循环 - 循环操作以上步骤直到用户<strong><em>两次</em></strong>按下  <strong>ctrl-c</strong>  按钮退出。</p>\n</li>\n</ul>\n<p>Node 的交互式解释器可以很好的调试 Javascript 代码。</p>\n<h2 id=\"启动-Node-的终端：\"><a href=\"#启动-Node-的终端：\" class=\"headerlink\" title=\"启动 Node 的终端：\"></a>启动 Node 的终端：</h2><pre><code>$ node\nWelcome to Node.js v12.9.0.\nType &quot;.help&quot; for more information.\n&gt;</code></pre><h2 id=\"简单的表达式运算\"><a href=\"#简单的表达式运算\" class=\"headerlink\" title=\"简单的表达式运算\"></a>简单的表达式运算</h2><p>这时我们就可以在 &gt; 后输入简单的表达式，并按下回车键来计算结果。</p>\n<pre><code>$ node\n&gt; 1 +4\n5\n&gt; 5 / 2\n2.5\n&gt; 3 * 6\n18\n&gt; 4 - 1\n3\n&gt; 1 + ( 2 * 3 ) - 4\n3\n&gt;</code></pre><h2 id=\"使用变量\"><a href=\"#使用变量\" class=\"headerlink\" title=\"使用变量\"></a>使用变量</h2><p>你可以将数据存储在变量中，并在你需要的时候使用它。</p>\n<p>变量声明需要使用 var 关键字，如果没有使用 var 关键字变量会直接打印出来。</p>\n<p>使用 var 关键字的变量可以使用 console.log() 来输出变量。</p>\n<pre><code>$ node\n&gt; x = 10\n10\n&gt; var y = 10\nundefined\n&gt; x + y\n20\n&gt; console.log(&quot;Hello World&quot;)\nHello World\nundefined\n&gt; console.log(&quot;www.runoob.com&quot;)\nwww.runoob.com\nundefined</code></pre><h2 id=\"多行表达式\"><a href=\"#多行表达式\" class=\"headerlink\" title=\"多行表达式\"></a>多行表达式</h2><p>Node REPL 支持输入多行表达式，这就有点类似 JavaScript。接下来让我们来执行一个 do-while 循环：</p>\n<pre><code>$ node\n&gt; var x = 0\nundefined\n&gt; do {\n... x++;\n... console.log(&quot;x: &quot; + x);\n... } while ( x &lt; 5 );\nx: 1\nx: 2\nx: 3\nx: 4\nx: 5\nundefined\n&gt;</code></pre><p>… 三个点的符号是系统自动生成的，你回车换行后即可。Node 会自动检测是否为连续的表达式。</p>\n<h2 id=\"下划线-变量\"><a href=\"#下划线-变量\" class=\"headerlink\" title=\"下划线(_)变量\"></a>下划线(_)变量</h2><p>你可以使用下划线(_)获取上一个表达式的运算结果：</p>\n<pre><code>$ node\n&gt; var x = 10\nundefined\n&gt; var y = 20\nundefined\n&gt; x + y\n30\n&gt; var sum = _\nundefined\n&gt; console.log(sum)\n30\nundefined\n&gt;</code></pre><h2 id=\"REPL-命令\"><a href=\"#REPL-命令\" class=\"headerlink\" title=\"REPL 命令\"></a>REPL 命令</h2><ul>\n<li><p>ctrl + c - 退出当前终端。</p>\n</li>\n<li><p>ctrl + c 按下两次 - 退出 Node REPL。</p>\n</li>\n<li><p>ctrl + d - 退出 Node REPL.</p>\n</li>\n<li><p>向上/向下 键 - 查看输入的历史命令</p>\n</li>\n<li><p>tab 键 - 列出当前命令</p>\n</li>\n<li><p>.help - 列出使用命令</p>\n</li>\n<li><p>.break - 退出多行表达式</p>\n</li>\n<li><p>.clear - 退出多行表达式</p>\n</li>\n<li><p>.save filename - 保存当前的 Node REPL 会话到指定文件</p>\n</li>\n<li><p>.load filename - 载入当前 Node REPL 会话的文件内容。</p>\n</li>\n</ul>\n<h2 id=\"停止-REPL\"><a href=\"#停止-REPL\" class=\"headerlink\" title=\"停止 REPL\"></a>停止 REPL</h2><p>前面我们已经提到按下两次 ctrl + c 键就能退出 REPL:</p>\n<pre><code>$ node\n&gt;\n(^C again to quit)\n&gt;      </code></pre><h1 id=\"Node-js-回调函数\"><a href=\"#Node-js-回调函数\" class=\"headerlink\" title=\"Node.js 回调函数\"></a>Node.js 回调函数</h1><p>Node.js 异步编程的直接体现就是回调。</p>\n<p>异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。</p>\n<p>回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。</p>\n<p>例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。</p>\n<p>回调函数一般作为函数的最后一个参数出现：</p>\n<pre><code>function foo1(name, age, callback) { }\nfunction foo2(value, callback1, callback2) { }</code></pre><h2 id=\"阻塞代码实例\"><a href=\"#阻塞代码实例\" class=\"headerlink\" title=\"阻塞代码实例\"></a>阻塞代码实例</h2><p>创建一个文件 input.txt ，内容如下：</p>\n<pre><code>菜鸟教程官网地址：www.runoob.com</code></pre><p>创建 main.js 文件, 代码如下：</p>\n<pre><code>var fs = require(&quot;fs&quot;);\nvar data = fs.readFileSync(&apos;input.txt&apos;);\nconsole.log(data.toString());\nconsole.log(&quot;程序执行结束!&quot;);</code></pre><p>以上代码执行结果如下：</p>\n<pre><code>$ node main.js\n菜鸟教程官网地址：www.runoob.com\n\n程序执行结束!</code></pre><h2 id=\"非阻塞代码实例\"><a href=\"#非阻塞代码实例\" class=\"headerlink\" title=\"非阻塞代码实例\"></a>非阻塞代码实例</h2><p>创建一个文件 input.txt ，内容如下：</p>\n<pre><code>菜鸟教程官网地址：www.runoob.com</code></pre><p>创建 main.js 文件, 代码如下：</p>\n<pre><code>fs.readFile(&apos;input.txt&apos;, function (err, data) {\n    if (err) return console.error(err);\n    console.log(data.toString());\n});\n\nconsole.log(&quot;程序执行结束!&quot;);</code></pre><p>以上代码执行结果如下：</p>\n<pre><code>$ node main.js\n程序执行结束!\n菜鸟教程官网地址：www.runoob.com</code></pre><p>以上两个实例我们了解了阻塞与非阻塞调用的不同。第一个实例在文件读取完后才执行完程序。 第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。</p>\n<p>因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。</p>\n<h1 id=\"Node-js-事件循环\"><a href=\"#Node-js-事件循环\" class=\"headerlink\" title=\"Node.js 事件循环\"></a>Node.js 事件循环</h1><ul>\n<li><p>Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。    </p>\n</li>\n<li><p>Node.js 几乎每一个 API 都是支持回调函数的。</p>\n</li>\n<li><p>Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。</p>\n</li>\n<li><p>Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.</p>\n</li>\n</ul>\n<h2 id=\"事件驱动程序\"><a href=\"#事件驱动程序\" class=\"headerlink\" title=\"事件驱动程序\"></a>事件驱动程序</h2><p>Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。</p>\n<p>当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。</p>\n<p>这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）</p>\n<p>在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。</p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2015/09/event_loop.jpg\" alt></p>\n<p>整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。</p>\n<p>Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：</p>\n<pre><code>// 引入 events 模块\nvar events = require(&apos;events&apos;);\n// 创建 eventEmitter 对象\nvar eventEmitter = new events.EventEmitter();</code></pre><p>以下程序绑定事件处理程序：</p>\n<pre><code>// 绑定事件及事件的处理程序\neventEmitter.on(&apos;eventName&apos;, eventHandler);</code></pre><p>我们可以通过程序触发事件：</p>\n<pre><code>// 触发事件\neventEmitter.emit(&apos;eventName&apos;);</code></pre><h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>创建 main.js 文件，代码如下所示：</p>\n<pre><code>// 引入 events 模块\nvar events = require(&apos;events&apos;);\n// 创建 eventEmitter 对象\nvar eventEmitter = new events.EventEmitter();\n\n// 创建事件处理程序\nvar connectHandler = function connected() {\n   console.log(&apos;连接成功。&apos;);\n\n   // 触发 data_received 事件 \n   eventEmitter.emit(&apos;data_received&apos;);\n} \n\n// 绑定 connection 事件处理程序\neventEmitter.on(&apos;connection&apos;, connectHandler);\n\n// 使用匿名函数绑定 data_received 事件\neventEmitter.on(&apos;data_received&apos;, function(){\n   console.log(&apos;数据接收成功。&apos;);\n});    \n\n// 触发 connection 事件 \neventEmitter.emit(&apos;connection&apos;);\n\nconsole.log(&quot;程序执行完毕。&quot;);</code></pre><p>接下来让我们执行以上代码：</p>\n<pre><code>$ node main.js\n连接成功。\n数据接收成功。\n程序执行完毕。</code></pre><h2 id=\"Node-应用程序是如何工作的？\"><a href=\"#Node-应用程序是如何工作的？\" class=\"headerlink\" title=\"Node 应用程序是如何工作的？\"></a>Node 应用程序是如何工作的？</h2><p>在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。</p>\n<p>接下来让我们来重新看下前面的实例，创建一个 input.txt ,文件内容如下：</p>\n<pre><code>菜鸟教程官网地址：www.runoob.com</code></pre><p>创建 main.js 文件，代码如下：</p>\n<pre><code>var fs = require(&quot;fs&quot;);\n\nfs.readFile(&apos;input.txt&apos;, function (err, data) {\n   if (err){\n      console.log(err.stack);\n      return;\n   }\n   console.log(data.toString());\n});\nconsole.log(&quot;程序执行完毕&quot;);</code></pre><p>以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。</p>\n<p>如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。</p>\n<p>执行以上代码，执行结果如下：</p>\n<pre><code>程序执行完毕\n菜鸟教程官网地址：www.runoob.com      </code></pre><p>接下来我们删除 input.txt 文件，执行结果如下所示：</p>\n<pre><code>程序执行完毕\nError: ENOENT, open &apos;input.txt&apos;</code></pre><p>因为文件 input.txt 不存在，所以输出了错误信息。</p>\n<h1 id=\"Node-js-EventEmitter\"><a href=\"#Node-js-EventEmitter\" class=\"headerlink\" title=\"Node.js EventEmitter\"></a>Node.js EventEmitter</h1><p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。</p>\n<p>Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p>\n<h2 id=\"EventEmitter-类\"><a href=\"#EventEmitter-类\" class=\"headerlink\" title=\"EventEmitter 类\"></a>EventEmitter 类</h2><p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。</p>\n<p>你可以通过require(“events”);来访问该模块。</p>\n<pre><code>// 引入 events 模块\nvar events = require(&apos;events&apos;);\n// 创建 eventEmitter 对象\nvar eventEmitter = new events.EventEmitter();</code></pre><p>EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。</p>\n<h3 id=\"下面我们用一个简单的例子说明-EventEmitter-的用法：\"><a href=\"#下面我们用一个简单的例子说明-EventEmitter-的用法：\" class=\"headerlink\" title=\"下面我们用一个简单的例子说明 EventEmitter 的用法：\"></a>下面我们用一个简单的例子说明 EventEmitter 的用法：</h3><pre><code>//event.js 文件\nvar EventEmitter = require(&apos;events&apos;).EventEmitter; \nvar event = new EventEmitter(); \nevent.on(&apos;some_event&apos;, function() { \n    console.log(&apos;some_event 事件触发&apos;); \n}); \nsetTimeout(function() { \n    event.emit(&apos;some_event&apos;); \n}, 1000); </code></pre><p>执行结果如下：</p>\n<p>运行这段代码，1 秒后控制台输出了 ‘some_event 事件触发’。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。</p>\n<pre><code>$ node event.js \nsome_event 事件触发          </code></pre><p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。</p>\n<p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p>\n<p>让我们以下面的例子解释这个过程：</p>\n<pre><code>//event.js 文件\nvar events = require(&apos;events&apos;); \nvar emitter = new events.EventEmitter(); \nemitter.on(&apos;someEvent&apos;, function(arg1, arg2) { \n    console.log(&apos;listener1&apos;, arg1, arg2); \n}); \nemitter.on(&apos;someEvent&apos;, function(arg1, arg2) { \n    console.log(&apos;listener2&apos;, arg1, arg2); \n}); \nemitter.emit(&apos;someEvent&apos;, &apos;arg1 参数&apos;, &apos;arg2 参数&apos;); </code></pre><p>执行以上代码，运行的结果如下：</p>\n<pre><code>$ node event.js \nlistener1 arg1 参数 arg2 参数\nlistener2 arg1 参数 arg2 参数    </code></pre><p>以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。</p>\n<p>运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。</p>\n<p>EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"1-addListener-event-listener\"><a href=\"#1-addListener-event-listener\" class=\"headerlink\" title=\"1. addListener(event, listener)\"></a>1. addListener(event, listener)</h3><p>为指定事件添加一个监听器到监听器数组的尾部。</p>\n<h3 id=\"2-on-event-listener\"><a href=\"#2-on-event-listener\" class=\"headerlink\" title=\"2. on(event, listener)\"></a>2. on(event, listener)</h3><p>为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。</p>\n<pre><code>server.on(&apos;connection&apos;, function (stream) {\n  console.log(&apos;someone connected!&apos;);\n});</code></pre><h3 id=\"3-once-event-listener\"><a href=\"#3-once-event-listener\" class=\"headerlink\" title=\"3. once(event, listener)\"></a>3. once(event, listener)</h3><p>为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。</p>\n<pre><code>server.once(&apos;connection&apos;, function (stream) {\n  console.log(&apos;Ah, we have our first user!&apos;);\n});</code></pre><h3 id=\"4-removeListener-event-listener\"><a href=\"#4-removeListener-event-listener\" class=\"headerlink\" title=\"4. removeListener(event, listener)\"></a>4. removeListener(event, listener)</h3><p>移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。</p>\n<p>它接受两个参数，第一个是事件名称，第二个是回调函数名称。</p>\n<pre><code>var callback = function(stream) {\n  console.log(&apos;someone connected!&apos;);\n};\nserver.on(&apos;connection&apos;, callback);\n// ...\nserver.removeListener(&apos;connection&apos;, callback);</code></pre><h3 id=\"5-removeAllListeners-event\"><a href=\"#5-removeAllListeners-event\" class=\"headerlink\" title=\"5. removeAllListeners([event])\"></a>5. removeAllListeners([event])</h3><p>移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。</p>\n<h3 id=\"6-setMaxListeners-n\"><a href=\"#6-setMaxListeners-n\" class=\"headerlink\" title=\"6. setMaxListeners(n)\"></a>6. setMaxListeners(n)</h3><p>默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。</p>\n<h3 id=\"7-listeners-event\"><a href=\"#7-listeners-event\" class=\"headerlink\" title=\"7. listeners(event)\"></a>7. listeners(event)</h3><p>返回指定事件的监听器数组。</p>\n<h3 id=\"8-emit-event-arg1-arg2-…\"><a href=\"#8-emit-event-arg1-arg2-…\" class=\"headerlink\" title=\"8. emit(event, [arg1], [arg2], […])\"></a>8. emit(event, [arg1], [arg2], […])</h3><p>按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</p>\n<h2 id=\"类方法\"><a href=\"#类方法\" class=\"headerlink\" title=\"类方法\"></a>类方法</h2><h3 id=\"listenerCount-emitter-event\"><a href=\"#listenerCount-emitter-event\" class=\"headerlink\" title=\"listenerCount(emitter, event)\"></a>listenerCount(emitter, event)</h3><p>返回指定事件的监听器数量。</p>\n<pre><code>events.EventEmitter.listenerCount(emitter, eventName) //已废弃，不推荐\nevents.emitter.listenerCount(eventName) //推荐</code></pre><h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><h3 id=\"newListener\"><a href=\"#newListener\" class=\"headerlink\" title=\"newListener\"></a>newListener</h3><ul>\n<li><p>event - 字符串，事件名称</p>\n</li>\n<li><p>listener - 处理事件函数</p>\n</li>\n</ul>\n<p>该事件在添加新监听器时被触发。</p>\n<h3 id=\"removeListener\"><a href=\"#removeListener\" class=\"headerlink\" title=\"removeListener\"></a>removeListener</h3><ul>\n<li><p>event - 字符串，事件名称</p>\n</li>\n<li><p>listener - 处理事件函数</p>\n</li>\n</ul>\n<p>从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。</p>\n<h2 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。</p>\n<p>创建 main.js 文件，代码如下：</p>\n<pre><code>var events = require(&apos;events&apos;);\nvar eventEmitter = new events.EventEmitter();\n\n// 监听器 #1\nvar listener1 = function listener1() {\n   console.log(&apos;监听器 listener1 执行。&apos;);\n}\n\n// 监听器 #2\nvar listener2 = function listener2() {\n  console.log(&apos;监听器 listener2 执行。&apos;);\n}\n\n// 绑定 connection 事件，处理函数为 listener1 \neventEmitter.addListener(&apos;connection&apos;, listener1);\n\n// 绑定 connection 事件，处理函数为 listener2\neventEmitter.on(&apos;connection&apos;, listener2);\n\nvar eventListeners = eventEmitter.listenerCount(&apos;connection&apos;);\nconsole.log(eventListeners + &quot; 个监听器监听连接事件。&quot;);\n\n// 处理 connection 事件 \neventEmitter.emit(&apos;connection&apos;);\n\n// 移除监绑定的 listener1 函数\neventEmitter.removeListener(&apos;connection&apos;, listener1);\nconsole.log(&quot;listener1 不再受监听。&quot;);\n\n// 触发连接事件\neventEmitter.emit(&apos;connection&apos;);\n\neventListeners = eventEmitter.listenerCount(&apos;connection&apos;);\nconsole.log(eventListeners + &quot; 个监听器监听连接事件。&quot;);\n\nconsole.log(&quot;程序执行完毕。&quot;);</code></pre><p>以上代码，执行结果如下所示：</p>\n<pre><code>$ node main.js  \n2 个监听器监听连接事件。\n监听器 listener1 执行。\n监听器 listener2 执行。\nlistener1 不再受监听。\n监听器 listener2 执行。\n1 个监听器监听连接事件。\n程序执行完毕。</code></pre><h2 id=\"error-事件\"><a href=\"#error-事件\" class=\"headerlink\" title=\"error 事件\"></a>error 事件</h2><p>EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。</p>\n<p>当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p>\n<p>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：</p>\n<pre><code>var events = require(&apos;events&apos;); \nvar emitter = new events.EventEmitter(); \nemitter.emit(&apos;error&apos;); </code></pre><p>运行时会显示以下错误：</p>\n<pre><code>node.js:201 \nthrow e; // process.nextTick error, or &apos;error&apos; event on first tick \n^ \nError: Uncaught, unspecified &apos;error&apos; event. \nat EventEmitter.emit (events.js:50:15) \nat Object.&lt;anonymous&gt; (/home/byvoid/error.js:5:9) \nat Module._compile (module.js:441:26) \nat Object..js (module.js:459:10) \nat Module.load (module.js:348:31) \nat Function._load (module.js:308:12) \nat Array.0 (module.js:479:10) \nat EventEmitter._tickCallback (node.js:192:40)    </code></pre><h2 id=\"继承-EventEmitter\"><a href=\"#继承-EventEmitter\" class=\"headerlink\" title=\"继承 EventEmitter\"></a>继承 EventEmitter</h2><p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p>\n<p>为什么要这样做呢？原因有两点：</p>\n<p>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。</p>\n<p>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p>\n<h1 id=\"Node-js-Buffer-缓冲区\"><a href=\"#Node-js-Buffer-缓冲区\" class=\"headerlink\" title=\"Node.js Buffer(缓冲区)\"></a>Node.js Buffer(缓冲区)</h1><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。</p>\n<p>但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。</p>\n<p>在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。</p>\n<blockquote>\n<blockquote>\n<p>在v6.0之前创建Buffer对象直接使用new Buffer()构造函数来创建对象实例，但是Buffer对内存的权限操作相比很大，可以直接捕获一些敏感信息，所以在v6.0以后，官方文档里面建议使用 Buffer.from() 接口去创建Buffer对象。    </p>\n</blockquote>\n</blockquote>\n<h2 id=\"Buffer-与字符编码\"><a href=\"#Buffer-与字符编码\" class=\"headerlink\" title=\"Buffer 与字符编码\"></a>Buffer 与字符编码</h2><p>Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。</p>\n<pre><code>const buf = Buffer.from(&apos;runoob&apos;, &apos;ascii&apos;);\n\n// 输出 72756e6f6f62\nconsole.log(buf.toString(&apos;hex&apos;));\n\n// 输出 cnVub29i\nconsole.log(buf.toString(&apos;base64&apos;));</code></pre><p>Node.js 目前支持的字符编码包括：</p>\n<ul>\n<li><p>ascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。</p>\n</li>\n<li><p>utf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。</p>\n</li>\n<li><p>utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。</p>\n</li>\n<li><p>ucs2 - utf16le 的别名。</p>\n</li>\n<li><p>base64 - Base64 编码。</p>\n</li>\n<li><p>latin1 - 一种把 Buffer 编码成一字节编码的字符串的方式。</p>\n</li>\n<li><p>binary - latin1 的别名。</p>\n</li>\n<li><p>hex - 将每个字节编码为两个十六进制字符。</p>\n</li>\n</ul>\n<h2 id=\"创建-Buffer-类\"><a href=\"#创建-Buffer-类\" class=\"headerlink\" title=\"创建 Buffer 类\"></a>创建 Buffer 类</h2><p>Buffer 提供了以下 API 来创建 Buffer 类：</p>\n<ul>\n<li><p>Buffer.alloc(size[, fill[, encoding]])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0</p>\n</li>\n<li><p>Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据</p>\n</li>\n<li><p>Buffer.allocUnsafeSlow(size)</p>\n</li>\n<li><p>Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）</p>\n</li>\n<li><p>Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。</p>\n</li>\n<li><p>Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例</p>\n</li>\n<li><p>Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例</p>\n<p>  / 创建一个长度为 10、且用 0 填充的 Buffer。<br>  const buf1 = Buffer.alloc(10);</p>\n<p>  // 创建一个长度为 10、且用 0x1 填充的 Buffer。<br>  const buf2 = Buffer.alloc(10, 1);</p>\n<p>  // 创建一个长度为 10、且未初始化的 Buffer。<br>  // 这个方法比调用 Buffer.alloc() 更快，<br>  // 但返回的 Buffer 实例可能包含旧数据，<br>  // 因此需要使用 fill() 或 write() 重写。<br>  const buf3 = Buffer.allocUnsafe(10);</p>\n<p>  // 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。<br>  const buf4 = Buffer.from([1, 2, 3]);</p>\n<p>  // 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。<br>  const buf5 = Buffer.from(‘tést’);</p>\n<p>  // 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。<br>  const buf6 = Buffer.from(‘tést’, ‘latin1’);</p>\n</li>\n</ul>\n<h2 id=\"写入缓冲区\"><a href=\"#写入缓冲区\" class=\"headerlink\" title=\"写入缓冲区\"></a>写入缓冲区</h2><h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre><code>buf.write(string[, offset[, length]][, encoding])</code></pre><h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>参数描述如下：</p>\n<ul>\n<li><p>string - 写入缓冲区的字符串。</p>\n</li>\n<li><p>offset - 缓冲区开始写入的索引值，默认为 0 。</p>\n</li>\n<li><p>length - 写入的字节数，默认为 buffer.length</p>\n</li>\n<li><p>encoding - 使用的编码。默认为 ‘utf8’ 。</p>\n</li>\n</ul>\n<p>根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。</p>\n<h3 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。</p>\n<h3 id=\"实例-2\"><a href=\"#实例-2\" class=\"headerlink\" title=\"实例\"></a>实例</h3><pre><code>buf = Buffer.alloc(256);\nlen = buf.write(&quot;www.runoob.com&quot;);\n\nconsole.log(&quot;写入字节数 : &quot;+  len);</code></pre><p>执行以上代码，输出结果为：</p>\n<pre><code>$node main.js\n写入字节数 : 14</code></pre><h2 id=\"从缓冲区读取数据\"><a href=\"#从缓冲区读取数据\" class=\"headerlink\" title=\"从缓冲区读取数据\"></a>从缓冲区读取数据</h2><h3 id=\"读取-Node-缓冲区数据的语法如下所示：\"><a href=\"#读取-Node-缓冲区数据的语法如下所示：\" class=\"headerlink\" title=\"读取 Node 缓冲区数据的语法如下所示：\"></a>读取 Node 缓冲区数据的语法如下所示：</h3><pre><code>buf.toString([encoding[, start[, end]]])</code></pre><h3 id=\"参数-1\"><a href=\"#参数-1\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>参数描述如下：</p>\n<ul>\n<li><p>encoding - 使用的编码。默认为 ‘utf8’ 。</p>\n</li>\n<li><p>start - 指定开始读取的索引位置，默认为 0。</p>\n</li>\n<li><p>end - 结束位置，默认为缓冲区的末尾。</p>\n</li>\n</ul>\n<h3 id=\"返回\"><a href=\"#返回\" class=\"headerlink\" title=\"返回\"></a>返回</h3><p>解码缓冲区数据并使用指定的编码返回字符串。</p>\n<h3 id=\"实例-3\"><a href=\"#实例-3\" class=\"headerlink\" title=\"实例\"></a>实例</h3><pre><code>buf = Buffer.alloc(26);\nfor (var i = 0 ; i &lt; 26 ; i++) {\n  buf[i] = i + 97;\n}\n\nconsole.log( buf.toString(&apos;ascii&apos;));       // 输出: abcdefghijklmnopqrstuvwxyz\nconsole.log( buf.toString(&apos;ascii&apos;,0,5));   // 输出: abcde\nconsole.log( buf.toString(&apos;utf8&apos;,0,5));    // 输出: abcde\nconsole.log( buf.toString(undefined,0,5)); // 使用 &apos;utf8&apos; 编码, 并输出: abcde</code></pre><p>执行以上代码，输出结果为：</p>\n<pre><code>$ node main.js\nabcdefghijklmnopqrstuvwxyz\nabcde\nabcde\nabcde</code></pre><h2 id=\"将-Buffer-转换为-JSON-对象\"><a href=\"#将-Buffer-转换为-JSON-对象\" class=\"headerlink\" title=\"将 Buffer 转换为 JSON 对象\"></a>将 Buffer 转换为 JSON 对象</h2><h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre><code>buf.toJSON()</code></pre><p>当字符串化一个 Buffer 实例时，JSON.stringify() 会隐式地调用该 toJSON()。</p>\n<h3 id=\"返回值-1\"><a href=\"#返回值-1\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>返回 JSON 对象。</p>\n<h3 id=\"实例-4\"><a href=\"#实例-4\" class=\"headerlink\" title=\"实例\"></a>实例</h3><pre><code>const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);\nconst json = JSON.stringify(buf);\n\n// 输出: {&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]}\nconsole.log(json);\n\nconst copy = JSON.parse(json, (key, value) =&gt; {\n  return value &amp;&amp; value.type === &apos;Buffer&apos; ?\n    Buffer.from(value.data) :\n    value;\n});\n\n// 输出: &lt;Buffer 01 02 03 04 05&gt;\nconsole.log(copy);</code></pre><p>执行以上代码，输出结果为：</p>\n<pre><code>{&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]}\n&lt;Buffer 01 02 03 04 05&gt;</code></pre><h2 id=\"缓冲区合并\"><a href=\"#缓冲区合并\" class=\"headerlink\" title=\"缓冲区合并\"></a>缓冲区合并</h2><h3 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre><code>Buffer.concat(list[, totalLength])</code></pre><h3 id=\"参数-2\"><a href=\"#参数-2\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>参数描述如下：</p>\n<ul>\n<li><p>list - 用于合并的 Buffer 对象数组列表。</p>\n</li>\n<li><p>totalLength - 指定合并后Buffer对象的总长度。</p>\n</li>\n</ul>\n<h3 id=\"返回值-2\"><a href=\"#返回值-2\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>返回一个多个成员合并的新 Buffer 对象。</p>\n<h3 id=\"实例-5\"><a href=\"#实例-5\" class=\"headerlink\" title=\"实例\"></a>实例</h3><pre><code>var buffer1 = Buffer.from((&apos;菜鸟教程&apos;));\nvar buffer2 = Buffer.from((&apos;www.runoob.com&apos;));\nvar buffer3 = Buffer.concat([buffer1,buffer2]);\nconsole.log(&quot;buffer3 内容: &quot; + buffer3.toString());</code></pre><p>执行以上代码，输出结果为：</p>\n<pre><code>buffer3 内容: 菜鸟教程www.runoob.com</code></pre><h2 id=\"缓冲区比较\"><a href=\"#缓冲区比较\" class=\"headerlink\" title=\"缓冲区比较\"></a>缓冲区比较</h2><h3 id=\"语法-3\"><a href=\"#语法-3\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>Node Buffer 比较的函数语法如下所示, 该方法在 Node.js v0.12.2 版本引入    </p>\n<pre><code>buf.compare(otherBuffer);</code></pre><h3 id=\"参数-3\"><a href=\"#参数-3\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>参数描述如下：</p>\n<ul>\n<li>otherBuffer - 与 buf 对象比较的另外一个 Buffer 对象。</li>\n</ul>\n<h3 id=\"返回值-3\"><a href=\"#返回值-3\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。</p>\n<h3 id=\"实例-6\"><a href=\"#实例-6\" class=\"headerlink\" title=\"实例\"></a>实例</h3><pre><code>var buffer1 = Buffer.from(&apos;ABC&apos;);\nvar buffer2 = Buffer.from(&apos;ABCD&apos;);\nvar result = buffer1.compare(buffer2);\n\nif(result &lt; 0) {\n   console.log(buffer1 + &quot; 在 &quot; + buffer2 + &quot;之前&quot;);\n}else if(result == 0){\n   console.log(buffer1 + &quot; 与 &quot; + buffer2 + &quot;相同&quot;);\n}else {\n   console.log(buffer1 + &quot; 在 &quot; + buffer2 + &quot;之后&quot;);\n}</code></pre><p>执行以上代码，输出结果为：</p>\n<pre><code>ABC在ABCD之前</code></pre><h2 id=\"拷贝缓冲区\"><a href=\"#拷贝缓冲区\" class=\"headerlink\" title=\"拷贝缓冲区\"></a>拷贝缓冲区</h2><h3 id=\"语法-4\"><a href=\"#语法-4\" class=\"headerlink\" title=\"语法\"></a>语法</h3><pre><code>buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</code></pre><ul>\n<li><p>targetBuffer - 要拷贝的 Buffer 对象。</p>\n</li>\n<li><p>targetStart - 数字, 可选, 默认: 0</p>\n</li>\n<li><p>sourceStart - 数字, 可选, 默认: 0</p>\n</li>\n<li><p>sourceEnd - 数字, 可选, 默认: buffer.length</p>\n</li>\n</ul>\n<h3 id=\"返回值-4\"><a href=\"#返回值-4\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>没有返回值。</p>\n<h3 id=\"实例-7\"><a href=\"#实例-7\" class=\"headerlink\" title=\"实例\"></a>实例</h3><pre><code>var buf1 = Buffer.from(&apos;abcdefghijkl&apos;);\nvar buf2 = Buffer.from(&apos;RUNOOB&apos;);\n\n//将 buf2 插入到 buf1 指定位置上\nbuf2.copy(buf1, 2);\n\nconsole.log(buf1.toString());</code></pre><p>执行以上代码，输出结果为：</p>\n<pre><code>abRUNOOBijkl</code></pre><h2 id=\"缓冲区裁剪\"><a href=\"#缓冲区裁剪\" class=\"headerlink\" title=\"缓冲区裁剪\"></a>缓冲区裁剪</h2><p>Node 缓冲区裁剪语法如下所示：</p>\n<pre><code>buf.slice([start[, end]])</code></pre><p>参数<br>参数描述如下：</p>\n<ul>\n<li><p>start - 数字, 可选, 默认: 0</p>\n</li>\n<li><p>end - 数字, 可选, 默认: buffer.length</p>\n</li>\n</ul>\n<p>返回值<br>返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。</p>\n<p>实例</p>\n<pre><code>var buffer1 = Buffer.from(&apos;runoob&apos;);\n// 剪切缓冲区\nvar buffer2 = buffer1.slice(0,2);\nconsole.log(&quot;buffer2 content: &quot; + buffer2.toString());\n执行</code></pre><p>执行以上代码，输出结果为：</p>\n<pre><code>buffer2 content: ru</code></pre><h2 id=\"缓冲区长度\"><a href=\"#缓冲区长度\" class=\"headerlink\" title=\"缓冲区长度\"></a>缓冲区长度</h2><pre><code>buf.length;</code></pre><p>返回值<br>返回 Buffer 对象所占据的内存长度。</p>\n<p>实例</p>\n<pre><code>var buffer = Buffer.from(&apos;www.runoob.com&apos;);\n//  缓冲区长度\nconsole.log(&quot;buffer length: &quot; + buffer.length);</code></pre><p>执行以上代码，输出结果为：</p>\n<pre><code>buffer length: 14</code></pre><h1 id=\"Node-js-Stream-流\"><a href=\"#Node-js-Stream-流\" class=\"headerlink\" title=\"Node.js Stream(流)\"></a>Node.js Stream(流)</h1><p>Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。</p>\n<p>Node.js，Stream 有四种流类型：</p>\n<ul>\n<li><p>Readable - 可读操作。</p>\n</li>\n<li><p>Writable - 可写操作。</p>\n</li>\n<li><p>Duplex - 可读可写操作.</p>\n</li>\n<li><p>Transform - 操作被写入数据，然后读出结果。</p>\n</li>\n</ul>\n<p>所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：</p>\n<ul>\n<li><p>data - 当有数据可读时触发。</p>\n</li>\n<li><p>end - 没有更多的数据可读时触发。</p>\n</li>\n<li><p>error - 在接收和写入过程中发生错误时触发。</p>\n</li>\n<li><p>finish - 所有数据已被写入到底层系统时触发。</p>\n</li>\n</ul>\n<h2 id=\"从流中读取数据\"><a href=\"#从流中读取数据\" class=\"headerlink\" title=\"从流中读取数据\"></a>从流中读取数据</h2><p>创建 input.txt 文件，内容如下：</p>\n<pre><code>菜鸟教程官网地址：www.runoob.com\n\nvar fs = require(&quot;fs&quot;);\nvar data = &apos;&apos;;\n\n// 创建可读流\nvar readerStream = fs.createReadStream(&apos;input.txt&apos;);\n\n// 设置编码为 utf8。\nreaderStream.setEncoding(&apos;UTF8&apos;);\n\n// 处理流事件 --&gt; data, end, and error\nreaderStream.on(&apos;data&apos;, function(chunk) {\n   data += chunk;\n});\n\nreaderStream.on(&apos;end&apos;,function(){\n   console.log(data);\n});\n\nreaderStream.on(&apos;error&apos;, function(err){\n   console.log(err.stack);\n});\n\nconsole.log(&quot;程序执行完毕&quot;);</code></pre><p>以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下：</p>\n<pre><code>$ node main.js \n程序执行完毕\n写入完成。</code></pre><p>查看 output.txt 文件的内容：</p>\n<pre><code>$ cat output.txt \n菜鸟教程官网地址：www.runoob.com</code></pre><h2 id=\"管道流\"><a href=\"#管道流\" class=\"headerlink\" title=\"管道流\"></a>管道流</h2><p>管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。    </p>\n<p>设置 input.txt 文件内容如下：</p>\n<pre><code>菜鸟教程官网地址：www.runoob.com\n管道流操作实例</code></pre><p>创建 main.js 文件, 代码如下：</p>\n<pre><code>var fs = require(&quot;fs&quot;);\n\n// 创建一个可读流\nvar readerStream = fs.createReadStream(&apos;input.txt&apos;);\n\n// 创建一个可写流\nvar writerStream = fs.createWriteStream(&apos;output.txt&apos;);\n\n// 管道读写操作\n// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中\nreaderStream.pipe(writerStream);\n\nconsole.log(&quot;程序执行完毕&quot;);</code></pre><p>代码执行结果如下：</p>\n<pre><code>$ node main.js \n程序执行完毕</code></pre><p>查看 output.txt 文件的内容：</p>\n<pre><code>$ cat output.txt \n菜鸟教程官网地址：www.runoob.com\n管道流操作实例</code></pre><h2 id=\"链式流\"><a href=\"#链式流\" class=\"headerlink\" title=\"链式流\"></a>链式流</h2><p>链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。</p>\n<p>接下来我们就是用管道和链式来压缩和解压文件。</p>\n<p>创建 compress.js 文件, 代码如下：</p>\n<pre><code>var fs = require(&quot;fs&quot;);\nvar zlib = require(&apos;zlib&apos;);\n\n// 压缩 input.txt 文件为 input.txt.gz\nfs.createReadStream(&apos;input.txt&apos;)\n  .pipe(zlib.createGzip())\n  .pipe(fs.createWriteStream(&apos;input.txt.gz&apos;));\n\nconsole.log(&quot;文件压缩完成。&quot;);</code></pre><p>代码执行结果如下：</p>\n<pre><code>$ node compress.js \n文件压缩完成。</code></pre><p>执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。</p>\n<p>接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下：</p>\n<pre><code>var fs = require(&quot;fs&quot;);\nvar zlib = require(&apos;zlib&apos;);\n\n// 解压 input.txt.gz 文件为 input.txt\nfs.createReadStream(&apos;input.txt.gz&apos;)\n  .pipe(zlib.createGunzip())\n  .pipe(fs.createWriteStream(&apos;input.txt&apos;));\n\nconsole.log(&quot;文件解压完成。&quot;);</code></pre><p>代码执行结果如下：</p>\n<pre><code>$ node decompress.js \n文件解压完成。</code></pre><h1 id=\"Node-js模块系统\"><a href=\"#Node-js模块系统\" class=\"headerlink\" title=\"Node.js模块系统\"></a>Node.js模块系统</h1><p>为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。</p>\n<p>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。</p>\n<h2 id=\"创建模块-1\"><a href=\"#创建模块-1\" class=\"headerlink\" title=\"创建模块\"></a>创建模块</h2><p>在 Node.js 中，创建一个模块非常简单，如下我们创建一个 main.js 文件，代码如下:</p>\n<pre><code>var hello = require(&apos;./hello&apos;);\nhello.world();</code></pre><p>以上实例中，代码 require(‘./hello’) 引入了当前目录下的 hello.js 文件（./ 为当前目录，node.js 默认后缀为 js）。</p>\n<p>Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。</p>\n<p>接下来我们就来创建 hello.js 文件，代码如下：</p>\n<pre><code>exports.world = function() {\n  console.log(&apos;Hello World&apos;);\n}</code></pre><p>在以上示例中，hello.js 通过 exports 对象把 world 作为模块的访问接口，在 main.js 中通过 require(‘./hello’) 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。</p>\n<p>有时候我们只是想把一个对象封装到模块中，格式如下：</p>\n<pre><code>module.exports = function() {\n  // ...\n}</code></pre><p>例如:</p>\n<pre><code>//hello.js \nfunction Hello() { \n    var name; \n    this.setName = function(thyName) { \n        name = thyName; \n    }; \n    this.sayHello = function() { \n        console.log(&apos;Hello &apos; + name); \n    }; \n}; \nmodule.exports = Hello;</code></pre><p>这样就可以直接获得这个对象了：</p>\n<pre><code>//main.js \nvar Hello = require(&apos;./hello&apos;); \nhello = new Hello(); \nhello.setName(&apos;BYVoid&apos;); \nhello.sayHello(); </code></pre><p>模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。    </p>\n<h2 id=\"服务端的模块放在哪里\"><a href=\"#服务端的模块放在哪里\" class=\"headerlink\" title=\"服务端的模块放在哪里\"></a>服务端的模块放在哪里</h2><p>也许你已经注意到，我们已经在代码中使用了模块了。像这样：</p>\n<pre><code>var http = require(&quot;http&quot;);\n\n...\n\nhttp.createServer(...);</code></pre><p>Node.js 中自带了一个叫做 http 的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。</p>\n<p>这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。</p>\n<p>Node.js 的 require 方法中的文件查找策略如下：</p>\n<p>由于 Node.js 中存在 4 类模块（原生模块和3种文件模块），尽管 require 方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。如下图所示：    </p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2014/03/nodejs-require.jpg\" alt></p>\n<h2 id=\"从文件模块缓存中加载\"><a href=\"#从文件模块缓存中加载\" class=\"headerlink\" title=\"从文件模块缓存中加载\"></a>从文件模块缓存中加载</h2><p>尽管原生模块与文件模块的优先级不同，但是都会优先从文件模块的缓存中加载已经存在的模块。</p>\n<h2 id=\"从原生模块加载\"><a href=\"#从原生模块加载\" class=\"headerlink\" title=\"从原生模块加载\"></a>从原生模块加载</h2><p>原生模块的优先级仅次于文件模块缓存的优先级。require 方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个 http/http.js/http.node/http.json 文件，require(“http”) 都不会从这些文件中加载，而是从原生模块中加载。</p>\n<p>原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。</p>\n<h2 id=\"从文件加载\"><a href=\"#从文件加载\" class=\"headerlink\" title=\"从文件加载\"></a>从文件加载</h2><p>当文件模块缓存中不存在，而且不是原生模块的时候，Node.js 会解析 require 方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。</p>\n<p>require方法接受以下几种参数的传递：    </p>\n<ul>\n<li><p>http、fs、path等，原生模块。</p>\n</li>\n<li><p>./mod或../mod，相对路径的文件模块。</p>\n</li>\n<li><p>/pathtomodule/mod，绝对路径的文件模块。</p>\n</li>\n<li><p>mod，非原生模块的文件模块。</p>\n</li>\n</ul>\n<p>在路径 Y 下执行 require(X) 语句执行顺序：</p>\n<pre><code>1. 如果 X 是内置模块\n   a. 返回内置模块\n   b. 停止执行\n2. 如果 X 以 &apos;/&apos; 开头\n   a. 设置 Y 为文件根路径\n3. 如果 X 以 &apos;./&apos; 或 &apos;/&apos; or &apos;../&apos; 开头\n   a. LOAD_AS_FILE(Y + X)\n   b. LOAD_AS_DIRECTORY(Y + X)\n4. LOAD_NODE_MODULES(X, dirname(Y))\n5. 抛出异常 &quot;not found&quot;\n\nLOAD_AS_FILE(X)\n1. 如果 X 是一个文件, 将 X 作为 JavaScript 文本载入并停止执行。\n2. 如果 X.js 是一个文件, 将 X.js 作为 JavaScript 文本载入并停止执行。\n3. 如果 X.json 是一个文件, 解析 X.json 为 JavaScript 对象并停止执行。\n4. 如果 X.node 是一个文件, 将 X.node 作为二进制插件载入并停止执行。\n\nLOAD_INDEX(X)\n1. 如果 X/index.js 是一个文件,  将 X/index.js 作为 JavaScript 文本载入并停止执行。\n2. 如果 X/index.json 是一个文件, 解析 X/index.json 为 JavaScript 对象并停止执行。\n3. 如果 X/index.node 是一个文件,  将 X/index.node 作为二进制插件载入并停止执行。\n\nLOAD_AS_DIRECTORY(X)\n1. 如果 X/package.json 是一个文件,\n   a. 解析 X/package.json, 并查找 &quot;main&quot; 字段。\n   b. let M = X + (json main 字段)\n   c. LOAD_AS_FILE(M)\n   d. LOAD_INDEX(M)\n2. LOAD_INDEX(X)\n\nLOAD_NODE_MODULES(X, START)\n1. let DIRS=NODE_MODULES_PATHS(START)\n2. for each DIR in DIRS:\n   a. LOAD_AS_FILE(DIR/X)\n   b. LOAD_AS_DIRECTORY(DIR/X)\n\nNODE_MODULES_PATHS(START)\n1. let PARTS = path split(START)\n2. let I = count of PARTS - 1\n3. let DIRS = []\n4. while I &gt;= 0,\n   a. if PARTS[I] = &quot;node_modules&quot; CONTINUE\n   b. DIR = path join(PARTS[0 .. I] + &quot;node_modules&quot;)\n   c. DIRS = DIRS + DIR\n   d. let I = I - 1\n5. return DIRS</code></pre><p>exports 和 module.exports 的使用</p>\n<p>如果要对外暴露属性或方法，就用 exports 就行，要暴露对象(类似class，包含了很多属性和方法)，就用 module.exports。    </p>\n<h1 id=\"Node-js-函数\"><a href=\"#Node-js-函数\" class=\"headerlink\" title=\"Node.js 函数\"></a>Node.js 函数</h1><p>在JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。</p>\n<p>Node.js中函数的使用与Javascript类似，举例来说，你可以这样做：</p>\n<pre><code>function say(word) {\n  console.log(word);\n}\n\nfunction execute(someFunction, value) {\n  someFunction(value);\n}\n\nexecute(say, &quot;Hello&quot;);</code></pre><p>以上代码中，我们把 say 函数作为execute函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！</p>\n<p>这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。</p>\n<p>当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。</p>\n<h2 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h2><p>我们可以把一个函数作为变量传递。但是我们不一定要绕这个”先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：</p>\n<pre><code>function execute(someFunction, value) {\n  someFunction(value);\n}</code></pre><p>我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。</p>\n<p>用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做匿名函数 。</p>\n<h2 id=\"函数传递是如何让HTTP服务器工作的\"><a href=\"#函数传递是如何让HTTP服务器工作的\" class=\"headerlink\" title=\"函数传递是如何让HTTP服务器工作的\"></a>函数传递是如何让HTTP服务器工作的</h2><p>带着这些知识，我们再来看看我们简约而不简单的HTTP服务器：</p>\n<pre><code>var http = require(&quot;http&quot;);\n\nhttp.createServer(function(request, response) {\n  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});\n  response.write(&quot;Hello World&quot;);\n  response.end();\n}).listen(8888);</code></pre><p>现在它看上去应该清晰了很多：我们向 createServer 函数传递了一个匿名函数。</p>\n<p>用这样的代码也可以达到同样的目的：</p>\n<pre><code>var http = require(&quot;http&quot;);\n\nfunction onRequest(request, response) {\n  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});\n  response.write(&quot;Hello World&quot;);\n  response.end();\n}\n\nhttp.createServer(onRequest).listen(8888);</code></pre><h1 id=\"Node-js-路由\"><a href=\"#Node-js-路由\" class=\"headerlink\" title=\"Node.js 路由\"></a>Node.js 路由</h1><p>我们要为路由提供请求的 URL 和其他需要的 GET 及 POST 参数，随后路由需要根据这些数据来执行相应的代码。</p>\n<p>因此，我们需要查看 HTTP 请求，从中提取出请求的 URL 以及 GET/POST 参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。</p>\n<p>我们需要的所有数据都会包含在 request 对象中，该对象作为 onRequest() 回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的 Node.JS 模块，它们分别是 url 和 querystring 模块。</p>\n<pre><code>url.parse(string).query\n                                           |\n           url.parse(string).pathname      |\n                       |                   |\n                       |                   |\n                     ------ -------------------\nhttp://localhost:8888/start?foo=bar&amp;hello=world\n                                ---       -----\n                                 |          |\n                                 |          |\n              querystring.parse(queryString)[&quot;foo&quot;]    |\n                                            |\n                         querystring.parse(queryString)[&quot;hello&quot;]</code></pre><p>当然我们也可以用 querystring 模块来解析 POST 请求体中的参数，稍后会有演示。</p>\n<p>现在我们来给 onRequest() 函数加上一些逻辑，用来找出浏览器请求的 URL 路径：</p>\n<p><strong>server.js 文件代码：</strong></p>\n<pre><code>var http = require(&quot;http&quot;);\nvar url = require(&quot;url&quot;);\n\nfunction start() {\n  function onRequest(request, response) {\n    var pathname = url.parse(request.url).pathname;\n    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);\n    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});\n    response.write(&quot;Hello World&quot;);\n    response.end();\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(&quot;Server has started.&quot;);\n}\n\nexports.start = start;</code></pre><p>好了，我们的应用现在可以通过请求的 URL 路径来区别不同请求了–这使我们得以使用路由（还未完成）来将请求以 URL 路径为基准映射到处理程序上。</p>\n<p>在我们所要构建的应用中，这意味着来自 /start 和 /upload 的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。</p>\n<p>现在我们可以来编写路由了，建立一个名为 router.js 的文件，添加以下内容：<br><strong>router.js</strong></p>\n<pre><code>function route(pathname) {\n  console.log(&quot;About to route a request for &quot; + pathname);\n}\n\nexports.route = route;</code></pre><p>如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。</p>\n<p>我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块。</p>\n<p>首先，我们来扩展一下服务器的 start() 函数，以便将路由函数作为参数传递过去，server.js 文件代码如下</p>\n<pre><code>var http = require(&quot;http&quot;);\nvar url = require(&quot;url&quot;);\n\nfunction start(route) {\n  function onRequest(request, response) {\n    var pathname = url.parse(request.url).pathname;\n    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);\n\n    route(pathname);\n\n    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});\n    response.write(&quot;Hello World&quot;);\n    response.end();\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(&quot;Server has started.&quot;);\n}\n\nexports.start = start;</code></pre><p>同时，我们会相应扩展 index.js，使得路由函数可以被注入到服务器中：</p>\n<p><strong>index.js 文件代码：</strong></p>\n<pre><code>var server = require(&quot;./server&quot;);\nvar router = require(&quot;./router&quot;);\n\nserver.start(router.route);</code></pre><p>在这里，我们传递的函数依旧什么也没做。</p>\n<p>如果现在启动应用（node index.js，始终记得这个命令行），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：</p>\n<pre><code>$ node index.js\nServer has started.        \n\n以上输出已经去掉了比较烦人的 /favicon.ico 请求相关的部分。\n\n浏览器访问 http://127.0.0.1:8888/，输出结果如下：</code></pre><h1 id=\"Node-js-全局对象\"><a href=\"#Node-js-全局对象\" class=\"headerlink\" title=\"Node.js 全局对象\"></a>Node.js 全局对象</h1><p>avaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。</p>\n<p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p>\n<p>在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</p>\n<h2 id=\"全局对象与全局变量\"><a href=\"#全局对象与全局变量\" class=\"headerlink\" title=\"全局对象与全局变量\"></a>全局对象与全局变量</h2><p>global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量：</p>\n<ul>\n<li><p>在最外层定义的变量；</p>\n</li>\n<li><p>全局对象的属性；</p>\n</li>\n<li><p>隐式定义的变量（未定义直接赋值的变量）。</p>\n</li>\n</ul>\n<p>你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注 意的是，在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。</p>\n<p>注意： 最好不要使用 var 定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险。</p>\n<h2 id=\"filename\"><a href=\"#filename\" class=\"headerlink\" title=\"__filename\"></a>__filename</h2><p>_filename 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。</p>\n<p><strong>实例</strong><br>创建文件 main.js ，代码如下所示：</p>\n<pre><code>// 输出全局变量 __filename 的值\nconsole.log( __filename );</code></pre><p>执行 main.js 文件，代码如下所示:</p>\n<pre><code>$ node main.js\n/web/com/runoob/nodejs/main.js</code></pre><h2 id=\"dirname\"><a href=\"#dirname\" class=\"headerlink\" title=\"__dirname\"></a>__dirname</h2><p>__dirname 表示当前执行脚本所在的目录。</p>\n<p><strong>实例</strong>    </p>\n<p>创建文件 main.js ，代码如下所示：</p>\n<pre><code>// 输出全局变量 __dirname 的值\nconsole.log( __dirname );</code></pre><p>执行 main.js 文件，代码如下所示:</p>\n<pre><code>$ node main.js\n/web/com/runoob/nodejs</code></pre><h2 id=\"setTimeout-cb-ms\"><a href=\"#setTimeout-cb-ms\" class=\"headerlink\" title=\"setTimeout(cb, ms)\"></a>setTimeout(cb, ms)</h2><p>setTimeout(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout() 只执行一次指定函数。</p>\n<p>返回一个代表定时器的句柄值。</p>\n<p><strong>实例</strong>    </p>\n<p>创建文件 main.js ，代码如下所示：</p>\n<pre><code>function printHello(){\n   console.log( &quot;Hello, World!&quot;);\n}\n// 两秒后执行以上函数\nsetTimeout(printHello, 2000);</code></pre><p>执行 main.js 文件，代码如下所示:</p>\n<pre><code>$ node main.js\nHello, World!    </code></pre><h2 id=\"clearTimeout-t\"><a href=\"#clearTimeout-t\" class=\"headerlink\" title=\"clearTimeout(t)\"></a>clearTimeout(t)</h2><p>clearTimeout( t ) 全局函数用于停止一个之前通过 setTimeout() 创建的定时器。 参数 t 是通过 setTimeout() 函数创建的定时器。    </p>\n<p>实例<br>创建文件 main.js ，代码如下所示：</p>\n<pre><code>function printHello(){\n   console.log( &quot;Hello, World!&quot;);\n}\n// 两秒后执行以上函数\nvar t = setTimeout(printHello, 2000);\n\n// 清除定时器\nclearTimeout(t);</code></pre><p>执行 main.js 文件，代码如下所示:</p>\n<pre><code>$ node main.js    </code></pre><h2 id=\"setInterval-cb-ms\"><a href=\"#setInterval-cb-ms\" class=\"headerlink\" title=\"setInterval(cb, ms)\"></a>setInterval(cb, ms)</h2><p>setInterval(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。</p>\n<p>返回一个代表定时器的句柄值。可以使用 clearInterval(t) 函数来清除定时器。</p>\n<p>setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。</p>\n<p>实例<br>创建文件 main.js ，代码如下所示：</p>\n<pre><code>function printHello(){\n   console.log( &quot;Hello, World!&quot;);\n}\n// 两秒后执行以上函数\nsetInterval(printHello, 2000);</code></pre><p>执行 main.js 文件，代码如下所示:</p>\n<pre><code>$ node main.js\nHello, World!\nHello, World!\nHello, World!\nHello, World!\nHello, World!\nHello, World!\nHello, World!</code></pre><p>以上程序每隔两秒就会输出一次”Hello, World!”，且会永久执行下去，直到你按下 ctrl + c 按钮。</p>\n<h2 id=\"console\"><a href=\"#console\" class=\"headerlink\" title=\"console\"></a>console</h2><p>console 用于提供控制台标准输出，它是由 Internet Explorer 的 JScript 引擎提供的调试工具，后来逐渐成为浏览器的实施标准。</p>\n<p>Node.js 沿用了这个标准，提供与习惯行为一致的 console 对象，用于向标准输出流（stdout）或标准错误流（stderr）输出字符。</p>\n<h3 id=\"console-log-data-…\"><a href=\"#console-log-data-…\" class=\"headerlink\" title=\"console.log([data][, …])\"></a>console.log([data][, …])</h3><p>向标准输出流打印字符并以换行符结束。该方法接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。</p>\n<h3 id=\"console-info-data-…\"><a href=\"#console-info-data-…\" class=\"headerlink\" title=\"console.info([data][, …])\"></a>console.info([data][, …])</h3><p>该命令的作用是返回信息性消息，这个命令与console.log差别并不大，除了在chrome中只会输出文字外，其余的会显示一个蓝色的惊叹号。</p>\n<h3 id=\"console-error-data-…\"><a href=\"#console-error-data-…\" class=\"headerlink\" title=\"console.error([data][, …])\"></a>console.error([data][, …])</h3><p>输出错误消息的。控制台在出现错误时会显示是红色的叉子。</p>\n<h3 id=\"console-warn-data-…\"><a href=\"#console-warn-data-…\" class=\"headerlink\" title=\"console.warn([data][, …])\"></a>console.warn([data][, …])</h3><p>输出警告消息。控制台出现有黄色的惊叹号。</p>\n<h3 id=\"console-dir-obj-options\"><a href=\"#console-dir-obj-options\" class=\"headerlink\" title=\"console.dir(obj[, options])\"></a>console.dir(obj[, options])</h3><p>用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</p>\n<h3 id=\"console-time-label\"><a href=\"#console-time-label\" class=\"headerlink\" title=\"console.time(label)\"></a>console.time(label)</h3><p>输出时间，表示计时开始。</p>\n<h3 id=\"console-timeEnd-label\"><a href=\"#console-timeEnd-label\" class=\"headerlink\" title=\"console.timeEnd(label)\"></a>console.timeEnd(label)</h3><p>结束时间，表示计时结束。</p>\n<h3 id=\"console-trace-message-…\"><a href=\"#console-trace-message-…\" class=\"headerlink\" title=\"console.trace(message[, …])\"></a>console.trace(message[, …])</h3><p>当前执行的代码在堆栈中的调用路径，这个测试函数运行很有帮助，只要给想测试的函数里面加入 console.trace 就行了。</p>\n<h3 id=\"console-assert-value-message-…\"><a href=\"#console-assert-value-message-…\" class=\"headerlink\" title=\"console.assert(value[, message][, …])\"></a>console.assert(value[, message][, …])</h3><p>用于判断某个表达式或变量是否为真，接收两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。</p>\n<p>console.log()：向标准输出流打印字符并以换行符结束。<br>console.log 接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。</p>\n<p>第一个参数是一个字符串，如果没有 参数，只打印一个换行。</p>\n<pre><code>console.log(&apos;Hello world&apos;); \nconsole.log(&apos;byvoid%diovyb&apos;); \nconsole.log(&apos;byvoid%diovyb&apos;, 1991); \n运行结果为：\n\nHello world \nbyvoid%diovyb \nbyvoid1991iovyb \n\nconsole.error()：与console.log() 用法相同，只是向标准错误流输出。\nconsole.trace()：向标准错误流输出当前的调用栈。\n\nconsole.trace();\n\n运行结果为：\n\nTrace: \nat Object.&lt;anonymous&gt; (/home/byvoid/consoletrace.js:1:71) \nat Module._compile (module.js:441:26) \nat Object..js (module.js:459:10) \nat Module.load (module.js:348:31) \nat Function._load (module.js:308:12) \nat Array.0 (module.js:479:10) \nat EventEmitter._tickCallback (node.js:192:40)\n\nconsole.info(&quot;程序开始执行：&quot;);\n\nvar counter = 10;\nconsole.log(&quot;计数: %d&quot;, counter);\n\nconsole.time(&quot;获取数据&quot;);\n//\n// 执行一些代码\n// \nconsole.timeEnd(&apos;获取数据&apos;);\n\nconsole.info(&quot;程序执行完毕。&quot;)\n\n程序开始执行：\n计数: 10\n获取数据: 0ms\n程序执行完毕</code></pre><h2 id=\"process\"><a href=\"#process\" class=\"headerlink\" title=\"process\"></a>process</h2><p>process 是一个全局变量，即 global 对象的属性。</p>\n<p>它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要 和它打交道。下面将会介绍 process 对象的一些最常用的成员方法。</p>\n<h3 id=\"exit\"><a href=\"#exit\" class=\"headerlink\" title=\"exit\"></a>exit</h3><p>当进程准备退出时触发。</p>\n<h3 id=\"beforeExit\"><a href=\"#beforeExit\" class=\"headerlink\" title=\"beforeExit\"></a>beforeExit</h3><p>当 node 清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时 node 退出，但是 ‘beforeExit’ 的监听器可以异步调用，这样 node 就会继续执行。</p>\n<h3 id=\"uncaughtException\"><a href=\"#uncaughtException\" class=\"headerlink\" title=\"uncaughtException\"></a>uncaughtException</h3><p>当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。</p>\n<h3 id=\"Signal-事件\"><a href=\"#Signal-事件\" class=\"headerlink\" title=\"Signal 事件\"></a>Signal 事件</h3><p>当进程接收到信号时就触发。信号列表详见标准的 POSIX 信号名，如 SIGINT、SIGUSR1 等。</p>\n<h3 id=\"实例-8\"><a href=\"#实例-8\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>创建文件 main.js ，代码如下所示：</p>\n<pre><code>process.on(&apos;exit&apos;, function(code) {\n\n  // 以下代码永远不会执行\n  setTimeout(function() {\n    console.log(&quot;该代码不会执行&quot;);\n  }, 0);\n\n  console.log(&apos;退出码为:&apos;, code);\n});\nconsole.log(&quot;程序执行结束&quot;);</code></pre><p>执行 main.js 文件，代码如下所示:</p>\n<pre><code>$ node main.js\n程序执行结束\n退出码为: 0</code></pre><h3 id=\"退出状态码\"><a href=\"#退出状态码\" class=\"headerlink\" title=\"退出状态码\"></a>退出状态码</h3><table>\n<thead>\n<tr>\n<th align=\"left\">状态码</th>\n<th align=\"left\">名称&amp;描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">Uncaught Fatal Exception <br> 有未捕获异常，并且没有被域或 uncaughtException 处理函数处理。</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">Unused <br> 保留</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">Internal JavaScript Parse Error  <br> JavaScript的源码启动 Node 进程时引起解析错误。非常罕见，仅会在开发 Node 时才会有。</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">Internal JavaScript Evaluation Failure  <br> JavaScript 的源码启动 Node 进程，评估时返回函数失败。非常罕见，仅会在开发 Node 时才会有。</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">Fatal Error  <br> V8 里致命的不可恢复的错误。通常会打印到 stderr ，内容为： FATAL ERROR</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">Non-function Internal Exception Handler  <br> 未捕获异常，内部异常处理函数不知为何设置为on-function，并且不能被调用。</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">Internal Exception Handler Run-Time Failure  <br> 未捕获的异常， 并且异常处理函数处理时自己抛出了异常。例如，如果 process.on(‘uncaughtException’) 或 domain.on(‘error’) 抛出了异常。</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">Unused  <br> 保留</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">Invalid Argument  <br> 可能是给了未知的参数，或者给的参数没有值。</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">Internal JavaScript Run-Time Failure  <br> JavaScript的源码启动 Node 进程时抛出错误，非常罕见，仅会在开发 Node 时才会有。</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">Invalid Debug Argument   <br> 设置了参数–debug 和/或 –debug-brk，但是选择了错误端口。</td>\n</tr>\n<tr>\n<td align=\"left\">128</td>\n<td align=\"left\">Signal Exits  <br> 如果 Node 接收到致命信号，比如SIGKILL 或 SIGHUP，那么退出代码就是128 加信号代码。这是标准的 Unix 做法，退出信号代码放在高位。</td>\n</tr>\n</tbody></table>\n<h3 id=\"Process-属性\"><a href=\"#Process-属性\" class=\"headerlink\" title=\"Process 属性\"></a>Process 属性</h3><p>Process 提供了很多有用的属性，便于我们更好的控制系统的交互：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">属性&amp;描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">stdout <br> 标准输出流。</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">stderr <br> 标准错误流。</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">stdin <br> 标准输入流。</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">argv <br> argv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">execPath <br> 返回执行当前脚本的 Node 二进制文件的绝对路径。</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">execArgv <br> 返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">env <br> 返回一个对象，成员为当前 shell 的环境变量</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">exitCode <br> 进程退出时的代码，如果进程优通过 process.exit() 退出，不需要指定退出码。</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">version <br> Node 的版本，比如v0.10.18。</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">versions <br> 一个属性，包含了 node 的版本和依赖.</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">config <br> 一个包含用来编译当前 node 执行文件的 javascript 配置选项的对象。它与运行 ./configure 脚本生成的 “config.gypi” 文件相同。</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">pid <br> 当前进程的进程号。</td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">title <br> 进程名，默认值为”node”，可以自定义该值。</td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">arch <br> 当前 CPU 的架构：’arm’、’ia32’ 或者 ‘x64’。</td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">platform <br> 运行程序所在的平台系统 ‘darwin’, ‘freebsd’, ‘linux’, ‘sunos’ 或 ‘win32’</td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">mainModule<br> require.main 的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。</td>\n</tr>\n</tbody></table>\n<p><strong><em>实例</em></strong><br>创建文件 main.js ，代码如下所示：</p>\n<pre><code>// 输出到终端\nprocess.stdout.write(&quot;Hello World!&quot; + &quot;\\n&quot;);\n\n// 通过参数读取\nprocess.argv.forEach(function(val, index, array) {\n   console.log(index + &apos;: &apos; + val);\n});\n\n// 获取执行路径\nconsole.log(process.execPath);\n\n\n// 平台信息\nconsole.log(process.platform);</code></pre><p>执行 main.js 文件，代码如下所示:</p>\n<pre><code>$ node main.js\nHello World!\n0: node\n1: /web/www/node/main.js\n/usr/local/node/0.10.36/bin/node\ndarwin</code></pre><p><strong>方法参考手册</strong><br>Process 提供了很多有用的方法，便于我们更好的控制系统的交互：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">方法 &amp; 描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">abort() <br> 这将导致node触发abort事件。会让node退出并生成一个核心文件</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">chdir(directory) <br> 改变当前工作进程的目录，如果操作失败抛出异常。</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">cwd() <br> 返回当前进程的工作目录</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">exit([code]) <br> 使用指定的 code 结束进程。如果忽略，将会使用 code 0。</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">getgid() <br> 取进程的群组标识（参见 getgid(2)）。获取到得时群组的数字 id，而不是名字. 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">setgid(id) <br> 设置进程的群组标识（参见 setgid(2)）。可以接收数字 ID 或者群组名。如果指定了群组名，会阻塞等待解析为数字 ID 。                    注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">getuid() <br> 获取进程的用户标识(参见 getuid(2))。这是数字的用户 id，不是用户名。                  注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">setuid(id) <br> 设置进程的用户标识（参见setuid(2)）。接收数字 ID或字符串名字。果指定了群组名，会阻塞等待解析为数字 ID 。                    注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">getgroups() <br> 返回进程的群组 iD 数组。POSIX 系统没有保证一定有，但是 node.js 保证有。                     注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">setgroups(groups) <br> 设置进程的群组 ID。这是授权操作，所以你需要有 root 权限，或者有 CAP_SETGID 能力。                            注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">initgroups(user, extra_group) <br> 读取 /etc/group ，并初始化群组访问列表，使用成员所在的所有群组。这是授权操作，所以你需要有 root 权限，或者有 CAP_SETGID 能力。                                        注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">kill(pid[, signal]) <br> 发送信号给进程. pid 是进程id，并且 signal 是发送的信号的字符串描述。信号名是字符串，比如 ‘SIGINT’ 或 ‘SIGHUP’。如果忽略，信号会是 ‘SIGTERM’。</td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">memoryUsage() <br> 返回一个对象，描述了 Node 进程所用的内存状况，单位为字节。</td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">nextTick(callback) <br> 一旦当前事件循环结束，调用回调函数。</td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">umask([mask]) <br> 设置或读取进程文件的掩码。子进程从父进程继承掩码。如果mask 参数有效，返回旧的掩码。否则，返回当前掩码。</td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">uptime() <br> 返回 Node 已经运行的秒数。</td>\n</tr>\n<tr>\n<td align=\"left\">17</td>\n<td align=\"left\">hrtime() <br> 返回当前进程的高分辨时间，形式为 [seconds, nanoseconds]数组。它是相对于过去的任意事件。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。                   你可以将之前的结果传递给当前的 process.hrtime() ，会返回两者间的时间差，用来基准和测量时间间隔。</td>\n</tr>\n</tbody></table>\n<h2 id=\"实例-9\"><a href=\"#实例-9\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>创建文件 main.js ，代码如下所示：</p>\n<pre><code>// 输出当前目录\nconsole.log(&apos;当前目录: &apos; + process.cwd());\n\n// 输出当前版本\nconsole.log(&apos;当前版本: &apos; + process.version);\n\n// 输出内存使用情况\nconsole.log(process.memoryUsage());</code></pre><p>执行 main.js 文件，代码如下所示:</p>\n<pre><code>$ node main.js\n当前目录: /web/com/runoob/nodejs\n当前版本: v0.10.36\n{ rss: 12541952, heapTotal: 4083456, heapUsed: 2157056 }</code></pre><h1 id=\"Node-js-常用工具\"><a href=\"#Node-js-常用工具\" class=\"headerlink\" title=\"Node.js 常用工具\"></a>Node.js 常用工具</h1><p>util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。</p>\n<p>util.inherits<br>util.inherits(constructor, superConstructor) 是一个实现对象间原型继承的函数。</p>\n<p>JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有提供对象继承的语言级别特性，而是通过原型复制来实现的。</p>\n<p>在这里我们只介绍 util.inherits 的用法，示例如下</p>\n"}],"PostAsset":[{"_id":"source/_posts/Javac原理/f.jpg","slug":"f.jpg","post":"ck139cecn000cojfydo4f4w5j","modified":1,"renderable":0},{"_id":"source/_posts/Mac-下locate命令使用问题WARNING-The-locate-database-var-db-locate-database-does-not-exist/locate.png","post":"ck139cecr000iojfyrksaew9v","slug":"locate.png","modified":1,"renderable":1},{"_id":"source/_posts/读-活着-有感/下载.jpeg","post":"ck139ceds0022ojfy98t118kd","slug":"下载.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/Javac原理/j.jpg","post":"ck139cecn000cojfydo4f4w5j","slug":"j.jpg","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ck139cecg0005ojfywzqbt2q3","category_id":"ck139cehm0025ojfyj44ueewo","_id":"ck139ceky006tojfy9inrpqen"},{"post_id":"ck139cech0006ojfy92gxajyd","category_id":"ck139cehp0029ojfyf8pwgyvl","_id":"ck139ceky006vojfyjd7rej49"},{"post_id":"ck139ceck0009ojfyc28a1c7q","category_id":"ck139cehp002bojfy54be1pzp","_id":"ck139ceky006xojfyvd3dqgs5"},{"post_id":"ck139cecm000bojfyjmw5a4y0","category_id":"ck139cehq002dojfy1eze1k2u","_id":"ck139ceky006zojfy8xjrhafk"},{"post_id":"ck139cecn000cojfydo4f4w5j","category_id":"ck139cehr002fojfyl0rm9jk6","_id":"ck139cekz0071ojfyuhjy0lw2"},{"post_id":"ck139cecn000dojfyqrqwnmxt","category_id":"ck139cehr002hojfyil7h8abe","_id":"ck139cekz0073ojfy35mko6ec"},{"post_id":"ck139ceco000eojfyvngd9dhr","category_id":"ck139cehu002jojfyobp3prog","_id":"ck139cekz0075ojfy7fzs9bwq"},{"post_id":"ck139ceco000fojfymrnbx7wm","category_id":"ck139cehr002hojfyil7h8abe","_id":"ck139cekz0077ojfy00wnz2na"},{"post_id":"ck139cecp000gojfydrrtwdsa","category_id":"ck139cehr002hojfyil7h8abe","_id":"ck139cekz0079ojfyzb3r7eap"},{"post_id":"ck139cecq000hojfyw3qzkjnj","category_id":"ck139cehr002hojfyil7h8abe","_id":"ck139cel0007bojfyymxodx68"},{"post_id":"ck139cecr000iojfyrksaew9v","category_id":"ck139cehx002qojfy6sc91809","_id":"ck139cel0007dojfy44jzsms1"},{"post_id":"ck139cecs000kojfy5tebpk9c","category_id":"ck139cehx002sojfy9dxnhf6e","_id":"ck139cel0007fojfy9p9y8i12"},{"post_id":"ck139cecu000oojfys3hazmvn","category_id":"ck139cehy002uojfynaghg6wy","_id":"ck139cel0007hojfy4uf5z3vq"},{"post_id":"ck139cecv000pojfy2mt2fwh8","category_id":"ck139cehy002wojfyhtnubkh4","_id":"ck139cel0007jojfybnw1jl0q"},{"post_id":"ck139cecv000qojfyksibevzk","category_id":"ck139cehr002fojfyl0rm9jk6","_id":"ck139cel1007lojfyt4jth666"},{"post_id":"ck139cecw000rojfymftcuyiq","category_id":"ck139cehr002hojfyil7h8abe","_id":"ck139cel1007nojfyg3n2z5zq"},{"post_id":"ck139cecx000sojfy4td3sp4m","category_id":"ck139cehr002hojfyil7h8abe","_id":"ck139cel1007pojfy5i4vt49j"},{"post_id":"ck139cecy000tojfytzteq5g9","category_id":"ck139cei20034ojfyeg9dgona","_id":"ck139cel2007rojfyumztjlb4"},{"post_id":"ck139cecy000uojfysedao90c","category_id":"ck139cei20036ojfy4tgk7vuo","_id":"ck139cel2007tojfyr1cnvrzq"},{"post_id":"ck139cecz000vojfyev4iy6lc","category_id":"ck139cei30038ojfy218d3b65","_id":"ck139cel2007vojfyqbitue48"},{"post_id":"ck139ced1000zojfy5zknr7ck","category_id":"ck139cehp002bojfy54be1pzp","_id":"ck139cel2007xojfybowoy3x5"},{"post_id":"ck139ced30011ojfyfefo4znf","category_id":"ck139cei4003cojfyq5opducq","_id":"ck139cel3007zojfy088tgsli"},{"post_id":"ck139ced40012ojfykbz37j4y","category_id":"ck139cehp0029ojfyf8pwgyvl","_id":"ck139cel30081ojfyu46opbwu"},{"post_id":"ck139ced40013ojfy2gj0dyjl","category_id":"ck139cei6003gojfy4gcq2elg","_id":"ck139cel30083ojfyikfq25sc"},{"post_id":"ck139ced50014ojfy4xmtcq2u","category_id":"ck139cei8003iojfypz76p9vi","_id":"ck139cel40085ojfy7ygm18o0"},{"post_id":"ck139ced60016ojfyvd1p0tzq","category_id":"ck139cehr002hojfyil7h8abe","_id":"ck139cel40087ojfykryko00w"},{"post_id":"ck139ced70017ojfy4uib2m64","category_id":"ck139cei8003iojfypz76p9vi","_id":"ck139cel40089ojfyth00h4wj"},{"post_id":"ck139ced80018ojfy2y9gmvhi","category_id":"ck139ceia003oojfyoriycsaw","_id":"ck139cel4008bojfyhfsq9x8d"},{"post_id":"ck139ced9001aojfyndw3lrw6","category_id":"ck139cehy002uojfynaghg6wy","_id":"ck139cel4008dojfy2e7g88op"},{"post_id":"ck139cedd001bojfy559n125t","category_id":"ck139cehr002hojfyil7h8abe","_id":"ck139cel5008fojfyrftgbceq"},{"post_id":"ck139cede001cojfy6jivtsgq","category_id":"ck139ceic003uojfyxjjh3r4c","_id":"ck139cel5008hojfy6xm44lvr"},{"post_id":"ck139cedf001eojfynvfv7iel","category_id":"ck139cei20034ojfyeg9dgona","_id":"ck139cel5008jojfy3irhfsjo"},{"post_id":"ck139cedf001fojfyixs02em2","category_id":"ck139cei20036ojfy4tgk7vuo","_id":"ck139cel5008lojfy7jnhc1mm"},{"post_id":"ck139cedg001gojfy0zx66tta","category_id":"ck139cehr002hojfyil7h8abe","_id":"ck139cel5008nojfywqj4984b"},{"post_id":"ck139cedg001hojfy3wlrpimw","category_id":"ck139cehr002hojfyil7h8abe","_id":"ck139cel5008pojfylz5x27nk"},{"post_id":"ck139cedh001iojfyaf0lh7kd","category_id":"ck139ceif0043ojfymz7co3ci","_id":"ck139cel5008rojfyt94qykc9"},{"post_id":"ck139cedi001kojfywctap0oi","category_id":"ck139ceif0043ojfymz7co3ci","_id":"ck139cel6008tojfyfi3bkl0t"},{"post_id":"ck139cedj001mojfybbs7r94x","category_id":"ck139ceig0047ojfyynawtv7u","_id":"ck139cel6008vojfy2c4r32nv"},{"post_id":"ck139cedk001nojfyxpacfngq","category_id":"ck139cei8003iojfypz76p9vi","_id":"ck139cel6008xojfysk12dpjv"},{"post_id":"ck139cedl001oojfy9upjax3z","category_id":"ck139cehx002sojfy9dxnhf6e","_id":"ck139cel6008zojfy0r8teb8x"},{"post_id":"ck139cedl001pojfy3ytw2fwb","category_id":"ck139ceif0043ojfymz7co3ci","_id":"ck139cel60091ojfyjs0wq98y"},{"post_id":"ck139cedm001rojfyp2w9zplj","category_id":"ck139ceii004fojfyg3aalv8n","_id":"ck139cel60093ojfy051akea3"},{"post_id":"ck139cedn001sojfy6d3e8upf","category_id":"ck139ceii004hojfyo28p8dhb","_id":"ck139cel60095ojfyy9j8tr7v"},{"post_id":"ck139cedo001uojfy96n6mo8u","category_id":"ck139ceij004jojfyho323ht5","_id":"ck139cel70097ojfys18l34dx"},{"post_id":"ck139cedp001vojfy515h3itf","category_id":"ck139ceif0043ojfymz7co3ci","_id":"ck139cel70099ojfyspt5tv4k"},{"post_id":"ck139cedp001wojfy042optrx","category_id":"ck139ceif0043ojfymz7co3ci","_id":"ck139cel7009bojfyf8omk4b2"},{"post_id":"ck139cedp001xojfy8aachd1t","category_id":"ck139ceif0043ojfymz7co3ci","_id":"ck139cel7009dojfyzykwp2m4"},{"post_id":"ck139cedq001zojfy74koa75m","category_id":"ck139ceil004rojfycpsu85u6","_id":"ck139cel7009fojfyf14bfmea"},{"post_id":"ck139cedr0020ojfykcdp2v7i","category_id":"ck139ceif0043ojfymz7co3ci","_id":"ck139cel7009hojfyo2p9090x"},{"post_id":"ck139ceds0022ojfy98t118kd","category_id":"ck139ceim004vojfyf4ajx59v","_id":"ck139cel8009jojfy0d20t080"},{"post_id":"ck139ceds0023ojfy9o1mo6ua","category_id":"ck139ceif0043ojfymz7co3ci","_id":"ck139cel8009lojfymebad3cu"}],"PostTag":[{"post_id":"ck139cecb0001ojfyljxmtmri","tag_id":"ck139ceh70024ojfytaqwvk69","_id":"ck139ceky006sojfylg2uxrjw"},{"post_id":"ck139cecb0001ojfyljxmtmri","tag_id":"ck139ceho0028ojfyrjee9fj6","_id":"ck139ceky006uojfy9qs6p6uy"},{"post_id":"ck139cecf0003ojfynqrmj1vz","tag_id":"ck139cehp002aojfywnfv0m9u","_id":"ck139ceky006wojfywhh96uwx"},{"post_id":"ck139cecf0003ojfynqrmj1vz","tag_id":"ck139cehq002cojfypz8dobih","_id":"ck139ceky006yojfym79uc6js"},{"post_id":"ck139cecf0003ojfynqrmj1vz","tag_id":"ck139cehr002eojfyeyxzssvu","_id":"ck139cekz0070ojfy1mzi3bw9"},{"post_id":"ck139cecg0004ojfyw42l1owh","tag_id":"ck139ceh70024ojfytaqwvk69","_id":"ck139cekz0072ojfy6buqe1ns"},{"post_id":"ck139cecg0004ojfyw42l1owh","tag_id":"ck139cehu002iojfysmf8r4rr","_id":"ck139cekz0074ojfyujx6d7j3"},{"post_id":"ck139cecg0005ojfywzqbt2q3","tag_id":"ck139cehu002kojfyva6hypdt","_id":"ck139cekz0076ojfyb1sja0ci"},{"post_id":"ck139cecg0005ojfywzqbt2q3","tag_id":"ck139cehv002mojfyhru7hhc2","_id":"ck139cekz0078ojfy6qvmp0to"},{"post_id":"ck139cech0006ojfy92gxajyd","tag_id":"ck139cehw002pojfyzai0q1ef","_id":"ck139cel0007aojfyxj9mcij9"},{"post_id":"ck139cech0006ojfy92gxajyd","tag_id":"ck139cehx002rojfyzoxgsz99","_id":"ck139cel0007cojfyv01c3f51"},{"post_id":"ck139ceci0007ojfye06dp1pp","tag_id":"ck139cehy002tojfy5uwirhrh","_id":"ck139cel0007eojfycmoz8eoo"},{"post_id":"ck139ceci0007ojfye06dp1pp","tag_id":"ck139cehy002vojfyhk0wf07u","_id":"ck139cel0007gojfynd0kc93e"},{"post_id":"ck139cecj0008ojfyis2eofhc","tag_id":"ck139cehz002xojfy99sbu0vo","_id":"ck139cel0007iojfy99cpi0au"},{"post_id":"ck139cecj0008ojfyis2eofhc","tag_id":"ck139cehz002zojfyquy96b72","_id":"ck139cel0007kojfy7hrgyakl"},{"post_id":"ck139ceck0009ojfyc28a1c7q","tag_id":"ck139cei00031ojfymzahq8hg","_id":"ck139cel1007mojfyoofmzm47"},{"post_id":"ck139cecl000aojfyutwscpk1","tag_id":"ck139cei10033ojfykw5erqn1","_id":"ck139cel1007oojfym2122gdw"},{"post_id":"ck139cecm000bojfyjmw5a4y0","tag_id":"ck139cei20035ojfy0ktymfde","_id":"ck139cel2007qojfyyjcox1eo"},{"post_id":"ck139cecm000bojfyjmw5a4y0","tag_id":"ck139cei30037ojfykrqd2pbo","_id":"ck139cel2007sojfy67o2ga24"},{"post_id":"ck139cecn000cojfydo4f4w5j","tag_id":"ck139cehw002pojfyzai0q1ef","_id":"ck139cel2007uojfyzzqpqh03"},{"post_id":"ck139cecn000dojfyqrqwnmxt","tag_id":"ck139cehp002aojfywnfv0m9u","_id":"ck139cel2007wojfyc539uov5"},{"post_id":"ck139cecn000dojfyqrqwnmxt","tag_id":"ck139cei5003dojfyoi2j5umv","_id":"ck139cel3007yojfy5xywwxm8"},{"post_id":"ck139ceco000eojfyvngd9dhr","tag_id":"ck139cei6003fojfyl6pley6v","_id":"ck139cel30080ojfynb6lz2f0"},{"post_id":"ck139ceco000eojfyvngd9dhr","tag_id":"ck139cei7003hojfyhyqz3bme","_id":"ck139cel30082ojfy6isvg285"},{"post_id":"ck139ceco000fojfymrnbx7wm","tag_id":"ck139cei8003jojfyvq5z6x92","_id":"ck139cel40084ojfyxi5hktfn"},{"post_id":"ck139ceco000fojfymrnbx7wm","tag_id":"ck139cei9003lojfy93m544iw","_id":"ck139cel40086ojfyni44aviq"},{"post_id":"ck139ceco000fojfymrnbx7wm","tag_id":"ck139ceia003nojfymprlcl31","_id":"ck139cel40088ojfy2i1lxf6e"},{"post_id":"ck139ceco000fojfymrnbx7wm","tag_id":"ck139ceia003pojfyenfjyy3t","_id":"ck139cel4008aojfyyt166llw"},{"post_id":"ck139cecp000gojfydrrtwdsa","tag_id":"ck139cei8003jojfyvq5z6x92","_id":"ck139cel4008cojfyqesvq41b"},{"post_id":"ck139cecp000gojfydrrtwdsa","tag_id":"ck139ceic003tojfynvaz4lfz","_id":"ck139cel5008eojfy2v05407y"},{"post_id":"ck139cecq000hojfyw3qzkjnj","tag_id":"ck139cei8003jojfyvq5z6x92","_id":"ck139cel5008gojfyzskm4w70"},{"post_id":"ck139cecr000iojfyrksaew9v","tag_id":"ck139ceid003xojfyxarfpf6p","_id":"ck139cel5008iojfytvewv5jm"},{"post_id":"ck139cecr000iojfyrksaew9v","tag_id":"ck139ceie003zojfy30x3sx98","_id":"ck139cel5008kojfyhg0w1tnb"},{"post_id":"ck139cecr000jojfyoj24fm0m","tag_id":"ck139ceie0042ojfyiab7don4","_id":"ck139cel5008mojfynyjweyyr"},{"post_id":"ck139cecr000jojfyoj24fm0m","tag_id":"ck139ceif0044ojfyevleq1u5","_id":"ck139cel5008oojfy7oy9tq5w"},{"post_id":"ck139cecr000jojfyoj24fm0m","tag_id":"ck139ceif0046ojfy6jnoffwp","_id":"ck139cel5008qojfyao1lnggj"},{"post_id":"ck139cecs000kojfy5tebpk9c","tag_id":"ck139cehw002pojfyzai0q1ef","_id":"ck139cel6008sojfyqtk1rr31"},{"post_id":"ck139cecs000kojfy5tebpk9c","tag_id":"ck139ceig004aojfy48n3w20k","_id":"ck139cel6008uojfyvrt0f0m2"},{"post_id":"ck139cecs000kojfy5tebpk9c","tag_id":"ck139cehy002tojfy5uwirhrh","_id":"ck139cel6008wojfyj3wnhgbd"},{"post_id":"ck139cecs000kojfy5tebpk9c","tag_id":"ck139ceii004eojfyxrknkd1s","_id":"ck139cel6008yojfyzhz9gvaj"},{"post_id":"ck139cecs000lojfywqv1p5bw","tag_id":"ck139ceii004gojfyvvateg14","_id":"ck139cel60090ojfym9q8uhxo"},{"post_id":"ck139cecu000oojfys3hazmvn","tag_id":"ck139ceii004iojfycgn4yuzj","_id":"ck139cel60092ojfy42nkz7e1"},{"post_id":"ck139cecv000pojfy2mt2fwh8","tag_id":"ck139ceij004kojfyqj7kp6kq","_id":"ck139cel60094ojfyo253sn5z"},{"post_id":"ck139cecv000qojfyksibevzk","tag_id":"ck139ceij004mojfysvh4mdjl","_id":"ck139cel70096ojfy79d54c22"},{"post_id":"ck139cecv000qojfyksibevzk","tag_id":"ck139cehw002pojfyzai0q1ef","_id":"ck139cel70098ojfyhk4a9hd4"},{"post_id":"ck139cecw000rojfymftcuyiq","tag_id":"ck139cei8003jojfyvq5z6x92","_id":"ck139cel7009aojfyy9v53g2q"},{"post_id":"ck139cecx000sojfy4td3sp4m","tag_id":"ck139cei8003jojfyvq5z6x92","_id":"ck139cel7009cojfynlbauej3"},{"post_id":"ck139cecy000tojfytzteq5g9","tag_id":"ck139cehw002pojfyzai0q1ef","_id":"ck139cel7009eojfyb8p2hymt"},{"post_id":"ck139cecy000tojfytzteq5g9","tag_id":"ck139ceim004wojfy7xyqhxqj","_id":"ck139cel7009gojfyre74jgb3"},{"post_id":"ck139cecz000vojfyev4iy6lc","tag_id":"ck139cein004yojfy6re9pb91","_id":"ck139cel8009iojfyuckgvs24"},{"post_id":"ck139ced0000wojfyex6jrb21","tag_id":"ck139cehu002kojfyva6hypdt","_id":"ck139cel8009kojfytc45lr1r"},{"post_id":"ck139ced0000wojfyex6jrb21","tag_id":"ck139cein0050ojfy3gvc6xma","_id":"ck139cel8009mojfye3j8kbov"},{"post_id":"ck139ced0000xojfyfvgobzpy","tag_id":"ck139ceio0051ojfyqizsn0z8","_id":"ck139cel8009nojfysolxpx7p"},{"post_id":"ck139ced0000xojfyfvgobzpy","tag_id":"ck139ceio0052ojfyrg5qloyw","_id":"ck139cel8009oojfy25712eoe"},{"post_id":"ck139ced0000xojfyfvgobzpy","tag_id":"ck139ceio0053ojfyfbu9e6y9","_id":"ck139cel8009pojfyv5p4t5wp"},{"post_id":"ck139ced1000zojfy5zknr7ck","tag_id":"ck139cei00031ojfymzahq8hg","_id":"ck139cel8009qojfy74y6rq1h"},{"post_id":"ck139ced20010ojfyryww0g0r","tag_id":"ck139ceio0055ojfynw7ji1o9","_id":"ck139cel8009rojfysnr3snuu"},{"post_id":"ck139ced20010ojfyryww0g0r","tag_id":"ck139ceip0056ojfy7hg0j13u","_id":"ck139cel8009sojfyeess8vzu"},{"post_id":"ck139ced30011ojfyfefo4znf","tag_id":"ck139ceip0057ojfyqlfazb4b","_id":"ck139cel8009tojfywz6h9782"},{"post_id":"ck139ced30011ojfyfefo4znf","tag_id":"ck139ceip0058ojfyzpmshf8e","_id":"ck139cel8009uojfycca24ccz"},{"post_id":"ck139ced30011ojfyfefo4znf","tag_id":"ck139ceiq0059ojfyeoluq217","_id":"ck139cel8009vojfyq8bpo7pd"},{"post_id":"ck139ced40012ojfykbz37j4y","tag_id":"ck139cehy002tojfy5uwirhrh","_id":"ck139cel9009wojfy7cbipx8j"},{"post_id":"ck139ced40012ojfykbz37j4y","tag_id":"ck139cehw002pojfyzai0q1ef","_id":"ck139cel9009xojfy1423jg1g"},{"post_id":"ck139ced40012ojfykbz37j4y","tag_id":"ck139ceir005cojfy98wrc9co","_id":"ck139cel9009yojfyxxwmjukh"},{"post_id":"ck139ced40013ojfy2gj0dyjl","tag_id":"ck139cehy002tojfy5uwirhrh","_id":"ck139cel9009zojfy34weqefk"},{"post_id":"ck139ced50014ojfy4xmtcq2u","tag_id":"ck139cehw002pojfyzai0q1ef","_id":"ck139cel900a0ojfynk960lto"},{"post_id":"ck139ced50014ojfy4xmtcq2u","tag_id":"ck139ceis005fojfypg9nmude","_id":"ck139cel900a1ojfycqqk4el5"},{"post_id":"ck139ced50014ojfy4xmtcq2u","tag_id":"ck139ceim004wojfy7xyqhxqj","_id":"ck139cel900a2ojfyxoliogrv"},{"post_id":"ck139ced60015ojfy5876e72h","tag_id":"ck139cei00031ojfymzahq8hg","_id":"ck139cel900a3ojfy3oqvh86n"},{"post_id":"ck139ced60016ojfyvd1p0tzq","tag_id":"ck139cei8003jojfyvq5z6x92","_id":"ck139cel900a4ojfyul6m9spz"},{"post_id":"ck139ced60016ojfyvd1p0tzq","tag_id":"ck139ceiu005jojfy4p12p2f6","_id":"ck139cel900a5ojfyq73be66s"},{"post_id":"ck139ced70017ojfy4uib2m64","tag_id":"ck139ceiu005kojfywg2dk4fe","_id":"ck139cel900a6ojfytb96v69w"},{"post_id":"ck139ced70017ojfy4uib2m64","tag_id":"ck139ceie003zojfy30x3sx98","_id":"ck139cel900a7ojfyq1ormzm4"},{"post_id":"ck139ced80018ojfy2y9gmvhi","tag_id":"ck139ceiu005kojfywg2dk4fe","_id":"ck139cel900a8ojfy49gx9lh6"},{"post_id":"ck139ced80018ojfy2y9gmvhi","tag_id":"ck139ceiw005nojfyfskaq348","_id":"ck139cel900a9ojfy50nqhvcn"},{"post_id":"ck139ced80018ojfy2y9gmvhi","tag_id":"ck139cehy002vojfyhk0wf07u","_id":"ck139cel900aaojfyss5rcqj6"},{"post_id":"ck139ced80019ojfyblnujekd","tag_id":"ck139ceif0046ojfy6jnoffwp","_id":"ck139cel900abojfylnjqwx6s"},{"post_id":"ck139ced80019ojfyblnujekd","tag_id":"ck139ceiu005kojfywg2dk4fe","_id":"ck139cel900acojfypoo3nwru"},{"post_id":"ck139ced9001aojfyndw3lrw6","tag_id":"ck139ceix005rojfyy3wvd2sf","_id":"ck139cela00adojfypve0ifat"},{"post_id":"ck139ced9001aojfyndw3lrw6","tag_id":"ck139ceix005sojfyuaz435iy","_id":"ck139cela00aeojfy4cihyet7"},{"post_id":"ck139cedd001bojfy559n125t","tag_id":"ck139ceix005tojfy5p64hds4","_id":"ck139cela00afojfy97zx1x3m"},{"post_id":"ck139cedd001bojfy559n125t","tag_id":"ck139ceix005rojfyy3wvd2sf","_id":"ck139cela00agojfymradwriq"},{"post_id":"ck139cede001cojfy6jivtsgq","tag_id":"ck139ceij004mojfysvh4mdjl","_id":"ck139celb00ahojfyk0pdho3w"},{"post_id":"ck139cede001cojfy6jivtsgq","tag_id":"ck139ceiy005wojfy694f3lwf","_id":"ck139celb00aiojfy70n3fan1"},{"post_id":"ck139cede001dojfyjaxsh9lr","tag_id":"ck139ceiz005xojfyxs2f3gqa","_id":"ck139celb00ajojfyb4wl0n1j"},{"post_id":"ck139cedf001eojfynvfv7iel","tag_id":"ck139cehw002pojfyzai0q1ef","_id":"ck139celb00akojfyr582d58s"},{"post_id":"ck139cedf001eojfynvfv7iel","tag_id":"ck139ceim004wojfy7xyqhxqj","_id":"ck139celb00alojfyndyhhr2u"},{"post_id":"ck139cedf001fojfyixs02em2","tag_id":"ck139cei8003jojfyvq5z6x92","_id":"ck139celb00amojfyfxp4hmc0"},{"post_id":"ck139cedf001fojfyixs02em2","tag_id":"ck139cei5003dojfyoi2j5umv","_id":"ck139celb00anojfyo0dhpigm"},{"post_id":"ck139cedg001gojfy0zx66tta","tag_id":"ck139cej10062ojfyy94felxb","_id":"ck139celb00aoojfybxgjatz3"},{"post_id":"ck139cedg001hojfy3wlrpimw","tag_id":"ck139cehp002aojfywnfv0m9u","_id":"ck139celb00apojfyy5m3tvz7"},{"post_id":"ck139cedh001iojfyaf0lh7kd","tag_id":"ck139cej10064ojfysssq79nq","_id":"ck139celb00aqojfytr9izah0"},{"post_id":"ck139cedh001iojfyaf0lh7kd","tag_id":"ck139cej10065ojfy8aifudi5","_id":"ck139celb00arojfywsa6qcvg"},{"post_id":"ck139cedi001kojfywctap0oi","tag_id":"ck139cej10065ojfy8aifudi5","_id":"ck139celb00asojfy6xq0eecn"},{"post_id":"ck139cedj001mojfybbs7r94x","tag_id":"ck139cej20067ojfymgudedsy","_id":"ck139celb00atojfyimrn5ner"},{"post_id":"ck139cedj001mojfybbs7r94x","tag_id":"ck139cehw002pojfyzai0q1ef","_id":"ck139celb00auojfy6bw2ktun"},{"post_id":"ck139cedk001nojfyxpacfngq","tag_id":"ck139cehw002pojfyzai0q1ef","_id":"ck139celb00avojfy7t7rfnra"},{"post_id":"ck139cedk001nojfyxpacfngq","tag_id":"ck139ceie003zojfy30x3sx98","_id":"ck139celb00awojfywmbpm1cz"},{"post_id":"ck139cedl001oojfy9upjax3z","tag_id":"ck139cehw002pojfyzai0q1ef","_id":"ck139celb00axojfy7u9rd0l6"},{"post_id":"ck139cedl001oojfy9upjax3z","tag_id":"ck139ceig004aojfy48n3w20k","_id":"ck139celb00ayojfyq618i11z"},{"post_id":"ck139cedl001pojfy3ytw2fwb","tag_id":"ck139cej10065ojfy8aifudi5","_id":"ck139celc00azojfyudvr1kpq"},{"post_id":"ck139cedm001rojfyp2w9zplj","tag_id":"ck139cej4006eojfy5xpdpame","_id":"ck139celc00b0ojfytzmihs9f"},{"post_id":"ck139cedn001sojfy6d3e8upf","tag_id":"ck139cej4006fojfy492wukkd","_id":"ck139celc00b1ojfyyhdv8ceu"},{"post_id":"ck139cedn001tojfyrtcnm48r","tag_id":"ck139cej4006gojfy8vt0rhgt","_id":"ck139celc00b2ojfy8nzw7vud"},{"post_id":"ck139cedn001tojfyrtcnm48r","tag_id":"ck139cej4006hojfyc0tub5wv","_id":"ck139celc00b3ojfy6hl0vs74"},{"post_id":"ck139cedn001tojfyrtcnm48r","tag_id":"ck139cej5006iojfyhpghfsfd","_id":"ck139celc00b4ojfyru0shere"},{"post_id":"ck139cedn001tojfyrtcnm48r","tag_id":"ck139cej5006jojfy1yskyljd","_id":"ck139celc00b5ojfyq7g75dms"},{"post_id":"ck139cedn001tojfyrtcnm48r","tag_id":"ck139ceij004kojfyqj7kp6kq","_id":"ck139celc00b6ojfyloy9ctyn"},{"post_id":"ck139cedo001uojfy96n6mo8u","tag_id":"ck139cej5006lojfy1965w9fs","_id":"ck139celc00b7ojfynugvxzgr"},{"post_id":"ck139cedp001vojfy515h3itf","tag_id":"ck139cej10065ojfy8aifudi5","_id":"ck139celc00b8ojfy7raneyij"},{"post_id":"ck139cedp001vojfy515h3itf","tag_id":"ck139cej6006nojfy5pu98hc6","_id":"ck139celc00b9ojfy9rn3b448"},{"post_id":"ck139cedp001vojfy515h3itf","tag_id":"ck139cej6006oojfyueb5lqmf","_id":"ck139celc00baojfy5qumzwlv"},{"post_id":"ck139cedq001zojfy74koa75m","tag_id":"ck139cej6006pojfyrtuy8r90","_id":"ck139celc00bbojfyyluwi5f2"},{"post_id":"ck139cedq001zojfy74koa75m","tag_id":"ck139cehw002pojfyzai0q1ef","_id":"ck139celc00bcojfyudq3vaw7"},{"post_id":"ck139ceds0022ojfy98t118kd","tag_id":"ck139cej8006rojfyq12l3c8k","_id":"ck139celc00bdojfydsjj8x91"},{"post_id":"ck139cehn0027ojfyfta52rev","tag_id":"ck139ceie0042ojfyiab7don4","_id":"ck139celd00beojfyfgmk8ijl"}],"Tag":[{"name":"AtomicInteger","_id":"ck139ceh70024ojfytaqwvk69"},{"name":"CAS","_id":"ck139ceho0028ojfyrjee9fj6"},{"name":"linux","_id":"ck139cehp002aojfywnfv0m9u"},{"name":"CentOS","_id":"ck139cehq002cojfypz8dobih"},{"name":"防火墙","_id":"ck139cehr002eojfyeyxzssvu"},{"name":"源码","_id":"ck139cehu002iojfysmf8r4rr"},{"name":"git","_id":"ck139cehu002kojfyva6hypdt"},{"name":"ssh","_id":"ck139cehv002mojfyhru7hhc2"},{"name":"java","_id":"ck139cehw002pojfyzai0q1ef"},{"name":"filter","_id":"ck139cehx002rojfyzoxgsz99"},{"name":"idea","_id":"ck139cehy002tojfy5uwirhrh"},{"name":"快捷键","_id":"ck139cehy002vojfyhk0wf07u"},{"name":"Intellij IDEA","_id":"ck139cehz002xojfy99sbu0vo"},{"name":"JDK","_id":"ck139cehz002zojfyquy96b72"},{"name":"hexo","_id":"ck139cei00031ojfymzahq8hg"},{"name":"kotlin","_id":"ck139cei10033ojfykw5erqn1"},{"name":"JSP","_id":"ck139cei20035ojfy0ktymfde"},{"name":"JavaScript","_id":"ck139cei30037ojfykrqd2pbo"},{"name":"ubuntu","_id":"ck139cei5003dojfyoi2j5umv"},{"name":"LeetCode","_id":"ck139cei6003fojfyl6pley6v"},{"name":"算法","_id":"ck139cei7003hojfyhyqz3bme"},{"name":"Linux","_id":"ck139cei8003jojfyvq5z6x92"},{"name":"tar","_id":"ck139cei9003lojfy93m544iw"},{"name":"压缩","_id":"ck139ceia003nojfymprlcl31"},{"name":"解压缩","_id":"ck139ceia003pojfyenfjyy3t"},{"name":"命令","_id":"ck139ceic003tojfynvaz4lfz"},{"name":"Mac","_id":"ck139ceid003xojfyxarfpf6p"},{"name":"exception","_id":"ck139ceie003zojfy30x3sx98"},{"name":"node","_id":"ck139ceie0042ojfyiab7don4"},{"name":"npm","_id":"ck139ceif0044ojfyevleq1u5"},{"name":"brew","_id":"ck139ceif0046ojfy6jnoffwp"},{"name":"lombok","_id":"ck139ceig004aojfy48n3w20k"},{"name":"plugin","_id":"ck139ceii004eojfyxrknkd1s"},{"name":"java jdk","_id":"ck139ceii004gojfyvvateg14"},{"name":"laravel","_id":"ck139ceii004iojfycgn4yuzj"},{"name":"mysql","_id":"ck139ceij004kojfyqj7kp6kq"},{"name":"Spring","_id":"ck139ceij004mojfysvh4mdjl"},{"name":"spring","_id":"ck139ceim004wojfy7xyqhxqj"},{"name":"vagrant","_id":"ck139cein004yojfy6re9pb91"},{"name":"回滚","_id":"ck139cein0050ojfy3gvc6xma"},{"name":"编码","_id":"ck139ceio0051ojfyqizsn0z8"},{"name":"hex","_id":"ck139ceio0052ojfyrg5qloyw"},{"name":"16进制","_id":"ck139ceio0053ojfyfbu9e6y9"},{"name":"键盘","_id":"ck139ceio0055ojfynw7ji1o9"},{"name":"hhkb","_id":"ck139ceip0056ojfy7hg0j13u"},{"name":"homestead","_id":"ck139ceip0057ojfyqlfazb4b"},{"name":"mongo","_id":"ck139ceip0058ojfyzpmshf8e"},{"name":"php扩展","_id":"ck139ceiq0059ojfyeoluq217"},{"name":"maven","_id":"ck139ceir005cojfy98wrc9co"},{"name":"异常","_id":"ck139ceis005fojfypg9nmude"},{"name":"环境变量","_id":"ck139ceiu005jojfy4p12p2f6"},{"name":"mac","_id":"ck139ceiu005kojfywg2dk4fe"},{"name":"chrome","_id":"ck139ceiw005nojfyfskaq348"},{"name":"php","_id":"ck139ceix005rojfyy3wvd2sf"},{"name":"unset","_id":"ck139ceix005sojfyuaz435iy"},{"name":"shell","_id":"ck139ceix005tojfy5p64hds4"},{"name":"Tomcat","_id":"ck139ceiy005wojfy694f3lwf"},{"name":"java tomcat","_id":"ck139ceiz005xojfyxs2f3gqa"},{"name":"vim","_id":"ck139cej10062ojfyy94felxb"},{"name":"bug","_id":"ck139cej10064ojfysssq79nq"},{"name":"生活","_id":"ck139cej10065ojfy8aifudi5"},{"name":"Shiro","_id":"ck139cej20067ojfymgudedsy"},{"name":"育儿","_id":"ck139cej4006eojfy5xpdpame"},{"name":"TravisCI","_id":"ck139cej4006fojfy492wukkd"},{"name":"回表","_id":"ck139cej4006gojfy8vt0rhgt"},{"name":"覆盖索引","_id":"ck139cej4006hojfyc0tub5wv"},{"name":"数据库","_id":"ck139cej5006iojfyhpghfsfd"},{"name":"oracle","_id":"ck139cej5006jojfy1yskyljd"},{"name":"成语","_id":"ck139cej5006lojfy1965w9fs"},{"name":"泰拳","_id":"ck139cej6006nojfy5pu98hc6"},{"name":"运动","_id":"ck139cej6006oojfyueb5lqmf"},{"name":"rabbitMQ","_id":"ck139cej6006pojfyrtuy8r90"},{"name":"读后感","_id":"ck139cej8006rojfyq12l3c8k"}]}}