<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>I want jing jing</title>
  
  <subtitle>I want jing jing ,Don&#39;t ask me who is jing jing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://iwantjingjing.com/"/>
  <updated>2020-04-28T01:39:11.241Z</updated>
  <id>http://iwantjingjing.com/</id>
  
  <author>
    <name>给予ππ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql之锁</title>
    <link href="http://iwantjingjing.com/2020/04/28/mysql%E4%B9%8B%E9%94%81/"/>
    <id>http://iwantjingjing.com/2020/04/28/mysql之锁/</id>
    <published>2020-04-28T01:03:29.000Z</published>
    <updated>2020-04-28T01:39:11.241Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://xzh20121116.github.io/post/mysql-zhi-suo/" target="_blank" rel="noopener">摘自</a></p><h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><pre><code>加锁 lock tablas ...read/write主动解锁 unlock tables ... 被动解锁 客户端断开连接时被动解锁限制其他线程读写，也会对本线程接下来的操作对象。一般不用，消耗大</code></pre><h2 id="MDL（元数据锁-meta-data-lock）"><a href="#MDL（元数据锁-meta-data-lock）" class="headerlink" title="MDL（元数据锁 meta data lock）"></a>MDL（元数据锁 meta data lock）</h2><pre><code>自动加锁读锁 对表数据的增删改查写锁 对表结构的修改多个事务读锁不互斥多个事务写锁互斥mdl作用保证读写的正确性</code></pre><h1 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h1><p>根据数据引擎来实现的，MyIsam就不支持行锁</p><h2 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h2><pre><code>innodb中有需要时加此锁，但并非不需要时解锁，而是在事务提交之后解锁。若一个事务锁多行，尽可能把并发多的行往后写。</code></pre><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><pre><code>事务a等待事务b释放某行的锁，事务b等待事务a释放某行的锁就造成死锁。例如：事务a update table a ... where line = 1;事务b update table a ... where line = 2;事务a update table a ... where line = 2;事务b update table a ... where line = 1;事务a等待事务b释放line=2的锁，事务b等待事务a释放line=1的锁，由于两阶段锁的存在（即事务只有在commit之后才释放锁）顾造成锁都释放不了，造成死锁。</code></pre><h2 id="mvcc-多版本并发控制"><a href="#mvcc-多版本并发控制" class="headerlink" title="mvcc(多版本并发控制)"></a>mvcc(多版本并发控制)</h2><pre><code>mysql在修改一行数据时，都会记录一行此数据相应的回滚操作，若某行数据被改了n次，则此事务相应的回滚记录也被记录了n次。这种一条数据在系统中有多个版本就是多版本并发控制mvcc.</code></pre><h1 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h1><p> <img src="mysql%E4%B9%8B%E9%94%81.png" alt> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://xzh20121116.github.io/post/mysql-zhi-suo/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;摘自&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;表级锁&quot;&gt;&lt;a href=&quot;#表级锁&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://iwantjingjing.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://iwantjingjing.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>java 内存模型与volatile关键字</title>
    <link href="http://iwantjingjing.com/2020/04/27/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8Evolatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://iwantjingjing.com/2020/04/27/java-内存模型与volatile关键字/</id>
    <published>2020-04-27T03:56:54.000Z</published>
    <updated>2020-04-27T04:37:03.720Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://xzh20121116.github.io/post/VPO1pZnCC/" target="_blank" rel="noopener">摘自</a></p><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="what（是什么）"><a href="#what（是什么）" class="headerlink" title="what（是什么）"></a>what（是什么）</h2><p>一种抽象概念，是一种规则，描述了Java线程间通信的访问方式。<br>规定了主内存，工作内存（线程本地内存）之间通行的规则。<br>所有线程都可以访问（读取）主内存的资源，然后将主内存的资源拷贝到自己的工作内存，修改时先修改自己的工作内存，然后将工作内存的资源拷贝到主内存，所有线程都不可直接对主内存进行写入。他们只能直接操作自己的工作内存。</p><pre><code>1 一个线程加锁前必须将主内存中的值刷新到自己的工作内存2 一个线程解锁前必须将自己工作内存中的值刷新到主内存3 加解锁必须是同一个锁</code></pre><h2 id="主内存与工作内存之间的关系8种"><a href="#主内存与工作内存之间的关系8种" class="headerlink" title="主内存与工作内存之间的关系8种"></a>主内存与工作内存之间的关系8种</h2><pre><code>1 lock 作用于主内存 即保证资源被一个线程独享2 unlock 作用于主内存 释放一个资源3 read 作用于主内存 将一个资源从主内存传输到工作内存4 load 作用于工作内存 将读取的资源加载到工作内存5 use 工作内存 使用资源以用于显示，传递等6 assign 工作内存 赋值 将从控制引擎得到的值赋值给工作内存7 store 工作内存 将赋值的值写入存储到工作内存8 write 主内存 将存储的值 刷新到主内存</code></pre><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><pre><code>原子性 一个操作是不可中断的，即多个线程操作时，一个线程的操作也是不可被打断的，直到操作完成。可见性 对主内存的修改，其他线程都能第一时间看到,多线程有问题有序性 理想状态是一条一条执行的，但因重排序（指令重拍的存在）顾不是有序的</code></pre><h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><h2 id="保证了两大特性"><a href="#保证了两大特性" class="headerlink" title="保证了两大特性"></a>保证了两大特性</h2><pre><code>有序性可见性</code></pre><h2 id="有序性原理"><a href="#有序性原理" class="headerlink" title="有序性原理"></a>有序性原理</h2><p>当操作由volatile修饰的变量时，jvm会向控制器发送一条带有lock前缀的指令，该指令实际上就形成了一个内存屏障，有效隔离了变量前及变量后的操作，防止了指令重排序。从而实现了有序性</p><h2 id="可见性原理"><a href="#可见性原理" class="headerlink" title="可见性原理"></a>可见性原理</h2><p>lock指令保证了工作内存变量值得有效性，即其他工作内存变量值得无效性。</p><h1 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h1><p><img src="java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E3%80%81volatile%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://xzh20121116.github.io/post/VPO1pZnCC/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;摘自&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; c
      
    
    </summary>
    
    
      <category term="java" scheme="http://iwantjingjing.com/categories/java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础题</title>
    <link href="http://iwantjingjing.com/2020/04/19/Java%E5%9F%BA%E7%A1%80%E9%A2%98/"/>
    <id>http://iwantjingjing.com/2020/04/19/Java基础题/</id>
    <published>2020-04-19T08:50:24.000Z</published>
    <updated>2020-04-19T09:20:51.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-以下哪个是finalize-方法的正确形式？"><a href="#1-以下哪个是finalize-方法的正确形式？" class="headerlink" title="1.以下哪个是finalize()方法的正确形式？"></a>1.以下哪个是finalize()方法的正确形式？</h1><pre><code>A.protected void finalize() throws ThrowableB.final finalize()C.public final finalize()D.private boolean finalize()答案：A</code></pre><h1 id="2-如果finalize（）方法抛出一个运行时异常，以下哪个描述正确？"><a href="#2-如果finalize（）方法抛出一个运行时异常，以下哪个描述正确？" class="headerlink" title="2.如果finalize（）方法抛出一个运行时异常，以下哪个描述正确？"></a>2.如果finalize（）方法抛出一个运行时异常，以下哪个描述正确？</h1><pre><code>A.正在运行的应用程序系统崩溃B.此异常被忽略，并且该异常对象被垃圾回收器回收C.此异常被忽略，但是该异常对象未被垃圾回收期回收D.此异常导致JVM崩溃答案：B答案解析：finalize()方法只是用于清除对象，而不是实际的销毁对象，因此对该方法的调用不会引起系统崩溃，该方法抛出的异常也会作为废弃对象被垃圾回收期回收</code></pre><h1 id="3-如何释放掉一个对象占据的内存空间？"><a href="#3-如何释放掉一个对象占据的内存空间？" class="headerlink" title="3.如何释放掉一个对象占据的内存空间？"></a>3.如何释放掉一个对象占据的内存空间？</h1><pre><code>A.调用free()方法B.调用System.gc()方法C.赋值给该对象的引用为nullD.程序员无法明确强制垃圾回收器运行答案：D</code></pre><h1 id="4-给出以下代码："><a href="#4-给出以下代码：" class="headerlink" title="4.给出以下代码："></a>4.给出以下代码：</h1><pre><code>1.public class Example {2. public static void main(String[] args) {3.  String s = &quot;abcd&quot;;4.  Integer x = new Integer(3);5.  String s2 = s + 4;6.  s2 = null;7.  s = null;8. }9.}改程序运行到第几行变量S2引用的对象符合垃圾回收器回收条件？A.第7行B.不存在C.第6行D.直到main线程结束，S2应用的对象才可能被回收答案：C</code></pre><h1 id="5-以下代码运行到关键点处，有多少对象符合垃圾回收的条件？"><a href="#5-以下代码运行到关键点处，有多少对象符合垃圾回收的条件？" class="headerlink" title="5.以下代码运行到关键点处，有多少对象符合垃圾回收的条件？"></a>5.以下代码运行到关键点处，有多少对象符合垃圾回收的条件？</h1><pre><code>public class Example { public static void main(String[] args) {  String name;  String newName = &quot;Nick&quot;;  newName = &quot;Jason&quot;;  name = &quot;Frieda&quot;;  String newestName = name;  name = null;  // 关键点 }}A.0个B.1个C.2个D.3个答案：B</code></pre><h1 id="6-以下哪些是有关垃圾回收器的正确描述？"><a href="#6-以下哪些是有关垃圾回收器的正确描述？" class="headerlink" title="6.以下哪些是有关垃圾回收器的正确描述？"></a>6.以下哪些是有关垃圾回收器的正确描述？</h1><pre><code>A.程序员可以在制定时间调用垃圾回收器释放内存B.垃圾回收器可以保证Java程序不会产生内存溢出C.程序员可以制定垃圾回收器回收对象D.对象的finalize()方法在对象被垃圾回收器回收之前获得调用答案：C、D答案解析：通过通配符*号引入的两个不同包中存在同名的类，当代码中不加包名直接使用时，会产生编译错误，使用时需要提供完整包路径</code></pre><h1 id="7-拥有下列哪些引用类型的对象在虚拟机内存足够的情况下不会被垃圾回收机制回收？"><a href="#7-拥有下列哪些引用类型的对象在虚拟机内存足够的情况下不会被垃圾回收机制回收？" class="headerlink" title="7.拥有下列哪些引用类型的对象在虚拟机内存足够的情况下不会被垃圾回收机制回收？"></a>7.拥有下列哪些引用类型的对象在虚拟机内存足够的情况下不会被垃圾回收机制回收？</h1><pre><code>A.强引用B.软引用C.弱引用D.虚引用答案：A、B</code></pre><h1 id="8-finalize和C-的-destructors有何差异"><a href="#8-finalize和C-的-destructors有何差异" class="headerlink" title="8.finalize和C++ 的 destructors有何差异?"></a>8.finalize和C++ 的 destructors有何差异?</h1><pre><code>答案：Java内部具有“内存使用回收” 的机制， 虽然它也提供了类似 (C++ 的) destructors的 finalize()，每个对象都可以使用这个方法 method，但必须冒著破坏原先回收机制的危险。所以建议尽量避免使用finalize()，不妨考虑多使用引用队列来释出资源会好一些。</code></pre><h1 id="9-Java语言中异常的分类是哪项？"><a href="#9-Java语言中异常的分类是哪项？" class="headerlink" title="9.Java语言中异常的分类是哪项？"></a>9.Java语言中异常的分类是哪项？</h1><pre><code>A.运行时异常和异常B.受检异常和非受检异常C.错误和异常D.错误和运行时异常答案：C</code></pre><h1 id="10-所有异常的父类是哪项？"><a href="#10-所有异常的父类是哪项？" class="headerlink" title="10.所有异常的父类是哪项？"></a>10.所有异常的父类是哪项？</h1><pre><code>A.ThrowableB.ErrorC.RuntimeExceptionD.Exception答案：A</code></pre><h1 id="11-下列属于非受检异常（运行时异常）的是哪项？"><a href="#11-下列属于非受检异常（运行时异常）的是哪项？" class="headerlink" title="11.下列属于非受检异常（运行时异常）的是哪项？"></a>11.下列属于非受检异常（运行时异常）的是哪项？</h1><pre><code>A.SQLExceptionB.IOExceptionC.NullPointerExceptionD.OutOfMemoryError答案：C</code></pre><h1 id="12-假设有自定义异常类ServiceException-那么抛出该异常的语句正确的是哪项？"><a href="#12-假设有自定义异常类ServiceException-那么抛出该异常的语句正确的是哪项？" class="headerlink" title="12.假设有自定义异常类ServiceException,那么抛出该异常的语句正确的是哪项？"></a>12.假设有自定义异常类ServiceException,那么抛出该异常的语句正确的是哪项？</h1><pre><code>A.raise ServiceExceptionB.throw new ServiceException()C.throw ServiceExceptionD.throws ServiceException答案：B</code></pre><h1 id="13-在方法声明中，说明该方法可能会抛出的异常列表时使用哪个关键字？"><a href="#13-在方法声明中，说明该方法可能会抛出的异常列表时使用哪个关键字？" class="headerlink" title="13.在方法声明中，说明该方法可能会抛出的异常列表时使用哪个关键字？"></a>13.在方法声明中，说明该方法可能会抛出的异常列表时使用哪个关键字？</h1><pre><code>A.throw B.catchC.finallyD.throws答案：D</code></pre><h1 id="14-现有代码："><a href="#14-现有代码：" class="headerlink" title="14.现有代码："></a>14.现有代码：</h1><pre><code>public class Example { public static void main(String[] args) {  try {   System.out.print(Integer.parseInt(&quot;forty&quot;));     } catch (RuntimeException e) {   System.out.println(&quot;Runtime&quot;);  }catch (NumberFormatException e) {   System.out.println(&quot;Number&quot;);  } }}执行结果是什么？A.输出NumberB.输出RuntimeC.输出40D.编译失败答案：D答案解析：NumberFormatException是RuntimeException的子类，因此两个catch块位置应该交换才能正确处理异常</code></pre><h1 id="15-现有代码如下："><a href="#15-现有代码如下：" class="headerlink" title="15.现有代码如下："></a>15.现有代码如下：</h1><pre><code>public class Example { void topGo() {  try {   middleGo();  } catch (Exception e) {   System.out.println(&quot;catch&quot;);  } } void middleGo() throws Exception {  go();  System.out.println(&quot;late middle&quot;); } void go() throws Exception {  throw new Exception(); } public static void main(String[] args) {  Example example = new Example();  example.topGo(); }}该代码的执行结果是？A.输出late middleB.输出catchC.输出late middle catchD.输出catch late middle答案：B</code></pre><h1 id="16-如下代码执行后的输出结果是？"><a href="#16-如下代码执行后的输出结果是？" class="headerlink" title="16.如下代码执行后的输出结果是？"></a>16.如下代码执行后的输出结果是？</h1><pre><code>public class Example { public static void main(String[] args) {  try {   throw new Exception();  } catch (Exception e) {   try {    throw new Exception();   } catch (Exception e2) {    System.out.println(&quot;inner&quot;);   }   System.out.println(&quot;middle&quot;);  }  System.out.println(&quot;out&quot;); }}A.inner outerB.middle outerC.inner middle outerD.编译失败答案：C</code></pre><h1 id="17-现有如下代码："><a href="#17-现有如下代码：" class="headerlink" title="17.现有如下代码："></a>17.现有如下代码：</h1><pre><code>public class Example extends Utils{ public static void main(String[] args) {  try {   System.out.println(new Example().getInt(&quot;42&quot;));  } catch (NumberFormatException e) {   System.out.println(&quot;NFExc&quot;);  } }  int getInt(String arg) throws NumberFormatException{  return Integer.parseInt(arg); }}class Utils { int getInt(String arg) {  return 42; }}该代码执行的结果是？A.NFExcB.42.0C.42NFExcD.编译失败答案：B答案解析：Utils中的getInt方法没有抛出异常，而子类Example中的getInt抛出了运行时异常，这是符合方法覆盖的抛出异常特性规范的，因为运行时异常并不会强制要求方法调用代码捕获处理</code></pre><h1 id="18-现有如下代码："><a href="#18-现有如下代码：" class="headerlink" title="18.现有如下代码："></a>18.现有如下代码：</h1><pre><code>public class Example extends Utils{ public static void main(String[] args) {  try {   System.out.println(new Example().getInt(&quot;42&quot;));  } catch (NumberFormatException e) {   System.out.println(&quot;NFExc&quot;);  } }  int getInt(String arg) throws Exception{  return Integer.parseInt(arg); }}class Utils { int getInt(String arg) {  return 42; }}该代码执行的结果是？A.NFExcB.42.0C.42NFExcD.编译失败答案：D答案解析：子类抛出的异常不符合方法覆盖的异常列表要求，因此编译失败（见上题）</code></pre><h1 id="19-现有如下代码："><a href="#19-现有如下代码：" class="headerlink" title="19.现有如下代码："></a>19.现有如下代码：</h1><pre><code>public class Example { public static void main(String[] args) {// a  new Example().topGo(); } void topGo() {// b  middleGo(); } void middleGo() {// c  go();  System.out.println(&quot;late middle&quot;); } void go() {// d  throw new Exception(); }}为了使代码能够编译通过，需要在哪个地方加入声明throws Exception?A.dB.c和dC.b、c和dD.a、b、c和d答案：D</code></pre><h1 id="20-下面代码的执行结果是？"><a href="#20-下面代码的执行结果是？" class="headerlink" title="20.下面代码的执行结果是？"></a>20.下面代码的执行结果是？</h1><pre><code>class Example extends Utils { public static void main(String[] args) {  try {   System.out.print(new Example().getlnt(&quot;42&quot;));  } catch (Exception e) {   System.out.println(&quot;Exc&quot;);  } } int getlnt(String arg) throws Exception {  return Integer.parseInt(arg); }}class Utils { int getlnt() {  return 42; }}A.NFExcB.42.0C.42NFExcD.编译失败答案：B答案解析：本题没有实现方法覆盖</code></pre><h1 id="21-关于异常处理，说法错误的是？"><a href="#21-关于异常处理，说法错误的是？" class="headerlink" title="21.关于异常处理，说法错误的是？"></a>21.关于异常处理，说法错误的是？</h1><pre><code>A.try⋯catch⋯finally结构中，必须有try语句块，catch语句块和finally语句块不是必须的，但至少要两者取其一B.在异常处理中，若try中的代码可能产生多种异常则可以对应多个catch语句，若catch中的参数类型有父类子类关系，此时应该将子类放在后面，父类放在前面C.一个方法可以抛出多个异常，方法的返回值也能够是异常D.Throwable是所有异常的超类答案：B答案解析：若catch中的参数类型有父类子类关系，此时应该将子类放在前面，父类放在后面</code></pre><h1 id="22-以下关于Error和Exception类的描述正确的是？"><a href="#22-以下关于Error和Exception类的描述正确的是？" class="headerlink" title="22.以下关于Error和Exception类的描述正确的是？"></a>22.以下关于Error和Exception类的描述正确的是？</h1><pre><code>A.Error类和Exception类都是Throwable类的子类B.Error类是一个final类，而Exception类是一个非final类C.Exception类是一个final类，而Error类是一个非final类D.Error类和Exception类都实现了Throwable接口答案：A</code></pre><h1 id="23-请问以下哪个是声明一个方法抛出异常的正确形式？"><a href="#23-请问以下哪个是声明一个方法抛出异常的正确形式？" class="headerlink" title="23.请问以下哪个是声明一个方法抛出异常的正确形式？"></a>23.请问以下哪个是声明一个方法抛出异常的正确形式？</h1><pre><code>A.void m() throws IOException{}B.void m() throw IOExceptionC.void m(){} throws IOExceptionD.void m(void) throw IOException{}答案：A</code></pre><h1 id="24-请问以下哪些关于try⋯catch⋯finally结构中的finally语句的描述是正确的？"><a href="#24-请问以下哪些关于try⋯catch⋯finally结构中的finally语句的描述是正确的？" class="headerlink" title="24.请问以下哪些关于try⋯catch⋯finally结构中的finally语句的描述是正确的？"></a>24.请问以下哪些关于try⋯catch⋯finally结构中的finally语句的描述是正确的？</h1><pre><code>A.只有当一个catch语句获得执行后，finally语句才获得执行B.只有当catch语句未获得执行时，finally语句才获得执行C.如果有finally语句，return语句将在finally语句执行完毕后才会返回D.只有当异常抛出时，finally语句才获得执行答案：C</code></pre><h1 id="25-请问以下代码的直接执行结果是？"><a href="#25-请问以下代码的直接执行结果是？" class="headerlink" title="25.请问以下代码的直接执行结果是？"></a>25.请问以下代码的直接执行结果是？</h1><pre><code>class Example{ public static void main(String[] args) {  try {   System.out.println(args[0]);   System.out.println(&quot;I&apos;m nomal&quot;);   if (true)    return;  } catch (Exception ex) {   System.out.println(&quot;I&apos;m exception&quot;);   if (true)    return;  } finally {   System.out.println(&quot;I&apos;m finally.&quot;);  }  System.out.println(&quot;Out of try.&quot;); }｝A.I&apos;m exceptionI&apos;m finally.B.代码不能编译通过，因为最后一条语句位于return后，不可到达C.代码编译通过，但运行时输出异常信息D.I&apos;m nomalI&apos;m finally.答案：A</code></pre><h1 id="26-关于以下代码，说法正确的是？"><a href="#26-关于以下代码，说法正确的是？" class="headerlink" title="26.关于以下代码，说法正确的是？"></a>26.关于以下代码，说法正确的是？</h1><pre><code>class Example{ public static void main(String[] args) throws IOException {  if (args[0] == &quot;hello&quot;) {   throw new IOException();  } }}A.代码编译成功B.代码编译失败，因为main()方法是入口方法，不能抛出异常C.代码编译失败，因为IOException异常是系统异常，不能由应用程序抛出D.代码编译失败，因为字符串应该用equals方法判定一致性答案：A</code></pre><h1 id="27-关于以下代码，说法正确的是？"><a href="#27-关于以下代码，说法正确的是？" class="headerlink" title="27.关于以下代码，说法正确的是？"></a>27.关于以下代码，说法正确的是？</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  System.out.println(&quot;Before Try&quot;);  try {  } catch (java.io.IOException e) {   System.out.println(&quot;Inside Catch&quot;);  }  System.out.println(&quot;At the End&quot;); }}A.代码编译失败，因为无异常抛出B.代码编译失败，因为未导入IOException异常类C.输出Before TryAt the EndD.输出Inside CatchAt the End答案：A</code></pre><h1 id="28-关于以下代码，说法正确的是？"><a href="#28-关于以下代码，说法正确的是？" class="headerlink" title="28.关于以下代码，说法正确的是？"></a>28.关于以下代码，说法正确的是？</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  System.out.println(&quot;Before Try&quot;);  try {  } catch (Throwable e) {   System.out.println(&quot;Inside Catch&quot;);  }  System.out.println(&quot;At the End&quot;); }}A.代码编译失败，因为无异常抛出B.代码编译失败，因为未导入IOException异常类C.输出Before TryAt the EndD.输出Inside CatchAt the End答案：C</code></pre><h1 id="29-给出以下代码："><a href="#29-给出以下代码：" class="headerlink" title="29.给出以下代码："></a>29.给出以下代码：</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  try {   methodA();     } catch (IOException e) {   System.out.println(&quot;caught IOException&quot;);  }catch (Exception e) {   System.out.println(&quot;caught Exception&quot;);  } }}如果methodA()方法抛出一个IOException异常，则该程序的运行结果是什么？A.无内容输出B.代码编译失败C.输出caught IOExceptionD.输出caught Exception答案：C</code></pre><h1 id="30-下列代码的运行结果是？"><a href="#30-下列代码的运行结果是？" class="headerlink" title="30.下列代码的运行结果是？"></a>30.下列代码的运行结果是？</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  try {   return;  } finally{   System.out.println(&quot;Finally&quot;);  } }}A.无内容输出B.输出FinallyC.代码编译失败D.输出异常信息答案：B</code></pre><h1 id="31-给出以下代码，执行结果是？"><a href="#31-给出以下代码，执行结果是？" class="headerlink" title="31.给出以下代码，执行结果是？"></a>31.给出以下代码，执行结果是？</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  aMethod(); } static void aMethod(){  try {   System.out.println(&quot;Try&quot;);   return;  } catch (Exception e) {   System.out.println(&quot;Catch&quot;);  }finally{   System.out.println(&quot;Finally&quot;);  } }}A.代码编译成功，但运行期间抛出异常B.代码便以失败，因为return语句错误C.输出Try和FinallyD.输出Try答案：C</code></pre><h1 id="32-以下代码中，如果test-方法抛出一个NullPointException异常时，打印输出什么内容？"><a href="#32-以下代码中，如果test-方法抛出一个NullPointException异常时，打印输出什么内容？" class="headerlink" title="32.以下代码中，如果test()方法抛出一个NullPointException异常时，打印输出什么内容？"></a>32.以下代码中，如果test()方法抛出一个NullPointException异常时，打印输出什么内容？</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  try {   test();   System.out.println(&quot;Message1&quot;);  } catch (ArrayIndexOutOfBoundsException e) {   System.out.println(&quot;Message2&quot;);  }finally{   System.out.println(&quot;Message3&quot;);  } }}A.打印输出Message1B.打印输出Message2C.打印输出Message3D.以上都不对答案：C</code></pre><h1 id="33-以下代码执行结果是什么？"><a href="#33-以下代码执行结果是什么？" class="headerlink" title="33.以下代码执行结果是什么？"></a>33.以下代码执行结果是什么？</h1><pre><code>class Example { public static String output = &quot;&quot;; public static void foo(int i) {  try {   if (i == 1) {    throw new Exception();   }   output += &quot;1&quot;;  } catch (Exception e) {   output += &quot;2&quot;;   return;  } finally {   output += &quot;3&quot;;  }  output += &quot;4&quot;; } public static void main(String[] args) throws IOException {  foo(0);  foo(1);  System.out.println(output); }}A.无内容输出B.代码编译失败C.输出13423D.输出14323答案：C</code></pre><h1 id="34-以下代码执行结果是？"><a href="#34-以下代码执行结果是？" class="headerlink" title="34.以下代码执行结果是？"></a>34.以下代码执行结果是？</h1><pre><code>public abstract class Example extends Base { public abstract void method();}class Base { public Base() throws IOException {  throw new IOException(); }}A.代码编译失败，因为非抽象类不能被扩展为抽象类B.代码编译失败，因为必须提供一个可以抛出或可以不抛出IOException异常的构造器C.代码编译失败，以in为必须提供一个可以抛出IOException异常或其子类的构造器D.代码编译成功答案：C</code></pre><h1 id="35-关于以下代码正确的说法是："><a href="#35-关于以下代码正确的说法是：" class="headerlink" title="35.关于以下代码正确的说法是："></a>35.关于以下代码正确的说法是：</h1><pre><code>public class Example {int x = 0; public Example(int inVal) throws Exception {if (inVal != this.x) { throw new Exception(&quot;Invalid input&quot;);} }public static void main(String[] args) { Example t = new Example(4); }}A.代码在第1行编译错误B.代码在第4行编译错误C.代码在第6行编译错误D.代码在第11行编译错误答案：D</code></pre><h1 id="36-关于try⋯catch⋯finally结构，描述正确的是些？"><a href="#36-关于try⋯catch⋯finally结构，描述正确的是些？" class="headerlink" title="36.关于try⋯catch⋯finally结构，描述正确的是些？"></a>36.关于try⋯catch⋯finally结构，描述正确的是些？</h1><pre><code>A.可以有多个catchB.只能有一个catchC.可以没有catchD.finally必须有答案：A、C</code></pre><h1 id="37-当fragile-方法抛出一个IllegalArgumentException异常时，下列代码的运行结果是什么？"><a href="#37-当fragile-方法抛出一个IllegalArgumentException异常时，下列代码的运行结果是什么？" class="headerlink" title="37.当fragile()方法抛出一个IllegalArgumentException异常时，下列代码的运行结果是什么？"></a>37.当fragile()方法抛出一个IllegalArgumentException异常时，下列代码的运行结果是什么？</h1><pre><code>public static void main(String[] args) throws IOException {  try {   fragile();  } catch (NullPointerException e) {   System.out.println(&quot;NullPointerException thrown&quot;);  } catch (Exception e) {   System.out.println(&quot;Exception thrown&quot;);  } finally {   System.out.println(&quot;Done with exceptions&quot;);  }  System.out.println(&quot;myMethod is done&quot;); }｝A.输出NullPointerException thrownB.输出Exception thrownC.输出Done with ExceptionD.输出myMethod is done答案：B、C、D</code></pre><h1 id="38-现有如下代码："><a href="#38-现有如下代码：" class="headerlink" title="38.现有如下代码："></a>38.现有如下代码：</h1><pre><code>public class Example {  public static void main(String[] args) {  try {   int x=Integer.parseInt(&quot;42a&quot;);   //插入代码处   System.out.println(&quot;oops&quot;);  } }}在插入代码处插入哪些语句可以在运行后输出oops？A. } catch (IllegalArgumentException e) {B.} catch (IllegalStateException c) {C. } catch (NumbelFormatException n) {D.} catch (ClassCastException c) {答案：A、C</code></pre><h1 id="39-下列代码的执行结果是？"><a href="#39-下列代码的执行结果是？" class="headerlink" title="39.下列代码的执行结果是？"></a>39.下列代码的执行结果是？</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  int i = 1, j = 1;  try {   i++;   j--;   if (i == j) {    j++;   }  } catch (ArithmeticException e) {   System.out.println(0);  } catch (ArrayIndexOutOfBoundsException e) {   System.out.println(1);  } catch (Exception e) {   System.out.println(2);  } finally {   System.out.println(3);  }  System.out.println(4); }}A.输出1B.输出2C.输出3D.输出4答案：C、D</code></pre><h1 id="40-下列代码的执行结果是？"><a href="#40-下列代码的执行结果是？" class="headerlink" title="40.下列代码的执行结果是？"></a>40.下列代码的执行结果是？</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  int i = 1, j = 1;  try {   i++;   j--;   if (i/j &gt; 1) {    j++;   }  } catch (ArithmeticException e) {   System.out.println(0);  } catch (ArrayIndexOutOfBoundsException e) {   System.out.println(1);  } catch (Exception e) {   System.out.println(2);  } finally {   System.out.println(3);  }  System.out.println(4); }}A.输出0B.输出2C.输出3D.输出4答案：A、C、D</code></pre><h1 id="41-现有如下代码："><a href="#41-现有如下代码：" class="headerlink" title="41.现有如下代码："></a>41.现有如下代码：</h1><pre><code>public class Example {  public static void main(String[] args) {  try {   System.out.println(&quot;before&quot;);   doRisyThing();   System.out.println(&quot;after&quot;);  } catch (Exception e) {   System.out.println(&quot;catch&quot;);  }  System.out.println(&quot;done&quot;); } public static void doRisyThing() throws Exception{  //this code returns unless it throws an Exception }}该代码可能的执行结果有哪些？A.before catchB.before after doneC.before catch doneD.before after catch答案：B、C</code></pre><h1 id="42-以下有关java-lang-Exception异常类的正确描述有？"><a href="#42-以下有关java-lang-Exception异常类的正确描述有？" class="headerlink" title="42.以下有关java.lang.Exception异常类的正确描述有？"></a>42.以下有关java.lang.Exception异常类的正确描述有？</h1><pre><code>A.该类是一个公共类B.该类是Throwable类的子类C.该类实现了Throwable接口D.该类可以序列化答案：A、B、D</code></pre><h1 id="43-给出以下代码："><a href="#43-给出以下代码：" class="headerlink" title="43.给出以下代码："></a>43.给出以下代码：</h1><pre><code>1. public void aMethod(){  2.  3.  if(Condition){4.   5.  }6.  7. }当if条件表达式为true时，插入哪些语句可以抛出MyException异常？A.在第4行插入throws new MyException();B.在第4行插入throw new MyException();C.在第6行插入throw new MyException();D.在第1行插入throws MyException答案：B、D</code></pre><h1 id="44-以下哪些是catch语句能够捕获处理的异常？"><a href="#44-以下哪些是catch语句能够捕获处理的异常？" class="headerlink" title="44.以下哪些是catch语句能够捕获处理的异常？"></a>44.以下哪些是catch语句能够捕获处理的异常？</h1><pre><code>A.ThrowableB.ErrorC.ExceptionD.String答案：A、B、CError也是可以被catch捕获的</code></pre><h1 id="45-以下哪些描述是正确的？"><a href="#45-以下哪些描述是正确的？" class="headerlink" title="45.以下哪些描述是正确的？"></a>45.以下哪些描述是正确的？</h1><pre><code>A.try语句块后必须至少存在一个catch语句块B.try语句块后可以存在不限数量的finally语句块C.try语句块后必须至少存在一个catch语句块或finally语句块D.如果catch和finally语句块同时存在，则catch语句块必须位于finally语句块前答案：C、D</code></pre><h1 id="46-下列代码的执行结果是？"><a href="#46-下列代码的执行结果是？" class="headerlink" title="46.下列代码的执行结果是？"></a>46.下列代码的执行结果是？</h1><pre><code>class Example { private void method1() throws Exception {  throw new RuntimeException(); } public void method2() {  try {   method1();  } catch (RuntimeException e) {   System.out.println(&quot;Caught Runtime Exception&quot;);  } catch (Exception e) {   System.out.println(&quot;Caught Exception&quot;);  } } public static void main(String[] args) throws IOException {  Example a = new Example();  a.method2(); }}A.代码编译失败B.输出Caught Runtime ExceptionC.输出Caught ExceptionD.输出Caught Runtime Exception和Caught Exception答案：B</code></pre><h1 id="47-以下代码的输出结果是什么？选择所有的正确答案。"><a href="#47-以下代码的输出结果是什么？选择所有的正确答案。" class="headerlink" title="47.以下代码的输出结果是什么？选择所有的正确答案。"></a>47.以下代码的输出结果是什么？选择所有的正确答案。</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  for (int i = 0; i &lt; 10; i++) {   try {    try {     if (i % 3 == 0)      throw new Exception(&quot;E0&quot;);     System.out.println(i);    } catch (Exception inner) {     i *= 2;     if (i % 3 == 0)      throw new Exception(&quot;E1&quot;);    } finally {     ++i;    }   } catch (Exception outer) {    i += 3;   } finally {    --i;   }  } }}A.4.0B.5.0C.6.0D.7.0答案：A、B</code></pre><h1 id="48-Java中异常的分类"><a href="#48-Java中异常的分类" class="headerlink" title="48.Java中异常的分类"></a>48.Java中异常的分类</h1><pre><code>答案：java.lang.Throwable|-- Error错误：JVM内部的严重问题。无法恢复。程序人员不用处理。|--Exception异常：普通的问题。通过合理的处理，程序还可以回到正常执行流程。要求编程人员要进行处理。|--RuntimeException:也叫非受检异常(unchecked exception).这类异常是编程人员的逻辑问题。应该承担责任。Java编译器不进行强制要求处理。 也就是说，这类异常再程序中，可以进行处理，也可以不处理。|--非RuntimeException:也叫受检异常(checked exception).这类异常是由一些外部的偶然因素所引起的。Java编译器强制要求处理。也就是说，程序必须进行对这类异常进行处理。</code></pre><h1 id="49-给出常见的RuntimeException"><a href="#49-给出常见的RuntimeException" class="headerlink" title="49.给出常见的RuntimeException"></a>49.给出常见的RuntimeException</h1><pre><code>答案：常见的运行时异常有如下这些ArithmeticException, ArrayStoreException, BufferOverflowException, BufferUnderflowException, CannotRedoException, CannotUndoException, ClassCastException, CMMException, ConcurrentModificationException, DOMException, EmptyStackException, IllegalArgumentException, IllegalMonitorStateException, IllegalPathStateException, IllegalStateException, ImagingOpException, IndexOutOfBoundsException, MissingResourceException, NegativeArraySizeException, NoSuchElementException, NullPointerException, ProfileDataException, ProviderException, RasterFormatException, SecurityException, SystemException, UndeclaredThrowableException, UnmodifiableSetException, UnsupportedOperationException</code></pre><h1 id="50-error和exception有什么区别"><a href="#50-error和exception有什么区别" class="headerlink" title="50.error和exception有什么区别"></a>50.error和exception有什么区别</h1><pre><code>答案：error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况</code></pre><h1 id="51-以下代码的执行结果是？"><a href="#51-以下代码的执行结果是？" class="headerlink" title="51.以下代码的执行结果是？"></a>51.以下代码的执行结果是？</h1><pre><code>public static int fun() {  int result = 5;  try {   result = result / 0;   return result;  } catch (Exception e) {   System.out.println(&quot;Exception&quot;);   result = -1;   return result;  } finally {   result = 10;   System.out.println(&quot;i am in finally&quot;);  } } public static void main(String[] args) {  int x=fun();  System.out.println(x); }答案：ExceptionI am in finally-1</code></pre><h1 id="52-以下代码的执行结果是？"><a href="#52-以下代码的执行结果是？" class="headerlink" title="52.以下代码的执行结果是？"></a>52.以下代码的执行结果是？</h1><pre><code>public class Example { public static StringBuffer fun() {  StringBuffer result = new StringBuffer(&quot;Hello&quot;);  Integer i = new Integer(5);  try {   if (true)    throw new RuntimeException();   return result;  } catch (Exception e) {   System.out.println(&quot;Exception&quot;);   result.append(&quot; World&quot;);   return result;  } finally {   result.append(&quot; Java&quot;);   System.out.println(&quot;i am in finally&quot;);  } } public static void main(String[] args) {  StringBuffer x = fun();  System.out.println(x); }答案：Exceptioni am in finallyHello World Java</code></pre><h1 id="53-什么时候用assert"><a href="#53-什么时候用assert" class="headerlink" title="53.什么时候用assert?"></a>53.什么时候用assert?</h1><pre><code>答案：断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为 true。如果表达式计算为 false，那么系统会报告一个 Assertionerror。它用于调试目的：assert(a &gt; 0); // throws anAssertionerror if a &lt;= 0断言可以有两种形式：assert Expression1 ;assert Expression1 :Expression2 ;  Expression1 应该总是产生一个布尔值。  Expression2 可以是得出一个值的任意表达式。这个值用于生成显示更多调试信息的 String 消息。  断言在默认情况下是禁用的。要在编译时启用断言，需要使用 source 1.4 标记：  javac -source 1.4 Test.java  要在运行时启用断言，可使用 -enableassertions 或者 -ea 标记。  要在运行时选择禁用断言，可使用 -da 或者 -disableassertions 标记。  要系统类中启用断言，可使用 -esa 或者 -dsa 标记。还可以在包的基础上启用或者禁用断言。 可以在预计正常情况下不会到达的任何位置上放置断言。断言可以用于验证传递给私有方法的参数。不过，断言不应该用于验证传递给公有方法的参数，因为不管是否启用了断言，公有方法都必须检查其参数。不过，既可以在公有方法中，也可以在非公有方法中利用断言测试后置条件。另外，断言不应该以任何方式改变程序的状态。</code></pre><h1 id="54-给我一个你最常见到的runtime-exception"><a href="#54-给我一个你最常见到的runtime-exception" class="headerlink" title="54.给我一个你最常见到的runtime exception"></a>54.给我一个你最常见到的runtime exception</h1><pre><code>答案：常见的运行时异常有如下这些ArithmeticException, ArrayStoreException, BufferOverflowException, BufferUnderflowException, CannotRedoException, CannotUndoException, ClassCastException, CMMException, ConcurrentModificationException, DOMException, EmptyStackException, IllegalArgumentException, IllegalMonitorStateException, IllegalPathStateException, IllegalStateException, ImagingOpException, IndexOutOfBoundsException, MissingResourceException, NegativeArraySizeException, NoSuchElementException, NullPointerException, ProfileDataException, ProviderException, RasterFormatException, SecurityException, SystemException, UndeclaredThrowableException, UnmodifiableSetException, UnsupportedOperationException</code></pre><h1 id="55-谈谈final-finally-finalize的区别"><a href="#55-谈谈final-finally-finalize的区别" class="headerlink" title="55.谈谈final, finally, finalize的区别"></a>55.谈谈final, finally, finalize的区别</h1><pre><code>答案：final—修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载finally—再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）finalize—方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的</code></pre><h1 id="56-下列说法错误的是？"><a href="#56-下列说法错误的是？" class="headerlink" title="56.下列说法错误的是？"></a>56.下列说法错误的是？</h1><pre><code>A.Object类是所有Java类的顶层类，即类继承树的根。B.如果一个类没有使用extends关键字扩展任何类，则编译器自动将创建的类视为Object类的子类C.Object类中提供了equals()方法来判定本对象和其他对象中的内容是否一致D.Object中提供的clone默认为浅克隆答案：Cequals方法默认和==一致</code></pre><h1 id="57-定义在Object类上的hashCode-方法的返回值类型是什么？"><a href="#57-定义在Object类上的hashCode-方法的返回值类型是什么？" class="headerlink" title="57.定义在Object类上的hashCode()方法的返回值类型是什么？"></a>57.定义在Object类上的hashCode()方法的返回值类型是什么？</h1><pre><code>A.charB.longC.intD.float答案：C</code></pre><h1 id="58-关于集合中对象的equals-和hashCode-规定说法错误的是？"><a href="#58-关于集合中对象的equals-和hashCode-规定说法错误的是？" class="headerlink" title="58.关于集合中对象的equals()和hashCode()规定说法错误的是？"></a>58.关于集合中对象的equals()和hashCode()规定说法错误的是？</h1><pre><code>A.如果两个对象相同，那么他们的hashCode值需要一致B.如果两个对象的hashCode值一致，他们的equals方法不一定返回trueC.equals方法默认和==判定一致D.Java中hashCode就是对象的内存地址答案：DJava中hashCode不是内存地址，但是可以一定程度上代表地址特诊</code></pre><h1 id="59-以下代码执行结果是什么？"><a href="#59-以下代码执行结果是什么？" class="headerlink" title="59.以下代码执行结果是什么？"></a>59.以下代码执行结果是什么？</h1><pre><code>class Person { static void sayHello() {  System.out.println(&quot;HelloWorld!&quot;); }}public class Example { public static void main(String[] args) {  ((Person) null).sayHello(); }}A.编译失败B.编译成功，运行时产生NullPointerExceptionC.输出HelloWorld!D.输出空白字符串答案：Cnull能够被造型撑任何类型，而sayHello方法是静态方法，不依赖实例调用</code></pre><h1 id="60-下列代码执行结果是："><a href="#60-下列代码执行结果是：" class="headerlink" title="60.下列代码执行结果是："></a>60.下列代码执行结果是：</h1><pre><code>class RectObject { public int x; public int y; public RectObject(int x, int y) {  this.x = x;  this.y = y; } @Override public int hashCode() {  final int prime = 31;  int result = 1;  result = prime * result + x;  result = prime * result + y;  return result; } @Override public boolean equals(Object obj) {  if (this == obj)   return true;  if (obj == null)   return false;  if (getClass() != obj.getClass())   return false;  final RectObject other = (RectObject) obj;  if (x != other.x) {   return false;  }  if (y != other.y) {   return false;  }  return true; }}public class Example { public static void main(String[] args) {  HashSet&lt;RectObject&gt; set = new HashSet&lt;RectObject&gt;();  RectObject r1 = new RectObject(3, 3);  RectObject r2 = new RectObject(5, 5);  RectObject r3 = new RectObject(3, 3);  set.add(r1);  set.add(r2);  set.add(r3);  set.add(r1);  System.out.println(&quot;size:&quot; + set.size()); }}A.size:1B.size:2C.size:3D.size:4答案：B因为我们重写了RectObject类的hashCode方法，只要RectObject对象的x,y属性值相等那么他的hashCode值也是相等的，所以先比较hashCode的值，r1和r2对象的x,y属性值不等，所以他们的hashCode不相同的，所以r2对象可以放进去，但是r3对象的x,y属性值和r1对象的属性值相同的，所以hashCode是相等的，这时候在比较r1和r3的equals方法，因为他么两的x,y值是相等的，所以r1,r3对象是相等的，所以r3不能放进去了，同样最后再添加一个r1也是没有没有添加进去的，所以set集合中只有一个r1和r2这两个对象</code></pre><h1 id="61-以下代码的执行结果是？"><a href="#61-以下代码的执行结果是？" class="headerlink" title="61.以下代码的执行结果是？"></a>61.以下代码的执行结果是？</h1><pre><code>class RectObject { public int x; public int y; public RectObject(int x, int y) {  this.x = x;  this.y = y; } @Override public boolean equals(Object obj) {  if (this == obj)   return true;  if (obj == null)   return false;  if (getClass() != obj.getClass())   return false;  final RectObject other = (RectObject) obj;  if (x != other.x) {   return false;  }  if (y != other.y) {   return false;  }  return true; }}public class Example { public static void main(String[] args) {  HashSet&lt;RectObject&gt; set = new HashSet&lt;RectObject&gt;();  RectObject r1 = new RectObject(3, 3);  RectObject r2 = new RectObject(5, 5);  RectObject r3 = new RectObject(3, 3);  set.add(r1);  set.add(r2);  set.add(r3);  set.add(r1);  System.out.println(&quot;size:&quot; + set.size()); }}A.size:1B.size:2C.size:3D.size:4答案：C首先判断r1对象和r2对象的hashCode，因为Object中的hashCode方法返回的是对象本地内存地址的换算结果，不同的实例对象的hashCode是不相同的，同样因为r3和r1的hashCode也是不相等的，但是r1==r1的，所以最后set集合中只有r1,r2,r3这三个对象，所以大小是3</code></pre><h1 id="62-以下代码执行结果是？"><a href="#62-以下代码执行结果是？" class="headerlink" title="62.以下代码执行结果是？"></a>62.以下代码执行结果是？</h1><pre><code>class RectObject { public int x; public int y; public RectObject(int x, int y) {  this.x = x;  this.y = y; } @Override public boolean equals(Object obj) {  return false; }}public class Example { public static void main(String[] args) {  HashSet&lt;RectObject&gt; set = new HashSet&lt;RectObject&gt;();  RectObject r1 = new RectObject(3, 3);  RectObject r2 = new RectObject(5, 5);  RectObject r3 = new RectObject(3, 3);  set.add(r1);  set.add(r2);  set.add(r3);  set.add(r1);  System.out.println(&quot;size:&quot; + set.size()); }}A.size:1B.size:2C.size:3D.size:4答案：C首先是判断hashCode是否相等，不相等的话，直接跳过，相等的话，然后再来比较这两个对象是否相等或者这两个对象的equals方法，因为是进行的或操作，所以只要有一个成立即可，那这里我们就可以解释了，其实上面的那个集合的大小是3,因为最后的一个r1没有放进去，以为r1==r1返回true的，所以没有放进去了。所以集合的大小是3，如果我们将hashCode方法设置成始终返回false的话，这个集合就是4了。</code></pre><h1 id="63-以下代码执行结果是？"><a href="#63-以下代码执行结果是？" class="headerlink" title="63.以下代码执行结果是？"></a>63.以下代码执行结果是？</h1><pre><code>class RectObject { public int x; public int y; public RectObject(int x, int y) {  this.x = x;  this.y = y; } @Override public int hashCode() {  // TODO Auto-generated method stub  return (int)System.nanoTime(); } @Override public boolean equals(Object obj) {  return false; }}public class Example { public static void main(String[] args) {  HashSet&lt;RectObject&gt; set = new HashSet&lt;RectObject&gt;();  RectObject r1 = new RectObject(3, 3);  RectObject r2 = new RectObject(5, 5);  RectObject r3 = new RectObject(3, 3);  set.add(r1);  set.add(r2);  set.add(r3);  set.add(r1);  System.out.println(&quot;size:&quot; + set.size()); }}A.size:1B.size:2C.size:3D.size:4答案：D见上题</code></pre><h1 id="64-下列关于Math类说法错误的是"><a href="#64-下列关于Math类说法错误的是" class="headerlink" title="64.下列关于Math类说法错误的是"></a>64.下列关于Math类说法错误的是</h1><pre><code>A.java.lang.Math类是final类，因此不能被其他类继承B.java.lang.Math类的构造器是私有的，即声明为private，不能实例化一个Math类的对象C.java.lang.Math类上定义的所有常量和方法均是public和static的，因此可以直接通过类名调用D.min()和max()方法的参数之一，如果是NaN值，则方法将返回另一个参数值答案：Dmin()和max()方法的参数之一，如果是NaN值，则方法的返回值就为NaN</code></pre><h1 id="65-以下哪个方法是Math类中定义的？"><a href="#65-以下哪个方法是Math类中定义的？" class="headerlink" title="65.以下哪个方法是Math类中定义的？"></a>65.以下哪个方法是Math类中定义的？</h1><pre><code>A.absolute()B.log()C.cosine()D.sine()答案：B在Math类中对应的正确方法应为abs()\cos()\sin()</code></pre><h1 id="66-定义在Math类上的round-double-d-方法的返回值类型是什么？"><a href="#66-定义在Math类上的round-double-d-方法的返回值类型是什么？" class="headerlink" title="66.定义在Math类上的round(double d)方法的返回值类型是什么？"></a>66.定义在Math类上的round(double d)方法的返回值类型是什么？</h1><pre><code>A.charB.intC.longD.double答案：Cround方法用于获取一个四舍五入的整数</code></pre><h1 id="67-以下哪个方法用于计算平方根？"><a href="#67-以下哪个方法用于计算平方根？" class="headerlink" title="67.以下哪个方法用于计算平方根？"></a>67.以下哪个方法用于计算平方根？</h1><pre><code>A.squareRoot()B.sqrt()C.root()D.sqr()答案：B</code></pre><h1 id="68-调用Math-random-方法最有可能输出以下哪些结果？"><a href="#68-调用Math-random-方法最有可能输出以下哪些结果？" class="headerlink" title="68.调用Math.random()方法最有可能输出以下哪些结果？"></a>68.调用Math.random()方法最有可能输出以下哪些结果？</h1><pre><code>A.-0.12和0.56E3B.0.12和1.1E1C.-23.45和0.0D.0.356和0.03答案：Drandom()方法返回值的取值范围在0.0..1.0之间</code></pre><h1 id="69-以下代码的输出结果是什么？"><a href="#69-以下代码的输出结果是什么？" class="headerlink" title="69.以下代码的输出结果是什么？"></a>69.以下代码的输出结果是什么？</h1><pre><code>public class Example { public static void main(String[] args) {  System.out.println(Math.round(Float.MAX_VALUE)); }}A.输出Integer.MAX_VALUEB.输出一个最接近Float.MAX_VALUE的整数C.编译失败D.运行时输出异常信息答案：AMath.round(Float.MAX_VALUE)的返回值为Integer.MAX_VALUE，Math.round(Double.MAX_VALUE)的返回值为Long.MAX_VALUE（真实计算结果超过返回值范围）</code></pre><h1 id="70-以下代码的运行结果是什么？"><a href="#70-以下代码的运行结果是什么？" class="headerlink" title="70.以下代码的运行结果是什么？"></a>70.以下代码的运行结果是什么？</h1><pre><code>public class Example { public static void main(String[] args) {  System.out.println(Math.min(0.0, -0.0)); }}A.代码编译失败B.输出0.0C.输出-0.0D.代码编译成功，但运行时输出异常信息答案：C浮点数的取值范围内存在正负0.0</code></pre><h1 id="71-以下代码的执行结果是？"><a href="#71-以下代码的执行结果是？" class="headerlink" title="71.以下代码的执行结果是？"></a>71.以下代码的执行结果是？</h1><pre><code>public class Example { public static void main(String[] args) {  System.out.println(Math.min(0.0, -0.0)); }}A.输出4B.输出5C.输出6 D.输出9答案：D比2.3大的最接近整数是3，因此ceil(2.3f)=3.0，因为2.7的四舍五入的值为3.0，所以round(2.7)=3.0，最终打印输出等于9</code></pre><h1 id="72-以下代码的运行结果是什么？"><a href="#72-以下代码的运行结果是什么？" class="headerlink" title="72.以下代码的运行结果是什么？"></a>72.以下代码的运行结果是什么？</h1><pre><code>public class Example { public static void main(String[] args) {  double d1 = -0.5;  System.out.println(&quot;Ceil d1=&quot; + Math.ceil(d1));  System.out.println(&quot;Floor d1=&quot; + Math.floor(d1)); }}A.输出Ceil d1=-0.0 Floor d1=-1.0B.输出Ceil d1=0.0 Floor d1=-1.0C.输出Ceil d1=-0.0 Floor d1=-0.0D.输出Ceil d1=0.0 Floor d1=0.0答案：A</code></pre><h1 id="73-给出以下代码，为了结果输出-12-0，方法method-d-应为以下哪个方法？"><a href="#73-给出以下代码，为了结果输出-12-0，方法method-d-应为以下哪个方法？" class="headerlink" title="73.给出以下代码，为了结果输出-12.0，方法method(d)应为以下哪个方法？"></a>73.给出以下代码，为了结果输出-12.0，方法method(d)应为以下哪个方法？</h1><pre><code>public class Example { public static void main(String[] args) {  double d = -11.1;  double d1 = method(d);  System.out.println(d1); }}A.floor()B.ceil()C.round()D.abs()答案：A</code></pre><h1 id="74-给出以下代码，请问在程序的第6行插入那条语句，改程序可依次打印输出11、10、9？"><a href="#74-给出以下代码，请问在程序的第6行插入那条语句，改程序可依次打印输出11、10、9？" class="headerlink" title="74.给出以下代码，请问在程序的第6行插入那条语句，改程序可依次打印输出11、10、9？"></a>74.给出以下代码，请问在程序的第6行插入那条语句，改程序可依次打印输出11、10、9？</h1><pre><code>1.public class Example {2. public static void main(String[] args) {3.  double x[] = { 10.2, 9.1, 8.7 };4.  int i[] = new int[3];5.  for (int a = 0; a &lt; x.length; a++) {6.7.   System.out.println(i[a]);8.  }9. }10.}A.i[1] = ((int)Math.min(x[a]));B.i[1] = ((int)Math.max(x[a]));C.i[1] = ((int)Math.ceil(x[a]));D.i[1] = ((int)Math.floor(x[a]));答案：C</code></pre><h1 id="75-以下代码执行结果是？"><a href="#75-以下代码执行结果是？" class="headerlink" title="75.以下代码执行结果是？"></a>75.以下代码执行结果是？</h1><pre><code>public class Example { public static void main(String[] args) {  System.out.println(Math.min(Float.NaN, Float.POSITIVE_INFINITY)); }}A.输出NaNB.打印输出InfinityC.运行时异常，因为NaN不是有效的参数D.运行时异常，因为Infinity不是有效的参数答案：Amin()和max()方法的参数之一，如果是NaN值，则方法的返回值就为NaN</code></pre><h1 id="76-以下代码的执行结果是？"><a href="#76-以下代码的执行结果是？" class="headerlink" title="76.以下代码的执行结果是？"></a>76.以下代码的执行结果是？</h1><pre><code>public class Example{  public static void main(String s[]){   String str=”123”;String str_=new String(“123”);String  _str=”123”;   System.out.println(str==_str);System.out.println(str==str_);} }A.输出true trueB.输出false falseC.输出true falseD.输出false true答案：C字符串创建的时候可以使用常量池</code></pre><h1 id="77-public-class-Example"><a href="#77-public-class-Example" class="headerlink" title="77.public class Example {"></a>77.public class Example {</h1><pre><code> public static void main(String[] args) {  Integer i = 100;  Integer j = 100;  System.out.println(i == j);  i = 300;  j = 300;  System.out.println(i == j); }}A.输出true trueB.输出false falseC.输出true falseD.输出false true答案：C128以内的数进行自动包装时使用池操作</code></pre><h1 id="78-以下哪个不是基本类型的包装类？"><a href="#78-以下哪个不是基本类型的包装类？" class="headerlink" title="78.以下哪个不是基本类型的包装类？"></a>78.以下哪个不是基本类型的包装类？</h1><pre><code>A.CharB.IntegerC.BooleanD.float答案：A</code></pre><h1 id="79-以下说法正确的是？"><a href="#79-以下说法正确的是？" class="headerlink" title="79.以下说法正确的是？"></a>79.以下说法正确的是？</h1><pre><code>A.Void类是Class类的子类B.Float类是Double类的子类C.Double类是Wrapper类的子类D.Integer类是Number类的子类答案：D</code></pre><h1 id="80-定义在Integer类上的哪些方法用于将一个Integer对象转换为一个基本数据int类型？"><a href="#80-定义在Integer类上的哪些方法用于将一个Integer对象转换为一个基本数据int类型？" class="headerlink" title="80.定义在Integer类上的哪些方法用于将一个Integer对象转换为一个基本数据int类型？"></a>80.定义在Integer类上的哪些方法用于将一个Integer对象转换为一个基本数据int类型？</h1><pre><code>A.valueOf（）B.intValue（）C.getInt（）D.getInteger（）答案：B</code></pre><h1 id="81-一下代码的执行结果是什么？"><a href="#81-一下代码的执行结果是什么？" class="headerlink" title="81.一下代码的执行结果是什么？"></a>81.一下代码的执行结果是什么？</h1><pre><code>public class Example { public static void main(String[] args) {  String val = null;  int x = Integer.parseInt(val);  System.out.println(x); }}A.输出0B.输出nullC.输出NumberFormatException异常D.无内容输出答案：C</code></pre><h1 id="82-由于Java中存在字符串对象池，因此采用下面方法创建的两个字符串变量，他们指向的是同一个字符串对象：String-str1-”asddsg”-String-str2-”asddsg”"><a href="#82-由于Java中存在字符串对象池，因此采用下面方法创建的两个字符串变量，他们指向的是同一个字符串对象：String-str1-”asddsg”-String-str2-”asddsg”" class="headerlink" title="82.由于Java中存在字符串对象池，因此采用下面方法创建的两个字符串变量，他们指向的是同一个字符串对象：String str1=”asddsg”;String str2=”asddsg”"></a>82.由于Java中存在字符串对象池，因此采用下面方法创建的两个字符串变量，他们指向的是同一个字符串对象：String str1=”asddsg”;String str2=”asddsg”</h1><pre><code>A.调用字符串上定义的改变字符串内容的方法，返回值都是一个新字符串，而原有字符串内容不变B.调用replace（char oldChar,char newChar）方法时，当参数oldChar和newChar一致时，返回一个和源对象内容一致的新字符串C.String的equals方法用于判定两个字符串内容是否一致D.调用toUpperCase()和toLowerCase()方法，当为进行大小写转换时，返回源字符串对象答案：B调用replace（char oldChar,char newChar）方法时，当参数oldChar和newChar一致时，返回源字符串对象</code></pre><h1 id="83-以下说法错误的是？"><a href="#83-以下说法错误的是？" class="headerlink" title="83.以下说法错误的是？"></a>83.以下说法错误的是？</h1><pre><code>A.String中的append方法用于在源字符串后追加内容B.StringBuffer中的append方法用于在源字符串后追加内容C.StringBuffer是一个缓冲区，器内容可变D.String中的concat方法用于字符串串联答案：AString中没有append方法</code></pre><h1 id="84-以下哪些有关通过子类来扩展String类功能的描述是正确的？"><a href="#84-以下哪些有关通过子类来扩展String类功能的描述是正确的？" class="headerlink" title="84.以下哪些有关通过子类来扩展String类功能的描述是正确的？"></a>84.以下哪些有关通过子类来扩展String类功能的描述是正确的？</h1><pre><code>A.无法子类化，因为String类是一个final类B.可以子类化，通过覆盖String类中的方法实现功能扩展C.无法子类化，因为String类是一个抽象类D.可以子类化，但是只能覆盖Object类中声明的方法，因为String类中定义的其他方法否是final的答案：A</code></pre><h1 id="85-嗲用以下哪个方法会导致字符串被改变？"><a href="#85-嗲用以下哪个方法会导致字符串被改变？" class="headerlink" title="85.嗲用以下哪个方法会导致字符串被改变？"></a>85.嗲用以下哪个方法会导致字符串被改变？</h1><pre><code>A.concat()B.toUpperCase()C.replace()D.没有改变字符串的方法可以调用答案：D</code></pre><h1 id="86-如何获取一个String类实例S包含的字符个数？"><a href="#86-如何获取一个String类实例S包含的字符个数？" class="headerlink" title="86.如何获取一个String类实例S包含的字符个数？"></a>86.如何获取一个String类实例S包含的字符个数？</h1><pre><code>A.s.sizeB.s.lengthC.s.size()D.s.length()答案：D</code></pre><h1 id="87-以下代码执行结果是？"><a href="#87-以下代码执行结果是？" class="headerlink" title="87.以下代码执行结果是？"></a>87.以下代码执行结果是？</h1><pre><code>public class Example { public static void main(String[] args) {  System.out.println(&quot;string&quot;.endsWith(&quot;&quot;)); }}A.输出trueB.输出falseC.编译失败D.运行时输出异常信息答案：A</code></pre><h1 id="88-有String-s-“Metallica”-请问以下哪个语句可以打印输出ica？"><a href="#88-有String-s-“Metallica”-请问以下哪个语句可以打印输出ica？" class="headerlink" title="88.有String s = “Metallica”;请问以下哪个语句可以打印输出ica？"></a>88.有String s = “Metallica”;请问以下哪个语句可以打印输出ica？</h1><pre><code>A.System.out.println(s.substring(7));B.System.out.println(s.substring(6));C.System.out.println(s.substring(6，8));D.System.out.println(s.substring(7，9));答案：B</code></pre><h1 id="89-以下那些关于String类的描述是正确的？"><a href="#89-以下那些关于String类的描述是正确的？" class="headerlink" title="89.以下那些关于String类的描述是正确的？"></a>89.以下那些关于String类的描述是正确的？</h1><pre><code>A.该类是一个final类B.该类是一个public类C.该类可以序列化D.该类有一个一StringBuffer实例作为参数的构造器答案：A、B、C、D</code></pre><h1 id="90-以下哪些是String类中定义的方法？"><a href="#90-以下哪些是String类中定义的方法？" class="headerlink" title="90.以下哪些是String类中定义的方法？"></a>90.以下哪些是String类中定义的方法？</h1><pre><code>A.length（）B.toUpper()C.toString()D.equals()答案：A、C、D</code></pre><h1 id="91-以下哪些关于封装类的描述是正确的？"><a href="#91-以下哪些关于封装类的描述是正确的？" class="headerlink" title="91.以下哪些关于封装类的描述是正确的？"></a>91.以下哪些关于封装类的描述是正确的？</h1><pre><code>A.封装类都是public类B.封装类均可序列化C.封装类均是final类D.封装类都是java.lang.Number类的子类答案：A、B、C</code></pre><h1 id="92-请问以下哪些方法是定义在Object类上的，请选择所有正确答案"><a href="#92-请问以下哪些方法是定义在Object类上的，请选择所有正确答案" class="headerlink" title="92.请问以下哪些方法是定义在Object类上的，请选择所有正确答案"></a>92.请问以下哪些方法是定义在Object类上的，请选择所有正确答案</h1><pre><code>A.toString()B.equals(Object o)C.println()D.wait()答案：A、B、D</code></pre><h1 id="93-请问以下哪些描述是正确的？请选择所有正确答案"><a href="#93-请问以下哪些描述是正确的？请选择所有正确答案" class="headerlink" title="93.请问以下哪些描述是正确的？请选择所有正确答案"></a>93.请问以下哪些描述是正确的？请选择所有正确答案</h1><pre><code>A.Class类是Object类的超类B.Object类是一个final类C.Class类可用于装载其他类D.ClassLoader类可用于装载其他类答案：C、D</code></pre><h1 id="94-给出以下代码，请问以下哪些定义在Math类上的方法可以使表达式结果为true"><a href="#94-给出以下代码，请问以下哪些定义在Math类上的方法可以使表达式结果为true" class="headerlink" title="94.给出以下代码，请问以下哪些定义在Math类上的方法可以使表达式结果为true?"></a>94.给出以下代码，请问以下哪些定义在Math类上的方法可以使表达式结果为true?</h1><pre><code>Method(-4.4) == -4A.round()B.trunc()C.floor()D.ceil()答案：A、D</code></pre><h1 id="95-下面这条语句一共创建了多少个对象：String-s-”a”-”b”-”c”-”d”"><a href="#95-下面这条语句一共创建了多少个对象：String-s-”a”-”b”-”c”-”d”" class="headerlink" title="95.下面这条语句一共创建了多少个对象：String s=”a”+”b”+”c”+”d”;"></a>95.下面这条语句一共创建了多少个对象：String s=”a”+”b”+”c”+”d”;</h1><pre><code>一个字符串对象和一个指向这个对象的引用对于如下代码：Strings1 = &quot;a&quot;;Strings2 = s1 + &quot;b&quot;;Strings3 = &quot;a&quot; + &quot;b&quot;;System.out.println(s2== &quot;ab&quot;);System.out.println(s3== &quot;ab&quot;);答案：第一条语句打印的结果为false，第二条语句打印的结果为true，这说明javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串，所以，上面的代码应该只创建了一个String对象和一个指向该对象的饮用。写如下两行代码，               String s = &quot;a&quot; +&quot;b&quot; + &quot;c&quot; + &quot;d&quot;;               System.out.println(s ==&quot;abcd&quot;);  最终打印的结果应该为true。</code></pre><h1 id="96-以下代码的执行结果是？"><a href="#96-以下代码的执行结果是？" class="headerlink" title="96.以下代码的执行结果是？"></a>96.以下代码的执行结果是？</h1><pre><code>class ShadowClone implements Cloneable { private int a; private int[] b; @Override public Object clone() {  ShadowClone sc = null;  try {   sc = (ShadowClone) super.clone();  } catch (CloneNotSupportedException e) {   e.printStackTrace();  }  return sc; } public int getA() {  return a; } public void setA(int a) {  this.a = a; } public int[] getB() {  return b; } public void setB(int[] b) {  this.b = b; }}public class Example { public static void main(String[] args) {  ShadowClone c1 = new ShadowClone();  c1.setA(100);  c1.setB(new int[] { 1000 });  System.out.println(&quot;克隆前c1:  a=&quot; + c1.getA() + &quot; b[0]=&quot; + c1.getB()[0]);  ShadowClone c2 = (ShadowClone) c1.clone();  c2.setA(50);  int[] a = c2.getB();  a[0] = 5;  c2.setB(a);  System.out.println(&quot;克隆后c1:  a=&quot; + c1.getA() + &quot; b[0]=&quot; + c1.getB()[0]);  System.out.println(&quot;克隆后c2:  a=&quot; + c2.getA() + &quot; b[0]=&quot; + c2.getB()[0]); }}答案：克隆前c1:  a=100 b[0]=1000克隆后c1:  a=100 b[0]=5克隆后c2:  a=50 b[0]=5Java中Object类提供的克隆方法默认为浅克隆，因此克隆后的引用属性和原始对象中的引用属性引用了同一对象，对克隆对象中引用数据的变更就直接反映到原始对象中</code></pre><h1 id="97-以下代码的执行结果是？"><a href="#97-以下代码的执行结果是？" class="headerlink" title="97.以下代码的执行结果是？"></a>97.以下代码的执行结果是？</h1><pre><code>class DeepClone implements Cloneable { private int a; private int[] b; @Override public Object clone() {  DeepClone sc = null;  try {   sc = (DeepClone) super.clone();   int[] t = sc.getB();   int[] b1 = new int[t.length];   for (int i = 0; i &lt; b1.length; i++) {    b1[i] = t[i];   }   sc.setB(b1);  } catch (CloneNotSupportedException e) {   e.printStackTrace();  }  return sc; } public int getA() {  return a; } public void setA(int a) {  this.a = a; } public int[] getB() {  return b; } public void setB(int[] b) {  this.b = b; }}public class Example { public static void main(String[] args) {  DeepClone c1 = new DeepClone();  c1.setA(100);  c1.setB(new int[] { 1000 });  System.out.println(&quot;克隆前c1:  a=&quot; + c1.getA() + &quot; b[0]=&quot; + c1.getB()[0]);  DeepClone c2 = (DeepClone) c1.clone();  c2.setA(50);  int[] a = c2.getB();  a[0] = 5;  c2.setB(a);  System.out.println(&quot;克隆后c1:  a=&quot; + c1.getA() + &quot; b[0]=&quot; + c1.getB()[0]);  System.out.println(&quot;克隆后c2:  a=&quot; + c2.getA() + &quot; b[0]=&quot; + c2.getB()[0]); }}答案：克隆前c1:  a=100 b[0]=1000克隆后c1:  a=100 b[0]=1000克隆后c2:  a=50 b[0]=5自定义的深度克隆</code></pre><h1 id="98-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对"><a href="#98-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对" class="headerlink" title="98.两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对"></a>98.两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对</h1><pre><code>答案：不对，有相同的hash code</code></pre><h1 id="99-覆盖equals-方法时需要注意的设计原则有哪些？"><a href="#99-覆盖equals-方法时需要注意的设计原则有哪些？" class="headerlink" title="99.覆盖equals()方法时需要注意的设计原则有哪些？"></a>99.覆盖equals()方法时需要注意的设计原则有哪些？</h1><pre><code>答案：对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。反射性：x.equals(x)必须返回是“true”。类推性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。 </code></pre><h1 id="100-equals方法和-的区别"><a href="#100-equals方法和-的区别" class="headerlink" title="100.equals方法和==的区别"></a>100.equals方法和==的区别</h1><pre><code>答案：1.基本数据类型，也称原始数据类型。byte,short,char,int,long,float,double,boolean  他们之间的比较，应用双等号（==）,比较的是他们的值。2.复合数据类型(类)  当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地 址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。  对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（==）进行比较的，所以比较后的结果跟双等号（==）的结果相同。 </code></pre><h1 id="101-String、StringBuffer、StringBuilder有什么区别？"><a href="#101-String、StringBuffer、StringBuilder有什么区别？" class="headerlink" title="101.String、StringBuffer、StringBuilder有什么区别？"></a>101.String、StringBuffer、StringBuilder有什么区别？</h1><pre><code>答案：String类表示内容不可改变的字符串。而StringBuffer类表示内容可以被修改的字符串。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。另外，String实现了equals方法，new String(“abc”).equals(new String(“abc”)的结果为true,而StringBuffer没有实现equals方法，所以，new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为false。StringBuffer和StringBuilder类都表示内容可以被修改的字符串，StringBuilder是线程不安全的，运行效率高，如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用StringBuilder。如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用StringBuffer。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-以下哪个是finalize-方法的正确形式？&quot;&gt;&lt;a href=&quot;#1-以下哪个是finalize-方法的正确形式？&quot; class=&quot;headerlink&quot; title=&quot;1.以下哪个是finalize()方法的正确形式？&quot;&gt;&lt;/a&gt;1.以下哪个是finali
      
    
    </summary>
    
    
      <category term="java" scheme="http://iwantjingjing.com/categories/java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="面试" scheme="http://iwantjingjing.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql优化</title>
    <link href="http://iwantjingjing.com/2020/04/16/mysql%E4%BC%98%E5%8C%96/"/>
    <id>http://iwantjingjing.com/2020/04/16/mysql优化/</id>
    <published>2020-04-16T10:22:32.000Z</published>
    <updated>2020-04-16T10:27:54.017Z</updated>
    
    <content type="html"><![CDATA[<p>所谓超级读书法就是，读一段不会则停下来把之前的内容再读一遍，以此类推<br>                                                            ——费曼<br>孔子曰：温故而知新可以为师已<br>不知谁说的： 读书百遍，其义自见</p><p>mysql优化</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="两个瓶颈"><a href="#两个瓶颈" class="headerlink" title="两个瓶颈"></a>两个瓶颈</h2><pre><code>CPU    CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候。I/O    磁盘I/O瓶颈发生在装入数据远大于内存容量的时候    应用分布在网络上，那么查询量相当大的时候那么平瓶颈就会出现在网络上。</code></pre><h2 id="如何查看系统性能"><a href="#如何查看系统性能" class="headerlink" title="如何查看系统性能"></a>如何查看系统性能</h2><pre><code>mpstatiostatsarvmstat</code></pre><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><pre><code>1 什么是索引    加速查询最好的方法就是索引。    类似于图书的目录2.索引类型     普通索引            是最基本的索引，它没有任何限制。     唯一索引            与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。     组合索引            指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。     主键索引            是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引     全文索引            主要用来查找文本中的关键字，而不是直接与索引中的值相比较            它更像是一个搜索引擎            fulltext索引配合match against操作使用            可以在create table，alter table ，create index使用            目前只有char、varchar，text 列上可以创建全文索引            先插入数据再建索引比建表时先建索引再插入数据效率高3.索引优化    1 只要列中含有NULL值，就最好不要在此例设置索引，复合索引如果有NULL值，此列在使用时也不会使用索引     2 尽量使用短索引，如果可以，应该制定一个前缀长度     3 对于经常在where子句使用的列，最好设置索引，这样会加快查找速度     4 对于有多个列where或者order by子句的，应该建立复合索引     5 对于like语句，以%或者‘-’开头的不会使用索引，以%结尾会使用索引     6 尽量不要在列上进行运算（函数操作和表达式操作）     7 尽量不要使用not in和&lt;&gt;操作</code></pre><h2 id="SQL慢查询的优化"><a href="#SQL慢查询的优化" class="headerlink" title="SQL慢查询的优化"></a>SQL慢查询的优化</h2><pre><code>1.如何捕获低效sql    1）slow_query_log            这个参数设置为ON，可以捕获执行时间超过一定数值的SQL语句。    2）ong_query_time            当SQL语句执行时间超过此数值时，就会被记录到日志中，建议设置为1或者更短。    3）slow_query_log_file            记录日志的文件名。    4）log_queries_not_using_indexes            这个参数设置为ON，可以捕获到所有未使用索引的SQL语句，尽管这个SQL语句有可能执行得挺快。2.慢查询优化的基本步骤    1)先运行看看是否真的很慢，注意设置SQL_NO_CACHE    2）where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高    3)explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）    4)order by limit 形式的sql语句让排序的表优先查    5)了解业务方使用场景    6)加索引时参照建索引的几大原则    7)观察结果，不符合预期继续从1开始分析2.优化原则     1查询时，能不要*就不用*，尽量写全字段名     2 大部分情况连接效率远大于子查询     3 多使用explain和profile分析查询语句     4 查看慢查询日志，找出执行时间长的sql语句优化     5 多表连接时，尽量小表驱动大表，即小表 join 大表    6  在千万级分页时使用limit    7  对于经常使用的查询，可以开启缓存</code></pre><h2 id="数据库表优化"><a href="#数据库表优化" class="headerlink" title="数据库表优化"></a>数据库表优化</h2><pre><code>1 表的字段尽可能用NOT NULL2 字段长度固定的表查询会更快3 把数据库的大表按时间或一些标志分成小表4 将表拆分    水平切分:将记录散列到不同的表中，各表的结构完全相同，每次从分表中查询, 提高效率。    垂直切分:将表中大字段单独拆分到另外一张表, 形成一对一的关系。</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><pre><code>索引的优化  sql语句的优化  表的优化  在高并发网络环境下，除了优化数据库外，还会涉及到分布式缓存，CDN，数据库读写分离等高并发优化技术mysql优化18条  1 只要列中含有NULL值，就最好不要在此例设置索引，复合索引如果有NULL值，此列在使用时也不会使用索引   2 尽量使用短索引，如果可以，应该制定一个前缀长度   3 对于经常在where子句使用的列，最好设置索引，这样会加快查找速度   4 对于有多个列where或者order by子句的，应该建立复合索引   5 对于like语句，以%或者‘-’开头的不会使用索引，以%结尾会使用索引   6 尽量不要在列上进行运算（函数操作和表达式操作）   7 尽量不要使用not in和&lt;&gt;操作   1查询时，能不要*就不用*，尽量写全字段名   2 大部分情况连接效率远大于子查询   3 多使用explain和profile分析查询语句   4 查看慢查询日志，找出执行时间长的sql语句优化   5 多表连接时，尽量小表驱动大表，即小表 join 大表  6  在千万级分页时使用limit  7  对于经常使用的查询，可以开启缓存  1 表的字段尽可能用NOT NULL  2 字段长度固定的表查询会更快  3 把数据库的大表按时间或一些标志分成小表  4 将表拆分    水平切分:将记录散列到不同的表中，各表的结构完全相同，每次从分表中查询, 提高效率。    垂直切分:将表中大字段单独拆分到另外一张表, 形成一对一的关系。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所谓超级读书法就是，读一段不会则停下来把之前的内容再读一遍，以此类推&lt;br&gt;                                                            ——费曼&lt;br&gt;孔子曰：温故而知新可以为师已&lt;br&gt;不知谁说的： 读书百遍，其
      
    
    </summary>
    
    
      <category term="面试" scheme="http://iwantjingjing.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试，mysql" scheme="http://iwantjingjing.com/tags/%E9%9D%A2%E8%AF%95%EF%BC%8Cmysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql面试题</title>
    <link href="http://iwantjingjing.com/2020/04/16/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://iwantjingjing.com/2020/04/16/mysql面试题/</id>
    <published>2020-04-16T10:13:26.000Z</published>
    <updated>2020-04-19T09:33:56.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL的复制原理以及流程"><a href="#MySQL的复制原理以及流程" class="headerlink" title="MySQL的复制原理以及流程"></a>MySQL的复制原理以及流程</h1><pre><code>基本原理流程，3个线程以及之间的关联；  主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；  从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；  从：sql执行线程——执行relay log中的语句；</code></pre><h1 id="MySQL中myisam与innodb的区别，至少5点"><a href="#MySQL中myisam与innodb的区别，至少5点" class="headerlink" title="MySQL中myisam与innodb的区别，至少5点"></a>MySQL中myisam与innodb的区别，至少5点</h1><pre><code>5点不同  1&gt;.InnoDB支持事物，而MyISAM不支持事物  2&gt;.InnoDB支持行级锁，而MyISAM支持表级锁  3&gt;.InnoDB支持MVCC, 而MyISAM不支持      MVCC是版本控制？  4&gt;.InnoDB支持外键，而MyISAM不支持  5&gt;.InnoDB不支持全文索引，而MyISAM支持。 innodb引擎的4大特性  插入缓冲（insert buffer)  二次写(double write)  自适应哈希索引(ahi)  预读(read ahead)2者selectcount(*)哪个更快，为什么  myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</code></pre><h1 id="MySQL中varchar与char的区别以及varchar-50-中的50代表的涵义"><a href="#MySQL中varchar与char的区别以及varchar-50-中的50代表的涵义" class="headerlink" title="MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义"></a>MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义</h1><pre><code>(1)、varchar与char的区别  char是一种固定长度的类型  varchar则是一种可变长度的类型(2)、varchar(50)中50的涵义  最多存放50个字符  varchar(50)和(200)存储hello所占空间一样  但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)(3)、int（20）中20的涵义  是指显示字符的长度  要加参数的，最大为255  比如它是记录行数的id,插入10笔资料，它就显示00000000001 ~~~00000000010，当字符的位数超过11,它也只显示11位，如果你没有加那个让它未满11位就前面加0的参数，它不会在前面加0  20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；(4)、mysql为什么这么设计  对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；</code></pre><h1 id="问了innodb的事务与日志的实现方式"><a href="#问了innodb的事务与日志的实现方式" class="headerlink" title="问了innodb的事务与日志的实现方式"></a>问了innodb的事务与日志的实现方式</h1><pre><code>(1)、有多少种日志；  错误日志：记录出错信息，也记录一些警告信息或者正确的信息。  查询日志：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。  慢查询日志：设置一个阈(yu)值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。  二进制日志：记录对数据库执行更改的所有操作。  中继日志：中继日志也是二进制日志，用来给slave 库恢复  事务日志：重做日志redo和回滚日志undo(2)、事物的4种隔离级别  读未提交(RU)        read uncommited ：读到未提交数据  读已提交(RC)        read committed：脏读，不可重复读  可重复读(RR)        repeatable read：可重读  串行        serializable ：串行事物(3)、事务是如何通过日志来实现的，说得越深入越好。  事务日志是通过redo和innodb的存储引擎日志缓冲（Innodb log buffer）来实现的  当开始一个事务的时候，会记录该事务的lsn(log sequence number)号;  当事务执行时，会往InnoDB存储引擎的日志的日志缓存里面插入事务日志；  当事务提交时，必须将存储引擎的日志缓冲写入磁盘（通过innodb_flush_log_at_trx_commit来控制），也就是写数据前，需要先写日志。这种方式称为“预写日志方式”</code></pre><h1 id="MySQL-binlog的几种日志录入格式以及区别"><a href="#MySQL-binlog的几种日志录入格式以及区别" class="headerlink" title="MySQL binlog的几种日志录入格式以及区别"></a>MySQL binlog的几种日志录入格式以及区别</h1><pre><code>Statement：每一条会修改数据的sql都会记录在binlog中。  优点      不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。  缺点      由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的 一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同 的结果。      使用以下函数的语句也有问题：              sleep()函数              last_insert_id()              user-defined functions(udf)              LOAD_FILE()              UUID()              USER()              FOUND_ROWS()              SYSDATE() (除非启动时启用了 --sysdate-is-now 选项)      同时在INSERT …SELECT 会产生比 RBR 更多的行级锁Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改。  优点      binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了      rowlevel的日志内容会非常清楚的记录下 每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题  缺点      可能会产生大量的日志内容Mixedlevel: 是以上两种level的混合使用  一般的语句修改使用statment格式保存binlog  一些函数，statement无法完成主从复制的操作，则 采用row格式保存binlog</code></pre><h1 id="MySQL数据库cpu飙升到500-的话他怎么处理？"><a href="#MySQL数据库cpu飙升到500-的话他怎么处理？" class="headerlink" title="MySQL数据库cpu飙升到500%的话他怎么处理？"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h1><pre><code>1、列出所有进程 show processlist,观察所有进程 ,多秒没有状态变化的(干掉)2、查看超时日志或者错误日志 (做了几年开发,一般会是查询以及大批量的插入会导致cpu与i/o上涨,当然不排除网络状态突然断了,导致一个请求服务器只接受到一半，比如where子句或分页子句没有发送,,当然的一次被坑经历)</code></pre><h1 id="sql优化各种方法"><a href="#sql优化各种方法" class="headerlink" title="sql优化各种方法"></a>sql优化各种方法</h1><pre><code>(1)、explain出来的各种item的意义；  select_type      表示查询中每个select子句的类型  type      表示MySQL在表中找到所需行的方式，又称“访问类型”  possible_keys      指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用  key      显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL  key_len      表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度  ref      表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值  Extra      包含不适合在其他列中显示但十分重要的额外信息(2)、profile的意义以及使用场景；  查询到 SQL 会执行多少时间, 并看出 CPU/Memory 使用量, 执行过程中 Systemlock, Table lock 花多少时间等等</code></pre><h1 id="备份计划，mysqldump以及xtranbackup的实现原理"><a href="#备份计划，mysqldump以及xtranbackup的实现原理" class="headerlink" title="备份计划，mysqldump以及xtranbackup的实现原理"></a>备份计划，mysqldump以及xtranbackup的实现原理</h1><pre><code>(1)、备份计划；  这里每个公司都不一样，您别说那种1小时1全备什么的就行(2)、备份恢复时间；  这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考      20G的2分钟（mysqldump）      80G的30分钟(mysqldump)      111G的30分钟（mysqldump)      288G的3小时（xtra)      3T的4小时（xtra)      逻辑导入时间一般是备份时间的5倍以上(3)、xtrabackup实现原理  在InnoDB内部会维护一个redo日志文件，我们也可以叫做事务日志文件  事务日志会存储每一个InnoDB表数据的记录修改。  当InnoDB启动时，InnoDB会检查数据文件和事务日志，并执行两个步骤：它应用（前滚）已经提交的事务日志到数据文件，并将修改过但没有提交的数据进行回滚操作。</code></pre><h1 id="500台db，在最快时间之内重启"><a href="#500台db，在最快时间之内重启" class="headerlink" title="500台db，在最快时间之内重启"></a>500台db，在最快时间之内重启</h1><pre><code>使用批量 ssh 工具 pssh 来对需要重启的机器执行重启命令。 也可以使用 salt（前提是客户端有安装 salt）或者 ansible（ ansible 只需要 ssh 免登通了就行）等多线程工具同时操作多台服务器</code></pre><h1 id="innodb的读写参数优化"><a href="#innodb的读写参数优化" class="headerlink" title="innodb的读写参数优化"></a>innodb的读写参数优化</h1><pre><code>(1)、读取参数  global buffer pool以及 local buffer；(2)、写入参数；  innodb_flush_log_at_trx_commit  innodb_buffer_pool_size(3)、与IO相关的参数；  innodb_write_io_threads = 8  innodb_read_io_threads = 8  innodb_thread_concurrency = 0(4)、缓存参数以及缓存的适用场景。  query cache/query_cache_type  并不是所有表都适合使用query cache。造成query cache失效的原因主要是相应的table发生了变更  第一个：读操作多的话看看比例，简单来说，如果是用户清单表，或者说是数据比例比较固定，比如说商品列表，是可以打开的，前提是这些库比较集中，数据库中的实务比较小。  第二个：我们“行骗”的时候，比如说我们竞标的时候压测，把query cache打开，还是能收到qps激增的效果，当然前提示前端的连接池什么的都配置一样。大部分情况下如果写入的居多，访问量并不多，那么就不要打开，例如社交网站的，10%的人产生内容，其余的90%都在消费，打开还是效果很好的，但是你如果是qq消息，或者聊天，那就很要命。  第三个：小网站或者没有高并发的无所谓，高并发下，会看到 很多 qcache 锁 等待，所以一般高并发下，不建议打开query cache</code></pre><h1 id="你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？"><a href="#你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？" class="headerlink" title="你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？"></a>你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？</h1><pre><code>监控的工具有很多，例如zabbix，lepus，我这里用的是lepus</code></pre><h1 id="你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？"><a href="#你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？" class="headerlink" title="你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？"></a>你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？</h1><pre><code>主从一致性校验有多种工具 例如checksum、mysqldiff、pt-table-checksum等checksummysqldiffpt-table-checksum</code></pre><h1 id="你们数据库是否支持emoji表情，如果不支持，如何操作？"><a href="#你们数据库是否支持emoji表情，如果不支持，如何操作？" class="headerlink" title="你们数据库是否支持emoji表情，如果不支持，如何操作？"></a>你们数据库是否支持emoji表情，如果不支持，如何操作？</h1><pre><code>如果是utf8字符集的话，需要升级至utf8_mb4方可支持utf8_mb4</code></pre><h1 id="你是如何维护数据库的数据字典的？"><a href="#你是如何维护数据库的数据字典的？" class="headerlink" title="你是如何维护数据库的数据字典的？"></a>你是如何维护数据库的数据字典的？</h1><pre><code>一般是直接在生产库进行注释，利用工具导出成excel方便流通</code></pre><h1 id="表中有大字段X-例如：text类型-，且字段X不会经常更新，以读为为主，请问"><a href="#表中有大字段X-例如：text类型-，且字段X不会经常更新，以读为为主，请问" class="headerlink" title="表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为为主，请问"></a>表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为为主，请问</h1><pre><code>拆带来的问题：连接消耗 + 存储拆分空间不拆可能带来的问题：查询性能；如果能容忍拆分带来的空间问题,拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区) 顺序IO,减少连接消耗,最后这是一个文本列再加上一个全文索引来尽量抵消连接消耗如果能容忍不拆分带来的查询性能损失的话:上面的方案在某个极致条件下肯定会出现问题,那么不拆就是最好的选择</code></pre><h1 id="MySQL中InnoDB引擎的行锁是通过加在什么上完成-或称实现-的？为什么是这样子的？"><a href="#MySQL中InnoDB引擎的行锁是通过加在什么上完成-或称实现-的？为什么是这样子的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？"></a>MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？</h1><pre><code>InnoDB是基于索引来完成行锁例: select * from tab_with_index where id = 1 for update;for update 可以根据条件来完成行锁锁定,并且 id 是有索引键的列,如果 id 不是索引键那么InnoDB将完成表锁,,并发将无从谈起</code></pre><h1 id="开放性问题：据说是腾讯的"><a href="#开放性问题：据说是腾讯的" class="headerlink" title="开放性问题：据说是腾讯的"></a>开放性问题：据说是腾讯的</h1><pre><code>一个6亿的表a，一个3亿的表b，通过外键tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。  1、如果A表TID是自增长,并且是连续的,B表的ID为索引  select * from a,b where a.tid = b.id and a.tid&gt;500000 limit 200;  2、如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。  select * from b , (select tid from a limit 50000,200) a where b.id = a .tid;</code></pre><h1 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a>什么是存储过程？有哪些优缺点？</h1><pre><code>存储过程是一些预编译的SQL语句。1、更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。2、存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全</code></pre><h1 id="索引有哪些数据结构"><a href="#索引有哪些数据结构" class="headerlink" title="索引有哪些数据结构"></a>索引有哪些数据结构</h1><pre><code>Hash、B+去创建索引的时候，可以选择索引的类型</code></pre><h1 id="索引是什么？有什么作用以及优缺点？"><a href="#索引是什么？有什么作用以及优缺点？" class="headerlink" title="索引是什么？有什么作用以及优缺点？"></a>索引是什么？有什么作用以及优缺点？</h1><pre><code>1、索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构2、索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。MySQL数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引  1、索引加快数据库的检索速度  2、索引降低了插入、删除、修改等维护任务的速度  3、唯一索引可以确保每一行数据的唯一性  4、通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能  5、索引需要占物理和数据空间</code></pre><h1 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h1><pre><code>事务（Transaction）是并发控制的基本单位。它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。</code></pre><h1 id="使用索引查询一定能提高查询的性能吗？为什么"><a href="#使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="使用索引查询一定能提高查询的性能吗？为什么"></a>使用索引查询一定能提高查询的性能吗？为什么</h1><pre><code>通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.1、索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况:2、基于一个范围的检索,一般查询返回结果集小于表中记录数的30%3、基于非唯一性索引的检索</code></pre><h1 id="简单说一说drop、delete与truncate的区"><a href="#简单说一说drop、delete与truncate的区" class="headerlink" title="简单说一说drop、delete与truncate的区"></a>简单说一说drop、delete与truncate的区</h1><pre><code>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别1、delete和truncate只删除表的数据不删除表的结构2、速度,一般来说: drop&gt; truncate &gt;delete3、delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;如果有相应的trigger,执行的时候将被触发.4、 truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.</code></pre><h1 id="drop、delete与truncate分别在什么场景之下使用？"><a href="#drop、delete与truncate分别在什么场景之下使用？" class="headerlink" title="drop、delete与truncate分别在什么场景之下使用？"></a>drop、delete与truncate分别在什么场景之下使用？</h1><pre><code>1、不再需要一张表的时候，用drop2、想删除部分数据行时候，用delete，并且带上where子句3、保留表而删除所有数据的时候用truncate</code></pre><h1 id="超键、候选键、主键、外键分别是什么？"><a href="#超键、候选键、主键、外键分别是什么？" class="headerlink" title="超键、候选键、主键、外键分别是什么？"></a>超键、候选键、主键、外键分别是什么？</h1><pre><code>1、超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。2、候选键：是最小超键，即没有冗余元素的超键。3、主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。4、外键：在一个表中存在的另一个表的主键称此表的外键。</code></pre><h1 id="什么是视图？以及视图的使用场景有哪些？"><a href="#什么是视图？以及视图的使用场景有哪些？" class="headerlink" title="什么是视图？以及视图的使用场景有哪些？"></a>什么是视图？以及视图的使用场景有哪些？</h1><pre><code>1、视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。2、只暴露部分字段给访问者，所以就建一个虚表，就是视图。3、查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异</code></pre><h1 id="说一说三个范式。"><a href="#说一说三个范式。" class="headerlink" title="说一说三个范式。"></a>说一说三个范式。</h1><pre><code>第一范式（1NF）：属性唯一  数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。第二范式（2NF）：记录唯一  2:要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情第三范式（3NF）：表唯一  3:表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）</code></pre><h1 id="数据库的乐观锁和悲观锁是什么？"><a href="#数据库的乐观锁和悲观锁是什么？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？"></a>数据库的乐观锁和悲观锁是什么？</h1><pre><code>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</code></pre><h1 id="Mysql中有哪几种锁？"><a href="#Mysql中有哪几种锁？" class="headerlink" title="Mysql中有哪几种锁？"></a>Mysql中有哪几种锁？</h1><pre><code>1.表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。2.行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。3. 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</code></pre><h1 id="mysql有哪些引擎"><a href="#mysql有哪些引擎" class="headerlink" title="mysql有哪些引擎"></a>mysql有哪些引擎</h1><pre><code> MyISAMHeapMergeINNODBISAM</code></pre><h1 id="简述在MySQL数据库中MyISAM和InnoDB的区别"><a href="#简述在MySQL数据库中MyISAM和InnoDB的区别" class="headerlink" title="简述在MySQL数据库中MyISAM和InnoDB的区别"></a>简述在MySQL数据库中MyISAM和InnoDB的区别</h1><pre><code>MyISAM：  不支持事务，但是每次查询都是原子的；  支持表级锁，即每次操作是对整个表加锁；  存储表的总行数；  一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；  采用菲聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。InnoDb  支持ACID的事务，支持事务的四种隔离级别；  支持行级锁及外键约束：因此可以支持写并发；  不存储总行数；  一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制；  主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。</code></pre><h1 id="主键和候选键有什么区别？"><a href="#主键和候选键有什么区别？" class="headerlink" title="主键和候选键有什么区别？"></a>主键和候选键有什么区别？</h1><pre><code>表格的每一行都由主键唯一标识,一个表只有一个主键。主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</code></pre><h1 id="myisamchk是用来做什么的？"><a href="#myisamchk是用来做什么的？" class="headerlink" title="myisamchk是用来做什么的？"></a>myisamchk是用来做什么的？</h1><pre><code>它用来压缩MyISAM表，这减少了磁盘或内存使用。</code></pre><h1 id="MyISAM-Static和MyISAM-Dynamic有什么区别？"><a href="#MyISAM-Static和MyISAM-Dynamic有什么区别？" class="headerlink" title="MyISAM Static和MyISAM Dynamic有什么区别？"></a>MyISAM Static和MyISAM Dynamic有什么区别？</h1><pre><code>在MyISAM Static上的所有字段有固定宽度。动态MyISAM表将具有像TEXT，BLOB等字段，以适应不同长度的数据类型。MyISAM Static在受损情况下更容易恢复。</code></pre><h1 id="如果一个表有一列定义为TIMESTAMP，将发生什么？"><a href="#如果一个表有一列定义为TIMESTAMP，将发生什么？" class="headerlink" title="如果一个表有一列定义为TIMESTAMP，将发生什么？"></a>如果一个表有一列定义为TIMESTAMP，将发生什么？</h1><pre><code>每当行被更改时，时间戳字段将获取当前时间戳。</code></pre><h1 id="列设置为AUTO-INCREMENT时，如果在表中达到最大值，会发生什么情况？"><a href="#列设置为AUTO-INCREMENT时，如果在表中达到最大值，会发生什么情况？" class="headerlink" title="列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？"></a>列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？</h1><pre><code>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</code></pre><h1 id="怎样才能找出最后一次插入时分配了哪个自动增量？"><a href="#怎样才能找出最后一次插入时分配了哪个自动增量？" class="headerlink" title="怎样才能找出最后一次插入时分配了哪个自动增量？"></a>怎样才能找出最后一次插入时分配了哪个自动增量？</h1><pre><code>LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。</code></pre><h1 id="你怎么看到为表格定义的所有索引？"><a href="#你怎么看到为表格定义的所有索引？" class="headerlink" title="你怎么看到为表格定义的所有索引？"></a>你怎么看到为表格定义的所有索引？</h1><pre><code>SHOW INDEX FROM</code></pre><h1 id="LIKE声明中的％和-是什么意思？"><a href="#LIKE声明中的％和-是什么意思？" class="headerlink" title="LIKE声明中的％和_是什么意思？"></a>LIKE声明中的％和_是什么意思？</h1><pre><code>％对应于0个或更多字符，_只是LIKE语句中的一个字符。子主题 2</code></pre><h1 id="如何在Unix和Mysql时间戳之间进行转换？"><a href="#如何在Unix和Mysql时间戳之间进行转换？" class="headerlink" title="如何在Unix和Mysql时间戳之间进行转换？"></a>如何在Unix和Mysql时间戳之间进行转换？</h1><pre><code>UNIX_TIMESTAMP是从Mysql时间戳转换为Unix时间戳的命令FROM_UNIXTIME是从Unix时间戳转换为Mysql时间戳的命令</code></pre><h1 id="列对比运算符是什么？"><a href="#列对比运算符是什么？" class="headerlink" title="列对比运算符是什么？"></a>列对比运算符是什么？</h1><pre><code>在SELECT语句的列比较中使用=，&lt;&gt;，&lt;=，&lt;，&gt; =，&gt;，&lt;&lt;，&gt;&gt;，&lt;=&gt;，AND，OR或LIKE运算符。</code></pre><h1 id="BLOB和TEXT有什么区别？"><a href="#BLOB和TEXT有什么区别？" class="headerlink" title="BLOB和TEXT有什么区别？"></a>BLOB和TEXT有什么区别？</h1><pre><code>BLOB是一个二进制对象，可以容纳可变数量的数据。TEXT是一个不区分大小写的BLOB。BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。</code></pre><h1 id="mysql-fetch-array和mysql-fetch-object的区别是什么？"><a href="#mysql-fetch-array和mysql-fetch-object的区别是什么？" class="headerlink" title="mysql_fetch_array和mysql_fetch_object的区别是什么？"></a>mysql_fetch_array和mysql_fetch_object的区别是什么？</h1><pre><code>mysql_fetch_array（） – 将结果行作为关联数组或来自数据库的常规数组返回。mysql_fetch_object – 从数据库返回结果行作为对象。</code></pre><h1 id="MyISAM表格将在哪里存储，并且还提供其存储格式？"><a href="#MyISAM表格将在哪里存储，并且还提供其存储格式？" class="headerlink" title="MyISAM表格将在哪里存储，并且还提供其存储格式？"></a>MyISAM表格将在哪里存储，并且还提供其存储格式？</h1><pre><code>每个MyISAM表格以三种格式存储在磁盘上：·“.frm”文件存储表定义·数据文件具有“.MYD”（MYData）扩展名索引文件具有“.MYI”（MYIndex）扩展名</code></pre><h1 id="Mysql如何优化DISTINCT？"><a href="#Mysql如何优化DISTINCT？" class="headerlink" title="Mysql如何优化DISTINCT？"></a>Mysql如何优化DISTINCT？</h1><pre><code>DISTINCT在所有列上转换为GROUP BY，并与ORDER BY子句结合使用。</code></pre><h1 id="如何显示前50行？"><a href="#如何显示前50行？" class="headerlink" title="如何显示前50行？"></a>如何显示前50行？</h1><pre><code>SELECT*FROM LIMIT 0,50;</code></pre><h1 id="可以使用多少列创建索引？"><a href="#可以使用多少列创建索引？" class="headerlink" title="可以使用多少列创建索引？"></a>可以使用多少列创建索引？</h1><pre><code>任何标准表最多可以创建16个索引列。</code></pre><h1 id="NOW（）和CURRENT-DATE（）有什么区别？"><a href="#NOW（）和CURRENT-DATE（）有什么区别？" class="headerlink" title="NOW（）和CURRENT_DATE（）有什么区别？"></a>NOW（）和CURRENT_DATE（）有什么区别？</h1><pre><code>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。CURRENT_DATE（）仅显示当前年份，月份和日期。</code></pre><h1 id="什么是非标准字符串类型？"><a href="#什么是非标准字符串类型？" class="headerlink" title="什么是非标准字符串类型？"></a>什么是非标准字符串类型？</h1><pre><code>TINYTEXT TEXT MEDIUMTEXT LONGTEXT</code></pre><h1 id="什么是通用SQL函数？"><a href="#什么是通用SQL函数？" class="headerlink" title="什么是通用SQL函数？"></a>什么是通用SQL函数？</h1><pre><code>CONCAT(A, B) – 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。FORMAT(X, D)- 格式化数字X到D有效数字。CURRDATE(), CURRTIME()- 返回当前日期或时间。NOW（） – 将当前日期和时间作为一个值返回。MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） – 从日期值中提取给定数据。HOUR（），MINUTE（），SECOND（） – 从时间值中提取给定数据。DATEDIFF（A，B） – 确定两个日期之间的差异，通常用于计算年龄SUBTIMES（A，B） – 确定两次之间的差异。FROMDAYS（INT） – 将整数天数转换为日期值。</code></pre><h1 id="MYSQL支持事务吗？"><a href="#MYSQL支持事务吗？" class="headerlink" title="MYSQL支持事务吗？"></a>MYSQL支持事务吗？</h1><pre><code>在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，你的MYSQL就可以使用事务处理,使用SET AUTOCOMMIT=0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。</code></pre><h1 id="mysql里记录货币用什么字段类型好"><a href="#mysql里记录货币用什么字段类型好" class="headerlink" title="mysql里记录货币用什么字段类型好"></a>mysql里记录货币用什么字段类型好</h1><pre><code>NUMERICDECIMAL  salary DECIMAL(9,2)  9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。  因此，在这种情况下，能被存储在salary列中的值的范围是从-9999999.99到9999999.99。</code></pre><h1 id="mysql有关权限的表都有哪几个？"><a href="#mysql有关权限的表都有哪几个？" class="headerlink" title="mysql有关权限的表都有哪几个？"></a>mysql有关权限的表都有哪几个？</h1><pre><code>Mysql服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。userdbtable_privcolumns_privhost</code></pre><h1 id="列的字符串类型可以是什么？"><a href="#列的字符串类型可以是什么？" class="headerlink" title="列的字符串类型可以是什么？"></a>列的字符串类型可以是什么？</h1><pre><code>字符串类型是： SET BLOB ENUM CHAR TEXT</code></pre><h1 id="MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年-怎么优化？"><a href="#MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年-怎么优化？" class="headerlink" title="MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？"></a>MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？</h1><pre><code>a. 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。b. 选择合适的表字段数据类型和存储引擎，适当的添加索引。c. mysql库主从读写分离。d. 找规律分表，减少单表中的数据量提高查询速度。e。添加缓存机制，比如memcached，apc等。f. 不经常改动的页面，生成静态页面。g. 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE.</code></pre><h1 id="锁的优化策略"><a href="#锁的优化策略" class="headerlink" title="锁的优化策略"></a>锁的优化策略</h1><pre><code>1. 读写分离2. 分段加锁3. 减少锁持有的时间4. 多个线程尽量以相同的顺序去获取资源不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁。</code></pre><h1 id="索引的底层实现原理和优化"><a href="#索引的底层实现原理和优化" class="headerlink" title="索引的底层实现原理和优化"></a>索引的底层实现原理和优化</h1><pre><code>B+树，经过优化的B+树主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此InnoDB建议为大部分表使用默认自增的主键作为主索引。</code></pre><h1 id="什么情况下设置了索引但无法使用"><a href="#什么情况下设置了索引但无法使用" class="headerlink" title="什么情况下设置了索引但无法使用"></a>什么情况下设置了索引但无法使用</h1><pre><code>1.以“%”开头的LIKE语句，模糊匹配2. OR语句前后没有同时使用索引3. 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）</code></pre><h1 id="实践中如何优化MySQL"><a href="#实践中如何优化MySQL" class="headerlink" title="实践中如何优化MySQL"></a>实践中如何优化MySQL</h1><pre><code>1.SQL语句及索引的优化2. 数据库表结构的优化3.系统配置的优化4.硬件的优化</code></pre><h1 id="优化数据库的方法"><a href="#优化数据库的方法" class="headerlink" title="优化数据库的方法"></a>优化数据库的方法</h1><pre><code>选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如’省份’、’性别’最好适用ENUM使用连接(JOIN)来代替子查询适用联合(UNION)来代替手动创建的临时表事务处理锁定表、优化事务处理适用外键，优化锁定表建立索引优化查询语句</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL的复制原理以及流程&quot;&gt;&lt;a href=&quot;#MySQL的复制原理以及流程&quot; class=&quot;headerlink&quot; title=&quot;MySQL的复制原理以及流程&quot;&gt;&lt;/a&gt;MySQL的复制原理以及流程&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;基本原理流程，3个线程以及之
      
    
    </summary>
    
    
      <category term="面试" scheme="http://iwantjingjing.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试，mysql" scheme="http://iwantjingjing.com/tags/%E9%9D%A2%E8%AF%95%EF%BC%8Cmysql/"/>
    
  </entry>
  
  <entry>
    <title>redis面试题</title>
    <link href="http://iwantjingjing.com/2020/04/16/redis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://iwantjingjing.com/2020/04/16/redis面试题/</id>
    <published>2020-04-16T10:03:11.000Z</published>
    <updated>2020-04-16T10:12:41.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="双写一致问题"><a href="#双写一致问题" class="headerlink" title="双写一致问题"></a>双写一致问题</h2><pre><code>非原子操作，多线程一定会发生解决方案：延时双删策略    先删Redis，再删数据库，再删Redis知乎答案</code></pre><h2 id="redis与memcached有什么区别？为什么选用redis作为缓存的中间件"><a href="#redis与memcached有什么区别？为什么选用redis作为缓存的中间件" class="headerlink" title="redis与memcached有什么区别？为什么选用redis作为缓存的中间件"></a>redis与memcached有什么区别？为什么选用redis作为缓存的中间件</h2><pre><code>1： Redis支持数据结构多，如果需要缓存支持负责的结构，Redis是不错的选择2： Redis天生支持集群，memcached需要依赖客户端来实现往集群中分片写入数据3： 性能对比    1 Redis单核，所以平均每个核上Redis处理小数据时性能优于memcached    2 memcached多核,处理大于100k数据时优于Redis4.Redis支持数据的备份，即master-slave模式的数据备份。3.Redis可以持久化其数据</code></pre><h2 id="说说redis线程模型"><a href="#说说redis线程模型" class="headerlink" title="说说redis线程模型"></a>说说redis线程模型</h2><pre><code>1 file event handler    内部使用文件事件处理器 file event handler，这个是单线程的，所以redis才叫单线程的模型    结构            1多个socket            2 io多路复用程序            3文件时间分派器            4 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）2 io多路复用机制同时监听多个socket    采用io多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器进行处理。</code></pre><h2 id="Redis有哪些数据结构啊？"><a href="#Redis有哪些数据结构啊？" class="headerlink" title="Redis有哪些数据结构啊？"></a>Redis有哪些数据结构啊？</h2><pre><code>普通青年    1String            二进制安全的字符串，最大512M    2 Hash    3 List            按照添加顺序保持顺序的字符串列表    4 Set            无序的字符串集合，不存在重复的元素。    5 SortedSet(/Zset)            已排序的字符串集合。2B青年    1 HyperLogLog    2 Geo    3 Pub    4 Sub文艺青年    1 Redis Module    2 BloomFilter    3 RedisSearch    4 Redis-ML</code></pre><h2 id="如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h2><pre><code>1 过期时间设置的过于集中，到过期的时候，Redis可能会出现短暂的卡顿现象，2 严重会雪崩3 一般在时间上加一个随机值，使得过期时间分散一些4 示例：如电商的首页</code></pre><h2 id="你使用过Redis分布式锁么，它是怎么回事？"><a href="#你使用过Redis分布式锁么，它是怎么回事？" class="headerlink" title="你使用过Redis分布式锁么，它是怎么回事？"></a>你使用过Redis分布式锁么，它是怎么回事？</h2><pre><code>1 setnx    先拿setnx来争抢锁2 expire    抢到之后，再用Expire给锁加一个过期时间防止锁忘记释放</code></pre><h2 id="如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？"><a href="#如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？" class="headerlink" title="如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？"></a>如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？</h2><pre><code>set指令有个非常复杂的参数EX，这个应该是可以同时把setnx和expire合成一条指令来用的</code></pre><h2 id="假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？"><a href="#假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？" class="headerlink" title="假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？"></a>假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？</h2><pre><code>使用keys指令可以扫出指定模式的key列表</code></pre><h2 id="继续追问：如果这个redis正在给线上的业务提供服务，那么使用keys指令会有什么问题"><a href="#继续追问：如果这个redis正在给线上的业务提供服务，那么使用keys指令会有什么问题" class="headerlink" title="继续追问：如果这个redis正在给线上的业务提供服务，那么使用keys指令会有什么问题?"></a>继续追问：如果这个redis正在给线上的业务提供服务，那么使用keys指令会有什么问题?</h2><pre><code>1 redis是单线程的，使用keys会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕2 可使用scan指令非阻塞的取出    1 缺点： 有一定重复    2 单体花费时间比keys长</code></pre><h2 id="redis是怎么持久化的？"><a href="#redis是怎么持久化的？" class="headerlink" title="redis是怎么持久化的？"></a>redis是怎么持久化的？</h2><pre><code>1 rdb    1 rdb做镜像全量持久化    2 耗费较长    3不够实时    4导致大量丢失数据    5理解为一整个表全量的数据    6生成指定时间间隔内的 Redis 内存中数据快照，是一个二进制文件 dumpr.rdb2 aof    1 aof做增量持久化    2 每次操作的日志    3记录 Redis 除了查询以外的所有写命令，并在Redis 服务启动时，通过重新执行这些命令来还原数据。3 在redis实例重启时，会使用rdb持久化文件重构内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态4 机制    1 aof持久化开启且存在aof文件时，优先加载aof文件    2 aof关闭或者aof文件不存在时，加载rdb文件    3 加载aof/rdb文件成功后，redis启动成功    4 aof/rdb文件存在错误时，redis启动失败并打印错误信息</code></pre><h2 id="redis服务主从数据是怎么交互的？"><a href="#redis服务主从数据是怎么交互的？" class="headerlink" title="redis服务主从数据是怎么交互的？"></a>redis服务主从数据是怎么交互的？</h2><pre><code>1 slave发送psync命令给master    若这个slave第一次连接到master，他会触发一个全量复制。2 master就会启动一个线程，生成RDB快照，还会把新的写请求都缓存在内存中3 RDB文件生成后，master会将这个RDB发送给slave的4 slave拿到之后做的第一件事情就是写进本地的磁盘，然后加载进内存，5 然后master会把内存里面缓存的那些新命名都发给slave。</code></pre><h2 id="对方追问如果突然机器停电会怎样"><a href="#对方追问如果突然机器停电会怎样" class="headerlink" title="对方追问如果突然机器停电会怎样?"></a>对方追问如果突然机器停电会怎样?</h2><pre><code>1 取决于aof日志sync属性的配置2在每一条写指令时都sync一下磁盘，就不会丢失数据，    在高性能要求下每次都sync是不现实的3一般都使用定时sync，比如1s/1次，这个时候最多就会丢失1s的数据</code></pre><h2 id="对方继续追问rdb的原理是什么？"><a href="#对方继续追问rdb的原理是什么？" class="headerlink" title="对方继续追问rdb的原理是什么？"></a>对方继续追问rdb的原理是什么？</h2><pre><code>1 fork    指redis通过创建子进程来进行rdb操作2 cow    cow指的是copy on write            写时复制机制3 原理    1 Redis 调用 fork() ，同时拥有父进程和子进程。    2 子进程将数据集写入到一个临时 RDB 文件中。    3 当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。4 优点    1保存了 Redis 在某个时间点的数据，这种数据比较适合做备份和用于灾难恢复。    2也可以随时将数据集还原到不同的版本    RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。    在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）5 RDB 的缺点    服务器故障时丢失数据</code></pre><h2 id="AOF创建原理"><a href="#AOF创建原理" class="headerlink" title="AOF创建原理"></a>AOF创建原理</h2><pre><code>1 AOF 重写和 RDB 创建快照一样，都巧妙地利用了写时复制机制。2 Redis 执行 fork() ，现在同时拥有父进程和子进程。3 子进程开始将新 AOF 文件的内容写入到临时文件。4 对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾    优点：即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。5 当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。6 优点    只进行追加操作的日志文件，不产生新文件    AOF文件过大自动优化为恢复当前数据集所需的最小命令集合。    可以设置不同的 fsync 策略7 缺点    文件的体积通常要大于 RDB 文件    根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。    在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）    RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</code></pre><h2 id="Redis的过期策略？"><a href="#Redis的过期策略？" class="headerlink" title="Redis的过期策略？"></a>Redis的过期策略？</h2><pre><code>1定期删除    默认100s就随机抽一些设置了过期时间的key，去检查是否过期，过期了就删了            为啥不扫描全部设置了过期时间的key呢？            线上基本上也都是会设置一定的过期时间的。            全扫描跟你去查数据库不带where条件不走索引全表扫描一样，100s一次，Redis累都累死了。2 惰性删除    见名知意，惰性嘛，我不主动删，我懒，我等你来查询了我看看你过期没，过期就删了还不给你返回，没过期该怎么样就怎么样。</code></pre><h2 id="Redis最后就是如果的如果，定期没删，我也没查询，那可咋整？"><a href="#Redis最后就是如果的如果，定期没删，我也没查询，那可咋整？" class="headerlink" title="Redis最后就是如果的如果，定期没删，我也没查询，那可咋整？"></a>Redis最后就是如果的如果，定期没删，我也没查询，那可咋整？</h2><pre><code>内存淘汰机制！    noeviction            返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）    allkeys-lru             尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。    volatile-lru            尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。    allkeys-random            回收随机的键使得新添加的数据有空间存放。    volatile-random            回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。    volatile-ttl            回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放</code></pre><h2 id="什么是LRU算法"><a href="#什么是LRU算法" class="headerlink" title="什么是LRU算法"></a>什么是LRU算法</h2><pre><code>1 一种缓存淘汰算法2 Least recently used，最近最少使用3 核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”4实现方式    LinkedHashMap</code></pre><h2 id="为什么redis那么快"><a href="#为什么redis那么快" class="headerlink" title="为什么redis那么快"></a>为什么redis那么快</h2><pre><code>先吹个牛逼    Redis采用的是单进程单线程模型的kv数据库，由c编写，官方提供的数据是达到10w的qps（每秒内查询次数）1 基于内存操作    完全基于内存，绝大部分请求是纯粹的内存操作，非常快。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1);2 数据结构优化    数据结构简单，对数据操作也简单，redis中的数据结构是专门进行设计的3 单线程    避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换消耗，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。4 多路I/O复用模型    使用多路i/o复用模型，非阻塞io；5 底层模型不同    redis直接自己构建了vm机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</code></pre><h2 id="我可以问一下啥是上下文切换吗？为啥可能线程不安全？"><a href="#我可以问一下啥是上下文切换吗？为啥可能线程不安全？" class="headerlink" title="我可以问一下啥是上下文切换吗？为啥可能线程不安全？"></a>我可以问一下啥是上下文切换吗？为啥可能线程不安全？</h2><pre><code>好比你看一本英文书，你看到第十页发现有个单词不会，你加了个书签，然后去查字典，过了一会你回来继续从书签那里读，ok目前为止没问题。问题来了，你去查字典的时候，别人过来翻了一下你的书，然后走了，然后你回来了，你再看书的时候发现书不是你看的那一页了。</code></pre><h2 id="那他是单线程，我们服务器都是多核的，那不是浪费吗？"><a href="#那他是单线程，我们服务器都是多核的，那不是浪费吗？" class="headerlink" title="那他是单线程，我们服务器都是多核的，那不是浪费吗？"></a>那他是单线程，我们服务器都是多核的，那不是浪费吗？</h2><pre><code>虽然他是单线程的，但是我们可以单机开多个实例啊</code></pre><h2 id="既然提到了单机会有瓶颈，那你们是怎么解决这个瓶颈的？"><a href="#既然提到了单机会有瓶颈，那你们是怎么解决这个瓶颈的？" class="headerlink" title="既然提到了单机会有瓶颈，那你们是怎么解决这个瓶颈的？"></a>既然提到了单机会有瓶颈，那你们是怎么解决这个瓶颈的？</h2><pre><code>redis cluster主从同步读写分离Redis cluster支撑n个redis mater node，并且每个master node 都可以挂载多个salve node这样整个Redis就可以横向扩容了，如果你要吃成更大数据量的缓存，那就横向扩容更多的master节点，每个master节点就能存放更多的数据了。</code></pre><h2 id="Redis还有其他保证集群高可用的方式吗？"><a href="#Redis还有其他保证集群高可用的方式吗？" class="headerlink" title="Redis还有其他保证集群高可用的方式吗？"></a>Redis还有其他保证集群高可用的方式吗？</h2><pre><code>哨兵集群sentinel（森提nou）哨兵必须用三个实例去保证自己的健壮性，哨兵+主从并不能保证数据不丢失，但是可以保证集群的高可用一个机器挂了，剩下两个机器需要选举出来一个执行故障转移，如果只有两台机器的话，挂了一个就剩下一个了，没有哨兵去允许故障转移了</code></pre><h2 id="Redis的同步机制"><a href="#Redis的同步机制" class="headerlink" title="Redis的同步机制"></a>Redis的同步机制</h2><pre><code>1 主从同步，从从同步2 第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录内存buffer，3 待完成后将rdb文件全量同步到复制节点4 复制节点接受完成后将rdb镜像加载到内存5 加载完成后，通知主节点将期间修改的操作记录同步到点进行重放就完成了同步过程6 后续的增量数据通过aof日志同步即知，有点类似数据库的binlog。</code></pre><h2 id="Redis-并发竞争key问题如何解决"><a href="#Redis-并发竞争key问题如何解决" class="headerlink" title="Redis 并发竞争key问题如何解决?"></a>Redis 并发竞争key问题如何解决?</h2><pre><code>原因：同时有多个客户端去set一个key。场景1： 例如有多个请求一起去对某个商品减库存场景2： 比如有3个请求有序的修改某个key解决方案：    1：乐观锁适用于大家一起抢着改同一个key，对修改顺序没有要求的场景。            watch 命令可以方便的实现乐观锁。            乐观锁适用于大家一起抢着改同一个key，对修改顺序没有要求的场景。            原理：watch 命令会监视给定的每一个key，当 exec 时如果监视的任一个key自从调用watch后发生过变化，则整个事务会回滚，不执行任何动作。            如果你的 redis 使用了数据分片的方式，那么这个方法就不适用了    2： 分布式锁            适合分布式环境，不用关心 redis 是否为分片集群模式。            ZooKeeper            Redis    3 时间戳，适合有序场景    4 消息队列，串行化处理            在并发量很大的情况下，可以通过消息队列进行串行化处理。这在高并发场景中是一种很常见的解决方案。</code></pre><h2 id="是否使用过Redis集群，集群的原理是什么？"><a href="#是否使用过Redis集群，集群的原理是什么？" class="headerlink" title="是否使用过Redis集群，集群的原理是什么？"></a>是否使用过Redis集群，集群的原理是什么？</h2><pre><code>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</code></pre><h2 id="如何使用过Redis做异步队列？"><a href="#如何使用过Redis做异步队列？" class="headerlink" title="如何使用过Redis做异步队列？"></a>如何使用过Redis做异步队列？</h2><pre><code>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。如果不用sleep，list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。如果想要生产一次消费多次，可以使用pub/sub主题订阅者模式，可以实现1:N的消息队列，但在消费者下线后，生产的消息会丢失，想要持久化的话，需要使用消息队列如rabbitmq等。</code></pre><h2 id="Redis如何实现延时队列？"><a href="#Redis如何实现延时队列？" class="headerlink" title="Redis如何实现延时队列？"></a>Redis如何实现延时队列？</h2><pre><code>使用sortedset拿时间戳作为score消息内容作为key调用zadd来生产消息消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。</code></pre><h2 id="Redis单点吞吐量"><a href="#Redis单点吞吐量" class="headerlink" title="Redis单点吞吐量"></a>Redis单点吞吐量</h2><pre><code>单点TPS达到8万/秒QPS达到10万/秒</code></pre><h2 id="什么是TPS"><a href="#什么是TPS" class="headerlink" title="什么是TPS"></a>什么是TPS</h2><pre><code>每秒钟最大能处理的请求数每秒钟处理完的事务次数，一个应用系统1s能完成多少事务处理，一个事务在分布式处理中，可能会对应多个请求，对于衡量单个接口服务的处理能力，用QPS比较合理。</code></pre><h2 id="什么是QPS"><a href="#什么是QPS" class="headerlink" title="什么是QPS"></a>什么是QPS</h2><pre><code>应用系统每秒钟最大能接受的用户访问量每秒钟处理完请求的次数，注意这里是处理完，具体是指发出请求到服务器处理完成功返回结果。可以理解在server中有个counter，每处理一个请求加1，1秒后counter=QPS。</code></pre><h2 id="Redis哈希槽"><a href="#Redis哈希槽" class="headerlink" title="Redis哈希槽"></a>Redis哈希槽</h2><pre><code>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中</code></pre><h2 id="Redis集群最大节点个数是多少？"><a href="#Redis集群最大节点个数是多少？" class="headerlink" title="Redis集群最大节点个数是多少？"></a>Redis集群最大节点个数是多少？</h2><pre><code>Redis集群预分好16384个桶(哈希槽)</code></pre><h2 id="Redis事务是什么？"><a href="#Redis事务是什么？" class="headerlink" title="Redis事务是什么？"></a>Redis事务是什么？</h2><pre><code>Redis事务可以一次执行多个命令，有以下特点：    批量操作在发送 EXEC 命令前被放入队列缓存。    收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。    在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</code></pre><h2 id="Redis线程模型？"><a href="#Redis线程模型？" class="headerlink" title="Redis线程模型？"></a>Redis线程模型？</h2><pre><code>单线程Redis 4.0 之后的版本却抛弃了单线程模型这一设</code></pre><h2 id="Pipeline有什么好处，为什么要用Pipeline？"><a href="#Pipeline有什么好处，为什么要用Pipeline？" class="headerlink" title="Pipeline有什么好处，为什么要用Pipeline？"></a>Pipeline有什么好处，为什么要用Pipeline？</h2><pre><code>可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目</code></pre><h2 id="redis常用命令"><a href="#redis常用命令" class="headerlink" title="redis常用命令"></a>redis常用命令</h2><pre><code>Keys    *表示区配所有，    以bit开头的，    查看Exists key是否存在。Set    设置 key 对应的值为 string 类型的 value。setnx    设置 key 对应的值为 string 类型的 value    如果 key 已经存在，返回 0，nx 是 not exist 的意思。Expire    设置过期时间（单位秒）TTL    查看剩下多少时间    返回负数则key失效，key不存在了Setex    设置 key 对应的值为 string 类型的 value，并指定此键值对应的有效期。Mset    一次设置多个 key 的值，    成功返回 ok 表示所有的值都设置了，失败返回 0 表示没有任何值被设置。Getset    设置 key 的值    并返回 key 的旧值Mget    一次获取多个 key 的值    如果对应 key 不存在，则对应返回 nilIncr    对 key 的值做加加操作,并返回新的值    注意 incr 一个不是 int 的 value 会返回错误    incr 一个不存在的 key，则设置 key 为 1incrby    同 incr 类似，加指定值 ，key 不存在时候会设置 key，并认为原来的 value 是 0Decr    对 key 的值做的是减减操作，decr 一个不存在 key，则设置 key 为-1Decrby    同 decr，减指定值。Append    给指定 key 的字符串值追加 value,返回新字符串值的长度。Strlen    取指定 key 的 value 值的长度。persist xxx(取消过期时间)    选择数据库（0-15库）Select 0 //选择数据库move age 1//把age 移动到1库Randomkey随机返回一个keyRename重命名Type 返回数据类型在bin下的可执行文件    redis-server ：Redis的服务端    redis-cli ：命令行客户端    redis-benchmark ：Redis性能测试工具    redis-check-aof ：AOF文件修复工具    redis-check-dump ：RDB文件检测工具    redis-sentinel : 用于做主备</code></pre><h2 id="Redis启动方式有几种"><a href="#Redis启动方式有几种" class="headerlink" title="Redis启动方式有几种"></a>Redis启动方式有几种</h2><pre><code>不加载配置启动：redis-server加载配置启动：redis-server /etc/redis.conf使用docker启动：run -d --rm -v /root/test/redis.conf:/redis.conf --name redis-test -p 6379:6379 redis:5.0.0</code></pre><h2 id="Redis停止方式有几种"><a href="#Redis停止方式有几种" class="headerlink" title="Redis停止方式有几种"></a>Redis停止方式有几种</h2><pre><code>命令行连上redis以后运行shutdown直接结束redis进程：kill ...停止docker启动的redis：docker stop redis-test</code></pre><h2 id="Redis常见性能问题解决之道"><a href="#Redis常见性能问题解决之道" class="headerlink" title="Redis常见性能问题解决之道"></a>Redis常见性能问题解决之道</h2><pre><code>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内尽量避免在压力很大的主库上增加从库(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…    这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</code></pre><h2 id="redis集群投票机制"><a href="#redis集群投票机制" class="headerlink" title="redis集群投票机制"></a>redis集群投票机制</h2><pre><code>redis集群服务器之间通过互相的ping-pong判断是否节点可以连接上如果有一半以上的节点去ping一个节点的时候没有回应，集群就认为这个节点宕机了。</code></pre><h2 id="Redis主要有哪些功能？"><a href="#Redis主要有哪些功能？" class="headerlink" title="Redis主要有哪些功能？"></a>Redis主要有哪些功能？</h2><pre><code>1.哨兵（Sentinel）和复制（Replication）    Sentinel可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能，    Replication则是负责让一个Redis服务器可以配备多个备份的服务器。    Redis也是利用这两个功能来保证Redis的高可用的2.事务    支持一次性按顺序执行多个命令的能力，并保证其原子性。3.LUA脚本    在事务的基础上，如果我们需要在服务端一次性的执行更复杂的操作（包含一些逻辑判断），则lua就可以排上用场了4.持久化5.集群（Cluster）    Cluster    在Redis官方的分布式方案出来之前，有twemproxy和codis两种方案，这两个方案总体上来说都是依赖proxy来进行分布式的。</code></pre><h2 id="Redis为什么是单线程的？"><a href="#Redis为什么是单线程的？" class="headerlink" title="Redis为什么是单线程的？"></a>Redis为什么是单线程的？</h2><pre><code>多线程处理会涉及到锁，上下文切换，单线程没有这些消耗Redis是单进程单线程的，Redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</code></pre><h2 id="Redis瓶颈可能是"><a href="#Redis瓶颈可能是" class="headerlink" title="Redis瓶颈可能是"></a>Redis瓶颈可能是</h2><pre><code>机器内存或者网络带宽</code></pre><h2 id="其他开源软件采用的模型"><a href="#其他开源软件采用的模型" class="headerlink" title="其他开源软件采用的模型"></a>其他开源软件采用的模型</h2><pre><code>Nginx：多进程单线程模型Memcached：单进程多线程模型</code></pre><h2 id="使用Redis的优势？"><a href="#使用Redis的优势？" class="headerlink" title="使用Redis的优势？"></a>使用Redis的优势？</h2><pre><code>1.速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)2. 支持丰富数据类型，支持string，list，set，sorted set，hash3.支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行4. 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</code></pre><h2 id="Redis集群方案应该怎么做？都有哪些方案？"><a href="#Redis集群方案应该怎么做？都有哪些方案？" class="headerlink" title="Redis集群方案应该怎么做？都有哪些方案？"></a>Redis集群方案应该怎么做？都有哪些方案？</h2><pre><code>1.twemproxy2.codis，目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。3.Redis cluster3.0自带的集，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。</code></pre><h2 id="Redis读写分离模型"><a href="#Redis读写分离模型" class="headerlink" title="Redis读写分离模型"></a>Redis读写分离模型</h2><pre><code>通过增加Slave DB的数量，读的性能可以线性增长。为了避免Master DB的单点故障，集群一般都会采用两台Master DB做双机热备，所以整个集群的读和写的可用性都非常高。读写分离架构的缺陷在于，不管是Master还是Slave，每个节点都必须保存完整的数据，如果在数据量很大的情况下，集群的扩展能力还是受限于单个节点的存储能力，而且对于Write-intensive类型的应用，读写分离架构并不适合。</code></pre><h2 id="Redis数据分片模型"><a href="#Redis数据分片模型" class="headerlink" title="Redis数据分片模型"></a>Redis数据分片模型</h2><pre><code>为了解决读写分离模型的缺陷，可以将数据分片模型应用进来。可以将每个节点看成都是独立的master，然后通过业务实现数据分片。结合上面两种模型，可以将每个master设计成由一个master和多个slave组成的模型。</code></pre><h2 id="Redis支持的Java客户端都有哪些？官方推荐用哪个？"><a href="#Redis支持的Java客户端都有哪些？官方推荐用哪个？" class="headerlink" title="Redis支持的Java客户端都有哪些？官方推荐用哪个？"></a>Redis支持的Java客户端都有哪些？官方推荐用哪个？</h2><pre><code>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</code></pre><h2 id="Redis集群的主从复制模型是怎样的？"><a href="#Redis集群的主从复制模型是怎样的？" class="headerlink" title="Redis集群的主从复制模型是怎样的？"></a>Redis集群的主从复制模型是怎样的？</h2><pre><code>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.</code></pre><h2 id="Redis集群会有写操作丢失吗？为什么？"><a href="#Redis集群会有写操作丢失吗？为什么？" class="headerlink" title="Redis集群会有写操作丢失吗？为什么？"></a>Redis集群会有写操作丢失吗？为什么？</h2><pre><code>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</code></pre><h2 id="Redis集群之间是如何复制的？"><a href="#Redis集群之间是如何复制的？" class="headerlink" title="Redis集群之间是如何复制的？"></a>Redis集群之间是如何复制的？</h2><pre><code>异步复制</code></pre><h2 id="Redis如何做内存优化？"><a href="#Redis如何做内存优化？" class="headerlink" title="Redis如何做内存优化？"></a>Redis如何做内存优化？</h2><pre><code>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面.</code></pre><h2 id="Redis回收进程如何工作的？"><a href="#Redis回收进程如何工作的？" class="headerlink" title="Redis回收进程如何工作的？"></a>Redis回收进程如何工作的？</h2><pre><code>一个客户端运行了新的命令，添加了新的数据。Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。</code></pre><h2 id="Redis回收使用的是什么算法？"><a href="#Redis回收使用的是什么算法？" class="headerlink" title="Redis回收使用的是什么算法？"></a>Redis回收使用的是什么算法？</h2><pre><code>LRU算法</code></pre><h2 id="Redis有哪些适合的场景？"><a href="#Redis有哪些适合的场景？" class="headerlink" title="Redis有哪些适合的场景？"></a>Redis有哪些适合的场景？</h2><pre><code>1）Session共享(单点登录)2）页面缓存3）队列4）排行榜/计数器5）发布/订阅</code></pre><h2 id="Redis持久化数据和缓存怎么做扩容？"><a href="#Redis持久化数据和缓存怎么做扩容？" class="headerlink" title="Redis持久化数据和缓存怎么做扩容？"></a>Redis持久化数据和缓存怎么做扩容？</h2><pre><code>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。如果Redis被当做一个持久化存储使用    必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。    否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</code></pre><h2 id="Redis事务相关的命令有哪几个？"><a href="#Redis事务相关的命令有哪几个？" class="headerlink" title="Redis事务相关的命令有哪几个？"></a>Redis事务相关的命令有哪几个？</h2><pre><code>MULTI、EXEC、DISCARD、WATCH</code></pre><h2 id="Redis-key的过期时间和永久有效分别怎么设置？"><a href="#Redis-key的过期时间和永久有效分别怎么设置？" class="headerlink" title="Redis key的过期时间和永久有效分别怎么设置？"></a>Redis key的过期时间和永久有效分别怎么设置？</h2><pre><code>EXPIRE和PERSIST命令。</code></pre><h2 id="Redis如何做大量数据插入？"><a href="#Redis如何做大量数据插入？" class="headerlink" title="Redis如何做大量数据插入？"></a>Redis如何做大量数据插入？</h2><pre><code>Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。</code></pre><h2 id="Redis和Redisson有什么关系？"><a href="#Redis和Redisson有什么关系？" class="headerlink" title="Redis和Redisson有什么关系？"></a>Redis和Redisson有什么关系？</h2><pre><code>Redisson是一个高级的分布式协调Redis客服端能帮助用户在分布式环境中轻松实现一些Java的对象     (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</code></pre><h2 id="Jedis与Redisson对比有什么优缺点？"><a href="#Jedis与Redisson对比有什么优缺点？" class="headerlink" title="Jedis与Redisson对比有什么优缺点？"></a>Jedis与Redisson对比有什么优缺点？</h2><pre><code>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</code></pre><h2 id="为什么要用-Redis-而不用-map-guava-做缓存"><a href="#为什么要用-Redis-而不用-map-guava-做缓存" class="headerlink" title="为什么要用 Redis 而不用 map/guava 做缓存?"></a>为什么要用 Redis 而不用 map/guava 做缓存?</h2><pre><code>缓存分为本地缓存和分布式缓存使用自带的 map 或者 guava 实现的是本地缓存，    特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，    并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。使用 redis 或 memcached 之类的称为分布式缓存，    在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。    缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。</code></pre><h2 id="你知道有哪些Redis分区实现方案？"><a href="#你知道有哪些Redis分区实现方案？" class="headerlink" title="你知道有哪些Redis分区实现方案？"></a>你知道有哪些Redis分区实现方案？</h2><pre><code>客户端分区    在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。代理分区    意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。    代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。    redis和memcached的一种代理实现就是Twemproxy查询路由(Query routing)    客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点    Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。</code></pre><h2 id="Redis分区有什么缺点"><a href="#Redis分区有什么缺点" class="headerlink" title="Redis分区有什么缺点"></a>Redis分区有什么缺点</h2><pre><code>涉及多个key的操作通常不会被支持。同时操作多个key,则不能使用Redis事务分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件。分区时动态扩容或缩容可能非常复杂。</code></pre><h2 id="什么是-RedLock"><a href="#什么是-RedLock" class="headerlink" title="什么是 RedLock"></a>什么是 RedLock</h2><pre><code>Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 Redlock，此种方式比原先的单节点的方法更安全安全特性：互斥访问，即永远只有一个 client 能拿到锁避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区容错性：只要大部分 Redis 节点存活就可以正常提供服务</code></pre><h2 id="布隆过滤器？"><a href="#布隆过滤器？" class="headerlink" title="布隆过滤器？"></a>布隆过滤器？</h2><pre><code>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力Bitmap：典型的就是哈希表    缺点是，Bitmap对于每个元素只能记录1bit信息它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;双写一致问题&quot;&gt;&lt;a href=&quot;#双写一致问题&quot; class=&quot;headerlink&quot; title=&quot;双写一致问题&quot;&gt;&lt;/a&gt;双写一致问题&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;非原子操作，多线程一定会发生
解决方案：延时双删策略
    先删Redis，再删数据库，再
      
    
    </summary>
    
    
      <category term="面试" scheme="http://iwantjingjing.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试，redis" scheme="http://iwantjingjing.com/tags/%E9%9D%A2%E8%AF%95%EF%BC%8Credis/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="http://iwantjingjing.com/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://iwantjingjing.com/2020/04/12/数据结构与算法/</id>
    <published>2020-04-12T05:40:05.000Z</published>
    <updated>2020-04-12T05:46:10.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="1数据结构"><a href="#1数据结构" class="headerlink" title="1数据结构"></a>1数据结构</h2><h3 id="1线性表"><a href="#1线性表" class="headerlink" title="1线性表"></a>1线性表</h3><pre><code>1数组2链表    1单链表    2双向链表    3循环链表    4双向循环链表    5静态链表3栈    1顺序栈    2链式栈4队列    1普通队列    2双端队列    3阻塞队列    4并发队列    5并发阻塞队列</code></pre><h3 id="2散列表"><a href="#2散列表" class="headerlink" title="2散列表"></a>2散列表</h3><pre><code>1散列函数2解决冲突    1链表法    2开发寻址法3动态扩容4位图</code></pre><h3 id="3树"><a href="#3树" class="headerlink" title="3树"></a>3树</h3><pre><code>1二叉树    1平衡二叉树    2二叉查找树    3平衡二叉查找树            1AVL树            2红黑树    4完全二叉树    5满二叉树2多路查找树    1B树    2B+树    3：2-3树    4：2-3-4树3堆    1小顶堆    2大顶堆    3优先级队列    4斐波那契堆    5二项堆4其他    1树状数组    2线段树</code></pre><h3 id="4图"><a href="#4图" class="headerlink" title="4图"></a>4图</h3><pre><code>1图的存储    1邻接矩阵    2邻接表2拓扑排序3最短路径4最小生成树5二分图6最大流</code></pre><h2 id="2算法"><a href="#2算法" class="headerlink" title="2算法"></a>2算法</h2><h3 id="1复杂度分析"><a href="#1复杂度分析" class="headerlink" title="1复杂度分析"></a>1复杂度分析</h3><pre><code>1空间复杂度2时间复杂度    1最好    2最坏    3平均    4分摊</code></pre><h3 id="2算法思想"><a href="#2算法思想" class="headerlink" title="2算法思想"></a>2算法思想</h3><pre><code>1贪心算法2分治算法3动态规划4回溯算法5枚举算法</code></pre><h3 id="3排序"><a href="#3排序" class="headerlink" title="3排序"></a>3排序</h3><pre><code>O(n^2)    1冒泡排序    2插入排序    3选择排序    4希尔排序O(nlogn)    1并归排序    2堆排序    3快速排序O(n)    1计数排序    2基数排序    3桶排序</code></pre><h3 id="4搜索"><a href="#4搜索" class="headerlink" title="4搜索"></a>4搜索</h3><pre><code>1深度优先2广度优先3A*启发式</code></pre><h3 id="5查找"><a href="#5查找" class="headerlink" title="5查找"></a>5查找</h3><pre><code>1线性查找2树查找3散列查找</code></pre><h3 id="6字符串匹配"><a href="#6字符串匹配" class="headerlink" title="6字符串匹配"></a>6字符串匹配</h3><pre><code>1朴素2KMP3Robin-Karp4Boyer-Moore5AC自动机6Tire7后缀数组</code></pre><h3 id="7其他"><a href="#7其他" class="headerlink" title="7其他"></a>7其他</h3><pre><code>1数论2计算几何3概率分析4并查集5拓扑网络6矩阵运算7线性规划</code></pre><h1 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h1><p><img src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.png" alt>    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构与算法&quot;&gt;&lt;a href=&quot;#数据结构与算法&quot; class=&quot;headerlink&quot; title=&quot;数据结构与算法&quot;&gt;&lt;/a&gt;数据结构与算法&lt;/h1&gt;&lt;h2 id=&quot;1数据结构&quot;&gt;&lt;a href=&quot;#1数据结构&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="脑图" scheme="http://iwantjingjing.com/categories/%E8%84%91%E5%9B%BE/"/>
    
    
      <category term="数据结构，算法，脑图" scheme="http://iwantjingjing.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E7%AE%97%E6%B3%95%EF%BC%8C%E8%84%91%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>后端架构图</title>
    <link href="http://iwantjingjing.com/2020/04/11/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%9B%BE/"/>
    <id>http://iwantjingjing.com/2020/04/11/后端架构图/</id>
    <published>2020-04-11T02:23:11.000Z</published>
    <updated>2020-04-11T02:38:33.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="后端架构"><a href="#后端架构" class="headerlink" title="后端架构"></a>后端架构</h1><h2 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h2><pre><code>多线程队列高性能网络层插件压缩加密反射调度特性扩张方法表达式树</code></pre><h2 id="基础监控"><a href="#基础监控" class="headerlink" title="基础监控"></a>基础监控</h2><h3 id="业务监控"><a href="#业务监控" class="headerlink" title="业务监控"></a>业务监控</h3><pre><code>业务操作完成量业务操作完成时间</code></pre><h3 id="用户行为"><a href="#用户行为" class="headerlink" title="用户行为"></a>用户行为</h3><pre><code>访问人数、在线人数访问热点访问轨迹</code></pre><h3 id="软件应用监控"><a href="#软件应用监控" class="headerlink" title="软件应用监控"></a>软件应用监控</h3><pre><code>执行性能，性能趋势报表图    页面级别    方法级别    数据库操作可用性服务、页面使用量开源组件性能监视</code></pre><h3 id="软件系统监控"><a href="#软件系统监控" class="headerlink" title="软件系统监控"></a>软件系统监控</h3><pre><code>磁盘内存CPU网络</code></pre><h3 id="硬件监控"><a href="#硬件监控" class="headerlink" title="硬件监控"></a>硬件监控</h3><pre><code>硬件资源的消耗趋势（容量规划）硬件资源的使用趋势（细化到进程）硬件资源的总体利用率</code></pre><h3 id="通用报警"><a href="#通用报警" class="headerlink" title="通用报警"></a>通用报警</h3><pre><code>基于统计值基于状态事件处理流程短信群发平台集中化配置邮件、短信通道跨平台的客户端分组+权限+自定义间隔信息模板细节报警信息</code></pre><h2 id="页面引擎"><a href="#页面引擎" class="headerlink" title="页面引擎"></a>页面引擎</h2><h3 id="MVC扩展"><a href="#MVC扩展" class="headerlink" title="MVC扩展"></a>MVC扩展</h3><pre><code>基础横切组件封装（ActionFilter等）模板集中存储+后台修改IOC支持执行性能组件全局注册</code></pre><h3 id="轻量级的ashx容器"><a href="#轻量级的ashx容器" class="headerlink" title="轻量级的ashx容器"></a>轻量级的ashx容器</h3><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><pre><code>脚本样式合并分布式会话验证码各种控件</code></pre><h2 id="横切关注"><a href="#横切关注" class="headerlink" title="横切关注"></a>横切关注</h2><h3 id="日志、异常、状态信息"><a href="#日志、异常、状态信息" class="headerlink" title="日志、异常、状态信息"></a>日志、异常、状态信息</h3><pre><code>集中收集    MongoDB后台集中查阅自动附加信息异步队列提交</code></pre><h3 id="通用性能"><a href="#通用性能" class="headerlink" title="通用性能"></a>通用性能</h3><pre><code>只要提供Dictionary&lt;string.long&gt;数据源就可以实现性能监控多级分组通用性能查看后台（highchart+ajax)支持各个粒度的数据聚合数据类型支持TextValue、TotalValue、StateValue、ExpressionValue数据源支持推模式和拉模式</code></pre><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><pre><code>本地缓存远端缓存    基于Redis各种过期模式    平滑过期    绝对时间过期    依赖过期过期回调容量限制</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><pre><code>配置集中化（消除本地配置）支持横向扩容（同步）支持复杂类型（自定义类型）    列表    字典    枚举    继承    抽象类配置后台（考虑多环境同步问题)    考虑实现配置实用率跟踪自动根据默认值初始化    考虑默认值的使用策略全局配配置和私有配置，支持分组更新回调    考虑细化到某个点基于行的版本（同步）控制高性能    缓存+数据库</code></pre><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><pre><code>任意数据的同步支持水平扩容支持拉模式和推模式支持</code></pre><h3 id="NOSQL客户端"><a href="#NOSQL客户端" class="headerlink" title="NOSQL客户端"></a>NOSQL客户端</h3><pre><code>配置集中统一的客户端集群管理</code></pre><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h2 id="分布式数据访问"><a href="#分布式数据访问" class="headerlink" title="分布式数据访问"></a>分布式数据访问</h2><h3 id="ORM特性"><a href="#ORM特性" class="headerlink" title="ORM特性"></a>ORM特性</h3><pre><code>查询表达器缓存（多级）关系延迟加载映射配置代码生成多数据库支持锁支持枚举支持</code></pre><h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><pre><code>监控性能NOSQL集成领域驱动支持</code></pre><h3 id="Shard特性"><a href="#Shard特性" class="headerlink" title="Shard特性"></a>Shard特性</h3><pre><code>分库规则和路由分表规则和路由集群    高可用负载均衡策略    软负载可用性探测读写分离    高性能分布式事物多写迁移辅助基于元数据还是映射的策略跨节点排序分页支持</code></pre><h2 id="服务端组件"><a href="#服务端组件" class="headerlink" title="服务端组件"></a>服务端组件</h2><p>  分布式文件系统<br>  分布式缓存系统<br>  分布式计算<br>  分布式存储系统<br>  分布式队列系统<br>  分布式计数器<br>  分布式锁</p><h2 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h2><h3 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h3><pre><code>同步调用异步调用双向调用    事件回调（软）负载均衡    随机、轮训、最小调用高级QoS均衡    根据性能决定均衡策略失败容错    重试、日志、后台容错调用拦截    增加横切平滑重启优雅升降级分布式事务批量调用    提高性能本地伪装    本地Mock逻辑用于容错隐式传参    客户端和服务端同步上下文服务分组    允许一个接口多种实现客户端代理生成插件    异步调用</code></pre><h3 id="协议集成"><a href="#协议集成" class="headerlink" title="协议集成"></a>协议集成</h3><pre><code>HessionWebServiceProtobuf自定义二进制序列化</code></pre><h3 id="集群监控"><a href="#集群监控" class="headerlink" title="集群监控"></a>集群监控</h3><pre><code>可用性性能版本路径依赖</code></pre><h3 id="动态部署"><a href="#动态部署" class="headerlink" title="动态部署"></a>动态部署</h3><pre><code>服务容器    守护、更新自动部署平滑回滚</code></pre><h3 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h3><pre><code>服务注册发现服务测试服务路由    机房感知、机器、上下文服务安全限制    调用验证    信息加密服务依赖关系服务负责人    信息通知服务文档服务声明周期服务命名空间服务限流    并发、流程</code></pre><h1 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h1><p><img src="%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84.png" alt>        </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;后端架构&quot;&gt;&lt;a href=&quot;#后端架构&quot; class=&quot;headerlink&quot; title=&quot;后端架构&quot;&gt;&lt;/a&gt;后端架构&lt;/h1&gt;&lt;h2 id=&quot;基础组件&quot;&gt;&lt;a href=&quot;#基础组件&quot; class=&quot;headerlink&quot; title=&quot;基础组件&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="架构" scheme="http://iwantjingjing.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://iwantjingjing.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="脑图" scheme="http://iwantjingjing.com/tags/%E8%84%91%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架</title>
    <link href="http://iwantjingjing.com/2020/04/11/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>http://iwantjingjing.com/2020/04/11/Java集合框架/</id>
    <published>2020-04-11T00:26:51.000Z</published>
    <updated>2020-04-11T00:35:42.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h1><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><pre><code>ArrayList    排列有序，可重复    底层使用数组    速度快，增删慢，getter()和setter()快    线程不安全    当容量不够，ArrayList是当前容量*1.5+1Vector    排列有序，可重复    底层使用数组    速度快，增删慢    线程安全，效率低    当容量不够，默认扩张一倍容量LinkedList    排列有序，可重复    底层使用双向循环链表数据结构    查询速度慢，增删快，add（）和remove（）方法快    线程不安全</code></pre><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><pre><code>HashSet    排列无序，不可重复    底层使用hash表实现    存取速度快    内部是HashMapTreeSet    排列无序，不可重复    底层使用二叉树实现    排序存储    内部是TreeMap的SortedSetLinkedHashSet    采用Hash表存储，并用双向链表记录插入顺序    内部是LinkedHashMap</code></pre><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><pre><code>在两端出入的List，所以也可以用数组或链表来实现</code></pre><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><pre><code>键不可重复，值可重复底层hash表线程不安全允许key值为null，值为null</code></pre><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><pre><code>键不可重复，值可重复底层Hash表线程安全键和值都不可为null</code></pre><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><pre><code>键不可重复，值可重复底层二叉树</code></pre><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java集合框架&quot;&gt;&lt;a href=&quot;#Java集合框架&quot; class=&quot;headerlink&quot; title=&quot;Java集合框架&quot;&gt;&lt;/a&gt;Java集合框架&lt;/h1&gt;&lt;h2 id=&quot;Collection&quot;&gt;&lt;a href=&quot;#Collection&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="java" scheme="http://iwantjingjing.com/categories/java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="集合，面试" scheme="http://iwantjingjing.com/tags/%E9%9B%86%E5%90%88%EF%BC%8C%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring常见问题总结</title>
    <link href="http://iwantjingjing.com/2020/04/10/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://iwantjingjing.com/2020/04/10/Spring常见问题总结/</id>
    <published>2020-04-10T08:07:49.000Z</published>
    <updated>2020-04-10T09:56:57.267Z</updated>
    
    <content type="html"><![CDATA[<p>Spring常见问题总结</p><p><a href="https://mp.weixin.qq.com/s/wcK2qsZxKDJTLIGqEIyaNg" target="_blank" rel="noopener">引用自</a></p><h1 id="1-什么是-Spring-框架"><a href="#1-什么是-Spring-框架" class="headerlink" title="1 什么是 Spring 框架?"></a>1 什么是 Spring 框架?</h1><p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。</p><h1 id="2-Spring-官网列出的-Spring-的-6-个特征"><a href="#2-Spring-官网列出的-Spring-的-6-个特征" class="headerlink" title="2 Spring 官网列出的 Spring 的 6 个特征:"></a>2 Spring 官网列出的 Spring 的 6 个特征:</h1><p>  核心技术 ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。<br>  测试 ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。<br>  数据访问 ：事务，DAO支持，JDBC，ORM，编组XML。<br>  Web支持 : Spring MVC和Spring WebFlux Web框架。<br>  集成 ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。<br>  语言 ：Kotlin，Groovy，动态语言。</p><h1 id="3-列举一些重要的Spring模块？"><a href="#3-列举一些重要的Spring模块？" class="headerlink" title="3 列举一些重要的Spring模块？"></a>3 列举一些重要的Spring模块？</h1><p>  Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。<br>  Spring Aspects ：该模块为与AspectJ的集成提供支持。<br>  Spring AOP ：提供了面向切面的编程实现。<br>  Spring JDBC : Java数据库连接。<br>  Spring JMS ：Java消息服务。<br>  Spring ORM : 用于支持Hibernate等ORM工具。<br>  Spring Web : 为创建Web应用程序提供支持。<br>  Spring Test : 提供了对 JUnit 和 TestNG 测试的支持。</p><h1 id="4-RestController-vs-Controller"><a href="#4-RestController-vs-Controller" class="headerlink" title="4 @RestController vs @Controller"></a>4 @RestController vs @Controller</h1><p>  Controller 返回一个页面<br>    对应于前后端不分离的情况。<br>    如果你需要在Spring4之前开发 RESTful Web服务的话，你需要使用@Controller 并结合@ResponseBody注解，也就是说@Controller +@ResponseBody= @RestController（Spring 4 之后新加的注解）。<br>  @RestController 返回JSON 或 XML 形式数据<br>    前后端分离</p><h1 id="5-谈谈自己对于-Spring-IoC-和-AOP-的理解"><a href="#5-谈谈自己对于-Spring-IoC-和-AOP-的理解" class="headerlink" title="5 谈谈自己对于 Spring IoC 和 AOP 的理解"></a>5 谈谈自己对于 Spring IoC 和 AOP 的理解</h1><p>  IoC（Inverse of Control:控制反转）是一种设计思想<br>  将原本在程序中手动创建对象的控制权，交由Spring框架来管理<br>  IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。<br>   IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。<br>  AOP(Aspect-Oriented Programming:面向切面编程<br>  事务处理、日志管理、权限控制<br>  减少系统的重复代码，降低模块间的耦合度<br>  Spring AOP就是基于动态代理的<br>    如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib ，这时候Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理</p><h1 id="6-Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#6-Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="6 Spring AOP 和 AspectJ AOP 有什么区别？"></a>6 Spring AOP 和 AspectJ AOP 有什么区别？</h1><p>  Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。<br>  Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。<br>  Spring AOP 已经集成了 AspectJ<br>  AspectJ 相比于 Spring AOP 功能更加强大<br>  Spring AOP 相对来说更简单，<br>  切面比较少，那么两者性能差异不大<br>  当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p><h1 id="7-Spring-中的-bean-的作用域有哪些"><a href="#7-Spring-中的-bean-的作用域有哪些" class="headerlink" title="7 Spring 中的 bean 的作用域有哪些?"></a>7 Spring 中的 bean 的作用域有哪些?</h1><p>  singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。<br>  prototype : 每次请求都会创建一个新的 bean 实例。<br>  request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。<br>  session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。<br>  global-session：全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</p><h1 id="8-Spring-中的单例-bean-的线程安全问题了解吗？"><a href="#8-Spring-中的单例-bean-的线程安全问题了解吗？" class="headerlink" title="8 Spring 中的单例 bean 的线程安全问题了解吗？"></a>8 Spring 中的单例 bean 的线程安全问题了解吗？</h1><p>  当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题<br>  在Bean对象中尽量避免定义可变的成员变量（不太现实）。<br>  在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</p><h1 id="9-Spring-中的-bean-生命周期"><a href="#9-Spring-中的-bean-生命周期" class="headerlink" title="9 Spring 中的 bean 生命周期?"></a>9 Spring 中的 bean 生命周期?</h1><p>  Bean 容器找到配置文件中 Spring Bean 的定义。<br>  Bean 容器利用 Java Reflection API 创建一个Bean的实例。<br>  如果涉及到一些属性值 利用 set()方法设置一些属性值。<br>  如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入Bean的名字。<br>  如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。<br>  如果Bean实现了 BeanFactoryAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoade r对象的实例。<br>  与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。<br>  如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法<br>  如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。<br>  如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。<br>  如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法<br>  当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。<br>  当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</p><h1 id="10-说说自己对于-Spring-MVC-了解"><a href="#10-说说自己对于-Spring-MVC-了解" class="headerlink" title="10 说说自己对于 Spring MVC 了解?"></a>10 说说自己对于 Spring MVC 了解?</h1><p>  Model1 时代<br>    整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作<br>    ①将控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；<br>    ②前端和后端相互依赖，难以进行测试并且开发效率极低；<br>  Model2 时代即JavaWeb MVC<br>    “Java Bean(Model)+ JSP（View,）+Servlet（Controller）<br>    重复造轮子<br>    应运而生比如Struts2但是 Struts2 比较笨重<br>    Spring MVC 使用更加简单和方便<br>    开发效率更高，并且 Spring MVC 运行速度更快。<br>  SpringMVC 工作原理</p><p>  流程说明（重要）：<br>    1：客户端（浏览器）发送请求，直接请求到 DispatcherServlet。<br>    2： DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。<br>    3： 解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。<br>    4：HandlerAdapter 会根据 Handler来调用真正的处理器开处理请求，并处理相应的业务逻辑。<br>    5： 处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。<br>    6： ViewResolver 会根据逻辑 View 查找实际的 View。<br>    7：DispaterServlet 把返回的 Model 传给 View（视图渲染）。<br>    8：把 View 返回给请求者（浏览器）</p><h1 id="11-Spring-框架中用到了哪些设计模式？"><a href="#11-Spring-框架中用到了哪些设计模式？" class="headerlink" title="11 Spring 框架中用到了哪些设计模式？"></a>11 Spring 框架中用到了哪些设计模式？</h1><p>  工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。<br>  代理设计模式 : Spring AOP 功能的实现。<br>  单例设计模式 : Spring 中的 Bean 默认都是单例的。<br>  模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。<br>  包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。<br>  观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。<br>  适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。</p><h1 id="12-Component-和-Bean-的区别是什么？"><a href="#12-Component-和-Bean-的区别是什么？" class="headerlink" title="12 @Component 和 @Bean 的区别是什么？"></a>12 @Component 和 @Bean 的区别是什么？</h1><p>  作用对象不同: @Component 注解作用于类，而@Bean注解作用于方法。<br>  @Component通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了Spring这是某个类的示例，当我需要用它的时候还给我。<br>  @Bean 注解比 Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。</p><h1 id="13-将一个类声明为Spring的-bean-的注解有哪些"><a href="#13-将一个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="13 将一个类声明为Spring的 bean 的注解有哪些?"></a>13 将一个类声明为Spring的 bean 的注解有哪些?</h1><p>  使用 @Autowired 注解自动装配 bean<br>  @Component ：通用的注解，可标注任意类为 Spring 组件。如果一个Bean不知道属于哪个层，可以使用@Component 注解标注。<br>  @Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。<br>  @Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。<br>  @Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</p><h1 id="14-Spring-管理事务的方式有几种？"><a href="#14-Spring-管理事务的方式有几种？" class="headerlink" title="14 Spring 管理事务的方式有几种？"></a>14 Spring 管理事务的方式有几种？</h1><p>  编程式事务，在代码中硬编码。(不推荐使用)<br>  声明式事务，在配置文件中配置（推荐使用）<br>    基于XML的声明式事务<br>    基于注解的声明式事务</p><h1 id="15-Spring-事务中的隔离级别有哪几种"><a href="#15-Spring-事务中的隔离级别有哪几种" class="headerlink" title="15 Spring 事务中的隔离级别有哪几种?"></a>15 Spring 事务中的隔离级别有哪几种?</h1><p>  TransactionDefinition.ISOLATION_DEFAULT<br>    使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.<br>  TransactionDefinition.ISOLATION_READ_UNCOMMITTED<br>    最低的隔离级别，允许读取尚未提交的数据变更<br>    可能会导致脏读、幻读或不可重复读<br>  TransactionDefinition.ISOLATION_READ_COMMITTED<br>    允许读取并发事务已经提交的数据<br>    可以阻止脏读，但是幻读或不可重复读仍有可能发生<br>  TransactionDefinition.ISOLATION_REPEATABLE_READ<br>    对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改<br>    可以阻止脏读和不可重复读，但幻读仍有可能发生。<br>  TransactionDefinition.ISOLATION_SERIALIZABLE<br>    最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，<br>    该级别可以防止脏读、不可重复读以及幻读<br>    严重影响程序的性能。通常情况下也不会用到该级别。</p><h1 id="16-Spring-事务中哪几种事务传播行为"><a href="#16-Spring-事务中哪几种事务传播行为" class="headerlink" title="16 Spring 事务中哪几种事务传播行为?"></a>16 Spring 事务中哪几种事务传播行为?</h1><p>  支持当前事务的情况：<br>    TransactionDefinition.PROPAGATION_REQUIRED<br>        如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。<br>    TransactionDefinition.PROPAGATION_SUPPORTS<br>        如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。<br>    TransactionDefinition.PROPAGATION_MANDATORY<br>        如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）<br>  不支持当前事务的情况：<br>    TransactionDefinition.PROPAGATION_REQUIRES_NEW<br>        创建一个新的事务，如果当前存在事务，则把当前事务挂起。<br>    TransactionDefinition.PROPAGATION_NOT_SUPPORTED<br>         以非事务方式运行，如果当前存在事务，则把当前事务挂起。<br>    TransactionDefinition.PROPAGATION_NEVER<br>        以非事务方式运行，如果当前存在事务，则抛出异常。<br>  其他情况：<br>    TransactionDefinition.PROPAGATION_NESTED<br>        如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</p><h1 id="17-Transactional-rollbackFor-Exception-class-注解了解吗？"><a href="#17-Transactional-rollbackFor-Exception-class-注解了解吗？" class="headerlink" title="17 @Transactional(rollbackFor = Exception.class)注解了解吗？"></a>17 @Transactional(rollbackFor = Exception.class)注解了解吗？</h1><p>  Exception分为运行时异常RuntimeException和非运行时异常<br>  Transactional<br>    如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚<br>    不配置rollbackFor属性，事物只会在遇到RuntimeException的时候才会回滚<br>    加上rollbackFor=Exception.class,可以让事物在遇到非运行时异常时也回滚。</p><h1 id="18-如何使用JPA在数据库中非持久化一个字段？"><a href="#18-如何使用JPA在数据库中非持久化一个字段？" class="headerlink" title="18 如何使用JPA在数据库中非持久化一个字段？"></a>18 如何使用JPA在数据库中非持久化一个字段？</h1><p>  static 修饰<br>  final 修饰<br>  transient 修饰<br>  @Transient 注解修饰</p><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.png" alt>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring常见问题总结&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/wcK2qsZxKDJTLIGqEIyaNg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;引用自&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-什么是-
      
    
    </summary>
    
    
      <category term="面试" scheme="http://iwantjingjing.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="面试" scheme="http://iwantjingjing.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Spring" scheme="http://iwantjingjing.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>精细阅读的杀手锏——SQ3R阅读法</title>
    <link href="http://iwantjingjing.com/2020/04/10/%E7%B2%BE%E7%BB%86%E9%98%85%E8%AF%BB%E7%9A%84%E6%9D%80%E6%89%8B%E9%94%8F%E2%80%94%E2%80%94SQ3R%E9%98%85%E8%AF%BB%E6%B3%95/"/>
    <id>http://iwantjingjing.com/2020/04/10/精细阅读的杀手锏——SQ3R阅读法/</id>
    <published>2020-04-10T06:19:39.000Z</published>
    <updated>2020-04-10T06:47:55.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-什么是SQ3R阅读法"><a href="#一-什么是SQ3R阅读法" class="headerlink" title="一. 什么是SQ3R阅读法"></a>一. 什么是SQ3R阅读法</h1><p>  美国俄亥俄州州立大学心理学教授罗宾逊（F. P. Robinson）<br>  1946年在他的著作Effective Study有所提及<br>  综览（Survey）、发问（Question）、阅读（Read）、背诵（Recite）、复习（Review）</p><h1 id="二-SQ3R阅读法的具体实施步骤"><a href="#二-SQ3R阅读法的具体实施步骤" class="headerlink" title="二. SQ3R阅读法的具体实施步骤"></a>二. SQ3R阅读法的具体实施步骤</h1><h2 id="1-Survey阶段"><a href="#1-Survey阶段" class="headerlink" title="1. Survey阶段"></a>1. Survey阶段</h2><ul><li>封面、扉页、前言</li><li>目录</li><li>各级标题</li><li>开头和结尾</li></ul><h2 id="2-Question阶段"><a href="#2-Question阶段" class="headerlink" title="2. Question阶段"></a>2. Question阶段</h2><ul><li>这本书/这篇文章主要说的什么</li><li>掌握了多少？</li><li>提问贯穿于整个阅读过程</li><li>只要有问题，你都可以用笔或借助电子设备将问题记录下来。</li><li>布朗和基利的《学会提问》</li></ul><h2 id="3-Read阶段"><a href="#3-Read阶段" class="headerlink" title="3.Read阶段"></a>3.Read阶段</h2><pre><code>加粗字段、重点图标阅读难度较高的篇章时要放慢速度。遇到不明白的地方，要停下来，再重读一遍。一次只阅读一小段并背诵那一段。阅读辅助说明的图象。          ——Study Guides and Strategies 博客网站</code></pre><h2 id="4-Recite阶段"><a href="#4-Recite阶段" class="headerlink" title="4. Recite阶段"></a>4. Recite阶段</h2><pre><code>非背诵，而是复述，尽可能多和详细听、说、读、写联想记忆法关键词记忆法谐音等记忆法</code></pre><h2 id="5-Review阶段"><a href="#5-Review阶段" class="headerlink" title="5.  Review阶段"></a>5.  Review阶段</h2><ol><li>Recite后半天Review一次；</li><li>一天后再Review一次；</li><li>三天后再Review一次；</li><li>一个星期后再Review一次；</li><li>一个月后再简单地Review一次。</li></ol><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="%E7%B2%BE%E7%BB%86%E9%98%85%E8%AF%BB%E7%9A%84%E6%9D%80%E6%89%8B%E9%94%8F%E2%80%94%E2%80%94SQ3R.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-什么是SQ3R阅读法&quot;&gt;&lt;a href=&quot;#一-什么是SQ3R阅读法&quot; class=&quot;headerlink&quot; title=&quot;一. 什么是SQ3R阅读法&quot;&gt;&lt;/a&gt;一. 什么是SQ3R阅读法&lt;/h1&gt;&lt;p&gt;  美国俄亥俄州州立大学心理学教授罗宾逊（F. P. R
      
    
    </summary>
    
    
    
      <category term="学习方法" scheme="http://iwantjingjing.com/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>运动改造大脑</title>
    <link href="http://iwantjingjing.com/2020/04/07/%E8%BF%90%E5%8A%A8%E6%94%B9%E9%80%A0%E5%A4%A7%E8%84%91/"/>
    <id>http://iwantjingjing.com/2020/04/07/运动改造大脑/</id>
    <published>2020-04-07T08:02:04.000Z</published>
    <updated>2020-04-07T08:04:51.115Z</updated>
    
    <content type="html"><![CDATA[<p><img src="yundong.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;yundong.png&quot; alt&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="读后感" scheme="http://iwantjingjing.com/categories/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    
      <category term="运动，读后感" scheme="http://iwantjingjing.com/tags/%E8%BF%90%E5%8A%A8%EF%BC%8C%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Java多线程</title>
    <link href="http://iwantjingjing.com/2020/04/03/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJava%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://iwantjingjing.com/2020/04/03/深入浅出Java多线程/</id>
    <published>2020-04-03T11:46:41.000Z</published>
    <updated>2020-04-04T05:00:51.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="进程与线程的基本概念"><a href="#进程与线程的基本概念" class="headerlink" title="进程与线程的基本概念"></a>进程与线程的基本概念</h2><h3 id="进程产生的背景"><a href="#进程产生的背景" class="headerlink" title="进程产生的背景"></a>进程产生的背景</h3><p>指令—》指令集（批处理） </p><p>缺点：串行，效率低</p><p><strong>进程：</strong> 应用程序在内存中分配的空间，正在运行的程序。</p><p> 进程优点： 操作系统并发成为可能。</p><p><strong>线程:</strong> 一个线程执行一个子任务，一个进程包含多个线程。</p><p>优点：让进程的内部并发成为了可能。 </p><p> <strong>多进程的方式也可以实现并发，为什么我们要使用多线程？</strong></p><ul><li>进程通信复杂，线程间可共享资源，通信较线程容易;</li><li>进程重量级，线程轻量级，系统开销小。</li></ul><p><strong>进程线程的区别？</strong></p><ul><li>本质区别：能否单独占有内存空间及其他系统资源（如：I/O);</li><li>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行系统调度的基本单位，即CPU时间的分配单位。</li></ul><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p><strong>上下文：</strong> 某一时间点CPU寄存器和程序计数器的内容。</p><p><strong>上下文切换:</strong> CPU从一个进程/线程切换到另一个进程/线程。</p><p><strong>缺点：</strong> 上先文切换是计算密集型的，消耗大量的CPU时间，故线程也不是越多越好。</p><h2 id="java多线程入门类和接口"><a href="#java多线程入门类和接口" class="headerlink" title="java多线程入门类和接口"></a>java多线程入门类和接口</h2><h3 id="Thread类和Runnable接口"><a href="#Thread类和Runnable接口" class="headerlink" title="Thread类和Runnable接口"></a>Thread类和Runnable接口</h3><p><strong>Java如何实现多线程？</strong></p><ul><li>继承Thread类，并重写run()方法。</li><li>实现Runnable接口的run()方法。</li></ul><p><strong>继承Thread类需注意什么？</strong></p><p>thread.start()方法后，该线程才算启动，调用start()后，虚拟机会先为我们创建一个线程，然后等到这个线程第一次得到时间片时，再调用run()方法。start()不可多次调用，否则抛异常。</p><p><strong>Java8函数式编程</strong></p><pre><code>new Thread(()-&gt;{System.out.println(&quot;java8&quot;);}).start();</code></pre><p><strong>Thread类的构造方法</strong></p><pre><code>Thread(Runnable target)Thread(Runnable target, String name)</code></pre><p><strong>Thread类的几个常用方法</strong></p><pre><code>currentThread(); // 静态方法，返回正在执行线程的引用。start(); // 启动线程。yield(); // 让出当前处理器的占用。sleep(); // 静态方法，休眠。join(); // 当前线程等待另一个线程执行完毕后再继续执行。内部调用的Object.wait()。</code></pre><p><strong>Thread类与Runnable比较？</strong></p><ul><li>Java单继承多实现，Runnable比Thread灵活；</li><li>Runnable更符合面向对象，将线程单独进行对象的封装;</li><li>Runnable降低了线程对象和线程任务的耦合性；</li><li>若不用Thread类诸多方法，Runnable更轻量级，适合实现多线程。</li></ul><h3 id="Callable、Future与FutureTask"><a href="#Callable、Future与FutureTask" class="headerlink" title="Callable、Future与FutureTask"></a>Callable、Future与FutureTask</h3><p><strong>为啥用Callable Future FutureTask?</strong><br>因为Runnable和Thread创建的线程没有返回值。当我们希望开启一个线程执行完一个任务后有返回值则用以上方式（异步模型）。</p><p><strong>Callable特点？</strong></p><ul><li>有返回值，支持泛型</li></ul><p><strong>Callable咋用？</strong></p><pre><code>伪代码 ExecutorService.submit(Callable) return一个Future，通过Future的get方法获取结果。</code></pre><p><strong>Future接口注意项</strong></p><ul><li>cancel() 试图取消，并不一定取消成功。</li></ul><p><strong>FutureTask类总结</strong></p><ul><li>Future类的实现类。</li><li>FutureTask实现了RunnableFuture接口，RunnableFuture同时继承了Runnable接口和Future接口。</li></ul><p><strong>为什么要用FutureTask?</strong><br>高并发下，Callable和FutureTask会创建多次。FutureTask能确保任务只执行一次。</p><p><strong>FutureTask有几个状态?分别是？及其转换关系？</strong><br>六个状态分别是：</p><ul><li>NEW = 0 // 新建</li><li>COMPLETING = 1 // 完成 </li><li>NORMAL = 2 // 正常</li><li>EXCEPTIONAL = 3 // 异常</li><li>CANCELLED = 4  // 取消</li><li>INTERRUPTING = 5 // 打断中</li><li>INTERRUPTED = 6 // 打断了的</li></ul><pre><code>转变路径0 -&gt; 1 -&gt; 20 -&gt; 1 -&gt; 30 -&gt; 40 -&gt; 5 -&gt; 6</code></pre><h2 id="线程组和线程优先级"><a href="#线程组和线程优先级" class="headerlink" title="线程组和线程优先级"></a>线程组和线程优先级</h2><h3 id="线程组（ThreadGroup）"><a href="#线程组（ThreadGroup）" class="headerlink" title="线程组（ThreadGroup）"></a>线程组（ThreadGroup）</h3><p><strong>线程组作用？</strong></p><hr><hr><hr><hr><h2 id="java线程的状态和主要转化方法"><a href="#java线程的状态和主要转化方法" class="headerlink" title="java线程的状态和主要转化方法"></a>java线程的状态和主要转化方法</h2><h2 id="Java线程间的通信"><a href="#Java线程间的通信" class="headerlink" title="Java线程间的通信"></a>Java线程间的通信</h2><h1 id="Java内存模型基础知识"><a href="#Java内存模型基础知识" class="headerlink" title="Java内存模型基础知识"></a>Java内存模型基础知识</h1><h2 id="Java内存模型基础知识-1"><a href="#Java内存模型基础知识-1" class="headerlink" title="Java内存模型基础知识"></a>Java内存模型基础知识</h2><h2 id="重排序与happens-before"><a href="#重排序与happens-before" class="headerlink" title="重排序与happens-before"></a>重排序与happens-before</h2><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h2 id="synchronized与锁"><a href="#synchronized与锁" class="headerlink" title="synchronized与锁"></a>synchronized与锁</h2><h2 id="CAS与原子操作"><a href="#CAS与原子操作" class="headerlink" title="CAS与原子操作"></a>CAS与原子操作</h2><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h1 id="JDK工具"><a href="#JDK工具" class="headerlink" title="JDK工具"></a>JDK工具</h1><h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><h2 id="锁接口和类"><a href="#锁接口和类" class="headerlink" title="锁接口和类"></a>锁接口和类</h2><h2 id="并发集合容器简介"><a href="#并发集合容器简介" class="headerlink" title="并发集合容器简介"></a>并发集合容器简介</h2><h2 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h2><h2 id="通信工具类"><a href="#通信工具类" class="headerlink" title="通信工具类"></a>通信工具类</h2><h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h2><h2 id="Java8-Stream并行计算原理"><a href="#Java8-Stream并行计算原理" class="headerlink" title="Java8 Stream并行计算原理"></a>Java8 Stream并行计算原理</h2><h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础篇&quot;&gt;&lt;a href=&quot;#基础篇&quot; class=&quot;headerlink&quot; title=&quot;基础篇&quot;&gt;&lt;/a&gt;基础篇&lt;/h1&gt;&lt;h2 id=&quot;进程与线程的基本概念&quot;&gt;&lt;a href=&quot;#进程与线程的基本概念&quot; class=&quot;headerlink&quot; title=&quot;进
      
    
    </summary>
    
    
      <category term="java" scheme="http://iwantjingjing.com/categories/java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="多线程" scheme="http://iwantjingjing.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="http://iwantjingjing.com/2020/03/29/JVM/"/>
    <id>http://iwantjingjing.com/2020/03/29/JVM/</id>
    <published>2020-03-29T07:51:15.000Z</published>
    <updated>2020-03-29T09:04:42.935Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一讲-初识JVM"><a href="#第一讲-初识JVM" class="headerlink" title="第一讲 初识JVM"></a>第一讲 初识JVM</h1><h2 id="JVM概念"><a href="#JVM概念" class="headerlink" title="JVM概念"></a>JVM概念</h2><p><img src="1585469351029.jpg" alt></p><h2 id="JVM发展历史"><a href="#JVM发展历史" class="headerlink" title="JVM发展历史"></a>JVM发展历史</h2><p><img src="WeChat59fc87098feb0906afe9f7c2ff0cfda4.png" alt><br><img src="1585469738770.jpg" alt><br><img src="1585469850194.jpg" alt><br><img src="1585469974766.jpg" alt></p><h2 id="JVM种类"><a href="#JVM种类" class="headerlink" title="JVM种类"></a>JVM种类</h2><p><img src="1585470188832.jpg" alt><br><img src="1585470274411.jpg" alt></p><h2 id="JAVA语言规范"><a href="#JAVA语言规范" class="headerlink" title="JAVA语言规范"></a>JAVA语言规范</h2><ul><li>语法</li><li>变量</li><li>类型</li><li>文法</li></ul><p><img src="1585471088237.jpg" alt><br><img src="1585471162424.jpg" alt><br><img src="1585471242571.jpg" alt><br><img src="1585472002039.jpg" alt><br><img src="1585472131986.jpg" alt></p><h2 id="JVM规范"><a href="#JVM规范" class="headerlink" title="JVM规范"></a>JVM规范</h2><ul><li>Class文件类型</li><li>运行时数据</li><li>帧栈</li><li>虚拟机的启动</li><li>虚拟机的指令集</li></ul><p><img src="1585472274370.jpg" alt></p><p>Class 文件格式<br>数字的内部表示和存储<br>Byte  -128 to 127 (-27 to 27 - 1)<br>returnAddress 数据类型定义<br>指向操作码的指针。不对应Java数据类型，不能在运行时修改。Finally实现需要<br>定义PC<br>堆<br>栈<br>方法区</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一讲-初识JVM&quot;&gt;&lt;a href=&quot;#第一讲-初识JVM&quot; class=&quot;headerlink&quot; title=&quot;第一讲 初识JVM&quot;&gt;&lt;/a&gt;第一讲 初识JVM&lt;/h1&gt;&lt;h2 id=&quot;JVM概念&quot;&gt;&lt;a href=&quot;#JVM概念&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="jvm" scheme="http://iwantjingjing.com/categories/jvm/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="jvm" scheme="http://iwantjingjing.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>面试准备</title>
    <link href="http://iwantjingjing.com/2020/03/28/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <id>http://iwantjingjing.com/2020/03/28/面试准备/</id>
    <published>2020-03-28T08:08:52.000Z</published>
    <updated>2020-03-29T07:32:35.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><hr><ol><li><ul><li></li></ul></li></ol><h3 id="缓存雪崩-多个key过期"><a href="#缓存雪崩-多个key过期" class="headerlink" title="缓存雪崩(多个key过期)"></a>缓存雪崩(多个key过期)</h3><p><strong>缓存雪崩</strong>：</p><p>我们可以简单的理解为：由同一时间热点缓存大面积失效，(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p><p><strong>解决办法</strong>：</p><blockquote><p>大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时将缓存失效时间分散开。</p><p>或者设置热点数据永不过期，有更新操作的时候更新下缓存，电商首页用这个策略，保险</p></blockquote><h3 id="缓存击穿（当单个key过期）"><a href="#缓存击穿（当单个key过期）" class="headerlink" title="缓存击穿（当单个key过期）"></a>缓存击穿（当单个key过期）</h3><p><strong>问题：</strong>一些设置了过期时间的key，这些key可能会在某些时间点被超高并发访问，是一种非常热点的数据，这个时候请求发现缓存过期了，会直接读取db，大并发可能会搞垮db</p><p><strong>解决方案0：</strong>热点数据永不过期</p><p><strong>解决方案</strong>1：使用互斥锁：（SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。）</p><p>业界比较常用的方式是使用metex。简单的来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（setnx）去set一个mutex key，当操作成功时，再进行load db的操作并设置缓存，否则就重试整个get缓存的方法</p><p>优点：思路简单、保证一致性</p><p>缺点：代码复杂度增大、存在死锁的风险</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;  </span><br><span class="line">   String value = redis.get(key);  </span><br><span class="line">   <span class="keyword">if</span> (value  == <span class="keyword">null</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="string">"1"</span>)) &#123;  </span><br><span class="line">        <span class="comment">// 3 min timeout to avoid mutex holder crash  </span></span><br><span class="line">        redis.expire(key_mutex, <span class="number">3</span> * <span class="number">60</span>)  </span><br><span class="line">        value = db.get(key);  </span><br><span class="line">        redis.set(key, value);  </span><br><span class="line">        redis.delete(key_mutex);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">//其他线程休息50毫秒后重试  </span></span><br><span class="line">        Thread.sleep(<span class="number">50</span>);  </span><br><span class="line">        get(key);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案2：</strong>异步构建缓存</p><p>在这种方案下，构建缓存采取异步策略，会从线程池中取线程来异步构建缓存，从而不会让所有的请求直接怼到数据库上。该方案redis自己维护一个timeout，当timeout小于System.currentTimeMillis()时，则进行缓存更新，否则直接返回value值。</p><p>优点：用户无需等待</p><p>缺点：无法保证缓存一致性</p><p>集群环境的redis代码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;  </span><br><span class="line">        V v = redis.get(key);  </span><br><span class="line">        String value = v.getValue();  </span><br><span class="line">        <span class="keyword">long</span> timeout = v.getTimeout();  </span><br><span class="line">        <span class="keyword">if</span> (v.timeout &lt;= System.currentTimeMillis()) &#123;  </span><br><span class="line">            <span class="comment">// 异步更新后台异常执行  </span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                    String keyMutex = <span class="string">"mutex:"</span> + key;  </span><br><span class="line">                    <span class="keyword">if</span> (redis.setnx(keyMutex, <span class="string">"1"</span>)) &#123;  </span><br><span class="line">                        <span class="comment">// 3 min timeout to avoid mutex holder crash  </span></span><br><span class="line">                        redis.expire(keyMutex, <span class="number">3</span> * <span class="number">60</span>);  </span><br><span class="line">                        String dbValue = db.get(key);  </span><br><span class="line">                        redis.set(key, dbValue);  </span><br><span class="line">                        redis.delete(keyMutex);  </span><br><span class="line">                   &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案3：</strong></p><p>布隆过滤器</p><p>优点：思路简单、保证一致性、性能强</p><p>缺点：代码复杂度增大、需要另外维护一个集合来存放缓存的key、不支持删值操作</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>问题：</strong>查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果db查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到db去，在流量大时，db可能就挂掉了</p><p>比如说：查询一个不存在id都是1开始自增上去的，如果查询一个id为-1的值</p><p><strong>解决方案：</strong></p><ol start="0"><li>接口添加校验，比如用户鉴权，参数合法校验，比如id&lt;0的直接拦截等。</li></ol><p>1.最常见的就是布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力</p><p>2.更简单粗暴的方法：如果一个查询返回的数据为空（不管数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，设置一个比较短的过期时间</p><h3 id="双写一致问题"><a href="#双写一致问题" class="headerlink" title="双写一致问题"></a>双写一致问题</h3><p>数据库跟缓存同时操作肯定会出现不一致的问题</p><p>解决方案：延时双删策略</p><p>先删除redis，更新数据库，删除redis</p><p>参考文章：<a href="https://www.cnblogs.com/rjzheng/p/9041659.html" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/9041659.html</a></p><h3 id="redis与memcached有什么区别？为什么选用redis作为缓存的中间件"><a href="#redis与memcached有什么区别？为什么选用redis作为缓存的中间件" class="headerlink" title="redis与memcached有什么区别？为什么选用redis作为缓存的中间件"></a>redis与memcached有什么区别？为什么选用redis作为缓存的中间件</h3><ol><li>redis支持复杂结构，如果需要缓存支持复杂的结构和操作，redis 是不错的选择</li><li>redis原生支持集群模式：memcached需要依赖客户端来实现往集群中分片写入数据。</li></ol><h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h4><p>redis只是用单核，而memcached可以使用多核，所有平均每一个核上redis在存储小数据时比memcached性能更高，而在100k以上的数据中，memcached性能要高于redis</p><h3 id="redis线程模型"><a href="#redis线程模型" class="headerlink" title="redis线程模型"></a>redis线程模型</h3><p>内部使用文件事件处理器 file event handler，这个是单线程的，所以redis才叫单线程的模型，它采用io多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器进行处理。</p><blockquote><p>文件事件处理器，结构包括四个部分：</p><ul><li>多个socket</li><li>io多路复用程序</li><li>文件时间分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul></blockquote><h3 id="Redis有哪些数据结构啊？"><a href="#Redis有哪些数据结构啊？" class="headerlink" title="Redis有哪些数据结构啊？"></a>Redis有哪些数据结构啊？</h3><blockquote><p>String、Hash、List、Set、SortedSet</p><p>以上五个基本类型，如果你是中高级用户的话，还有HyperLogLog、Geo、Pub、Sub</p><p>如果还想加分，还可以说玩过Redis Module，像BloomFilter、RedisSearch、Redis-ML</p></blockquote><h3 id="如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h3><blockquote><p>如果过期时间设置的过于集中，到过期的时候，Redis可能会出现短暂的卡顿现象，严重的话会出现缓存雪崩，一般在时间上加一个随机值，使得过期时间分散一些</p><p>电商首页经常会使用定时任务刷新缓存，可能大量的数据失效时间都十分集中，如果失效时间一样，又刚好在失效的时间点涌入大量访问，就可能缓存雪崩</p></blockquote><h3 id="你使用过Redis分布式锁么，它是怎么回事？"><a href="#你使用过Redis分布式锁么，它是怎么回事？" class="headerlink" title="你使用过Redis分布式锁么，它是怎么回事？"></a>你使用过Redis分布式锁么，它是怎么回事？</h3><blockquote><p>先拿setnx来争抢锁，抢到之后，再用Expire给锁加一个过期时间防止锁忘记释放。</p></blockquote><h4 id="如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？"><a href="#如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？" class="headerlink" title="如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？"></a>如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？</h4><blockquote><p>这个时候你一定要给予惊讶的反馈，是哦，这个锁就永远得不到释放了，紧接着，你抓了抓自己的头发，故作思考：我记得set指令有个非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的</p></blockquote><h3 id="假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？"><a href="#假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？" class="headerlink" title="假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？"></a>假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？</h3><blockquote><p>使用keys指令可以扫出指定模式的key列表</p></blockquote><p><strong>继续追问：如果这个redis正在给线上的业务提供服务，那么使用keys指令会有什么问题?</strong></p><blockquote><p>redis是单线程的，使用keys会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，这个时候可以使用<strong><u>scan</u></strong>指令，<strong><u>scan</u></strong>指令可以无阻塞的取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，单整体花费的时间会比直接使用keys指令长</p></blockquote><h3 id="redis是怎么持久化的？服务主从数据是怎么交互的？"><a href="#redis是怎么持久化的？服务主从数据是怎么交互的？" class="headerlink" title="redis是怎么持久化的？服务主从数据是怎么交互的？"></a>redis是怎么持久化的？服务主从数据是怎么交互的？</h3><blockquote><p>rdb做镜像全量持久化，aof做增量持久化。因为rdb会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用rdb持久化文件重构内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态</p><p>这里很好理解的，把rdb理解为一整个表全量的数据，aof理解为每次操作的日志就好了，服务器重启的时候先把表的数据全部搞进去，但是可能不完整，这个时候再回放一下日志，数据不就完整了嘛。不过redis本身的机制是aof持久化开启且存在aof文件时，优先加载aof文件；aof关闭或者aof文件不存在时，加载rdb文件；加载aof/rdb文件成功后，redis启动成功；aof/rdb文件存在错误时，redis启动失败并打印错误信息</p></blockquote><p><strong>对方追问如果突然机器停电会怎样?</strong></p><blockquote><p>取决于aof日志sync属性的配置，如果不要求心梗，在每一条写指令时都sync一下磁盘，就不会丢失数据，但是在高性能要求下每次都sync是不现实的，一般都使用定时sync，比如1s/1次，这个时候最多就会丢失1s的数据</p></blockquote><p><strong>对方继续追问rdb的原理是什么？</strong></p><blockquote><p>这个问题给出两个词汇就可以了，fork和cow。fork是指redis通过创建子进程来进行rdb操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会主键和子进程分离开来</p></blockquote><p><strong>Pipeline有什么好处，为什么要用Pipeline？</strong></p><blockquote><p>可以将多次io往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目</p></blockquote><blockquote></blockquote><p><strong>是否使用过redis集群，集群的高可用怎么保证，集群的原理是什么？</strong></p><blockquote><p>redis Sentinel着眼于高可用，在master宕机时会自动将slave升级为master，继续提供服务 。</p><p>redis cluster 着眼于扩展性，在单个redis内存不足时，使用cluster进行分片存储</p></blockquote><h3 id="哨兵、持久化、主从、手撕LRU"><a href="#哨兵、持久化、主从、手撕LRU" class="headerlink" title="哨兵、持久化、主从、手撕LRU"></a>哨兵、持久化、主从、手撕LRU</h3><p>在上面了解完基础知识已经一些缓存的常见问题之后，聊聊下面的</p><p><strong>为什么redis那么快</strong></p><blockquote><p>先看一下关系型数据库跟redis本质上的区别，如下图：</p><img src="img/面试准备.assets/image-20200224174728652.png" alt="image-20200224174728652" style="zoom:50%;"><p>Redis采用的是<strong>单进程单线程</strong>模型的kv数据库，由c编写，官方提供的数据是达到10w的qps（每秒内查询次数）</p><ul><li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快。数据存在内存中，类似于<strong>HashMap</strong>，HashMap的优势就是查找和操作的时间复杂度都是O(1);</li><li>数据结构简单，对数据操作也简单，redis中的数据结构是专门进行设计的</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换消耗，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</li><li>使用多路i/o复用模型，非阻塞io；</li><li>使用底层模型不同，他么之间底层实现方式以及与客户端之间通信的应用协议不一样，redis直接自己构建了vm机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</li></ul></blockquote><p><strong>我可以问一下啥是上下文切换吗？为啥可能线程不安全？</strong></p><blockquote><p>好比你看一本英文书，你看到第十页发现有个单词不会，你加了个书签，然后去查字典，过了一会你回来继续从书签那里读，ok目前为止没问题。</p><p>问题来了，你去查字典的时候，别人过来翻了一下你的书，然后走了，然后你回来了，你再看书的时候发现书不是你看的那一页了。</p></blockquote><p><strong>那他是单线程，我们服务器都是多核的，那不是浪费吗？</strong></p><blockquote><p>虽然他是单线程的，但是我们可以单机开多个实例啊</p></blockquote><p><strong>既然提到了单机会有瓶颈，那你们是怎么解决这个瓶颈的？</strong></p><blockquote><p>我们用到了集群的部署方式也就是redis cluster,并且是主从同步读写分离，类似Mysql的主从同步，Redis cluster支撑n个redis mater node，并且每个master node 都可以挂载多个salve node</p><p>这样整个Redis就可以横向扩容了，如果你要吃成更大数据量的缓存，那就横向扩容更多的master节点，每个master节点就能存放更多的数据了。</p></blockquote><p><strong>那么问题来了，他们之间是怎么进行数据交互的？以及redis 是怎么进行持久化的？Redis数据都在内存中，一断电或者重启不就木有了吗？</strong></p><blockquote><p>是的，持久化的话是redis高可用中的重要一点，因为redis数据在内存的特性，持久化必须有，我了解方式有两种：</p><p><strong>RDB：</strong>是对redis中的数据进行周期性的持久化</p><p><strong>AOF：</strong>对每条写入命令作为日志，以[只追加]【append-only】的方式写入到一个日志文件中，没有任何磁盘寻址的开销，所以很快，有点像mysql中binlog</p><p>这两种方式都可以把redis内存中的数据持久化到磁盘上，rdb更适合做冷备，aof更适合做热备</p><p><strong>tip</strong>：两种机制全部开启的时候，redis在重启的时候回默认使用aof去重新构建数据，因为aof的数据是比rdb更完整的</p></blockquote><p><strong>那这两种机制各自优缺点是啥？</strong></p><blockquote><p><strong>RDB</strong></p><p><strong>优点：</strong></p><p>会生成多个数据文件，每个数据文件都代表了某一时刻redis里面的数据，这种方式，很适合做冷备</p><p>rdb对redis性能影响较小，是因为在同步时候他只是fork了一个子进程去做持久化的，而且他在数据恢复的时候速度比aof来得快</p><p><strong>缺点：</strong></p><p>rdb都是快照文件，都是默认五分钟甚至更久的时间才生成一次，意味着两次同步之间五分钟的数据可能全部丢失，aof则最多丢1秒的数据</p><p>还有就是rdb在生成数据快照的时候，如果文件很大， 客户端可能会暂停几毫秒甚至几秒，你公司在做秒杀的时候它刚搞在这个时候fork了一个子进程去生成一个大快照</p><p><strong>AOF</strong></p><p><strong>优点：</strong>一秒生成一个，只追加的方式写，性能惊人</p><p><strong>缺点：</strong></p><p>一样的数据aof文件比rdb还要大，aof开启后redis支持写的qps会比rdb支持写的要低</p></blockquote><p><strong>那两者如何选择呢？</strong></p><blockquote><p>两个都要，出现事故，第一时间用rdb恢复，在用aof补全</p></blockquote><p><strong>Redis还有其他保证集群高可用的方式吗？</strong></p><blockquote><p>还要哨兵集群sentinel（森提nou）</p><p>哨兵必须用三个实例去保证自己的健壮性，哨兵+主从并不能保证数据不丢失，但是可以保证集群的高可用</p><p>一个机器挂了，剩下两个机器需要选举出来一个执行故障转移，如果只有两台机器的话，挂了一个就剩下一个了，没有哨兵去允许故障转移了</p></blockquote><p>Redis<strong>的同步机制</strong></p><blockquote><p>redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存，加载完成后，通知主节点将期间修改的操作记录同步到点进行重放就完成了同步过程。后续的增量数据通过aof日志同步即知，有点类似数据库的binlog。</p></blockquote><p><strong>说一下他的内存淘汰机制</strong></p><blockquote><p>Redis的过期策略有两种，<strong>定期删除</strong>+<strong>惰性删除</strong></p><p><strong>定期删除：</strong>默认100ms就随意抽一些设置了过期时间的key，检查是否过期，过期就删除</p><p>为什么不扫描全部设置了过期时间的key呢？</p><blockquote><p>因为太慢，浪费资源</p></blockquote><p>如果没随机到很多key，里面不就存在大量的无效key了？</p><blockquote><p>好问题，不是还有惰性删除吗</p></blockquote><p><strong>惰性删除：</strong>我不主动删，我懒，等你来查询了，我看看有没有过期，过期就删了还不给你返回，没过期就那么挂着</p></blockquote><h3 id="1-13-双写一致性、并发竞争、线程模型"><a href="#1-13-双写一致性、并发竞争、线程模型" class="headerlink" title="1.13 双写一致性、并发竞争、线程模型"></a>1.13 双写一致性、并发竞争、线程模型</h3><h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引有哪些数据结构"><a href="#索引有哪些数据结构" class="headerlink" title="索引有哪些数据结构"></a>索引有哪些数据结构</h3><p>Hash、B+</p><p>去创建索引的时候，可以选择索引的类型</p><h3 id="为什么hash、完全平衡二叉树、b树、b-树都可以优化查询，mysql为什么喜欢b-树？"><a href="#为什么hash、完全平衡二叉树、b树、b-树都可以优化查询，mysql为什么喜欢b-树？" class="headerlink" title="为什么hash、完全平衡二叉树、b树、b+树都可以优化查询，mysql为什么喜欢b+树？"></a>为什么hash、完全平衡二叉树、b树、b+树都可以优化查询，mysql为什么喜欢b+树？</h3><p>先说hash索引，字段值所对应的数据下标是哈希随机算出来的，可能会出现hash冲突。</p><p>举例：where name = ‘鸡蛋’，“鸡蛋”可以直接hash出他的数组下标，然后直接从数据中取出来</p><p>举例2：where name &gt;’鸡蛋’，那么hash表就无能为力了，他可以精确查询，但是不支持范围查询，就算做成索引，速度也很慢，要扫全表。</p><h4 id="hash表的适合场景？"><a href="#hash表的适合场景？" class="headerlink" title="hash表的适合场景？"></a>hash表的适合场景？</h4><p>hash表是无序的。</p><p>redis、Memcached这些nosql的中间件。kv结构的</p><h4 id="说的是无序的hash表，有没有有序的结构？"><a href="#说的是无序的hash表，有没有有序的结构？" class="headerlink" title="说的是无序的hash表，有没有有序的结构？"></a>说的是无序的hash表，有没有有序的结构？</h4><p>有序数组，等值查询和范围查询都很好</p><p><strong>缺点：</strong>适合做静态数据，因为增删改会改变他的结构</p><p><strong>适用：</strong>静态存储的索引啊，比如说2019年的支付宝账单，等等历史记录，都是不会变动的数据</p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>二叉树是有序的，所以支持范围查询，但是时间复杂度是o(log(n)),为了维持这个时间复杂度，更新的时间复杂度也得是o(log(n))，那就得保持这棵树是完全平衡二叉树了</p><p>索引页不止在内存里存储的，也要落盘持久化的，如果数据多了，树就很高了，查询成本随着树变高而高</p><p>如果公司为了节约成本用的机械盘，来一次千万级别的查询，那不得慢死了</p><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p><img src="https://user-gold-cdn.xitu.io/2020/3/8/170baaef95fc7c13?imageslim" alt="img"></p><p>b树比完全平衡二叉树要矮，原因是b树中的一个节点可以存储多个元素</p><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p><img src="https://user-gold-cdn.xitu.io/2020/3/8/170baaef96c4dc05?imageslim" alt="img"></p><p>同样的元素，b+树会比b树要“胖”，原因在于B+树中的非叶子节点会冗余一份在叶子节点中，并且叶子节点之间用指针相连</p><h4 id="B-树-优势"><a href="#B-树-优势" class="headerlink" title="B+树 优势"></a>B+树 优势</h4><p>Hash不支持范围查询</p><p>二叉树太高</p><p>只有B树可以跟b+比一比</p><p>b树一个节点存储多个元素，相对于完全平衡二叉树的树高整体降低了，磁盘io效率提高了</p><p>b+树是b树的升级版，只是把非叶子节点冗余一下，这样可以提高范围查找的效率：原因是会有指针指向下一个节点的叶子节点</p><h4 id="一个b-树节点可以存储多少个元素？"><a href="#一个b-树节点可以存储多少个元素？" class="headerlink" title="一个b+树节点可以存储多少个元素？"></a>一个b+树节点可以存储多少个元素？</h4><p>懵逼，换个角度，b+树中一个节点到底多大合适？</p><p>b+树中一个节点为一页或者页的倍数最合适</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p><strong>是什么?</strong></p><p>大概就是有个主键为ID的索引，和一天个普通字段 name 的索引，我们在普通字段上搜索：</p><p>select  * from table where name = ‘“丙丙”</p><p>执行的流程是：先查询name索引上的“丙丙”，然后找到他id是2，最后去主键索引，找到id为2对应的值。</p><p>回到主键索引树搜索的过程，就是回表。</p><p>覆盖索引可以避免回表</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p><strong>是什么？</strong></p><p>比如说刚才的 select * ，查询所有的，如果我们只是需要id，那么其实name字段的索引上就已经有了，就不需要回表了</p><p>很多联合索引的建立，就是为了支持覆盖索引，特定的业务能极大的提升效率</p><h3 id="char-、varchar的区别是什么？"><a href="#char-、varchar的区别是什么？" class="headerlink" title="char 、varchar的区别是什么？"></a>char 、varchar的区别是什么？</h3><p>varchar 是变长，而char是长度固定的，如果你的内容是固定大小的，使用char性能更好</p><h3 id="truncate与delete的区别是什么？"><a href="#truncate与delete的区别是什么？" class="headerlink" title="truncate与delete的区别是什么？"></a>truncate与delete的区别是什么？</h3><p>truncate 是永久删出表中的每一行，且不可恢复</p><h3 id="什么是触发器？"><a href="#什么是触发器？" class="headerlink" title="什么是触发器？"></a>什么是触发器？</h3><p>触发器是指一段代码，当触发某个事件时，自动执行这些代码。在mysql数据库中有如下6种触发器：1.Before Insert 2.After Insert 3.Before Update 4.After Update 5.Before Delete 6.After Delete</p><h3 id="float与double的区别是什么？"><a href="#float与double的区别是什么？" class="headerlink" title="float与double的区别是什么？"></a>float与double的区别是什么？</h3><p>fioat存储至多8位十进制数，内存占用4字节</p><p>double存储至多18位十进制数，内存占用8字节</p><h3 id="如果在mysql获取当前日期"><a href="#如果在mysql获取当前日期" class="headerlink" title="如果在mysql获取当前日期"></a>如果在mysql获取当前日期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select current_date();</span><br></pre></td></tr></table></figure><h3 id="如何查询第n高的工资"><a href="#如何查询第n高的工资" class="headerlink" title="如何查询第n高的工资"></a>如何查询第n高的工资</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct(salary) from employee order by salary Desc limit n-1,1</span><br></pre></td></tr></table></figure><h3 id="请说明innodb和mylsam的区别"><a href="#请说明innodb和mylsam的区别" class="headerlink" title="请说明innodb和mylsam的区别"></a>请说明innodb和mylsam的区别</h3><blockquote><p>innodb，支持事务</p><p>innodb，支持崩溃后的恢复</p></blockquote><h3 id="请列举三个以上表引擎"><a href="#请列举三个以上表引擎" class="headerlink" title="请列举三个以上表引擎"></a>请列举三个以上表引擎</h3><p>innodb 、MylSAM、Memory</p><h3 id="varchar和text的区别"><a href="#varchar和text的区别" class="headerlink" title="varchar和text的区别"></a>varchar和text的区别</h3><ul><li>varchar可以指定字符数，text不能指定</li><li>内部存储varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节（n&gt;255）,text是实际字符数+2个字节</li><li>text不能有默认值,默认值为null</li><li>varchar可以直接创建索引，text创建索引要指定前多少个字符，varchar查询速度快于text，在都创建索引的情况下，text的索引几乎不起作用。</li><li>查询text需要创建临时表</li></ul><h3 id="varchar（50）中50的含义"><a href="#varchar（50）中50的含义" class="headerlink" title="varchar（50）中50的含义"></a>varchar（50）中50的含义</h3><p>最多存放50个字符</p><p>varchar（50）和（200）存储“hello”所占用的空间是一样的，但是200在排序时会消耗更多内存。</p><h3 id="int（20）中20的含义"><a href="#int（20）中20的含义" class="headerlink" title="int（20）中20的含义"></a>int（20）中20的含义</h3><p>是指显示字符的长度，不影响内部存储，只是当定义了ZEROFILL时，前面补多少个0</p><h3 id="索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响？"><a href="#索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响？" class="headerlink" title="索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响？"></a>索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响？</h3><ol><li>唯一索引：数据列不允许重复，可以null，一个表可以创建多个</li><li>主键索引：一定是唯一索引，不允许null，一个表只能有一个</li><li>主键可以与外键构成曹肇完整性约束，防止数据不一致。</li><li>联合索引：将多个列组合在一起创建索引，可以覆盖多个列。</li><li>外检索引：基本不用，只有innodb类型的表才可以使用</li><li>全文索引：mysql自带的全文索引只能用于mylSAM，并且只能对英文进行全文检索（基本不用）</li></ol><h3 id="最左前缀"><a href="#最左前缀" class="headerlink" title="最左前缀"></a>最左前缀</h3><p>顾名思义，就是最左优先，在创建多列索引时，需要根据业务需求，where字句中使用最频繁的一列放在最左边。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">以 index(a,b,c) 为例,(注意和顺序有关)</span><br><span class="line">where a=2 可以用到索引</span><br><span class="line">where a=1 and b=2 可以用到索引</span><br><span class="line">where a=1 and b=2 and c=3 可以用到索引</span><br><span class="line">where b=1 / c=1 不能用到索引</span><br><span class="line">where a=1 and c=1 a可以发挥索引，c不能使用到索引</span><br><span class="line">where a=1 and b&gt;10 and c=1 a可以发挥索引，b也可以发挥索引，c不能发挥索引</span><br><span class="line">where a=1 and b like &apos;xxx%&apos; and c=1 a可以发挥索引，b可以发挥索引，c不能发挥索引</span><br></pre></td></tr></table></figure><ol><li>组合索引的生效原则是 从前往后依次使用生效，如果中间某个索引没有使用，那么断点前面的索引部分起作用，断点后面的索引没有起作用；</li></ol><h2 id="联合索引最左匹配原则"><a href="#联合索引最左匹配原则" class="headerlink" title="联合索引最左匹配原则"></a>联合索引最左匹配原则</h2><h4 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a><strong>最左前缀匹配原则</strong></h4><p>在mysql建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，示例：<br>对列col1、列col2和列col3建一个联合索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY test_col1_col2_col3 on test(col1,col2,col3);</span><br></pre></td></tr></table></figure><p>联合索引 test_col1_col2_col3 实际建立了(col1)、(col1,col2)、(col,col2,col3)三个索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM test WHERE col1=“1” AND clo2=“2” AND clo4=“4”</span><br></pre></td></tr></table></figure><p>上面这个查询语句执行时会依照最左前缀匹配原则，检索时会使用索引(col1,col2)进行数据匹配。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h4><p>索引的字段可以是任意顺序的，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM test WHERE col1=“1” AND clo2=“2”</span><br><span class="line">SELECT * FROM test WHERE col2=“2” AND clo1=“1”</span><br></pre></td></tr></table></figure><p>这两个查询语句都会用到索引(col1,col2)，mysql创建联合索引的规则是首先会对联合合索引的最左边的，也就是第一个字段col1的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个字段col2进行排序。其实就相当于实现了类似 order by col1 col2这样一种排序规则。</p><p>有人会疑惑第二个查询语句不符合最左前缀匹配：首先可以肯定是两个查询语句都包含索引(col1,col2)中的col1、col2两个字段，只是顺序不一样，查询条件一样，最后所查询的结果肯定是一样的。既然结果是一样的，到底以何种顺序的查询方式最好呢？此时我们可以借助mysql查询优化器explain，explain会纠正sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。</p><h4 id="为什么要使用联合索引"><a href="#为什么要使用联合索引" class="headerlink" title="为什么要使用联合索引"></a><strong>为什么要使用联合索引</strong></h4><ul><li><strong>减少开销</strong>。建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！</li><li><strong>覆盖索引</strong>。对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。</li><li><strong>效率高</strong>。索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select <em>from table where col1=1 and col2=2 and col3=3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W<em>10%=100w条数据，然后再回表从100w条数据中找到符合col2=2 and col3= 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w</em>10%</em> 10% *10%=1w，效率提升可想而知！</li></ul><h4 id="引申"><a href="#引申" class="headerlink" title="引申"></a><strong>引申</strong></h4><p>对于联合索引(col1,col2,col3)，查询语句SELECT * FROM test WHERE col2=2;是否能够触发索引？<br>大多数人都会说NO，实际上却是YES。<br><strong>原因</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test WHERE col2=2;</span><br><span class="line">EXPLAIN SELECT * FROM test WHERE col1=1;</span><br></pre></td></tr></table></figure><p>观察上述两个explain结果中的type字段。查询中分别是：</p><ol><li>type: index</li><li>type: ref</li></ol><p><strong>index</strong>：这种类型表示mysql会对整个该索引进行扫描。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个<strong>联合索引的一部分</strong>，mysql都可能会采用index类型的方式扫描。但是呢，缺点是效率不高，mysql会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引。所以，上述语句会触发索引。</p><p><strong>ref</strong>：这种类型表示mysql会根据特定的算法快速查找到某个符合条件的索引，而不是会对索引中每一个数据都进行一一的扫描判断，也就是所谓你平常理解的使用索引查询会更快的取出数据。而要想实现这种查找，索引却是有要求的，要实现这种能快速查找的算法，索引就要满足特定的数据结构。简单说，<strong>也就是索引字段的数据必须是有序的，才能实现这种类型的查找，才能利用到索引。</strong></p><h4 id="索引算法"><a href="#索引算法" class="headerlink" title="索引算法"></a><strong>索引算法</strong></h4><p>btree是最常用的，也是mysql默认的算法，因为它不仅仅可以用在=、&gt;、&gt;=、&lt;、&lt;=和between这些比较操作符上，也可以用于like操作符，只要他的查询条件不是一通配符开头的常量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name like ‘jack%’---使用索引</span><br><span class="line">select * from user where name like ‘%jack’---不使用索引</span><br></pre></td></tr></table></figure><p>hash索引只能用于对等比较，例如=、&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像btree索引需要从根节点到枝节点，最后才能访问到叶节点这样多次io访问，所以hash索引的效率远高于btree索引</p><h4 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a><strong>索引的设计原则</strong></h4><ol><li>适合索引的列是出现在where字句中的列，或者连接字句中指定的列</li><li>基数较小的列，索引效果差，没必要在此列建立索引</li><li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</li><li>不要过度索引，占用额外的磁盘空间，并降低写操作的性能。在修改表能容的时候，索引进行更新甚至重构</li></ol><h4 id="mysql中in-和exists区别"><a href="#mysql中in-和exists区别" class="headerlink" title="mysql中in 和exists区别"></a><strong>mysql中in 和exists区别</strong></h4><ol><li>如果查询的两个表大小想打，那么in和exists差别不大</li><li>如果一个小表，一个大表，则子查询表大的用exists，子查询表小的用in</li><li>not in 和 not exists 如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not exists 的子查询依然能用到表上的索引。所以无论哪个表达，用not exists 都比not in 要快</li></ol><h2 id="mysql的关联查询语句有哪些？"><a href="#mysql的关联查询语句有哪些？" class="headerlink" title="mysql的关联查询语句有哪些？"></a>mysql的关联查询语句有哪些？</h2><blockquote><p>6中关联查询：1 交叉连接（cross join）；2 内连接（inner join）；3 外连接（left join、right join）；4 联合查询（ union 与 union all）；5 全连接（full join）；</p></blockquote><p><strong>内连接分为三类</strong></p><blockquote><ol><li>等值连接：on a.id=b.id</li><li>不等值连接：on a.id &gt;b.id</li><li>自连接 ：select * from a t1 inner join a t2 on t1.id = t2.id</li></ol></blockquote><p><strong>外连接（left join、right join）</strong></p><blockquote><ol><li>左匹配连接，以左表为主，先查询出主表，按照on后的关联条件匹配右表，没有匹配到的用null填充，可以简写成left join</li><li>右匹配连接，同上</li></ol></blockquote><p><strong>联合查询（uninon 与 union all）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> a <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> b <span class="keyword">union</span> 。。。</span><br></pre></td></tr></table></figure><blockquote><ol><li>就是把多个结果集集中在一起，union前的结果为准，联合查询的列数要相等，相同的记录行会合并</li><li>如果使用union all，不会合并重复的记录行</li><li>union效率高于union all </li></ol></blockquote><h2 id="mysql的隔离级别和对应的问题"><a href="#mysql的隔离级别和对应的问题" class="headerlink" title="mysql的隔离级别和对应的问题"></a>mysql的隔离级别和对应的问题</h2><h3 id="Read-Uncomitted（读未提交）"><a href="#Read-Uncomitted（读未提交）" class="headerlink" title="Read Uncomitted（读未提交）"></a>Read Uncomitted（读未提交）</h3><p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结。</p><p>本级别很少用于实际应用，因为它的性能也不必其他级别好多事</p><p><strong>问题：</strong>脏读：读取未提交的数据</p><h3 id="Read-Committed（读已提交）"><a href="#Read-Committed（读已提交）" class="headerlink" title="Read Committed（读已提交）"></a>Read Committed（读已提交）</h3><p>大多数数据库系统的默认隔离级别（但不是mysql默认的）。满足了隔离的简单定义：一个事务只能看见已提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理期间可能会有新的commit，所以同一select 可能返回不同结果。</p><h3 id="Repeatable-Read（可重复读-默认级别）"><a href="#Repeatable-Read（可重复读-默认级别）" class="headerlink" title="Repeatable Read（可重复读-默认级别）"></a>Repeatable Read（可重复读-默认级别）</h3><p>这是mysql默认的事务隔离界别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。</p><p>不过理论上会导致另一个棘手的问题：幻读（Phantom Read）。简单的说，幻读指当前用户读取某一范围的数据行是，另一个书屋又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有心的“幻影”行。InnoDB和Falcon存储引擎通过多版本并发控制（mvcc）机制解决了该问题</p><h3 id="Serializable（可串行化）"><a href="#Serializable（可串行化）" class="headerlink" title="Serializable（可串行化）"></a>Serializable（可串行化）</h3><p>这是最高的隔离级别，通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，就是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。这四种隔离界别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：</p><ul><li><p>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p></li><li><p>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p></li><li><p>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就有几列数据是未查询出来的，如果此时插入和另外一个事务插入的数据，就会报错。</p></li></ul><h2 id="在数据库中如何优化？"><a href="#在数据库中如何优化？" class="headerlink" title="在数据库中如何优化？"></a>在数据库中如何优化？</h2><ul><li>对查询进行优化，尽量避免全表扫描，首先应考虑在where 及order by 涉及的列上建立索引</li><li>应尽量避免在where 字句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描</li><li>应尽量避免在where字句中使用！=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</li><li>应尽量避免在where字句中使用or来连接条件，如果一个字段有索引，一个字段没有索引，将导致全表扫描</li><li>in 和 not in 也要慎用，否则会导致全表扫描</li><li>like 模糊全匹配也将导致全表扫描</li></ul><h2 id="mysql的基础架构，画一下图"><a href="#mysql的基础架构，画一下图" class="headerlink" title="mysql的基础架构，画一下图"></a>mysql的基础架构，画一下图</h2><img src="img/面试准备.assets/image-20200306143322654.png" alt="image-20200306143322654" style="zoom:50%;"><h2 id="连接器是啥？"><a href="#连接器是啥？" class="headerlink" title="连接器是啥？"></a>连接器是啥？</h2><p>我们要查询db，第一步就是去连接db，这个连接器就是db跟我们对接的。</p><p>他负责跟客户端建立连接、获取权限、维持、管理连接</p><p>连接的时候回经过tcp握手，然后身份验证，然后输入账号密码就好了</p><p>验证ok后，我们就脸上mysql这个服务器了，但是这个时候处于空闲状态</p><h2 id="怎么查看空闲连接列表？"><a href="#怎么查看空闲连接列表？" class="headerlink" title="怎么查看空闲连接列表？"></a>怎么查看空闲连接列表？</h2><p><strong>show processList</strong></p><img src="img/面试准备.assets/image-20200306143801319.png" alt="image-20200306143801319" style="zoom:50%;"><p>其中Command列显示为<strong>sleep</strong>的这一行，就表示系统里面有一个空闲连接</p><p>如果数据库的客户端太久没有相应，连接器就自动断开了，这个时间参数是<strong>wait_timeout</strong>控制住的，默认时长是8小时。超时之后可以重新连接</p><h3 id="除了重新连接，还有其他方法吗？"><a href="#除了重新连接，还有其他方法吗？" class="headerlink" title="除了重新连接，还有其他方法吗？"></a>除了重新连接，还有其他方法吗？</h3><p>使用长连接</p><p>但是优缺点：长连接后，内存飙升很快，我们知道mysql在执行过程中临时使用的内存是管理在连接对象里面的。只有在断开连接的时候才能得到释放，如果长连接，这一部分内存就得不到释放，就oom了，在jvm里面就频繁fgc</p><h2 id="mysql缓存"><a href="#mysql缓存" class="headerlink" title="mysql缓存"></a>mysql缓存</h2><p>mysql拿到一个查询请求之后，会先到缓存里面查询看看，之前是否执行过这条</p><p>如果同一条语句执行两次，第一次明显比后面的慢，这就是因为缓存的存在</p><p>跟redis类似，只要你之前执行过的语句，都会在内存里面用key-value形式存储着</p><h3 id="为什么缓存弊大于利"><a href="#为什么缓存弊大于利" class="headerlink" title="为什么缓存弊大于利"></a>为什么缓存弊大于利</h3><p>缓存很容易失效，只要对表有任何的更新，这个表的所有查询缓存都会被清空，出现：缓存还没使用就被清空。</p><p>只有类似于配置表这种的，适用缓存</p><h3 id="查询的时候不想用缓存、想用缓存该如何操作？"><a href="#查询的时候不想用缓存、想用缓存该如何操作？" class="headerlink" title="查询的时候不想用缓存、想用缓存该如何操作？"></a>查询的时候不想用缓存、想用缓存该如何操作？</h3><p>可以显示调用，把query_cache_type设置成DEMAND，这样sql默认不适用缓存，想用缓存就用sql_cache。</p><p>缓存在mysql 8.0之后就取消了</p><h3 id="缓存查询完了，应该做啥呢？"><a href="#缓存查询完了，应该做啥呢？" class="headerlink" title="缓存查询完了，应该做啥呢？"></a>缓存查询完了，应该做啥呢？</h3><p>缓存没有命中的情况下，开始执行语句了，你写的sql有没有语法错误，这是接下来比较关心的点。</p><p>他会先<strong>词法分析</strong>，一条sql那么多单词，要识别每个字符代表的是什么？表名？列名？关键字？</p><p>然后开始<strong>语法分析</strong>，根据此法分析的结果，语法分析会判断你sql的对错，错了会提示你哪里错了</p><p>下一步：<strong>优化器</strong></p><p>主要优化什么：我们的表可能会建立很多索引，优化的有一步就是要确认使用哪个索引、执行顺序进行优化，条件那么多、先查哪个表，还是县关联？</p><p>最后就是执行了，交给 <strong>执行器</strong>去做</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h3 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a>什么是线程池？</h3><p>线程池的基本思想是对象池，在程序启动时就开辟一块内存空间，里面存放了众多（未死亡的）的线程，池中的线程执行调度由池管理器来处理，当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象带来的性能开销，节省了系统的资源</p><h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><blockquote><ol><li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用</li><li>运行线程池能有效的控制线程最大并发数，可以根据系统的承受能力</li><li>对线程进行一些简单的管理：比如：延迟执行、定时循环执行的策略等，运用线程池都能进行很好的实现</li></ol></blockquote><h3 id="线程池的主要组件"><a href="#线程池的主要组件" class="headerlink" title="线程池的主要组件"></a>线程池的主要组件</h3><p><img src="img/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.assets/image-20200214150028794.png" alt="image-20200214150028794"></p><p>一个线程池包括以下四个基本组成部分</p><blockquote><ol><li>线程池管理器（ThreadPool）:用于创建并管理线程池，创建、销毁线程池，添加新任务；</li><li>工作线程（WorkThread）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务</li><li>任务接口（Task）：每个任务都必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等。</li><li>任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。</li></ol></blockquote><h3 id="ThreadPoolExecutor类"><a href="#ThreadPoolExecutor类" class="headerlink" title="ThreadPoolExecutor类"></a>ThreadPoolExecutor类</h3><p>这个类的线程池中最核心的一个类</p><p><strong>线程池的主要处理流程</strong></p><blockquote><ol><li>线程数量未达到corePoolSize，则新建一个新城（核心线程）执行任务</li><li>线程数量达到了corePools，则将任务移入队列等待</li><li>队列已满，新建线程（非核心线程）执行任务</li><li>队列已满，总线程数又达到了maxImumPoolSize，就会抛出异常</li></ol></blockquote><p><strong>四中拒绝策略</strong></p><blockquote><ol><li>AbortPolicy：不执行新任务，直接抛出异常，提示线程池已满，线程池默认策略</li><li>DIscardPolicy：不执行新任务，也不抛出异常，基本上为静默模式</li><li>DIsCardOldSetPolicy：将消息队列中的一个任务替换为当前新进来的任务执行</li><li>CallerRunPolicy：用于被拒绝任务的处理程序，它直接在execute方法的调用线程中被拒绝的任务；如果执行程序已关闭，则会丢弃该任务。</li></ol></blockquote><h3 id="5-5-java通过Executors提供四种线程池"><a href="#5-5-java通过Executors提供四种线程池" class="headerlink" title="5.5 java通过Executors提供四种线程池"></a>5.5 java通过Executors提供四种线程池</h3><ol><li><p>CacheThreadPool：可缓存线程池</p><blockquote><ul><li>线程数无限制</li><li>有空闲线程则复用空闲线程，若没有则新建线程，一定程度减少频繁创建、销毁线程，减少系统开销</li></ul></blockquote></li><li><p>FixedThreadPool（）：定长线程池</p><blockquote><ul><li>可控制线程最大并发数（同时执行的线程数）</li><li>超出的线程会在队列中等待</li></ul></blockquote></li><li><p>ScheduledThreadPool</p><blockquote><ul><li>定时线程池</li><li>支持定时及周期性任务执行。</li></ul></blockquote></li><li><p>SingleThreadExecutor：单线程化的线程池</p><blockquote><ul><li>有且仅有一个工作线程任务</li><li>所有任务按照指定顺序执行，即遵循队列的入队出队规则</li></ul></blockquote></li></ol><h3 id="5-6-线程池参数设置"><a href="#5-6-线程池参数设置" class="headerlink" title="5.6 线程池参数设置"></a>5.6 线程池参数设置</h3><p>参数的设置跟系统的负载有直接关系，下面为系统负载的相关参数：</p><ul><li>tasks，每秒需要处理的任务数（针对系统需求）</li><li>threadtasks，每个线程每秒可处理任务数（针对线程本身）</li><li>responsetime，系统允许任务最大的响应时间，比如每个任务的响应时间不得超过2秒</li></ul><p><strong>corePoolSize</strong></p><p>系统每秒有tasks个任务需要处理理，则每个线程每钞可处理threadtasks个任务。，则需要的线程数为：tasks/threadtasks，即tasks/threadtasks个线程数。</p><p>假设系统每秒任务数为100 ~ 1000，每个线程每钞可处理10个任务，则需要100 / 10至1000 / 10，即10 ~ 100个线程。那么corePoolSize应该设置为大于10，具体数字最好根据8020原则，因为系统每秒任务数为100 ~ 1000，即80%情况下系统每秒任务数小于1000 * 20% = 200，则corePoolSize可设置为200 / 10 = 20。</p><p><strong>queueCapacity</strong></p><p>任务队列的长度要根据核心线程数，以及系统对任务响应时间的要求有关。队列长度可以设置为 所有核心线程每秒处理任务数 * 每个任务响应时间 = 每秒任务总响应时间 ，即(corePoolSize<em>threadtasks)</em>responsetime： (20<em>10)</em>2=400，即队列长度可设置为400。</p><p><strong>maxPoolSize</strong></p><p>当系统负载达到最大值时，核心线程数已无法按时处理完所有任务，这时就需要增加线程。每秒200个任务需要20个线程，那么当每秒达到1000个任务时，则需要（tasks - queueCapacity）/ threadtasks 即(1000-400)/10，即60个线程，可将maxPoolSize设置为60。</p><p>队列长度设置过大，会导致任务响应时间过长，切忌以下写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkedBlockingQueue queue = new LinkedBlockingQueue();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这实际上是将队列长度设置为Integer.MAX_VALUE，将会导致线程数量永远为corePoolSize，再也不会增加，当任务数量陡增时，任务响应时间也将随之陡增。</p><p><strong>keepAliveTime</strong></p><p>当负载降低时，可减少线程数量，当线程的空闲时间超过keepAliveTime，会自动释放线程资源。默认情况下线程池停止多余的线程并最少会保持corePoolSize个线程。</p><p><strong>allowCoreThreadTimeout</strong></p><p>默认情况下核心线程不会退出，可通过将该参数设置为true，让核心线程也退出。</p><h3 id="5-7-线程池的五种状态"><a href="#5-7-线程池的五种状态" class="headerlink" title="5.7 线程池的五种状态"></a>5.7 线程池的五种状态</h3><ol><li><p>线程池的初始化状态running，能够接受新任务，以及对已添加的任务进行处理。</p></li><li><p>线程池出在shutdown状态时，不接受新任务，但能处理已添加的任务。调用线程池的shutdown（）接口时，线程池由running-&gt;shutdown</p></li><li><p>线程池出在stop状态时，不接受新任务，不处理已添加的任务，并且会终端正在处理的任务。调用线程池的shutdownNow（）接口时，线程池由（running or shutdown） -&gt;stop。</p></li><li><p>当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。</p></li><li><p>当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。</p></li><li><p>当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。 线程池彻底终止，就变成TERMINATED状态。线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。</p></li></ol><h3 id="5-8-关闭线程池"><a href="#5-8-关闭线程池" class="headerlink" title="5.8 关闭线程池"></a>5.8 关闭线程池</h3><p>线程池提供两种关闭方法：shutDown()和shutDownNow()</p><p><strong>shutDown()</strong></p><p>当线程池调用该方法时，线程池的状态则like变成shutdown状态，此时，则不能再往线程池中添加任何任务，否则将会抛出异常；但是，此时线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出</p><p><strong>shutdownNow（）</strong></p><p>执行该方法，线程池的状态立刻变成STOP状态，并试图停止所有正在执行的线程，不再处理线程池中等待的任务，当然，会返回那些未执行的任务；不代表立刻就能退出，可能要等待所有正在执行的任务都执行完才能退出</p><h3 id="5-9-各种场景下怎么设置线程数"><a href="#5-9-各种场景下怎么设置线程数" class="headerlink" title="5.9 各种场景下怎么设置线程数"></a>5.9 各种场景下怎么设置线程数</h3><p><strong>高并发、任务执行时间短的业务</strong></p><blockquote><p>线程池线程数可以设置为cpu核心数+1，减少线程上下文的切换</p></blockquote><p><strong>并发不高、任务执行时间长的业务</strong></p><blockquote><p>这个需要判断执行时间是耗在那个地方了？</p><ul><li>io操作耗时，也就是io密集型的任务，因为io操作并不占用cpu，所有不要让所有的cpu闲下来，可以适当加大线程池中的线程数目（cpu核心数*2），让cpu处理更多的业务</li><li>计算操作耗时，也就是cpu密集型任务，那么久设置cpu核心数+1，线程数设置的少一些，减少线程上下文的切换。</li></ul></blockquote><p><strong>并发高、业务执行时间长的业务</strong></p><blockquote><p>解决这种类型任务的关键不在于线程池，而在于整体架构的设计</p></blockquote><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="五个状态"><a href="#五个状态" class="headerlink" title="五个状态"></a>五个状态</h2><h3 id="new（新建）"><a href="#new（新建）" class="headerlink" title="new（新建）"></a>new（新建）</h3><h3 id="Runnable（就绪）"><a href="#Runnable（就绪）" class="headerlink" title="Runnable（就绪）"></a>Runnable（就绪）</h3><h3 id="Running（运行）"><a href="#Running（运行）" class="headerlink" title="Running（运行）"></a>Running（运行）</h3><h3 id="Blocked（阻塞）"><a href="#Blocked（阻塞）" class="headerlink" title="Blocked（阻塞）"></a>Blocked（阻塞）</h3><h3 id="死亡"><a href="#死亡" class="headerlink" title="死亡"></a>死亡</h3><h2 id="线程的创建方式到底有几种"><a href="#线程的创建方式到底有几种" class="headerlink" title="线程的创建方式到底有几种"></a><strong>线程的创建方式到底有几种</strong></h2><blockquote><ol><li><p>声明为Thread的子类，并重写run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;        <span class="meta">@Override</span></span><br><span class="line">&gt;        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;            System.out.println(Thread.currentThread().getName() + <span class="string">" Thread running..."</span>);</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">&gt;            <span class="keyword">new</span> MyThread().start();</span><br><span class="line">&gt;            System.in.read();</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li><p>实现Runnable接口</p><p>Runnable的优点：</p><p>业务代码与线程类创建启动等逻辑解耦</p><p>Runnable可以复用，Thread则需要每次创建</p><p>类可以实现多个接口，而不可以继承多个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">&gt;        <span class="meta">@Override</span></span><br><span class="line">&gt;        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;            System.out.println(Thread.currentThread().getName() + <span class="string">" Runnable running..."</span>);</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">&gt;            <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();</span><br><span class="line">&gt;            System.in.read();</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="comment">// 有点</span></span><br><span class="line">&gt;    </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p><strong>归根结底</strong></p><p>创建线程只有一种方式，就是创建Thread对象，而构建一个线程的方式有多重，比如：创建线程类，实现Runnable接口，创建线程池，FutureTask等等</p><ol start="3"><li><p>线程池创建线程：实际是由默认的工厂代为创建Thread类来实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="comment">// Executors中的DefaultThreadFactory </span></span><br><span class="line">&gt;    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">&gt;            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">&gt;            <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">&gt;            <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">&gt;            <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;            DefaultThreadFactory() &#123;</span><br><span class="line">&gt;                SecurityManager s = System.getSecurityManager();</span><br><span class="line">&gt;                group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">&gt;                                      Thread.currentThread().getThreadGroup();</span><br><span class="line">&gt;                namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">&gt;                              poolNumber.getAndIncrement() +</span><br><span class="line">&gt;                             <span class="string">"-thread-"</span>;</span><br><span class="line">&gt;            &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">&gt;                Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">&gt;                                      namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">&gt;                                      <span class="number">0</span>);</span><br><span class="line">&gt;                <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">&gt;                    t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">&gt;                <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">&gt;                    t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">&gt;                <span class="keyword">return</span> t;</span><br><span class="line">&gt;            &#125;</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    <span class="comment">//由上newThread()方法可知，即使是线程池，本质上还是使用Thread的创建线程。</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="4"><li><p>Callable和FutureTask创建线程，本质其实也是Thread</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">&gt;        <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;         * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">&gt;         * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">&gt;         */</span></span><br><span class="line">&gt;        <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">&gt;        ......</span><br><span class="line">&gt;        <span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line">&gt;        ......</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="5"><li><p>定时器Timer：它的TimerTask其实也是实现了Runnable接口，可以看下TimerTask这个抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerExample</span> </span>&#123;</span><br><span class="line">&gt;        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;            Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">&gt;            <span class="comment">// 每隔1s打印下自己的名字</span></span><br><span class="line">&gt;            timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">&gt;                <span class="meta">@Override</span></span><br><span class="line">&gt;                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;                    System.out.println(Thread.currentThread().getName() + <span class="string">" timer running..."</span>);</span><br><span class="line">&gt;                &#125;</span><br><span class="line">&gt;            &#125;, <span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p><strong>线程和进程的区别</strong></p><blockquote><p>线程是进程的子集，一个进程可以有多个线程；</p><p>不同的进程使用不同的内存空间，所有单线程共享一片相同的内存空间</p></blockquote><p><strong>用Runnable还是Thread</strong></p><blockquote><p>推荐用Runnable，因为可以继承多个接口</p></blockquote><p><strong>Thread类中的start()和run()方法有什么区别？</strong></p><blockquote><p>start()被用来启动新创建的线程，而且<strong>start()</strong>内部调用了run()方法；</p><p><strong>run()</strong>,只会在原来的线程中调用，没有新的线程启动</p></blockquote><p><strong>Runnable和Callable有什么不同</strong></p><blockquote><p>都代表那些要在不同的线程中执行的任务。Runnable从1.0开始就有了，Callable在1.5增加的；</p><p>Callable的call()方法可以返回值和抛出异常</p></blockquote><h2 id="乐观锁、悲观锁"><a href="#乐观锁、悲观锁" class="headerlink" title="乐观锁、悲观锁"></a>乐观锁、悲观锁</h2><p>简单说说乐观锁、悲观锁，他们对应的实现cas、Synchronized、ReentrantLock</p><p>锁只能升级，不能降级</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><h4 id="说一说cas"><a href="#说一说cas" class="headerlink" title="说一说cas"></a>说一说cas</h4><p>Compare and Swap 比较并且替换，是乐观锁的一种实现方式，是一种轻量级锁，juc中很多工具类的实现是基于cas的</p><h4 id="cas是怎么实现线程安全的？"><a href="#cas是怎么实现线程安全的？" class="headerlink" title="cas是怎么实现线程安全的？"></a>cas是怎么实现线程安全的？</h4><p>线程在读取数据时不进行加锁，在准备写回数据时，先去查询原值，操作的时候比较原值是否修改，若未被其他线程修改则写回，若已修改，则重新执行读取流程，无法处理aba问题</p><p>cas操作长时间不成功的话，会导致一直自旋，相当于死循环了，cpu压力很大</p><h4 id="乐观锁在项目中的实践？"><a href="#乐观锁在项目中的实践？" class="headerlink" title="乐观锁在项目中的实践？"></a>乐观锁在项目中的实践？</h4><p>比如订单表，比如流水表，为了防止并发安问题，就会加入cas的校验过程，保证线程安全，但并不是所有场景都适用的。</p><h4 id="cas性能很好，但是Synchronized性能不咋地，为啥1-8之后反而多了Synchronized？"><a href="#cas性能很好，但是Synchronized性能不咋地，为啥1-8之后反而多了Synchronized？" class="headerlink" title="cas性能很好，但是Synchronized性能不咋地，为啥1.8之后反而多了Synchronized？"></a><strong>cas性能很好，但是Synchronized性能不咋地，为啥1.8之后反而多了Synchronized？</strong></h4><p>synchronized之前一直都是重量级的锁，但是后来java官方对他进行过升级 的，他现在采用的是锁升级的方式去做的。</p><p>针对synchronized获取锁的方式，jvm使用了锁升级的优化方式，就是先使用偏向锁优先同一进程然后再次获取锁，如果失败，就升级为cas轻量级锁，如果失败就会端在自旋，防止线程被系统挂起，最后如果以上都失败就升级为重量级锁；所有是一步步升级上去的，一开始也是通过很多轻量级的方式锁定的</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>什么是悲观锁，悲观锁，就是默认你每次都是渣男，每次都要提防着你是的</p><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>无论是修饰方法还是代码块，都是通过持有修饰对象的锁来实现同步</p><h5 id="是如何保证同一时刻只有一个线程可以进入临界区呢？"><a href="#是如何保证同一时刻只有一个线程可以进入临界区呢？" class="headerlink" title="是如何保证同一时刻只有一个线程可以进入临界区呢？"></a>是如何保证同一时刻只有一个线程可以进入临界区呢？</h5><p>jvm层面的synchronized加锁，是最常见的线程同步收之一</p><p>synchronized，代表这个方法加锁，相当于不管哪一个线程（比如线程A），运行到这个方法的时候，都要检查有没有其他线程B（或者c、d）正在用这个方法（或者该类方法啊其他同步方法），有的话要等他运行完之后，再运行，没有的话，锁定调用这，然后直接运行。</p><p>分别从他对对象、方法、代码块三方面加锁，去介绍怎么保证线程安全的</p><p><strong>同步方法</strong>和<strong>同步代码块</strong>底层都是通过monitor来实现同步的</p><h6 id="对象加锁"><a href="#对象加锁" class="headerlink" title="对象加锁"></a>对象加锁</h6><p>在jvm中，对象在内存中分为三块区域：对象头（header）、实例数据(Instance data)、对齐填充（padding）</p><p><strong>对象头</strong></p><p>以hotpot虚拟机为例，对象头主要包括两部分数据：mark word（标记字段）、klass pointer(类型指针)</p><ul><li><strong>mark word</strong>：默认存储对象的hashcode，分代年龄和锁标志位信息。它会根据对象的状态复制自己的存储空间，也就是说：在运行期间mark word里面存储的数据会随着锁标志位的变化而变化</li><li><strong>klass point</strong> ：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li></ul><img src="img/面试准备.assets/image-20200306165448996.png" alt="image-20200306165448996" style="zoom:33%;"><p>可以看到对象头保存了锁标志位和指向monitor对象的起始地址，如图所示，右侧就是对象对应的monitor对象</p><p>当monitor被某个线程持有后，就会处于锁定状态，如同种的 <strong>Owner</strong>部分，会指向持有monitor 对象的进程</p><p>另外 Monitor中海油两个队列分别是 EntryList和waitList，主要是用来存放进入及等待获取锁的线程，如果线程进入，则得到当前对象锁，那么别的线程在该类所有对象上的任何操作都不能进行</p><p><strong>如果一个对象有多个资源，就不需要将整个对象加锁</strong></p><p>由于每个对象都有锁，可以使用虚拟对象来上锁 Synchronized（new obj）</p><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>在介绍ReentrantLock之前，先介绍AQS（AbstractQueuedSynchronizer）</p><p>AQS：队列同步器，是实现ReentrantLock的基础</p><p>AQS有一个state标记位，值为1时表示有线程占用，其他线程需要进入到同步队列等待，同步队列是一个双向链表</p><h2 id="什么是aba"><a href="#什么是aba" class="headerlink" title="什么是aba"></a>什么是aba</h2><p><strong>什么是ABA</strong></p><p>就是一个线程把值改成了b，又一个线程把值改回了a，对于当前线程来说，发现他的值还是a，所有就不知道这个值到底有没有被人修改过，如果只追求最后结果正确，这是没关系的</p><p>但实际过程中还是需要记录修改过程的，比如资金修改什么的，你每次修改的都应该有记录，方便回溯</p><h3 id="如果和解决ABA问题？"><a href="#如果和解决ABA问题？" class="headerlink" title="如果和解决ABA问题？"></a><strong>如果和解决ABA问题？</strong></h3><p>用版本号去保证就好， 比如说，我在修改前去查询他原来的值的时候再带一个版本号，每次判断就连值和版本号一起判断，判断成功就给版本号+1，伪代码如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> a <span class="keyword">set</span> <span class="keyword">value</span> = newValue ，vision = vision + <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">value</span> = #&#123;oldValue&#125; <span class="keyword">and</span> vision = #&#123;vision&#125; // 判断原来的值和版本号是否匹配，中间有别的线程修改，值可能相等，但是版本号<span class="number">100</span>%不一样</span><br></pre></td></tr></table></figure><h3 id="除了版本号还有别的方法保证吗"><a href="#除了版本号还有别的方法保证吗" class="headerlink" title="除了版本号还有别的方法保证吗"></a><strong>除了版本号还有别的方法保证吗</strong></h3><p>比如时间戳也可以，查询的时候把时间戳一起查询出来，对的上才修改并且更新值的时候一起修改更新时间，方法很多，都是跟版本号异曲同工</p><h1 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h1><h3 id="6-1-1成员变量"><a href="#6-1-1成员变量" class="headerlink" title="6.1.1成员变量"></a>6.1.1成员变量</h3><p><strong>1。集合的初始化容量（必须是2的n次幂）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure><p>HashMap构造方法可以指定集合的初始化容量大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hash(<span class="keyword">int</span> 初始大小) <span class="comment">//构造一个带指定初始容量和默认加载因子（0.75）的空HashMap</span></span><br></pre></td></tr></table></figure><p>由此可见，当想HashMap中添加一个元素的时候，需要根据key的hash值，去确定其在数组中的具体位置。HashMap为了存取高效，要尽量减少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就是把数据存储到哪个链表中的算法</p><p>这个算法实际就是取模，hash%length，计算机中直接求余效率远不如位运算。所有源码中做了优化，使用hash&amp;（length-1），而实际上hash%length等于hash&amp;（length-1）的前提是lengtn是2的n次幂。</p><p>hash&amp;（length-1）是计算数组的索引的</p><p><strong>为什么是2的n次幂</strong></p><blockquote><p>答：减少hash冲突，提高性能</p></blockquote><p><strong>如果不是2的n次幂会怎么样？比如如果是9？</strong></p><blockquote><p>答：会通过无符号右移 按位或运算变为比指定容量大的最小的2的n次幂</p></blockquote><p><strong>2。默认的负载因子，默认值是0.75</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><p>达到这个之后，会扩容，rehash</p><p><strong>3。集合最大容量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;<span class="comment">//集合最大容量的上线是2的30次幂</span></span><br></pre></td></tr></table></figure><p> <strong>4。当链表的值超过8则会转红黑树（1.8新增）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>链表中节点的分布符合泊松分布，也就是说转变为红黑树的概率非常小</p><p><strong>5。当链表的长度小于6则会从红黑树转回链表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p><strong>6。当map里面的数量超过这个值时，表中的桶才会树化，否则桶内元素太多时会扩容，而不是树化沦为了避免进行扩容、树化选择的冲突，这个值不能小于4*TREEIFY_THRESHOLD（8）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;<span class="comment">//桶中结构转化为红黑树时对应数组长度最小的值</span></span><br></pre></td></tr></table></figure><p><strong>7。table用来初始化（必须是2的n次幂）（★★★★）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>table在jdk1.8中是由数组+链表+红黑树来组成的结构其中table就是hashMap中的数组，jdk8之前的数组类型是Entry&lt;K,V&gt;类型，jdk8之后就是Node&lt;K,V&gt;类型。只是换了个名字，都实现了一样的接口：Map.Entry&lt;K,V&gt;。负责存储键值对数据的</p><p><strong>8。HashMap中存放元素的个数（★★★★）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存放元素的个数，注意这个不等于数组的长度</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>size为HashMap中k-v的实时数量，不是数组table的长度。</p><p>9。用来记录hashMap的修改次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;<span class="comment">//每次扩容和更改map结构的计数器</span></span><br></pre></td></tr></table></figure><p>10。用来调整大小下一个容量的值计算方式（容量*负载因子）（边界值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure><p><strong>11。哈希表的加载因子（★★★★）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p>问题1：为什么架子啊因子设置是<strong>0.75</strong>，为什么不是是0.5呢？</p><p>考虑到hash冲突的问题，</p><h3 id="6-1-2构造方法"><a href="#6-1-2构造方法" class="headerlink" title="6.1.2构造方法"></a>6.1.2构造方法</h3><p>HashMap中重要的构造方法，他们分别如下：</p><p>1.构造一个空的hashMap，默认初始容量（16）和默认负载因子（0.75）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br></pre></td></tr></table></figure><p>2.构造一个具有指定出事容量和默认负载因子的HashMap（0.75）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3.构造一个具有指定的初始容量和负载因子的HashMap（★★★★★）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 边界值，决定是否扩容，不是数组长度</span></span><br><span class="line">  <span class="comment">//tableSizeFor(initialCapacity); 判断指定的初始容量是否是2的n次幂，如果不是，就会变成比初始容量大的最小的2的n次幂</span></span><br><span class="line">  <span class="comment">//  注意，jdk1.8以后的构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推迟到了put方法中，在put方法中会对threshold重新计算</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-3-成员方法"><a href="#6-1-3-成员方法" class="headerlink" title="6.1.3 成员方法"></a>6.1.3 成员方法</h3><p><strong>增加方法</strong></p><p>put方法是比较复杂的，实现步骤大致如下：</p><ol><li>先通过hash值计算出key映射到哪个桶（就是数组）</li><li>如果桶上没有碰撞冲突，则直接插入 </li><li>如果出现碰撞冲突，则需要处理冲突<ol><li>如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据</li><li>否则采用传统的链式方法插入，如果链的长度达到临界值，则把链表转化为红黑树</li></ol></li><li>如果同种存在重复的键，则为该键替换为新值value；</li><li>如果size大于阈值threshold，则进行扩容</li></ol><p>具体的方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>将链表转为红黑树</strong></p><p><strong>扩容方法 resize</strong></p><ol><li><p>什么时候才需要扩容？</p><blockquote><p>第一次是在putVal的时候扩容</p><p>补充：当HashMap中的其中一个链表的对象个数如果达到8个，此时如果数组长度没有达到64，那么HashMap会先扩容解决，如果已经达到64，那么这个链表会变成红黑树，节点类型由node变为treenode</p><p>当然，如果映射关系被移除后，下次执行resize方法时判断树节点个数低于6个，也会再把树转换为链表</p></blockquote></li><li><p>扩容是在做什么？</p><p>jdk8之前：</p><blockquote><p>reHash</p><p>创建新的数组</p><p>遍历放到新的数组</p></blockquote><p>jdk8开始：</p><blockquote><p>扩容避免了reHash，如何避免的呢？不需要重新计算hash；扩容之后要么还是在原来的索引位置，要么就是在（原来的索引位置+旧容量）的索引位置</p></blockquote></li><li><p>HashMap的扩容是什么？</p></li></ol><h2 id="面试题：谈谈你对hashMap的理解"><a href="#面试题：谈谈你对hashMap的理解" class="headerlink" title="面试题：谈谈你对hashMap的理解"></a>面试题：谈谈你对hashMap的理解</h2><p>hashmap是一种存取高效，但是不保证有序的容器。数据结构是<strong>数组+链表+红黑树</strong>，是解决hash冲突的产物，它实现了Map接口，采用kv键值对存储数据，并且实现了浅拷贝和序列化</p><p>默认大小是16，阈值是0.75，初始化大小必须是2的幂，最大是2的30次方，数组中存储的链表节点Entry类实现于Map.Entry接口，实现了对节点的通用操作</p><p>HashMap提供了四种构造方法，默认构造、指定初始容量构造、指定初始容量和阈值构造、基于Map的构造。虽然是构造方法，但是真正从初始化是在第一次添加操作里面实现的</p><p>第一次添加操作时，先判断数组有没有初始化，如果没有则先初始化</p><blockquote><p>添加操作的流程：</p><ol><li>先判断是否初始化</li><li>再判断传入的key是否为空，为空则保存在table[0]位置</li><li>key不为空的就对key进行hash，hash的结果再&amp;数组的长度就得到存储的位置</li><li>如果存储位置为空则创建节点，不为空说明存在冲突</li><li>解决冲突HashMap会先遍历链表，如果有相同的value就更新旧值，否则构建节点添加到链表头</li><li>添加还要先判断存储的节点数量是否达到阈值，达到阈值就要进行扩容</li><li>扩容2倍，是新建数组，所以要先转移节点，转移时都重新计算存储位置，可能保持不变，可能为就容量+位置</li><li>扩容结束后新插入的元素也得再hash一遍才能插入</li></ol></blockquote><p>获取节点的操作流程：</p><blockquote><ol><li>判断是否为空，为空就去table[0]找值</li><li>不为空，也是先hash，&amp;数组长度计算下标位置</li><li>遍历找相同的key返回值</li></ol></blockquote><p>HashMap是并发不安全的容器，并发添加操作中会出现丢失更新的问题；因为采用头插法在并发扩容时会产生环形链表的问题，导致cpu达到100%</p><p><strong>解决并发问题可以采用</strong></p><ul><li>java类库提供的Collections工具包下的Collections.synchronizedMap()方法，返回一个线程安全的map</li><li>使用并发包下的ConcurrentHashMap。它采用的是分段锁机制实现线程安全</li><li>使用HashTable（不推荐）</li></ul><p><strong>回答顺序：数据结构+继承结构+基本字段+构造方法+添加操作+扩容操作+并发问题+与1.8的区别</strong></p><h2 id="知识点扩展"><a href="#知识点扩展" class="headerlink" title="知识点扩展"></a>知识点扩展</h2><h4 id="说说浅拷贝与深拷贝的区别"><a href="#说说浅拷贝与深拷贝的区别" class="headerlink" title="说说浅拷贝与深拷贝的区别"></a><strong>说说浅拷贝与深拷贝的区别</strong></h4><blockquote><p><strong>基本数据类型</strong>：直接存储在栈中</p><p><strong>引用数据类型</strong>：存储的是该对象在栈中引用，真实数据存放在堆内存里。</p><p>这两种都是针对于Object和Array这样的引用类型数据的</p><p><strong>浅拷贝</strong>只复制指向某个对象的指针，而不是复制对象本身，新旧对象还是共享同一块内存，拷贝对象的时候只对基本数据类型进行了拷贝，对于引用数据类型只是进行了引用的传递，没有真实的创建一个新的对象。</p><p><strong>深拷贝</strong>会创造一个一模一样的对象，新旧对象不共享内存</p></blockquote><p><strong>Collections.synchronizedMap()和Hashtable的区别</strong></p><h4 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a><strong>HashMap和Hashtable的区别</strong></h4><blockquote><p>Hashtable是个过时的集合类</p><p>两者都实现了map接口，两者介乎等价，除了：Hashtable是synchronized的，这意味着线程安全，多个线程可以共享一个hashtable，java5提供了concurrentHashMap，他是Hashtable的替代，比Hashtable扩展性更好</p><table><thead><tr><th></th><th>HashMap</th><th>Hashtable</th></tr></thead><tbody><tr><td>线程是否安全</td><td>否</td><td>是</td></tr><tr><td>效率</td><td>高</td><td>低</td></tr><tr><td>null key 和null value</td><td>是</td><td>否</td></tr><tr><td>底层数据结构</td><td>数组+链表+红黑树</td><td></td></tr><tr><td>实现方式</td><td>继承AbstractMap类</td><td>继承了Dictionary类，是jdk1.0添加，好像已经过时了</td></tr><tr><td>初始化容量不同</td><td>16</td><td>11</td></tr><tr><td>扩容机制不同</td><td>翻倍</td><td>翻倍+1</td></tr><tr><td>迭代器不同</td><td>Iterator是fail-fast的</td><td>Enumerator不是fail-fast的</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p><strong>快速失败fail-fast是啥？原理是啥</strong></p><blockquote><p>是java集合中的一种机制，在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception</p><p>原理：在遍历的过程中使用一个modCount遍历用来记录内容变化，如果发生变化，他的值就会改变，每当迭代器使用hashNext、next遍历下一个元素之前，都会检测modCount变量</p></blockquote><p><strong>fail-fast场景？</strong></p><blockquote><p>java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改，算是一种安全机制吧。</p></blockquote><p><strong>安全失败 fail-safe</strong></p><blockquote><p>java.util.concurrent包下的容器都是安全失败的，可以在多线程下并发使用，并发修改。</p></blockquote><p><strong>Hashtable效率低的原因？</strong></p><blockquote><p>看过源码，会发现，他对数据的操作都会上锁</p></blockquote><p><strong>为啥Hashtable不允许键值为null？</strong></p><blockquote><p>Hashtable在put空值的时候回直接抛异常，HashMap却做了特殊处理</p><p>Hashtable使用的是<strong>安全失败机制</strong>，这种机制会使你此次读取到的数据不一定是最新的数据，如果你使用null值，就会使得它无法判断对应的key是不存在还是为空，因为你无法再调用一次contain（key）来对key是否存在进行判断，ConcurrentHashMap同理。</p></blockquote></blockquote><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="*ConcurrentHashMap *"></a>*<em>ConcurrentHashMap *</em></h1><p>ConcurrentHashMap的数据结构，以及并发度这么高？</p><blockquote><p>底层基于<strong>数组+链表</strong>组成的，不过在jdk1.7与18中稍有不同</p><p><strong>1.7版本</strong></p><p>先看1.7 如图所示：是有segment数组、HashEntry组成，和HashMap一样，仍然是<strong>数组+链表</strong></p><p>HashEntry跟HashMap差不多，不同的是，他使用了<strong>volatile修饰他的value还有next</strong>。</p><p>ConcurrentHashMap采用了分段锁，其中Segment继承于ReentrantLock。不会像Hashtable那样不管是put还是get操作都需要做同步处理，理论上他支持Segment数量的并发。</p><p>每当一个线程占用锁访问一个Segment时，不会影响到其他的Segment。</p><p><strong>put</strong>：第一步的时候回尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则尝试自旋获取锁，如果重试的次数达到了Max_SCAN_RETRIES则改为阻塞锁获取，保证能获取成功</p><p><strong>get：</strong>将key通过hash之后定位到具体的Segment，再通过一次Hash定位到具体的元素上。由于HashEntry中的value是volatile的，保证了内存可见性，所有每次获取的都是最新值，整个过程不需要加锁</p><blockquote><p>虽然1.7支持每个Segment并发访问，但是还是存在一些问题？基本还是数组+链表的方式，查询时候，还得遍历链表，效率低下，跟1.7的HashMap存在一样的问题</p></blockquote><p><strong>1.8版本</strong></p><p>基本抛弃了原有的Segment分段锁，采取了<strong>CAS+Synchronized</strong>来保证并发安全性，跟HashMap很像，也把之前的HashEntry改成了node，但是作用不变</p><p><strong>值的存取过程？以及怎么保证线程安全？</strong></p><p>put操作还是比较复杂的，大概有一下几个步骤：</p><ol><li>根据key计算出Hashcode。</li><li>判断是否需要进行初始化。</li><li>即为当前key定位出的node，如果为空表是当前位置可以写入数据，利用cas尝试写入，失败则自选保证成功。</li><li>如果当前位置的hashCode == moved == -1，则需要进行扩容</li><li>如果都不满足，则利用synchronized锁写入数据</li><li>如果数量大于 <strong>TREEIFY_THRESHOLD</strong>，则要转换为红黑树</li></ol><p><strong>这里所说的cas是什么？自旋又是什么？</strong></p><p>cas是乐观锁的一种实现方式，是一种轻量级锁，juc中很多工具类的实现就是基于cas的</p><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。</p><p><strong>cas就一定能保证数据没被别的线程修改过吗？</strong></p><p>并不能，比如经典的<strong>ABA</strong>问题，CAS就无法判断了</p><p><strong>什么是ABA</strong></p><p>就是一个线程把值改成了b，又一个线程把值改回了a，对于当前线程来说，发现他的值还是a，所有就不知道这个值到底有没有被人修改过，如果只追求最后结果正确，这是没关系的</p><p>但实际过程中还是需要记录修改过程的，比如资金修改什么的，你每次修改的都应该有记录，方便回溯</p><p><strong>如果和解决ABA问题？</strong></p><p>用版本号去保证就好， 比如说，我在修改前去查询他原来的值的时候再带一个版本号，每次判断就连值和版本号一起判断，判断成功就给版本号+1，伪代码如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; update a set value = newValue ，vision = vision + 1 where value = #&#123;oldValue&#125; and vision = #&#123;vision&#125; // 判断原来的值和版本号是否匹配，中间有别的线程修改，值可能相等，但是版本号100%不一样</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>除了版本号还有别的方法保证吗</strong></p><p>比如时间戳也可以，查询的时候把时间戳一起查询出来，对的上才修改并且更新值的时候一起修改更新时间，方法很多，都是跟版本号异曲同工</p><p><strong>cas性能很好，但是Synchronized性能不咋地，为啥1.8之后反而多了Synchronized？</strong></p><p>synchronized之前一直都是重量级的锁，但是后来java官方对他进行过升级 的，他现在采用的是锁升级的方式去做的。</p><p>针对synchronized获取锁的方式，jvm使用了锁升级的优化方式，就是先使用偏向锁优先同一进程然后再次获取锁，如果失败，就升级为cas轻量级锁，如果失败就会端在自旋，防止线程被系统挂起，最后如果以上都失败就升级为重量级锁；所有是一步步升级上去的，一开始也是通过很多轻量级的方式锁定的</p></blockquote><blockquote><p>先来一张1.7图：</p><p><img src="img/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.assets/image-20200217155742981.png" alt="image-20200217155742981"></p><p><strong>jdk1.7</strong>从图中可以看出，Hashtable的锁是加在整个表上的，而ConcurrentHashMap是加在segment（每个段上的），这样我们在堆segment1操作的时候，同时也可以对segment2中的数据操作，这样效率会高很多。需要hash两次，第一次Hash定位到segment，第二次Hash定位到元素所在的链表的头部</p><p><strong>jdk1.8</strong></p><p>jdk8中ConcurrentHashMap参考了jdk8HashMap的实现，采用了数组+链表+红黑树的实现方式来设计，内部大量采用cas操作（CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。）从jdk8来看，它的数据结构已经接近HashMap，只是增加了同步的操作来控制并发</p></blockquote><h1 id="网络tcp常见面试题"><a href="#网络tcp常见面试题" class="headerlink" title="网络tcp常见面试题"></a>网络tcp常见面试题</h1><h2 id="为什么建立连接是三次握手？"><a href="#为什么建立连接是三次握手？" class="headerlink" title="为什么建立连接是三次握手？"></a>为什么建立连接是三次握手？</h2><p>两个目的：信息对等、防止超时</p><p>先从信息对等的角度来看，如下图，双方只有确定四类信息，才能建立连接，第二次握手之后，从b机器的视角看还有两个红色的no是无法确定的，只有在第三次握手之后才能确认完毕</p><img src="img/面试准备.assets/image-20200306195733777.png" alt="image-20200306195733777" style="zoom:50%;"><p>防止脏数据，ttl网络报文的生存时间往往都会超过tcp请求超时时间，如果两次握手就建立连接，传输数据并释放连接后，第一次超时的请求才到达b机器，b机器会认为是a创建新的连接请求，然后确认统一创建连接，因为a的状态不是xx，所以直接丢了b的确认数据，以至于最后只是b机器单方面的创建连接完毕</p><h2 id="tcp断开连接为什么是四次？"><a href="#tcp断开连接为什么是四次？" class="headerlink" title="tcp断开连接为什么是四次？"></a>tcp断开连接为什么是四次？</h2><p><strong>为什么四次？</strong></p><blockquote><p>确保数据能够完成传输</p></blockquote><p>第一次:**</p><p>A—&gt;B：我要断开连接</p><p><strong>第二次：</strong></p><p>B—&gt;A：我答应你，但是要等我处理完数据</p><p><strong>第三次</strong></p><p>B—&gt;A：我处理完了，咱们断开连接把</p><p><strong>第四次</strong></p><p>A—-&gt;B：我答应你，咱俩掰了</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序经典的呢，叫单轴快排，改进的叫双轴快排</p><p>他的排序思想就是：<strong>在数组中选择一个元素作为轴进行排序</strong></p><blockquote><p>第一次将大于轴的元素放在轴右边，小于轴的元素放在轴左边，这样就完成了第一次排序，然后对轴两边分区选轴进行递归排序，直到只剩下一个元素时返回。</p></blockquote><p>双轴快排使用到Arrays中是sort方法，所处理的都是基本数据类型</p><p>空间复杂度是 ologn，如果不考虑递归的话，可以达到o1 </p><h1 id="链表，反转链表"><a href="#链表，反转链表" class="headerlink" title="链表，反转链表"></a>链表，反转链表</h1><h1 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h1><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><strong>volatile</strong></h3><p><strong>可见性</strong>（✅）</p><blockquote><p>会强制将修改的值写入主内存，并且其他用过的工作内存的值都无效了</p></blockquote><p><strong>原子性</strong>（❌）</p><blockquote><p>自增不是原子操作，volatile也无法保证对变量的任何操作都是原子性的</p><p>valatile只能保证对单次读、写的原子性</p></blockquote><p><strong>有序性</strong>（✅❌一定程度）</p><blockquote><p>volatile禁止指令重排有两层意思：</p><ol><li>当程序执行到volatile变量的读操作或者写操作时，在他前面的操作肯定已经全部进行，且结果对后面的操作可见；在他后面的操作肯定都还没有执行</li><li>在进行指令优化时，不能讲volatile变量访问的语句放在他后面执行，也不能放到前面执行</li></ol></blockquote><p><strong>使用场景</strong></p><blockquote><p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于他，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile无法保证操作的原子性</p><p>使用volatile必须具备以下两个条件（实际就是保证使用场景是原子性操作）</p><ol><li>对变量的写操作不依赖于当前值</li><li>该变量没有包含在具有其他变量的不变式中</li></ol></blockquote><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h3 id="1、为什么用线程池"><a href="#1、为什么用线程池" class="headerlink" title="1、为什么用线程池"></a>1、为什么用线程池</h3><p>使用线程池主要是为了解决：</p><blockquote><p>通过重用线程池中的线程，来减少每个线程的创建销毁的性能开销</p><p>对线程进行一些维护和管理，比如定时开始，周期执行，并发控制等等</p></blockquote><p>不要用多线程去治理长连接，肯定是异步的网络模型nio，不在这里多说。</p><h3 id="2、线程池参数什么意思？"><a href="#2、线程池参数什么意思？" class="headerlink" title="2、线程池参数什么意思？"></a>2、线程池参数什么意思？</h3><p><strong>corePoolSize</strong></p><blockquote><p>常驻核心线程数，即本地任务执行完毕，核心线程也不会被销毁</p></blockquote><p><strong>maximumPoolSize</strong></p><blockquote><p>线程池最大线程数，必须大于等于1，如果待执行的线程数大于此值，需要借助第五个参数（workQueue）的帮助，缓存在队列中，如果与核心线程数一致的话，即固定了线程池大小</p></blockquote><p><strong>keepAliveTime</strong></p><blockquote><p>线程池中的线程空闲时间，当空闲时间达到此值时，线程会被销毁，只剩下核心线程</p></blockquote><p><strong>TimeUnit</strong></p><blockquote><p>时间单位，结合上面这个一起用，通常是秒</p></blockquote><p><strong>workQueue</strong></p><blockquote><p>表示缓存队列，请求的线程数大于线程池最大线程数时，线程进入BlockingQueue阻塞队列</p></blockquote><p><strong>threadFactory</strong></p><blockquote><p>线程工厂，用来生产一组相同任务的线程，线程池的命名就是通过给这个factory增加组名前缀来实现的</p></blockquote><p><strong>handler</strong></p><blockquote><p>表示执行拒绝策略的对象，当超过第五个为参数workQueue的任务缓存区上线的时候，就可以通过该策略处理请求，这是一种简单的限流保护</p></blockquote><h3 id="3、线程池中的threadpoolexecutor，每个参数是干嘛用的？"><a href="#3、线程池中的threadpoolexecutor，每个参数是干嘛用的？" class="headerlink" title="3、线程池中的threadpoolexecutor，每个参数是干嘛用的？"></a>3、线程池中的threadpoolexecutor，每个参数是干嘛用的？</h3><h3 id="4、说一下线程池内部使用规则"><a href="#4、说一下线程池内部使用规则" class="headerlink" title="4、说一下线程池内部使用规则"></a>4、说一下线程池内部使用规则</h3><h3 id="5、用过AtomicInteger吗？怎么用的"><a href="#5、用过AtomicInteger吗？怎么用的" class="headerlink" title="5、用过AtomicInteger吗？怎么用的"></a>5、用过AtomicInteger吗？怎么用的</h3><h3 id="6、用过threadlocal吗？怎么用的"><a href="#6、用过threadlocal吗？怎么用的" class="headerlink" title="6、用过threadlocal吗？怎么用的"></a>6、用过threadlocal吗？怎么用的</h3><h3 id="7、程序、进程、线程的区别？举个现实的例子说明"><a href="#7、程序、进程、线程的区别？举个现实的例子说明" class="headerlink" title="7、程序、进程、线程的区别？举个现实的例子说明"></a>7、程序、进程、线程的区别？举个现实的例子说明</h3><h3 id="8、java中通过哪些方式创建多线程类？分别使用代码说明，并调用之"><a href="#8、java中通过哪些方式创建多线程类？分别使用代码说明，并调用之" class="headerlink" title="8、java中通过哪些方式创建多线程类？分别使用代码说明，并调用之"></a>8、java中通过哪些方式创建多线程类？分别使用代码说明，并调用之</h3><h3 id="9、Thread类有没有实现Runnable接口？"><a href="#9、Thread类有没有实现Runnable接口？" class="headerlink" title="9、Thread类有没有实现Runnable接口？"></a>9、Thread类有没有实现Runnable接口？</h3><h3 id="10、当调用一个线程对象的start方法后，线程马上进入运行"><a href="#10、当调用一个线程对象的start方法后，线程马上进入运行" class="headerlink" title="10、当调用一个线程对象的start方法后，线程马上进入运行"></a>10、当调用一个线程对象的start方法后，线程马上进入运行</h3><h3 id="11、下面的代码，实际上有几个线程在运行"><a href="#11、下面的代码，实际上有几个线程在运行" class="headerlink" title="11、下面的代码，实际上有几个线程在运行"></a>11、下面的代码，实际上有几个线程在运行</h3><h3 id="12、线程的几种状态"><a href="#12、线程的几种状态" class="headerlink" title="12、线程的几种状态"></a>12、线程的几种状态</h3><h3 id="13、说说：sleep、yield、join、wait方法的区别"><a href="#13、说说：sleep、yield、join、wait方法的区别" class="headerlink" title="13、说说：sleep、yield、join、wait方法的区别"></a>13、说说：sleep、yield、join、wait方法的区别</h3><p><strong>join</strong></p><blockquote><p>谁调用了join，谁就会被阻塞，直到join执行完毕</p><p>当先线程等待，调用此方法的线程执行结束再继续执行</p><p>比如：在main方法中调用t.join(),那么main会进入阻塞状态，一直等待t线程执行完毕，main方法再恢复到就绪状态，准备继续执行</p></blockquote><p><strong>sleep</strong></p><blockquote><p>需要制定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态。</p><p>该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。</p></blockquote><h3 id="14、为什么不推荐使用stop和destory方法来结束线程"><a href="#14、为什么不推荐使用stop和destory方法来结束线程" class="headerlink" title="14、为什么不推荐使用stop和destory方法来结束线程"></a>14、为什么不推荐使用stop和destory方法来结束线程</h3><h3 id="15、写个代码说明，终止线程的典型方式"><a href="#15、写个代码说明，终止线程的典型方式" class="headerlink" title="15、写个代码说明，终止线程的典型方式"></a>15、写个代码说明，终止线程的典型方式</h3><h3 id="16、A线程的优先级是10，b线程的优先级是1，那么当进行调度时一定会调用A吗？"><a href="#16、A线程的优先级是10，b线程的优先级是1，那么当进行调度时一定会调用A吗？" class="headerlink" title="16、A线程的优先级是10，b线程的优先级是1，那么当进行调度时一定会调用A吗？"></a>16、A线程的优先级是10，b线程的优先级是1，那么当进行调度时一定会调用A吗？</h3><h3 id="17、synchronized加在static关键字前和普通方法前的区别？"><a href="#17、synchronized加在static关键字前和普通方法前的区别？" class="headerlink" title="17、synchronized加在static关键字前和普通方法前的区别？"></a>17、synchronized加在static关键字前和普通方法前的区别？</h3><blockquote><p>Synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”，不同的对象没有竞争关系</p><p>Synchronized修饰static静态方法，实际上是对该类对象加锁，俗称“类锁”，这个类所有的对象竞争一把锁</p><p>结论：类锁和对象锁不同，他们之间不会产生互斥。</p></blockquote><h3 id="18、使用Timer和TimerTask实现定时执行，定时在每天下午17：00执行"><a href="#18、使用Timer和TimerTask实现定时执行，定时在每天下午17：00执行" class="headerlink" title="18、使用Timer和TimerTask实现定时执行，定时在每天下午17：00执行"></a>18、使用Timer和TimerTask实现定时执行，定时在每天下午17：00执行</h3><h3 id="19、wait方法被调用时，所在线程是否会释放所持有的锁资源？sleep方法呢？"><a href="#19、wait方法被调用时，所在线程是否会释放所持有的锁资源？sleep方法呢？" class="headerlink" title="19、wait方法被调用时，所在线程是否会释放所持有的锁资源？sleep方法呢？"></a>19、wait方法被调用时，所在线程是否会释放所持有的锁资源？sleep方法呢？</h3><h3 id="20、wait、notify、notifyAll是在Thread类中定义的方法吗？作用分别是什么？"><a href="#20、wait、notify、notifyAll是在Thread类中定义的方法吗？作用分别是什么？" class="headerlink" title="20、wait、notify、notifyAll是在Thread类中定义的方法吗？作用分别是什么？"></a>20、wait、notify、notifyAll是在Thread类中定义的方法吗？作用分别是什么？</h3><h3 id="21、notify是唤醒所在对象watipool中的一个线程吗？"><a href="#21、notify是唤醒所在对象watipool中的一个线程吗？" class="headerlink" title="21、notify是唤醒所在对象watipool中的一个线程吗？"></a>21、notify是唤醒所在对象watipool中的一个线程吗？</h3><h3 id><a href="#" class="headerlink" title></a></h3><h1 id="java虚拟机"><a href="#java虚拟机" class="headerlink" title="java虚拟机"></a>java虚拟机</h1><h2 id="说一说jvm的内存模型（每一个模块都说）"><a href="#说一说jvm的内存模型（每一个模块都说）" class="headerlink" title="说一说jvm的内存模型（每一个模块都说）"></a>说一说jvm的内存模型（每一个模块都说）</h2><p><strong>方法区（Method Area）</strong></p><blockquote><p>方法区主要是放一下类似类定义、常量、编译后的代码、静态变量等，在jdk1.7中hotspot vm 的实现就把他放在了永久代中，这样的好处是可以直接使用堆中的gc算法来管理，但坏处就是经常会出现内存溢出。</p><p>所以在1.8中，取消了<strong>永久代</strong>，<strong>用元空间取而代之</strong>，元空间直接使用本地内存，perm（永久代）区的字符串常量在堆内存</p><p><strong>常量池中的string实际是保存在堆内存中的</strong></p></blockquote><p><strong>堆（heap）</strong></p><blockquote><p>oom故障最主要的发源地，几乎存储着所有的实例对象，堆由垃圾收集器自动回收，由各子线程共享使用，通常情况下，堆占用的内存是内存区域中最大的</p><p>对的内存空间既可以固定大小，也可以运行时动态调整，但是通常为了避免堆空间的不断扩容与收缩，在线上环境时，jvm最大堆空间和最小堆空间设置成一样，避免gc后调整大小带来的额外压力</p><p><strong>新生代：</strong>1个eden区+2个survivor区</p><p>绝大部分对象在eden区生成，当eden区满了的时候，会触发young gc。垃圾回收的时候，在eden区实现清除策略，没有被引用的对象则直接回收。依然存活的对象会被已送到Survivor区。</p><p>Survivor分为s0 和 s1两块内存空间，那么送到哪块呢？每次ygc的时候，他们将存活的对象复制到未使用的那块空间，然后将当前正在使用的空间完全清除，交换两块空间的使用状态。</p><p>如果ygc要移送的对象大于Survivor区容量的上限，则直接移交给老年代。</p><p>每个对象都有一个计数器，每次ygc都会加1，-XX：MaxTenuring Threshold参数能配置计数器的值达到某个阈值的时候，对象从新生代晋升至老年代，如果该参数配置为1，那么从新生代的eden区直接移送到年老代。</p><p>默认值是15，可以在Survivor区交换14次之后，晋升至老年代。</p><p>流程图如下：</p><p>![image-20200114135528237](img/尚学堂 java 300 讲.assets/image-20200114135528237.png)</p><p>如果Survivor区无法放下，会尝试在老年代中进行分配，如果老年代也放不下，则会触发「fgc」，如果『fgc』后依然放不下，则抛出oom，所以给jvm设置运行参数-XX：+heapDumpOnOutOfMemoryError，让jvm遇到oom异常时能输出堆信息，特别是相隔数月才出现的oom异常尤为重要</p></blockquote><p><strong>虚拟机栈</strong></p><blockquote><p>jvm在执行方法时，会在此区域中创建一个栈帧来存放方法的各种信息，比如返回值，局部变量表和各种对象引用等，方法开始执行前就先创建栈帧入栈，执行完后就出栈</p><p>只有位于栈顶帧才是有效的， 称为“当前栈”</p></blockquote><p><strong>本地方法栈</strong></p><blockquote><p>和虚拟机栈类似，不过是专门给native方法用的</p></blockquote><p><strong>程序计数器</strong></p><blockquote><p>占用很小的一块区域，我们知道jvm执行代码是一行一行执行字节码文件，所有需要一个计数器来记录当前执行的行数</p></blockquote><h2 id="说一说垃圾回收吧？有哪些垃圾回收算法"><a href="#说一说垃圾回收吧？有哪些垃圾回收算法" class="headerlink" title="说一说垃圾回收吧？有哪些垃圾回收算法"></a>说一说垃圾回收吧？有哪些垃圾回收算法</h2><p><strong>标记-清除</strong></p><blockquote><p>分为两个阶段，标记阶段、清除阶段</p><p>在标记阶段，首先通过<strong>根节点</strong>（gc roots）,标记所有从根节点开始的对象，未被标记的对象是未被引用的垃圾对象，然后，在清除阶段，清除所有未被标记的对象</p><p><strong>缺点：</strong>会带来大量的空间碎片，在分配一个较大连续空间时容易触发fgc</p></blockquote><p><strong>标记-整理</strong></p><blockquote><p>从根集合节点进行扫描，标记出所有的存活对象，并将这些存活的对象整理到内存空间的一端，形成连续的已使用空间，最后把已使用空间之外的部分全部清理掉，这样就不会产生空间碎片</p></blockquote><p><strong>标记-复制</strong></p><blockquote><p>为了能够并行的标记和整理，将空间分为了两块，每次只激活其中一块，垃圾回收时只需要把存活的对象复制到另一块未激活的空间上，然后把未激活标记为已激活，把已激活标记未激活，然后清理原空间中的对象</p><p><strong>场景：</strong>作为主流的ygc算法进行新生代的垃圾回收</p></blockquote><p><strong>分代收集算法</strong></p><blockquote><p>目前虚拟机使用回收算法，解决了标记整理不适合老年代的问题</p><p>将内存分为各个年代，一般是来年代，和新生代，永久代（jdk1.8中被元空间替代）</p><p>新生代存活率低，可以使用复制算法</p><p>老年代对象存活率高，没有额外空间对他进行分配担保，所以只能使用标记清除或者标记整理</p></blockquote><p><strong>如何判断一个对象是否应该回收</strong></p><blockquote><p><strong>方法1：引用计数</strong>，该对象每被一个地方引用，计数器就加+1，引用失效时，计数器-1，计数器为0时的对象就不能再被使用</p><p>缺点：很难解决循环引用的问题</p><p><strong>方法2：可达性分析法</strong>：通过gc  roots作为七点，从这些节点开始，向下搜索，当一个对象到gc roots没有任何引用链，这个对象就是不可用的，至少<strong>两次标记</strong></p></blockquote><p><strong>什么可以作为GC ROOT呢？</strong></p><blockquote><p>类静态属性中引用的对象（方法区）</p><p>常量引用的的对象（方法区）</p><p>虚拟机栈中引用的对象（栈帧中的本地变量表）</p><p>jni引用的对象（本地方法栈）</p></blockquote><p><strong>除了垃圾回收，还有哪些工作会造成cpu负载过高，100%负载，并给出排查过程</strong></p><blockquote><ol><li>使用top命令查找占用cpu高的进程pid</li><li>显示线程列表  ps -mp 35867 -o THREAD,tid,time—-找到占用cpu过高的tid</li><li>将需要的线程tid转换为16进制    printf “%x\n” 35889</li><li>打印线程堆栈信息     jstack 35867 |grep 8c31 -A 30</li></ol></blockquote><p><strong>cms收集器的特点</strong>（标记-清除）</p><blockquote><p>回收停顿时间比较短，四个步骤完成工作</p><ul><li>初始标记（只是标记一下gc roots能直接关联到的对象，速度很快）</li><li>并发标记（进行gc roots tracing 追踪）</li><li>重新标记（为了修正并发标记期间因用户程序持续运行产生变动的那一部分对象的标记记录，比1长，比2短）</li><li>并发清除（）</li></ul><p><strong>缺点</strong></p><p>第1、3步需要stw</p><p>对cpu资源非常敏感，在并发阶段，虽然不会导致用户线程停顿，但是因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低</p><p>因为标记-清除，会产生大量碎片，可以配置参数，强制jvm在fgc后对老年代进行压缩，但是会stw</p></blockquote><p><strong>G1</strong>★★★★</p><blockquote><p>四个步骤</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul><p>g1在jdk1.7中是推荐使用，jdk11是默认的</p><p>将堆空间分割成若干个大小相同的区域，即region，包括eden、Survivor、old、Humongous四种类型，Humongous是特殊的ol的类型，专门存放大对象，防止了反复拷贝移动</p><p>这样的划分方式，意味着不需要一个连续的内存空间管理对象，g1采用的是mark-copy，不产生大量的空间碎片</p><p>g1提供两种gc模式，ygc，mixedgc，两种都是stw的</p></blockquote><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p><strong>String  a = ‘’abc”； 和 String b = new String（“abc”）；是不是一样的？为什么？他们对应的内存空间分别是什么？</strong></p><blockquote><p>不一样</p><p>String  a = ‘’abc”是在现在栈中创建一个string类的对象引用变量，然后查找栈中有没有存放“abc”，如果没有则将“abc”放入栈，并令a指向abc</p><p>new String（abc）是在堆中存放，每次new 都会在堆中存放一个</p><p>equals比较值是否相等，==比较地址是否相等</p></blockquote><h2 id="Object-o-new-Object"><a href="#Object-o-new-Object" class="headerlink" title="Object o = new Object()"></a>Object o = new Object()</h2><p><strong>解释一下对象的创建过程（半初始化）</strong></p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span></span>&#123;</span><br><span class="line">&gt; <span class="keyword">int</span> m = <span class="number">8</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; T t = <span class="keyword">new</span> T();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>编译后的字节码如下</p><ol><li><p>new</p><p>为对象申请了一块内存，m此时是默认值，半初始化</p></li><li><p>dup</p></li><li><p>invokespecial #3&lt;T.<init>&gt;</init></p><p>这里才会把m设置为8，第1、3步之间就是半初始化状态</p></li><li><p>astore_1</p></li><li><p>return</p></li></ol></blockquote><p><strong>dcl单例(Double Check Lock)到底需不需要volatile问题</strong></p><blockquote><p>上锁前检查一次，上锁后再检查一次，要不要在定义的 时候加个volatile？</p><p>阻止对这块内存的访问指令重排序 。需要，出现的几率很小，但是还是需要</p><p><img src="img/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.assets/image-20200305221218238.png" alt="image-20200305221218238"></p></blockquote><p><strong>对象在内存中的存储布局</strong></p><p><img src="img/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.assets/image-20200305223356714.png" alt="image-20200305223356714"></p><blockquote><p><strong>普通对象 new xx()</strong></p><ul><li>对象头markword </li><li>类型指针classpointer：这个类型是什么类型？指向xx.class</li><li>实例数据instance data  比如说m=1，对象的数据</li><li>对齐padding ，比如最后算出来是30个字节？不是8的倍数怎么办？长成32</li></ul><p><strong>数组</strong> T[] a = new T[5]</p><ul><li>对象头</li><li>类型指针:数组是什么类型？int？T？</li><li>数组长度（length 4字节）</li><li>实例数据</li><li>对齐</li></ul></blockquote><p><strong>对象头具体包括什么</strong></p><blockquote><ul><li>锁的信息</li><li>gc的信息：被回收多少次了</li><li>hashCode</li></ul><p><strong>对象头占用8个字节（64位虚拟机）</strong></p><img src="img/面试准备.assets/image-20200305223705998.png" alt="image-20200305223705998" style="zoom:50%;"><p>什么时候回产生hashcode？当然是调用未重写的hashcode()方法以及System.identityHashCode的时候</p></blockquote><p><strong>对象怎么定位</strong></p><blockquote><img src="img/面试准备.assets/image-20200306114341914.png" alt="image-20200306114341914" style="zoom:50%;"><p>直接指针是hotspot使用的方式</p><p><strong>句柄方式</strong>：</p><p>优点：对象小，垃圾回收时不用频繁改动t</p><p>缺点：两次访问</p><p><strong>直接指针</strong></p></blockquote><p><strong>对象怎么分配（栈上-线程本地-eden-old）</strong></p><blockquote><img src="img/面试准备.assets/image-20200306115136889.png" alt="image-20200306115136889" style="zoom:50%;"></blockquote><p><strong>该代码在内存中占用多少字节</strong></p><blockquote><p>要看压不压缩</p><p>一个object占多少字节？</p><p>16</p><p>new int[]{} 是24</p></blockquote><h1 id="常用框架、技术"><a href="#常用框架、技术" class="headerlink" title="常用框架、技术"></a>常用框架、技术</h1><h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><p>spring框架是一个轻量级的控制反转和面向切面的容器框架</p><p><strong>轻量</strong></p><blockquote><p>从大小到开销来说都是轻量的，spring框架开源字啊一个只有1m大小的jar文件中发布，而且spring所处理的开销也是微不足道的</p></blockquote><p><strong>非侵入式</strong></p><blockquote><p>spring应用中的对象不依赖于spring的特定类</p></blockquote><p><strong>IOC（控制反转）</strong></p><blockquote><p>一个对象依赖的其他对象会通过被动的方式传递进来，而不是这个对象自己创建或者主动查找依赖对象</p></blockquote><p><strong>AOP（面向切面）</strong></p><blockquote><p>只完成业务逻辑，并不负责其他的系统级的关注点</p></blockquote><p><strong>容器</strong></p><blockquote><p>定义了bean是如何创建、配置、管理的</p></blockquote><h3 id="框架模块"><a href="#框架模块" class="headerlink" title="框架模块"></a>框架模块</h3><p>你可以不必将应用完全基于spring，可以自由的挑选适用你的模块，而忽略其余的模块</p><h4 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h4><p>这是spring框架最基础的部分，它提供了<strong>依赖注入</strong>特征来实现容器对bean的管理。这里最基本的概念是BeanFactory，它是任何spring应用的核心。BeanFactory是工厂模式的一个实现，他使用ioc将应用配置和依赖说明从实际的应用代码中分离出来</p><h4 id="应用上下文（context）模块"><a href="#应用上下文（context）模块" class="headerlink" title="应用上下文（context）模块"></a>应用上下文（context）模块</h4><p>核心模块的beanFactory使spring成为了一个容器，而上下文模块使他成为一个框架，这个模块扩展了BeanFactory的概念，增加了对国际化消息、事件传播以及验证的支持</p><p>另外，这个模块提供了许多企业服务，例如电子邮件、JNDI访问、EJB集成、远程以及时序调度（scheduling）服务。也包括了对模版框架例如Velocity和FreeMarker集成的支持。</p><h4 id="AOP模块"><a href="#AOP模块" class="headerlink" title="AOP模块"></a>AOP模块</h4><h4 id="JDBC抽象和DAO模块"><a href="#JDBC抽象和DAO模块" class="headerlink" title="JDBC抽象和DAO模块"></a>JDBC抽象和DAO模块</h4><p>使用jdbc经常导致大量的重复代码：连接、创建于巨，处理结果集，关闭链接。</p><p>这两个模块抽取了这些重复代码，因此可以保持数据库访问代码干净简洁。</p><p>这个模块还使用了<strong>aop模块</strong>为spring应用中的对象提供了事务管理服务</p><h4 id="对象-关系映射集成"><a href="#对象-关系映射集成" class="headerlink" title="对象/关系映射集成"></a>对象/关系映射集成</h4><p>orm模块，spring并不试图实现自己的orm解决方案，而是为集中流行orm框架提供了集成方案。</p><p>spring的事务管理支持这些orm框架中的每一个也包括jdbc。</p><h4 id="WEB-模块"><a href="#WEB-模块" class="headerlink" title="WEB 模块"></a>WEB 模块</h4><p>web上下文模块建立于应用上下文模块之上，提供了一个合适于web应用的上下文。另外，这个模块还提供了一些面向服务支持。例如：实现文件上传的multipart请求，它也提供了spring 和其它web框架的集成，比如Struts、WebWork。</p><h4 id="mvc框架"><a href="#mvc框架" class="headerlink" title="mvc框架"></a>mvc框架</h4><p>spring为构建web应用提供了一个功能全面的mvc框架。虽然spring可以很容易的与其它mvc框架集成，例如struts，但spring的mvc框架使用ioc对控制逻辑和业务对象提供了完全的分离。</p><h2 id="ioc"><a href="#ioc" class="headerlink" title="ioc"></a>ioc</h2><h2 id="使用到的设计模式"><a href="#使用到的设计模式" class="headerlink" title="使用到的设计模式"></a>使用到的设计模式</h2><p><strong>1.简单工厂模式</strong></p><blockquote><p>应用场景：又叫静态工厂，不属于23中设计模式。实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类</p><p>BeanFactory就是简单工程模式的体现，根据传入一个唯一的标识来获取bean对象</p></blockquote><p><strong>2.工厂模式</strong></p><blockquote><p>应用场景：通常由应用程序直接使用new创建新的对象，为了将对象的创建和使用相分离，采用工厂模式，即应用程序将对象的创建及初始化职责交给工厂对象。</p><p>一般情况下，应用程序有自己的工厂对象来创建bena，如果将应用程序自己的工程对象交给spring管理，那么spring管理就不是普通bean，而是工程bean</p></blockquote><p><strong>3.单例模式</strong></p><blockquote><p>应用场景：保证一个类只有一个实例，并提供一个访问它的全局访问点</p><p>spring中的单例模式只完成了后半句，即提供了全局的访问点BeanFactory，但没有从构造器级别去空值单例，这是因为spring管理的是任意的java对象，spring下默认的bean均为单例</p></blockquote><p><strong>4.原型模式-Prototype</strong></p><blockquote><p>应用场景：原型模式就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节</p><p>所谓原型模式，就是java中的克隆技术，以某个对象为原型，复制出新的对象，显然新的对象具备原型对象的特点，效率噶（避免了重新执行构造过程步骤）</p></blockquote><p><strong>5.代理模式–Proxy</strong></p><blockquote><p>应用场景：为其他对象提供一种代理以控制对这个对象的访问。从结构上看和Decorator（装饰器）模式类似，但是proxy是控制，更像是一种对功能的闲置，而Decorator是增加职责。</p><p>spring中代理模式体现在aop中，比如cglibAopProxy，和jdkAopProxy</p></blockquote><p><strong>6.策略模式–Strategy</strong></p><blockquote><p>应用场景：定义一系列的算法，把它们一个个封装起来，并且使他们可互相替换，最终执行结果是固定的，执行过程和执行逻辑不一样</p><p>spring中在实例化对象的时候用到了Strategy模式</p></blockquote><p><strong>7.模板方法模式–TemplateMethod</strong></p><blockquote><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤</p><p>TemplateMethod模式一般是需要继承的。执行流程固定，但是中间实现步骤有细微差别</p><p>springorm数据类型</p></blockquote><p><strong>8.委派模式–Delegate</strong></p><blockquote><p>应用场景：不属于23中设计模式，是面向对象设计模式中常用的一种模式。这种模式的原理为类b和类a是两个没有任何关系的类，b具有和a一模一样的方法和属性；并且调用b中的方法，属性就是调用a中同名的方法和属性，b好像就是一个受a委托授权的终结。第三方的代码不需要指定a的存在，也不需要和a发生直接的联系，通过b就可以直接使用a的功能，这样既能够使用到a的各种功能，又能够很好的将a保护起来，一举两得</p><p>要和代理模式区分开来，持有被委托人的引用，不关心过程，只关心结果</p><p>DIspatcher</p></blockquote><p><strong>9.适配器模式–Adapter</strong></p><blockquote><p>springAOP模块对BeforeAdvice、AfterAdvice、ThrowsAdvice三种通知类型的支持实际上是借助适配器模式来实现的，这样的好处是使得框架允许用户向框架中加入自己想要支持任何一种通知雷丁，这三种通知类型是springAOP模块定义的，他们是AOP联盟定义的Advice的子类型</p></blockquote><p><strong>10.装饰器模式–Decorator</strong></p><blockquote><p>应用场景：比如说项目需要多数据库连接，用户每次访问都会根据需要去访问不同的数据库</p><p>首先想到的是在spring的applicationContext中配置所有的DataSource。这些DataSource可能是各种不同类型的，比如不同的数据库oracle、mysql，也可能是不同的数据源：比如Apache提供的org.apache.commons.dbcp.BasicDataSource、Spring提供的org.springframework.jndi.JndiObjectFactoryBean等。然后SessionFactory根据客户的每次请求，将DataSource属性设置成不同的数据源，以到达切换数据源的目的。</p><p>spring中用的包装器模式在类名上有两种表现：一种是类名中含有Wrapper、另一种是类名中喊有Decorator。基本上都是动态的给一个对象添加一些额外的职责。</p><p>io流包装、数据源包装等</p></blockquote><p><strong>11.观察者模式–Observer</strong></p><blockquote><p>应用场景：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变是，所有依赖于它的对象都得到通知并被自动更新</p><p>Spring中Observer模式常用的地方是Listener的实现。如：ApplicationListener</p><p>一般由两个角色组成：发布者和订阅者（观察者），观察者通常有一个回调，也可以没有，监听器、日志收集</p></blockquote><p>设计模式对比</p><table><thead><tr><th>设计模式</th><th>一句话归纳</th></tr></thead><tbody><tr><td>工厂模式Factory</td><td>只对结果负责，不要三无产品</td></tr><tr><td>单例模式Singleton</td><td>保证独一无二</td></tr><tr><td>适配器模式Adapter</td><td>需要一个转换头（兼容）</td></tr><tr><td>装饰器模式 Decorator</td><td>需要包装，但不改变本质（同宗同源）</td></tr><tr><td>代理模式Proxy</td><td>办事要求人，所以找代理</td></tr><tr><td>观察者模式Observer</td><td>完成时通知我</td></tr><tr><td>策略模式Strategy</td><td>我行我素，达到目的就行</td></tr><tr><td>模板模式Template</td><td>流程标准化，原料自己加</td></tr><tr><td>委派模式Delegate</td><td>干活是你的（普通员工），功劳是我的（项目经理）</td></tr><tr><td>原型模式prototype</td><td>拔一根好，吹出千万个</td></tr></tbody></table><p>编程思想总结</p><table><thead><tr><th>spring思想</th><th>应用场景（特点）</th><th>一句话归纳</th></tr></thead><tbody><tr><td>aop</td><td>面向切面变成，找出多个类中中有一定规律的代码，开发时拆开，运行时再合并，例如aop日志</td><td>解耦，专人做专事</td></tr><tr><td>oop</td><td>面向对象变成，归纳总结生活中的一切事务</td><td>封装、集成、多态</td></tr><tr><td>bop</td><td>面向bean编程，面向bean（普通java类）设计程序</td><td>一切从bean开始</td></tr><tr><td>ioc</td><td>控制翻转，将new对象的动作交给spring管理，并由spring保存已创建的对象（ioc容器）</td><td>转交控制权（控制翻转）</td></tr><tr><td>DI/DL</td><td>依赖注入或者依赖查找，spring不仅保存自己创建的对象，而保存对象与对象之间的关系<br>注入即赋值，主要三种方式：构造方法、set方法、直接赋值</td><td>先理清关系再赋值</td></tr></tbody></table><p>cglib与jdk的区别是：</p><blockquote><p>创建代理的消耗</p><p>cglib不适合频繁创建，适合创建一次，长期使用</p></blockquote><h3 id="spring-bean-的加载、注入过程"><a href="#spring-bean-的加载、注入过程" class="headerlink" title="spring bean 的加载、注入过程"></a>spring bean 的加载、注入过程</h3><blockquote><ol><li>执行该对象的构造方法</li><li>执行set参数注入方法</li><li>执行BeanNameAware的实现方法获取bean的id</li><li>执行BeanFactoryAware的实现方法获取bean的工厂</li><li>执行BeanPostProcessor的postProcessBeforeInitalization处理方法</li><li>执行In</li></ol></blockquote><h3 id="说一下对spring的理解，ioc和aop在项目里怎么用的"><a href="#说一下对spring的理解，ioc和aop在项目里怎么用的" class="headerlink" title="说一下对spring的理解，ioc和aop在项目里怎么用的"></a>说一下对spring的理解，ioc和aop在项目里怎么用的</h3><p>spring 是一个开源框架，处于mvc的控制层，能应对需求的快速变化，主要原因是它有一种面向切面编程（aop）的优势</p><p>其次它提升了系统性能，是因为通过依赖倒置机制（ioc），系统中用到的对象不是在系统加载时就全部实例化，而是在调用到这个类时才会实例化该对象</p><p><strong>优点</strong></p><blockquote><ul><li>降低了组件之间的耦合性，实现了软件各层之间的解耦</li><li>可以使用容易提供的众多服务，事务管理、消息服务、日志记录等</li><li>容器提供了aop，利用它很容易实现如权限拦截、运行期监控等功能</li></ul></blockquote><p>Spring中的aop技术是设计模式中的动态代理模式</p><h2 id="AOP的两种实现方式？哪个效率更高？为什么？"><a href="#AOP的两种实现方式？哪个效率更高？为什么？" class="headerlink" title="AOP的两种实现方式？哪个效率更高？为什么？"></a>AOP的两种实现方式？哪个效率更高？为什么？</h2><p>jdk动态代理、cglib</p><p>JDK<strong>动态代理具体实现原理</strong></p><blockquote><ul><li>通过实现InvocationHandle接口创建自己的调用处理器</li><li>通过Proxy类指定ClassLoader对象和一组interface来创建动态代理</li><li>通过反射机制获取动态代理类的构造函数，其唯一参数类型就是调用处理器接口类型</li><li>通过构造函数创建动态代理实例，构造时调用处理器对象作为参数传入；</li></ul><p>jdk动态代理是面向接口的代理模式，如果被代理目标没有接口那么spring也无能为力，Spring通过java的 反射机制生产被代理接口的新的匿名实现类，重写了其中AOP的增强方法。</p></blockquote><p><strong>CGLib动态代理</strong></p><blockquote><p>强大的、高性能的Code生产类库，可以实现运行期动态扩展java类，Spring在运行期间通过cglib集成要被动态代理的类，重写父类的方法，实现Aop切面变成</p></blockquote><p><strong>两者的对比</strong></p><blockquote><p>jdk是面向接口的</p><p>cglib是通过字节码底层集成要代理类来实现（如果被代理类被final修饰，那么会失败）</p></blockquote><p><strong>性能</strong></p><blockquote><p>主要体现在如下的两个指标中</p><ul><li>cglib所创建的动态搭理对象在实际运行时候的性能要比jdk高，大概10倍</li><li>cglib在创建对象的时候所花费的时间比jdk要高，大概8倍</li></ul><p>因此，对于Singleton的代理对象或者具有实例池的代理，因为无需频繁的创建代理对象，所以比较适合采用cglib动态代理，反之使用jdk</p></blockquote><h3 id="spring事务的传播机制"><a href="#spring事务的传播机制" class="headerlink" title="spring事务的传播机制"></a>spring事务的传播机制</h3><p>有如下几种</p><ul><li><p>PROPAGATION_REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</p></li><li><p>PROPAGATION_SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。</p></li><li><p>PROPAGATION_MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常。</p></li><li><p>PROPAGATION_REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。</p></li><li><p>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p></li><li><p>PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p></li><li><p>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p></li></ul><p>常用的主要由三个：Required、RequresNew、Nested</p><ul><li>Required：简单理解就是事务方法会判断是否存在事务，有事务就用已有的，没有就重新开启一个</li><li>RequiresNew：简单理解就是开启新事务，若当前已有事务，挂起当前事务。新开启的事务和之前的事务无关，拥有自己的锁和隔离级别，可以独立提交和回滚，内层事务执行期间，外层事务挂起。内层事务执行完毕，外层事务恢复执行</li><li>Nested：简单理解就是：嵌套事务，如果外部事务回滚，则嵌套事务也回滚！！外部事务提交的时候，嵌套事务才会被提交。嵌套事务回滚不会影响外部事务</li></ul><p>如果想事务一起执行可以用Required满足大部分场景，如果不想让执行的子事务的结果影响到父事务的提交，可以将子事务设置为RequiresNew</p><h3 id="简单说一下IOC、DI"><a href="#简单说一下IOC、DI" class="headerlink" title="简单说一下IOC、DI"></a>简单说一下IOC、DI</h3><p>Inversion on Control，控制翻转，对象的创建交给外部容器完成，这个就叫做控制翻转</p><p>Dependency injection，依赖注入、处理对象的依赖关系</p><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><ul><li>控制反转，解决对象创建的问题</li><li>依赖注入，在创建完对象后，对象的关系的处理就是依赖注入</li></ul><h2 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h2><ol><li><p>核心配置文件是哪几个？他们的区别是啥？</p><p>applicaion和boostrap配置文件</p><p>application配置文件主要用于springboot项目的自动化配置</p><p>boostrap配置文件主要用于</p><p>​    一些固定的不能被覆盖的属性，一些加密解密的场景</p></li><li><p>配置文件有哪几种格式？有什么区别？</p><p>properties和yml</p><p>区别就是书写格式不同</p><p>另外 yml 格式不支持@propertySource注解导入配置</p></li><li><p>事务是怎么实现的？</p><p>基于@Transactional注解</p><blockquote><p>整体事务控制流程</p><ol><li>当@Transactional注解的方法被外部的代码调用时，spring在运行时为方法所在类生成一个aop代理对象。</li><li>代理对象根据@transactional的属性，决定是否由事务拦截器TransactionInterceptor对此方法进行事务拦截。</li><li>在进行事务拦截时，会先开启事务，然后执行业务代码，根据执行是否出现异常，通过抽象事务管理来进行rollback或者commit。</li></ol></blockquote></li><li><p>数据库引擎是否支持事务？</p><p>mysql的mylsam不支持事务</p><p>如果事务生效，库和表的引擎必须是InnoDB</p><p>当事务方法被本类内部方法调用时，@Transactional 注解并不生效，因为，只有被当前类以外的调用时，才会由spring生成的代理对象来管理</p><p>一定要确保所使用的数据源加载了事务管理器（配置文件写一下就好）</p></li><li><p>springboot的核心注解是哪个？他主要由哪几个注解组成？</p><p>启动类上面的注解是@springbootApplication，它是核心注解，包含了以下三个注解</p><p>@springbootConfiguration：组合了@Configuration注解，实现配置文件的功能</p><p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项</p><p>@ComponentScan：spring组件扫描</p></li><li><p>开启springboot 特性有哪几种方式?</p><ol><li>继承spring-boot-starter-parent项目</li><li>导入spring-boot-dependencies项目依赖</li></ol></li><li><p>springboot需要独立的容器运行吗？</p><p>可以不需要，内置了tomcat/jetty等容器。</p></li><li><p>springboot 配置加载顺序</p><ol><li>properties</li><li>yaml文件</li><li>系统环境变量</li><li>命令行参数</li></ol></li><li><p>springboot可以兼容老spring项目吗？如何做?</p><p>可以兼容，使用@ImportResource注解导入老spring项目配置文件</p></li><li><p>保护springboot应用有哪些方法？</p><ol><li>在生产中使用https</li><li>启用csrf保护</li><li>使用内容安全策略防止xss攻击</li></ol></li></ol><p><strong>private不能事务，基于aop实现的，aspectj可以</strong>？？</p><p><strong>springboot默认的代理是cglib</strong>？？</p><h2 id="spring-cloud"><a href="#spring-cloud" class="headerlink" title="spring cloud"></a>spring cloud</h2><ol><li><p>微服务之间是如何独立通讯的？</p><ol><li>同步：rpc、rest等</li><li>异步：消息队列</li></ol></li><li><p>ribbon和feign的区别？</p><ol><li>都是客户端的负载均衡工具，feign的底层是通过ribbon实现的，是对riboon的封装</li><li>ribbon使用httpclient或者restTemplate模拟http请求，步骤繁琐。</li><li>feign采用接口+注解的方式，将需要调用的其他服务的方法定义成抽象方法即可，不需要自己构建http请求。就像调用自身工程的方法一样调用</li></ol></li><li><p>注册中心用的什么？</p><p>用的nacos= eureka+config</p></li><li><p>nacos优点？</p><ol><li>nacos自带配置中心，且提供了管理界面</li><li>动态刷新，eureka需要配合mq实现配置动态刷新，nacos采用netty保持tcp场链接实时推送</li><li>nacos可用根据业务和环境进行分组管理</li><li>默认提供权重设置功能，调整承载流量压力</li><li>nacos支持由客户端或服务端发起的健康检查，eureka是由客户端发起心跳</li><li>nacos支持对服务在线管理，eureka只是预览服务状态</li></ol></li><li><p>选型建议？</p><p>采用eureka防范的考虑</p><ol><li>想用spring cloud 原生全家桶</li><li>想用本地文件和git作为配置管理的，将配置与服务分开管理</li><li>考虑短期的稳定性</li></ol><p>采用Nacos方案的考虑</p><ol><li>想在线对服务进行上下线和流量管理</li><li>不想采用MQ实现配置中心动态刷新</li><li>不想新增配置中心生产集群</li><li>考虑引入spring cloud alibaba生态</li></ol></li><li><p>eureka 和zookeeper都可以提供服务注册和发现的功能，请说说两个的区别？</p><ol><li><p>zookeeper保证的是cp，Eureka保证的ap</p><p>zookeeper在选举期间注册服务谈话，虽然服务最终会回复，但是选举期间不可用的</p><p>eureka各个节点是平等关系，只要有一台eureka就可以保证服务可以用，查询到的数据并不是最新的</p><blockquote><p>自我保护机制会导致：</p><p>eureka不再从注册列表移除因长时间没有收到心跳而应该过期的服务</p><p>eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点（高可用）</p><p>当网络稳定是，当前实例新的注册信息会被同步到其他节点中（最终一致性）</p><p>eureka可以很好的应对因为网络故障导致部分节点失去联系的情况，而不会像zookeeper一样使得整个注册系统瘫痪</p></blockquote></li><li><p>eureka可以看做是一个工程，而zookeeper只是一个进程</p></li></ol></li><li><p>springcloud是如何实现服务发现和注册的？</p><p>服务在发布时指定对应的服务名（包括了ip地址和端口）将服务注册到注册中心（eureka或者zookeeper或者nacos）</p><p>在main方法添加@enableDiscoveryClient 同一个服务修改端口就可以启动多个实例</p><p>调用方的话：传递服务名称通过注册中心获取所有的可用实例，通过负载均衡策略调用（ribbon和feign）对用的服务</p></li></ol><h2 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h2><h3 id="说一下mybatis与hibernate的区别"><a href="#说一下mybatis与hibernate的区别" class="headerlink" title="说一下mybatis与hibernate的区别"></a>说一下mybatis与hibernate的区别</h3><p><strong>共同点</strong></p><blockquote><p>都是通过orm对象关系映射框架，都是持久层数据框架</p></blockquote><p><strong>不同点</strong></p><ul><li>hibernate重量级框架，Mybatis是轻量级框架</li><li>Hibernate对jdbc的封装比较深，对开发者写sql的要求高，只要通过hql语句操作对象即可完成数据的持久化操作了</li><li>Mybatis也是对jdbc的封装，但是没有H那么深，他的sql语句都在配置里，也可以通过重新配置里sql，来实现数据优化</li><li>处理大数据的时候，建议使用Mybatis，它优化sql更方便</li></ul><h2 id="RocketMq"><a href="#RocketMq" class="headerlink" title="RocketMq"></a>RocketMq</h2><p><strong>核心模块</strong></p><ul><li>rocketmq-broker：接受生产者发来的消息并存储（通过调用rocketmq-stroe），消费者从这里取得消息</li><li>rocketmq-client：提供发送、接收消息的客户端API</li><li>rocketmq-namesrv：NameServer，类似于Zookeeper，这里保存着消息的TopicName，队列运行时的元信息</li><li>rocketmq-common：通用的一些类、方法、数据结构等</li><li>rocketmq-remoting：基于Netty4的client/Server + fastjson序列化 + 自定义二进制协议</li><li>rocketmq-store：消息、索引存储等</li><li>rocketmq-filtersrv：消息过滤器（一般用tag就可以）</li><li>rocketmq-tools：命令行工具</li></ul><p><strong>四大核心</strong>组成部分</p><p>他主要有四大核心：NameServer、Broker、Producer以及Consumer</p><img src="img/面试准备.assets/image-20200309102855022.png" alt="image-20200309102855022" style="zoom:50%;"><p>可以看到，他啥都是可以集群的，这是他吞吐量大，高可用的原因之一</p><p>集群的模式也很花哨，可以支持多master模式、多master多slave异步复制模式、多master多slave同步双写模式</p><p>而且这个模式好像kafka啊，废话，rocketmq 本身就是阿里基于kafka的很多特性研发的</p><h3 id="分别介绍一下各个集群组成部分"><a href="#分别介绍一下各个集群组成部分" class="headerlink" title="分别介绍一下各个集群组成部分"></a>分别介绍一下各个集群组成部分</h3><h4 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h4><blockquote><p>主要负责对数据源的管理，包括了对于topic和路由信息的管理。</p></blockquote><p>类似于Dubbo中zookeeper，但NameServer与Zookeeper相比更轻量。主要是因为每个NameServer节点互相之间是独立的，没有任何信息交互。</p><p>NameServer压力不会太大，平时的开销主要是维持心跳和提供Topic-Broker的关系数据。</p><p>但是有一点需要注意，Brker想NameServer发心跳时，会带上当前自己所负责的所有Topic信息，如果Topic个数太多（万级别），会导致一次心跳中，光Topic的数据就几十m，网络情况差的话，网络传输失败，心跳失败，导致NameServer误认为Broker心跳失败</p><p>NameServer被设计成几乎无状态的，可以横向扩展，节点之间相互之间无通信，通过部署多台机器来标记自己是个伪集群。</p><p>每个Broker在启动的时候都会到NameServer注册， Producer在发送消息前会根据Topic到NameServer获取到Broker的路由信息，Consumer也会定时获取Topic的路由信息。</p><p>所有从功能上看NameServer应该是和Zookeeper差不多，据说RocketMq的早期版本确实使用的Zookeeper，后来改为了自己实现的NameServer</p><h4 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h4><blockquote><p><strong>生产者</strong>，负责产生消息，一般是由业务系统负责产生消息</p></blockquote><ul><li>Producer又用户进行分布式部署，消息由Producer通过多种负责均衡模式发送到Broker集群，发送延时低，支持快速失败。</li><li>RocketMq提供了三种方式发送消息：同步、异步、单向<ul><li><strong>同步发送</strong>：指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包。一般用于重要通知消息，重要通知邮件，营销短信等</li><li><strong>异步发送</strong>：指发送方发出数据后，不等待接收方发回响应，就发送下个数据包，一般用于对响应时间不敏感的业务</li><li><strong>单向发送：</strong>值负责发送消息而不等待服务器的回应且没有回调函数触发，适用于某些耗时非常短但对可靠性要求并不高的场景，例如日志收集</li></ul></li></ul><h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><blockquote><p>消息<strong>中转角色</strong>，负责存储消息，转发消息</p></blockquote><p>Broker是具体提供业务的服务器，单个broker节点与所有的NameServer节点保持长连接及心跳，并会定时将Topic信息注册到NameServer，顺带一提底层的通信和连接都是基于netty实现的</p><p>Broker负责消息存储，以Topic为维度支持轻量级的队列，单机可以支撑上完队列规模，支持消息推拉模型</p><p>官网上说：具有<strong>上亿级消息堆积能力</strong>，同事可严格保证消息的<strong>有序性</strong></p><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><blockquote><p><strong>消费者</strong>，负责消费消息，一般是由后台系统负责异步消费</p></blockquote><p>Consumer也由用户部署，支持push和pull两种消费模式，支持<strong>集群消费</strong>和<strong>广播消费</strong>，提供实时的<strong>消息订阅机制</strong></p><p><strong>Pull：</strong>拉取，主动从消息服务器拉取消息，只要批量拉取到消息，用户应用就会启动消费过程</p><p><strong>Push：</strong>推送，封装了消息的拉取、消费进度和其他的内部维护工作，将消息到达时执行的回调接口留给用户应用程序来实现。所有Push被称为被动消费；从实现上看还是从消费服务器中拉取消息，不同于pull的是 push首先要注册消费监听器，当监听器触发后才开始消费消息。</p><h3 id="一次完成的通讯流程是什么样的？"><a href="#一次完成的通讯流程是什么样的？" class="headerlink" title="一次完成的通讯流程是什么样的？"></a>一次完成的通讯流程是什么样的？</h3><p>Producer 与 NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic陆游信息，并向Topic服务的Broker Master建立长连接，且定时向Broker发送心跳</p><p>Producer 只能将消息发送到Broker master，但是Consumer不一样，它同时和提供Topic的Master 和Slave建立长连接，既可以从Master订阅，也可以从Slave订阅消息</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>单机吞吐量：十万级</li><li>可用性：非常高，分布式架构</li><li>消息可靠性：经过参数优化配置，消息可以做到0丢失</li><li>功能支持：mq功能较为完善，还是分布式的，扩展性好</li><li>支持10亿级别的消息堆积，不会因为堆积导致性能下降</li><li>源码是java，我们可以自己阅读源码，定制自己公司的mq，可以掌控</li><li>天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况</li><li>稳定性更值得信赖，经历了多次双11</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>支持的客户端语言不多，java、c++(不成熟)</li><li>社区活跃度不是特别活跃的那种</li><li>没有在mq核心中去实现<strong>jms</strong>等接口，有些系统要迁移需要修改大量代码</li></ul><p>消息去</p><h1 id="陌陌面试题"><a href="#陌陌面试题" class="headerlink" title="陌陌面试题"></a>陌陌面试题</h1><h3 id="java多线程的实现？"><a href="#java多线程的实现？" class="headerlink" title="java多线程的实现？"></a>java多线程的实现？</h3><h3 id="二叉树后序遍历"><a href="#二叉树后序遍历" class="headerlink" title="二叉树后序遍历"></a>二叉树后序遍历</h3><h3 id="网络io模型"><a href="#网络io模型" class="headerlink" title="网络io模型"></a>网络io模型</h3><h3 id="三次握手每次在干嘛？"><a href="#三次握手每次在干嘛？" class="headerlink" title="三次握手每次在干嘛？"></a>三次握手每次在干嘛？</h3><h3 id="两个有序表的第n-和第n-1-大的数，不要额外空间，时间复杂度优化到nlogn？"><a href="#两个有序表的第n-和第n-1-大的数，不要额外空间，时间复杂度优化到nlogn？" class="headerlink" title="两个有序表的第n 和第n+1 大的数，不要额外空间，时间复杂度优化到nlogn？"></a>两个有序表的第n 和第n+1 大的数，不要额外空间，时间复杂度优化到nlogn？</h3><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><strong>单例模式</strong></h3><p><strong>优点</strong></p><blockquote><ol><li><p>只创建一个实例，节省内存开销 </p></li><li><p>减少了系统的性能开销，创建、回收对象都对性能有影响</p></li><li><p>提供了对唯一实例的受控访问</p></li><li><p>允许可变数目的实例</p></li></ol></blockquote><p><strong>缺点</strong></p><blockquote><ol><li>没有抽象层，因此扩展有很大的困难</li><li>单例类的职责过重，一定程度上违背了“单一职责原则”</li><li>滥用单例将带来一些负面问题：比如实例化的对象长时间不被利用，系统会认为是垃圾而回收</li></ol></blockquote><p><strong>使用场景</strong></p><blockquote><ul><li>web中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来</li><li>要求生产唯一序列号</li><li>创建一个对象需要消耗的资源过多，比如I/O与数据库的连接等</li></ul></blockquote><p><strong>关键代码</strong></p><blockquote><p>构造函数是私有的</p></blockquote><p><strong>注意事项</strong></p><blockquote><p>getInstance()方法中需要使用同步锁synchronized(Singleton.class)防止多线程同事进入造成instance被多次实例化。</p></blockquote><p><strong>懒汉</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类,在调用时才会初始化,因此是懒汉式</span></span><br><span class="line"><span class="comment"> * 看似是饿汉式,但只有调用getLazySingleton时才会初始化,线程安全由ClassLoad保证,不用思考怎么加锁</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 缺点:仍然会被反射和序列化攻击</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingletonHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton lazySingleton = <span class="keyword">new</span> LazySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getLazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazySingletonHolder.lazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>饿汉</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HungrySingleton 对象已经创建完成[在类加载时创建]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton hungrySingleton = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造函数,不能被外部访问</span></span><br><span class="line"><span class="comment">     * 创造对象的行为只能由这个类决定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回单例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getHungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungrySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建线程安全的单例有哪些实现方法？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">双检锁/双重校验锁</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span>==singleton)&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">null</span> == singleton)&#123;</span><br><span class="line">singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登记式/静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>枚举</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">INSTANCE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whatEverMethod</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="6"><li></li></ol></blockquote><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p><strong>ArrayList有用过吗？它是一个什么东西？可以用来做什么</strong>？</p><blockquote><p>就是一个数组列表，主要用来状态数据，如果装在的是基本数据类型（int、long、boolean、short、byte、double、char、float）的时候，只能存储他们对应的包装类,它的主要底层实现是数组</p><p>与它类似是LinkedList、和LinkedList相比，它的查找和访问元素的速度较快，但是增删慢</p><p><strong>小结：</strong>底层是数组实现的存储</p><p><strong>特点：</strong>查询效率高，增删效率低，线程不安全，使用频率高</p></blockquote><p><strong>线程不安全，为啥还使用它呢？</strong></p><blockquote><p>因为正常使用的场景中，都是用来查询，不会涉及太频繁的增删，如果涉及频繁的增删，可以使用LinkedList，如果要线程安全就使用Vector，这就是三者的区别，实际开发中还是ArrayList使用的最多。</p><p>不存在一个集合工具查询效率高，增删效率也高，线程还是安全的。</p><p>做的也都是一些线下的系统，没啥并发</p></blockquote><p><strong>它的底层是数组，数组是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？</strong></p><blockquote><p>ArrayList可以通过构造方法在初始化的时候指定底层数组的大小</p><p>如果是使用无参构造初始化，则赋值底层数据一个默认空数组，只有真正对数据进行添加是，才会分配默认的<strong>初始容量10</strong></p><p>可以看下它的无参构造和有参构造，无参就是默认大小，有参会判断参数</p></blockquote><p><strong>数组是有长度限制的，而ArrayList是可以存放任意数量对象，长度不受限制，那么他是怎么实现的呢？</strong></p><blockquote><p>实现比较简单，他就是通过数组扩容的方式去实现的。</p><p>比如说现在有一个长度为10的数组，需要新增第11个了，发现已经满了，那么会怎么做呢？</p><p>第一步：他会重新定义一个10+10/2的数组也就是一个长度为15的数组</p><p>第二步：把原数组的数据，原封不动的复制到新数组中，这个时候再把指向原数组的地址切换到新地址，ArrayList就这样完成了一次扩容</p></blockquote><p><strong>能具体说下1.7和1.8初始化的时候的区别么？</strong></p><blockquote><p>初始化的时候：1.7以前会调用this(10)的时候才是真正的容量为10，1.7开始就是默认走空数组了，只有第一次add的时候才会变成10</p></blockquote><p><strong>ArrayList的默认数组大小为什么是10？</strong></p><blockquote><p>不清楚。。。</p></blockquote><p><strong>为什么增删慢？</strong></p><blockquote><p>因为他的数组，是连续的内存空间，比如说删除一个的话，需要移动后面所有的</p></blockquote><p><strong>ArrayList（int initialCapacity）会不会初始化数组大小？</strong></p><blockquote><p>会初始化数组大小！但是List没，那size就没变，set下标和size比较的那就报错了。</p></blockquote><p><strong>ArrayList插入删除一定慢么？</strong></p><blockquote><p>取决于你删除的元素离数组末端有多远，ArrayList拿来作为堆栈来用还是挺合适的，push和pop操作完全不涉及数据移动操作。</p></blockquote><p><strong>它的删除是怎么实现的呢？</strong></p><blockquote><p>删除跟新增是一样的，不过叫是叫删除，但是在代码里可以发现，他还是在copy一个数组，举个例子：要删除index5这个位置</p><p><img src="img/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.assets/image-20200221162800968.png" alt="image-20200221162800968"></p><p>那么代码就复制一个index5+1到最后的数组，然后把它放到index开始的位置</p><p><img src="img/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.assets/image-20200221162852100.png" alt="image-20200221162852100"></p><p>index5的位置就被成功“删除了”，起始就是被覆盖了</p></blockquote><p>ArrayList是线程安全的么？</p><blockquote><p>当然不是，线程安全的数组容器是Vector</p><p>Vector的实现很简单，就是把所有的方法统统加上Synchronized就完事了。</p><p>你也可以不使用vector，用Collections.synchronizedList把一个普通的ArrayList包装成一个线程安全版本的数组容器也可以，原理同Vector是一样的，就是给所有的方法套上一层synchronized</p></blockquote><p>ArrayList用来做队列合适么？</p><blockquote><p>队列一般是FIFO（先进先出）的，如果用ArrayList做队列，就需要在数组尾部追加数据，数组头部删除数组，或者反过来。</p><p>但是无论如何总会有一个操作涉及到数组数据的迁移，耗费性能</p><p><strong>结论：</strong>不适合</p></blockquote><p><strong>那数组适合做队列吗？</strong></p><blockquote><p>数组是非常适合的</p><p>比如ArrayBlockingQueue内部实现就是一个环形队列，它是一个定长队列，内部是用一个定长数组来实现的。</p><p>另外著名的Disruptor开源Library也是用环形数组来实现的超高性能队列，具体原理不做解释，比较复杂。</p><p>简单点说就是使用两个偏移量来标记数组的读位置和写位置，如果超过长度就折回到数组开头，前提是它们是定长数组。</p></blockquote><p><strong>ArrayList的遍历和LinkedList遍历性能比较如何？</strong></p><blockquote><p>ArrayList快得多，内存是连续的，cpu的内部缓存结构会缓存连续的内存片段，可以大幅度降低读取内存的性能开销。</p></blockquote><p><strong>总结：</strong></p><blockquote><p>ArrayList就是动态数组，可以看成Array的复杂版本，提供了冬天的增删，实现了ICollection和IList接口，灵活的设置数组的大小等好处</p><p>面试频率不如HashMap和ConcurrentHashMap</p></blockquote><h1 id="秒杀系统设计"><a href="#秒杀系统设计" class="headerlink" title="秒杀系统设计"></a>秒杀系统设计</h1><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>要定点秒杀100件手机</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>高并发</strong></p><blockquote><p>时间短，瞬间用户量大</p></blockquote><p><strong>超卖</strong></p><p><strong>恶意请求</strong></p><blockquote><p>黄牛几十台机器脚本秒杀，模拟个十几万人的请求</p></blockquote><p><strong>链接暴露</strong></p><blockquote><p>前端暴露了地址，或者开发人员自己知道了，猛点</p></blockquote><p><strong>数据库</strong></p><blockquote><p>每秒上万甚至十几万的qps打到数据库，基本gg</p></blockquote><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>服务单一职责</strong></p><blockquote><p>微服务设计思想，再用分布式的部署方式</p><p>给秒单独的服务，单独的库</p><p><strong>好处：</strong>就算挂了， 也不会影响其他服务</p></blockquote><p><strong>秒杀连接加盐</strong></p><blockquote><p>把url动态化，就连写代码的人都不知道，通过md5之类的加密算法随机的字符串去做url，然后通过前端代码获取url后台校验才能通过。</p></blockquote><p>redis<strong>集群</strong></p><blockquote><p>单机redis顶不住，那就多找几个兄弟，秒杀本来就是读多写少</p><p>redis集群、主从同步、读写分离、还可以高点哨兵，开启持久化直接无敌高可用</p></blockquote><p><strong>nginx</strong></p><blockquote><p>高性能的web服务器，并发也是随便几万不是梦，但是tomcat只能顶几百的并发啊。那简单啊负载均衡嘛，一台服务器几百，那就多搞点，在秒杀的时候多租点流量机</p><p>恶意请求拦截也需要用它，一般单个用户请求次数太夸张，不像真人的请求在网关那一层就得拦截掉了</p></blockquote><p><strong>资源静态化</strong></p><blockquote><p>秒杀一般都是特定的商品还有页面模板，现在一般都是前后端分离的，所有页面一般是不会经过后端的，但是前段也要有自己的服务器啊，那就把能提前放到cdn服务器的东西都放进去，反正把能提升效率的步骤都做一下，减少真正秒杀时候服务器的压力</p></blockquote><p><strong>按钮控制</strong></p><blockquote><p>秒杀前按钮<strong>置灰</strong>，到点了才能点</p><p>这是防止在快到秒杀前的时间疯狂请求服务器，这个时候就需要前端的配合，定时去请求你的后端服务器，获取最新的北京时间，到时间点了再给按钮可以用</p><p>点击一次之后也得置灰几秒，防止一直点</p></blockquote><p><strong>限流</strong></p><blockquote><p>前端限流：跟按钮控制类似，防止一直点</p><p>后端限流：秒杀的时候肯定是涉及到了后续的<strong>订单生成</strong>和<strong>支付操作</strong>，一旦秒杀产品卖完了，return一个false，前端直接秒杀结束</p><p>真正的限流还会有限流组件，比如阿里的Sentinel、Hystrix等</p></blockquote><p><strong>库存预热</strong></p><blockquote><p>秒杀的本质，就是对库存的争夺，每个秒杀的用户来你都去数据库查询库存校验库存，然后扣减库存，对开发很不友好，而且数据库顶不住啊</p><p><strong>提前把商品的库存加载到redis中去</strong>，让整个流程都在redis里做，然后等秒杀结束了，再异步的去修改库存就好了</p><p>但是用redis的话就有一个问题了，我们上面说了主从，然后回去读库然后再判断有库存才去减库存，正常情况没问题，但是高并发的情况问题就很大了：比如只剩下一个库存了，高并发，四个服务器一起查询大家发现都还剩一个，都觉得自己抢到了，都去扣库存了，结果变成-3了，这样就发生了超卖</p><p><strong>Lua</strong>：lua脚本类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作，一个脚本=查库存+扣减库存，如果是0 了直接false</p></blockquote><p><strong>削峰填谷</strong></p><blockquote><p>说到这里就知道是说mq了，卖100个东西直接100个请求，我觉得没问题，但万一秒杀一万个，10万个呢，服务器挂了 </p><p>把他放消息队列，然后一点点消费去改库存不就好了嘛</p></blockquote><h1 id="消息队列基础"><a href="#消息队列基础" class="headerlink" title="消息队列基础"></a>消息队列基础</h1><p>经典场景，需要熟烂于心：异步、削峰、解耦</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a><strong>异步</strong></h3><blockquote><p>一个下单流程：本来需要100ms，后来产品说要加上积分，流程中加上积分扣减，200ms了</p><ul><li><p>产品说要加上优惠券，300毫秒了</p></li><li><p>产品说要发短信，400毫秒了</p></li><li><p>再后来。。。</p></li></ul><p>让产品加的这三点可以<strong>异步</strong></p></blockquote><p><strong>面试官：异步，我用线程、线程池去做不一样吗</strong>？</p><blockquote><p>为什么不能用线程去做？</p><p>用线程的话，扣积分、扣优惠券、发短信是不是都需要单独的接口？，每次加一个流程是不是代码都要改动？</p><p>但是用了消息队列，问题迎刃而解啊：</p><p>你下单了，你就把你支付成功的消息告诉别的系统，他们收到了去处理就好了，来多少类似的需求，只需要对应的人员去监听该消息就行了</p></blockquote><p><strong>那你的流程走完了，别人没成功怎么办？</strong></p><blockquote><p>起始不需要考虑，业务系统本身就是自己开发人员维护的，你扣积分失败和我下单有什么关系？</p></blockquote><h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>平时流量低，但是秒杀时流量猛增，你的服务器，redis，mysql各自的承受能力都不一样，全部流量赵丹全收肯定有问题啊，直接就挂了</p><p><strong>怎么办</strong></p><blockquote><p>把请求放到队列里面，每秒消费多少请求，就看自己的服务器处理能力，你能处理5000qps，你就消费这么多人，可能会比正常的慢一点，但是不至于打挂服务器，等流量高峰下去了，你的服务器也就没压力了</p></blockquote><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h2 id="消息去重、重复消费"><a href="#消息去重、重复消费" class="headerlink" title="消息去重、重复消费"></a>消息去重、重复消费</h2><p>原则：使用业务端逻辑保持幂等性</p><p>策略：保证每条消息都要唯一编号（比如唯一流水号），且保证消息处理成功与去重表的日志同时出现。</p><p>建立一个消息表，拿到这个消息做数据库的insert操作。给这个消息做一个唯一主键或约束，就算出现重复消费的情况，也会导致主键冲突，以后就不再处理这条消息了</p><h2 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h2><p><strong>Qos：Quality of Service 服务质量</strong></p><p>消息领域对投递的定义分为：</p><ul><li>最多一次</li><li>至少一次</li><li>仅一次</li></ul><p>几乎所有的mq产品都声称自己做到了  <strong>至少一次</strong></p><p>既然是至少一次，那避免不来消息重复，尤其是在分布式网络环境下</p><h2 id="消息可用性"><a href="#消息可用性" class="headerlink" title="消息可用性"></a>消息可用性</h2><p>当我们选择好了集群模式之后，那么我们需要关系的就是怎么去存储和复制这个数据，RocketMq对消息的刷盘提供了同步和异步的策略来满足我们。</p><p>同步刷盘：如果刷盘超时则会返给FLUSH_DISK_TIMEOUT，如果是异步刷盘不会返回刷盘相关信息，选择同步刷盘可以尽最大程度满足我们的消息不会丢失。</p><p>除了存储有选择之后，我们的主从同步提供了同步和异步两种模式来进行复制，当然选择同步可以提升可用性，但是消息的发送RT时间会下降10%左右。</p><p>RocketMq采用的是混合型的存储结构，即为Broker单个实例下所有的队列公用一个日志数据文件（即为COmmitLog）来存储</p><p>Kafka采用的是独立型的存储结构，每个队列一个文件。</p><p>RocketMq采用混合型存储结构的缺点在于：会存在较多的随机读操作，因此读的效率偏低。同时消费消息需要依赖ConsumeQueue，构建该逻辑消费队列需要一定开销。</p><h2 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h2><p>生产者消费者一般需要保证顺序消费的话，可能就是一个业务场景下的，比如订单的创建、支付、发货、收货。</p><p>那么这些东西是不是一个订单号呢？一个订单的肯定是一个订单号啊</p><p>一个topic下游多个队列，为了保证发送有序，RocketMq提供了MessageQueueSelector队列选择机制，他有三种实现：</p><img src="img/面试准备.assets/image-20200309154910190.png" alt="image-20200309154910190" style="zoom:50%;"><p>我们可以使用<strong>Hash取模法</strong>，让同一个订单发送到同一个队列中，再使用同步发送包，只有同个订单创建消息发送成功，再发送支付消息。这样就保证了<strong>发送有序</strong></p><p>Rokcet的topic内的队列机制，可以保证存储满足FIFO（先进先出），剩下的只需要消费者顺序消费即可</p><h2 id="分布式事务-1"><a href="#分布式事务-1" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="Half-Message-半消息）"><a href="#Half-Message-半消息）" class="headerlink" title="Half Message(半消息）"></a>Half Message(半消息）</h3><p>是指暂时不能倍Consumer消费的消息。Producer已经把消息成功发送到了Broker端，但此消息被标记为<strong>暂不能投递</strong>状态，处于该状态下的消息成为半消息，需要Producer对消息的二次确认后，Consumer才能去消费它。</p><h3 id="消息回查"><a href="#消息回查" class="headerlink" title="消息回查"></a>消息回查</h3><p>由于网络闪断，生产者重启等原因，导致Producer端一直没有对<strong>半消息</strong>进行二次确认，这时Brocker服务器会定时扫描长期处于半消息的消息，会主动询问Producer端，该消息的最终状态（Commit 或者 Rollback），该消息即为消息回查。</p><img src="img/面试准备.assets/image-20200309160441698.png" alt="image-20200309160441698" style="zoom:50%;"><p>A服务先发送个Half Message给Brock端，消息中携带 B服务 即将要+100元的信息。 </p><p>当A服务知道Half Message发送成功后，那么开始第3步执行本地事务。 </p><p>执行本地事务(会有三种情况1、执行成功。2、执行失败。3、网络等原因导致没有响应) </p><p>如果本地事务成功，那么Product像Brock服务器发送Commit,这样B服务就可以消费该message。 </p><p>如果本地事务失败，那么Product像Brock服务器发送Rollback,那么就会直接删除上面这条半消息。</p><p>如果因为网络等原因迟迟没有返回失败还是成功，那么会执行RocketMQ的回调接口,来进行事务的回查。</p><h2 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h2><h3 id="Broker端消息过滤"><a href="#Broker端消息过滤" class="headerlink" title="Broker端消息过滤"></a>Broker<strong>端消息过滤</strong></h3><p>在broker中，按照Consumer 的要求做过滤，优点是减少了对于 Consumer 无用消息的网络传输。缺点是增加了Broker的负担，实现相对复杂。</p><h3 id="Consumer-端消息过滤"><a href="#Consumer-端消息过滤" class="headerlink" title="Consumer 端消息过滤"></a>Consumer 端消息过滤</h3><p>这种过滤完全可由应用完全自定义实现，但是缺点是很多无用的消息要传到Consumer端</p><h2 id="Broker的Buffer问题"><a href="#Broker的Buffer问题" class="headerlink" title="Broker的Buffer问题"></a>Broker的Buffer问题</h2><p>Broker的buffer通常指的是Broker中一个队列的内存Buffer大小，这类Buffer通常大小有限。</p><p>另外，RokcetMq没有内存Buffer概念，RocketMq的队列都是持久化磁盘，数据定时清除。</p><p>RockertMq同其他mq有个非常显著的区别，RocketMq的内存Buffer抽象成一个无线长度的队列，不管有多少数据进来都能装得下，这个无线是有前提的，Broker会定期删除过期的数据。</p><p>例如Broker只保存三天的消息，那么Buffer长度虽然无线，但是3天前的数据会被从队尾删除。</p><h2 id="回溯消费"><a href="#回溯消费" class="headerlink" title="回溯消费"></a>回溯消费</h2><p>回溯消息是只Concumer已经消费成功的消息，由于业务上的需求需要重新消费，要支持此功能，Broker在向Consumer投递消息成功后，消息仍然需要保留。并且重新消费一般是按时间维度。</p><p>RocketMq支持按照时间回溯消费，可以精确到秒，可以向前，向后</p><h2 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h2><p>消息中间件的主要功能就是异步解耦，还有个重要功能是挡住前端的数据洪峰，保证后端系统的稳定性</p><p>消息堆积有两种</p><ul><li>堆积在内存Buffer，一旦超过内存Buffer，可以根据一定的丢弃策略来丢弃消息，这种情况堆积能力主要在于内存Buffer大小，而且消息堆积后，性能下降不大</li><li>堆积在持久化存储系统中，例如db，kv存储，文件记录形式。当消息不能再内存命cache命中时，要不可避免的访问磁盘，会产生大量读io，读io的吞吐量直接决定了消息堆积后的访问能力。</li></ul><p>评估消息堆积能力主要有以下四点：</p><ul><li>消息能堆积多少条，多少字节？即消息的堆积容量</li><li>消息堆积后，发消息的吞吐量大小，是否会受堆积影响？</li><li>正常消费的Consumer是否受影响</li><li>访问堆积在磁盘的消息是，吞吐量有多大？</li></ul><h2 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h2><p>定时消息是指消息发到Broker后，不能立刻被Consumer消费，要到特定的时间点或者等待特定的时间后才能被消费。</p><p>RocketMq支持定时消息，但是不支持任意时间精度，支持特定的level，例如5s,10s,1m等</p><p>如果要支持任意的时间精度，需要在Broker做，必须要做消息排序，再涉及到持久化，那么消息排序要不可避免的产生巨大性能开销</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;redis&quot;&gt;&lt;a href=&quot;#redis&quot; class=&quot;headerlink&quot; title=&quot;redis&quot;&gt;&lt;/a&gt;redis&lt;/h2&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;缓存雪崩-多
      
    
    </summary>
    
    
      <category term="面试" scheme="http://iwantjingjing.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://iwantjingjing.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java 面试</title>
    <link href="http://iwantjingjing.com/2020/02/01/java-%E9%9D%A2%E8%AF%95/"/>
    <id>http://iwantjingjing.com/2020/02/01/java-面试/</id>
    <published>2020-02-01T15:52:28.000Z</published>
    <updated>2020-04-19T09:08:02.932Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.javanav.com/interview/93b0069472fd479393006c0e73043fc4.html" target="_blank" rel="noopener">摘自</a></p><h1 id="基础与语法"><a href="#基础与语法" class="headerlink" title="基础与语法"></a>基础与语法</h1><h2 id="1-jdk-jre-区别"><a href="#1-jdk-jre-区别" class="headerlink" title="1 jdk jre 区别"></a>1 jdk jre 区别</h2><p>JRE：Java Runtime Environment（ java 运行时环境）。即java程序的运行时环境，包含了 java 虚拟机，java基础类库。</p><p>JDK：Java Development Kit（ java 开发工具包）。即java语言编写的程序所需的开发工具包。JDK 包含了 JRE，同时还包括 java 源码的编译器 javac、监控工具 jconsole、分析工具 jvisualvm等。</p><h2 id="2-和equals的区别是什么"><a href="#2-和equals的区别是什么" class="headerlink" title="2 ==和equals的区别是什么?"></a>2 ==和equals的区别是什么?</h2><p> == 的作用：</p><ul><li><p>基本类型：比较值是否相等</p></li><li><p>引用类型：比较内存地址值是否相等</p><p>equals() 的作用:<br>引用类型：默认情况下比较的是内存地址是否相等。可以按照需求逻辑，重写对象的equals（）方法（重写 equals() 方法，一般须重写 hashCode() 方法）。</p></li></ul><h2 id="3-基本类型和包装类对象使用-和-equals进行比较的结果？"><a href="#3-基本类型和包装类对象使用-和-equals进行比较的结果？" class="headerlink" title="3 基本类型和包装类对象使用 == 和 equals进行比较的结果？"></a>3 基本类型和包装类对象使用 == 和 equals进行比较的结果？</h2><p>1、值不同，使用 ＝＝ 和 equals() 比较都返回 false</p><p>2、值相同</p><p>使用 ＝＝ 比较：</p><ul><li>基本类型 － 基本类型、基本类型 － 包装对象返回 true</li><li>包装对象 － 包装对象返回 false</li><li>缓存中取的包装对象比较返回 true（原因是 JVM 缓存部分基本类型常用的包装类对象，如 Integer -128 ~ 127 是被缓存的）</li></ul><pre><code>Integer i1 = 100;Integer i2 = 100;Integer i3 = 200;Integer i4 = 200;System.out.println(i1==i2); //打印trueSystem.out.println(i3==i4); //打印false </code></pre><p>使用 equals() 比较</p><ul><li>包装对象－基本类型返回 true</li><li>包装对象－包装对象返回 true</li></ul><p>3、不同类型的对象对比，返回 false</p><p>JDK1.8，实验代码</p><pre><code>byte b1 = 127;Byte b2 = new Byte(&quot;127&quot;);Byte b3 = new Byte(&quot;127&quot;);System.out.println(&quot;Byte 基本类型和包装对象使用 == 比较 : &quot; + (b1 == b2));System.out.println(&quot;Byte 基本类型和包装对象使用 equals 比较 : &quot; + b2.equals(b1));System.out.println(&quot;Byte 包装对象和包装对象使用 == 比较 : &quot; + (b2 == b3));System.out.println(&quot;Byte 包装对象和包装对象使用 equals 比较 : &quot; + b2.equals(b3));System.out.println();short s1 = 12;Short s2 = new Short(&quot;12&quot;);Short s3 = new Short(&quot;12&quot;);System.out.println(&quot;Short 基本类型和包装对象使用 == 比较 : &quot; + (s1 == s2));System.out.println(&quot;Short 基本类型和包装对象使用 equals 比较 : &quot; + s2.equals(s1));System.out.println(&quot;Short 包装对象和包装对象使用 == 比较 : &quot; + (s2 == s3));System.out.println(&quot;Short 包装对象和包装对象使用 equals 比较 : &quot; + s2.equals(s3));System.out.println();char c1 = &apos;A&apos;;Character c2 = new Character(&apos;A&apos;);Character c3 = new Character(&apos;A&apos;);System.out.println(&quot;Character 基本类型和包装对象使用 == 比较 : &quot; + (c1 == c2));System.out.println(&quot;Character 基本类型和包装对象使用 equals 比较 : &quot; + c2.equals(c1));System.out.println(&quot;Character 包装对象和包装对象使用 == 比较 : &quot; + (c2 == c3));System.out.println(&quot;Character 包装对象和包装对象使用 equals 比较 : &quot; + c2.equals(c3));System.out.println();int i1 = 10000;Integer i2 = new Integer(10000);Integer i3 = new Integer(10000);System.out.println(&quot;Integer 基本类型和包装对象使用 == 比较 : &quot; + (i1 == i2));System.out.println(&quot;Integer 基本类型和包装对象使用 equals 比较 : &quot; + i2.equals(i1));System.out.println(&quot;Integer 包装对象和包装对象使用 == 比较 : &quot; + (i2 == i3));System.out.println(&quot;Integer 包装对象和包装对象使用 equals 比较 : &quot; + i2.equals(i3));System.out.println();long l1 = 1000000000000000L;Long l2 = new Long(&quot;1000000000000000&quot;);Long l3 = new Long(&quot;1000000000000000&quot;);System.out.println(&quot;Long 基本类型和包装对象使用 == 比较 : &quot; + (l1 == l2));System.out.println(&quot;Long 基本类型和包装对象使用 equals 比较 : &quot; + l2.equals(l1));System.out.println(&quot;Long 包装对象和包装对象使用 == 比较 : &quot; + (l2 == l3));System.out.println(&quot;Long 包装对象和包装对象使用 equals 比较 : &quot; + l2.equals(l3));System.out.println();float f1 = 10000.111F;Float f2 = new Float(&quot;10000.111&quot;);Float f3 = new Float(&quot;10000.111&quot;);System.out.println(&quot;Float 基本类型和包装对象使用 == 比较 : &quot; + (f1 == f2));System.out.println(&quot;Float 基本类型和包装对象使用 equals 比较 : &quot; + f2.equals(f1));System.out.println(&quot;Float 包装对象和包装对象使用 == 比较 : &quot; + (f2 == f3));System.out.println(&quot;Float 包装对象和包装对象使用 equals 比较 : &quot; + f2.equals(f3));System.out.println();double d1 = 10000.111;Double d2 = new Double(&quot;10000.111&quot;);Double d3 = new Double(&quot;10000.111&quot;);System.out.println(&quot;Double 基本类型和包装对象使用 == 比较 : &quot; + (d1 == d2));System.out.println(&quot;Double 基本类型和包装对象使用 equals 比较 : &quot; + d2.equals(d1));System.out.println(&quot;Double 包装对象和包装对象使用 == 比较 : &quot; + (d2 == d3));System.out.println(&quot;Double 包装对象和包装对象使用 equals 比较 : &quot; + d2.equals(d3));System.out.println();boolean bl1 = true;Boolean bl2 = new Boolean(&quot;true&quot;);Boolean bl3 = new Boolean(&quot;true&quot;);System.out.println(&quot;Boolean 基本类型和包装对象使用 == 比较 : &quot; + (bl1 == bl2));System.out.println(&quot;Boolean 基本类型和包装对象使用 equals 比较 : &quot; + bl2.equals(bl1));System.out.println(&quot;Boolean 包装对象和包装对象使用 == 比较 : &quot; + (bl2 == bl3));System.out.println(&quot;Boolean 包装对象和包装对象使用 equals 比较 : &quot; + bl2.equals(bl3));</code></pre><p>运行结果</p><pre><code>Byte 基本类型和包装对象使用 == 比较 : trueByte 基本类型和包装对象使用 equals 比较 : trueByte 包装对象和包装对象使用 == 比较 : falseByte 包装对象和包装对象使用 equals 比较 : trueShort 基本类型和包装对象使用 == 比较 : trueShort 基本类型和包装对象使用 equals 比较 : trueShort 包装对象和包装对象使用 == 比较 : falseShort 包装对象和包装对象使用 equals 比较 : trueCharacter 基本类型和包装对象使用 == 比较 : trueCharacter 基本类型和包装对象使用 equals 比较 : trueCharacter 包装对象和包装对象使用 == 比较 : falseCharacter 包装对象和包装对象使用 equals 比较 : trueInteger 基本类型和包装对象使用 == 比较 : trueInteger 基本类型和包装对象使用 equals 比较 : trueInteger 包装对象和包装对象使用 == 比较 : falseInteger 包装对象和包装对象使用 equals 比较 : trueLong 基本类型和包装对象使用 == 比较 : trueLong 基本类型和包装对象使用 equals 比较 : trueLong 包装对象和包装对象使用 == 比较 : falseLong 包装对象和包装对象使用 equals 比较 : trueFloat 基本类型和包装对象使用 == 比较 : trueFloat 基本类型和包装对象使用 equals 比较 : trueFloat 包装对象和包装对象使用 == 比较 : falseFloat 包装对象和包装对象使用 equals 比较 : trueDouble 基本类型和包装对象使用 == 比较 : trueDouble 基本类型和包装对象使用 equals 比较 : trueDouble 包装对象和包装对象使用 == 比较 : falseDouble 包装对象和包装对象使用 equals 比较 : trueBoolean 基本类型和包装对象使用 == 比较 : trueBoolean 基本类型和包装对象使用 equals 比较 : trueBoolean 包装对象和包装对象使用 == 比较 : falseBoolean 包装对象和包装对象使用 equals 比较 : true</code></pre><p>ps：可以延伸一个问题，基本类型与包装对象的拆/装箱的过程</p><h2 id="4-什么是装箱？什么是拆箱？装箱和拆箱的执行过程？常见问题？"><a href="#4-什么是装箱？什么是拆箱？装箱和拆箱的执行过程？常见问题？" class="headerlink" title="4 什么是装箱？什么是拆箱？装箱和拆箱的执行过程？常见问题？"></a>4 什么是装箱？什么是拆箱？装箱和拆箱的执行过程？常见问题？</h2><p>1、什么是装箱？什么是拆箱？<br>装箱：基本类型转变为包装器类型的过程。<br>拆箱：包装器类型转变为基本类型的过程。</p><pre><code>//JDK1.5之前是不支持自动装箱和自动拆箱的，定义Integer对象，必须Integer i = new Integer(8);//JDK1.5开始，提供了自动装箱的功能，定义Integer对象可以这样Integer i = 8;int n = i;//自动拆箱</code></pre><p>2、装箱和拆箱的执行过程？</p><ul><li>装箱是通过调用包装器类的 valueOf 方法实现的</li><li>拆箱是通过调用包装器类的 xxxValue 方法实现的，xxx代表对应的基本数据类型。</li><li>如int装箱的时候自动调用Integer的valueOf(int)方法；Integer拆箱的时候自动调用Integer的intValue方法。</li></ul><p>3、常见问题？</p><ul><li>整型的包装类 valueOf 方法返回对象时，在常用的取值范围内，会返回缓存对象。</li><li>浮点型的包装类 valueOf 方法返回新的对象。</li><li>布尔型的包装类 valueOf 方法 Boolean类的静态常量 TRUE | FALSE。</li></ul><p>实验代码</p><pre><code>Integer i1 = 100;Integer i2 = 100;Integer i3 = 200;Integer i4 = 200;System.out.println(i1 == i2);//trueSystem.out.println(i3 == i4);//falseDouble d1 = 100.0;Double d2 = 100.0;Double d3 = 200.0;Double d4 = 200.0;System.out.println(d1 == d2);//falseSystem.out.println(d3 == d4);//falseBoolean b1 = false;Boolean b2 = false;Boolean b3 = true;Boolean b4 = true;System.out.println(b1 == b2);//trueSystem.out.println(b3 == b4);//true</code></pre><ul><li>包含算术运算会触发自动拆箱。</li><li>存在大量自动装箱的过程，如果装箱返回的包装对象不是从缓存中获取，会创建很多新的对象，比较消耗内存。</li></ul><pre><code>Integer s1 = 0;long t1 = System.currentTimeMillis();for(int i = 0; i &lt;1000 * 10000; i++){    s1 += i;}long t2 = System.currentTimeMillis();System.out.println(&quot;使用Integer，递增相加耗时：&quot; + (t2 - t1));//使用Integer，递增相加耗时：68int s2 = 0;long t3 = System.currentTimeMillis();for(int i = 0; i &lt;1000 * 10000; i++){    s2 += i;}long t4 = System.currentTimeMillis();System.out.println(&quot;使用int&quot; + (t4 - t3));//使用int，递增相加耗时：6</code></pre><p>ps：可深入研究一下 javap 命令，看下自动拆箱、装箱后的class文件组成。<br>       看一下 JDK 中 Byte、Short、Character、Integer、Long、Boolean、Float、Double的 valueOf 和 xxxValue 方法的源码（xxx代表基本类型如intValue）。     </p><h2 id="hashCode-相同，equals-也一定为true吗？"><a href="#hashCode-相同，equals-也一定为true吗？" class="headerlink" title="hashCode()相同，equals()也一定为true吗？"></a>hashCode()相同，equals()也一定为true吗？</h2><p>首先，答案肯定是不一定。同时反过来 equals() 为true，hashCode() 也不一定相同。</p><ul><li>类的 hashCode() 方法和 equals() 方法都可以重写，返回的值完全在于自己定义。</li><li>hashCode() 返回该对象的哈希码值；equals() 返回两个对象是否相等。</li></ul><p>关于 hashCode() 和 equals() 是方法是有一些 常规协定 ：</p><ul><li><p>1、两个对象用 equals() 比较返回true，那么两个对象的hashCode()方法必须返回相同的结果。</p></li><li><p>2、两个对象用 equals() 比较返回false，不要求hashCode()方法也一定返回不同的值，但是最好返回不同值，以提搞哈希表性能。</p></li><li><p>3、重写 equals() 方法，必须重写 hashCode() 方法，以保证 equals() 方法相等时两个对象 hashcode() 返回相同的值。</p></li></ul><h2 id="final在java中的作用"><a href="#final在java中的作用" class="headerlink" title="final在java中的作用"></a>final在java中的作用</h2><p>final 语义是不可改变的。</p><ul><li>被 final 修饰的类，不能够被继承。</li><li>被 final 修饰的成员变量必须要初始化，赋初值后不能再重新赋值(可以调用对象方法修改属性值)。对基本类型来说是其值不可变；对引用变量来说其引用不可变，即不能再指向其他的对象。</li><li>被 final 修饰的方法代表不能重写。</li></ul><h2 id="final-finally-finalize-区别"><a href="#final-finally-finalize-区别" class="headerlink" title="final finally finalize()区别"></a>final finally finalize()区别</h2><ul><li><p>final 表示最终的、不可改变的。用于修饰类、方法和变量。final 变量必须在声明时给定初值，只能读取，不可修改。final 方法也同样只能使用，不能重写，但能够重载。final 修饰的对象，对象的引用地址不能变，但对象的属性值可以改变</p></li><li><p>finally 异常处理的一部分，它只能用在 try/catch 语句中，表示希望 finally 语句块中的代码最后一定被执行（存在一些情况导致 finally 语句块不会被执行，如 jvm 结束）</p></li><li><p>finalize() 是在 java.lang.Object 里定义的，Object 的 finalize() 方法什么都不做，对象被回收时 finalize() 方法会被调用。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要清理工作，在垃圾收集器删除对象之前被调用的。一般情况下，此方法由JVM调用。特殊情况下，可重写 finalize() 方法，当对象被回收的时候释放一些资源，须调用 super.finalize() 。 </p></li></ul><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="-2"><a href="#-2" class="headerlink" title></a></h2><h2 id="-3"><a href="#-3" class="headerlink" title></a></h2><h2 id="-4"><a href="#-4" class="headerlink" title></a></h2><h2 id="-5"><a href="#-5" class="headerlink" title></a></h2><h2 id="-6"><a href="#-6" class="headerlink" title></a></h2><h2 id="-7"><a href="#-7" class="headerlink" title></a></h2><h2 id="-8"><a href="#-8" class="headerlink" title></a></h2><h2 id="-9"><a href="#-9" class="headerlink" title></a></h2><h2 id="-10"><a href="#-10" class="headerlink" title></a></h2><h2 id="-11"><a href="#-11" class="headerlink" title></a></h2><h2 id="-12"><a href="#-12" class="headerlink" title></a></h2><h2 id="-13"><a href="#-13" class="headerlink" title></a></h2><h2 id="-14"><a href="#-14" class="headerlink" title></a></h2><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h1 id="文件解析与生成"><a href="#文件解析与生成" class="headerlink" title="文件解析与生成"></a>文件解析与生成</h1><h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><h1 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h1><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.javanav.com/interview/93b0069472fd479393006c0e73043fc4.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;摘自&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;基础与语法
      
    
    </summary>
    
    
      <category term="面试" scheme="http://iwantjingjing.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试，Java" scheme="http://iwantjingjing.com/tags/%E9%9D%A2%E8%AF%95%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>读与时间做朋友有感</title>
    <link href="http://iwantjingjing.com/2019/12/22/%E8%AF%BB%E4%B8%8E%E6%97%B6%E9%97%B4%E5%81%9A%E6%9C%8B%E5%8F%8B%E6%9C%89%E6%84%9F/"/>
    <id>http://iwantjingjing.com/2019/12/22/读与时间做朋友有感/</id>
    <published>2019-12-22T13:13:44.000Z</published>
    <updated>2019-12-22T13:55:59.347Z</updated>
    
    <content type="html"><![CDATA[<p>近日读完了李笑来写的《与时间做朋友》收货一下观点</p><ul><li><p>1 20分钟学习命令行下的批处理方法</p></li><li><p>2 Google通配符学习</p></li><li><p>3 概率统计学（买彩票这种行为在学过概率统计的人看来是对自己智商的侮辱）</p></li><li><p>4 千万不要拒绝学习</p></li><li><p>5 《今春的两种感想》对体验、试错、和观察进行补充的就是阅读。</p></li><li><p>6 伯纳姆与杰.费伦著《本能》</p></li><li><p>7 电影《新基督山伯爵》</p></li><li><p>8 达尔文《物种起源》 1859年11月24日</p></li><li><p>9 愚人网</p></li><li><p>10猴子吃香蕉被打（经验主义害猴子被打）</p></li><li><p>11 亚里士多德《论问题》”强光喷嚏反射”</p></li><li><p>12 美国前第一夫人罗莎琳.卡特就观察到了这样一个现象：”优秀的领导，能够把人们带到他们想去的地方，而卓越的领导，能够把人们带到他们应该去但是没想过要去的地方。<br>A leader takes people where they want to go .<br>A grate leader takes people where they don’t necessarily want to go ,but ought to be.</p></li><li><p>13 人在学生时期应该认真阅读至少3本关于科学史和科学方法的书籍</p></li><li><p>14 在人们探索未知、寻求真理的时候，困难几乎都来自于如何正确的理解”与现有经验相悖的知识”</p></li><li><p>15 自学能力的基础是阅读理解能力</p></li><li><p>16 写作能力在自学能力中占据重要位置。（这里提到的”写作能力”不是写小说的能力，不是写诗歌的能力，不是写剧本的能力，也不是写散文的能力，只是写作能力中最基本的一种——写出简洁、有效、准确、朴素、具体的说明性文章的能力。</p></li><li><p>17 对抗选择性输入：把目前无法理解的、支持的、反对的、无所谓的论点和观点记录下来。对无法理解的，写下自己当时的疑惑何在，对支持的，记录下几个理由或者实例；对反对的，同样记录几个理由或者实例；甚至对那些无所谓的，也记录其原因。一个有着这样良好记录习惯的人会获得他人无法拥有的处理信息和知识的能力——反刍chu</p></li><li><p>18 读教科书，要先把所有概念都记下来，暂时不懂的就死记硬背。把概念牢记于心，就可以通过以后的学习和实践反复审视它，并形成透彻理解。</p></li><li><p>19 学习任何一门学科，都最好先去读一下该学科的发展历史，这是最好的起点。</p></li><li><p>20 《围城》钱钟书著</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近日读完了李笑来写的《与时间做朋友》收货一下观点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1 20分钟学习命令行下的批处理方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2 Google通配符学习&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3 概率统计学（买彩票这种行为在学过概率统计的人看来是对自
      
    
    </summary>
    
    
    
      <category term="读后感，李笑来" scheme="http://iwantjingjing.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F%EF%BC%8C%E6%9D%8E%E7%AC%91%E6%9D%A5/"/>
    
  </entry>
  
  <entry>
    <title>DevOps简介</title>
    <link href="http://iwantjingjing.com/2019/12/02/DevOps%E7%AE%80%E4%BB%8B/"/>
    <id>http://iwantjingjing.com/2019/12/02/DevOps简介/</id>
    <published>2019-12-02T08:29:09.000Z</published>
    <updated>2019-12-22T13:13:03.794Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/liufei1983/p/7152013.html" target="_blank" rel="noopener">摘抄自</a></p><h1 id="DevOps简介"><a href="#DevOps简介" class="headerlink" title="DevOps简介"></a>DevOps简介</h1><p>DevOps是一个完整的面向IT运维的工作流，以IT自动化以及持续集成（CI）、持续部署（CD）为基础，来优化开发、测试、系统运维等多有环节。</p><h1 id="DevOps的概念"><a href="#DevOps的概念" class="headerlink" title="DevOps的概念"></a>DevOps的概念</h1><p>DevOps一词的来自于Development和Operations的组合，突出重视软件开发人员和运维人员的沟通合作，通过自动化流程来使得软件构建、测试、发布更加快捷、频繁和可靠。</p><p><img src="devops.png" alt><br>DevOps是为了填补开发端和运维端之间的信息鸿沟，改善团队之间的协作关系。不过需要澄清的一点是，从开发到运维，中间还有测试环节。DevOps其实包含了三个部分：开发、测试和运维。</p><p><img src="dev2.png" alt><br>换句话说，DevOps希望做到的是软件产品交付过程中IT工具链的打通，使得各个团队减少时间损耗，更加高效地协同工作。专家们总结出了下面这个DevOps能力图，良好的闭环可以大大增加整体的产出。<br><img src="dev3.png" alt></p><h1 id="历史变革"><a href="#历史变革" class="headerlink" title="历史变革"></a>历史变革</h1><p>由上所述，相信大家对DevOps有了一定的了解。但是除了触及工具链之外，作为文化和技术的方法论，DevOps还需要公司在组织文化上的变革。回顾软件行业的研发模式，可以发现大致有三个阶段：瀑布式开发、敏捷开发、DevOps。</p><p>DevOps早在九年前就有人提出来，但是，为什么这两年才开始受到越来越多的企业重视和实践呢？因为DevOps的发展是独木不成林的，现在有越来越多的技术支撑。微服务架构理念、容器技术使得DevOps的实施变得更加容易，计算能力提升和云环境的发展使得快速开发的产品可以立刻获得更广泛的使用。</p><p>好处是什么？</p><p>DevOps的一个巨大好处就是可以高效交付，这也正好是它的初衷。Puppet和DevOps Research and Assessment (DORA) 主办了2016年DevOps调查报告，根据全球4600位各IT公司的技术工作者的提交数据统计，得出高效公司平均每年可以完成1460次部署。</p><p>与低效组织相比，高效组织的部署频繁200倍，产品投入使用速度快2555倍，服务恢复速度快24倍。在工作内容的时间分配上，低效者要多花22%的时间用在为规划好或者重复工作上，而高效者却可以多花29%的时间用在新的工作上。所以这里的高效不仅仅指公司产出的效率提高，还指员工的工作质量得到提升。</p><p>DevOps另外一个好处就是会改善公司组织文化、提高员工的参与感。员工们变得更高效，也更有满足和成就感；调查显示高效员工的雇员净推荐值（eNPS:employee Net Promoter Score）更高，即对公司更加认同。</p><p>快速部署同时提高IT稳定性。这难道不矛盾吗？</p><p>快速的部署其实可以帮助更快地发现问题，产品被更快地交付到用户手中，团队可以更快地得到用户的反馈，从而进行更快地响应。而且，DevOps小步快跑的形式带来的变化是比较小的，出现问题的偏差每次都不会太大，修复起来也会相对容易一些。</p><p><img src="dev4.png" alt></p><p>因此，认为速度就意味着危险是一种偏见。此外，滞后软件服务的发布也并不一定会完全地避免问题，在竞争日益激烈的IT行业，这反而可能错失了软件的发布时机</p><h1 id="为什么DevOps会兴起？"><a href="#为什么DevOps会兴起？" class="headerlink" title="为什么DevOps会兴起？"></a>为什么DevOps会兴起？</h1><h2 id="条件成熟：技术配套发展"><a href="#条件成熟：技术配套发展" class="headerlink" title="条件成熟：技术配套发展"></a>条件成熟：技术配套发展</h2><p>技术的发展使得DevOps有了更多的配合。早期时，大家虽然意识到了这个问题的，但是苦于当时没有完善丰富的技术工具，是一种“理想很丰满，但是现实很骨感”的情况。DevOps的实现可以基于新兴的容器技术；也可以在自动化运维工具Puppet、SaltStack、Ansible之后的延伸；还可以构建在传统的Cloud Foundry、OpenShift等PaaS厂商之上。</p><h2 id="来自市场的外部需求：这世界变化太快"><a href="#来自市场的外部需求：这世界变化太快" class="headerlink" title="来自市场的外部需求：这世界变化太快"></a>来自市场的外部需求：这世界变化太快</h2><p>IT行业已经越来越与市场的经济发展紧密挂钩，专家们认为IT将会有支持中心变成利润驱动中心。事实上，这个变化已经开始了，这不仅体现在Google、苹果这些大企业中，而且也发生在传统行业中，比如出租车业务中的Uber、酒店连锁行业中的Airbnb、图书经销商Amazon等等。能否让公司的IT配套方案及时跟上市场需求的步伐，在今天显得至关重要。</p><p>DevOps 2016年度报告给出了一个运维成本的计算公式：<br>停机费用成本 = 部署频率 * 版本迭代失败概率 * 平均修复时间 * 断电的金钱损失</p><p>来自团队的内在动力：工程师也需要</p><p>对于工程师而言，他们也是DevOps的受益者。微软资深工程师Scott Hanselman说过“对于开发者而言，最有力的工具就是自动化工具”（The most powerful tool we have as developers is automation）。</p><p>工具链的打通使得开发者们在交付软件时可以完成生产环境的构建、测试和运行；正如Amazon的VP兼CTO Werner Vogels那句让人印象深刻的话：“谁开发谁运行”。（You build it, you run it）</p><h2 id="实现DevOps需要什么？"><a href="#实现DevOps需要什么？" class="headerlink" title="实现DevOps需要什么？"></a>实现DevOps需要什么？</h2><h2 id="硬性要求：工具上的准备"><a href="#硬性要求：工具上的准备" class="headerlink" title="硬性要求：工具上的准备"></a>硬性要求：工具上的准备</h2><p>上文提到了工具链的打通，那么工具自然就需要做好准备。现将工具类型及对应的不完全列举整理如下：</p><ul><li><p>代码管理（SCM）：GitHub、GitLab、BitBucket、SubVersion</p></li><li><p>构建工具：Ant、Gradle、maven</p></li><li><p>自动部署：Capistrano、CodeDeploy</p></li><li><p>持续集成（CI）：Bamboo、Hudson、Jenkins</p></li><li><p>配置管理：Ansible、Chef、Puppet、SaltStack、ScriptRock GuardRail</p></li><li><p>容器：Docker、LXC、第三方厂商如AWS</p></li><li><p>编排：Kubernetes、Core、Apache Mesos、DC/OS</p></li><li><p>服务注册与发现：Zookeeper、etcd、Consul</p></li><li><p>脚本语言：python、ruby、shell</p></li><li><p>日志管理：ELK、Logentries</p></li><li><p>系统监控：Datadog、Graphite、Icinga、Nagios</p></li><li><p>性能监控：AppDynamics、New Relic、Splunk</p></li><li><p>压力测试：JMeter、Blaze Meter、loader.io</p></li><li><p>预警：PagerDuty、pingdom、厂商自带如AWS SNS</p></li><li><p>HTTP加速器：Varnish</p></li><li><p>消息总线：ActiveMQ、SQS</p></li><li><p>应用服务器：Tomcat、JBoss</p></li><li><p>Web服务器：Apache、Nginx、IIS</p></li><li><p>数据库：MySQL、Oracle、PostgreSQL等关系型数据库；cassandra、mongoDB、redis等NoSQL数据库</p></li><li><p>项目管理（PM）：Jira、Asana、Taiga、Trello、Basecamp、Pivotal Tracker<br>在工具的选择上，需要结合公司业务需求和技术团队情况而定。（注：更多关于工具的详细介绍可以参见此文：51 Best DevOps Tools for #DevOps Engineers）</p></li></ul><h2 id="软性需求：文化和人"><a href="#软性需求：文化和人" class="headerlink" title="软性需求：文化和人"></a>软性需求：文化和人</h2><p>DevOps成功与否，公司组织是否利于协作是关键。开发人员和运维人员可以良好沟通互相学习，从而拥有高生产力。并且协作也存在于业务人员与开发人员之间。</p><p>出席了2016年伦敦企业级DevOps峰会的ITV公司在2012年就开始落地DevOps，其通用平台主管Clark在接受了InfoQ的采访，在谈及成功时表示，业务人员非常清楚他们希望在最小化可行产品中实现什么，工程师们就按需交付，不做多余工作。</p><p>这样，工程师们使用通用的平台（即打通的工具链）得到更好的一致性和更高的质量。此外，DevOps对工程师个人的要求也提高了，很多专家也认为招募到优秀的人才也是一个挑战。</p><h2 id="DevOps的采用现状"><a href="#DevOps的采用现状" class="headerlink" title="DevOps的采用现状"></a>DevOps的采用现状</h2><h3 id="哪些公司在用？"><a href="#哪些公司在用？" class="headerlink" title="哪些公司在用？"></a>哪些公司在用？</h3><p>DevOps正在增长，尤其是在大企业中：调查发现，DevOps的接受度有了显著提高。74%的受访者已经接受了DevOps，而去年这一比例为66%。目前，在81%的大企业开始接受DevOps，中小企业的接受度仅为70%。<br>那么具体而言都有些公司在采用DevOps呢？Adobe、Amazon、Apple、Airbnb、Ebay、Etsy、Facebook、LinkedIn、Netflix、NASA、Starbucks、Target（泛欧实时全额自动清算系统）、Walmart、Sony等等。</p><h3 id="他们怎么实施的？"><a href="#他们怎么实施的？" class="headerlink" title="他们怎么实施的？"></a>他们怎么实施的？</h3><p>首先，大企业正在自下而上接受DevOps，其中业务单位或部门（31%）以及项目和团队（29%）已经实施DevOps。不过，只有21%的大企业在整个公司范围内采用了DevOps。 </p><p>其次，在工具层面上，DevOps工具的用量大幅激增。Chef和Puppet依然是最常用的DevOps工具，使用率均为32%。Docker是年增长率最快的工具，用量增长一倍以上。Ansible的用量也有显著增加，使用率从10%翻倍至20%。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/liufei1983/p/7152013.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;摘抄自&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;DevOps简介&quot;&gt;&lt;a href=&quot;#DevOps
      
    
    </summary>
    
    
      <category term="开发模式" scheme="http://iwantjingjing.com/categories/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="DevOps" scheme="http://iwantjingjing.com/tags/DevOps/"/>
    
      <category term="开发模式，摘抄" scheme="http://iwantjingjing.com/tags/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%91%98%E6%8A%84/"/>
    
  </entry>
  
  <entry>
    <title>读别让自己墙了自己有感</title>
    <link href="http://iwantjingjing.com/2019/12/02/%E8%AF%BB%E5%88%AB%E8%AE%A9%E8%87%AA%E5%B7%B1%E5%A2%99%E4%BA%86%E8%87%AA%E5%B7%B1%E6%9C%89%E6%84%9F/"/>
    <id>http://iwantjingjing.com/2019/12/02/读别让自己墙了自己有感/</id>
    <published>2019-12-02T05:38:44.000Z</published>
    <updated>2019-12-22T13:22:53.914Z</updated>
    
    <content type="html"><![CDATA[<p> <a href="https://coolshell.cn/articles/20276.html/comment-page-2#comments" target="_blank" rel="noopener">文章链接</a></p><h1 id="收获的主题"><a href="#收获的主题" class="headerlink" title="收获的主题"></a>收获的主题</h1><ul><li><p>只专注于一种技术其他都是垃圾（不要将自己的技术栈封闭起来）</p></li><li><p>关注负面的东西不要胜过正面的东西</p></li><li><p>离开Java的世界就基本上做不了架构了</p></li><li><p>把自己最宝贵的时间用在了很烂的项目上，就算能用一些新技术也只能是自娱自乐，在实验室中玩玩罢了</p></li><li><p>把自己的技术栈封闭起来，直接放弃了这个时代最具有工业化的技术Java，对于一个好的程序员来说同时掌握几种语言和技术是完全没有问题的，不要自己封闭了自己的视野</p></li><li><p>视野、环境和舞台对一个人的限制是非常大的。井蛙不知大海，被空间维度所限制；夏虫不知冬天，被时间维度所限制；圈养的动物没有斗志，是被自己意志所限制。</p></li><li><p>偏见和不开放，对一个人限制是真正有毁灭性的。主动让自己成为一个瞎子和聋子，主动把自己能力阉割掉是多么让人痛心的一件事。</p></li><li><p>不限制自己的人会穷举各种方法来解决问题，限制自己的人，会找各式各样的问题或借口。</p></li><li><p>不限制自己的人，会努力改变自己的问题和缺陷，限制自己的人会放任自己。</p></li><li><p>先把软件设计好再写代码。</p><h1 id="技术方向"><a href="#技术方向" class="headerlink" title="技术方向"></a>技术方向</h1></li><li><p>Docker、go、k8s</p></li><li><p>翻找Youtube的各种大会，GitHub的各种issue和pull request</p></li><li><p>成为一个技术牛人的条件：基础知识过硬，细节扎得深，面很广，学习能力强，有英文能力，逻辑思维能力不错，非常的自律，执行力也很强，抓得住重点,最重要的一点：在大公司历练过。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></li><li><p>做高价值的事。所谓高价值，就是：别人愿付高价的，高技术门槛的，有创造力的，颠覆性的……</p></li><li><p>扩大自己的眼界，开放自己的内心。你的英文语言能力对你能不能融入世界是起决定性的作用。你的视野决定了你知不知道要去哪，你的开放决定了你想不想去。</p></li><li><p>站在更高的维度.面的维度会超过点的维度，空间的维度会超过面的维度，在更高维度上思考和学习，你会收货更多。整天在焦虑那些低维度的事（比如自己的薪水、工作的地点、稳不稳定、有没有户口……)，只会让你变得越来越平庸，只要你站在更高的维度（比如：眼界有没有扩大、可能性是不是更多、竞争力是不是更强、能不能解决更大更难的问题、能创造多大的价值……)，时间会让你明白那些低维度的东西全都不是事儿。技术学习上也一样，站在学习编程语法特性的维度和站在学习编程范式、设计模式的维度是两种完全不一样的学习方式。</p></li><li><p>精于计算得失。很多人其实不是很懂计算。绝大多数人都是在计算自己会失去多少，而不会算得到多少。而一般的人也总是在算短期内会失去什么，优秀的则总是会算我投入后未来会有什么样的回报，前者在算计今天，目光短浅，而后者则是舍在今天，得在明天，计算的是未来。精于计算得失的，就懂得什么是投资，不懂的只会投机。对于赚钱，你可以投机，但是对于自己最好还是投资。</p></li><li><p>勇于跳出传统的束缚。做”鸡”的比”二奶”好多了</p></li><li><p>别自己墙了自己，人最可悲的就是自己限制自己，想都不敢想！</p><p>庄子曰过：</p><p> 井蛙不可以语于海者，拘于虚也；//空间局限</p><p> 夏虫不可以语于冰者，笃于时也；//时间局限</p><p> 曲士不可以语于道者，束于教也。//认识局限</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;a href=&quot;https://coolshell.cn/articles/20276.html/comment-page-2#comments&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章链接&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;收获的主题&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="读后感" scheme="http://iwantjingjing.com/categories/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    
      <category term="读后感，左耳" scheme="http://iwantjingjing.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F%EF%BC%8C%E5%B7%A6%E8%80%B3/"/>
    
  </entry>
  
  <entry>
    <title>杀威棍</title>
    <link href="http://iwantjingjing.com/2019/10/06/%E6%9D%80%E5%A8%81%E6%A3%8D/"/>
    <id>http://iwantjingjing.com/2019/10/06/杀威棍/</id>
    <published>2019-10-06T08:06:05.000Z</published>
    <updated>2019-10-06T08:13:39.634Z</updated>
    
    <content type="html"><![CDATA[<p>《说唐》里秦叔宝进牢房时,衙役喊得一句话来解释:<br>“进的牢来先打你一百杀威棍,看你老不老实!”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《说唐》里秦叔宝进牢房时,衙役喊得一句话来解释:&lt;br&gt;“进的牢来先打你一百杀威棍,看你老不老实!”&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="传统文化" scheme="http://iwantjingjing.com/tags/%E4%BC%A0%E7%BB%9F%E6%96%87%E5%8C%96/"/>
    
  </entry>
  
</feed>
