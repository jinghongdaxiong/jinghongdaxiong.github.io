<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>I want jing jing</title>
  
  <subtitle>I want jing jing ,Don&#39;t ask me who is jing jing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://iwantjingjing.com/"/>
  <updated>2020-11-01T14:05:11.485Z</updated>
  <id>http://iwantjingjing.com/</id>
  
  <author>
    <name>给予ππ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>架构师问题</title>
    <link href="http://iwantjingjing.com/2020/11/01/%E6%9E%B6%E6%9E%84%E5%B8%88%E9%97%AE%E9%A2%98/"/>
    <id>http://iwantjingjing.com/2020/11/01/%E6%9E%B6%E6%9E%84%E5%B8%88%E9%97%AE%E9%A2%98/</id>
    <published>2020-11-01T14:04:04.000Z</published>
    <updated>2020-11-01T14:05:11.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="架构师技术问题："><a href="#架构师技术问题：" class="headerlink" title="架构师技术问题："></a>架构师技术问题：</h1><h2 id="在生产者、消费者、MQ中间件，都存在的情况下，如何设计才能保证发送MQ消息的100-不丢失。"><a href="#在生产者、消费者、MQ中间件，都存在的情况下，如何设计才能保证发送MQ消息的100-不丢失。" class="headerlink" title="在生产者、消费者、MQ中间件，都存在的情况下，如何设计才能保证发送MQ消息的100%不丢失。"></a>在生产者、消费者、MQ中间件，都存在的情况下，如何设计才能保证发送MQ消息的100%不丢失。</h2><h2 id="如何让MQ消费者按照消息发送的先后顺序进行消费？"><a href="#如何让MQ消费者按照消息发送的先后顺序进行消费？" class="headerlink" title="如何让MQ消费者按照消息发送的先后顺序进行消费？"></a>如何让MQ消费者按照消息发送的先后顺序进行消费？</h2><h2 id="当MQ集群挂了情况下，你们如何处理消息，有没有备用方案？"><a href="#当MQ集群挂了情况下，你们如何处理消息，有没有备用方案？" class="headerlink" title="当MQ集群挂了情况下，你们如何处理消息，有没有备用方案？"></a>当MQ集群挂了情况下，你们如何处理消息，有没有备用方案？</h2><h2 id="说一说JVM实际工作中，常用的年轻代和老年代的组合。"><a href="#说一说JVM实际工作中，常用的年轻代和老年代的组合。" class="headerlink" title="说一说JVM实际工作中，常用的年轻代和老年代的组合。"></a>说一说JVM实际工作中，常用的年轻代和老年代的组合。</h2><h2 id="默认情况下，一个对象经过多少次垃圾回收会进入老年代？"><a href="#默认情况下，一个对象经过多少次垃圾回收会进入老年代？" class="headerlink" title="默认情况下，一个对象经过多少次垃圾回收会进入老年代？"></a>默认情况下，一个对象经过多少次垃圾回收会进入老年代？</h2><h2 id="生产环境下：永久代一般分配大多内存？"><a href="#生产环境下：永久代一般分配大多内存？" class="headerlink" title="生产环境下：永久代一般分配大多内存？"></a>生产环境下：永久代一般分配大多内存？</h2><h2 id="JVM如何只作YongGC不做FullGC？"><a href="#JVM如何只作YongGC不做FullGC？" class="headerlink" title="JVM如何只作YongGC不做FullGC？"></a>JVM如何只作YongGC不做FullGC？</h2><h2 id="G1垃圾回收器是如何分配内存的？"><a href="#G1垃圾回收器是如何分配内存的？" class="headerlink" title="G1垃圾回收器是如何分配内存的？"></a>G1垃圾回收器是如何分配内存的？</h2><h2 id="Java内存模型？"><a href="#Java内存模型？" class="headerlink" title="Java内存模型？"></a>Java内存模型？</h2><h2 id="JVM内存分配？一台4核8G的服务器，分配多少内存？"><a href="#JVM内存分配？一台4核8G的服务器，分配多少内存？" class="headerlink" title="JVM内存分配？一台4核8G的服务器，分配多少内存？"></a>JVM内存分配？一台4核8G的服务器，分配多少内存？</h2><h2 id="JVM优化思路？"><a href="#JVM优化思路？" class="headerlink" title="JVM优化思路？"></a>JVM优化思路？</h2><h2 id="G1垃圾回收器使用场景？"><a href="#G1垃圾回收器使用场景？" class="headerlink" title="G1垃圾回收器使用场景？"></a>G1垃圾回收器使用场景？</h2><p>##你们公司的缓存架构是如何设计的？</p><h2 id="微服务之间访问的超时时间是如何设置的，设置依据是什么？"><a href="#微服务之间访问的超时时间是如何设置的，设置依据是什么？" class="headerlink" title="微服务之间访问的超时时间是如何设置的，设置依据是什么？"></a>微服务之间访问的超时时间是如何设置的，设置依据是什么？</h2><h2 id="限流机制是如何做的？限流的线程池数量大小怎么设置的？有什么参考标准？"><a href="#限流机制是如何做的？限流的线程池数量大小怎么设置的？有什么参考标准？" class="headerlink" title="限流机制是如何做的？限流的线程池数量大小怎么设置的？有什么参考标准？"></a>限流机制是如何做的？限流的线程池数量大小怎么设置的？有什么参考标准？</h2><h2 id="HDFS的主节点和备份节点是如何同步数据的。"><a href="#HDFS的主节点和备份节点是如何同步数据的。" class="headerlink" title="HDFS的主节点和备份节点是如何同步数据的。"></a>HDFS的主节点和备份节点是如何同步数据的。</h2><h2 id="MySQL在8核16G，16核32G情况下，承载的并发量大概是多大？"><a href="#MySQL在8核16G，16核32G情况下，承载的并发量大概是多大？" class="headerlink" title="MySQL在8核16G，16核32G情况下，承载的并发量大概是多大？"></a>MySQL在8核16G，16核32G情况下，承载的并发量大概是多大？</h2><h2 id="SpringCloud有生产落地经验吗？"><a href="#SpringCloud有生产落地经验吗？" class="headerlink" title="SpringCloud有生产落地经验吗？"></a>SpringCloud有生产落地经验吗？</h2><h2 id="maven和私服是如何管理和使用的？"><a href="#maven和私服是如何管理和使用的？" class="headerlink" title="maven和私服是如何管理和使用的？"></a>maven和私服是如何管理和使用的？</h2><h2 id="redis和db如何做到读写一致？分低并发和高并发场景回答"><a href="#redis和db如何做到读写一致？分低并发和高并发场景回答" class="headerlink" title="redis和db如何做到读写一致？分低并发和高并发场景回答"></a>redis和db如何做到读写一致？分低并发和高并发场景回答</h2><h2 id="分布式事务使用的框架，遇到的问题，原理？"><a href="#分布式事务使用的框架，遇到的问题，原理？" class="headerlink" title="分布式事务使用的框架，遇到的问题，原理？"></a>分布式事务使用的框架，遇到的问题，原理？</h2><h2 id="分布式锁实现由哪些方式？性能如何，zk锁并发多的时候如何进行优化？"><a href="#分布式锁实现由哪些方式？性能如何，zk锁并发多的时候如何进行优化？" class="headerlink" title="分布式锁实现由哪些方式？性能如何，zk锁并发多的时候如何进行优化？"></a>分布式锁实现由哪些方式？性能如何，zk锁并发多的时候如何进行优化？</h2><h2 id="微服务拆分原则是什么？如何拆分的？"><a href="#微服务拆分原则是什么？如何拆分的？" class="headerlink" title="微服务拆分原则是什么？如何拆分的？"></a>微服务拆分原则是什么？如何拆分的？</h2><h2 id="你们的配置文件是如何管理的？"><a href="#你们的配置文件是如何管理的？" class="headerlink" title="你们的配置文件是如何管理的？"></a>你们的配置文件是如何管理的？</h2><h2 id="分布式锁有哪些实现方式，各自的使用场景？"><a href="#分布式锁有哪些实现方式，各自的使用场景？" class="headerlink" title="分布式锁有哪些实现方式，各自的使用场景？"></a>分布式锁有哪些实现方式，各自的使用场景？</h2><h2 id="分布式事务如何做的？"><a href="#分布式事务如何做的？" class="headerlink" title="分布式事务如何做的？"></a>分布式事务如何做的？</h2><h2 id="微服务用了几台服务器，服务器的配置是什么？"><a href="#微服务用了几台服务器，服务器的配置是什么？" class="headerlink" title="微服务用了几台服务器，服务器的配置是什么？"></a>微服务用了几台服务器，服务器的配置是什么？</h2><h2 id="服务熔断和降级如何做的？"><a href="#服务熔断和降级如何做的？" class="headerlink" title="服务熔断和降级如何做的？"></a>服务熔断和降级如何做的？</h2><h2 id="限流是如何做的？"><a href="#限流是如何做的？" class="headerlink" title="限流是如何做的？"></a>限流是如何做的？</h2><h2 id="接口基本的性能测试如何做？"><a href="#接口基本的性能测试如何做？" class="headerlink" title="接口基本的性能测试如何做？"></a>接口基本的性能测试如何做？</h2><h2 id="zookeeper挂了，dubbo还能用么？"><a href="#zookeeper挂了，dubbo还能用么？" class="headerlink" title="zookeeper挂了，dubbo还能用么？"></a>zookeeper挂了，dubbo还能用么？</h2><h2 id="MQ用过嘛？-用在哪些场景？"><a href="#MQ用过嘛？-用在哪些场景？" class="headerlink" title="MQ用过嘛？ 用在哪些场景？"></a>MQ用过嘛？ 用在哪些场景？</h2><h2 id="消费者默认重试多少次？"><a href="#消费者默认重试多少次？" class="headerlink" title="消费者默认重试多少次？"></a>消费者默认重试多少次？</h2><h2 id="rocketMQ如果几次消费重试都失败了，如何处理？"><a href="#rocketMQ如果几次消费重试都失败了，如何处理？" class="headerlink" title="rocketMQ如果几次消费重试都失败了，如何处理？"></a>rocketMQ如果几次消费重试都失败了，如何处理？</h2><h2 id="守护线程和用户线程区别？"><a href="#守护线程和用户线程区别？" class="headerlink" title="守护线程和用户线程区别？"></a>守护线程和用户线程区别？</h2><h2 id="线程池用过嘛？怎么用的？"><a href="#线程池用过嘛？怎么用的？" class="headerlink" title="线程池用过嘛？怎么用的？"></a>线程池用过嘛？怎么用的？</h2><h2 id="一台机器4C8G大约可以开多少线程？根据什么计算？可以分CPU密集型和IO密集型应用说。"><a href="#一台机器4C8G大约可以开多少线程？根据什么计算？可以分CPU密集型和IO密集型应用说。" class="headerlink" title="一台机器4C8G大约可以开多少线程？根据什么计算？可以分CPU密集型和IO密集型应用说。"></a>一台机器4C8G大约可以开多少线程？根据什么计算？可以分CPU密集型和IO密集型应用说。</h2><h2 id="读多写少用什么锁？"><a href="#读多写少用什么锁？" class="headerlink" title="读多写少用什么锁？"></a>读多写少用什么锁？</h2><h2 id="redis如何删除过期数据的？"><a href="#redis如何删除过期数据的？" class="headerlink" title="redis如何删除过期数据的？"></a>redis如何删除过期数据的？</h2><h2 id="redis雪崩如何处理？"><a href="#redis雪崩如何处理？" class="headerlink" title="redis雪崩如何处理？"></a>redis雪崩如何处理？</h2><h2 id="如何保证redis和db的读写一致？"><a href="#如何保证redis和db的读写一致？" class="headerlink" title="如何保证redis和db的读写一致？"></a>如何保证redis和db的读写一致？</h2><h2 id="都多写少用什么锁？"><a href="#都多写少用什么锁？" class="headerlink" title="都多写少用什么锁？"></a>都多写少用什么锁？</h2><h2 id="如果保证MQ消息的零丢失？"><a href="#如果保证MQ消息的零丢失？" class="headerlink" title="如果保证MQ消息的零丢失？"></a>如果保证MQ消息的零丢失？</h2><h2 id="假设一个表有abc三个字段，实际的查询场景需要按照-a-b，b-c进行查询，如何设计索引，让所有的查询都能用到索引？"><a href="#假设一个表有abc三个字段，实际的查询场景需要按照-a-b，b-c进行查询，如何设计索引，让所有的查询都能用到索引？" class="headerlink" title="假设一个表有abc三个字段，实际的查询场景需要按照 a+b，b+c进行查询，如何设计索引，让所有的查询都能用到索引？"></a>假设一个表有abc三个字段，实际的查询场景需要按照 a+b，b+c进行查询，如何设计索引，让所有的查询都能用到索引？</h2><h2 id="abc三个字段建立了联合索引"><a href="#abc三个字段建立了联合索引" class="headerlink" title="abc三个字段建立了联合索引"></a>abc三个字段建立了联合索引</h2><h2 id="where条件是-a-‘’-and-b-’’"><a href="#where条件是-a-‘’-and-b-’’" class="headerlink" title="where条件是 a = ‘’ and b=’’"></a>where条件是 a = ‘’ and b=’’</h2><h2 id="where条件是-a-‘’-and-c-’’"><a href="#where条件是-a-‘’-and-c-’’" class="headerlink" title="where条件是 a = ‘’ and c=’’"></a>where条件是 a = ‘’ and c=’’</h2><h2 id="where条件是-b-‘’-and-c-’’"><a href="#where条件是-b-‘’-and-c-’’" class="headerlink" title="where条件是 b = ‘’ and c=’’"></a>where条件是 b = ‘’ and c=’’</h2><h2 id="mysql数据库默认的事务隔离级别是什么？"><a href="#mysql数据库默认的事务隔离级别是什么？" class="headerlink" title="mysql数据库默认的事务隔离级别是什么？"></a>mysql数据库默认的事务隔离级别是什么？</h2><h2 id="mysql索引的创建原则？"><a href="#mysql索引的创建原则？" class="headerlink" title="mysql索引的创建原则？"></a>mysql索引的创建原则？</h2><h2 id="mysql如何进行性能压测？"><a href="#mysql如何进行性能压测？" class="headerlink" title="mysql如何进行性能压测？"></a>mysql如何进行性能压测？</h2><h2 id="mysql如何对sql进行性能分析？"><a href="#mysql如何对sql进行性能分析？" class="headerlink" title="mysql如何对sql进行性能分析？"></a>mysql如何对sql进行性能分析？</h2><h2 id="mysql服务器的配置？"><a href="#mysql服务器的配置？" class="headerlink" title="mysql服务器的配置？"></a>mysql服务器的配置？</h2><h2 id="必问问题："><a href="#必问问题：" class="headerlink" title="必问问题："></a>必问问题：</h2><h2 id="1、找工作最看重一家公司的哪些方面？3-5年职业规划。"><a href="#1、找工作最看重一家公司的哪些方面？3-5年职业规划。" class="headerlink" title="1、找工作最看重一家公司的哪些方面？3-5年职业规划。"></a>1、找工作最看重一家公司的哪些方面？3-5年职业规划。</h2><h2 id="团队，"><a href="#团队，" class="headerlink" title="团队，"></a>团队，</h2><h2 id="2、上班时间和距离是否接受"><a href="#2、上班时间和距离是否接受" class="headerlink" title="2、上班时间和距离是否接受"></a>2、上班时间和距离是否接受</h2><h2 id="东西上，8-30"><a href="#东西上，8-30" class="headerlink" title="东西上，8:30"></a>东西上，8:30</h2><h2 id="3、目前薪资-，期望薪资，最快入职时间。"><a href="#3、目前薪资-，期望薪资，最快入职时间。" class="headerlink" title="3、目前薪资 ，期望薪资，最快入职时间。"></a>3、目前薪资 ，期望薪资，最快入职时间。</h2><h2 id="30-40，1周"><a href="#30-40，1周" class="headerlink" title="30-40，1周"></a>30-40，1周</h2><h2 id="4、对加班看法？"><a href="#4、对加班看法？" class="headerlink" title="4、对加班看法？"></a>4、对加班看法？</h2><h2 id="5、在职还是离职？离职时间，离职原因"><a href="#5、在职还是离职？离职时间，离职原因" class="headerlink" title="5、在职还是离职？离职时间，离职原因:"></a>5、在职还是离职？离职时间，离职原因:</h2><h2 id="微服务的优点和缺点是什么？"><a href="#微服务的优点和缺点是什么？" class="headerlink" title="微服务的优点和缺点是什么？"></a>微服务的优点和缺点是什么？</h2><h2 id="Springboot如何区分开发环境和生产环境"><a href="#Springboot如何区分开发环境和生产环境" class="headerlink" title="Springboot如何区分开发环境和生产环境"></a>Springboot如何区分开发环境和生产环境</h2><h2 id="spring-cloud-的核心组件有哪些？"><a href="#spring-cloud-的核心组件有哪些？" class="headerlink" title="spring cloud 的核心组件有哪些？"></a>spring cloud 的核心组件有哪些？</h2><h2 id="Eureka：服务注册于发现。"><a href="#Eureka：服务注册于发现。" class="headerlink" title="Eureka：服务注册于发现。"></a>Eureka：服务注册于发现。</h2><h2 id="Feign：基于动态代理机制，根据注解和选择的机器，拼接请求-url-地址，发起请求。"><a href="#Feign：基于动态代理机制，根据注解和选择的机器，拼接请求-url-地址，发起请求。" class="headerlink" title="Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。"></a>Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。</h2><h2 id="Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。"><a href="#Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。" class="headerlink" title="Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。"></a>Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。</h2><h2 id="Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。"><a href="#Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。" class="headerlink" title="Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。"></a>Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。</h2><h2 id="Zuul：网关管理，由-Zuul-网关转发请求给对应的服务。"><a href="#Zuul：网关管理，由-Zuul-网关转发请求给对应的服务。" class="headerlink" title="Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。"></a>Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;架构师技术问题：&quot;&gt;&lt;a href=&quot;#架构师技术问题：&quot; class=&quot;headerlink&quot; title=&quot;架构师技术问题：&quot;&gt;&lt;/a&gt;架构师技术问题：&lt;/h1&gt;&lt;h2 id=&quot;在生产者、消费者、MQ中间件，都存在的情况下，如何设计才能保证发送MQ消息的100
      
    
    </summary>
    
    
      <category term="面试" scheme="http://iwantjingjing.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://iwantjingjing.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>读断舍离有感</title>
    <link href="http://iwantjingjing.com/2020/07/20/%E8%AF%BB%E6%96%AD%E8%88%8D%E7%A6%BB%E6%9C%89%E6%84%9F/"/>
    <id>http://iwantjingjing.com/2020/07/20/%E8%AF%BB%E6%96%AD%E8%88%8D%E7%A6%BB%E6%9C%89%E6%84%9F/</id>
    <published>2020-07-20T00:32:15.000Z</published>
    <updated>2020-07-20T16:30:46.604Z</updated>
    
    <content type="html"><![CDATA[<p>   近日在老师的推荐下，有幸读了蔡雪莲老师的断舍离。感觉受益良多。特此记录。</p><p>   全书从断、舍、离三个方面阐述了如何做人及做事的道理。断指的是断绝繁杂，从是什么，为什么，怎么做三个发方面论述。舍指的是舍弃重负，人生就是一场旅行，行李越重，走的越艰辛。咱得学会做选择，舍弃一些不必要的，知道啥是自己真正需要的。啥都想要的 结果就是啥都得不到。一份耕耘一份收获！离：就是舍弃执念。这个观点使我不由的想起《金刚经》的精髓：”应无所住，而生其心”。我的理解：离并不是没有原则，啥都不坚持，而是老师说的”方法论”换个方法，再试！一件事儿成与不成！方法很重要。为同一个目标尝试多种方法，从而取最优解，比对所有目标用一个方法好的多。很简单的一个例子就是：一个经验用十年还是十年经验是不同的。别给自己设限，敢于尝试，乐于尝试！我行！</p><p>   读书真的就是交朋友，通过一个朋友认识另一个朋友。通过一本书，了解另一本书。人生三大喜事：洞房花烛夜、金榜题名时、他乡遇顾知。前两件或许很难实现，通过读书，第三件确是经常遇到。读的过程中，你会突然有一种他乡遇顾知的感觉,然后会心一笑，原来你也在这儿！</p><p>   读《断舍离》就有这种感觉，中间的好多观点与《少有人走的路》不谋而合。读这本书对我最大的启发还是第一章论述的一个观点”学会做人生的减法”，知行合一，读了这段自己就实践了一下：过程不表，就是扔了很多旧衣服啥的！心情顿时舒畅。然后开始读下一段：咦！不对啊！咋有一种笑傲江湖那个段子的感觉？</p><p>   “欲练此功？必先自宫” 刚完事！下一篇写到”欲练此功？也可不宫”！刚扔完，雪莲老师就开始教旧物利用。好吧，就这样吧！老实说扔点东西，还是很爽的！</p><p><img src="%E6%96%AD%E8%88%8D%E7%A6%BB.png" alt="脑图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   近日在老师的推荐下，有幸读了蔡雪莲老师的断舍离。感觉受益良多。特此记录。&lt;/p&gt;
&lt;p&gt;   全书从断、舍、离三个方面阐述了如何做人及做事的道理。断指的是断绝繁杂，从是什么，为什么，怎么做三个发方面论述。舍指的是舍弃重负，人生就是一场旅行，行李越重，走的越艰辛。咱得学
      
    
    </summary>
    
    
    
      <category term="读后感" scheme="http://iwantjingjing.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>mysql误删一条数据如何恢复</title>
    <link href="http://iwantjingjing.com/2020/06/27/mysql%E8%AF%AF%E5%88%A0%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D/"/>
    <id>http://iwantjingjing.com/2020/06/27/mysql%E8%AF%AF%E5%88%A0%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D/</id>
    <published>2020-06-27T13:12:12.000Z</published>
    <updated>2020-06-27T13:16:12.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="误删了一条数据或一个表如何恢复"><a href="#误删了一条数据或一个表如何恢复" class="headerlink" title="误删了一条数据或一个表如何恢复"></a>误删了一条数据或一个表如何恢复</h1><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;误删了一条数据或一个表如何恢复&quot;&gt;&lt;a href=&quot;#误删了一条数据或一个表如何恢复&quot; class=&quot;headerlink&quot; title=&quot;误删了一条数据或一个表如何恢复&quot;&gt;&lt;/a&gt;误删了一条数据或一个表如何恢复&lt;/h1&gt;&lt;h1 id=&quot;解决方案&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://iwantjingjing.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://iwantjingjing.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>多线程与JVM</title>
    <link href="http://iwantjingjing.com/2020/06/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8EJVM/"/>
    <id>http://iwantjingjing.com/2020/06/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8EJVM/</id>
    <published>2020-06-01T05:16:35.000Z</published>
    <updated>2020-06-01T05:39:17.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="1、如何在Java中实现线程？"><a href="#1、如何在Java中实现线程？" class="headerlink" title="1、如何在Java中实现线程？"></a>1、如何在Java中实现线程？</h2><p>Tips：继承Thread、实现Runnable、实现Callable接口通过FutureTask包装器来创建Thread线程、线<br>程池。建议看源码消化；</p><h2 id="2、在具体多线程编程实践中，如何选用Runnable还是Thread？"><a href="#2、在具体多线程编程实践中，如何选用Runnable还是Thread？" class="headerlink" title="2、在具体多线程编程实践中，如何选用Runnable还是Thread？"></a>2、在具体多线程编程实践中，如何选用Runnable还是Thread？</h2><p>Tips：接口、类的区别。讲解服务熔断多线程ExceptionRatioDegradeDemo的代码示例。</p><h2 id="3、Thread类中的start-和run-方法有什么区别？"><a href="#3、Thread类中的start-和run-方法有什么区别？" class="headerlink" title="3、Thread类中的start()和run()方法有什么区别？"></a>3、Thread类中的start()和run()方法有什么区别？</h2><p>Tips：start就绪，run运行，掌握Thread的内部类State</p><h2 id="4、Java中Runnable和Callable有什么不同？"><a href="#4、Java中Runnable和Callable有什么不同？" class="headerlink" title="4、Java中Runnable和Callable有什么不同？"></a>4、Java中Runnable和Callable有什么不同？</h2><p>Tips：Runnable和Callable基于接口实现多线程，前者不带返回参数，后者带返回参数</p><h2 id="5、Java多线程中调用wait-和-sleep-方法有什么不同？"><a href="#5、Java多线程中调用wait-和-sleep-方法有什么不同？" class="headerlink" title="5、Java多线程中调用wait() 和 sleep()方法有什么不同？"></a>5、Java多线程中调用wait() 和 sleep()方法有什么不同？</h2><p>Tips：Wait、notify一起使用，sleep当前线程睡眠</p><h2 id="6、什么是Executor框架？"><a href="#6、什么是Executor框架？" class="headerlink" title="6、什么是Executor框架？"></a>6、什么是Executor框架？</h2><p>Tips：线程池框架，管理线程的生命周期。 Executor框架包含Executors，ExecutorService，CompletionService，<br>Future，Callable等 </p><h2 id="7、在Java中Executor和Executors的区别？"><a href="#7、在Java中Executor和Executors的区别？" class="headerlink" title="7、在Java中Executor和Executors的区别？"></a>7、在Java中Executor和Executors的区别？</h2><p>Tips：Executor是多线程自带的框架， Executors是Executor框架的工厂类，通过Executors创建不同类型的线程池</p><h2 id="8、Java中用到的线程调度算法是什么"><a href="#8、Java中用到的线程调度算法是什么" class="headerlink" title="8、Java中用到的线程调度算法是什么"></a>8、Java中用到的线程调度算法是什么</h2><p>Tips：对高优先级，使用优先调度的抢占式策略；同优先级线程组成先进先出队列（先到先服务），使用时间片策<br>略。</p><h2 id="9、什么是多线程中的上下文切换？"><a href="#9、什么是多线程中的上下文切换？" class="headerlink" title="9、什么是多线程中的上下文切换？"></a>9、什么是多线程中的上下文切换？</h2><p>Tips：CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换<br>前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加<br>载的过程就是一次上下文切换。</p><h2 id="10、什么是线程安全？"><a href="#10、什么是线程安全？" class="headerlink" title="10、什么是线程安全？"></a>10、什么是线程安全？</h2><p>Tips：多线程访问，有锁保护，不会出现数据不一致、数据污染等情况</p><h2 id="11、请说说有哪些线程不安全的java类？"><a href="#11、请说说有哪些线程不安全的java类？" class="headerlink" title="11、请说说有哪些线程不安全的java类？"></a>11、请说说有哪些线程不安全的java类？</h2><p>Tips： ArrayList(非)、Vector；HashMap(非)、HashTable</p><h2 id="12、Java中如何获取到线程dump文件？"><a href="#12、Java中如何获取到线程dump文件？" class="headerlink" title="12、Java中如何获取到线程dump文件？"></a>12、Java中如何获取到线程dump文件？</h2><p>Tips：jvm常见命令。 jmap -dump:format=b,file=文件名 [pid]。参考：<br><a href="https://www.cnblogs.com/0616--ataozhijia/p/4136312.html" target="_blank" rel="noopener">https://www.cnblogs.com/0616--ataozhijia/p/4136312.html</a></p><h2 id="13、池技术有什么作用，常见的池技术有哪些？"><a href="#13、池技术有什么作用，常见的池技术有哪些？" class="headerlink" title="13、池技术有什么作用，常见的池技术有哪些？"></a>13、池技术有什么作用，常见的池技术有哪些？</h2><p>tips：复用对象，节省创建、销毁资源的时间，提升性能</p><h2 id="14、请谈谈线程池的使用场景"><a href="#14、请谈谈线程池的使用场景" class="headerlink" title="14、请谈谈线程池的使用场景"></a>14、请谈谈线程池的使用场景</h2><p>tips：大量线程使用的场景，且线程执行的时间较短，特别耗时的操作会导致大量线程阻塞，甚<br>至导致系统宕机</p><h2 id="15、用线程池有什么好处？"><a href="#15、用线程池有什么好处？" class="headerlink" title="15、用线程池有什么好处？"></a>15、用线程池有什么好处？</h2><p>tips：线程的复用，节省线程的创建、销毁时间，提升性能。参考jason java多线程.ppt</p><h2 id="16、线程池的技术原理是什么？"><a href="#16、线程池的技术原理是什么？" class="headerlink" title="16、线程池的技术原理是什么？"></a>16、线程池的技术原理是什么？</h2><p>Tips：读ThreadPoolExecutor源码，了解execute 方法，掌握线程池的原理示意图。<br>可参考： <a href="https://www.cnblogs.com/cm4j/p/thread-pool.html" target="_blank" rel="noopener">https://www.cnblogs.com/cm4j/p/thread-pool.html</a></p><h2 id="17、线程池有哪些种类，各自的使用场景是什么？"><a href="#17、线程池有哪些种类，各自的使用场景是什么？" class="headerlink" title="17、线程池有哪些种类，各自的使用场景是什么？"></a>17、线程池有哪些种类，各自的使用场景是什么？</h2><p>tips：掌握excutors，读源码。参考jason java多线程.ppt</p><h2 id="18、线程池有哪些重要的参数？"><a href="#18、线程池有哪些重要的参数？" class="headerlink" title="18、线程池有哪些重要的参数？"></a>18、线程池有哪些重要的参数？</h2><p>Tips：掌握ThreadPoolExecutor， corePoolSize、maximumPoolSize、keepAliveTime</p><h2 id="19、你们在具体的设计开发过程中是如何设置这些重要参数的？"><a href="#19、你们在具体的设计开发过程中是如何设置这些重要参数的？" class="headerlink" title="19、你们在具体的设计开发过程中是如何设置这些重要参数的？"></a>19、你们在具体的设计开发过程中是如何设置这些重要参数的？</h2><p>Tips： corePoolSize、maximumPoolSize和cpu、内存有关系，考虑到一定的冗余，宁可小不可大。</p><h2 id="20、单例的使用场景是什么，如何实现单例？"><a href="#20、单例的使用场景是什么，如何实现单例？" class="headerlink" title="20、单例的使用场景是什么，如何实现单例？"></a>20、单例的使用场景是什么，如何实现单例？</h2><p>Tips：高性能、节省重量级操作的资源、唯一实例，手写</p><h2 id="21、如何在Java中创建线程安全的Singleton？"><a href="#21、如何在Java中创建线程安全的Singleton？" class="headerlink" title="21、如何在Java中创建线程安全的Singleton？"></a>21、如何在Java中创建线程安全的Singleton？</h2><p>Tips：注意线程安全条件下的单例写法</p><h2 id="22、synchronzied关键词的使用"><a href="#22、synchronzied关键词的使用" class="headerlink" title="22、synchronzied关键词的使用"></a>22、synchronzied关键词的使用</h2><p>Tips：悲观锁，保证线程安全。参考： <a href="https://blog.csdn.net/aa792978017/article/details/88835512" target="_blank" rel="noopener">https://blog.csdn.net/aa792978017/article/details/88835512</a></p><h2 id="23、ReentrantLock和synchronized使用的场景是什么，机制有何不同？"><a href="#23、ReentrantLock和synchronized使用的场景是什么，机制有何不同？" class="headerlink" title="23、ReentrantLock和synchronized使用的场景是什么，机制有何不同？"></a>23、ReentrantLock和synchronized使用的场景是什么，机制有何不同？</h2><p>Tips：二者都是锁， ReentrantLock基于CAS的乐观锁， synchronized是悲观锁。建议读<br>ReentrantLock源码，理解记忆。演示Counter7。</p><h2 id="24、什么是ThreadLocal变量？"><a href="#24、什么是ThreadLocal变量？" class="headerlink" title="24、什么是ThreadLocal变量？"></a>24、什么是ThreadLocal变量？</h2><p>Tips： ThreadLocal用于保存某个线程共享变量。不同线程只能从中get，set，remove自己的变量，<br>而不会影响其他线程的变量。讲解ThreadLocal的set、get、remove方法。</p><h2 id="25、ThreadLocal技术原理是什么，它在架构中常常用来做什么？"><a href="#25、ThreadLocal技术原理是什么，它在架构中常常用来做什么？" class="headerlink" title="25、ThreadLocal技术原理是什么，它在架构中常常用来做什么？"></a>25、ThreadLocal技术原理是什么，它在架构中常常用来做什么？</h2><p>tips： 读ThreadLocal ，理解ThreadLocalMap。 参考jason 16、ThreadLocal原理及在多层架构中的应<br>                                                 用</p><h2 id="26、volatile适用于高并发的什么场景？"><a href="#26、volatile适用于高并发的什么场景？" class="headerlink" title="26、volatile适用于高并发的什么场景？"></a>26、volatile适用于高并发的什么场景？</h2><p>Tips：轻量级锁，状态位。讲解服务熔断多线程ExceptionCountDegradeDemo的代码示例。</p><h2 id="27、CountDownLatch用于多线程的什么场景？"><a href="#27、CountDownLatch用于多线程的什么场景？" class="headerlink" title="27、CountDownLatch用于多线程的什么场景？"></a>27、CountDownLatch用于多线程的什么场景？</h2><p>Tips:线程计数、线程等待。建议阅读CountDownLatch，讲解Counter1示例.</p><h2 id="28、java多线程有哪些常见的锁，各自用法是什么？"><a href="#28、java多线程有哪些常见的锁，各自用法是什么？" class="headerlink" title="28、java多线程有哪些常见的锁，各自用法是什么？"></a>28、java多线程有哪些常见的锁，各自用法是什么？</h2><p>tips：至少有五种， volatile 、synchronized 、 ReentrantLock 、 Condition、 ReadWriteLock</p><h2 id="29、多线程join方法用于什么场景？"><a href="#29、多线程join方法用于什么场景？" class="headerlink" title="29、多线程join方法用于什么场景？"></a>29、多线程join方法用于什么场景？</h2><p>Tips:控制线程顺序，讲解Thread的join源码。讲解JoinTest示例</p><h2 id="30、java多线程中让所有子线程执行完毕的方法有哪几种？"><a href="#30、java多线程中让所有子线程执行完毕的方法有哪几种？" class="headerlink" title="30、java多线程中让所有子线程执行完毕的方法有哪几种？"></a>30、java多线程中让所有子线程执行完毕的方法有哪几种？</h2><p>tips：至少有两种。线程的sleep、join。</p><h2 id="31、高并发环境下的计数器如何实现？"><a href="#31、高并发环境下的计数器如何实现？" class="headerlink" title="31、高并发环境下的计数器如何实现？"></a>31、高并发环境下的计数器如何实现？</h2><p>Tips：至少有6种实现方式。讲解counter包下的代码示例。复习 CountDownLatch、AtomicInteger、<br>synchronized、ReentrantLock、线程状态。</p><h2 id="32、HashTable、HashMap、ConcurrentHashMap各自的技术原理和使用场景是什么？"><a href="#32、HashTable、HashMap、ConcurrentHashMap各自的技术原理和使用场景是什么？" class="headerlink" title="32、HashTable、HashMap、ConcurrentHashMap各自的技术原理和使用场景是什么？"></a>32、HashTable、HashMap、ConcurrentHashMap各自的技术原理和使用场景是什么？</h2><p>Tips： 建议看源码。HashTable线程安全、悲观锁，锁整个hash表的数据，效率低；ConcurrentHashMap线程<br>安全、乐观锁，分段锁； HashMap非线程安全； 可参考：<a href="https://www.cnblogs.com/zq-boke/p/8654539.html" target="_blank" rel="noopener">https://www.cnblogs.com/zq-boke/p/8654539.html</a></p><h2 id="33、LinkedBlockingQueue、ConcurrentLinkedQueue各自技术原理和使用场景是什么？"><a href="#33、LinkedBlockingQueue、ConcurrentLinkedQueue各自技术原理和使用场景是什么？" class="headerlink" title="33、LinkedBlockingQueue、ConcurrentLinkedQueue各自技术原理和使用场景是什么？"></a>33、LinkedBlockingQueue、ConcurrentLinkedQueue各自技术原理和使用场景是什么？</h2><p>Tips： 前者：阻塞队列，用于生产消费者模式； 后者：并发队列，用于高并发场景。</p><h2 id="34、-Java中如何停止一个线程？"><a href="#34、-Java中如何停止一个线程？" class="headerlink" title="34、 Java中如何停止一个线程？"></a>34、 Java中如何停止一个线程？</h2><p>Tips：stop（不推荐）、状态位、interrupt。讲解ThreadStop1、 ThreadStop2。</p><h2 id="35、Java中Semaphore是什么？"><a href="#35、Java中Semaphore是什么？" class="headerlink" title="35、Java中Semaphore是什么？"></a>35、Java中Semaphore是什么？</h2><p>Tips：信号量，用于访问限制可以访问某些资源（物理或逻辑的）线程数目。讲解SemaphoreTest。</p><h2 id="36、java多线程中有哪些并发流量控制工具类？"><a href="#36、java多线程中有哪些并发流量控制工具类？" class="headerlink" title="36、java多线程中有哪些并发流量控制工具类？"></a>36、java多线程中有哪些并发流量控制工具类？</h2><p>tips：至少有三种。 CountDownLatch、Semaphore 、CyclicBarrier</p><h2 id="37、高并发场景下，如何理解每一个线程执行的逻辑耗时不能过长？"><a href="#37、高并发场景下，如何理解每一个线程执行的逻辑耗时不能过长？" class="headerlink" title="37、高并发场景下，如何理解每一个线程执行的逻辑耗时不能过长？"></a>37、高并发场景下，如何理解每一个线程执行的逻辑耗时不能过长？</h2><p>Tips：如果每一个线程执行的逻辑耗时过长，会导致大量线程阻塞，性能急剧下降，系统可用性<br>存在风险，存在宕机的可能性。</p><h2 id="38、什么是线程非安全？"><a href="#38、什么是线程非安全？" class="headerlink" title="38、什么是线程非安全？"></a>38、什么是线程非安全？</h2><p>Tips：不提供数据访问保护，多个线程写数据造成所得到的数据是脏数据。</p><h2 id="39、在微服务的分布式架构中，设置服务的超时时间有什么好处？"><a href="#39、在微服务的分布式架构中，设置服务的超时时间有什么好处？" class="headerlink" title="39、在微服务的分布式架构中，设置服务的超时时间有什么好处？"></a>39、在微服务的分布式架构中，设置服务的超时时间有什么好处？</h2><p>Tips：防止大量线程阻塞导致系统宕机。</p><h2 id="40、常见的多线程数据结构有哪些，你用过其中的哪些多线程数据结构？"><a href="#40、常见的多线程数据结构有哪些，你用过其中的哪些多线程数据结构？" class="headerlink" title="40、常见的多线程数据结构有哪些，你用过其中的哪些多线程数据结构？"></a>40、常见的多线程数据结构有哪些，你用过其中的哪些多线程数据结构？</h2><p>tips：建议多读concurrent包下的源码。 ConcurrentHashMap、LinkedBlockingQueue、<br>ConcurrentLinkedQueue、Semaphore等</p><h2 id="41、多线程的常见设计模式，你用过其中的哪些设计模式"><a href="#41、多线程的常见设计模式，你用过其中的哪些设计模式" class="headerlink" title="41、多线程的常见设计模式，你用过其中的哪些设计模式"></a>41、多线程的常见设计模式，你用过其中的哪些设计模式</h2><p>tips：掌握三种最常见的多线程设计模式。</p><h2 id="42、什么是Master-Worker模式？如何实现Master-Worker模式？"><a href="#42、什么是Master-Worker模式？如何实现Master-Worker模式？" class="headerlink" title="42、什么是Master-Worker模式？如何实现Master-Worker模式？"></a>42、什么是Master-Worker模式？如何实现Master-Worker模式？</h2><p>Tips：大任务的并发分解、结果合并。掌握Master-Worker 设计模式原理图。讲解PlusWorker、<br>Master相关代码。</p><h2 id="43、什么是Producer-Consumer模式？如何实现Producer-Consumer模式？"><a href="#43、什么是Producer-Consumer模式？如何实现Producer-Consumer模式？" class="headerlink" title="43、什么是Producer-Consumer模式？如何实现Producer-Consumer模式？"></a>43、什么是Producer-Consumer模式？如何实现Producer-Consumer模式？</h2><p>Tips：利用缓冲区对生产者、消费者解耦。掌握生产消费者原理图。讲解Producer、 Consumer</p><h2 id="44、什么是Future模式？如何实现Future模式？"><a href="#44、什么是Future模式？如何实现Future模式？" class="headerlink" title="44、什么是Future模式？如何实现Future模式？"></a>44、什么是Future模式？如何实现Future模式？</h2><p>Tips：适合异步耗时的场景。阅读并掌握Excutors、ExecutorService、FutureTask。</p><h2 id="45、多线程使用场景是什么？"><a href="#45、多线程使用场景是什么？" class="headerlink" title="45、多线程使用场景是什么？"></a>45、多线程使用场景是什么？</h2><p>Tips：并发场景、”小逻辑”、性能提升。</p><h2 id="46、多线程有什么优缺点？"><a href="#46、多线程有什么优缺点？" class="headerlink" title="46、多线程有什么优缺点？"></a>46、多线程有什么优缺点？</h2><p>Tips：优点：提升性能；缺点：门槛高，特别是锁，滥用线程会产生死锁、影响性能甚至宕机，<br>线程切换耗性能；</p><h2 id="47、假设某系统的某个接口的峰值TPS为2w-s-其它接口的并发峰值至多为200每秒-，且该接口会"><a href="#47、假设某系统的某个接口的峰值TPS为2w-s-其它接口的并发峰值至多为200每秒-，且该接口会" class="headerlink" title="47、假设某系统的某个接口的峰值TPS为2w/s(其它接口的并发峰值至多为200每秒)，且该接口会"></a>47、假设某系统的某个接口的峰值TPS为2w/s(其它接口的并发峰值至多为200每秒)，且该接口会</h2><p>保存数据至数据库，如何提升该接口的性能？<br>Tips：线程池、多线程、分页、批处理。讲解thunder中间件的ThunderEngine源码。</p><h2 id="48、是否熟悉java-concurrent包的内容，请讲讲concurrent包有哪些重要的内容？"><a href="#48、是否熟悉java-concurrent包的内容，请讲讲concurrent包有哪些重要的内容？" class="headerlink" title="48、是否熟悉java concurrent包的内容，请讲讲concurrent包有哪些重要的内容？"></a>48、是否熟悉java concurrent包的内容，请讲讲concurrent包有哪些重要的内容？</h2><p>Tips：建议多阅读java concurrent包的内容。</p><h2 id="49、请讲讲并发编程的CAS理论"><a href="#49、请讲讲并发编程的CAS理论" class="headerlink" title="49、请讲讲并发编程的CAS理论"></a>49、请讲讲并发编程的CAS理论</h2><p>tips： Compare And Swap、乐观锁机制、jdk的Unsafe类执行这些操作、Doug Lea、 concurrent 包<br>的重要理论基石。</p><h2 id="50、请讲讲并发队列和阻塞队列"><a href="#50、请讲讲并发队列和阻塞队列" class="headerlink" title="50、请讲讲并发队列和阻塞队列"></a>50、请讲讲并发队列和阻塞队列</h2><p>tips： ConcurrentLinkedQueue、 LinkedBlockingQueue。掌握原理。</p><h2 id="51、多线程yield方法使用于什么场景？"><a href="#51、多线程yield方法使用于什么场景？" class="headerlink" title="51、多线程yield方法使用于什么场景？"></a>51、多线程yield方法使用于什么场景？</h2><p>Tips： yield：让步，线程等待。</p><h2 id="52、请讲讲线程异步处理的原理及关键组件？"><a href="#52、请讲讲线程异步处理的原理及关键组件？" class="headerlink" title="52、请讲讲线程异步处理的原理及关键组件？"></a>52、请讲讲线程异步处理的原理及关键组件？</h2><p>Tips：异步耗时的操作。读源码并掌握Excutors、ExecutorService、FutureTask。</p><h2 id="53、在实际项目（产品）研发过程中，你是否有使用过多线程，和线程池，如果有，请举例说明"><a href="#53、在实际项目（产品）研发过程中，你是否有使用过多线程，和线程池，如果有，请举例说明" class="headerlink" title="53、在实际项目（产品）研发过程中，你是否有使用过多线程，和线程池，如果有，请举例说明"></a>53、在实际项目（产品）研发过程中，你是否有使用过多线程，和线程池，如果有，请举例说明</h2><p>Tips：通用常见的技术场景：批量数据的处理。建议用STAR模型回答。</p><h2 id="54、什么是多线程的原子操作？"><a href="#54、什么是多线程的原子操作？" class="headerlink" title="54、什么是多线程的原子操作？"></a>54、什么是多线程的原子操作？</h2><p>Tips：基于cas的最基本的操作。阅读AtomicInteger的代码头说明并讲解AtomicInteger的CAS机制。</p><h2 id="55、Java-中有哪些原子操作？"><a href="#55、Java-中有哪些原子操作？" class="headerlink" title="55、Java 中有哪些原子操作？"></a>55、Java 中有哪些原子操作？</h2><p>Tips： AtomicInteger、 AtomicLong、AtomicBoolean、 AtomicIntegerArray等等</p><h2 id="56、多线程原子操作类使用场景是什么，你在项目的实际研发过程中是否有使用"><a href="#56、多线程原子操作类使用场景是什么，你在项目的实际研发过程中是否有使用" class="headerlink" title="56、多线程原子操作类使用场景是什么，你在项目的实际研发过程中是否有使用"></a>56、多线程原子操作类使用场景是什么，你在项目的实际研发过程中是否有使用</h2><p>过原子操作类？<br>Tips：并发计数，比如：微服务场景下的服务监控的统计。</p><h2 id="57、如何在多个线程间共享数据？"><a href="#57、如何在多个线程间共享数据？" class="headerlink" title="57、如何在多个线程间共享数据？"></a>57、如何在多个线程间共享数据？</h2><p>Tips：多个线程之间传参，共享变量；或者内部类；运行MultyThreadShareDateTest。</p><h2 id="58、线程的状态有哪些，线程状态的使用场景是什么？"><a href="#58、线程的状态有哪些，线程状态的使用场景是什么？" class="headerlink" title="58、线程的状态有哪些，线程状态的使用场景是什么？"></a>58、线程的状态有哪些，线程状态的使用场景是什么？</h2><p>Tips：建议阅读Thread类及其内部类State。讲解woker-master的Master类</p><h2 id="59、有多个线程T1，T2，T3，怎么确保它们按顺序执行？"><a href="#59、有多个线程T1，T2，T3，怎么确保它们按顺序执行？" class="headerlink" title="59、有多个线程T1，T2，T3，怎么确保它们按顺序执行？"></a>59、有多个线程T1，T2，T3，怎么确保它们按顺序执行？</h2><p>tips：参考JoinTest</p><h2 id="60、wait-notify-notifyAll一般使用于什么场景？"><a href="#60、wait-notify-notifyAll一般使用于什么场景？" class="headerlink" title="60、wait/notify/notifyAll一般使用于什么场景？"></a>60、wait/notify/notifyAll一般使用于什么场景？</h2><p>Tips：悲观锁，和synchronize关键字联合使用，不建议使用，编程复杂。</p><h1 id="JVM复习题"><a href="#JVM复习题" class="headerlink" title="JVM复习题"></a>JVM复习题</h1><h2 id="1、请说说jvm的基本结构"><a href="#1、请说说jvm的基本结构" class="headerlink" title="1、请说说jvm的基本结构"></a>1、请说说jvm的基本结构</h2><p>Tips：建议掌握jvm的基本结构图。java类加载器、方法区、堆、直接内存、java栈、本地方法栈、<br>PC寄存器、执行引擎。参考jason的JVM基础知识及性能调优.ppt。 </p><h2 id="2、什么是JVM-？"><a href="#2、什么是JVM-？" class="headerlink" title="2、什么是JVM ？"></a>2、什么是JVM ？</h2><p>Tips：Java Virtual Machine。Java应用和操作系统之间的桥梁。</p><h2 id="3、堆空间的结构"><a href="#3、堆空间的结构" class="headerlink" title="3、堆空间的结构"></a>3、堆空间的结构</h2><p>Tips:Eden、S0、S1、tenured(Old Gerneration)。记忆技巧：按照时间来分。参考jason的JVM基础<br>知识及性能调优.ppt。 </p><h2 id="4、Java中堆和栈有什么区别？"><a href="#4、Java中堆和栈有什么区别？" class="headerlink" title="4、Java中堆和栈有什么区别？"></a>4、Java中堆和栈有什么区别？</h2><p>Tips：堆主要用于管理对象，栈主要用来管理方法区相关的局部变量。参考：<br><a href="https://www.cnblogs.com/ibelieve618/p/6380328.html" target="_blank" rel="noopener">https://www.cnblogs.com/ibelieve618/p/6380328.html</a></p><h2 id="5、为何新生代要设置两个survivor区，jvm的设计上有何目的？"><a href="#5、为何新生代要设置两个survivor区，jvm的设计上有何目的？" class="headerlink" title="5、为何新生代要设置两个survivor区，jvm的设计上有何目的？"></a>5、为何新生代要设置两个survivor区，jvm的设计上有何目的？</h2><p>Tips:复制算法</p><h2 id="6、垃圾回收中的复制算法适用于在什么场景下使用？"><a href="#6、垃圾回收中的复制算法适用于在什么场景下使用？" class="headerlink" title="6、垃圾回收中的复制算法适用于在什么场景下使用？"></a>6、垃圾回收中的复制算法适用于在什么场景下使用？</h2><p>Tips:年轻代的垃圾回收。参考jason的JVM基础知识及性能调优.ppt。 </p><h2 id="7、老年代的垃圾回收一般用什么算法？"><a href="#7、老年代的垃圾回收一般用什么算法？" class="headerlink" title="7、老年代的垃圾回收一般用什么算法？"></a>7、老年代的垃圾回收一般用什么算法？</h2><p>Tips:标记清除算法、标记压缩算法。参考jason的JVM基础知识及性能调优.ppt。 </p><h2 id="8、-java方法栈和本地方法栈的区别？"><a href="#8、-java方法栈和本地方法栈的区别？" class="headerlink" title="8、 java方法栈和本地方法栈的区别？"></a>8、 java方法栈和本地方法栈的区别？</h2><p>Tips: 前者是java方法的调用，后者是java调用native方法，比如操作系统、dll等相关的c语<br>言的方法。</p><h2 id="9、GC回收机制？"><a href="#9、GC回收机制？" class="headerlink" title="9、GC回收机制？"></a>9、GC回收机制？</h2><p>Tips:垃圾回收算法、垃圾收集器。</p><h2 id="10、top、jmap、jstat、jstack命令各自有什么用途？"><a href="#10、top、jmap、jstat、jstack命令各自有什么用途？" class="headerlink" title="10、top、jmap、jstat、jstack命令各自有什么用途？"></a>10、top、jmap、jstat、jstack命令各自有什么用途？</h2><p>Tips:top系统整体资源使用情况，jmap导出堆到文件，jstat查看jvm运行情况，jstack导出 线程堆栈到文件。</p><h2 id="11、有哪些常见的jvm命令，说说各自的用途是什么？"><a href="#11、有哪些常见的jvm命令，说说各自的用途是什么？" class="headerlink" title="11、有哪些常见的jvm命令，说说各自的用途是什么？"></a>11、有哪些常见的jvm命令，说说各自的用途是什么？</h2><p>Tips:掌握jstat、jmap、jstack、jinfo等jvm命令。</p><h2 id="12、GC有哪些算法。"><a href="#12、GC有哪些算法。" class="headerlink" title="12、GC有哪些算法。"></a>12、GC有哪些算法。</h2><p>Tips:复制算法、标记算法、标记压缩算法、分代算法。</p><h2 id="13、什么是线程中断。"><a href="#13、什么是线程中断。" class="headerlink" title="13、什么是线程中断。"></a>13、什么是线程中断。</h2><p>Tips: stop the world，简称STW，垃圾回收的停顿，参考 billy 1.GC算法与种类</p><h2 id="14、MGC、FGC分别是什么意思，它们在什么情况下会发生？"><a href="#14、MGC、FGC分别是什么意思，它们在什么情况下会发生？" class="headerlink" title="14、MGC、FGC分别是什么意思，它们在什么情况下会发生？"></a>14、MGC、FGC分别是什么意思，它们在什么情况下会发生？</h2><p>Tips：年轻代垃圾回收、老年代垃圾回收。参考jason JVM基础知识及性能调优</p><h2 id="15、请讲讲jvm的分代，为什么要分代，jvm分代有什么好处？"><a href="#15、请讲讲jvm的分代，为什么要分代，jvm分代有什么好处？" class="headerlink" title="15、请讲讲jvm的分代，为什么要分代，jvm分代有什么好处？"></a>15、请讲讲jvm的分代，为什么要分代，jvm分代有什么好处？</h2><p>Tips：根据对象的实际情况采用不同的分代。掌握分代的临界值变量。参考jason<br>JVM基础知识及性能调优.PPT</p><h2 id="16、你知道哪些jvm调优工具么？"><a href="#16、你知道哪些jvm调优工具么？" class="headerlink" title="16、你知道哪些jvm调优工具么？"></a>16、你知道哪些jvm调优工具么？</h2><p>Tips：VisualVM、Jconsole、MAT。参考性能监控工具.ppt</p><h2 id="17、在jvm中，年轻代如何向老年代转变的，转换的重要参数是什么"><a href="#17、在jvm中，年轻代如何向老年代转变的，转换的重要参数是什么" class="headerlink" title="17、在jvm中，年轻代如何向老年代转变的，转换的重要参数是什么?"></a>17、在jvm中，年轻代如何向老年代转变的，转换的重要参数是什么?</h2><p>Tips：年龄累加、 MaxTenuringThreshold。参考jason JVM基础知识及性能调优.PPT</p><h2 id="18、直接内存使用场景是什么，使用直接内存可能会存在什么问题？"><a href="#18、直接内存使用场景是什么，使用直接内存可能会存在什么问题？" class="headerlink" title="18、直接内存使用场景是什么，使用直接内存可能会存在什么问题？"></a>18、直接内存使用场景是什么，使用直接内存可能会存在什么问题？</h2><p>Tips：java原生、netty、mina等相关的NIO操作。参考jason JVM基础知识及性能调优.PPT</p><h2 id="19、堆内存有哪些重要参数？"><a href="#19、堆内存有哪些重要参数？" class="headerlink" title="19、堆内存有哪些重要参数？"></a>19、堆内存有哪些重要参数？</h2><p>Tips: -Xms(初始堆大小)、 -Xmx(最大堆大小)</p><h2 id="20、如何设置堆大小，是否有一些经验值？"><a href="#20、如何设置堆大小，是否有一些经验值？" class="headerlink" title="20、如何设置堆大小，是否有一些经验值？"></a>20、如何设置堆大小，是否有一些经验值？</h2><p>Tips:堆内存至少可以设置为整个内存的一半大小，甚至2/3大小。</p><h2 id="21、如何打印JVM日志？"><a href="#21、如何打印JVM日志？" class="headerlink" title="21、如何打印JVM日志？"></a>21、如何打印JVM日志？</h2><p>Tips: -XX:+PrintGC、-XX:+PrintGCDetails、-XX:+PrintGCTimeStamps、-XX:+PrintGCDateStamps。演示<br>DirectBufferOOM</p><h2 id="22、请介绍常见的jvm参数"><a href="#22、请介绍常见的jvm参数" class="headerlink" title="22、请介绍常见的jvm参数"></a>22、请介绍常见的jvm参数</h2><p>Tips：堆内存参数、年轻代参数、日志参数、直接内存参数等等。参考jason JVM基础知识及性能<br>调优.PPT </p><h2 id="23、CMS收集器有什么特点？"><a href="#23、CMS收集器有什么特点？" class="headerlink" title="23、CMS收集器有什么特点？"></a>23、CMS收集器有什么特点？</h2><p>Tips:老年代、并发收集、低停顿。</p><h2 id="24、G1收集器有什么特点？"><a href="#24、G1收集器有什么特点？" class="headerlink" title="24、G1收集器有什么特点？"></a>24、G1收集器有什么特点？</h2><p>Tips:年轻代和老年代，最新的垃圾回收算法，较综合。</p><h2 id="25、垃圾回收器有哪些？"><a href="#25、垃圾回收器有哪些？" class="headerlink" title="25、垃圾回收器有哪些？"></a>25、垃圾回收器有哪些？</h2><p>Tips: Serial、Parallel 、CMS、G1。参考jason JVM基础知识及性能调优.PPT</p><h2 id="26、java内存模型"><a href="#26、java内存模型" class="headerlink" title="26、java内存模型"></a>26、java内存模型</h2><p>Tips:多个线程通信、同步、happens-before原则(volatile、join)。参考：<br><a href="https://www.cnblogs.com/yuanfy008/p/9252555.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanfy008/p/9252555.html</a></p><h2 id="27、什么是类加载器，类加载器有哪些，类加载器的加载顺序是什么？"><a href="#27、什么是类加载器，类加载器有哪些，类加载器的加载顺序是什么？" class="headerlink" title="27、什么是类加载器，类加载器有哪些，类加载器的加载顺序是什么？"></a>27、什么是类加载器，类加载器有哪些，类加载器的加载顺序是什么？</h2><p>Tips：将类的.class文件中的二进制数据读入到内存。三种类加载器：BootstrapClassLoader-&gt;ExtClassLoader-&gt;<br>AppClassLoader ，演示ClassLoaderTest，熟悉rt.jar的Launcher、Classloader。参考：<br><a href="https://www.cnblogs.com/heyanan/p/6123279.html" target="_blank" rel="noopener">https://www.cnblogs.com/heyanan/p/6123279.html</a></p><h2 id="28、简述java内存分配与回收策略"><a href="#28、简述java内存分配与回收策略" class="headerlink" title="28、简述java内存分配与回收策略"></a>28、简述java内存分配与回收策略</h2><p>Tips：年轻代，老年代，小对象，大对象。 参考：<a href="https://segmentfault.com/a/1190000014944731" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014944731</a></p><h2 id="29、Perm-Space中保存什么数据？会引起OutOfMemory吗？"><a href="#29、Perm-Space中保存什么数据？会引起OutOfMemory吗？" class="headerlink" title="29、Perm Space中保存什么数据？会引起OutOfMemory吗？"></a>29、Perm Space中保存什么数据？会引起OutOfMemory吗？</h2><p>Tips:类加载数据。永久代内存过小，会导致OOM。</p><h2 id="30、是否有做过jvm参数方面的调优，如果有，请举例说明。"><a href="#30、是否有做过jvm参数方面的调优，如果有，请举例说明。" class="headerlink" title="30、是否有做过jvm参数方面的调优，如果有，请举例说明。"></a>30、是否有做过jvm参数方面的调优，如果有，请举例说明。</h2><p>Tips：最好用star面试模型。设置堆内存参数、直接内存参数、eclipse、tomcat的相关的jvm参数等等。</p><h2 id="31、内存溢出的根本原因是什么，该如何解决？"><a href="#31、内存溢出的根本原因是什么，该如何解决？" class="headerlink" title="31、内存溢出的根本原因是什么，该如何解决？"></a>31、内存溢出的根本原因是什么，该如何解决？</h2><p>Tips:jvm的相关资源不够用，导致内存溢出。解决程序错误、调整参数、分布式架构(大数据、微服务架构，<br>本质都是多台机器分布式计算或者处理相关程序逻辑)。</p><h2 id="32、简述java类加载机制"><a href="#32、简述java类加载机制" class="headerlink" title="32、简述java类加载机制"></a>32、简述java类加载机制</h2><p>Tips：熟悉Launcher 、ClassLoader源码理解记忆。</p><h2 id="33、GC收集器有哪些？CMS收集器与G1收集器的特点"><a href="#33、GC收集器有哪些？CMS收集器与G1收集器的特点" class="headerlink" title="33、GC收集器有哪些？CMS收集器与G1收集器的特点"></a>33、GC收集器有哪些？CMS收集器与G1收集器的特点</h2><p>Tips:从内存年代、回收算法、线程数等角度整体理解记忆。参考：<br><a href="https://blog.csdn.net/qq_35503221/article/details/80313129" target="_blank" rel="noopener">https://blog.csdn.net/qq_35503221/article/details/80313129</a></p><h2 id="34、类加载器双亲委派模型机制是什么？"><a href="#34、类加载器双亲委派模型机制是什么？" class="headerlink" title="34、类加载器双亲委派模型机制是什么？"></a>34、类加载器双亲委派模型机制是什么？</h2><p>Tips：熟悉ClassLoader的loadClass() 。 参考：<a href="https://blog.csdn.net/weixin_38118016/article/details/79579657" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38118016/article/details/79579657</a></p><h2 id="35、什么情况下会出现永久代内存溢出，如何解决此类问题？"><a href="#35、什么情况下会出现永久代内存溢出，如何解决此类问题？" class="headerlink" title="35、什么情况下会出现永久代内存溢出，如何解决此类问题？"></a>35、什么情况下会出现永久代内存溢出，如何解决此类问题？</h2><p>Tips: jar包过多、加载大量class文件，永久代内存参数过小。增加JVM的PermSize和MaxPermSize参数大小。<br>演示PermTest、PermTest2、 PermTest3。</p><h2 id="36、什么情况下会出现堆内存溢出，如何解决此类问题？"><a href="#36、什么情况下会出现堆内存溢出，如何解决此类问题？" class="headerlink" title="36、什么情况下会出现堆内存溢出，如何解决此类问题？"></a>36、什么情况下会出现堆内存溢出，如何解决此类问题？</h2><p>Tips:参考jason JVM基础知识及性能调优.PPT。演示 HeapOOMTest。</p><h2 id="37、什么情况下会出现直接内存溢出，如何解决此类问题？"><a href="#37、什么情况下会出现直接内存溢出，如何解决此类问题？" class="headerlink" title="37、什么情况下会出现直接内存溢出，如何解决此类问题？"></a>37、什么情况下会出现直接内存溢出，如何解决此类问题？</h2><p>Tips:参考jason JVM基础知识及性能调优.PPT。演示 DirectBufferOOM 。</p><h2 id="38、什么情况下会出现过多线程导致内存溢出的问题，如何解决此类问题？"><a href="#38、什么情况下会出现过多线程导致内存溢出的问题，如何解决此类问题？" class="headerlink" title="38、什么情况下会出现过多线程导致内存溢出的问题，如何解决此类问题？"></a>38、什么情况下会出现过多线程导致内存溢出的问题，如何解决此类问题？</h2><p>Tips:参考jason JVM基础知识及性能调优.PPT。</p><h2 id="39、什么情况下会出现CPU使用率过高的问题，如何解决此类问题？"><a href="#39、什么情况下会出现CPU使用率过高的问题，如何解决此类问题？" class="headerlink" title="39、什么情况下会出现CPU使用率过高的问题，如何解决此类问题？"></a>39、什么情况下会出现CPU使用率过高的问题，如何解决此类问题？</h2><p>Tips:参考jason JVM基础知识及性能调优.PPT。</p><h2 id="40、OOM有哪些可能，应该如何处理。"><a href="#40、OOM有哪些可能，应该如何处理。" class="headerlink" title="40、OOM有哪些可能，应该如何处理。"></a>40、OOM有哪些可能，应该如何处理。</h2><p>Tips：该问题比较综合，参考Jason JVM基础知识及性能调优.PPT</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h1&gt;&lt;h2 id=&quot;1、如何在Java中实现线程？&quot;&gt;&lt;a href=&quot;#1、如何在Java中实现线程？&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="java" scheme="http://iwantjingjing.com/categories/java/"/>
    
    
      <category term="多线程，JVM" scheme="http://iwantjingjing.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8CJVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾收集器</title>
    <link href="http://iwantjingjing.com/2020/05/31/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://iwantjingjing.com/2020/05/31/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2020-05-31T09:39:55.000Z</published>
    <updated>2020-05-31T09:41:10.646Z</updated>
    
    <content type="html"><![CDATA[<p><img src="JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="千字不如一图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png&quot; alt=&quot;千字不如一图&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="JVM" scheme="http://iwantjingjing.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://iwantjingjing.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收算法与回收机制</title>
    <link href="http://iwantjingjing.com/2020/05/31/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://iwantjingjing.com/2020/05/31/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2020-05-31T08:15:56.000Z</published>
    <updated>2020-05-31T08:16:58.239Z</updated>
    
    <content type="html"><![CDATA[<p><img src="JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.png" alt="千字不如一图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.png&quot; alt=&quot;千字不如一
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://iwantjingjing.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://iwantjingjing.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java的类加载机制</title>
    <link href="http://iwantjingjing.com/2020/05/31/Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://iwantjingjing.com/2020/05/31/Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</id>
    <published>2020-05-31T07:08:54.000Z</published>
    <updated>2020-05-31T07:10:08.778Z</updated>
    
    <content type="html"><![CDATA[<p><img src="java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.png" alt="千字不如一图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.png&quot; alt=&quot;千字不如一图&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="java" scheme="http://iwantjingjing.com/categories/java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM调优</title>
    <link href="http://iwantjingjing.com/2020/05/30/JVM%E8%B0%83%E4%BC%98/"/>
    <id>http://iwantjingjing.com/2020/05/30/JVM%E8%B0%83%E4%BC%98/</id>
    <published>2020-05-30T13:00:46.000Z</published>
    <updated>2020-05-30T13:02:43.204Z</updated>
    
    <content type="html"><![CDATA[<p><img src="JVM%E8%B0%83%E4%BC%98.png" alt="千字不如一图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;JVM%E8%B0%83%E4%BC%98.png&quot; alt=&quot;千字不如一图&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="JVM" scheme="http://iwantjingjing.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://iwantjingjing.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存模型</title>
    <link href="http://iwantjingjing.com/2020/05/29/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://iwantjingjing.com/2020/05/29/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-05-29T04:48:34.000Z</published>
    <updated>2020-05-29T05:10:18.128Z</updated>
    
    <content type="html"><![CDATA[<p><img src="JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="千字不如一图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png&quot; alt=&quot;千字不如一图&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="JVM" scheme="http://iwantjingjing.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://iwantjingjing.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>自旋锁、排队自旋锁、MCS锁、CLH锁</title>
    <link href="http://iwantjingjing.com/2020/05/28/%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E6%8E%92%E9%98%9F%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81MCS%E9%94%81%E3%80%81CLH%E9%94%81/"/>
    <id>http://iwantjingjing.com/2020/05/28/%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E6%8E%92%E9%98%9F%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81MCS%E9%94%81%E3%80%81CLH%E9%94%81/</id>
    <published>2020-05-28T12:50:24.000Z</published>
    <updated>2020-05-28T13:53:12.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p>当锁被其他线程占用时，自己不断的循环检测锁是否释放，不改变线程状态<br>（即不挂起线程或睡眠状态），需占用CPU资源，适用于临界区很小的情况。<br>若线程竞争激烈，则会消耗大量CPU资源，不适用于自旋锁。</p><h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>线程的状态改变是很消耗CPU资源的，所以有了不改变线程状态的自旋锁。<br>适用于锁竞争不是很激烈的情况</p><h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><p>talk is cheap show me the code</p><pre><code>import java.util.concurrent.atomic.AtomicReference;public class SpinLock {   private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;Thread&gt;();   public void lock() {       Thread currentThread = Thread.currentThread();              // 如果锁未被占用，则设置当前线程为锁的拥有者       while (!owner.compareAndSet(null, currentThread)) {       }   }   public void unlock() {       Thread currentThread = Thread.currentThread();              // 只有锁的拥有者才能释放锁       owner.compareAndSet(currentThread, null);   }</code></pre><p>SimpleSpinLock里有一个owner属性持有锁当前拥有者的线程的引用，如果该引用为null，则表示锁未被占用，不为null则被占用。</p><p>这里用AtomicReference是为了使用它的原子性的compareAndSet方法（CAS操作），解决了多线程并发操作导致数据不一致的问题，确保其他线程可以看到锁的真实状态。</p><p>缺点<br>CAS操作需要硬件的配合；<br>保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；<br>没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。       </p><h1 id="排队自旋锁（Ticket-Lock）"><a href="#排队自旋锁（Ticket-Lock）" class="headerlink" title="排队自旋锁（Ticket Lock）"></a>排队自旋锁（Ticket Lock）</h1><h1 id="what-1"><a href="#what-1" class="headerlink" title="what"></a>what</h1><h1 id="why-1"><a href="#why-1" class="headerlink" title="why"></a>why</h1><h1 id="how-1"><a href="#how-1" class="headerlink" title="how"></a>how</h1><h1 id="MCS锁"><a href="#MCS锁" class="headerlink" title="MCS锁"></a>MCS锁</h1><h1 id="what-2"><a href="#what-2" class="headerlink" title="what"></a>what</h1><h1 id="why-2"><a href="#why-2" class="headerlink" title="why"></a>why</h1><h1 id="how-2"><a href="#how-2" class="headerlink" title="how"></a>how</h1><h1 id="CLH锁"><a href="#CLH锁" class="headerlink" title="CLH锁"></a>CLH锁</h1><h1 id="what-3"><a href="#what-3" class="headerlink" title="what"></a>what</h1><h1 id="why-3"><a href="#why-3" class="headerlink" title="why"></a>why</h1><h1 id="how-3"><a href="#how-3" class="headerlink" title="how"></a>how</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自旋锁&quot;&gt;&lt;a href=&quot;#自旋锁&quot; class=&quot;headerlink&quot; title=&quot;自旋锁&quot;&gt;&lt;/a&gt;自旋锁&lt;/h1&gt;&lt;h1 id=&quot;what&quot;&gt;&lt;a href=&quot;#what&quot; class=&quot;headerlink&quot; title=&quot;what&quot;&gt;&lt;/a&gt;wha
      
    
    </summary>
    
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="锁" scheme="http://iwantjingjing.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>钝感力</title>
    <link href="http://iwantjingjing.com/2020/05/14/%E9%92%9D%E6%84%9F%E5%8A%9B/"/>
    <id>http://iwantjingjing.com/2020/05/14/%E9%92%9D%E6%84%9F%E5%8A%9B/</id>
    <published>2020-05-14T08:45:35.000Z</published>
    <updated>2020-05-14T09:13:27.431Z</updated>
    
    <content type="html"><![CDATA[<p>14：46分读完了钝感力这本书。有以下收货：</p><ul><li><p>1、我发现自己读pdf文件1小时大概能读1M（本书有3M，我读完大概花了3个小时）</p></li><li><p>2、所谓钝感力感觉还是要让自己看问题大度些：别把什么都看得太执着。</p></li></ul><p>作者是日本人渡边淳一。间接从一个侧面反映了日本的民族性格。想来一个美国人可能写不出这样的书。作者阐释了<br>啥是钝感力，从心理以及生理上。虽然其举的一些例字不敢苟同，但整体读下来还是挺值得一读的。钝感力可能不能让你立马富有或者啥的，但<br>肯定能让你比之前生活的更幸福。钝感力不是让你一味的忍，而是不要太在意，一些可有可无的小矛盾，能忽略就忽略。<br>钝感力可以让你有更好的适应能力。人最牛逼的能力就是在哪儿都能适应的能力。<br>钝感力不是为了别人，而是真的能让自己活的更好，身体上，心理上都是。</p><p>想来我是一个相对敏感的人，钝感力是一种能力，自己还是要努力锻炼这种能力！</p><h1 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h1><p>宽以待人，豁达处事（金刚经讲就是：应无所住而生其心）</p><h1 id="为什么要有钝感力"><a href="#为什么要有钝感力" class="headerlink" title="为什么要有钝感力"></a>为什么要有钝感力</h1><p> 1 人是社会性动物，而人际关系是第一生产力，有利于人际关系，也就是有利于生产力的发展。</p><p> 2 有利于血液循环</p><p> 3 有利于适应能力提高</p><p> 4 有利于身体健康</p><p> 5 有利于睡眠</p><h1 id="怎样做"><a href="#怎样做" class="headerlink" title="怎样做"></a>怎样做</h1><p>别太把别人说的当回事儿，遇事儿别往心里搁，该吃吃，该喝喝。吃好喝好比啥都重要。没事儿看看鬼畜也挺好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;14：46分读完了钝感力这本书。有以下收货：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1、我发现自己读pdf文件1小时大概能读1M（本书有3M，我读完大概花了3个小时）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2、所谓钝感力感觉还是要让自己看问题大度些：别把什么都看得太执着。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="读书" scheme="http://iwantjingjing.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读后感" scheme="http://iwantjingjing.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>如何设计一个秒杀系统</title>
    <link href="http://iwantjingjing.com/2020/05/11/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/"/>
    <id>http://iwantjingjing.com/2020/05/11/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-05-11T15:20:55.000Z</published>
    <updated>2020-05-11T16:02:44.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高并发系统的几大方向"><a href="#高并发系统的几大方向" class="headerlink" title="高并发系统的几大方向"></a>高并发系统的几大方向</h1><p>1.请求数据尽量少，从而减少cpu消耗</p><p>2.访问路径尽量短，减少节点消耗</p><p>3.强依赖尽量少，减少加载时间</p><p>4.不要有单点，要有备份</p><p>5.减少额外请求，减少加载时间</p><pre><code>设计技巧10w级别可能瓶颈就在数据读取上，通过增加缓存一般就能解决100w那么，可能服务端的网络可能都是瓶颈，所以要把大部分的静态数据放到cdn上甚至缓存在浏览器里</code></pre><h1 id="数据的动静分离"><a href="#数据的动静分离" class="headerlink" title="数据的动静分离"></a>数据的动静分离</h1><h2 id="静态数据做缓存"><a href="#静态数据做缓存" class="headerlink" title="静态数据做缓存"></a>静态数据做缓存</h2><pre><code>第一，你应该把静态数据缓存到离用户最近的地方第二，静态化改造就是要直接缓存 HTTP 连接</code></pre><h2 id="5-个方面来分离出动态内容"><a href="#5-个方面来分离出动态内容" class="headerlink" title="5 个方面来分离出动态内容"></a>5 个方面来分离出动态内容</h2><pre><code>URL 唯一化分离浏览者相关的因素分离时间因素异步化地域因素去掉 Cookie</code></pre><h2 id="动态内容的处理通常有两种方案：ESI（Edge-Side-Includes）方案和-CSI（Client-Side-Include）方案。"><a href="#动态内容的处理通常有两种方案：ESI（Edge-Side-Includes）方案和-CSI（Client-Side-Include）方案。" class="headerlink" title="动态内容的处理通常有两种方案：ESI（Edge Side Includes）方案和 CSI（Client Side Include）方案。"></a>动态内容的处理通常有两种方案：ESI（Edge Side Includes）方案和 CSI（Client Side Include）方案。</h2><ul><li><p>ESI 方案（或者 SSI）：即在 Web 代理服务器上做动态内容请求，并将请求插入到静态页面中，当用户拿到页面时已经是一个完整的页面了。这种方式对服务端性能有些影响，但是用户体验较好</p></li><li><p>CSI 方案。即单独发起一个异步 JavaScript 请求，以向服务端获取动态内容。这种方式服务端性能更佳，但是用户端页面可能会延时，体验稍差。</p></li></ul><h2 id="动静分离的几种架构方案"><a href="#动静分离的几种架构方案" class="headerlink" title="动静分离的几种架构方案"></a>动静分离的几种架构方案</h2><pre><code>实体机单机部署；统一 Cache 层；上 CDN。</code></pre><h1 id="有针对性地处理好系统的“热点数据”"><a href="#有针对性地处理好系统的“热点数据”" class="headerlink" title="有针对性地处理好系统的“热点数据”"></a>有针对性地处理好系统的“热点数据”</h1><h2 id="为什么要关注热点"><a href="#为什么要关注热点" class="headerlink" title="为什么要关注热点"></a>为什么要关注热点</h2><pre><code>28定律 </code></pre><h2 id="什么是“热点”"><a href="#什么是“热点”" class="headerlink" title="什么是“热点”"></a>什么是“热点”</h2><ul><li>热点操作</li></ul><pre><code>读请求写请求 优化方法：存储层根据CAP理论做平衡</code></pre><ul><li>热点数据</li></ul><pre><code>静态热点数据能够提前预测的热点数据动态热点数据不能够提前预测的热点数据</code></pre><h2 id="发现热点数据"><a href="#发现热点数据" class="headerlink" title="发现热点数据"></a>发现热点数据</h2><h3 id="发现静态热点数据"><a href="#发现静态热点数据" class="headerlink" title="发现静态热点数据"></a>发现静态热点数据</h3><pre><code>报名技术手段提前预测</code></pre><h3 id="发现动态热点数据"><a href="#发现动态热点数据" class="headerlink" title="发现动态热点数据"></a>发现动态热点数据</h3><pre><code>构建一个异步的系统，它可以收集交易链路上各个环节中的中间件产品的热点 Key，如 Nginx、缓存、RPC 服务框架等这些中间件（一些中间件产品本身已经有热点统计模块）。建立一个热点上报和可以按照需求订阅的热点服务的下发规范，主要目的是通过交易链路上各个系统（包括详情、购物车、交易、优惠、库存、物流等）访问的时间差，把上游已经发现的热点透传给下游系统，提前做好保护。比如，对于大促高峰期，详情系统是最早知道的，在统一接入层上 Nginx 模块统计的热点 URL将上游系统收集的热点数据发送到热点服务台，然后下游系统（如交易系统）就会知道哪些商品会被频繁调用，然后做热点保护。重点(构建一个异步的系统，它可以收集交易链路上各个环节中的中间件产品的热点 Key，如 Nginx、缓存、RPC 服务框架等这些中间件（一些中间件产品本身已经有热点统计模块）。, 建立一个热点上报和可以按照需求订阅的热点服务的下发规范，主要目的是通过交易链路上各个系统（包括详情、购物车、交易、优惠、库存、物流等）访问的时间差，把上游已经发现的热点透传给下游系统，提前做好保护。比如，对于大促高峰期，详情系统是最早知道的，在统一接入层上 Nginx 模块统计的热点 URL, 将上游系统收集的热点数据发送到热点服务台，然后下游系统（如交易系统）就会知道哪些商品会被频繁调用，然后做热点保护。)</code></pre><h2 id="处理热点数据"><a href="#处理热点数据" class="headerlink" title="处理热点数据"></a>处理热点数据</h2><pre><code>一是优化缓存热点数据LRU 淘汰算法二是限制例如对被访问商品的 ID 做一致性 Hash，然后根据 Hash 做分桶，每个分桶设置一个处理队列，这样可以把热点商品限制在一个请求队列里，防止因某些热点商品占用太多的服务器资源，而使其他请求始终得不到服务器的处理资源。三是隔离业务隔离把秒杀做成一种营销活动，卖家要参加秒杀这种营销活动需要单独报名，从技术上来说，卖家报名后对我们来说就有了已知热点，因此可以提前做好预热。系统隔离系统隔离更多的是运行时的隔离，可以通过分组部署的方式和另外 99% 分开。秒杀可以申请单独的域名，目的也是让请求落到不同的集群中。数据隔离秒杀所调用的数据大部分都是热点数据，比如会启用单独的 Cache 集群或者 MySQL 数据库来放热点数据，目的也是不想 0.01% 的数据有机会影响 99.99% 数据隔离的其他办法比如，你可以按照用户来区分，给不同的用户分配不同的 Cookie，在接入层，路由到不同的服务接口中；再比如，你还可以在接入层针对 URL 中的不同 Path 来设置限流策略。服务层调用不同的服务接口，以及数据层通过给数据打标来区分</code></pre><h1 id="流量削峰这事应该怎么做？"><a href="#流量削峰这事应该怎么做？" class="headerlink" title="流量削峰这事应该怎么做？"></a>流量削峰这事应该怎么做？</h1><h2 id="为什么要削峰"><a href="#为什么要削峰" class="headerlink" title="为什么要削峰"></a>为什么要削峰</h2><ul><li><p>平稳</p></li><li><p>节省服务器的资源成本</p></li></ul><h2 id="方式方法？"><a href="#方式方法？" class="headerlink" title="方式方法？"></a>方式方法？</h2><h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h3><pre><code>消息队列来缓冲瞬时流量，把同步的直接调用转换成异步的间接推送，中间通过一个队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去。利用线程池加锁等待也是一种常用的排队方式；先进先出、先进后出等常用的内存排队算法的实现方式；把请求序列化到文件中，然后再顺序地读文件（例如基于 MySQL binlog 的同步机制）来恢复请求等方式。</code></pre><h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a>答题</h3><pre><code>防止部分买家使用秒杀器在参加秒杀时作弊延缓请求题库生成模块题库的推送模块题目的图片生成模块设计思路(题库生成模块, 题库的推送模块, 题目的图片生成模块)</code></pre><h3 id="分层过滤"><a href="#分层过滤" class="headerlink" title="分层过滤"></a>分层过滤</h3><pre><code>在不同的层次尽可能地过滤掉无效请求，让“漏斗”最末端的才是有效请分层校验的基本原则是将动态请求的读数据缓存（Cache）在 Web 端，过滤掉无效的数据读；对读数据不做强一致性校验，减少因为一致性校验产生瓶颈的问题；对写数据进行基于时间的合理分片，过滤掉过期的失效请求；对写请求做限流保护，将超出系统承载能力的请求过滤掉；对写数据进行强一致性校验，只保留最后有效的数据。</code></pre><h3 id="业务手段"><a href="#业务手段" class="headerlink" title="业务手段"></a>业务手段</h3><pre><code>零点开启优惠券抽奖活动</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>一个是通过队列来缓冲请求，即控制请求的发出；一个是通过答题来延长请求发出的时间，在请求发出后承接请求时进行控制，最后再对不符合条件的请求进行过滤；最后一种是对请求进行分层过滤。队列缓冲能起到很好的削峰和缓冲作用。答题更适用于秒杀或者营销活动等应用场景分层过滤非常适合交易性的写请求</code></pre><h1 id="影响性能的因素有哪些？又该如何提高系统的性能？"><a href="#影响性能的因素有哪些？又该如何提高系统的性能？" class="headerlink" title="影响性能的因素有哪些？又该如何提高系统的性能？"></a>影响性能的因素有哪些？又该如何提高系统的性能？</h1><h2 id="影响性能的因素"><a href="#影响性能的因素" class="headerlink" title="影响性能的因素"></a>影响性能的因素</h2><pre><code>QPS（Query Per Second，每秒请求数）响应时间（Response Time，RT）“总 QPS =（1000ms / 响应时间）× 线程数量”，一个是一次响应的服务端耗时，一个是处理请求的线程数。</code></pre><h2 id="响应时间和-QPS-有啥关系"><a href="#响应时间和-QPS-有啥关系" class="headerlink" title="响应时间和 QPS 有啥关系"></a>响应时间和 QPS 有啥关系</h2><pre><code>真正对性能有影响的是 CPU 的执行时间应该致力于减少 CPU 的执行时间</code></pre><h2 id="线程数对-QPS-的影响"><a href="#线程数对-QPS-的影响" class="headerlink" title="线程数对 QPS 的影响"></a>线程数对 QPS 的影响</h2><pre><code>设置什么样的线程数最合理呢“线程数 = 2 * CPU 核数 + 1”线程数 = [(线程等待时间 + 线程 CPU 时间) / 线程 CPU 时间] × CPU 数量当然，最好的办法是通过性能测试来发现最佳的线程数。</code></pre><h2 id="如何发现瓶颈"><a href="#如何发现瓶颈" class="headerlink" title="如何发现瓶颈"></a>如何发现瓶颈</h2><pre><code>缓存系统而言，制约它的是内存对存储型系统来说 I/O 更容易是瓶颈。秒杀，它的瓶颈更多地发生在 CPU 上海量请求涌过来，你的页面又比较大，那么网络就有可能出现瓶颈。</code></pre><h2 id="如何发现CPU瓶颈？使用工具"><a href="#如何发现CPU瓶颈？使用工具" class="headerlink" title="如何发现CPU瓶颈？使用工具"></a>如何发现CPU瓶颈？使用工具</h2><pre><code>JProfilerYourkitjstack 定时地打印调用栈</code></pre><h2 id="怎样简单地判断-CPU-是不是瓶颈呢"><a href="#怎样简单地判断-CPU-是不是瓶颈呢" class="headerlink" title="怎样简单地判断 CPU 是不是瓶颈呢"></a>怎样简单地判断 CPU 是不是瓶颈呢</h2><pre><code>一个办法就是看当 QPS 达到极限时，你的服务器的 CPU 使用率是不是超过了 95%，如果没有超过，那么表示 CPU 还有提升的空间，要么是有锁限制，要么是有过多的本地 I/O 等待发生。</code></pre><h2 id="如何优化系统"><a href="#如何优化系统" class="headerlink" title="如何优化系统"></a>如何优化系统</h2><pre><code>1. 减少编码网页输出是可以直接进行流输出的，即用 resp.getOutputStream() 函数写数据，把一些静态的数据提前转化成字节，等到真正往外写的时候再直接用 OutputStream() 函数写，就可以减少静态数据的编码转换。网页输出是可以直接进行流输出的，即用 resp.getOutputStream() 函数写数据性能提升30% 左右2. 减少序列化避免或者减少 RPC 就可以减少序列化合并部署部署到一台机器上同一个 Tomcat 容器中且不能走本机的 Socket3. Java 极致优化Web 系统做静态化改造，让大部分请求和数据直接在 Nginx 服务器或者 Web 代理服务器（如 Varnish、Squid 等）上直接返回（这样可以减少数据的序列化与反序列化）直接使用 Servlet 处理请求。避免使用传统的 MVC 框架，这样可以绕过一大堆复杂且用处不大的处理逻辑，节省 1ms 时间（具体取决于你对 MVC 框架的依赖程度）。直接输出流数据。使用 resp.getOutputStream() 而不是 resp.getWriter() 函数，可以省掉一些不变字符数据的编码，从而提升性能；数据输出时推荐使用 JSON 而不是模板引擎（一般都是解释执行）来输出页面。4. 并发读优化放到 Tair 缓存里面集中式缓存为了保证命中率一般都会采用一致性 Hash，所以同一个 key 会落到同一台机器上。虽然单台缓存机器也能支撑 30w/s 的请求，但还是远不足以应对像“大秒”这种级别的热点商品答案是采用应用层的 LocalCache，即在秒杀系统的单机上缓存商品相关的数据。像商品中的“标题”和“描述”这些本身不变的数据，会在秒杀开始之前全量推送到秒杀机器上，并一直缓存到秒杀结束；像库存这类动态数据，会采用“被动失效”的方式缓存一定时间（一般是数秒），失效后再去缓存拉取最新的数据。</code></pre><h1 id="秒杀系统“减库存”设计的核心逻辑"><a href="#秒杀系统“减库存”设计的核心逻辑" class="headerlink" title="秒杀系统“减库存”设计的核心逻辑"></a>秒杀系统“减库存”设计的核心逻辑</h1><h2 id="减库存有哪几种方式"><a href="#减库存有哪几种方式" class="headerlink" title="减库存有哪几种方式"></a>减库存有哪几种方式</h2><ul><li>下单减库存</li></ul><p>控制最精确</p><p>不会出现超卖</p><p>有些人下完单可能并不会付款</p><ul><li>付款减库存</li></ul><p>并发比较高，有可能出现买家下单后付不了款的情况，因为可能商品已经被其他人买走了。</p><ul><li>预扣库存</li></ul><p>买家下单后，库存为其保留一定的时间（如 10 分钟），超过这个时间，库存将会自动释放，释放后其他买家就可以继续购买。在买家付款前，系统会校验该订单的库存是否还有保留：如果没有保留，则再次尝试预扣；如果库存不足（也就是预扣失败）则不允许继续付款；如果预扣成功，则完成付款并实际地减去库存</p><h2 id="减库存可能存在的问题"><a href="#减库存可能存在的问题" class="headerlink" title="减库存可能存在的问题"></a>减库存可能存在的问题</h2><ul><li>下单减库存</li></ul><p>恶意下单商品就不能正常售卖</p><ul><li>付款减库存”又会导致另外一个问题：库存超卖。</li></ul><p>下单成功但是付不了款，买家的购物体验自然比较差。</p><ul><li>预扣库存</li></ul><p>一定程度上缓解上面的问题，但无法彻底解决</p><h2 id="解决办法还是要结合安全和反作弊的措施来制止。"><a href="#解决办法还是要结合安全和反作弊的措施来制止。" class="headerlink" title="解决办法还是要结合安全和反作弊的措施来制止。"></a>解决办法还是要结合安全和反作弊的措施来制止。</h2><pre><code>给经常下单不付款的买家进行识别打标（可以在被打标的买家下单时不减库存给某些类目设置最大购买件数（例如，参加活动的商品一人最多只能买 3 件）以及对重复下单不付款的操作进行次数限制等。对普通的商品下单数量超过库存数量的情况，可以通过补货来解决有些卖家完全不允许库存为负数的情况，那只能在买家付款时提示库存不足。</code></pre><h1 id="大型秒杀中如何减库存？"><a href="#大型秒杀中如何减库存？" class="headerlink" title="大型秒杀中如何减库存？"></a>大型秒杀中如何减库存？</h1><pre><code>下单减库存由于参加秒杀的商品，一般都是“抢到就是赚到”，所以成功下单后却不付款的情况比较少，再加上卖家对秒杀商品的库存有严格限制，所以秒杀商品采用“下单减库存”更加合理。另外，理论上由于“下单减库存”比“预扣库存”以及涉及第三方支付的“付款减库存”在逻辑上更为简单，所以性能上更占优势。主要就是保证大并发请求时库存数据不能为负数一种是在应用程序中通过事务来判断，即保证减后库存不能为负数，否则就回滚；另一种办法是直接设置数据库的字段数据为无符号整数，这样减后库存字段值小于零时会直接执行 SQL 语句来报错再有一种就是使用 CASE WHEN 判断语句，例如这样的 SQL 语句：UPDATE item SET inventory = CASE WHEN inventory &gt;= xxx THEN inventory-xxx ELSE inventory END</code></pre><h2 id="秒杀减库存的极致优化"><a href="#秒杀减库存的极致优化" class="headerlink" title="秒杀减库存的极致优化"></a>秒杀减库存的极致优化</h2><pre><code>缓存中减库存秒杀商品的减库存逻辑非常单一，比如没有复杂的 SKU 库存和总库存这种联动关系的话可以在缓存中做数据库中减库存比较复杂的减库存逻辑，或者需要使用事务，你还是必须在数据库中完成减库存。单个热点商品会影响整个数据库的性能进行隔离，把热点商品放到单独的热点库中。但是这无疑会带来维护上的麻烦，比如要做热点数据的动态迁移以及单独的数据库等。由于 MySQL 存储数据的特点，同一数据在数据库里肯定是一行存储（MySQL），因此会有大量线程来竞争 InnoDB 行锁，而并发度越高时等待线程会越多，</code></pre><h2 id="要解决并发锁的问题，有两种办法："><a href="#要解决并发锁的问题，有两种办法：" class="headerlink" title="要解决并发锁的问题，有两种办法："></a>要解决并发锁的问题，有两种办法：</h2><pre><code>应用层做排队。按照商品维度设置队列顺序执行，这样能减少同一台机器对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量，防止热点商品占用太多的数据库连接。数据库层做排队。应用层只能做到单机的排队，但是应用机器数本身很多，这种排队方式控制并发的能力仍然有限，所以如果能在数据库层做全局排队是最理想的。阿里的数据库团队开发了针对这种 MySQL 的 InnoDB 层上的补丁程序（patch），可以在数据库层上对单行记录做到并发排队。</code></pre><h1 id="准备Plan-B：如何设计兜底方案"><a href="#准备Plan-B：如何设计兜底方案" class="headerlink" title="准备Plan B：如何设计兜底方案?"></a>准备Plan B：如何设计兜底方案?</h1><h2 id="高可用建设应该从哪里着手"><a href="#高可用建设应该从哪里着手" class="headerlink" title="高可用建设应该从哪里着手"></a>高可用建设应该从哪里着手</h2><ul><li>架构阶段</li></ul><pre><code>可扩展性容错性避免系统出现单点问题多机房单元化部署，即使某个城市的某个机房出现整体故障，仍然不会影响整体网站的运转</code></pre><ul><li>编码阶段</li></ul><pre><code>健壮性涉及远程调用问题时，要设置合理的超时退出机制，防止被其他系统拖垮也要对调用的返回结果集有预期，防止返回的结果超出程序处理范围，最常见的做法就是对错误异常进行捕获，对无法预料的错误要有默认处理结果</code></pre><ul><li>测试阶段</li></ul><pre><code>保证测试用例的覆盖度，保证最坏情况发生时，我们也有相应的处理流程。</code></pre><ul><li>发布阶段</li></ul><pre><code>要有紧急的回滚机制。</code></pre><ul><li>运行阶段</li></ul><pre><code>运行态最重要的是对系统的监控要准确及时，发现问题能够准确报警并且报警数据要准确详细，以便于排查问题</code></pre><ul><li>故障发生</li></ul><pre><code>最重要的就是及时止损例如由于程序问题导致商品价格错误，那就要及时下架商品或者关闭购买链接，防止造成重大资产损失。然后就是要能够及时恢复服务，并定位原因解决问题。</code></pre><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>所谓“降级”，就是当系统的容量达到一定程度时，限制或者关闭系统的某些非核心功能，从而把有限的资源保留给更核心的业务</p><p>可以通过预案系统和开关系统来实现降级</p><p>当秒杀流量达到 5w/s 时，把成交记录的获取从展示 20 条降级到只展示 5 条。“从 20 改到 5”这个操作由一个开关来实现，也就是设置一个能够从开关系统动态获取的系统参数。</p><p>降级的核心目标是牺牲次要的功能和用户体验来保证核心业务流程的稳定，是一个不得已而为之的举措。</p><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>基于 QPS 和线程数的限流应用最多，最大 QPS 很容易通过压测提前获取，例如我们的系统最高支持 1w QPS 时，可以设置 8000 来进行限流保护。线程数限流在客户端比较有效，例如在远程调用时我们设置连接池的线程数，超出这个并发线程请求，就将线程进行排队或者直接超时丢弃。</p><p>限流无疑会影响用户的正常请求，所以必然会导致一部分用户请求失败，因此在系统处理这种异常时一定要设置超时时间，防止因被限流的请求不能 fast fail（快速失败）而拖垮系统。</p><p>可以是在客户端限流，也可以是在服务端限流</p><p>限流的实现方式既要支持 URL 以及方法级别的限流，也要支持基于 QPS 和线程的限流。</p><p>客户端限流</p><p>好处可以限制请求的发出，通过减少发出无用请求从而减少对系统的消耗。缺点就是当客户端比较分散时，没法设置合理的限流阈值：如果阈值设的太小，会导致服务端没有达到瓶颈时客户端已经被限制；而如果设的太大，则起不到限制的作用。</p><p>服务端限流</p><p>好处是可以根据服务端的性能设置合理的阈值，而缺点就是被限制的请求都是无效的请求，处理这些无效的请求本身也会消耗服务器资源。</p><h2 id="拒绝服务"><a href="#拒绝服务" class="headerlink" title="拒绝服务"></a>拒绝服务</h2><p> CPU 使用率达到 90% 或者系统 load 值达到 2*CPU 核数时，系统直接拒绝所有请求</p><p>在最前端的 Nginx 上设置过载保护，当机器负载达到某个值时直接拒绝 HTTP 请求并返回 503 错误码，在 Java 层同样也可以设计过载保护</p><p>像这种系统过载保护虽然在过载时无法提供服务，但是系统仍然可以运作，当负载下降时又很容易恢复，所以每个系统和每个环节都应该设置这个兜底方案，对系统做最坏情况下的保护。</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>预防</p><p>建立常态的压力体系，例如上线前的单机压测到上线后的全链路压测</p><p>管控</p><p>做好线上运行时的降级、限流和兜底保护</p><p>监控</p><p>建立性能基线来记录性能的变化趋势以及线上机器的负载报警体系，发现问题及时预警</p><p>恢复体系</p><p>遇到故障要及时止损，并提供快速的数据订正工具等</p><p>准</p><p>稳</p><p>快</p><p>提高单次请求的效率</p><p>减少没必要的请求</p><p>秒杀核心<br>(准, 稳, 快)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;高并发系统的几大方向&quot;&gt;&lt;a href=&quot;#高并发系统的几大方向&quot; class=&quot;headerlink&quot; title=&quot;高并发系统的几大方向&quot;&gt;&lt;/a&gt;高并发系统的几大方向&lt;/h1&gt;&lt;p&gt;1.请求数据尽量少，从而减少cpu消耗&lt;/p&gt;
&lt;p&gt;2.访问路径尽量短，减
      
    
    </summary>
    
    
    
      <category term="架构" scheme="http://iwantjingjing.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="秒杀" scheme="http://iwantjingjing.com/tags/%E7%A7%92%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://iwantjingjing.com/2020/04/28/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://iwantjingjing.com/2020/04/28/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-28T07:31:50.000Z</published>
    <updated>2020-04-28T07:45:39.768Z</updated>
    
    <content type="html"><![CDATA[<pre><code>public class Test02 {      /**      * 单例模式，懒汉式，线程安全      */      public static class Singleton {          private final static Singleton INSTANCE = new Singleton();          private Singleton() {          }          public static Singleton getInstance() {              return INSTANCE;          }      }        /**      * 单例模式，饿汉式，线程不安全      */      public static class Singleton2 {          private static Singleton2 instance = null;          private Singleton2() {          }          public static Singleton2 getInstance() {              if (instance == null) {                  instance = new Singleton2();              }              return instance;          }      }      /**      * 单例模式，饿汉式，线程安全，多线程环境下效率不高      */      public static class Singleton3 {          private static Singleton3 instance = null;          private Singleton3() {          }          public static synchronized Singleton3 getInstance() {              if (instance == null) {                  instance = new Singleton3();              }              return instance;          }      }      /**      * 单例模式，懒汉式，变种，线程安全      */      public static class Singleton4 {          private static Singleton4 instance = null;          static {              instance = new Singleton4();          }          private Singleton4() {          }          public static Singleton4 getInstance() {              return instance;          }      }      /**      * 单例模式，使用静态内部类，线程安全【推荐】      */      public static class Singleton5 {          private final static class SingletonHolder {              private static final Singleton5 INSTANCE = new Singleton5();          }          private Singleton5() {          }          public static Singleton5 getInstance() {              return SingletonHolder.INSTANCE;          }      }      /**      * 静态内部类，使用枚举方式，线程安全【推荐】      */      public enum Singleton6 {          INSTANCE;          public void whateverMethod() {          }      }      /**      * 静态内部类，使用双重校验锁，线程安全【推荐】      */      public static class Singleton7 {          private volatile static Singleton7 instance = null;          private Singleton7() {          }          public static Singleton7 getInstance() {              if (instance == null) {                  synchronized (Singleton7.class) {                      if (instance == null) {                          instance = new Singleton7();                      }                  }              }              return instance;          }      }      public static void main(String[] args) {          System.out.println(Singleton.getInstance() == Singleton.getInstance());          System.out.println(Singleton2.getInstance() == Singleton2.getInstance());          System.out.println(Singleton3.getInstance() == Singleton3.getInstance());          System.out.println(Singleton4.getInstance() == Singleton4.getInstance());          System.out.println(Singleton5.getInstance() == Singleton5.getInstance());          System.out.println(Singleton6.INSTANCE == Singleton6.INSTANCE);          System.out.println(Singleton7.getInstance() == Singleton7.getInstance());      }  }  </code></pre><p><a href="https://wiki.jikexueyuan.com/project/for-offer/question-two.html" target="_blank" rel="noopener">参考1</a><br><a href="https://blog.csdn.net/u011595939/article/details/79972371" target="_blank" rel="noopener">参考2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;public class Test02 {  
    /** 
     * 单例模式，懒汉式，线程安全 
     */  
    public static class Singleton {  
        private final stat
      
    
    </summary>
    
    
      <category term="java" scheme="http://iwantjingjing.com/categories/java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="设计模式" scheme="http://iwantjingjing.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>私有构造函数的作用</title>
    <link href="http://iwantjingjing.com/2020/04/28/%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://iwantjingjing.com/2020/04/28/%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8/</id>
    <published>2020-04-28T06:48:41.000Z</published>
    <updated>2020-04-28T06:56:13.781Z</updated>
    
    <content type="html"><![CDATA[<p>1 防止对象被随意创建</p><p>2 用于实现单例</p><p>3 工具类防止实例化（不创建对象，方法设为静态，可通过对象.来调用）</p><p>4 应用于工厂模式的实现</p><pre><code>父类方法调用子类实现1。你可以返回任何的Shape类型，包括Shape的子类。比如你可以把makeShape写成这样：public class Shape {    private Shape() {       /* set something here */    }    public static Shape makeShape(/* arglist */) {           System.out.println(&quot;here is the shape you ordered&quot;);           if (retangle)                 return (new Retangle(/* arglist*/));           if (Circle)                return (new Circle(/* arglist */));        /* you can return as many shapes as you like */        }}    这里假设Retangle 和 Circle 都是shape的子类，并且和Shape类在同一个包內，Shape类可以访问子类的构造函数。这样shape就提供了一个图形工厂。 用户通过一个接口就可以生成不同的图形。事实上，这种用法被称为“工厂模式”。</code></pre><p>5 方便抛出异常</p><pre><code>在构造器中的异常一般会被jvm抛弃    </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1 防止对象被随意创建&lt;/p&gt;
&lt;p&gt;2 用于实现单例&lt;/p&gt;
&lt;p&gt;3 工具类防止实例化（不创建对象，方法设为静态，可通过对象.来调用）&lt;/p&gt;
&lt;p&gt;4 应用于工厂模式的实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;父类方法调用子类实现
1。你可以返回任何的Shape类型，包括S
      
    
    </summary>
    
    
      <category term="java" scheme="http://iwantjingjing.com/categories/java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL · 特性分析 · 到底是谁执行了FTWRL</title>
    <link href="http://iwantjingjing.com/2020/04/28/MySQL-%C2%B7-%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90-%C2%B7-%E5%88%B0%E5%BA%95%E6%98%AF%E8%B0%81%E6%89%A7%E8%A1%8C%E4%BA%86FTWL/"/>
    <id>http://iwantjingjing.com/2020/04/28/MySQL-%C2%B7-%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90-%C2%B7-%E5%88%B0%E5%BA%95%E6%98%AF%E8%B0%81%E6%89%A7%E8%A1%8C%E4%BA%86FTWL/</id>
    <published>2020-04-28T03:35:31.000Z</published>
    <updated>2020-04-28T03:42:53.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><pre><code>FTWRL是flush table with read lock的简称。该命令主要用于保证备份一致性备份 全局读锁(lock_global_read_lock) 会导致所有的更新操作被堵塞全局COMMIT锁(make_global_read_lock_block_commit) 会导致所有的活跃事务无法提交FLUSH TABLES WITH READ LOCK执行后整个系统会一直处于只读状态，直到显示执行UNLOCK TABLES。这点请切记。</code></pre><h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><p><img src="tmp.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;what&quot;&gt;&lt;a href=&quot;#what&quot; class=&quot;headerlink&quot; title=&quot;what&quot;&gt;&lt;/a&gt;what&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;FTWRL是flush table with read lock的简称。
该命令主要用于保证备份一致性备份 
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://iwantjingjing.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://iwantjingjing.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql之锁</title>
    <link href="http://iwantjingjing.com/2020/04/28/mysql%E4%B9%8B%E9%94%81/"/>
    <id>http://iwantjingjing.com/2020/04/28/mysql%E4%B9%8B%E9%94%81/</id>
    <published>2020-04-28T01:03:29.000Z</published>
    <updated>2020-04-28T01:39:11.241Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://xzh20121116.github.io/post/mysql-zhi-suo/" target="_blank" rel="noopener">摘自</a></p><h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><pre><code>加锁 lock tablas ...read/write主动解锁 unlock tables ... 被动解锁 客户端断开连接时被动解锁限制其他线程读写，也会对本线程接下来的操作对象。一般不用，消耗大</code></pre><h2 id="MDL（元数据锁-meta-data-lock）"><a href="#MDL（元数据锁-meta-data-lock）" class="headerlink" title="MDL（元数据锁 meta data lock）"></a>MDL（元数据锁 meta data lock）</h2><pre><code>自动加锁读锁 对表数据的增删改查写锁 对表结构的修改多个事务读锁不互斥多个事务写锁互斥mdl作用保证读写的正确性</code></pre><h1 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h1><p>根据数据引擎来实现的，MyIsam就不支持行锁</p><h2 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h2><pre><code>innodb中有需要时加此锁，但并非不需要时解锁，而是在事务提交之后解锁。若一个事务锁多行，尽可能把并发多的行往后写。</code></pre><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><pre><code>事务a等待事务b释放某行的锁，事务b等待事务a释放某行的锁就造成死锁。例如：事务a update table a ... where line = 1;事务b update table a ... where line = 2;事务a update table a ... where line = 2;事务b update table a ... where line = 1;事务a等待事务b释放line=2的锁，事务b等待事务a释放line=1的锁，由于两阶段锁的存在（即事务只有在commit之后才释放锁）顾造成锁都释放不了，造成死锁。</code></pre><h2 id="mvcc-多版本并发控制"><a href="#mvcc-多版本并发控制" class="headerlink" title="mvcc(多版本并发控制)"></a>mvcc(多版本并发控制)</h2><pre><code>mysql在修改一行数据时，都会记录一行此数据相应的回滚操作，若某行数据被改了n次，则此事务相应的回滚记录也被记录了n次。这种一条数据在系统中有多个版本就是多版本并发控制mvcc.</code></pre><h1 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h1><p> <img src="mysql%E4%B9%8B%E9%94%81.png" alt=""> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://xzh20121116.github.io/post/mysql-zhi-suo/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;摘自&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;表级锁&quot;&gt;&lt;a href=&quot;#表级锁&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://iwantjingjing.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://iwantjingjing.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>java 内存模型与volatile关键字</title>
    <link href="http://iwantjingjing.com/2020/04/27/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8Evolatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://iwantjingjing.com/2020/04/27/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8Evolatile%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-04-27T03:56:54.000Z</published>
    <updated>2020-04-27T04:37:03.720Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://xzh20121116.github.io/post/VPO1pZnCC/" target="_blank" rel="noopener">摘自</a></p><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="what（是什么）"><a href="#what（是什么）" class="headerlink" title="what（是什么）"></a>what（是什么）</h2><p>一种抽象概念，是一种规则，描述了Java线程间通信的访问方式。<br>规定了主内存，工作内存（线程本地内存）之间通行的规则。<br>所有线程都可以访问（读取）主内存的资源，然后将主内存的资源拷贝到自己的工作内存，修改时先修改自己的工作内存，然后将工作内存的资源拷贝到主内存，所有线程都不可直接对主内存进行写入。他们只能直接操作自己的工作内存。</p><pre><code>1 一个线程加锁前必须将主内存中的值刷新到自己的工作内存2 一个线程解锁前必须将自己工作内存中的值刷新到主内存3 加解锁必须是同一个锁</code></pre><h2 id="主内存与工作内存之间的关系8种"><a href="#主内存与工作内存之间的关系8种" class="headerlink" title="主内存与工作内存之间的关系8种"></a>主内存与工作内存之间的关系8种</h2><pre><code>1 lock 作用于主内存 即保证资源被一个线程独享2 unlock 作用于主内存 释放一个资源3 read 作用于主内存 将一个资源从主内存传输到工作内存4 load 作用于工作内存 将读取的资源加载到工作内存5 use 工作内存 使用资源以用于显示，传递等6 assign 工作内存 赋值 将从控制引擎得到的值赋值给工作内存7 store 工作内存 将赋值的值写入存储到工作内存8 write 主内存 将存储的值 刷新到主内存</code></pre><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><pre><code>原子性 一个操作是不可中断的，即多个线程操作时，一个线程的操作也是不可被打断的，直到操作完成。可见性 对主内存的修改，其他线程都能第一时间看到,多线程有问题有序性 理想状态是一条一条执行的，但因重排序（指令重拍的存在）顾不是有序的</code></pre><h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><h2 id="保证了两大特性"><a href="#保证了两大特性" class="headerlink" title="保证了两大特性"></a>保证了两大特性</h2><pre><code>有序性可见性</code></pre><h2 id="有序性原理"><a href="#有序性原理" class="headerlink" title="有序性原理"></a>有序性原理</h2><p>当操作由volatile修饰的变量时，jvm会向控制器发送一条带有lock前缀的指令，该指令实际上就形成了一个内存屏障，有效隔离了变量前及变量后的操作，防止了指令重排序。从而实现了有序性</p><h2 id="可见性原理"><a href="#可见性原理" class="headerlink" title="可见性原理"></a>可见性原理</h2><p>lock指令保证了工作内存变量值得有效性，即其他工作内存变量值得无效性。</p><h1 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h1><p><img src="java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E3%80%81volatile%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://xzh20121116.github.io/post/VPO1pZnCC/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;摘自&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; c
      
    
    </summary>
    
    
      <category term="java" scheme="http://iwantjingjing.com/categories/java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础题</title>
    <link href="http://iwantjingjing.com/2020/04/19/Java%E5%9F%BA%E7%A1%80%E9%A2%98/"/>
    <id>http://iwantjingjing.com/2020/04/19/Java%E5%9F%BA%E7%A1%80%E9%A2%98/</id>
    <published>2020-04-19T08:50:24.000Z</published>
    <updated>2020-04-19T09:20:51.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-以下哪个是finalize-方法的正确形式？"><a href="#1-以下哪个是finalize-方法的正确形式？" class="headerlink" title="1.以下哪个是finalize()方法的正确形式？"></a>1.以下哪个是finalize()方法的正确形式？</h1><pre><code>A.protected void finalize() throws ThrowableB.final finalize()C.public final finalize()D.private boolean finalize()答案：A</code></pre><h1 id="2-如果finalize（）方法抛出一个运行时异常，以下哪个描述正确？"><a href="#2-如果finalize（）方法抛出一个运行时异常，以下哪个描述正确？" class="headerlink" title="2.如果finalize（）方法抛出一个运行时异常，以下哪个描述正确？"></a>2.如果finalize（）方法抛出一个运行时异常，以下哪个描述正确？</h1><pre><code>A.正在运行的应用程序系统崩溃B.此异常被忽略，并且该异常对象被垃圾回收器回收C.此异常被忽略，但是该异常对象未被垃圾回收期回收D.此异常导致JVM崩溃答案：B答案解析：finalize()方法只是用于清除对象，而不是实际的销毁对象，因此对该方法的调用不会引起系统崩溃，该方法抛出的异常也会作为废弃对象被垃圾回收期回收</code></pre><h1 id="3-如何释放掉一个对象占据的内存空间？"><a href="#3-如何释放掉一个对象占据的内存空间？" class="headerlink" title="3.如何释放掉一个对象占据的内存空间？"></a>3.如何释放掉一个对象占据的内存空间？</h1><pre><code>A.调用free()方法B.调用System.gc()方法C.赋值给该对象的引用为nullD.程序员无法明确强制垃圾回收器运行答案：D</code></pre><h1 id="4-给出以下代码："><a href="#4-给出以下代码：" class="headerlink" title="4.给出以下代码："></a>4.给出以下代码：</h1><pre><code>1.public class Example {2. public static void main(String[] args) {3.  String s = &quot;abcd&quot;;4.  Integer x = new Integer(3);5.  String s2 = s + 4;6.  s2 = null;7.  s = null;8. }9.}改程序运行到第几行变量S2引用的对象符合垃圾回收器回收条件？A.第7行B.不存在C.第6行D.直到main线程结束，S2应用的对象才可能被回收答案：C</code></pre><h1 id="5-以下代码运行到关键点处，有多少对象符合垃圾回收的条件？"><a href="#5-以下代码运行到关键点处，有多少对象符合垃圾回收的条件？" class="headerlink" title="5.以下代码运行到关键点处，有多少对象符合垃圾回收的条件？"></a>5.以下代码运行到关键点处，有多少对象符合垃圾回收的条件？</h1><pre><code>public class Example { public static void main(String[] args) {  String name;  String newName = &quot;Nick&quot;;  newName = &quot;Jason&quot;;  name = &quot;Frieda&quot;;  String newestName = name;  name = null;  // 关键点 }}A.0个B.1个C.2个D.3个答案：B</code></pre><h1 id="6-以下哪些是有关垃圾回收器的正确描述？"><a href="#6-以下哪些是有关垃圾回收器的正确描述？" class="headerlink" title="6.以下哪些是有关垃圾回收器的正确描述？"></a>6.以下哪些是有关垃圾回收器的正确描述？</h1><pre><code>A.程序员可以在制定时间调用垃圾回收器释放内存B.垃圾回收器可以保证Java程序不会产生内存溢出C.程序员可以制定垃圾回收器回收对象D.对象的finalize()方法在对象被垃圾回收器回收之前获得调用答案：C、D答案解析：通过通配符*号引入的两个不同包中存在同名的类，当代码中不加包名直接使用时，会产生编译错误，使用时需要提供完整包路径</code></pre><h1 id="7-拥有下列哪些引用类型的对象在虚拟机内存足够的情况下不会被垃圾回收机制回收？"><a href="#7-拥有下列哪些引用类型的对象在虚拟机内存足够的情况下不会被垃圾回收机制回收？" class="headerlink" title="7.拥有下列哪些引用类型的对象在虚拟机内存足够的情况下不会被垃圾回收机制回收？"></a>7.拥有下列哪些引用类型的对象在虚拟机内存足够的情况下不会被垃圾回收机制回收？</h1><pre><code>A.强引用B.软引用C.弱引用D.虚引用答案：A、B</code></pre><h1 id="8-finalize和C-的-destructors有何差异"><a href="#8-finalize和C-的-destructors有何差异" class="headerlink" title="8.finalize和C++ 的 destructors有何差异?"></a>8.finalize和C++ 的 destructors有何差异?</h1><pre><code>答案：Java内部具有“内存使用回收” 的机制， 虽然它也提供了类似 (C++ 的) destructors的 finalize()，每个对象都可以使用这个方法 method，但必须冒著破坏原先回收机制的危险。所以建议尽量避免使用finalize()，不妨考虑多使用引用队列来释出资源会好一些。</code></pre><h1 id="9-Java语言中异常的分类是哪项？"><a href="#9-Java语言中异常的分类是哪项？" class="headerlink" title="9.Java语言中异常的分类是哪项？"></a>9.Java语言中异常的分类是哪项？</h1><pre><code>A.运行时异常和异常B.受检异常和非受检异常C.错误和异常D.错误和运行时异常答案：C</code></pre><h1 id="10-所有异常的父类是哪项？"><a href="#10-所有异常的父类是哪项？" class="headerlink" title="10.所有异常的父类是哪项？"></a>10.所有异常的父类是哪项？</h1><pre><code>A.ThrowableB.ErrorC.RuntimeExceptionD.Exception答案：A</code></pre><h1 id="11-下列属于非受检异常（运行时异常）的是哪项？"><a href="#11-下列属于非受检异常（运行时异常）的是哪项？" class="headerlink" title="11.下列属于非受检异常（运行时异常）的是哪项？"></a>11.下列属于非受检异常（运行时异常）的是哪项？</h1><pre><code>A.SQLExceptionB.IOExceptionC.NullPointerExceptionD.OutOfMemoryError答案：C</code></pre><h1 id="12-假设有自定义异常类ServiceException-那么抛出该异常的语句正确的是哪项？"><a href="#12-假设有自定义异常类ServiceException-那么抛出该异常的语句正确的是哪项？" class="headerlink" title="12.假设有自定义异常类ServiceException,那么抛出该异常的语句正确的是哪项？"></a>12.假设有自定义异常类ServiceException,那么抛出该异常的语句正确的是哪项？</h1><pre><code>A.raise ServiceExceptionB.throw new ServiceException()C.throw ServiceExceptionD.throws ServiceException答案：B</code></pre><h1 id="13-在方法声明中，说明该方法可能会抛出的异常列表时使用哪个关键字？"><a href="#13-在方法声明中，说明该方法可能会抛出的异常列表时使用哪个关键字？" class="headerlink" title="13.在方法声明中，说明该方法可能会抛出的异常列表时使用哪个关键字？"></a>13.在方法声明中，说明该方法可能会抛出的异常列表时使用哪个关键字？</h1><pre><code>A.throw B.catchC.finallyD.throws答案：D</code></pre><h1 id="14-现有代码："><a href="#14-现有代码：" class="headerlink" title="14.现有代码："></a>14.现有代码：</h1><pre><code>public class Example { public static void main(String[] args) {  try {   System.out.print(Integer.parseInt(&quot;forty&quot;));     } catch (RuntimeException e) {   System.out.println(&quot;Runtime&quot;);  }catch (NumberFormatException e) {   System.out.println(&quot;Number&quot;);  } }}执行结果是什么？A.输出NumberB.输出RuntimeC.输出40D.编译失败答案：D答案解析：NumberFormatException是RuntimeException的子类，因此两个catch块位置应该交换才能正确处理异常</code></pre><h1 id="15-现有代码如下："><a href="#15-现有代码如下：" class="headerlink" title="15.现有代码如下："></a>15.现有代码如下：</h1><pre><code>public class Example { void topGo() {  try {   middleGo();  } catch (Exception e) {   System.out.println(&quot;catch&quot;);  } } void middleGo() throws Exception {  go();  System.out.println(&quot;late middle&quot;); } void go() throws Exception {  throw new Exception(); } public static void main(String[] args) {  Example example = new Example();  example.topGo(); }}该代码的执行结果是？A.输出late middleB.输出catchC.输出late middle catchD.输出catch late middle答案：B</code></pre><h1 id="16-如下代码执行后的输出结果是？"><a href="#16-如下代码执行后的输出结果是？" class="headerlink" title="16.如下代码执行后的输出结果是？"></a>16.如下代码执行后的输出结果是？</h1><pre><code>public class Example { public static void main(String[] args) {  try {   throw new Exception();  } catch (Exception e) {   try {    throw new Exception();   } catch (Exception e2) {    System.out.println(&quot;inner&quot;);   }   System.out.println(&quot;middle&quot;);  }  System.out.println(&quot;out&quot;); }}A.inner outerB.middle outerC.inner middle outerD.编译失败答案：C</code></pre><h1 id="17-现有如下代码："><a href="#17-现有如下代码：" class="headerlink" title="17.现有如下代码："></a>17.现有如下代码：</h1><pre><code>public class Example extends Utils{ public static void main(String[] args) {  try {   System.out.println(new Example().getInt(&quot;42&quot;));  } catch (NumberFormatException e) {   System.out.println(&quot;NFExc&quot;);  } }  int getInt(String arg) throws NumberFormatException{  return Integer.parseInt(arg); }}class Utils { int getInt(String arg) {  return 42; }}该代码执行的结果是？A.NFExcB.42.0C.42NFExcD.编译失败答案：B答案解析：Utils中的getInt方法没有抛出异常，而子类Example中的getInt抛出了运行时异常，这是符合方法覆盖的抛出异常特性规范的，因为运行时异常并不会强制要求方法调用代码捕获处理</code></pre><h1 id="18-现有如下代码："><a href="#18-现有如下代码：" class="headerlink" title="18.现有如下代码："></a>18.现有如下代码：</h1><pre><code>public class Example extends Utils{ public static void main(String[] args) {  try {   System.out.println(new Example().getInt(&quot;42&quot;));  } catch (NumberFormatException e) {   System.out.println(&quot;NFExc&quot;);  } }  int getInt(String arg) throws Exception{  return Integer.parseInt(arg); }}class Utils { int getInt(String arg) {  return 42; }}该代码执行的结果是？A.NFExcB.42.0C.42NFExcD.编译失败答案：D答案解析：子类抛出的异常不符合方法覆盖的异常列表要求，因此编译失败（见上题）</code></pre><h1 id="19-现有如下代码："><a href="#19-现有如下代码：" class="headerlink" title="19.现有如下代码："></a>19.现有如下代码：</h1><pre><code>public class Example { public static void main(String[] args) {// a  new Example().topGo(); } void topGo() {// b  middleGo(); } void middleGo() {// c  go();  System.out.println(&quot;late middle&quot;); } void go() {// d  throw new Exception(); }}为了使代码能够编译通过，需要在哪个地方加入声明throws Exception?A.dB.c和dC.b、c和dD.a、b、c和d答案：D</code></pre><h1 id="20-下面代码的执行结果是？"><a href="#20-下面代码的执行结果是？" class="headerlink" title="20.下面代码的执行结果是？"></a>20.下面代码的执行结果是？</h1><pre><code>class Example extends Utils { public static void main(String[] args) {  try {   System.out.print(new Example().getlnt(&quot;42&quot;));  } catch (Exception e) {   System.out.println(&quot;Exc&quot;);  } } int getlnt(String arg) throws Exception {  return Integer.parseInt(arg); }}class Utils { int getlnt() {  return 42; }}A.NFExcB.42.0C.42NFExcD.编译失败答案：B答案解析：本题没有实现方法覆盖</code></pre><h1 id="21-关于异常处理，说法错误的是？"><a href="#21-关于异常处理，说法错误的是？" class="headerlink" title="21.关于异常处理，说法错误的是？"></a>21.关于异常处理，说法错误的是？</h1><pre><code>A.try⋯catch⋯finally结构中，必须有try语句块，catch语句块和finally语句块不是必须的，但至少要两者取其一B.在异常处理中，若try中的代码可能产生多种异常则可以对应多个catch语句，若catch中的参数类型有父类子类关系，此时应该将子类放在后面，父类放在前面C.一个方法可以抛出多个异常，方法的返回值也能够是异常D.Throwable是所有异常的超类答案：B答案解析：若catch中的参数类型有父类子类关系，此时应该将子类放在前面，父类放在后面</code></pre><h1 id="22-以下关于Error和Exception类的描述正确的是？"><a href="#22-以下关于Error和Exception类的描述正确的是？" class="headerlink" title="22.以下关于Error和Exception类的描述正确的是？"></a>22.以下关于Error和Exception类的描述正确的是？</h1><pre><code>A.Error类和Exception类都是Throwable类的子类B.Error类是一个final类，而Exception类是一个非final类C.Exception类是一个final类，而Error类是一个非final类D.Error类和Exception类都实现了Throwable接口答案：A</code></pre><h1 id="23-请问以下哪个是声明一个方法抛出异常的正确形式？"><a href="#23-请问以下哪个是声明一个方法抛出异常的正确形式？" class="headerlink" title="23.请问以下哪个是声明一个方法抛出异常的正确形式？"></a>23.请问以下哪个是声明一个方法抛出异常的正确形式？</h1><pre><code>A.void m() throws IOException{}B.void m() throw IOExceptionC.void m(){} throws IOExceptionD.void m(void) throw IOException{}答案：A</code></pre><h1 id="24-请问以下哪些关于try⋯catch⋯finally结构中的finally语句的描述是正确的？"><a href="#24-请问以下哪些关于try⋯catch⋯finally结构中的finally语句的描述是正确的？" class="headerlink" title="24.请问以下哪些关于try⋯catch⋯finally结构中的finally语句的描述是正确的？"></a>24.请问以下哪些关于try⋯catch⋯finally结构中的finally语句的描述是正确的？</h1><pre><code>A.只有当一个catch语句获得执行后，finally语句才获得执行B.只有当catch语句未获得执行时，finally语句才获得执行C.如果有finally语句，return语句将在finally语句执行完毕后才会返回D.只有当异常抛出时，finally语句才获得执行答案：C</code></pre><h1 id="25-请问以下代码的直接执行结果是？"><a href="#25-请问以下代码的直接执行结果是？" class="headerlink" title="25.请问以下代码的直接执行结果是？"></a>25.请问以下代码的直接执行结果是？</h1><pre><code>class Example{ public static void main(String[] args) {  try {   System.out.println(args[0]);   System.out.println(&quot;I&apos;m nomal&quot;);   if (true)    return;  } catch (Exception ex) {   System.out.println(&quot;I&apos;m exception&quot;);   if (true)    return;  } finally {   System.out.println(&quot;I&apos;m finally.&quot;);  }  System.out.println(&quot;Out of try.&quot;); }｝A.I&apos;m exceptionI&apos;m finally.B.代码不能编译通过，因为最后一条语句位于return后，不可到达C.代码编译通过，但运行时输出异常信息D.I&apos;m nomalI&apos;m finally.答案：A</code></pre><h1 id="26-关于以下代码，说法正确的是？"><a href="#26-关于以下代码，说法正确的是？" class="headerlink" title="26.关于以下代码，说法正确的是？"></a>26.关于以下代码，说法正确的是？</h1><pre><code>class Example{ public static void main(String[] args) throws IOException {  if (args[0] == &quot;hello&quot;) {   throw new IOException();  } }}A.代码编译成功B.代码编译失败，因为main()方法是入口方法，不能抛出异常C.代码编译失败，因为IOException异常是系统异常，不能由应用程序抛出D.代码编译失败，因为字符串应该用equals方法判定一致性答案：A</code></pre><h1 id="27-关于以下代码，说法正确的是？"><a href="#27-关于以下代码，说法正确的是？" class="headerlink" title="27.关于以下代码，说法正确的是？"></a>27.关于以下代码，说法正确的是？</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  System.out.println(&quot;Before Try&quot;);  try {  } catch (java.io.IOException e) {   System.out.println(&quot;Inside Catch&quot;);  }  System.out.println(&quot;At the End&quot;); }}A.代码编译失败，因为无异常抛出B.代码编译失败，因为未导入IOException异常类C.输出Before TryAt the EndD.输出Inside CatchAt the End答案：A</code></pre><h1 id="28-关于以下代码，说法正确的是？"><a href="#28-关于以下代码，说法正确的是？" class="headerlink" title="28.关于以下代码，说法正确的是？"></a>28.关于以下代码，说法正确的是？</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  System.out.println(&quot;Before Try&quot;);  try {  } catch (Throwable e) {   System.out.println(&quot;Inside Catch&quot;);  }  System.out.println(&quot;At the End&quot;); }}A.代码编译失败，因为无异常抛出B.代码编译失败，因为未导入IOException异常类C.输出Before TryAt the EndD.输出Inside CatchAt the End答案：C</code></pre><h1 id="29-给出以下代码："><a href="#29-给出以下代码：" class="headerlink" title="29.给出以下代码："></a>29.给出以下代码：</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  try {   methodA();     } catch (IOException e) {   System.out.println(&quot;caught IOException&quot;);  }catch (Exception e) {   System.out.println(&quot;caught Exception&quot;);  } }}如果methodA()方法抛出一个IOException异常，则该程序的运行结果是什么？A.无内容输出B.代码编译失败C.输出caught IOExceptionD.输出caught Exception答案：C</code></pre><h1 id="30-下列代码的运行结果是？"><a href="#30-下列代码的运行结果是？" class="headerlink" title="30.下列代码的运行结果是？"></a>30.下列代码的运行结果是？</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  try {   return;  } finally{   System.out.println(&quot;Finally&quot;);  } }}A.无内容输出B.输出FinallyC.代码编译失败D.输出异常信息答案：B</code></pre><h1 id="31-给出以下代码，执行结果是？"><a href="#31-给出以下代码，执行结果是？" class="headerlink" title="31.给出以下代码，执行结果是？"></a>31.给出以下代码，执行结果是？</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  aMethod(); } static void aMethod(){  try {   System.out.println(&quot;Try&quot;);   return;  } catch (Exception e) {   System.out.println(&quot;Catch&quot;);  }finally{   System.out.println(&quot;Finally&quot;);  } }}A.代码编译成功，但运行期间抛出异常B.代码便以失败，因为return语句错误C.输出Try和FinallyD.输出Try答案：C</code></pre><h1 id="32-以下代码中，如果test-方法抛出一个NullPointException异常时，打印输出什么内容？"><a href="#32-以下代码中，如果test-方法抛出一个NullPointException异常时，打印输出什么内容？" class="headerlink" title="32.以下代码中，如果test()方法抛出一个NullPointException异常时，打印输出什么内容？"></a>32.以下代码中，如果test()方法抛出一个NullPointException异常时，打印输出什么内容？</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  try {   test();   System.out.println(&quot;Message1&quot;);  } catch (ArrayIndexOutOfBoundsException e) {   System.out.println(&quot;Message2&quot;);  }finally{   System.out.println(&quot;Message3&quot;);  } }}A.打印输出Message1B.打印输出Message2C.打印输出Message3D.以上都不对答案：C</code></pre><h1 id="33-以下代码执行结果是什么？"><a href="#33-以下代码执行结果是什么？" class="headerlink" title="33.以下代码执行结果是什么？"></a>33.以下代码执行结果是什么？</h1><pre><code>class Example { public static String output = &quot;&quot;; public static void foo(int i) {  try {   if (i == 1) {    throw new Exception();   }   output += &quot;1&quot;;  } catch (Exception e) {   output += &quot;2&quot;;   return;  } finally {   output += &quot;3&quot;;  }  output += &quot;4&quot;; } public static void main(String[] args) throws IOException {  foo(0);  foo(1);  System.out.println(output); }}A.无内容输出B.代码编译失败C.输出13423D.输出14323答案：C</code></pre><h1 id="34-以下代码执行结果是？"><a href="#34-以下代码执行结果是？" class="headerlink" title="34.以下代码执行结果是？"></a>34.以下代码执行结果是？</h1><pre><code>public abstract class Example extends Base { public abstract void method();}class Base { public Base() throws IOException {  throw new IOException(); }}A.代码编译失败，因为非抽象类不能被扩展为抽象类B.代码编译失败，因为必须提供一个可以抛出或可以不抛出IOException异常的构造器C.代码编译失败，以in为必须提供一个可以抛出IOException异常或其子类的构造器D.代码编译成功答案：C</code></pre><h1 id="35-关于以下代码正确的说法是："><a href="#35-关于以下代码正确的说法是：" class="headerlink" title="35.关于以下代码正确的说法是："></a>35.关于以下代码正确的说法是：</h1><pre><code>public class Example {int x = 0; public Example(int inVal) throws Exception {if (inVal != this.x) { throw new Exception(&quot;Invalid input&quot;);} }public static void main(String[] args) { Example t = new Example(4); }}A.代码在第1行编译错误B.代码在第4行编译错误C.代码在第6行编译错误D.代码在第11行编译错误答案：D</code></pre><h1 id="36-关于try⋯catch⋯finally结构，描述正确的是些？"><a href="#36-关于try⋯catch⋯finally结构，描述正确的是些？" class="headerlink" title="36.关于try⋯catch⋯finally结构，描述正确的是些？"></a>36.关于try⋯catch⋯finally结构，描述正确的是些？</h1><pre><code>A.可以有多个catchB.只能有一个catchC.可以没有catchD.finally必须有答案：A、C</code></pre><h1 id="37-当fragile-方法抛出一个IllegalArgumentException异常时，下列代码的运行结果是什么？"><a href="#37-当fragile-方法抛出一个IllegalArgumentException异常时，下列代码的运行结果是什么？" class="headerlink" title="37.当fragile()方法抛出一个IllegalArgumentException异常时，下列代码的运行结果是什么？"></a>37.当fragile()方法抛出一个IllegalArgumentException异常时，下列代码的运行结果是什么？</h1><pre><code>public static void main(String[] args) throws IOException {  try {   fragile();  } catch (NullPointerException e) {   System.out.println(&quot;NullPointerException thrown&quot;);  } catch (Exception e) {   System.out.println(&quot;Exception thrown&quot;);  } finally {   System.out.println(&quot;Done with exceptions&quot;);  }  System.out.println(&quot;myMethod is done&quot;); }｝A.输出NullPointerException thrownB.输出Exception thrownC.输出Done with ExceptionD.输出myMethod is done答案：B、C、D</code></pre><h1 id="38-现有如下代码："><a href="#38-现有如下代码：" class="headerlink" title="38.现有如下代码："></a>38.现有如下代码：</h1><pre><code>public class Example {  public static void main(String[] args) {  try {   int x=Integer.parseInt(&quot;42a&quot;);   //插入代码处   System.out.println(&quot;oops&quot;);  } }}在插入代码处插入哪些语句可以在运行后输出oops？A. } catch (IllegalArgumentException e) {B.} catch (IllegalStateException c) {C. } catch (NumbelFormatException n) {D.} catch (ClassCastException c) {答案：A、C</code></pre><h1 id="39-下列代码的执行结果是？"><a href="#39-下列代码的执行结果是？" class="headerlink" title="39.下列代码的执行结果是？"></a>39.下列代码的执行结果是？</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  int i = 1, j = 1;  try {   i++;   j--;   if (i == j) {    j++;   }  } catch (ArithmeticException e) {   System.out.println(0);  } catch (ArrayIndexOutOfBoundsException e) {   System.out.println(1);  } catch (Exception e) {   System.out.println(2);  } finally {   System.out.println(3);  }  System.out.println(4); }}A.输出1B.输出2C.输出3D.输出4答案：C、D</code></pre><h1 id="40-下列代码的执行结果是？"><a href="#40-下列代码的执行结果是？" class="headerlink" title="40.下列代码的执行结果是？"></a>40.下列代码的执行结果是？</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  int i = 1, j = 1;  try {   i++;   j--;   if (i/j &gt; 1) {    j++;   }  } catch (ArithmeticException e) {   System.out.println(0);  } catch (ArrayIndexOutOfBoundsException e) {   System.out.println(1);  } catch (Exception e) {   System.out.println(2);  } finally {   System.out.println(3);  }  System.out.println(4); }}A.输出0B.输出2C.输出3D.输出4答案：A、C、D</code></pre><h1 id="41-现有如下代码："><a href="#41-现有如下代码：" class="headerlink" title="41.现有如下代码："></a>41.现有如下代码：</h1><pre><code>public class Example {  public static void main(String[] args) {  try {   System.out.println(&quot;before&quot;);   doRisyThing();   System.out.println(&quot;after&quot;);  } catch (Exception e) {   System.out.println(&quot;catch&quot;);  }  System.out.println(&quot;done&quot;); } public static void doRisyThing() throws Exception{  //this code returns unless it throws an Exception }}该代码可能的执行结果有哪些？A.before catchB.before after doneC.before catch doneD.before after catch答案：B、C</code></pre><h1 id="42-以下有关java-lang-Exception异常类的正确描述有？"><a href="#42-以下有关java-lang-Exception异常类的正确描述有？" class="headerlink" title="42.以下有关java.lang.Exception异常类的正确描述有？"></a>42.以下有关java.lang.Exception异常类的正确描述有？</h1><pre><code>A.该类是一个公共类B.该类是Throwable类的子类C.该类实现了Throwable接口D.该类可以序列化答案：A、B、D</code></pre><h1 id="43-给出以下代码："><a href="#43-给出以下代码：" class="headerlink" title="43.给出以下代码："></a>43.给出以下代码：</h1><pre><code>1. public void aMethod(){  2.  3.  if(Condition){4.   5.  }6.  7. }当if条件表达式为true时，插入哪些语句可以抛出MyException异常？A.在第4行插入throws new MyException();B.在第4行插入throw new MyException();C.在第6行插入throw new MyException();D.在第1行插入throws MyException答案：B、D</code></pre><h1 id="44-以下哪些是catch语句能够捕获处理的异常？"><a href="#44-以下哪些是catch语句能够捕获处理的异常？" class="headerlink" title="44.以下哪些是catch语句能够捕获处理的异常？"></a>44.以下哪些是catch语句能够捕获处理的异常？</h1><pre><code>A.ThrowableB.ErrorC.ExceptionD.String答案：A、B、CError也是可以被catch捕获的</code></pre><h1 id="45-以下哪些描述是正确的？"><a href="#45-以下哪些描述是正确的？" class="headerlink" title="45.以下哪些描述是正确的？"></a>45.以下哪些描述是正确的？</h1><pre><code>A.try语句块后必须至少存在一个catch语句块B.try语句块后可以存在不限数量的finally语句块C.try语句块后必须至少存在一个catch语句块或finally语句块D.如果catch和finally语句块同时存在，则catch语句块必须位于finally语句块前答案：C、D</code></pre><h1 id="46-下列代码的执行结果是？"><a href="#46-下列代码的执行结果是？" class="headerlink" title="46.下列代码的执行结果是？"></a>46.下列代码的执行结果是？</h1><pre><code>class Example { private void method1() throws Exception {  throw new RuntimeException(); } public void method2() {  try {   method1();  } catch (RuntimeException e) {   System.out.println(&quot;Caught Runtime Exception&quot;);  } catch (Exception e) {   System.out.println(&quot;Caught Exception&quot;);  } } public static void main(String[] args) throws IOException {  Example a = new Example();  a.method2(); }}A.代码编译失败B.输出Caught Runtime ExceptionC.输出Caught ExceptionD.输出Caught Runtime Exception和Caught Exception答案：B</code></pre><h1 id="47-以下代码的输出结果是什么？选择所有的正确答案。"><a href="#47-以下代码的输出结果是什么？选择所有的正确答案。" class="headerlink" title="47.以下代码的输出结果是什么？选择所有的正确答案。"></a>47.以下代码的输出结果是什么？选择所有的正确答案。</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  for (int i = 0; i &lt; 10; i++) {   try {    try {     if (i % 3 == 0)      throw new Exception(&quot;E0&quot;);     System.out.println(i);    } catch (Exception inner) {     i *= 2;     if (i % 3 == 0)      throw new Exception(&quot;E1&quot;);    } finally {     ++i;    }   } catch (Exception outer) {    i += 3;   } finally {    --i;   }  } }}A.4.0B.5.0C.6.0D.7.0答案：A、B</code></pre><h1 id="48-Java中异常的分类"><a href="#48-Java中异常的分类" class="headerlink" title="48.Java中异常的分类"></a>48.Java中异常的分类</h1><pre><code>答案：java.lang.Throwable|-- Error错误：JVM内部的严重问题。无法恢复。程序人员不用处理。|--Exception异常：普通的问题。通过合理的处理，程序还可以回到正常执行流程。要求编程人员要进行处理。|--RuntimeException:也叫非受检异常(unchecked exception).这类异常是编程人员的逻辑问题。应该承担责任。Java编译器不进行强制要求处理。 也就是说，这类异常再程序中，可以进行处理，也可以不处理。|--非RuntimeException:也叫受检异常(checked exception).这类异常是由一些外部的偶然因素所引起的。Java编译器强制要求处理。也就是说，程序必须进行对这类异常进行处理。</code></pre><h1 id="49-给出常见的RuntimeException"><a href="#49-给出常见的RuntimeException" class="headerlink" title="49.给出常见的RuntimeException"></a>49.给出常见的RuntimeException</h1><pre><code>答案：常见的运行时异常有如下这些ArithmeticException, ArrayStoreException, BufferOverflowException, BufferUnderflowException, CannotRedoException, CannotUndoException, ClassCastException, CMMException, ConcurrentModificationException, DOMException, EmptyStackException, IllegalArgumentException, IllegalMonitorStateException, IllegalPathStateException, IllegalStateException, ImagingOpException, IndexOutOfBoundsException, MissingResourceException, NegativeArraySizeException, NoSuchElementException, NullPointerException, ProfileDataException, ProviderException, RasterFormatException, SecurityException, SystemException, UndeclaredThrowableException, UnmodifiableSetException, UnsupportedOperationException</code></pre><h1 id="50-error和exception有什么区别"><a href="#50-error和exception有什么区别" class="headerlink" title="50.error和exception有什么区别"></a>50.error和exception有什么区别</h1><pre><code>答案：error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况</code></pre><h1 id="51-以下代码的执行结果是？"><a href="#51-以下代码的执行结果是？" class="headerlink" title="51.以下代码的执行结果是？"></a>51.以下代码的执行结果是？</h1><pre><code>public static int fun() {  int result = 5;  try {   result = result / 0;   return result;  } catch (Exception e) {   System.out.println(&quot;Exception&quot;);   result = -1;   return result;  } finally {   result = 10;   System.out.println(&quot;i am in finally&quot;);  } } public static void main(String[] args) {  int x=fun();  System.out.println(x); }答案：ExceptionI am in finally-1</code></pre><h1 id="52-以下代码的执行结果是？"><a href="#52-以下代码的执行结果是？" class="headerlink" title="52.以下代码的执行结果是？"></a>52.以下代码的执行结果是？</h1><pre><code>public class Example { public static StringBuffer fun() {  StringBuffer result = new StringBuffer(&quot;Hello&quot;);  Integer i = new Integer(5);  try {   if (true)    throw new RuntimeException();   return result;  } catch (Exception e) {   System.out.println(&quot;Exception&quot;);   result.append(&quot; World&quot;);   return result;  } finally {   result.append(&quot; Java&quot;);   System.out.println(&quot;i am in finally&quot;);  } } public static void main(String[] args) {  StringBuffer x = fun();  System.out.println(x); }答案：Exceptioni am in finallyHello World Java</code></pre><h1 id="53-什么时候用assert"><a href="#53-什么时候用assert" class="headerlink" title="53.什么时候用assert?"></a>53.什么时候用assert?</h1><pre><code>答案：断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为 true。如果表达式计算为 false，那么系统会报告一个 Assertionerror。它用于调试目的：assert(a &gt; 0); // throws anAssertionerror if a &lt;= 0断言可以有两种形式：assert Expression1 ;assert Expression1 :Expression2 ;  Expression1 应该总是产生一个布尔值。  Expression2 可以是得出一个值的任意表达式。这个值用于生成显示更多调试信息的 String 消息。  断言在默认情况下是禁用的。要在编译时启用断言，需要使用 source 1.4 标记：  javac -source 1.4 Test.java  要在运行时启用断言，可使用 -enableassertions 或者 -ea 标记。  要在运行时选择禁用断言，可使用 -da 或者 -disableassertions 标记。  要系统类中启用断言，可使用 -esa 或者 -dsa 标记。还可以在包的基础上启用或者禁用断言。 可以在预计正常情况下不会到达的任何位置上放置断言。断言可以用于验证传递给私有方法的参数。不过，断言不应该用于验证传递给公有方法的参数，因为不管是否启用了断言，公有方法都必须检查其参数。不过，既可以在公有方法中，也可以在非公有方法中利用断言测试后置条件。另外，断言不应该以任何方式改变程序的状态。</code></pre><h1 id="54-给我一个你最常见到的runtime-exception"><a href="#54-给我一个你最常见到的runtime-exception" class="headerlink" title="54.给我一个你最常见到的runtime exception"></a>54.给我一个你最常见到的runtime exception</h1><pre><code>答案：常见的运行时异常有如下这些ArithmeticException, ArrayStoreException, BufferOverflowException, BufferUnderflowException, CannotRedoException, CannotUndoException, ClassCastException, CMMException, ConcurrentModificationException, DOMException, EmptyStackException, IllegalArgumentException, IllegalMonitorStateException, IllegalPathStateException, IllegalStateException, ImagingOpException, IndexOutOfBoundsException, MissingResourceException, NegativeArraySizeException, NoSuchElementException, NullPointerException, ProfileDataException, ProviderException, RasterFormatException, SecurityException, SystemException, UndeclaredThrowableException, UnmodifiableSetException, UnsupportedOperationException</code></pre><h1 id="55-谈谈final-finally-finalize的区别"><a href="#55-谈谈final-finally-finalize的区别" class="headerlink" title="55.谈谈final, finally, finalize的区别"></a>55.谈谈final, finally, finalize的区别</h1><pre><code>答案：final—修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载finally—再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）finalize—方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的</code></pre><h1 id="56-下列说法错误的是？"><a href="#56-下列说法错误的是？" class="headerlink" title="56.下列说法错误的是？"></a>56.下列说法错误的是？</h1><pre><code>A.Object类是所有Java类的顶层类，即类继承树的根。B.如果一个类没有使用extends关键字扩展任何类，则编译器自动将创建的类视为Object类的子类C.Object类中提供了equals()方法来判定本对象和其他对象中的内容是否一致D.Object中提供的clone默认为浅克隆答案：Cequals方法默认和==一致</code></pre><h1 id="57-定义在Object类上的hashCode-方法的返回值类型是什么？"><a href="#57-定义在Object类上的hashCode-方法的返回值类型是什么？" class="headerlink" title="57.定义在Object类上的hashCode()方法的返回值类型是什么？"></a>57.定义在Object类上的hashCode()方法的返回值类型是什么？</h1><pre><code>A.charB.longC.intD.float答案：C</code></pre><h1 id="58-关于集合中对象的equals-和hashCode-规定说法错误的是？"><a href="#58-关于集合中对象的equals-和hashCode-规定说法错误的是？" class="headerlink" title="58.关于集合中对象的equals()和hashCode()规定说法错误的是？"></a>58.关于集合中对象的equals()和hashCode()规定说法错误的是？</h1><pre><code>A.如果两个对象相同，那么他们的hashCode值需要一致B.如果两个对象的hashCode值一致，他们的equals方法不一定返回trueC.equals方法默认和==判定一致D.Java中hashCode就是对象的内存地址答案：DJava中hashCode不是内存地址，但是可以一定程度上代表地址特诊</code></pre><h1 id="59-以下代码执行结果是什么？"><a href="#59-以下代码执行结果是什么？" class="headerlink" title="59.以下代码执行结果是什么？"></a>59.以下代码执行结果是什么？</h1><pre><code>class Person { static void sayHello() {  System.out.println(&quot;HelloWorld!&quot;); }}public class Example { public static void main(String[] args) {  ((Person) null).sayHello(); }}A.编译失败B.编译成功，运行时产生NullPointerExceptionC.输出HelloWorld!D.输出空白字符串答案：Cnull能够被造型撑任何类型，而sayHello方法是静态方法，不依赖实例调用</code></pre><h1 id="60-下列代码执行结果是："><a href="#60-下列代码执行结果是：" class="headerlink" title="60.下列代码执行结果是："></a>60.下列代码执行结果是：</h1><pre><code>class RectObject { public int x; public int y; public RectObject(int x, int y) {  this.x = x;  this.y = y; } @Override public int hashCode() {  final int prime = 31;  int result = 1;  result = prime * result + x;  result = prime * result + y;  return result; } @Override public boolean equals(Object obj) {  if (this == obj)   return true;  if (obj == null)   return false;  if (getClass() != obj.getClass())   return false;  final RectObject other = (RectObject) obj;  if (x != other.x) {   return false;  }  if (y != other.y) {   return false;  }  return true; }}public class Example { public static void main(String[] args) {  HashSet&lt;RectObject&gt; set = new HashSet&lt;RectObject&gt;();  RectObject r1 = new RectObject(3, 3);  RectObject r2 = new RectObject(5, 5);  RectObject r3 = new RectObject(3, 3);  set.add(r1);  set.add(r2);  set.add(r3);  set.add(r1);  System.out.println(&quot;size:&quot; + set.size()); }}A.size:1B.size:2C.size:3D.size:4答案：B因为我们重写了RectObject类的hashCode方法，只要RectObject对象的x,y属性值相等那么他的hashCode值也是相等的，所以先比较hashCode的值，r1和r2对象的x,y属性值不等，所以他们的hashCode不相同的，所以r2对象可以放进去，但是r3对象的x,y属性值和r1对象的属性值相同的，所以hashCode是相等的，这时候在比较r1和r3的equals方法，因为他么两的x,y值是相等的，所以r1,r3对象是相等的，所以r3不能放进去了，同样最后再添加一个r1也是没有没有添加进去的，所以set集合中只有一个r1和r2这两个对象</code></pre><h1 id="61-以下代码的执行结果是？"><a href="#61-以下代码的执行结果是？" class="headerlink" title="61.以下代码的执行结果是？"></a>61.以下代码的执行结果是？</h1><pre><code>class RectObject { public int x; public int y; public RectObject(int x, int y) {  this.x = x;  this.y = y; } @Override public boolean equals(Object obj) {  if (this == obj)   return true;  if (obj == null)   return false;  if (getClass() != obj.getClass())   return false;  final RectObject other = (RectObject) obj;  if (x != other.x) {   return false;  }  if (y != other.y) {   return false;  }  return true; }}public class Example { public static void main(String[] args) {  HashSet&lt;RectObject&gt; set = new HashSet&lt;RectObject&gt;();  RectObject r1 = new RectObject(3, 3);  RectObject r2 = new RectObject(5, 5);  RectObject r3 = new RectObject(3, 3);  set.add(r1);  set.add(r2);  set.add(r3);  set.add(r1);  System.out.println(&quot;size:&quot; + set.size()); }}A.size:1B.size:2C.size:3D.size:4答案：C首先判断r1对象和r2对象的hashCode，因为Object中的hashCode方法返回的是对象本地内存地址的换算结果，不同的实例对象的hashCode是不相同的，同样因为r3和r1的hashCode也是不相等的，但是r1==r1的，所以最后set集合中只有r1,r2,r3这三个对象，所以大小是3</code></pre><h1 id="62-以下代码执行结果是？"><a href="#62-以下代码执行结果是？" class="headerlink" title="62.以下代码执行结果是？"></a>62.以下代码执行结果是？</h1><pre><code>class RectObject { public int x; public int y; public RectObject(int x, int y) {  this.x = x;  this.y = y; } @Override public boolean equals(Object obj) {  return false; }}public class Example { public static void main(String[] args) {  HashSet&lt;RectObject&gt; set = new HashSet&lt;RectObject&gt;();  RectObject r1 = new RectObject(3, 3);  RectObject r2 = new RectObject(5, 5);  RectObject r3 = new RectObject(3, 3);  set.add(r1);  set.add(r2);  set.add(r3);  set.add(r1);  System.out.println(&quot;size:&quot; + set.size()); }}A.size:1B.size:2C.size:3D.size:4答案：C首先是判断hashCode是否相等，不相等的话，直接跳过，相等的话，然后再来比较这两个对象是否相等或者这两个对象的equals方法，因为是进行的或操作，所以只要有一个成立即可，那这里我们就可以解释了，其实上面的那个集合的大小是3,因为最后的一个r1没有放进去，以为r1==r1返回true的，所以没有放进去了。所以集合的大小是3，如果我们将hashCode方法设置成始终返回false的话，这个集合就是4了。</code></pre><h1 id="63-以下代码执行结果是？"><a href="#63-以下代码执行结果是？" class="headerlink" title="63.以下代码执行结果是？"></a>63.以下代码执行结果是？</h1><pre><code>class RectObject { public int x; public int y; public RectObject(int x, int y) {  this.x = x;  this.y = y; } @Override public int hashCode() {  // TODO Auto-generated method stub  return (int)System.nanoTime(); } @Override public boolean equals(Object obj) {  return false; }}public class Example { public static void main(String[] args) {  HashSet&lt;RectObject&gt; set = new HashSet&lt;RectObject&gt;();  RectObject r1 = new RectObject(3, 3);  RectObject r2 = new RectObject(5, 5);  RectObject r3 = new RectObject(3, 3);  set.add(r1);  set.add(r2);  set.add(r3);  set.add(r1);  System.out.println(&quot;size:&quot; + set.size()); }}A.size:1B.size:2C.size:3D.size:4答案：D见上题</code></pre><h1 id="64-下列关于Math类说法错误的是"><a href="#64-下列关于Math类说法错误的是" class="headerlink" title="64.下列关于Math类说法错误的是"></a>64.下列关于Math类说法错误的是</h1><pre><code>A.java.lang.Math类是final类，因此不能被其他类继承B.java.lang.Math类的构造器是私有的，即声明为private，不能实例化一个Math类的对象C.java.lang.Math类上定义的所有常量和方法均是public和static的，因此可以直接通过类名调用D.min()和max()方法的参数之一，如果是NaN值，则方法将返回另一个参数值答案：Dmin()和max()方法的参数之一，如果是NaN值，则方法的返回值就为NaN</code></pre><h1 id="65-以下哪个方法是Math类中定义的？"><a href="#65-以下哪个方法是Math类中定义的？" class="headerlink" title="65.以下哪个方法是Math类中定义的？"></a>65.以下哪个方法是Math类中定义的？</h1><pre><code>A.absolute()B.log()C.cosine()D.sine()答案：B在Math类中对应的正确方法应为abs()\cos()\sin()</code></pre><h1 id="66-定义在Math类上的round-double-d-方法的返回值类型是什么？"><a href="#66-定义在Math类上的round-double-d-方法的返回值类型是什么？" class="headerlink" title="66.定义在Math类上的round(double d)方法的返回值类型是什么？"></a>66.定义在Math类上的round(double d)方法的返回值类型是什么？</h1><pre><code>A.charB.intC.longD.double答案：Cround方法用于获取一个四舍五入的整数</code></pre><h1 id="67-以下哪个方法用于计算平方根？"><a href="#67-以下哪个方法用于计算平方根？" class="headerlink" title="67.以下哪个方法用于计算平方根？"></a>67.以下哪个方法用于计算平方根？</h1><pre><code>A.squareRoot()B.sqrt()C.root()D.sqr()答案：B</code></pre><h1 id="68-调用Math-random-方法最有可能输出以下哪些结果？"><a href="#68-调用Math-random-方法最有可能输出以下哪些结果？" class="headerlink" title="68.调用Math.random()方法最有可能输出以下哪些结果？"></a>68.调用Math.random()方法最有可能输出以下哪些结果？</h1><pre><code>A.-0.12和0.56E3B.0.12和1.1E1C.-23.45和0.0D.0.356和0.03答案：Drandom()方法返回值的取值范围在0.0..1.0之间</code></pre><h1 id="69-以下代码的输出结果是什么？"><a href="#69-以下代码的输出结果是什么？" class="headerlink" title="69.以下代码的输出结果是什么？"></a>69.以下代码的输出结果是什么？</h1><pre><code>public class Example { public static void main(String[] args) {  System.out.println(Math.round(Float.MAX_VALUE)); }}A.输出Integer.MAX_VALUEB.输出一个最接近Float.MAX_VALUE的整数C.编译失败D.运行时输出异常信息答案：AMath.round(Float.MAX_VALUE)的返回值为Integer.MAX_VALUE，Math.round(Double.MAX_VALUE)的返回值为Long.MAX_VALUE（真实计算结果超过返回值范围）</code></pre><h1 id="70-以下代码的运行结果是什么？"><a href="#70-以下代码的运行结果是什么？" class="headerlink" title="70.以下代码的运行结果是什么？"></a>70.以下代码的运行结果是什么？</h1><pre><code>public class Example { public static void main(String[] args) {  System.out.println(Math.min(0.0, -0.0)); }}A.代码编译失败B.输出0.0C.输出-0.0D.代码编译成功，但运行时输出异常信息答案：C浮点数的取值范围内存在正负0.0</code></pre><h1 id="71-以下代码的执行结果是？"><a href="#71-以下代码的执行结果是？" class="headerlink" title="71.以下代码的执行结果是？"></a>71.以下代码的执行结果是？</h1><pre><code>public class Example { public static void main(String[] args) {  System.out.println(Math.min(0.0, -0.0)); }}A.输出4B.输出5C.输出6 D.输出9答案：D比2.3大的最接近整数是3，因此ceil(2.3f)=3.0，因为2.7的四舍五入的值为3.0，所以round(2.7)=3.0，最终打印输出等于9</code></pre><h1 id="72-以下代码的运行结果是什么？"><a href="#72-以下代码的运行结果是什么？" class="headerlink" title="72.以下代码的运行结果是什么？"></a>72.以下代码的运行结果是什么？</h1><pre><code>public class Example { public static void main(String[] args) {  double d1 = -0.5;  System.out.println(&quot;Ceil d1=&quot; + Math.ceil(d1));  System.out.println(&quot;Floor d1=&quot; + Math.floor(d1)); }}A.输出Ceil d1=-0.0 Floor d1=-1.0B.输出Ceil d1=0.0 Floor d1=-1.0C.输出Ceil d1=-0.0 Floor d1=-0.0D.输出Ceil d1=0.0 Floor d1=0.0答案：A</code></pre><h1 id="73-给出以下代码，为了结果输出-12-0，方法method-d-应为以下哪个方法？"><a href="#73-给出以下代码，为了结果输出-12-0，方法method-d-应为以下哪个方法？" class="headerlink" title="73.给出以下代码，为了结果输出-12.0，方法method(d)应为以下哪个方法？"></a>73.给出以下代码，为了结果输出-12.0，方法method(d)应为以下哪个方法？</h1><pre><code>public class Example { public static void main(String[] args) {  double d = -11.1;  double d1 = method(d);  System.out.println(d1); }}A.floor()B.ceil()C.round()D.abs()答案：A</code></pre><h1 id="74-给出以下代码，请问在程序的第6行插入那条语句，改程序可依次打印输出11、10、9？"><a href="#74-给出以下代码，请问在程序的第6行插入那条语句，改程序可依次打印输出11、10、9？" class="headerlink" title="74.给出以下代码，请问在程序的第6行插入那条语句，改程序可依次打印输出11、10、9？"></a>74.给出以下代码，请问在程序的第6行插入那条语句，改程序可依次打印输出11、10、9？</h1><pre><code>1.public class Example {2. public static void main(String[] args) {3.  double x[] = { 10.2, 9.1, 8.7 };4.  int i[] = new int[3];5.  for (int a = 0; a &lt; x.length; a++) {6.7.   System.out.println(i[a]);8.  }9. }10.}A.i[1] = ((int)Math.min(x[a]));B.i[1] = ((int)Math.max(x[a]));C.i[1] = ((int)Math.ceil(x[a]));D.i[1] = ((int)Math.floor(x[a]));答案：C</code></pre><h1 id="75-以下代码执行结果是？"><a href="#75-以下代码执行结果是？" class="headerlink" title="75.以下代码执行结果是？"></a>75.以下代码执行结果是？</h1><pre><code>public class Example { public static void main(String[] args) {  System.out.println(Math.min(Float.NaN, Float.POSITIVE_INFINITY)); }}A.输出NaNB.打印输出InfinityC.运行时异常，因为NaN不是有效的参数D.运行时异常，因为Infinity不是有效的参数答案：Amin()和max()方法的参数之一，如果是NaN值，则方法的返回值就为NaN</code></pre><h1 id="76-以下代码的执行结果是？"><a href="#76-以下代码的执行结果是？" class="headerlink" title="76.以下代码的执行结果是？"></a>76.以下代码的执行结果是？</h1><pre><code>public class Example{  public static void main(String s[]){   String str=”123”;String str_=new String(“123”);String  _str=”123”;   System.out.println(str==_str);System.out.println(str==str_);} }A.输出true trueB.输出false falseC.输出true falseD.输出false true答案：C字符串创建的时候可以使用常量池</code></pre><h1 id="77-public-class-Example"><a href="#77-public-class-Example" class="headerlink" title="77.public class Example {"></a>77.public class Example {</h1><pre><code> public static void main(String[] args) {  Integer i = 100;  Integer j = 100;  System.out.println(i == j);  i = 300;  j = 300;  System.out.println(i == j); }}A.输出true trueB.输出false falseC.输出true falseD.输出false true答案：C128以内的数进行自动包装时使用池操作</code></pre><h1 id="78-以下哪个不是基本类型的包装类？"><a href="#78-以下哪个不是基本类型的包装类？" class="headerlink" title="78.以下哪个不是基本类型的包装类？"></a>78.以下哪个不是基本类型的包装类？</h1><pre><code>A.CharB.IntegerC.BooleanD.float答案：A</code></pre><h1 id="79-以下说法正确的是？"><a href="#79-以下说法正确的是？" class="headerlink" title="79.以下说法正确的是？"></a>79.以下说法正确的是？</h1><pre><code>A.Void类是Class类的子类B.Float类是Double类的子类C.Double类是Wrapper类的子类D.Integer类是Number类的子类答案：D</code></pre><h1 id="80-定义在Integer类上的哪些方法用于将一个Integer对象转换为一个基本数据int类型？"><a href="#80-定义在Integer类上的哪些方法用于将一个Integer对象转换为一个基本数据int类型？" class="headerlink" title="80.定义在Integer类上的哪些方法用于将一个Integer对象转换为一个基本数据int类型？"></a>80.定义在Integer类上的哪些方法用于将一个Integer对象转换为一个基本数据int类型？</h1><pre><code>A.valueOf（）B.intValue（）C.getInt（）D.getInteger（）答案：B</code></pre><h1 id="81-一下代码的执行结果是什么？"><a href="#81-一下代码的执行结果是什么？" class="headerlink" title="81.一下代码的执行结果是什么？"></a>81.一下代码的执行结果是什么？</h1><pre><code>public class Example { public static void main(String[] args) {  String val = null;  int x = Integer.parseInt(val);  System.out.println(x); }}A.输出0B.输出nullC.输出NumberFormatException异常D.无内容输出答案：C</code></pre><h1 id="82-由于Java中存在字符串对象池，因此采用下面方法创建的两个字符串变量，他们指向的是同一个字符串对象：String-str1-”asddsg”-String-str2-”asddsg”"><a href="#82-由于Java中存在字符串对象池，因此采用下面方法创建的两个字符串变量，他们指向的是同一个字符串对象：String-str1-”asddsg”-String-str2-”asddsg”" class="headerlink" title="82.由于Java中存在字符串对象池，因此采用下面方法创建的两个字符串变量，他们指向的是同一个字符串对象：String str1=”asddsg”;String str2=”asddsg”"></a>82.由于Java中存在字符串对象池，因此采用下面方法创建的两个字符串变量，他们指向的是同一个字符串对象：String str1=”asddsg”;String str2=”asddsg”</h1><pre><code>A.调用字符串上定义的改变字符串内容的方法，返回值都是一个新字符串，而原有字符串内容不变B.调用replace（char oldChar,char newChar）方法时，当参数oldChar和newChar一致时，返回一个和源对象内容一致的新字符串C.String的equals方法用于判定两个字符串内容是否一致D.调用toUpperCase()和toLowerCase()方法，当为进行大小写转换时，返回源字符串对象答案：B调用replace（char oldChar,char newChar）方法时，当参数oldChar和newChar一致时，返回源字符串对象</code></pre><h1 id="83-以下说法错误的是？"><a href="#83-以下说法错误的是？" class="headerlink" title="83.以下说法错误的是？"></a>83.以下说法错误的是？</h1><pre><code>A.String中的append方法用于在源字符串后追加内容B.StringBuffer中的append方法用于在源字符串后追加内容C.StringBuffer是一个缓冲区，器内容可变D.String中的concat方法用于字符串串联答案：AString中没有append方法</code></pre><h1 id="84-以下哪些有关通过子类来扩展String类功能的描述是正确的？"><a href="#84-以下哪些有关通过子类来扩展String类功能的描述是正确的？" class="headerlink" title="84.以下哪些有关通过子类来扩展String类功能的描述是正确的？"></a>84.以下哪些有关通过子类来扩展String类功能的描述是正确的？</h1><pre><code>A.无法子类化，因为String类是一个final类B.可以子类化，通过覆盖String类中的方法实现功能扩展C.无法子类化，因为String类是一个抽象类D.可以子类化，但是只能覆盖Object类中声明的方法，因为String类中定义的其他方法否是final的答案：A</code></pre><h1 id="85-嗲用以下哪个方法会导致字符串被改变？"><a href="#85-嗲用以下哪个方法会导致字符串被改变？" class="headerlink" title="85.嗲用以下哪个方法会导致字符串被改变？"></a>85.嗲用以下哪个方法会导致字符串被改变？</h1><pre><code>A.concat()B.toUpperCase()C.replace()D.没有改变字符串的方法可以调用答案：D</code></pre><h1 id="86-如何获取一个String类实例S包含的字符个数？"><a href="#86-如何获取一个String类实例S包含的字符个数？" class="headerlink" title="86.如何获取一个String类实例S包含的字符个数？"></a>86.如何获取一个String类实例S包含的字符个数？</h1><pre><code>A.s.sizeB.s.lengthC.s.size()D.s.length()答案：D</code></pre><h1 id="87-以下代码执行结果是？"><a href="#87-以下代码执行结果是？" class="headerlink" title="87.以下代码执行结果是？"></a>87.以下代码执行结果是？</h1><pre><code>public class Example { public static void main(String[] args) {  System.out.println(&quot;string&quot;.endsWith(&quot;&quot;)); }}A.输出trueB.输出falseC.编译失败D.运行时输出异常信息答案：A</code></pre><h1 id="88-有String-s-“Metallica”-请问以下哪个语句可以打印输出ica？"><a href="#88-有String-s-“Metallica”-请问以下哪个语句可以打印输出ica？" class="headerlink" title="88.有String s = “Metallica”;请问以下哪个语句可以打印输出ica？"></a>88.有String s = “Metallica”;请问以下哪个语句可以打印输出ica？</h1><pre><code>A.System.out.println(s.substring(7));B.System.out.println(s.substring(6));C.System.out.println(s.substring(6，8));D.System.out.println(s.substring(7，9));答案：B</code></pre><h1 id="89-以下那些关于String类的描述是正确的？"><a href="#89-以下那些关于String类的描述是正确的？" class="headerlink" title="89.以下那些关于String类的描述是正确的？"></a>89.以下那些关于String类的描述是正确的？</h1><pre><code>A.该类是一个final类B.该类是一个public类C.该类可以序列化D.该类有一个一StringBuffer实例作为参数的构造器答案：A、B、C、D</code></pre><h1 id="90-以下哪些是String类中定义的方法？"><a href="#90-以下哪些是String类中定义的方法？" class="headerlink" title="90.以下哪些是String类中定义的方法？"></a>90.以下哪些是String类中定义的方法？</h1><pre><code>A.length（）B.toUpper()C.toString()D.equals()答案：A、C、D</code></pre><h1 id="91-以下哪些关于封装类的描述是正确的？"><a href="#91-以下哪些关于封装类的描述是正确的？" class="headerlink" title="91.以下哪些关于封装类的描述是正确的？"></a>91.以下哪些关于封装类的描述是正确的？</h1><pre><code>A.封装类都是public类B.封装类均可序列化C.封装类均是final类D.封装类都是java.lang.Number类的子类答案：A、B、C</code></pre><h1 id="92-请问以下哪些方法是定义在Object类上的，请选择所有正确答案"><a href="#92-请问以下哪些方法是定义在Object类上的，请选择所有正确答案" class="headerlink" title="92.请问以下哪些方法是定义在Object类上的，请选择所有正确答案"></a>92.请问以下哪些方法是定义在Object类上的，请选择所有正确答案</h1><pre><code>A.toString()B.equals(Object o)C.println()D.wait()答案：A、B、D</code></pre><h1 id="93-请问以下哪些描述是正确的？请选择所有正确答案"><a href="#93-请问以下哪些描述是正确的？请选择所有正确答案" class="headerlink" title="93.请问以下哪些描述是正确的？请选择所有正确答案"></a>93.请问以下哪些描述是正确的？请选择所有正确答案</h1><pre><code>A.Class类是Object类的超类B.Object类是一个final类C.Class类可用于装载其他类D.ClassLoader类可用于装载其他类答案：C、D</code></pre><h1 id="94-给出以下代码，请问以下哪些定义在Math类上的方法可以使表达式结果为true"><a href="#94-给出以下代码，请问以下哪些定义在Math类上的方法可以使表达式结果为true" class="headerlink" title="94.给出以下代码，请问以下哪些定义在Math类上的方法可以使表达式结果为true?"></a>94.给出以下代码，请问以下哪些定义在Math类上的方法可以使表达式结果为true?</h1><pre><code>Method(-4.4) == -4A.round()B.trunc()C.floor()D.ceil()答案：A、D</code></pre><h1 id="95-下面这条语句一共创建了多少个对象：String-s-”a”-”b”-”c”-”d”"><a href="#95-下面这条语句一共创建了多少个对象：String-s-”a”-”b”-”c”-”d”" class="headerlink" title="95.下面这条语句一共创建了多少个对象：String s=”a”+”b”+”c”+”d”;"></a>95.下面这条语句一共创建了多少个对象：String s=”a”+”b”+”c”+”d”;</h1><pre><code>一个字符串对象和一个指向这个对象的引用对于如下代码：Strings1 = &quot;a&quot;;Strings2 = s1 + &quot;b&quot;;Strings3 = &quot;a&quot; + &quot;b&quot;;System.out.println(s2== &quot;ab&quot;);System.out.println(s3== &quot;ab&quot;);答案：第一条语句打印的结果为false，第二条语句打印的结果为true，这说明javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串，所以，上面的代码应该只创建了一个String对象和一个指向该对象的饮用。写如下两行代码，               String s = &quot;a&quot; +&quot;b&quot; + &quot;c&quot; + &quot;d&quot;;               System.out.println(s ==&quot;abcd&quot;);  最终打印的结果应该为true。</code></pre><h1 id="96-以下代码的执行结果是？"><a href="#96-以下代码的执行结果是？" class="headerlink" title="96.以下代码的执行结果是？"></a>96.以下代码的执行结果是？</h1><pre><code>class ShadowClone implements Cloneable { private int a; private int[] b; @Override public Object clone() {  ShadowClone sc = null;  try {   sc = (ShadowClone) super.clone();  } catch (CloneNotSupportedException e) {   e.printStackTrace();  }  return sc; } public int getA() {  return a; } public void setA(int a) {  this.a = a; } public int[] getB() {  return b; } public void setB(int[] b) {  this.b = b; }}public class Example { public static void main(String[] args) {  ShadowClone c1 = new ShadowClone();  c1.setA(100);  c1.setB(new int[] { 1000 });  System.out.println(&quot;克隆前c1:  a=&quot; + c1.getA() + &quot; b[0]=&quot; + c1.getB()[0]);  ShadowClone c2 = (ShadowClone) c1.clone();  c2.setA(50);  int[] a = c2.getB();  a[0] = 5;  c2.setB(a);  System.out.println(&quot;克隆后c1:  a=&quot; + c1.getA() + &quot; b[0]=&quot; + c1.getB()[0]);  System.out.println(&quot;克隆后c2:  a=&quot; + c2.getA() + &quot; b[0]=&quot; + c2.getB()[0]); }}答案：克隆前c1:  a=100 b[0]=1000克隆后c1:  a=100 b[0]=5克隆后c2:  a=50 b[0]=5Java中Object类提供的克隆方法默认为浅克隆，因此克隆后的引用属性和原始对象中的引用属性引用了同一对象，对克隆对象中引用数据的变更就直接反映到原始对象中</code></pre><h1 id="97-以下代码的执行结果是？"><a href="#97-以下代码的执行结果是？" class="headerlink" title="97.以下代码的执行结果是？"></a>97.以下代码的执行结果是？</h1><pre><code>class DeepClone implements Cloneable { private int a; private int[] b; @Override public Object clone() {  DeepClone sc = null;  try {   sc = (DeepClone) super.clone();   int[] t = sc.getB();   int[] b1 = new int[t.length];   for (int i = 0; i &lt; b1.length; i++) {    b1[i] = t[i];   }   sc.setB(b1);  } catch (CloneNotSupportedException e) {   e.printStackTrace();  }  return sc; } public int getA() {  return a; } public void setA(int a) {  this.a = a; } public int[] getB() {  return b; } public void setB(int[] b) {  this.b = b; }}public class Example { public static void main(String[] args) {  DeepClone c1 = new DeepClone();  c1.setA(100);  c1.setB(new int[] { 1000 });  System.out.println(&quot;克隆前c1:  a=&quot; + c1.getA() + &quot; b[0]=&quot; + c1.getB()[0]);  DeepClone c2 = (DeepClone) c1.clone();  c2.setA(50);  int[] a = c2.getB();  a[0] = 5;  c2.setB(a);  System.out.println(&quot;克隆后c1:  a=&quot; + c1.getA() + &quot; b[0]=&quot; + c1.getB()[0]);  System.out.println(&quot;克隆后c2:  a=&quot; + c2.getA() + &quot; b[0]=&quot; + c2.getB()[0]); }}答案：克隆前c1:  a=100 b[0]=1000克隆后c1:  a=100 b[0]=1000克隆后c2:  a=50 b[0]=5自定义的深度克隆</code></pre><h1 id="98-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对"><a href="#98-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对" class="headerlink" title="98.两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对"></a>98.两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对</h1><pre><code>答案：不对，有相同的hash code</code></pre><h1 id="99-覆盖equals-方法时需要注意的设计原则有哪些？"><a href="#99-覆盖equals-方法时需要注意的设计原则有哪些？" class="headerlink" title="99.覆盖equals()方法时需要注意的设计原则有哪些？"></a>99.覆盖equals()方法时需要注意的设计原则有哪些？</h1><pre><code>答案：对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。反射性：x.equals(x)必须返回是“true”。类推性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。 </code></pre><h1 id="100-equals方法和-的区别"><a href="#100-equals方法和-的区别" class="headerlink" title="100.equals方法和==的区别"></a>100.equals方法和==的区别</h1><pre><code>答案：1.基本数据类型，也称原始数据类型。byte,short,char,int,long,float,double,boolean  他们之间的比较，应用双等号（==）,比较的是他们的值。2.复合数据类型(类)  当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地 址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。  对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（==）进行比较的，所以比较后的结果跟双等号（==）的结果相同。 </code></pre><h1 id="101-String、StringBuffer、StringBuilder有什么区别？"><a href="#101-String、StringBuffer、StringBuilder有什么区别？" class="headerlink" title="101.String、StringBuffer、StringBuilder有什么区别？"></a>101.String、StringBuffer、StringBuilder有什么区别？</h1><pre><code>答案：String类表示内容不可改变的字符串。而StringBuffer类表示内容可以被修改的字符串。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。另外，String实现了equals方法，new String(“abc”).equals(new String(“abc”)的结果为true,而StringBuffer没有实现equals方法，所以，new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为false。StringBuffer和StringBuilder类都表示内容可以被修改的字符串，StringBuilder是线程不安全的，运行效率高，如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用StringBuilder。如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用StringBuffer。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-以下哪个是finalize-方法的正确形式？&quot;&gt;&lt;a href=&quot;#1-以下哪个是finalize-方法的正确形式？&quot; class=&quot;headerlink&quot; title=&quot;1.以下哪个是finalize()方法的正确形式？&quot;&gt;&lt;/a&gt;1.以下哪个是finali
      
    
    </summary>
    
    
      <category term="java" scheme="http://iwantjingjing.com/categories/java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="面试" scheme="http://iwantjingjing.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql优化</title>
    <link href="http://iwantjingjing.com/2020/04/16/mysql%E4%BC%98%E5%8C%96/"/>
    <id>http://iwantjingjing.com/2020/04/16/mysql%E4%BC%98%E5%8C%96/</id>
    <published>2020-04-16T10:22:32.000Z</published>
    <updated>2020-04-16T10:27:54.017Z</updated>
    
    <content type="html"><![CDATA[<p>所谓超级读书法就是，读一段不会则停下来把之前的内容再读一遍，以此类推<br>                                                            ——费曼<br>孔子曰：温故而知新可以为师已<br>不知谁说的： 读书百遍，其义自见</p><p>mysql优化</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="两个瓶颈"><a href="#两个瓶颈" class="headerlink" title="两个瓶颈"></a>两个瓶颈</h2><pre><code>CPU    CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候。I/O    磁盘I/O瓶颈发生在装入数据远大于内存容量的时候    应用分布在网络上，那么查询量相当大的时候那么平瓶颈就会出现在网络上。</code></pre><h2 id="如何查看系统性能"><a href="#如何查看系统性能" class="headerlink" title="如何查看系统性能"></a>如何查看系统性能</h2><pre><code>mpstatiostatsarvmstat</code></pre><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><pre><code>1 什么是索引    加速查询最好的方法就是索引。    类似于图书的目录2.索引类型     普通索引            是最基本的索引，它没有任何限制。     唯一索引            与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。     组合索引            指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。     主键索引            是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引     全文索引            主要用来查找文本中的关键字，而不是直接与索引中的值相比较            它更像是一个搜索引擎            fulltext索引配合match against操作使用            可以在create table，alter table ，create index使用            目前只有char、varchar，text 列上可以创建全文索引            先插入数据再建索引比建表时先建索引再插入数据效率高3.索引优化    1 只要列中含有NULL值，就最好不要在此例设置索引，复合索引如果有NULL值，此列在使用时也不会使用索引     2 尽量使用短索引，如果可以，应该制定一个前缀长度     3 对于经常在where子句使用的列，最好设置索引，这样会加快查找速度     4 对于有多个列where或者order by子句的，应该建立复合索引     5 对于like语句，以%或者‘-’开头的不会使用索引，以%结尾会使用索引     6 尽量不要在列上进行运算（函数操作和表达式操作）     7 尽量不要使用not in和&lt;&gt;操作</code></pre><h2 id="SQL慢查询的优化"><a href="#SQL慢查询的优化" class="headerlink" title="SQL慢查询的优化"></a>SQL慢查询的优化</h2><pre><code>1.如何捕获低效sql    1）slow_query_log            这个参数设置为ON，可以捕获执行时间超过一定数值的SQL语句。    2）ong_query_time            当SQL语句执行时间超过此数值时，就会被记录到日志中，建议设置为1或者更短。    3）slow_query_log_file            记录日志的文件名。    4）log_queries_not_using_indexes            这个参数设置为ON，可以捕获到所有未使用索引的SQL语句，尽管这个SQL语句有可能执行得挺快。2.慢查询优化的基本步骤    1)先运行看看是否真的很慢，注意设置SQL_NO_CACHE    2）where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高    3)explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）    4)order by limit 形式的sql语句让排序的表优先查    5)了解业务方使用场景    6)加索引时参照建索引的几大原则    7)观察结果，不符合预期继续从1开始分析2.优化原则     1查询时，能不要*就不用*，尽量写全字段名     2 大部分情况连接效率远大于子查询     3 多使用explain和profile分析查询语句     4 查看慢查询日志，找出执行时间长的sql语句优化     5 多表连接时，尽量小表驱动大表，即小表 join 大表    6  在千万级分页时使用limit    7  对于经常使用的查询，可以开启缓存</code></pre><h2 id="数据库表优化"><a href="#数据库表优化" class="headerlink" title="数据库表优化"></a>数据库表优化</h2><pre><code>1 表的字段尽可能用NOT NULL2 字段长度固定的表查询会更快3 把数据库的大表按时间或一些标志分成小表4 将表拆分    水平切分:将记录散列到不同的表中，各表的结构完全相同，每次从分表中查询, 提高效率。    垂直切分:将表中大字段单独拆分到另外一张表, 形成一对一的关系。</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><pre><code>索引的优化  sql语句的优化  表的优化  在高并发网络环境下，除了优化数据库外，还会涉及到分布式缓存，CDN，数据库读写分离等高并发优化技术mysql优化18条  1 只要列中含有NULL值，就最好不要在此例设置索引，复合索引如果有NULL值，此列在使用时也不会使用索引   2 尽量使用短索引，如果可以，应该制定一个前缀长度   3 对于经常在where子句使用的列，最好设置索引，这样会加快查找速度   4 对于有多个列where或者order by子句的，应该建立复合索引   5 对于like语句，以%或者‘-’开头的不会使用索引，以%结尾会使用索引   6 尽量不要在列上进行运算（函数操作和表达式操作）   7 尽量不要使用not in和&lt;&gt;操作   1查询时，能不要*就不用*，尽量写全字段名   2 大部分情况连接效率远大于子查询   3 多使用explain和profile分析查询语句   4 查看慢查询日志，找出执行时间长的sql语句优化   5 多表连接时，尽量小表驱动大表，即小表 join 大表  6  在千万级分页时使用limit  7  对于经常使用的查询，可以开启缓存  1 表的字段尽可能用NOT NULL  2 字段长度固定的表查询会更快  3 把数据库的大表按时间或一些标志分成小表  4 将表拆分    水平切分:将记录散列到不同的表中，各表的结构完全相同，每次从分表中查询, 提高效率。    垂直切分:将表中大字段单独拆分到另外一张表, 形成一对一的关系。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所谓超级读书法就是，读一段不会则停下来把之前的内容再读一遍，以此类推&lt;br&gt;                                                            ——费曼&lt;br&gt;孔子曰：温故而知新可以为师已&lt;br&gt;不知谁说的： 读书百遍，其
      
    
    </summary>
    
    
      <category term="面试" scheme="http://iwantjingjing.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试，mysql" scheme="http://iwantjingjing.com/tags/%E9%9D%A2%E8%AF%95%EF%BC%8Cmysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql面试题</title>
    <link href="http://iwantjingjing.com/2020/04/16/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://iwantjingjing.com/2020/04/16/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-04-16T10:13:26.000Z</published>
    <updated>2020-04-19T09:33:56.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL的复制原理以及流程"><a href="#MySQL的复制原理以及流程" class="headerlink" title="MySQL的复制原理以及流程"></a>MySQL的复制原理以及流程</h1><pre><code>基本原理流程，3个线程以及之间的关联；  主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；  从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；  从：sql执行线程——执行relay log中的语句；</code></pre><h1 id="MySQL中myisam与innodb的区别，至少5点"><a href="#MySQL中myisam与innodb的区别，至少5点" class="headerlink" title="MySQL中myisam与innodb的区别，至少5点"></a>MySQL中myisam与innodb的区别，至少5点</h1><pre><code>5点不同  1&gt;.InnoDB支持事物，而MyISAM不支持事物  2&gt;.InnoDB支持行级锁，而MyISAM支持表级锁  3&gt;.InnoDB支持MVCC, 而MyISAM不支持      MVCC是版本控制？  4&gt;.InnoDB支持外键，而MyISAM不支持  5&gt;.InnoDB不支持全文索引，而MyISAM支持。 innodb引擎的4大特性  插入缓冲（insert buffer)  二次写(double write)  自适应哈希索引(ahi)  预读(read ahead)2者selectcount(*)哪个更快，为什么  myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</code></pre><h1 id="MySQL中varchar与char的区别以及varchar-50-中的50代表的涵义"><a href="#MySQL中varchar与char的区别以及varchar-50-中的50代表的涵义" class="headerlink" title="MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义"></a>MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义</h1><pre><code>(1)、varchar与char的区别  char是一种固定长度的类型  varchar则是一种可变长度的类型(2)、varchar(50)中50的涵义  最多存放50个字符  varchar(50)和(200)存储hello所占空间一样  但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)(3)、int（20）中20的涵义  是指显示字符的长度  要加参数的，最大为255  比如它是记录行数的id,插入10笔资料，它就显示00000000001 ~~~00000000010，当字符的位数超过11,它也只显示11位，如果你没有加那个让它未满11位就前面加0的参数，它不会在前面加0  20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；(4)、mysql为什么这么设计  对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；</code></pre><h1 id="问了innodb的事务与日志的实现方式"><a href="#问了innodb的事务与日志的实现方式" class="headerlink" title="问了innodb的事务与日志的实现方式"></a>问了innodb的事务与日志的实现方式</h1><pre><code>(1)、有多少种日志；  错误日志：记录出错信息，也记录一些警告信息或者正确的信息。  查询日志：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。  慢查询日志：设置一个阈(yu)值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。  二进制日志：记录对数据库执行更改的所有操作。  中继日志：中继日志也是二进制日志，用来给slave 库恢复  事务日志：重做日志redo和回滚日志undo(2)、事物的4种隔离级别  读未提交(RU)        read uncommited ：读到未提交数据  读已提交(RC)        read committed：脏读，不可重复读  可重复读(RR)        repeatable read：可重读  串行        serializable ：串行事物(3)、事务是如何通过日志来实现的，说得越深入越好。  事务日志是通过redo和innodb的存储引擎日志缓冲（Innodb log buffer）来实现的  当开始一个事务的时候，会记录该事务的lsn(log sequence number)号;  当事务执行时，会往InnoDB存储引擎的日志的日志缓存里面插入事务日志；  当事务提交时，必须将存储引擎的日志缓冲写入磁盘（通过innodb_flush_log_at_trx_commit来控制），也就是写数据前，需要先写日志。这种方式称为“预写日志方式”</code></pre><h1 id="MySQL-binlog的几种日志录入格式以及区别"><a href="#MySQL-binlog的几种日志录入格式以及区别" class="headerlink" title="MySQL binlog的几种日志录入格式以及区别"></a>MySQL binlog的几种日志录入格式以及区别</h1><pre><code>Statement：每一条会修改数据的sql都会记录在binlog中。  优点      不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。  缺点      由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的 一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同 的结果。      使用以下函数的语句也有问题：              sleep()函数              last_insert_id()              user-defined functions(udf)              LOAD_FILE()              UUID()              USER()              FOUND_ROWS()              SYSDATE() (除非启动时启用了 --sysdate-is-now 选项)      同时在INSERT …SELECT 会产生比 RBR 更多的行级锁Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改。  优点      binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了      rowlevel的日志内容会非常清楚的记录下 每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题  缺点      可能会产生大量的日志内容Mixedlevel: 是以上两种level的混合使用  一般的语句修改使用statment格式保存binlog  一些函数，statement无法完成主从复制的操作，则 采用row格式保存binlog</code></pre><h1 id="MySQL数据库cpu飙升到500-的话他怎么处理？"><a href="#MySQL数据库cpu飙升到500-的话他怎么处理？" class="headerlink" title="MySQL数据库cpu飙升到500%的话他怎么处理？"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h1><pre><code>1、列出所有进程 show processlist,观察所有进程 ,多秒没有状态变化的(干掉)2、查看超时日志或者错误日志 (做了几年开发,一般会是查询以及大批量的插入会导致cpu与i/o上涨,当然不排除网络状态突然断了,导致一个请求服务器只接受到一半，比如where子句或分页子句没有发送,,当然的一次被坑经历)</code></pre><h1 id="sql优化各种方法"><a href="#sql优化各种方法" class="headerlink" title="sql优化各种方法"></a>sql优化各种方法</h1><pre><code>(1)、explain出来的各种item的意义；  select_type      表示查询中每个select子句的类型  type      表示MySQL在表中找到所需行的方式，又称“访问类型”  possible_keys      指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用  key      显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL  key_len      表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度  ref      表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值  Extra      包含不适合在其他列中显示但十分重要的额外信息(2)、profile的意义以及使用场景；  查询到 SQL 会执行多少时间, 并看出 CPU/Memory 使用量, 执行过程中 Systemlock, Table lock 花多少时间等等</code></pre><h1 id="备份计划，mysqldump以及xtranbackup的实现原理"><a href="#备份计划，mysqldump以及xtranbackup的实现原理" class="headerlink" title="备份计划，mysqldump以及xtranbackup的实现原理"></a>备份计划，mysqldump以及xtranbackup的实现原理</h1><pre><code>(1)、备份计划；  这里每个公司都不一样，您别说那种1小时1全备什么的就行(2)、备份恢复时间；  这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考      20G的2分钟（mysqldump）      80G的30分钟(mysqldump)      111G的30分钟（mysqldump)      288G的3小时（xtra)      3T的4小时（xtra)      逻辑导入时间一般是备份时间的5倍以上(3)、xtrabackup实现原理  在InnoDB内部会维护一个redo日志文件，我们也可以叫做事务日志文件  事务日志会存储每一个InnoDB表数据的记录修改。  当InnoDB启动时，InnoDB会检查数据文件和事务日志，并执行两个步骤：它应用（前滚）已经提交的事务日志到数据文件，并将修改过但没有提交的数据进行回滚操作。</code></pre><h1 id="500台db，在最快时间之内重启"><a href="#500台db，在最快时间之内重启" class="headerlink" title="500台db，在最快时间之内重启"></a>500台db，在最快时间之内重启</h1><pre><code>使用批量 ssh 工具 pssh 来对需要重启的机器执行重启命令。 也可以使用 salt（前提是客户端有安装 salt）或者 ansible（ ansible 只需要 ssh 免登通了就行）等多线程工具同时操作多台服务器</code></pre><h1 id="innodb的读写参数优化"><a href="#innodb的读写参数优化" class="headerlink" title="innodb的读写参数优化"></a>innodb的读写参数优化</h1><pre><code>(1)、读取参数  global buffer pool以及 local buffer；(2)、写入参数；  innodb_flush_log_at_trx_commit  innodb_buffer_pool_size(3)、与IO相关的参数；  innodb_write_io_threads = 8  innodb_read_io_threads = 8  innodb_thread_concurrency = 0(4)、缓存参数以及缓存的适用场景。  query cache/query_cache_type  并不是所有表都适合使用query cache。造成query cache失效的原因主要是相应的table发生了变更  第一个：读操作多的话看看比例，简单来说，如果是用户清单表，或者说是数据比例比较固定，比如说商品列表，是可以打开的，前提是这些库比较集中，数据库中的实务比较小。  第二个：我们“行骗”的时候，比如说我们竞标的时候压测，把query cache打开，还是能收到qps激增的效果，当然前提示前端的连接池什么的都配置一样。大部分情况下如果写入的居多，访问量并不多，那么就不要打开，例如社交网站的，10%的人产生内容，其余的90%都在消费，打开还是效果很好的，但是你如果是qq消息，或者聊天，那就很要命。  第三个：小网站或者没有高并发的无所谓，高并发下，会看到 很多 qcache 锁 等待，所以一般高并发下，不建议打开query cache</code></pre><h1 id="你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？"><a href="#你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？" class="headerlink" title="你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？"></a>你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？</h1><pre><code>监控的工具有很多，例如zabbix，lepus，我这里用的是lepus</code></pre><h1 id="你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？"><a href="#你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？" class="headerlink" title="你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？"></a>你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？</h1><pre><code>主从一致性校验有多种工具 例如checksum、mysqldiff、pt-table-checksum等checksummysqldiffpt-table-checksum</code></pre><h1 id="你们数据库是否支持emoji表情，如果不支持，如何操作？"><a href="#你们数据库是否支持emoji表情，如果不支持，如何操作？" class="headerlink" title="你们数据库是否支持emoji表情，如果不支持，如何操作？"></a>你们数据库是否支持emoji表情，如果不支持，如何操作？</h1><pre><code>如果是utf8字符集的话，需要升级至utf8_mb4方可支持utf8_mb4</code></pre><h1 id="你是如何维护数据库的数据字典的？"><a href="#你是如何维护数据库的数据字典的？" class="headerlink" title="你是如何维护数据库的数据字典的？"></a>你是如何维护数据库的数据字典的？</h1><pre><code>一般是直接在生产库进行注释，利用工具导出成excel方便流通</code></pre><h1 id="表中有大字段X-例如：text类型-，且字段X不会经常更新，以读为为主，请问"><a href="#表中有大字段X-例如：text类型-，且字段X不会经常更新，以读为为主，请问" class="headerlink" title="表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为为主，请问"></a>表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为为主，请问</h1><pre><code>拆带来的问题：连接消耗 + 存储拆分空间不拆可能带来的问题：查询性能；如果能容忍拆分带来的空间问题,拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区) 顺序IO,减少连接消耗,最后这是一个文本列再加上一个全文索引来尽量抵消连接消耗如果能容忍不拆分带来的查询性能损失的话:上面的方案在某个极致条件下肯定会出现问题,那么不拆就是最好的选择</code></pre><h1 id="MySQL中InnoDB引擎的行锁是通过加在什么上完成-或称实现-的？为什么是这样子的？"><a href="#MySQL中InnoDB引擎的行锁是通过加在什么上完成-或称实现-的？为什么是这样子的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？"></a>MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？</h1><pre><code>InnoDB是基于索引来完成行锁例: select * from tab_with_index where id = 1 for update;for update 可以根据条件来完成行锁锁定,并且 id 是有索引键的列,如果 id 不是索引键那么InnoDB将完成表锁,,并发将无从谈起</code></pre><h1 id="开放性问题：据说是腾讯的"><a href="#开放性问题：据说是腾讯的" class="headerlink" title="开放性问题：据说是腾讯的"></a>开放性问题：据说是腾讯的</h1><pre><code>一个6亿的表a，一个3亿的表b，通过外键tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。  1、如果A表TID是自增长,并且是连续的,B表的ID为索引  select * from a,b where a.tid = b.id and a.tid&gt;500000 limit 200;  2、如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。  select * from b , (select tid from a limit 50000,200) a where b.id = a .tid;</code></pre><h1 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a>什么是存储过程？有哪些优缺点？</h1><pre><code>存储过程是一些预编译的SQL语句。1、更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。2、存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全</code></pre><h1 id="索引有哪些数据结构"><a href="#索引有哪些数据结构" class="headerlink" title="索引有哪些数据结构"></a>索引有哪些数据结构</h1><pre><code>Hash、B+去创建索引的时候，可以选择索引的类型</code></pre><h1 id="索引是什么？有什么作用以及优缺点？"><a href="#索引是什么？有什么作用以及优缺点？" class="headerlink" title="索引是什么？有什么作用以及优缺点？"></a>索引是什么？有什么作用以及优缺点？</h1><pre><code>1、索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构2、索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。MySQL数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引  1、索引加快数据库的检索速度  2、索引降低了插入、删除、修改等维护任务的速度  3、唯一索引可以确保每一行数据的唯一性  4、通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能  5、索引需要占物理和数据空间</code></pre><h1 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h1><pre><code>事务（Transaction）是并发控制的基本单位。它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。</code></pre><h1 id="使用索引查询一定能提高查询的性能吗？为什么"><a href="#使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="使用索引查询一定能提高查询的性能吗？为什么"></a>使用索引查询一定能提高查询的性能吗？为什么</h1><pre><code>通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.1、索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况:2、基于一个范围的检索,一般查询返回结果集小于表中记录数的30%3、基于非唯一性索引的检索</code></pre><h1 id="简单说一说drop、delete与truncate的区"><a href="#简单说一说drop、delete与truncate的区" class="headerlink" title="简单说一说drop、delete与truncate的区"></a>简单说一说drop、delete与truncate的区</h1><pre><code>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别1、delete和truncate只删除表的数据不删除表的结构2、速度,一般来说: drop&gt; truncate &gt;delete3、delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;如果有相应的trigger,执行的时候将被触发.4、 truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.</code></pre><h1 id="drop、delete与truncate分别在什么场景之下使用？"><a href="#drop、delete与truncate分别在什么场景之下使用？" class="headerlink" title="drop、delete与truncate分别在什么场景之下使用？"></a>drop、delete与truncate分别在什么场景之下使用？</h1><pre><code>1、不再需要一张表的时候，用drop2、想删除部分数据行时候，用delete，并且带上where子句3、保留表而删除所有数据的时候用truncate</code></pre><h1 id="超键、候选键、主键、外键分别是什么？"><a href="#超键、候选键、主键、外键分别是什么？" class="headerlink" title="超键、候选键、主键、外键分别是什么？"></a>超键、候选键、主键、外键分别是什么？</h1><pre><code>1、超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。2、候选键：是最小超键，即没有冗余元素的超键。3、主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。4、外键：在一个表中存在的另一个表的主键称此表的外键。</code></pre><h1 id="什么是视图？以及视图的使用场景有哪些？"><a href="#什么是视图？以及视图的使用场景有哪些？" class="headerlink" title="什么是视图？以及视图的使用场景有哪些？"></a>什么是视图？以及视图的使用场景有哪些？</h1><pre><code>1、视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。2、只暴露部分字段给访问者，所以就建一个虚表，就是视图。3、查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异</code></pre><h1 id="说一说三个范式。"><a href="#说一说三个范式。" class="headerlink" title="说一说三个范式。"></a>说一说三个范式。</h1><pre><code>第一范式（1NF）：属性唯一  数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。第二范式（2NF）：记录唯一  2:要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情第三范式（3NF）：表唯一  3:表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）</code></pre><h1 id="数据库的乐观锁和悲观锁是什么？"><a href="#数据库的乐观锁和悲观锁是什么？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？"></a>数据库的乐观锁和悲观锁是什么？</h1><pre><code>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</code></pre><h1 id="Mysql中有哪几种锁？"><a href="#Mysql中有哪几种锁？" class="headerlink" title="Mysql中有哪几种锁？"></a>Mysql中有哪几种锁？</h1><pre><code>1.表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。2.行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。3. 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</code></pre><h1 id="mysql有哪些引擎"><a href="#mysql有哪些引擎" class="headerlink" title="mysql有哪些引擎"></a>mysql有哪些引擎</h1><pre><code> MyISAMHeapMergeINNODBISAM</code></pre><h1 id="简述在MySQL数据库中MyISAM和InnoDB的区别"><a href="#简述在MySQL数据库中MyISAM和InnoDB的区别" class="headerlink" title="简述在MySQL数据库中MyISAM和InnoDB的区别"></a>简述在MySQL数据库中MyISAM和InnoDB的区别</h1><pre><code>MyISAM：  不支持事务，但是每次查询都是原子的；  支持表级锁，即每次操作是对整个表加锁；  存储表的总行数；  一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；  采用菲聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。InnoDb  支持ACID的事务，支持事务的四种隔离级别；  支持行级锁及外键约束：因此可以支持写并发；  不存储总行数；  一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制；  主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。</code></pre><h1 id="主键和候选键有什么区别？"><a href="#主键和候选键有什么区别？" class="headerlink" title="主键和候选键有什么区别？"></a>主键和候选键有什么区别？</h1><pre><code>表格的每一行都由主键唯一标识,一个表只有一个主键。主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</code></pre><h1 id="myisamchk是用来做什么的？"><a href="#myisamchk是用来做什么的？" class="headerlink" title="myisamchk是用来做什么的？"></a>myisamchk是用来做什么的？</h1><pre><code>它用来压缩MyISAM表，这减少了磁盘或内存使用。</code></pre><h1 id="MyISAM-Static和MyISAM-Dynamic有什么区别？"><a href="#MyISAM-Static和MyISAM-Dynamic有什么区别？" class="headerlink" title="MyISAM Static和MyISAM Dynamic有什么区别？"></a>MyISAM Static和MyISAM Dynamic有什么区别？</h1><pre><code>在MyISAM Static上的所有字段有固定宽度。动态MyISAM表将具有像TEXT，BLOB等字段，以适应不同长度的数据类型。MyISAM Static在受损情况下更容易恢复。</code></pre><h1 id="如果一个表有一列定义为TIMESTAMP，将发生什么？"><a href="#如果一个表有一列定义为TIMESTAMP，将发生什么？" class="headerlink" title="如果一个表有一列定义为TIMESTAMP，将发生什么？"></a>如果一个表有一列定义为TIMESTAMP，将发生什么？</h1><pre><code>每当行被更改时，时间戳字段将获取当前时间戳。</code></pre><h1 id="列设置为AUTO-INCREMENT时，如果在表中达到最大值，会发生什么情况？"><a href="#列设置为AUTO-INCREMENT时，如果在表中达到最大值，会发生什么情况？" class="headerlink" title="列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？"></a>列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？</h1><pre><code>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</code></pre><h1 id="怎样才能找出最后一次插入时分配了哪个自动增量？"><a href="#怎样才能找出最后一次插入时分配了哪个自动增量？" class="headerlink" title="怎样才能找出最后一次插入时分配了哪个自动增量？"></a>怎样才能找出最后一次插入时分配了哪个自动增量？</h1><pre><code>LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。</code></pre><h1 id="你怎么看到为表格定义的所有索引？"><a href="#你怎么看到为表格定义的所有索引？" class="headerlink" title="你怎么看到为表格定义的所有索引？"></a>你怎么看到为表格定义的所有索引？</h1><pre><code>SHOW INDEX FROM</code></pre><h1 id="LIKE声明中的％和-是什么意思？"><a href="#LIKE声明中的％和-是什么意思？" class="headerlink" title="LIKE声明中的％和_是什么意思？"></a>LIKE声明中的％和_是什么意思？</h1><pre><code>％对应于0个或更多字符，_只是LIKE语句中的一个字符。子主题 2</code></pre><h1 id="如何在Unix和Mysql时间戳之间进行转换？"><a href="#如何在Unix和Mysql时间戳之间进行转换？" class="headerlink" title="如何在Unix和Mysql时间戳之间进行转换？"></a>如何在Unix和Mysql时间戳之间进行转换？</h1><pre><code>UNIX_TIMESTAMP是从Mysql时间戳转换为Unix时间戳的命令FROM_UNIXTIME是从Unix时间戳转换为Mysql时间戳的命令</code></pre><h1 id="列对比运算符是什么？"><a href="#列对比运算符是什么？" class="headerlink" title="列对比运算符是什么？"></a>列对比运算符是什么？</h1><pre><code>在SELECT语句的列比较中使用=，&lt;&gt;，&lt;=，&lt;，&gt; =，&gt;，&lt;&lt;，&gt;&gt;，&lt;=&gt;，AND，OR或LIKE运算符。</code></pre><h1 id="BLOB和TEXT有什么区别？"><a href="#BLOB和TEXT有什么区别？" class="headerlink" title="BLOB和TEXT有什么区别？"></a>BLOB和TEXT有什么区别？</h1><pre><code>BLOB是一个二进制对象，可以容纳可变数量的数据。TEXT是一个不区分大小写的BLOB。BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。</code></pre><h1 id="mysql-fetch-array和mysql-fetch-object的区别是什么？"><a href="#mysql-fetch-array和mysql-fetch-object的区别是什么？" class="headerlink" title="mysql_fetch_array和mysql_fetch_object的区别是什么？"></a>mysql_fetch_array和mysql_fetch_object的区别是什么？</h1><pre><code>mysql_fetch_array（） – 将结果行作为关联数组或来自数据库的常规数组返回。mysql_fetch_object – 从数据库返回结果行作为对象。</code></pre><h1 id="MyISAM表格将在哪里存储，并且还提供其存储格式？"><a href="#MyISAM表格将在哪里存储，并且还提供其存储格式？" class="headerlink" title="MyISAM表格将在哪里存储，并且还提供其存储格式？"></a>MyISAM表格将在哪里存储，并且还提供其存储格式？</h1><pre><code>每个MyISAM表格以三种格式存储在磁盘上：·“.frm”文件存储表定义·数据文件具有“.MYD”（MYData）扩展名索引文件具有“.MYI”（MYIndex）扩展名</code></pre><h1 id="Mysql如何优化DISTINCT？"><a href="#Mysql如何优化DISTINCT？" class="headerlink" title="Mysql如何优化DISTINCT？"></a>Mysql如何优化DISTINCT？</h1><pre><code>DISTINCT在所有列上转换为GROUP BY，并与ORDER BY子句结合使用。</code></pre><h1 id="如何显示前50行？"><a href="#如何显示前50行？" class="headerlink" title="如何显示前50行？"></a>如何显示前50行？</h1><pre><code>SELECT*FROM LIMIT 0,50;</code></pre><h1 id="可以使用多少列创建索引？"><a href="#可以使用多少列创建索引？" class="headerlink" title="可以使用多少列创建索引？"></a>可以使用多少列创建索引？</h1><pre><code>任何标准表最多可以创建16个索引列。</code></pre><h1 id="NOW（）和CURRENT-DATE（）有什么区别？"><a href="#NOW（）和CURRENT-DATE（）有什么区别？" class="headerlink" title="NOW（）和CURRENT_DATE（）有什么区别？"></a>NOW（）和CURRENT_DATE（）有什么区别？</h1><pre><code>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。CURRENT_DATE（）仅显示当前年份，月份和日期。</code></pre><h1 id="什么是非标准字符串类型？"><a href="#什么是非标准字符串类型？" class="headerlink" title="什么是非标准字符串类型？"></a>什么是非标准字符串类型？</h1><pre><code>TINYTEXT TEXT MEDIUMTEXT LONGTEXT</code></pre><h1 id="什么是通用SQL函数？"><a href="#什么是通用SQL函数？" class="headerlink" title="什么是通用SQL函数？"></a>什么是通用SQL函数？</h1><pre><code>CONCAT(A, B) – 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。FORMAT(X, D)- 格式化数字X到D有效数字。CURRDATE(), CURRTIME()- 返回当前日期或时间。NOW（） – 将当前日期和时间作为一个值返回。MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） – 从日期值中提取给定数据。HOUR（），MINUTE（），SECOND（） – 从时间值中提取给定数据。DATEDIFF（A，B） – 确定两个日期之间的差异，通常用于计算年龄SUBTIMES（A，B） – 确定两次之间的差异。FROMDAYS（INT） – 将整数天数转换为日期值。</code></pre><h1 id="MYSQL支持事务吗？"><a href="#MYSQL支持事务吗？" class="headerlink" title="MYSQL支持事务吗？"></a>MYSQL支持事务吗？</h1><pre><code>在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，你的MYSQL就可以使用事务处理,使用SET AUTOCOMMIT=0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。</code></pre><h1 id="mysql里记录货币用什么字段类型好"><a href="#mysql里记录货币用什么字段类型好" class="headerlink" title="mysql里记录货币用什么字段类型好"></a>mysql里记录货币用什么字段类型好</h1><pre><code>NUMERICDECIMAL  salary DECIMAL(9,2)  9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。  因此，在这种情况下，能被存储在salary列中的值的范围是从-9999999.99到9999999.99。</code></pre><h1 id="mysql有关权限的表都有哪几个？"><a href="#mysql有关权限的表都有哪几个？" class="headerlink" title="mysql有关权限的表都有哪几个？"></a>mysql有关权限的表都有哪几个？</h1><pre><code>Mysql服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。userdbtable_privcolumns_privhost</code></pre><h1 id="列的字符串类型可以是什么？"><a href="#列的字符串类型可以是什么？" class="headerlink" title="列的字符串类型可以是什么？"></a>列的字符串类型可以是什么？</h1><pre><code>字符串类型是： SET BLOB ENUM CHAR TEXT</code></pre><h1 id="MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年-怎么优化？"><a href="#MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年-怎么优化？" class="headerlink" title="MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？"></a>MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？</h1><pre><code>a. 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。b. 选择合适的表字段数据类型和存储引擎，适当的添加索引。c. mysql库主从读写分离。d. 找规律分表，减少单表中的数据量提高查询速度。e。添加缓存机制，比如memcached，apc等。f. 不经常改动的页面，生成静态页面。g. 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE.</code></pre><h1 id="锁的优化策略"><a href="#锁的优化策略" class="headerlink" title="锁的优化策略"></a>锁的优化策略</h1><pre><code>1. 读写分离2. 分段加锁3. 减少锁持有的时间4. 多个线程尽量以相同的顺序去获取资源不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁。</code></pre><h1 id="索引的底层实现原理和优化"><a href="#索引的底层实现原理和优化" class="headerlink" title="索引的底层实现原理和优化"></a>索引的底层实现原理和优化</h1><pre><code>B+树，经过优化的B+树主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此InnoDB建议为大部分表使用默认自增的主键作为主索引。</code></pre><h1 id="什么情况下设置了索引但无法使用"><a href="#什么情况下设置了索引但无法使用" class="headerlink" title="什么情况下设置了索引但无法使用"></a>什么情况下设置了索引但无法使用</h1><pre><code>1.以“%”开头的LIKE语句，模糊匹配2. OR语句前后没有同时使用索引3. 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）</code></pre><h1 id="实践中如何优化MySQL"><a href="#实践中如何优化MySQL" class="headerlink" title="实践中如何优化MySQL"></a>实践中如何优化MySQL</h1><pre><code>1.SQL语句及索引的优化2. 数据库表结构的优化3.系统配置的优化4.硬件的优化</code></pre><h1 id="优化数据库的方法"><a href="#优化数据库的方法" class="headerlink" title="优化数据库的方法"></a>优化数据库的方法</h1><pre><code>选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如’省份’、’性别’最好适用ENUM使用连接(JOIN)来代替子查询适用联合(UNION)来代替手动创建的临时表事务处理锁定表、优化事务处理适用外键，优化锁定表建立索引优化查询语句</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL的复制原理以及流程&quot;&gt;&lt;a href=&quot;#MySQL的复制原理以及流程&quot; class=&quot;headerlink&quot; title=&quot;MySQL的复制原理以及流程&quot;&gt;&lt;/a&gt;MySQL的复制原理以及流程&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;基本原理流程，3个线程以及之
      
    
    </summary>
    
    
      <category term="面试" scheme="http://iwantjingjing.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试，mysql" scheme="http://iwantjingjing.com/tags/%E9%9D%A2%E8%AF%95%EF%BC%8Cmysql/"/>
    
  </entry>
  
</feed>
