<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>I want jing jing</title>
  
  <subtitle>I want jing jing ,Don&#39;t ask me who is jing jing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://iwantjingjing.com/"/>
  <updated>2020-03-28T08:17:10.914Z</updated>
  <id>http://iwantjingjing.com/</id>
  
  <author>
    <name>给予ππ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试准备</title>
    <link href="http://iwantjingjing.com/2020/03/28/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <id>http://iwantjingjing.com/2020/03/28/面试准备/</id>
    <published>2020-03-28T08:08:52.000Z</published>
    <updated>2020-03-28T08:17:10.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><hr><ol><li><ul><li></li></ul></li></ol><h3 id="缓存雪崩-多个key过期"><a href="#缓存雪崩-多个key过期" class="headerlink" title="缓存雪崩(多个key过期)"></a>缓存雪崩(多个key过期)</h3><p><strong>缓存雪崩</strong>：</p><p>我们可以简单的理解为：由同一时间热点缓存大面积失效，(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p><p><strong>解决办法</strong>：</p><blockquote><p>大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时将缓存失效时间分散开。</p><p>或者设置热点数据永不过期，有更新操作的时候更新下缓存，电商首页用这个策略，保险</p></blockquote><h3 id="缓存击穿（当单个key过期）"><a href="#缓存击穿（当单个key过期）" class="headerlink" title="缓存击穿（当单个key过期）"></a>缓存击穿（当单个key过期）</h3><p><strong>问题：</strong>一些设置了过期时间的key，这些key可能会在某些时间点被超高并发访问，是一种非常热点的数据，这个时候请求发现缓存过期了，会直接读取db，大并发可能会搞垮db</p><p><strong>解决方案0：</strong>热点数据永不过期</p><p><strong>解决方案</strong>1：使用互斥锁：（SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。）</p><p>业界比较常用的方式是使用metex。简单的来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（setnx）去set一个mutex key，当操作成功时，再进行load db的操作并设置缓存，否则就重试整个get缓存的方法</p><p>优点：思路简单、保证一致性</p><p>缺点：代码复杂度增大、存在死锁的风险</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;  </span><br><span class="line">   String value = redis.get(key);  </span><br><span class="line">   <span class="keyword">if</span> (value  == <span class="keyword">null</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="string">"1"</span>)) &#123;  </span><br><span class="line">        <span class="comment">// 3 min timeout to avoid mutex holder crash  </span></span><br><span class="line">        redis.expire(key_mutex, <span class="number">3</span> * <span class="number">60</span>)  </span><br><span class="line">        value = db.get(key);  </span><br><span class="line">        redis.set(key, value);  </span><br><span class="line">        redis.delete(key_mutex);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">//其他线程休息50毫秒后重试  </span></span><br><span class="line">        Thread.sleep(<span class="number">50</span>);  </span><br><span class="line">        get(key);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案2：</strong>异步构建缓存</p><p>在这种方案下，构建缓存采取异步策略，会从线程池中取线程来异步构建缓存，从而不会让所有的请求直接怼到数据库上。该方案redis自己维护一个timeout，当timeout小于System.currentTimeMillis()时，则进行缓存更新，否则直接返回value值。</p><p>优点：用户无需等待</p><p>缺点：无法保证缓存一致性</p><p>集群环境的redis代码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;  </span><br><span class="line">        V v = redis.get(key);  </span><br><span class="line">        String value = v.getValue();  </span><br><span class="line">        <span class="keyword">long</span> timeout = v.getTimeout();  </span><br><span class="line">        <span class="keyword">if</span> (v.timeout &lt;= System.currentTimeMillis()) &#123;  </span><br><span class="line">            <span class="comment">// 异步更新后台异常执行  </span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                    String keyMutex = <span class="string">"mutex:"</span> + key;  </span><br><span class="line">                    <span class="keyword">if</span> (redis.setnx(keyMutex, <span class="string">"1"</span>)) &#123;  </span><br><span class="line">                        <span class="comment">// 3 min timeout to avoid mutex holder crash  </span></span><br><span class="line">                        redis.expire(keyMutex, <span class="number">3</span> * <span class="number">60</span>);  </span><br><span class="line">                        String dbValue = db.get(key);  </span><br><span class="line">                        redis.set(key, dbValue);  </span><br><span class="line">                        redis.delete(keyMutex);  </span><br><span class="line">                   &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案3：</strong></p><p>布隆过滤器</p><p>优点：思路简单、保证一致性、性能强</p><p>缺点：代码复杂度增大、需要另外维护一个集合来存放缓存的key、不支持删值操作</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>问题：</strong>查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果db查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到db去，在流量大时，db可能就挂掉了</p><p>比如说：查询一个不存在id都是1开始自增上去的，如果查询一个id为-1的值</p><p><strong>解决方案：</strong></p><ol start="0"><li>接口添加校验，比如用户鉴权，参数合法校验，比如id&lt;0的直接拦截等。</li></ol><p>1.最常见的就是布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力</p><p>2.更简单粗暴的方法：如果一个查询返回的数据为空（不管数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，设置一个比较短的过期时间</p><h3 id="双写一致问题"><a href="#双写一致问题" class="headerlink" title="双写一致问题"></a>双写一致问题</h3><p>数据库跟缓存同时操作肯定会出现不一致的问题</p><p>解决方案：延时双删策略</p><p>先删除redis，更新数据库，删除redis</p><p>参考文章：<a href="https://www.cnblogs.com/rjzheng/p/9041659.html" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/9041659.html</a></p><h3 id="redis与memcached有什么区别？为什么选用redis作为缓存的中间件"><a href="#redis与memcached有什么区别？为什么选用redis作为缓存的中间件" class="headerlink" title="redis与memcached有什么区别？为什么选用redis作为缓存的中间件"></a>redis与memcached有什么区别？为什么选用redis作为缓存的中间件</h3><ol><li>redis支持复杂结构，如果需要缓存支持复杂的结构和操作，redis 是不错的选择</li><li>redis原生支持集群模式：memcached需要依赖客户端来实现往集群中分片写入数据。</li></ol><h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h4><p>redis只是用单核，而memcached可以使用多核，所有平均每一个核上redis在存储小数据时比memcached性能更高，而在100k以上的数据中，memcached性能要高于redis</p><h3 id="redis线程模型"><a href="#redis线程模型" class="headerlink" title="redis线程模型"></a>redis线程模型</h3><p>内部使用文件事件处理器 file event handler，这个是单线程的，所以redis才叫单线程的模型，它采用io多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器进行处理。</p><blockquote><p>文件事件处理器，结构包括四个部分：</p><ul><li>多个socket</li><li>io多路复用程序</li><li>文件时间分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul></blockquote><h3 id="Redis有哪些数据结构啊？"><a href="#Redis有哪些数据结构啊？" class="headerlink" title="Redis有哪些数据结构啊？"></a>Redis有哪些数据结构啊？</h3><blockquote><p>String、Hash、List、Set、SortedSet</p><p>以上五个基本类型，如果你是中高级用户的话，还有HyperLogLog、Geo、Pub、Sub</p><p>如果还想加分，还可以说玩过Redis Module，像BloomFilter、RedisSearch、Redis-ML</p></blockquote><h3 id="如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h3><blockquote><p>如果过期时间设置的过于集中，到过期的时候，Redis可能会出现短暂的卡顿现象，严重的话会出现缓存雪崩，一般在时间上加一个随机值，使得过期时间分散一些</p><p>电商首页经常会使用定时任务刷新缓存，可能大量的数据失效时间都十分集中，如果失效时间一样，又刚好在失效的时间点涌入大量访问，就可能缓存雪崩</p></blockquote><h3 id="你使用过Redis分布式锁么，它是怎么回事？"><a href="#你使用过Redis分布式锁么，它是怎么回事？" class="headerlink" title="你使用过Redis分布式锁么，它是怎么回事？"></a>你使用过Redis分布式锁么，它是怎么回事？</h3><blockquote><p>先拿setnx来争抢锁，抢到之后，再用Expire给锁加一个过期时间防止锁忘记释放。</p></blockquote><h4 id="如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？"><a href="#如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？" class="headerlink" title="如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？"></a>如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？</h4><blockquote><p>这个时候你一定要给予惊讶的反馈，是哦，这个锁就永远得不到释放了，紧接着，你抓了抓自己的头发，故作思考：我记得set指令有个非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的</p></blockquote><h3 id="假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？"><a href="#假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？" class="headerlink" title="假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？"></a>假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？</h3><blockquote><p>使用keys指令可以扫出指定模式的key列表</p></blockquote><p><strong>继续追问：如果这个redis正在给线上的业务提供服务，那么使用keys指令会有什么问题?</strong></p><blockquote><p>redis是单线程的，使用keys会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，这个时候可以使用<strong><u>scan</u></strong>指令，<strong><u>scan</u></strong>指令可以无阻塞的取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，单整体花费的时间会比直接使用keys指令长</p></blockquote><h3 id="redis是怎么持久化的？服务主从数据是怎么交互的？"><a href="#redis是怎么持久化的？服务主从数据是怎么交互的？" class="headerlink" title="redis是怎么持久化的？服务主从数据是怎么交互的？"></a>redis是怎么持久化的？服务主从数据是怎么交互的？</h3><blockquote><p>rdb做镜像全量持久化，aof做增量持久化。因为rdb会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用rdb持久化文件重构内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态</p><p>这里很好理解的，把rdb理解为一整个表全量的数据，aof理解为每次操作的日志就好了，服务器重启的时候先把表的数据全部搞进去，但是可能不完整，这个时候再回放一下日志，数据不就完整了嘛。不过redis本身的机制是aof持久化开启且存在aof文件时，优先加载aof文件；aof关闭或者aof文件不存在时，加载rdb文件；加载aof/rdb文件成功后，redis启动成功；aof/rdb文件存在错误时，redis启动失败并打印错误信息</p></blockquote><p><strong>对方追问如果突然机器停电会怎样?</strong></p><blockquote><p>取决于aof日志sync属性的配置，如果不要求心梗，在每一条写指令时都sync一下磁盘，就不会丢失数据，但是在高性能要求下每次都sync是不现实的，一般都使用定时sync，比如1s/1次，这个时候最多就会丢失1s的数据</p></blockquote><p><strong>对方继续追问rdb的原理是什么？</strong></p><blockquote><p>这个问题给出两个词汇就可以了，fork和cow。fork是指redis通过创建子进程来进行rdb操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会主键和子进程分离开来</p></blockquote><p><strong>Pipeline有什么好处，为什么要用Pipeline？</strong></p><blockquote><p>可以将多次io往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目</p></blockquote><blockquote></blockquote><p><strong>是否使用过redis集群，集群的高可用怎么保证，集群的原理是什么？</strong></p><blockquote><p>redis Sentinel着眼于高可用，在master宕机时会自动将slave升级为master，继续提供服务 。</p><p>redis cluster 着眼于扩展性，在单个redis内存不足时，使用cluster进行分片存储</p></blockquote><h3 id="哨兵、持久化、主从、手撕LRU"><a href="#哨兵、持久化、主从、手撕LRU" class="headerlink" title="哨兵、持久化、主从、手撕LRU"></a>哨兵、持久化、主从、手撕LRU</h3><p>在上面了解完基础知识已经一些缓存的常见问题之后，聊聊下面的</p><p><strong>为什么redis那么快</strong></p><blockquote><p>先看一下关系型数据库跟redis本质上的区别，如下图：</p><img src="img/面试准备.assets/image-20200224174728652.png" alt="image-20200224174728652" style="zoom:50%;"><p>Redis采用的是<strong>单进程单线程</strong>模型的kv数据库，由c编写，官方提供的数据是达到10w的qps（每秒内查询次数）</p><ul><li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快。数据存在内存中，类似于<strong>HashMap</strong>，HashMap的优势就是查找和操作的时间复杂度都是O(1);</li><li>数据结构简单，对数据操作也简单，redis中的数据结构是专门进行设计的</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换消耗，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</li><li>使用多路i/o复用模型，非阻塞io；</li><li>使用底层模型不同，他么之间底层实现方式以及与客户端之间通信的应用协议不一样，redis直接自己构建了vm机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</li></ul></blockquote><p><strong>我可以问一下啥是上下文切换吗？为啥可能线程不安全？</strong></p><blockquote><p>好比你看一本英文书，你看到第十页发现有个单词不会，你加了个书签，然后去查字典，过了一会你回来继续从书签那里读，ok目前为止没问题。</p><p>问题来了，你去查字典的时候，别人过来翻了一下你的书，然后走了，然后你回来了，你再看书的时候发现书不是你看的那一页了。</p></blockquote><p><strong>那他是单线程，我们服务器都是多核的，那不是浪费吗？</strong></p><blockquote><p>虽然他是单线程的，但是我们可以单机开多个实例啊</p></blockquote><p><strong>既然提到了单机会有瓶颈，那你们是怎么解决这个瓶颈的？</strong></p><blockquote><p>我们用到了集群的部署方式也就是redis cluster,并且是主从同步读写分离，类似Mysql的主从同步，Redis cluster支撑n个redis mater node，并且每个master node 都可以挂载多个salve node</p><p>这样整个Redis就可以横向扩容了，如果你要吃成更大数据量的缓存，那就横向扩容更多的master节点，每个master节点就能存放更多的数据了。</p></blockquote><p><strong>那么问题来了，他们之间是怎么进行数据交互的？以及redis 是怎么进行持久化的？Redis数据都在内存中，一断电或者重启不就木有了吗？</strong></p><blockquote><p>是的，持久化的话是redis高可用中的重要一点，因为redis数据在内存的特性，持久化必须有，我了解方式有两种：</p><p><strong>RDB：</strong>是对redis中的数据进行周期性的持久化</p><p><strong>AOF：</strong>对每条写入命令作为日志，以[只追加]【append-only】的方式写入到一个日志文件中，没有任何磁盘寻址的开销，所以很快，有点像mysql中binlog</p><p>这两种方式都可以把redis内存中的数据持久化到磁盘上，rdb更适合做冷备，aof更适合做热备</p><p><strong>tip</strong>：两种机制全部开启的时候，redis在重启的时候回默认使用aof去重新构建数据，因为aof的数据是比rdb更完整的</p></blockquote><p><strong>那这两种机制各自优缺点是啥？</strong></p><blockquote><p><strong>RDB</strong></p><p><strong>优点：</strong></p><p>会生成多个数据文件，每个数据文件都代表了某一时刻redis里面的数据，这种方式，很适合做冷备</p><p>rdb对redis性能影响较小，是因为在同步时候他只是fork了一个子进程去做持久化的，而且他在数据恢复的时候速度比aof来得快</p><p><strong>缺点：</strong></p><p>rdb都是快照文件，都是默认五分钟甚至更久的时间才生成一次，意味着两次同步之间五分钟的数据可能全部丢失，aof则最多丢1秒的数据</p><p>还有就是rdb在生成数据快照的时候，如果文件很大， 客户端可能会暂停几毫秒甚至几秒，你公司在做秒杀的时候它刚搞在这个时候fork了一个子进程去生成一个大快照</p><p><strong>AOF</strong></p><p><strong>优点：</strong>一秒生成一个，只追加的方式写，性能惊人</p><p><strong>缺点：</strong></p><p>一样的数据aof文件比rdb还要大，aof开启后redis支持写的qps会比rdb支持写的要低</p></blockquote><p><strong>那两者如何选择呢？</strong></p><blockquote><p>两个都要，出现事故，第一时间用rdb恢复，在用aof补全</p></blockquote><p><strong>Redis还有其他保证集群高可用的方式吗？</strong></p><blockquote><p>还要哨兵集群sentinel（森提nou）</p><p>哨兵必须用三个实例去保证自己的健壮性，哨兵+主从并不能保证数据不丢失，但是可以保证集群的高可用</p><p>一个机器挂了，剩下两个机器需要选举出来一个执行故障转移，如果只有两台机器的话，挂了一个就剩下一个了，没有哨兵去允许故障转移了</p></blockquote><p>Redis<strong>的同步机制</strong></p><blockquote><p>redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存，加载完成后，通知主节点将期间修改的操作记录同步到点进行重放就完成了同步过程。后续的增量数据通过aof日志同步即知，有点类似数据库的binlog。</p></blockquote><p><strong>说一下他的内存淘汰机制</strong></p><blockquote><p>Redis的过期策略有两种，<strong>定期删除</strong>+<strong>惰性删除</strong></p><p><strong>定期删除：</strong>默认100ms就随意抽一些设置了过期时间的key，检查是否过期，过期就删除</p><p>为什么不扫描全部设置了过期时间的key呢？</p><blockquote><p>因为太慢，浪费资源</p></blockquote><p>如果没随机到很多key，里面不就存在大量的无效key了？</p><blockquote><p>好问题，不是还有惰性删除吗</p></blockquote><p><strong>惰性删除：</strong>我不主动删，我懒，等你来查询了，我看看有没有过期，过期就删了还不给你返回，没过期就那么挂着</p></blockquote><h3 id="1-13-双写一致性、并发竞争、线程模型"><a href="#1-13-双写一致性、并发竞争、线程模型" class="headerlink" title="1.13 双写一致性、并发竞争、线程模型"></a>1.13 双写一致性、并发竞争、线程模型</h3><h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引有哪些数据结构"><a href="#索引有哪些数据结构" class="headerlink" title="索引有哪些数据结构"></a>索引有哪些数据结构</h3><p>Hash、B+</p><p>去创建索引的时候，可以选择索引的类型</p><h3 id="为什么hash、完全平衡二叉树、b树、b-树都可以优化查询，mysql为什么喜欢b-树？"><a href="#为什么hash、完全平衡二叉树、b树、b-树都可以优化查询，mysql为什么喜欢b-树？" class="headerlink" title="为什么hash、完全平衡二叉树、b树、b+树都可以优化查询，mysql为什么喜欢b+树？"></a>为什么hash、完全平衡二叉树、b树、b+树都可以优化查询，mysql为什么喜欢b+树？</h3><p>先说hash索引，字段值所对应的数据下标是哈希随机算出来的，可能会出现hash冲突。</p><p>举例：where name = ‘鸡蛋’，“鸡蛋”可以直接hash出他的数组下标，然后直接从数据中取出来</p><p>举例2：where name &gt;’鸡蛋’，那么hash表就无能为力了，他可以精确查询，但是不支持范围查询，就算做成索引，速度也很慢，要扫全表。</p><h4 id="hash表的适合场景？"><a href="#hash表的适合场景？" class="headerlink" title="hash表的适合场景？"></a>hash表的适合场景？</h4><p>hash表是无序的。</p><p>redis、Memcached这些nosql的中间件。kv结构的</p><h4 id="说的是无序的hash表，有没有有序的结构？"><a href="#说的是无序的hash表，有没有有序的结构？" class="headerlink" title="说的是无序的hash表，有没有有序的结构？"></a>说的是无序的hash表，有没有有序的结构？</h4><p>有序数组，等值查询和范围查询都很好</p><p><strong>缺点：</strong>适合做静态数据，因为增删改会改变他的结构</p><p><strong>适用：</strong>静态存储的索引啊，比如说2019年的支付宝账单，等等历史记录，都是不会变动的数据</p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>二叉树是有序的，所以支持范围查询，但是时间复杂度是o(log(n)),为了维持这个时间复杂度，更新的时间复杂度也得是o(log(n))，那就得保持这棵树是完全平衡二叉树了</p><p>索引页不止在内存里存储的，也要落盘持久化的，如果数据多了，树就很高了，查询成本随着树变高而高</p><p>如果公司为了节约成本用的机械盘，来一次千万级别的查询，那不得慢死了</p><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p><img src="https://user-gold-cdn.xitu.io/2020/3/8/170baaef95fc7c13?imageslim" alt="img"></p><p>b树比完全平衡二叉树要矮，原因是b树中的一个节点可以存储多个元素</p><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p><img src="https://user-gold-cdn.xitu.io/2020/3/8/170baaef96c4dc05?imageslim" alt="img"></p><p>同样的元素，b+树会比b树要“胖”，原因在于B+树中的非叶子节点会冗余一份在叶子节点中，并且叶子节点之间用指针相连</p><h4 id="B-树-优势"><a href="#B-树-优势" class="headerlink" title="B+树 优势"></a>B+树 优势</h4><p>Hash不支持范围查询</p><p>二叉树太高</p><p>只有B树可以跟b+比一比</p><p>b树一个节点存储多个元素，相对于完全平衡二叉树的树高整体降低了，磁盘io效率提高了</p><p>b+树是b树的升级版，只是把非叶子节点冗余一下，这样可以提高范围查找的效率：原因是会有指针指向下一个节点的叶子节点</p><h4 id="一个b-树节点可以存储多少个元素？"><a href="#一个b-树节点可以存储多少个元素？" class="headerlink" title="一个b+树节点可以存储多少个元素？"></a>一个b+树节点可以存储多少个元素？</h4><p>懵逼，换个角度，b+树中一个节点到底多大合适？</p><p>b+树中一个节点为一页或者页的倍数最合适</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p><strong>是什么?</strong></p><p>大概就是有个主键为ID的索引，和一天个普通字段 name 的索引，我们在普通字段上搜索：</p><p>select  * from table where name = ‘“丙丙”</p><p>执行的流程是：先查询name索引上的“丙丙”，然后找到他id是2，最后去主键索引，找到id为2对应的值。</p><p>回到主键索引树搜索的过程，就是回表。</p><p>覆盖索引可以避免回表</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p><strong>是什么？</strong></p><p>比如说刚才的 select * ，查询所有的，如果我们只是需要id，那么其实name字段的索引上就已经有了，就不需要回表了</p><p>很多联合索引的建立，就是为了支持覆盖索引，特定的业务能极大的提升效率</p><h3 id="char-、varchar的区别是什么？"><a href="#char-、varchar的区别是什么？" class="headerlink" title="char 、varchar的区别是什么？"></a>char 、varchar的区别是什么？</h3><p>varchar 是变长，而char是长度固定的，如果你的内容是固定大小的，使用char性能更好</p><h3 id="truncate与delete的区别是什么？"><a href="#truncate与delete的区别是什么？" class="headerlink" title="truncate与delete的区别是什么？"></a>truncate与delete的区别是什么？</h3><p>truncate 是永久删出表中的每一行，且不可恢复</p><h3 id="什么是触发器？"><a href="#什么是触发器？" class="headerlink" title="什么是触发器？"></a>什么是触发器？</h3><p>触发器是指一段代码，当触发某个事件时，自动执行这些代码。在mysql数据库中有如下6种触发器：1.Before Insert 2.After Insert 3.Before Update 4.After Update 5.Before Delete 6.After Delete</p><h3 id="float与double的区别是什么？"><a href="#float与double的区别是什么？" class="headerlink" title="float与double的区别是什么？"></a>float与double的区别是什么？</h3><p>fioat存储至多8位十进制数，内存占用4字节</p><p>double存储至多18位十进制数，内存占用8字节</p><h3 id="如果在mysql获取当前日期"><a href="#如果在mysql获取当前日期" class="headerlink" title="如果在mysql获取当前日期"></a>如果在mysql获取当前日期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select current_date();</span><br></pre></td></tr></table></figure><h3 id="如何查询第n高的工资"><a href="#如何查询第n高的工资" class="headerlink" title="如何查询第n高的工资"></a>如何查询第n高的工资</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct(salary) from employee order by salary Desc limit n-1,1</span><br></pre></td></tr></table></figure><h3 id="请说明innodb和mylsam的区别"><a href="#请说明innodb和mylsam的区别" class="headerlink" title="请说明innodb和mylsam的区别"></a>请说明innodb和mylsam的区别</h3><blockquote><p>innodb，支持事务</p><p>innodb，支持崩溃后的恢复</p></blockquote><h3 id="请列举三个以上表引擎"><a href="#请列举三个以上表引擎" class="headerlink" title="请列举三个以上表引擎"></a>请列举三个以上表引擎</h3><p>innodb 、MylSAM、Memory</p><h3 id="varchar和text的区别"><a href="#varchar和text的区别" class="headerlink" title="varchar和text的区别"></a>varchar和text的区别</h3><ul><li>varchar可以指定字符数，text不能指定</li><li>内部存储varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节（n&gt;255）,text是实际字符数+2个字节</li><li>text不能有默认值,默认值为null</li><li>varchar可以直接创建索引，text创建索引要指定前多少个字符，varchar查询速度快于text，在都创建索引的情况下，text的索引几乎不起作用。</li><li>查询text需要创建临时表</li></ul><h3 id="varchar（50）中50的含义"><a href="#varchar（50）中50的含义" class="headerlink" title="varchar（50）中50的含义"></a>varchar（50）中50的含义</h3><p>最多存放50个字符</p><p>varchar（50）和（200）存储“hello”所占用的空间是一样的，但是200在排序时会消耗更多内存。</p><h3 id="int（20）中20的含义"><a href="#int（20）中20的含义" class="headerlink" title="int（20）中20的含义"></a>int（20）中20的含义</h3><p>是指显示字符的长度，不影响内部存储，只是当定义了ZEROFILL时，前面补多少个0</p><h3 id="索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响？"><a href="#索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响？" class="headerlink" title="索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响？"></a>索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响？</h3><ol><li>唯一索引：数据列不允许重复，可以null，一个表可以创建多个</li><li>主键索引：一定是唯一索引，不允许null，一个表只能有一个</li><li>主键可以与外键构成曹肇完整性约束，防止数据不一致。</li><li>联合索引：将多个列组合在一起创建索引，可以覆盖多个列。</li><li>外检索引：基本不用，只有innodb类型的表才可以使用</li><li>全文索引：mysql自带的全文索引只能用于mylSAM，并且只能对英文进行全文检索（基本不用）</li></ol><h3 id="最左前缀"><a href="#最左前缀" class="headerlink" title="最左前缀"></a>最左前缀</h3><p>顾名思义，就是最左优先，在创建多列索引时，需要根据业务需求，where字句中使用最频繁的一列放在最左边。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">以 index(a,b,c) 为例,(注意和顺序有关)</span><br><span class="line">where a=2 可以用到索引</span><br><span class="line">where a=1 and b=2 可以用到索引</span><br><span class="line">where a=1 and b=2 and c=3 可以用到索引</span><br><span class="line">where b=1 / c=1 不能用到索引</span><br><span class="line">where a=1 and c=1 a可以发挥索引，c不能使用到索引</span><br><span class="line">where a=1 and b&gt;10 and c=1 a可以发挥索引，b也可以发挥索引，c不能发挥索引</span><br><span class="line">where a=1 and b like &apos;xxx%&apos; and c=1 a可以发挥索引，b可以发挥索引，c不能发挥索引</span><br></pre></td></tr></table></figure><ol><li>组合索引的生效原则是 从前往后依次使用生效，如果中间某个索引没有使用，那么断点前面的索引部分起作用，断点后面的索引没有起作用；</li></ol><h2 id="联合索引最左匹配原则"><a href="#联合索引最左匹配原则" class="headerlink" title="联合索引最左匹配原则"></a>联合索引最左匹配原则</h2><h4 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a><strong>最左前缀匹配原则</strong></h4><p>在mysql建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，示例：<br>对列col1、列col2和列col3建一个联合索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY test_col1_col2_col3 on test(col1,col2,col3);</span><br></pre></td></tr></table></figure><p>联合索引 test_col1_col2_col3 实际建立了(col1)、(col1,col2)、(col,col2,col3)三个索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM test WHERE col1=“1” AND clo2=“2” AND clo4=“4”</span><br></pre></td></tr></table></figure><p>上面这个查询语句执行时会依照最左前缀匹配原则，检索时会使用索引(col1,col2)进行数据匹配。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h4><p>索引的字段可以是任意顺序的，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM test WHERE col1=“1” AND clo2=“2”</span><br><span class="line">SELECT * FROM test WHERE col2=“2” AND clo1=“1”</span><br></pre></td></tr></table></figure><p>这两个查询语句都会用到索引(col1,col2)，mysql创建联合索引的规则是首先会对联合合索引的最左边的，也就是第一个字段col1的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个字段col2进行排序。其实就相当于实现了类似 order by col1 col2这样一种排序规则。</p><p>有人会疑惑第二个查询语句不符合最左前缀匹配：首先可以肯定是两个查询语句都包含索引(col1,col2)中的col1、col2两个字段，只是顺序不一样，查询条件一样，最后所查询的结果肯定是一样的。既然结果是一样的，到底以何种顺序的查询方式最好呢？此时我们可以借助mysql查询优化器explain，explain会纠正sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。</p><h4 id="为什么要使用联合索引"><a href="#为什么要使用联合索引" class="headerlink" title="为什么要使用联合索引"></a><strong>为什么要使用联合索引</strong></h4><ul><li><strong>减少开销</strong>。建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！</li><li><strong>覆盖索引</strong>。对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。</li><li><strong>效率高</strong>。索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select <em>from table where col1=1 and col2=2 and col3=3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W<em>10%=100w条数据，然后再回表从100w条数据中找到符合col2=2 and col3= 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w</em>10%</em> 10% *10%=1w，效率提升可想而知！</li></ul><h4 id="引申"><a href="#引申" class="headerlink" title="引申"></a><strong>引申</strong></h4><p>对于联合索引(col1,col2,col3)，查询语句SELECT * FROM test WHERE col2=2;是否能够触发索引？<br>大多数人都会说NO，实际上却是YES。<br><strong>原因</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test WHERE col2=2;</span><br><span class="line">EXPLAIN SELECT * FROM test WHERE col1=1;</span><br></pre></td></tr></table></figure><p>观察上述两个explain结果中的type字段。查询中分别是：</p><ol><li>type: index</li><li>type: ref</li></ol><p><strong>index</strong>：这种类型表示mysql会对整个该索引进行扫描。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个<strong>联合索引的一部分</strong>，mysql都可能会采用index类型的方式扫描。但是呢，缺点是效率不高，mysql会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引。所以，上述语句会触发索引。</p><p><strong>ref</strong>：这种类型表示mysql会根据特定的算法快速查找到某个符合条件的索引，而不是会对索引中每一个数据都进行一一的扫描判断，也就是所谓你平常理解的使用索引查询会更快的取出数据。而要想实现这种查找，索引却是有要求的，要实现这种能快速查找的算法，索引就要满足特定的数据结构。简单说，<strong>也就是索引字段的数据必须是有序的，才能实现这种类型的查找，才能利用到索引。</strong></p><h4 id="索引算法"><a href="#索引算法" class="headerlink" title="索引算法"></a><strong>索引算法</strong></h4><p>btree是最常用的，也是mysql默认的算法，因为它不仅仅可以用在=、&gt;、&gt;=、&lt;、&lt;=和between这些比较操作符上，也可以用于like操作符，只要他的查询条件不是一通配符开头的常量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name like ‘jack%’---使用索引</span><br><span class="line">select * from user where name like ‘%jack’---不使用索引</span><br></pre></td></tr></table></figure><p>hash索引只能用于对等比较，例如=、&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像btree索引需要从根节点到枝节点，最后才能访问到叶节点这样多次io访问，所以hash索引的效率远高于btree索引</p><h4 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a><strong>索引的设计原则</strong></h4><ol><li>适合索引的列是出现在where字句中的列，或者连接字句中指定的列</li><li>基数较小的列，索引效果差，没必要在此列建立索引</li><li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</li><li>不要过度索引，占用额外的磁盘空间，并降低写操作的性能。在修改表能容的时候，索引进行更新甚至重构</li></ol><h4 id="mysql中in-和exists区别"><a href="#mysql中in-和exists区别" class="headerlink" title="mysql中in 和exists区别"></a><strong>mysql中in 和exists区别</strong></h4><ol><li>如果查询的两个表大小想打，那么in和exists差别不大</li><li>如果一个小表，一个大表，则子查询表大的用exists，子查询表小的用in</li><li>not in 和 not exists 如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not exists 的子查询依然能用到表上的索引。所以无论哪个表达，用not exists 都比not in 要快</li></ol><h2 id="mysql的关联查询语句有哪些？"><a href="#mysql的关联查询语句有哪些？" class="headerlink" title="mysql的关联查询语句有哪些？"></a>mysql的关联查询语句有哪些？</h2><blockquote><p>6中关联查询：1 交叉连接（cross join）；2 内连接（inner join）；3 外连接（left join、right join）；4 联合查询（ union 与 union all）；5 全连接（full join）；</p></blockquote><p><strong>内连接分为三类</strong></p><blockquote><ol><li>等值连接：on a.id=b.id</li><li>不等值连接：on a.id &gt;b.id</li><li>自连接 ：select * from a t1 inner join a t2 on t1.id = t2.id</li></ol></blockquote><p><strong>外连接（left join、right join）</strong></p><blockquote><ol><li>左匹配连接，以左表为主，先查询出主表，按照on后的关联条件匹配右表，没有匹配到的用null填充，可以简写成left join</li><li>右匹配连接，同上</li></ol></blockquote><p><strong>联合查询（uninon 与 union all）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> a <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> b <span class="keyword">union</span> 。。。</span><br></pre></td></tr></table></figure><blockquote><ol><li>就是把多个结果集集中在一起，union前的结果为准，联合查询的列数要相等，相同的记录行会合并</li><li>如果使用union all，不会合并重复的记录行</li><li>union效率高于union all </li></ol></blockquote><h2 id="mysql的隔离级别和对应的问题"><a href="#mysql的隔离级别和对应的问题" class="headerlink" title="mysql的隔离级别和对应的问题"></a>mysql的隔离级别和对应的问题</h2><h3 id="Read-Uncomitted（读未提交）"><a href="#Read-Uncomitted（读未提交）" class="headerlink" title="Read Uncomitted（读未提交）"></a>Read Uncomitted（读未提交）</h3><p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结。</p><p>本级别很少用于实际应用，因为它的性能也不必其他级别好多事</p><p><strong>问题：</strong>脏读：读取未提交的数据</p><h3 id="Read-Committed（读已提交）"><a href="#Read-Committed（读已提交）" class="headerlink" title="Read Committed（读已提交）"></a>Read Committed（读已提交）</h3><p>大多数数据库系统的默认隔离级别（但不是mysql默认的）。满足了隔离的简单定义：一个事务只能看见已提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理期间可能会有新的commit，所以同一select 可能返回不同结果。</p><h3 id="Repeatable-Read（可重复读-默认级别）"><a href="#Repeatable-Read（可重复读-默认级别）" class="headerlink" title="Repeatable Read（可重复读-默认级别）"></a>Repeatable Read（可重复读-默认级别）</h3><p>这是mysql默认的事务隔离界别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。</p><p>不过理论上会导致另一个棘手的问题：幻读（Phantom Read）。简单的说，幻读指当前用户读取某一范围的数据行是，另一个书屋又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有心的“幻影”行。InnoDB和Falcon存储引擎通过多版本并发控制（mvcc）机制解决了该问题</p><h3 id="Serializable（可串行化）"><a href="#Serializable（可串行化）" class="headerlink" title="Serializable（可串行化）"></a>Serializable（可串行化）</h3><p>这是最高的隔离级别，通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，就是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。这四种隔离界别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：</p><ul><li><p>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p></li><li><p>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p></li><li><p>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就有几列数据是未查询出来的，如果此时插入和另外一个事务插入的数据，就会报错。</p></li></ul><h2 id="在数据库中如何优化？"><a href="#在数据库中如何优化？" class="headerlink" title="在数据库中如何优化？"></a>在数据库中如何优化？</h2><ul><li>对查询进行优化，尽量避免全表扫描，首先应考虑在where 及order by 涉及的列上建立索引</li><li>应尽量避免在where 字句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描</li><li>应尽量避免在where字句中使用！=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</li><li>应尽量避免在where字句中使用or来连接条件，如果一个字段有索引，一个字段没有索引，将导致全表扫描</li><li>in 和 not in 也要慎用，否则会导致全表扫描</li><li>like 模糊全匹配也将导致全表扫描</li></ul><h2 id="mysql的基础架构，画一下图"><a href="#mysql的基础架构，画一下图" class="headerlink" title="mysql的基础架构，画一下图"></a>mysql的基础架构，画一下图</h2><img src="img/面试准备.assets/image-20200306143322654.png" alt="image-20200306143322654" style="zoom:50%;"><h2 id="连接器是啥？"><a href="#连接器是啥？" class="headerlink" title="连接器是啥？"></a>连接器是啥？</h2><p>我们要查询db，第一步就是去连接db，这个连接器就是db跟我们对接的。</p><p>他负责跟客户端建立连接、获取权限、维持、管理连接</p><p>连接的时候回经过tcp握手，然后身份验证，然后输入账号密码就好了</p><p>验证ok后，我们就脸上mysql这个服务器了，但是这个时候处于空闲状态</p><h2 id="怎么查看空闲连接列表？"><a href="#怎么查看空闲连接列表？" class="headerlink" title="怎么查看空闲连接列表？"></a>怎么查看空闲连接列表？</h2><p><strong>show processList</strong></p><img src="img/面试准备.assets/image-20200306143801319.png" alt="image-20200306143801319" style="zoom:50%;"><p>其中Command列显示为<strong>sleep</strong>的这一行，就表示系统里面有一个空闲连接</p><p>如果数据库的客户端太久没有相应，连接器就自动断开了，这个时间参数是<strong>wait_timeout</strong>控制住的，默认时长是8小时。超时之后可以重新连接</p><h3 id="除了重新连接，还有其他方法吗？"><a href="#除了重新连接，还有其他方法吗？" class="headerlink" title="除了重新连接，还有其他方法吗？"></a>除了重新连接，还有其他方法吗？</h3><p>使用长连接</p><p>但是优缺点：长连接后，内存飙升很快，我们知道mysql在执行过程中临时使用的内存是管理在连接对象里面的。只有在断开连接的时候才能得到释放，如果长连接，这一部分内存就得不到释放，就oom了，在jvm里面就频繁fgc</p><h2 id="mysql缓存"><a href="#mysql缓存" class="headerlink" title="mysql缓存"></a>mysql缓存</h2><p>mysql拿到一个查询请求之后，会先到缓存里面查询看看，之前是否执行过这条</p><p>如果同一条语句执行两次，第一次明显比后面的慢，这就是因为缓存的存在</p><p>跟redis类似，只要你之前执行过的语句，都会在内存里面用key-value形式存储着</p><h3 id="为什么缓存弊大于利"><a href="#为什么缓存弊大于利" class="headerlink" title="为什么缓存弊大于利"></a>为什么缓存弊大于利</h3><p>缓存很容易失效，只要对表有任何的更新，这个表的所有查询缓存都会被清空，出现：缓存还没使用就被清空。</p><p>只有类似于配置表这种的，适用缓存</p><h3 id="查询的时候不想用缓存、想用缓存该如何操作？"><a href="#查询的时候不想用缓存、想用缓存该如何操作？" class="headerlink" title="查询的时候不想用缓存、想用缓存该如何操作？"></a>查询的时候不想用缓存、想用缓存该如何操作？</h3><p>可以显示调用，把query_cache_type设置成DEMAND，这样sql默认不适用缓存，想用缓存就用sql_cache。</p><p>缓存在mysql 8.0之后就取消了</p><h3 id="缓存查询完了，应该做啥呢？"><a href="#缓存查询完了，应该做啥呢？" class="headerlink" title="缓存查询完了，应该做啥呢？"></a>缓存查询完了，应该做啥呢？</h3><p>缓存没有命中的情况下，开始执行语句了，你写的sql有没有语法错误，这是接下来比较关心的点。</p><p>他会先<strong>词法分析</strong>，一条sql那么多单词，要识别每个字符代表的是什么？表名？列名？关键字？</p><p>然后开始<strong>语法分析</strong>，根据此法分析的结果，语法分析会判断你sql的对错，错了会提示你哪里错了</p><p>下一步：<strong>优化器</strong></p><p>主要优化什么：我们的表可能会建立很多索引，优化的有一步就是要确认使用哪个索引、执行顺序进行优化，条件那么多、先查哪个表，还是县关联？</p><p>最后就是执行了，交给 <strong>执行器</strong>去做</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h3 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a>什么是线程池？</h3><p>线程池的基本思想是对象池，在程序启动时就开辟一块内存空间，里面存放了众多（未死亡的）的线程，池中的线程执行调度由池管理器来处理，当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象带来的性能开销，节省了系统的资源</p><h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><blockquote><ol><li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用</li><li>运行线程池能有效的控制线程最大并发数，可以根据系统的承受能力</li><li>对线程进行一些简单的管理：比如：延迟执行、定时循环执行的策略等，运用线程池都能进行很好的实现</li></ol></blockquote><h3 id="线程池的主要组件"><a href="#线程池的主要组件" class="headerlink" title="线程池的主要组件"></a>线程池的主要组件</h3><p><img src="img/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.assets/image-20200214150028794.png" alt="image-20200214150028794"></p><p>一个线程池包括以下四个基本组成部分</p><blockquote><ol><li>线程池管理器（ThreadPool）:用于创建并管理线程池，创建、销毁线程池，添加新任务；</li><li>工作线程（WorkThread）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务</li><li>任务接口（Task）：每个任务都必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等。</li><li>任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。</li></ol></blockquote><h3 id="ThreadPoolExecutor类"><a href="#ThreadPoolExecutor类" class="headerlink" title="ThreadPoolExecutor类"></a>ThreadPoolExecutor类</h3><p>这个类的线程池中最核心的一个类</p><p><strong>线程池的主要处理流程</strong></p><blockquote><ol><li>线程数量未达到corePoolSize，则新建一个新城（核心线程）执行任务</li><li>线程数量达到了corePools，则将任务移入队列等待</li><li>队列已满，新建线程（非核心线程）执行任务</li><li>队列已满，总线程数又达到了maxImumPoolSize，就会抛出异常</li></ol></blockquote><p><strong>四中拒绝策略</strong></p><blockquote><ol><li>AbortPolicy：不执行新任务，直接抛出异常，提示线程池已满，线程池默认策略</li><li>DIscardPolicy：不执行新任务，也不抛出异常，基本上为静默模式</li><li>DIsCardOldSetPolicy：将消息队列中的一个任务替换为当前新进来的任务执行</li><li>CallerRunPolicy：用于被拒绝任务的处理程序，它直接在execute方法的调用线程中被拒绝的任务；如果执行程序已关闭，则会丢弃该任务。</li></ol></blockquote><h3 id="5-5-java通过Executors提供四种线程池"><a href="#5-5-java通过Executors提供四种线程池" class="headerlink" title="5.5 java通过Executors提供四种线程池"></a>5.5 java通过Executors提供四种线程池</h3><ol><li><p>CacheThreadPool：可缓存线程池</p><blockquote><ul><li>线程数无限制</li><li>有空闲线程则复用空闲线程，若没有则新建线程，一定程度减少频繁创建、销毁线程，减少系统开销</li></ul></blockquote></li><li><p>FixedThreadPool（）：定长线程池</p><blockquote><ul><li>可控制线程最大并发数（同时执行的线程数）</li><li>超出的线程会在队列中等待</li></ul></blockquote></li><li><p>ScheduledThreadPool</p><blockquote><ul><li>定时线程池</li><li>支持定时及周期性任务执行。</li></ul></blockquote></li><li><p>SingleThreadExecutor：单线程化的线程池</p><blockquote><ul><li>有且仅有一个工作线程任务</li><li>所有任务按照指定顺序执行，即遵循队列的入队出队规则</li></ul></blockquote></li></ol><h3 id="5-6-线程池参数设置"><a href="#5-6-线程池参数设置" class="headerlink" title="5.6 线程池参数设置"></a>5.6 线程池参数设置</h3><p>参数的设置跟系统的负载有直接关系，下面为系统负载的相关参数：</p><ul><li>tasks，每秒需要处理的任务数（针对系统需求）</li><li>threadtasks，每个线程每秒可处理任务数（针对线程本身）</li><li>responsetime，系统允许任务最大的响应时间，比如每个任务的响应时间不得超过2秒</li></ul><p><strong>corePoolSize</strong></p><p>系统每秒有tasks个任务需要处理理，则每个线程每钞可处理threadtasks个任务。，则需要的线程数为：tasks/threadtasks，即tasks/threadtasks个线程数。</p><p>假设系统每秒任务数为100 ~ 1000，每个线程每钞可处理10个任务，则需要100 / 10至1000 / 10，即10 ~ 100个线程。那么corePoolSize应该设置为大于10，具体数字最好根据8020原则，因为系统每秒任务数为100 ~ 1000，即80%情况下系统每秒任务数小于1000 * 20% = 200，则corePoolSize可设置为200 / 10 = 20。</p><p><strong>queueCapacity</strong></p><p>任务队列的长度要根据核心线程数，以及系统对任务响应时间的要求有关。队列长度可以设置为 所有核心线程每秒处理任务数 * 每个任务响应时间 = 每秒任务总响应时间 ，即(corePoolSize<em>threadtasks)</em>responsetime： (20<em>10)</em>2=400，即队列长度可设置为400。</p><p><strong>maxPoolSize</strong></p><p>当系统负载达到最大值时，核心线程数已无法按时处理完所有任务，这时就需要增加线程。每秒200个任务需要20个线程，那么当每秒达到1000个任务时，则需要（tasks - queueCapacity）/ threadtasks 即(1000-400)/10，即60个线程，可将maxPoolSize设置为60。</p><p>队列长度设置过大，会导致任务响应时间过长，切忌以下写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkedBlockingQueue queue = new LinkedBlockingQueue();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这实际上是将队列长度设置为Integer.MAX_VALUE，将会导致线程数量永远为corePoolSize，再也不会增加，当任务数量陡增时，任务响应时间也将随之陡增。</p><p><strong>keepAliveTime</strong></p><p>当负载降低时，可减少线程数量，当线程的空闲时间超过keepAliveTime，会自动释放线程资源。默认情况下线程池停止多余的线程并最少会保持corePoolSize个线程。</p><p><strong>allowCoreThreadTimeout</strong></p><p>默认情况下核心线程不会退出，可通过将该参数设置为true，让核心线程也退出。</p><h3 id="5-7-线程池的五种状态"><a href="#5-7-线程池的五种状态" class="headerlink" title="5.7 线程池的五种状态"></a>5.7 线程池的五种状态</h3><ol><li><p>线程池的初始化状态running，能够接受新任务，以及对已添加的任务进行处理。</p></li><li><p>线程池出在shutdown状态时，不接受新任务，但能处理已添加的任务。调用线程池的shutdown（）接口时，线程池由running-&gt;shutdown</p></li><li><p>线程池出在stop状态时，不接受新任务，不处理已添加的任务，并且会终端正在处理的任务。调用线程池的shutdownNow（）接口时，线程池由（running or shutdown） -&gt;stop。</p></li><li><p>当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。</p></li><li><p>当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。</p></li><li><p>当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。 线程池彻底终止，就变成TERMINATED状态。线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。</p></li></ol><h3 id="5-8-关闭线程池"><a href="#5-8-关闭线程池" class="headerlink" title="5.8 关闭线程池"></a>5.8 关闭线程池</h3><p>线程池提供两种关闭方法：shutDown()和shutDownNow()</p><p><strong>shutDown()</strong></p><p>当线程池调用该方法时，线程池的状态则like变成shutdown状态，此时，则不能再往线程池中添加任何任务，否则将会抛出异常；但是，此时线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出</p><p><strong>shutdownNow（）</strong></p><p>执行该方法，线程池的状态立刻变成STOP状态，并试图停止所有正在执行的线程，不再处理线程池中等待的任务，当然，会返回那些未执行的任务；不代表立刻就能退出，可能要等待所有正在执行的任务都执行完才能退出</p><h3 id="5-9-各种场景下怎么设置线程数"><a href="#5-9-各种场景下怎么设置线程数" class="headerlink" title="5.9 各种场景下怎么设置线程数"></a>5.9 各种场景下怎么设置线程数</h3><p><strong>高并发、任务执行时间短的业务</strong></p><blockquote><p>线程池线程数可以设置为cpu核心数+1，减少线程上下文的切换</p></blockquote><p><strong>并发不高、任务执行时间长的业务</strong></p><blockquote><p>这个需要判断执行时间是耗在那个地方了？</p><ul><li>io操作耗时，也就是io密集型的任务，因为io操作并不占用cpu，所有不要让所有的cpu闲下来，可以适当加大线程池中的线程数目（cpu核心数*2），让cpu处理更多的业务</li><li>计算操作耗时，也就是cpu密集型任务，那么久设置cpu核心数+1，线程数设置的少一些，减少线程上下文的切换。</li></ul></blockquote><p><strong>并发高、业务执行时间长的业务</strong></p><blockquote><p>解决这种类型任务的关键不在于线程池，而在于整体架构的设计</p></blockquote><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="五个状态"><a href="#五个状态" class="headerlink" title="五个状态"></a>五个状态</h2><h3 id="new（新建）"><a href="#new（新建）" class="headerlink" title="new（新建）"></a>new（新建）</h3><h3 id="Runnable（就绪）"><a href="#Runnable（就绪）" class="headerlink" title="Runnable（就绪）"></a>Runnable（就绪）</h3><h3 id="Running（运行）"><a href="#Running（运行）" class="headerlink" title="Running（运行）"></a>Running（运行）</h3><h3 id="Blocked（阻塞）"><a href="#Blocked（阻塞）" class="headerlink" title="Blocked（阻塞）"></a>Blocked（阻塞）</h3><h3 id="死亡"><a href="#死亡" class="headerlink" title="死亡"></a>死亡</h3><h2 id="线程的创建方式到底有几种"><a href="#线程的创建方式到底有几种" class="headerlink" title="线程的创建方式到底有几种"></a><strong>线程的创建方式到底有几种</strong></h2><blockquote><ol><li><p>声明为Thread的子类，并重写run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;        <span class="meta">@Override</span></span><br><span class="line">&gt;        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;            System.out.println(Thread.currentThread().getName() + <span class="string">" Thread running..."</span>);</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">&gt;            <span class="keyword">new</span> MyThread().start();</span><br><span class="line">&gt;            System.in.read();</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li><p>实现Runnable接口</p><p>Runnable的优点：</p><p>业务代码与线程类创建启动等逻辑解耦</p><p>Runnable可以复用，Thread则需要每次创建</p><p>类可以实现多个接口，而不可以继承多个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">&gt;        <span class="meta">@Override</span></span><br><span class="line">&gt;        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;            System.out.println(Thread.currentThread().getName() + <span class="string">" Runnable running..."</span>);</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">&gt;            <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();</span><br><span class="line">&gt;            System.in.read();</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="comment">// 有点</span></span><br><span class="line">&gt;    </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p><strong>归根结底</strong></p><p>创建线程只有一种方式，就是创建Thread对象，而构建一个线程的方式有多重，比如：创建线程类，实现Runnable接口，创建线程池，FutureTask等等</p><ol start="3"><li><p>线程池创建线程：实际是由默认的工厂代为创建Thread类来实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="comment">// Executors中的DefaultThreadFactory </span></span><br><span class="line">&gt;    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">&gt;            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">&gt;            <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">&gt;            <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">&gt;            <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;            DefaultThreadFactory() &#123;</span><br><span class="line">&gt;                SecurityManager s = System.getSecurityManager();</span><br><span class="line">&gt;                group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">&gt;                                      Thread.currentThread().getThreadGroup();</span><br><span class="line">&gt;                namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">&gt;                              poolNumber.getAndIncrement() +</span><br><span class="line">&gt;                             <span class="string">"-thread-"</span>;</span><br><span class="line">&gt;            &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">&gt;                Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">&gt;                                      namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">&gt;                                      <span class="number">0</span>);</span><br><span class="line">&gt;                <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">&gt;                    t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">&gt;                <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">&gt;                    t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">&gt;                <span class="keyword">return</span> t;</span><br><span class="line">&gt;            &#125;</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    <span class="comment">//由上newThread()方法可知，即使是线程池，本质上还是使用Thread的创建线程。</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="4"><li><p>Callable和FutureTask创建线程，本质其实也是Thread</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">&gt;        <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;         * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">&gt;         * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">&gt;         */</span></span><br><span class="line">&gt;        <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">&gt;        ......</span><br><span class="line">&gt;        <span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line">&gt;        ......</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="5"><li><p>定时器Timer：它的TimerTask其实也是实现了Runnable接口，可以看下TimerTask这个抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerExample</span> </span>&#123;</span><br><span class="line">&gt;        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;            Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">&gt;            <span class="comment">// 每隔1s打印下自己的名字</span></span><br><span class="line">&gt;            timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">&gt;                <span class="meta">@Override</span></span><br><span class="line">&gt;                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;                    System.out.println(Thread.currentThread().getName() + <span class="string">" timer running..."</span>);</span><br><span class="line">&gt;                &#125;</span><br><span class="line">&gt;            &#125;, <span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p><strong>线程和进程的区别</strong></p><blockquote><p>线程是进程的子集，一个进程可以有多个线程；</p><p>不同的进程使用不同的内存空间，所有单线程共享一片相同的内存空间</p></blockquote><p><strong>用Runnable还是Thread</strong></p><blockquote><p>推荐用Runnable，因为可以继承多个接口</p></blockquote><p><strong>Thread类中的start()和run()方法有什么区别？</strong></p><blockquote><p>start()被用来启动新创建的线程，而且<strong>start()</strong>内部调用了run()方法；</p><p><strong>run()</strong>,只会在原来的线程中调用，没有新的线程启动</p></blockquote><p><strong>Runnable和Callable有什么不同</strong></p><blockquote><p>都代表那些要在不同的线程中执行的任务。Runnable从1.0开始就有了，Callable在1.5增加的；</p><p>Callable的call()方法可以返回值和抛出异常</p></blockquote><h2 id="乐观锁、悲观锁"><a href="#乐观锁、悲观锁" class="headerlink" title="乐观锁、悲观锁"></a>乐观锁、悲观锁</h2><p>简单说说乐观锁、悲观锁，他们对应的实现cas、Synchronized、ReentrantLock</p><p>锁只能升级，不能降级</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><h4 id="说一说cas"><a href="#说一说cas" class="headerlink" title="说一说cas"></a>说一说cas</h4><p>Compare and Swap 比较并且替换，是乐观锁的一种实现方式，是一种轻量级锁，juc中很多工具类的实现是基于cas的</p><h4 id="cas是怎么实现线程安全的？"><a href="#cas是怎么实现线程安全的？" class="headerlink" title="cas是怎么实现线程安全的？"></a>cas是怎么实现线程安全的？</h4><p>线程在读取数据时不进行加锁，在准备写回数据时，先去查询原值，操作的时候比较原值是否修改，若未被其他线程修改则写回，若已修改，则重新执行读取流程，无法处理aba问题</p><p>cas操作长时间不成功的话，会导致一直自旋，相当于死循环了，cpu压力很大</p><h4 id="乐观锁在项目中的实践？"><a href="#乐观锁在项目中的实践？" class="headerlink" title="乐观锁在项目中的实践？"></a>乐观锁在项目中的实践？</h4><p>比如订单表，比如流水表，为了防止并发安问题，就会加入cas的校验过程，保证线程安全，但并不是所有场景都适用的。</p><h4 id="cas性能很好，但是Synchronized性能不咋地，为啥1-8之后反而多了Synchronized？"><a href="#cas性能很好，但是Synchronized性能不咋地，为啥1-8之后反而多了Synchronized？" class="headerlink" title="cas性能很好，但是Synchronized性能不咋地，为啥1.8之后反而多了Synchronized？"></a><strong>cas性能很好，但是Synchronized性能不咋地，为啥1.8之后反而多了Synchronized？</strong></h4><p>synchronized之前一直都是重量级的锁，但是后来java官方对他进行过升级 的，他现在采用的是锁升级的方式去做的。</p><p>针对synchronized获取锁的方式，jvm使用了锁升级的优化方式，就是先使用偏向锁优先同一进程然后再次获取锁，如果失败，就升级为cas轻量级锁，如果失败就会端在自旋，防止线程被系统挂起，最后如果以上都失败就升级为重量级锁；所有是一步步升级上去的，一开始也是通过很多轻量级的方式锁定的</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>什么是悲观锁，悲观锁，就是默认你每次都是渣男，每次都要提防着你是的</p><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>无论是修饰方法还是代码块，都是通过持有修饰对象的锁来实现同步</p><h5 id="是如何保证同一时刻只有一个线程可以进入临界区呢？"><a href="#是如何保证同一时刻只有一个线程可以进入临界区呢？" class="headerlink" title="是如何保证同一时刻只有一个线程可以进入临界区呢？"></a>是如何保证同一时刻只有一个线程可以进入临界区呢？</h5><p>jvm层面的synchronized加锁，是最常见的线程同步收之一</p><p>synchronized，代表这个方法加锁，相当于不管哪一个线程（比如线程A），运行到这个方法的时候，都要检查有没有其他线程B（或者c、d）正在用这个方法（或者该类方法啊其他同步方法），有的话要等他运行完之后，再运行，没有的话，锁定调用这，然后直接运行。</p><p>分别从他对对象、方法、代码块三方面加锁，去介绍怎么保证线程安全的</p><p><strong>同步方法</strong>和<strong>同步代码块</strong>底层都是通过monitor来实现同步的</p><h6 id="对象加锁"><a href="#对象加锁" class="headerlink" title="对象加锁"></a>对象加锁</h6><p>在jvm中，对象在内存中分为三块区域：对象头（header）、实例数据(Instance data)、对齐填充（padding）</p><p><strong>对象头</strong></p><p>以hotpot虚拟机为例，对象头主要包括两部分数据：mark word（标记字段）、klass pointer(类型指针)</p><ul><li><strong>mark word</strong>：默认存储对象的hashcode，分代年龄和锁标志位信息。它会根据对象的状态复制自己的存储空间，也就是说：在运行期间mark word里面存储的数据会随着锁标志位的变化而变化</li><li><strong>klass point</strong> ：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li></ul><img src="img/面试准备.assets/image-20200306165448996.png" alt="image-20200306165448996" style="zoom:33%;"><p>可以看到对象头保存了锁标志位和指向monitor对象的起始地址，如图所示，右侧就是对象对应的monitor对象</p><p>当monitor被某个线程持有后，就会处于锁定状态，如同种的 <strong>Owner</strong>部分，会指向持有monitor 对象的进程</p><p>另外 Monitor中海油两个队列分别是 EntryList和waitList，主要是用来存放进入及等待获取锁的线程，如果线程进入，则得到当前对象锁，那么别的线程在该类所有对象上的任何操作都不能进行</p><p><strong>如果一个对象有多个资源，就不需要将整个对象加锁</strong></p><p>由于每个对象都有锁，可以使用虚拟对象来上锁 Synchronized（new obj）</p><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>在介绍ReentrantLock之前，先介绍AQS（AbstractQueuedSynchronizer）</p><p>AQS：队列同步器，是实现ReentrantLock的基础</p><p>AQS有一个state标记位，值为1时表示有线程占用，其他线程需要进入到同步队列等待，同步队列是一个双向链表</p><h2 id="什么是aba"><a href="#什么是aba" class="headerlink" title="什么是aba"></a>什么是aba</h2><p><strong>什么是ABA</strong></p><p>就是一个线程把值改成了b，又一个线程把值改回了a，对于当前线程来说，发现他的值还是a，所有就不知道这个值到底有没有被人修改过，如果只追求最后结果正确，这是没关系的</p><p>但实际过程中还是需要记录修改过程的，比如资金修改什么的，你每次修改的都应该有记录，方便回溯</p><h3 id="如果和解决ABA问题？"><a href="#如果和解决ABA问题？" class="headerlink" title="如果和解决ABA问题？"></a><strong>如果和解决ABA问题？</strong></h3><p>用版本号去保证就好， 比如说，我在修改前去查询他原来的值的时候再带一个版本号，每次判断就连值和版本号一起判断，判断成功就给版本号+1，伪代码如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> a <span class="keyword">set</span> <span class="keyword">value</span> = newValue ，vision = vision + <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">value</span> = #&#123;oldValue&#125; <span class="keyword">and</span> vision = #&#123;vision&#125; // 判断原来的值和版本号是否匹配，中间有别的线程修改，值可能相等，但是版本号<span class="number">100</span>%不一样</span><br></pre></td></tr></table></figure><h3 id="除了版本号还有别的方法保证吗"><a href="#除了版本号还有别的方法保证吗" class="headerlink" title="除了版本号还有别的方法保证吗"></a><strong>除了版本号还有别的方法保证吗</strong></h3><p>比如时间戳也可以，查询的时候把时间戳一起查询出来，对的上才修改并且更新值的时候一起修改更新时间，方法很多，都是跟版本号异曲同工</p><h1 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h1><h3 id="6-1-1成员变量"><a href="#6-1-1成员变量" class="headerlink" title="6.1.1成员变量"></a>6.1.1成员变量</h3><p><strong>1。集合的初始化容量（必须是2的n次幂）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure><p>HashMap构造方法可以指定集合的初始化容量大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hash(<span class="keyword">int</span> 初始大小) <span class="comment">//构造一个带指定初始容量和默认加载因子（0.75）的空HashMap</span></span><br></pre></td></tr></table></figure><p>由此可见，当想HashMap中添加一个元素的时候，需要根据key的hash值，去确定其在数组中的具体位置。HashMap为了存取高效，要尽量减少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就是把数据存储到哪个链表中的算法</p><p>这个算法实际就是取模，hash%length，计算机中直接求余效率远不如位运算。所有源码中做了优化，使用hash&amp;（length-1），而实际上hash%length等于hash&amp;（length-1）的前提是lengtn是2的n次幂。</p><p>hash&amp;（length-1）是计算数组的索引的</p><p><strong>为什么是2的n次幂</strong></p><blockquote><p>答：减少hash冲突，提高性能</p></blockquote><p><strong>如果不是2的n次幂会怎么样？比如如果是9？</strong></p><blockquote><p>答：会通过无符号右移 按位或运算变为比指定容量大的最小的2的n次幂</p></blockquote><p><strong>2。默认的负载因子，默认值是0.75</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><p>达到这个之后，会扩容，rehash</p><p><strong>3。集合最大容量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;<span class="comment">//集合最大容量的上线是2的30次幂</span></span><br></pre></td></tr></table></figure><p> <strong>4。当链表的值超过8则会转红黑树（1.8新增）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>链表中节点的分布符合泊松分布，也就是说转变为红黑树的概率非常小</p><p><strong>5。当链表的长度小于6则会从红黑树转回链表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p><strong>6。当map里面的数量超过这个值时，表中的桶才会树化，否则桶内元素太多时会扩容，而不是树化沦为了避免进行扩容、树化选择的冲突，这个值不能小于4*TREEIFY_THRESHOLD（8）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;<span class="comment">//桶中结构转化为红黑树时对应数组长度最小的值</span></span><br></pre></td></tr></table></figure><p><strong>7。table用来初始化（必须是2的n次幂）（★★★★）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>table在jdk1.8中是由数组+链表+红黑树来组成的结构其中table就是hashMap中的数组，jdk8之前的数组类型是Entry&lt;K,V&gt;类型，jdk8之后就是Node&lt;K,V&gt;类型。只是换了个名字，都实现了一样的接口：Map.Entry&lt;K,V&gt;。负责存储键值对数据的</p><p><strong>8。HashMap中存放元素的个数（★★★★）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存放元素的个数，注意这个不等于数组的长度</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>size为HashMap中k-v的实时数量，不是数组table的长度。</p><p>9。用来记录hashMap的修改次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;<span class="comment">//每次扩容和更改map结构的计数器</span></span><br></pre></td></tr></table></figure><p>10。用来调整大小下一个容量的值计算方式（容量*负载因子）（边界值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure><p><strong>11。哈希表的加载因子（★★★★）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p>问题1：为什么架子啊因子设置是<strong>0.75</strong>，为什么不是是0.5呢？</p><p>考虑到hash冲突的问题，</p><h3 id="6-1-2构造方法"><a href="#6-1-2构造方法" class="headerlink" title="6.1.2构造方法"></a>6.1.2构造方法</h3><p>HashMap中重要的构造方法，他们分别如下：</p><p>1.构造一个空的hashMap，默认初始容量（16）和默认负载因子（0.75）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br></pre></td></tr></table></figure><p>2.构造一个具有指定出事容量和默认负载因子的HashMap（0.75）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3.构造一个具有指定的初始容量和负载因子的HashMap（★★★★★）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 边界值，决定是否扩容，不是数组长度</span></span><br><span class="line">  <span class="comment">//tableSizeFor(initialCapacity); 判断指定的初始容量是否是2的n次幂，如果不是，就会变成比初始容量大的最小的2的n次幂</span></span><br><span class="line">  <span class="comment">//  注意，jdk1.8以后的构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推迟到了put方法中，在put方法中会对threshold重新计算</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-3-成员方法"><a href="#6-1-3-成员方法" class="headerlink" title="6.1.3 成员方法"></a>6.1.3 成员方法</h3><p><strong>增加方法</strong></p><p>put方法是比较复杂的，实现步骤大致如下：</p><ol><li>先通过hash值计算出key映射到哪个桶（就是数组）</li><li>如果桶上没有碰撞冲突，则直接插入 </li><li>如果出现碰撞冲突，则需要处理冲突<ol><li>如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据</li><li>否则采用传统的链式方法插入，如果链的长度达到临界值，则把链表转化为红黑树</li></ol></li><li>如果同种存在重复的键，则为该键替换为新值value；</li><li>如果size大于阈值threshold，则进行扩容</li></ol><p>具体的方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>将链表转为红黑树</strong></p><p><strong>扩容方法 resize</strong></p><ol><li><p>什么时候才需要扩容？</p><blockquote><p>第一次是在putVal的时候扩容</p><p>补充：当HashMap中的其中一个链表的对象个数如果达到8个，此时如果数组长度没有达到64，那么HashMap会先扩容解决，如果已经达到64，那么这个链表会变成红黑树，节点类型由node变为treenode</p><p>当然，如果映射关系被移除后，下次执行resize方法时判断树节点个数低于6个，也会再把树转换为链表</p></blockquote></li><li><p>扩容是在做什么？</p><p>jdk8之前：</p><blockquote><p>reHash</p><p>创建新的数组</p><p>遍历放到新的数组</p></blockquote><p>jdk8开始：</p><blockquote><p>扩容避免了reHash，如何避免的呢？不需要重新计算hash；扩容之后要么还是在原来的索引位置，要么就是在（原来的索引位置+旧容量）的索引位置</p></blockquote></li><li><p>HashMap的扩容是什么？</p></li></ol><h2 id="面试题：谈谈你对hashMap的理解"><a href="#面试题：谈谈你对hashMap的理解" class="headerlink" title="面试题：谈谈你对hashMap的理解"></a>面试题：谈谈你对hashMap的理解</h2><p>hashmap是一种存取高效，但是不保证有序的容器。数据结构是<strong>数组+链表+红黑树</strong>，是解决hash冲突的产物，它实现了Map接口，采用kv键值对存储数据，并且实现了浅拷贝和序列化</p><p>默认大小是16，阈值是0.75，初始化大小必须是2的幂，最大是2的30次方，数组中存储的链表节点Entry类实现于Map.Entry接口，实现了对节点的通用操作</p><p>HashMap提供了四种构造方法，默认构造、指定初始容量构造、指定初始容量和阈值构造、基于Map的构造。虽然是构造方法，但是真正从初始化是在第一次添加操作里面实现的</p><p>第一次添加操作时，先判断数组有没有初始化，如果没有则先初始化</p><blockquote><p>添加操作的流程：</p><ol><li>先判断是否初始化</li><li>再判断传入的key是否为空，为空则保存在table[0]位置</li><li>key不为空的就对key进行hash，hash的结果再&amp;数组的长度就得到存储的位置</li><li>如果存储位置为空则创建节点，不为空说明存在冲突</li><li>解决冲突HashMap会先遍历链表，如果有相同的value就更新旧值，否则构建节点添加到链表头</li><li>添加还要先判断存储的节点数量是否达到阈值，达到阈值就要进行扩容</li><li>扩容2倍，是新建数组，所以要先转移节点，转移时都重新计算存储位置，可能保持不变，可能为就容量+位置</li><li>扩容结束后新插入的元素也得再hash一遍才能插入</li></ol></blockquote><p>获取节点的操作流程：</p><blockquote><ol><li>判断是否为空，为空就去table[0]找值</li><li>不为空，也是先hash，&amp;数组长度计算下标位置</li><li>遍历找相同的key返回值</li></ol></blockquote><p>HashMap是并发不安全的容器，并发添加操作中会出现丢失更新的问题；因为采用头插法在并发扩容时会产生环形链表的问题，导致cpu达到100%</p><p><strong>解决并发问题可以采用</strong></p><ul><li>java类库提供的Collections工具包下的Collections.synchronizedMap()方法，返回一个线程安全的map</li><li>使用并发包下的ConcurrentHashMap。它采用的是分段锁机制实现线程安全</li><li>使用HashTable（不推荐）</li></ul><p><strong>回答顺序：数据结构+继承结构+基本字段+构造方法+添加操作+扩容操作+并发问题+与1.8的区别</strong></p><h2 id="知识点扩展"><a href="#知识点扩展" class="headerlink" title="知识点扩展"></a>知识点扩展</h2><h4 id="说说浅拷贝与深拷贝的区别"><a href="#说说浅拷贝与深拷贝的区别" class="headerlink" title="说说浅拷贝与深拷贝的区别"></a><strong>说说浅拷贝与深拷贝的区别</strong></h4><blockquote><p><strong>基本数据类型</strong>：直接存储在栈中</p><p><strong>引用数据类型</strong>：存储的是该对象在栈中引用，真实数据存放在堆内存里。</p><p>这两种都是针对于Object和Array这样的引用类型数据的</p><p><strong>浅拷贝</strong>只复制指向某个对象的指针，而不是复制对象本身，新旧对象还是共享同一块内存，拷贝对象的时候只对基本数据类型进行了拷贝，对于引用数据类型只是进行了引用的传递，没有真实的创建一个新的对象。</p><p><strong>深拷贝</strong>会创造一个一模一样的对象，新旧对象不共享内存</p></blockquote><p><strong>Collections.synchronizedMap()和Hashtable的区别</strong></p><h4 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a><strong>HashMap和Hashtable的区别</strong></h4><blockquote><p>Hashtable是个过时的集合类</p><p>两者都实现了map接口，两者介乎等价，除了：Hashtable是synchronized的，这意味着线程安全，多个线程可以共享一个hashtable，java5提供了concurrentHashMap，他是Hashtable的替代，比Hashtable扩展性更好</p><table><thead><tr><th></th><th>HashMap</th><th>Hashtable</th></tr></thead><tbody><tr><td>线程是否安全</td><td>否</td><td>是</td></tr><tr><td>效率</td><td>高</td><td>低</td></tr><tr><td>null key 和null value</td><td>是</td><td>否</td></tr><tr><td>底层数据结构</td><td>数组+链表+红黑树</td><td></td></tr><tr><td>实现方式</td><td>继承AbstractMap类</td><td>继承了Dictionary类，是jdk1.0添加，好像已经过时了</td></tr><tr><td>初始化容量不同</td><td>16</td><td>11</td></tr><tr><td>扩容机制不同</td><td>翻倍</td><td>翻倍+1</td></tr><tr><td>迭代器不同</td><td>Iterator是fail-fast的</td><td>Enumerator不是fail-fast的</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p><strong>快速失败fail-fast是啥？原理是啥</strong></p><blockquote><p>是java集合中的一种机制，在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception</p><p>原理：在遍历的过程中使用一个modCount遍历用来记录内容变化，如果发生变化，他的值就会改变，每当迭代器使用hashNext、next遍历下一个元素之前，都会检测modCount变量</p></blockquote><p><strong>fail-fast场景？</strong></p><blockquote><p>java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改，算是一种安全机制吧。</p></blockquote><p><strong>安全失败 fail-safe</strong></p><blockquote><p>java.util.concurrent包下的容器都是安全失败的，可以在多线程下并发使用，并发修改。</p></blockquote><p><strong>Hashtable效率低的原因？</strong></p><blockquote><p>看过源码，会发现，他对数据的操作都会上锁</p></blockquote><p><strong>为啥Hashtable不允许键值为null？</strong></p><blockquote><p>Hashtable在put空值的时候回直接抛异常，HashMap却做了特殊处理</p><p>Hashtable使用的是<strong>安全失败机制</strong>，这种机制会使你此次读取到的数据不一定是最新的数据，如果你使用null值，就会使得它无法判断对应的key是不存在还是为空，因为你无法再调用一次contain（key）来对key是否存在进行判断，ConcurrentHashMap同理。</p></blockquote></blockquote><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="*ConcurrentHashMap *"></a>*<em>ConcurrentHashMap *</em></h1><p>ConcurrentHashMap的数据结构，以及并发度这么高？</p><blockquote><p>底层基于<strong>数组+链表</strong>组成的，不过在jdk1.7与18中稍有不同</p><p><strong>1.7版本</strong></p><p>先看1.7 如图所示：是有segment数组、HashEntry组成，和HashMap一样，仍然是<strong>数组+链表</strong></p><p>HashEntry跟HashMap差不多，不同的是，他使用了<strong>volatile修饰他的value还有next</strong>。</p><p>ConcurrentHashMap采用了分段锁，其中Segment继承于ReentrantLock。不会像Hashtable那样不管是put还是get操作都需要做同步处理，理论上他支持Segment数量的并发。</p><p>每当一个线程占用锁访问一个Segment时，不会影响到其他的Segment。</p><p><strong>put</strong>：第一步的时候回尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则尝试自旋获取锁，如果重试的次数达到了Max_SCAN_RETRIES则改为阻塞锁获取，保证能获取成功</p><p><strong>get：</strong>将key通过hash之后定位到具体的Segment，再通过一次Hash定位到具体的元素上。由于HashEntry中的value是volatile的，保证了内存可见性，所有每次获取的都是最新值，整个过程不需要加锁</p><blockquote><p>虽然1.7支持每个Segment并发访问，但是还是存在一些问题？基本还是数组+链表的方式，查询时候，还得遍历链表，效率低下，跟1.7的HashMap存在一样的问题</p></blockquote><p><strong>1.8版本</strong></p><p>基本抛弃了原有的Segment分段锁，采取了<strong>CAS+Synchronized</strong>来保证并发安全性，跟HashMap很像，也把之前的HashEntry改成了node，但是作用不变</p><p><strong>值的存取过程？以及怎么保证线程安全？</strong></p><p>put操作还是比较复杂的，大概有一下几个步骤：</p><ol><li>根据key计算出Hashcode。</li><li>判断是否需要进行初始化。</li><li>即为当前key定位出的node，如果为空表是当前位置可以写入数据，利用cas尝试写入，失败则自选保证成功。</li><li>如果当前位置的hashCode == moved == -1，则需要进行扩容</li><li>如果都不满足，则利用synchronized锁写入数据</li><li>如果数量大于 <strong>TREEIFY_THRESHOLD</strong>，则要转换为红黑树</li></ol><p><strong>这里所说的cas是什么？自旋又是什么？</strong></p><p>cas是乐观锁的一种实现方式，是一种轻量级锁，juc中很多工具类的实现就是基于cas的</p><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。</p><p><strong>cas就一定能保证数据没被别的线程修改过吗？</strong></p><p>并不能，比如经典的<strong>ABA</strong>问题，CAS就无法判断了</p><p><strong>什么是ABA</strong></p><p>就是一个线程把值改成了b，又一个线程把值改回了a，对于当前线程来说，发现他的值还是a，所有就不知道这个值到底有没有被人修改过，如果只追求最后结果正确，这是没关系的</p><p>但实际过程中还是需要记录修改过程的，比如资金修改什么的，你每次修改的都应该有记录，方便回溯</p><p><strong>如果和解决ABA问题？</strong></p><p>用版本号去保证就好， 比如说，我在修改前去查询他原来的值的时候再带一个版本号，每次判断就连值和版本号一起判断，判断成功就给版本号+1，伪代码如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; update a set value = newValue ，vision = vision + 1 where value = #&#123;oldValue&#125; and vision = #&#123;vision&#125; // 判断原来的值和版本号是否匹配，中间有别的线程修改，值可能相等，但是版本号100%不一样</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>除了版本号还有别的方法保证吗</strong></p><p>比如时间戳也可以，查询的时候把时间戳一起查询出来，对的上才修改并且更新值的时候一起修改更新时间，方法很多，都是跟版本号异曲同工</p><p><strong>cas性能很好，但是Synchronized性能不咋地，为啥1.8之后反而多了Synchronized？</strong></p><p>synchronized之前一直都是重量级的锁，但是后来java官方对他进行过升级 的，他现在采用的是锁升级的方式去做的。</p><p>针对synchronized获取锁的方式，jvm使用了锁升级的优化方式，就是先使用偏向锁优先同一进程然后再次获取锁，如果失败，就升级为cas轻量级锁，如果失败就会端在自旋，防止线程被系统挂起，最后如果以上都失败就升级为重量级锁；所有是一步步升级上去的，一开始也是通过很多轻量级的方式锁定的</p></blockquote><blockquote><p>先来一张1.7图：</p><p><img src="img/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.assets/image-20200217155742981.png" alt="image-20200217155742981"></p><p><strong>jdk1.7</strong>从图中可以看出，Hashtable的锁是加在整个表上的，而ConcurrentHashMap是加在segment（每个段上的），这样我们在堆segment1操作的时候，同时也可以对segment2中的数据操作，这样效率会高很多。需要hash两次，第一次Hash定位到segment，第二次Hash定位到元素所在的链表的头部</p><p><strong>jdk1.8</strong></p><p>jdk8中ConcurrentHashMap参考了jdk8HashMap的实现，采用了数组+链表+红黑树的实现方式来设计，内部大量采用cas操作（CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。）从jdk8来看，它的数据结构已经接近HashMap，只是增加了同步的操作来控制并发</p></blockquote><h1 id="网络tcp常见面试题"><a href="#网络tcp常见面试题" class="headerlink" title="网络tcp常见面试题"></a>网络tcp常见面试题</h1><h2 id="为什么建立连接是三次握手？"><a href="#为什么建立连接是三次握手？" class="headerlink" title="为什么建立连接是三次握手？"></a>为什么建立连接是三次握手？</h2><p>两个目的：信息对等、防止超时</p><p>先从信息对等的角度来看，如下图，双方只有确定四类信息，才能建立连接，第二次握手之后，从b机器的视角看还有两个红色的no是无法确定的，只有在第三次握手之后才能确认完毕</p><img src="img/面试准备.assets/image-20200306195733777.png" alt="image-20200306195733777" style="zoom:50%;"><p>防止脏数据，ttl网络报文的生存时间往往都会超过tcp请求超时时间，如果两次握手就建立连接，传输数据并释放连接后，第一次超时的请求才到达b机器，b机器会认为是a创建新的连接请求，然后确认统一创建连接，因为a的状态不是xx，所以直接丢了b的确认数据，以至于最后只是b机器单方面的创建连接完毕</p><h2 id="tcp断开连接为什么是四次？"><a href="#tcp断开连接为什么是四次？" class="headerlink" title="tcp断开连接为什么是四次？"></a>tcp断开连接为什么是四次？</h2><p><strong>为什么四次？</strong></p><blockquote><p>确保数据能够完成传输</p></blockquote><p>第一次:**</p><p>A—&gt;B：我要断开连接</p><p><strong>第二次：</strong></p><p>B—&gt;A：我答应你，但是要等我处理完数据</p><p><strong>第三次</strong></p><p>B—&gt;A：我处理完了，咱们断开连接把</p><p><strong>第四次</strong></p><p>A—-&gt;B：我答应你，咱俩掰了</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序经典的呢，叫单轴快排，改进的叫双轴快排</p><p>他的排序思想就是：<strong>在数组中选择一个元素作为轴进行排序</strong></p><blockquote><p>第一次将大于轴的元素放在轴右边，小于轴的元素放在轴左边，这样就完成了第一次排序，然后对轴两边分区选轴进行递归排序，直到只剩下一个元素时返回。</p></blockquote><p>双轴快排使用到Arrays中是sort方法，所处理的都是基本数据类型</p><p>空间复杂度是 ologn，如果不考虑递归的话，可以达到o1 </p><h1 id="链表，反转链表"><a href="#链表，反转链表" class="headerlink" title="链表，反转链表"></a>链表，反转链表</h1><h1 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h1><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><strong>volatile</strong></h3><p><strong>可见性</strong>（✅）</p><blockquote><p>会强制将修改的值写入主内存，并且其他用过的工作内存的值都无效了</p></blockquote><p><strong>原子性</strong>（❌）</p><blockquote><p>自增不是原子操作，volatile也无法保证对变量的任何操作都是原子性的</p><p>valatile只能保证对单次读、写的原子性</p></blockquote><p><strong>有序性</strong>（✅❌一定程度）</p><blockquote><p>volatile禁止指令重排有两层意思：</p><ol><li>当程序执行到volatile变量的读操作或者写操作时，在他前面的操作肯定已经全部进行，且结果对后面的操作可见；在他后面的操作肯定都还没有执行</li><li>在进行指令优化时，不能讲volatile变量访问的语句放在他后面执行，也不能放到前面执行</li></ol></blockquote><p><strong>使用场景</strong></p><blockquote><p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于他，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile无法保证操作的原子性</p><p>使用volatile必须具备以下两个条件（实际就是保证使用场景是原子性操作）</p><ol><li>对变量的写操作不依赖于当前值</li><li>该变量没有包含在具有其他变量的不变式中</li></ol></blockquote><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h3 id="1、为什么用线程池"><a href="#1、为什么用线程池" class="headerlink" title="1、为什么用线程池"></a>1、为什么用线程池</h3><p>使用线程池主要是为了解决：</p><blockquote><p>通过重用线程池中的线程，来减少每个线程的创建销毁的性能开销</p><p>对线程进行一些维护和管理，比如定时开始，周期执行，并发控制等等</p></blockquote><p>不要用多线程去治理长连接，肯定是异步的网络模型nio，不在这里多说。</p><h3 id="2、线程池参数什么意思？"><a href="#2、线程池参数什么意思？" class="headerlink" title="2、线程池参数什么意思？"></a>2、线程池参数什么意思？</h3><p><strong>corePoolSize</strong></p><blockquote><p>常驻核心线程数，即本地任务执行完毕，核心线程也不会被销毁</p></blockquote><p><strong>maximumPoolSize</strong></p><blockquote><p>线程池最大线程数，必须大于等于1，如果待执行的线程数大于此值，需要借助第五个参数（workQueue）的帮助，缓存在队列中，如果与核心线程数一致的话，即固定了线程池大小</p></blockquote><p><strong>keepAliveTime</strong></p><blockquote><p>线程池中的线程空闲时间，当空闲时间达到此值时，线程会被销毁，只剩下核心线程</p></blockquote><p><strong>TimeUnit</strong></p><blockquote><p>时间单位，结合上面这个一起用，通常是秒</p></blockquote><p><strong>workQueue</strong></p><blockquote><p>表示缓存队列，请求的线程数大于线程池最大线程数时，线程进入BlockingQueue阻塞队列</p></blockquote><p><strong>threadFactory</strong></p><blockquote><p>线程工厂，用来生产一组相同任务的线程，线程池的命名就是通过给这个factory增加组名前缀来实现的</p></blockquote><p><strong>handler</strong></p><blockquote><p>表示执行拒绝策略的对象，当超过第五个为参数workQueue的任务缓存区上线的时候，就可以通过该策略处理请求，这是一种简单的限流保护</p></blockquote><h3 id="3、线程池中的threadpoolexecutor，每个参数是干嘛用的？"><a href="#3、线程池中的threadpoolexecutor，每个参数是干嘛用的？" class="headerlink" title="3、线程池中的threadpoolexecutor，每个参数是干嘛用的？"></a>3、线程池中的threadpoolexecutor，每个参数是干嘛用的？</h3><h3 id="4、说一下线程池内部使用规则"><a href="#4、说一下线程池内部使用规则" class="headerlink" title="4、说一下线程池内部使用规则"></a>4、说一下线程池内部使用规则</h3><h3 id="5、用过AtomicInteger吗？怎么用的"><a href="#5、用过AtomicInteger吗？怎么用的" class="headerlink" title="5、用过AtomicInteger吗？怎么用的"></a>5、用过AtomicInteger吗？怎么用的</h3><h3 id="6、用过threadlocal吗？怎么用的"><a href="#6、用过threadlocal吗？怎么用的" class="headerlink" title="6、用过threadlocal吗？怎么用的"></a>6、用过threadlocal吗？怎么用的</h3><h3 id="7、程序、进程、线程的区别？举个现实的例子说明"><a href="#7、程序、进程、线程的区别？举个现实的例子说明" class="headerlink" title="7、程序、进程、线程的区别？举个现实的例子说明"></a>7、程序、进程、线程的区别？举个现实的例子说明</h3><h3 id="8、java中通过哪些方式创建多线程类？分别使用代码说明，并调用之"><a href="#8、java中通过哪些方式创建多线程类？分别使用代码说明，并调用之" class="headerlink" title="8、java中通过哪些方式创建多线程类？分别使用代码说明，并调用之"></a>8、java中通过哪些方式创建多线程类？分别使用代码说明，并调用之</h3><h3 id="9、Thread类有没有实现Runnable接口？"><a href="#9、Thread类有没有实现Runnable接口？" class="headerlink" title="9、Thread类有没有实现Runnable接口？"></a>9、Thread类有没有实现Runnable接口？</h3><h3 id="10、当调用一个线程对象的start方法后，线程马上进入运行"><a href="#10、当调用一个线程对象的start方法后，线程马上进入运行" class="headerlink" title="10、当调用一个线程对象的start方法后，线程马上进入运行"></a>10、当调用一个线程对象的start方法后，线程马上进入运行</h3><h3 id="11、下面的代码，实际上有几个线程在运行"><a href="#11、下面的代码，实际上有几个线程在运行" class="headerlink" title="11、下面的代码，实际上有几个线程在运行"></a>11、下面的代码，实际上有几个线程在运行</h3><h3 id="12、线程的几种状态"><a href="#12、线程的几种状态" class="headerlink" title="12、线程的几种状态"></a>12、线程的几种状态</h3><h3 id="13、说说：sleep、yield、join、wait方法的区别"><a href="#13、说说：sleep、yield、join、wait方法的区别" class="headerlink" title="13、说说：sleep、yield、join、wait方法的区别"></a>13、说说：sleep、yield、join、wait方法的区别</h3><p><strong>join</strong></p><blockquote><p>谁调用了join，谁就会被阻塞，直到join执行完毕</p><p>当先线程等待，调用此方法的线程执行结束再继续执行</p><p>比如：在main方法中调用t.join(),那么main会进入阻塞状态，一直等待t线程执行完毕，main方法再恢复到就绪状态，准备继续执行</p></blockquote><p><strong>sleep</strong></p><blockquote><p>需要制定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态。</p><p>该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。</p></blockquote><h3 id="14、为什么不推荐使用stop和destory方法来结束线程"><a href="#14、为什么不推荐使用stop和destory方法来结束线程" class="headerlink" title="14、为什么不推荐使用stop和destory方法来结束线程"></a>14、为什么不推荐使用stop和destory方法来结束线程</h3><h3 id="15、写个代码说明，终止线程的典型方式"><a href="#15、写个代码说明，终止线程的典型方式" class="headerlink" title="15、写个代码说明，终止线程的典型方式"></a>15、写个代码说明，终止线程的典型方式</h3><h3 id="16、A线程的优先级是10，b线程的优先级是1，那么当进行调度时一定会调用A吗？"><a href="#16、A线程的优先级是10，b线程的优先级是1，那么当进行调度时一定会调用A吗？" class="headerlink" title="16、A线程的优先级是10，b线程的优先级是1，那么当进行调度时一定会调用A吗？"></a>16、A线程的优先级是10，b线程的优先级是1，那么当进行调度时一定会调用A吗？</h3><h3 id="17、synchronized加在static关键字前和普通方法前的区别？"><a href="#17、synchronized加在static关键字前和普通方法前的区别？" class="headerlink" title="17、synchronized加在static关键字前和普通方法前的区别？"></a>17、synchronized加在static关键字前和普通方法前的区别？</h3><blockquote><p>Synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”，不同的对象没有竞争关系</p><p>Synchronized修饰static静态方法，实际上是对该类对象加锁，俗称“类锁”，这个类所有的对象竞争一把锁</p><p>结论：类锁和对象锁不同，他们之间不会产生互斥。</p></blockquote><h3 id="18、使用Timer和TimerTask实现定时执行，定时在每天下午17：00执行"><a href="#18、使用Timer和TimerTask实现定时执行，定时在每天下午17：00执行" class="headerlink" title="18、使用Timer和TimerTask实现定时执行，定时在每天下午17：00执行"></a>18、使用Timer和TimerTask实现定时执行，定时在每天下午17：00执行</h3><h3 id="19、wait方法被调用时，所在线程是否会释放所持有的锁资源？sleep方法呢？"><a href="#19、wait方法被调用时，所在线程是否会释放所持有的锁资源？sleep方法呢？" class="headerlink" title="19、wait方法被调用时，所在线程是否会释放所持有的锁资源？sleep方法呢？"></a>19、wait方法被调用时，所在线程是否会释放所持有的锁资源？sleep方法呢？</h3><h3 id="20、wait、notify、notifyAll是在Thread类中定义的方法吗？作用分别是什么？"><a href="#20、wait、notify、notifyAll是在Thread类中定义的方法吗？作用分别是什么？" class="headerlink" title="20、wait、notify、notifyAll是在Thread类中定义的方法吗？作用分别是什么？"></a>20、wait、notify、notifyAll是在Thread类中定义的方法吗？作用分别是什么？</h3><h3 id="21、notify是唤醒所在对象watipool中的一个线程吗？"><a href="#21、notify是唤醒所在对象watipool中的一个线程吗？" class="headerlink" title="21、notify是唤醒所在对象watipool中的一个线程吗？"></a>21、notify是唤醒所在对象watipool中的一个线程吗？</h3><h3 id><a href="#" class="headerlink" title></a></h3><h1 id="java虚拟机"><a href="#java虚拟机" class="headerlink" title="java虚拟机"></a>java虚拟机</h1><h2 id="说一说jvm的内存模型（每一个模块都说）"><a href="#说一说jvm的内存模型（每一个模块都说）" class="headerlink" title="说一说jvm的内存模型（每一个模块都说）"></a>说一说jvm的内存模型（每一个模块都说）</h2><p><strong>方法区（Method Area）</strong></p><blockquote><p>方法区主要是放一下类似类定义、常量、编译后的代码、静态变量等，在jdk1.7中hotspot vm 的实现就把他放在了永久代中，这样的好处是可以直接使用堆中的gc算法来管理，但坏处就是经常会出现内存溢出。</p><p>所以在1.8中，取消了<strong>永久代</strong>，<strong>用元空间取而代之</strong>，元空间直接使用本地内存，perm（永久代）区的字符串常量在堆内存</p><p><strong>常量池中的string实际是保存在堆内存中的</strong></p></blockquote><p><strong>堆（heap）</strong></p><blockquote><p>oom故障最主要的发源地，几乎存储着所有的实例对象，堆由垃圾收集器自动回收，由各子线程共享使用，通常情况下，堆占用的内存是内存区域中最大的</p><p>对的内存空间既可以固定大小，也可以运行时动态调整，但是通常为了避免堆空间的不断扩容与收缩，在线上环境时，jvm最大堆空间和最小堆空间设置成一样，避免gc后调整大小带来的额外压力</p><p><strong>新生代：</strong>1个eden区+2个survivor区</p><p>绝大部分对象在eden区生成，当eden区满了的时候，会触发young gc。垃圾回收的时候，在eden区实现清除策略，没有被引用的对象则直接回收。依然存活的对象会被已送到Survivor区。</p><p>Survivor分为s0 和 s1两块内存空间，那么送到哪块呢？每次ygc的时候，他们将存活的对象复制到未使用的那块空间，然后将当前正在使用的空间完全清除，交换两块空间的使用状态。</p><p>如果ygc要移送的对象大于Survivor区容量的上限，则直接移交给老年代。</p><p>每个对象都有一个计数器，每次ygc都会加1，-XX：MaxTenuring Threshold参数能配置计数器的值达到某个阈值的时候，对象从新生代晋升至老年代，如果该参数配置为1，那么从新生代的eden区直接移送到年老代。</p><p>默认值是15，可以在Survivor区交换14次之后，晋升至老年代。</p><p>流程图如下：</p><p>![image-20200114135528237](img/尚学堂 java 300 讲.assets/image-20200114135528237.png)</p><p>如果Survivor区无法放下，会尝试在老年代中进行分配，如果老年代也放不下，则会触发「fgc」，如果『fgc』后依然放不下，则抛出oom，所以给jvm设置运行参数-XX：+heapDumpOnOutOfMemoryError，让jvm遇到oom异常时能输出堆信息，特别是相隔数月才出现的oom异常尤为重要</p></blockquote><p><strong>虚拟机栈</strong></p><blockquote><p>jvm在执行方法时，会在此区域中创建一个栈帧来存放方法的各种信息，比如返回值，局部变量表和各种对象引用等，方法开始执行前就先创建栈帧入栈，执行完后就出栈</p><p>只有位于栈顶帧才是有效的， 称为“当前栈”</p></blockquote><p><strong>本地方法栈</strong></p><blockquote><p>和虚拟机栈类似，不过是专门给native方法用的</p></blockquote><p><strong>程序计数器</strong></p><blockquote><p>占用很小的一块区域，我们知道jvm执行代码是一行一行执行字节码文件，所有需要一个计数器来记录当前执行的行数</p></blockquote><h2 id="说一说垃圾回收吧？有哪些垃圾回收算法"><a href="#说一说垃圾回收吧？有哪些垃圾回收算法" class="headerlink" title="说一说垃圾回收吧？有哪些垃圾回收算法"></a>说一说垃圾回收吧？有哪些垃圾回收算法</h2><p><strong>标记-清除</strong></p><blockquote><p>分为两个阶段，标记阶段、清除阶段</p><p>在标记阶段，首先通过<strong>根节点</strong>（gc roots）,标记所有从根节点开始的对象，未被标记的对象是未被引用的垃圾对象，然后，在清除阶段，清除所有未被标记的对象</p><p><strong>缺点：</strong>会带来大量的空间碎片，在分配一个较大连续空间时容易触发fgc</p></blockquote><p><strong>标记-整理</strong></p><blockquote><p>从根集合节点进行扫描，标记出所有的存活对象，并将这些存活的对象整理到内存空间的一端，形成连续的已使用空间，最后把已使用空间之外的部分全部清理掉，这样就不会产生空间碎片</p></blockquote><p><strong>标记-复制</strong></p><blockquote><p>为了能够并行的标记和整理，将空间分为了两块，每次只激活其中一块，垃圾回收时只需要把存活的对象复制到另一块未激活的空间上，然后把未激活标记为已激活，把已激活标记未激活，然后清理原空间中的对象</p><p><strong>场景：</strong>作为主流的ygc算法进行新生代的垃圾回收</p></blockquote><p><strong>分代收集算法</strong></p><blockquote><p>目前虚拟机使用回收算法，解决了标记整理不适合老年代的问题</p><p>将内存分为各个年代，一般是来年代，和新生代，永久代（jdk1.8中被元空间替代）</p><p>新生代存活率低，可以使用复制算法</p><p>老年代对象存活率高，没有额外空间对他进行分配担保，所以只能使用标记清除或者标记整理</p></blockquote><p><strong>如何判断一个对象是否应该回收</strong></p><blockquote><p><strong>方法1：引用计数</strong>，该对象每被一个地方引用，计数器就加+1，引用失效时，计数器-1，计数器为0时的对象就不能再被使用</p><p>缺点：很难解决循环引用的问题</p><p><strong>方法2：可达性分析法</strong>：通过gc  roots作为七点，从这些节点开始，向下搜索，当一个对象到gc roots没有任何引用链，这个对象就是不可用的，至少<strong>两次标记</strong></p></blockquote><p><strong>什么可以作为GC ROOT呢？</strong></p><blockquote><p>类静态属性中引用的对象（方法区）</p><p>常量引用的的对象（方法区）</p><p>虚拟机栈中引用的对象（栈帧中的本地变量表）</p><p>jni引用的对象（本地方法栈）</p></blockquote><p><strong>除了垃圾回收，还有哪些工作会造成cpu负载过高，100%负载，并给出排查过程</strong></p><blockquote><ol><li>使用top命令查找占用cpu高的进程pid</li><li>显示线程列表  ps -mp 35867 -o THREAD,tid,time—-找到占用cpu过高的tid</li><li>将需要的线程tid转换为16进制    printf “%x\n” 35889</li><li>打印线程堆栈信息     jstack 35867 |grep 8c31 -A 30</li></ol></blockquote><p><strong>cms收集器的特点</strong>（标记-清除）</p><blockquote><p>回收停顿时间比较短，四个步骤完成工作</p><ul><li>初始标记（只是标记一下gc roots能直接关联到的对象，速度很快）</li><li>并发标记（进行gc roots tracing 追踪）</li><li>重新标记（为了修正并发标记期间因用户程序持续运行产生变动的那一部分对象的标记记录，比1长，比2短）</li><li>并发清除（）</li></ul><p><strong>缺点</strong></p><p>第1、3步需要stw</p><p>对cpu资源非常敏感，在并发阶段，虽然不会导致用户线程停顿，但是因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低</p><p>因为标记-清除，会产生大量碎片，可以配置参数，强制jvm在fgc后对老年代进行压缩，但是会stw</p></blockquote><p><strong>G1</strong>★★★★</p><blockquote><p>四个步骤</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul><p>g1在jdk1.7中是推荐使用，jdk11是默认的</p><p>将堆空间分割成若干个大小相同的区域，即region，包括eden、Survivor、old、Humongous四种类型，Humongous是特殊的ol的类型，专门存放大对象，防止了反复拷贝移动</p><p>这样的划分方式，意味着不需要一个连续的内存空间管理对象，g1采用的是mark-copy，不产生大量的空间碎片</p><p>g1提供两种gc模式，ygc，mixedgc，两种都是stw的</p></blockquote><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p><strong>String  a = ‘’abc”； 和 String b = new String（“abc”）；是不是一样的？为什么？他们对应的内存空间分别是什么？</strong></p><blockquote><p>不一样</p><p>String  a = ‘’abc”是在现在栈中创建一个string类的对象引用变量，然后查找栈中有没有存放“abc”，如果没有则将“abc”放入栈，并令a指向abc</p><p>new String（abc）是在堆中存放，每次new 都会在堆中存放一个</p><p>equals比较值是否相等，==比较地址是否相等</p></blockquote><h2 id="Object-o-new-Object"><a href="#Object-o-new-Object" class="headerlink" title="Object o = new Object()"></a>Object o = new Object()</h2><p><strong>解释一下对象的创建过程（半初始化）</strong></p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span></span>&#123;</span><br><span class="line">&gt; <span class="keyword">int</span> m = <span class="number">8</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; T t = <span class="keyword">new</span> T();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>编译后的字节码如下</p><ol><li><p>new</p><p>为对象申请了一块内存，m此时是默认值，半初始化</p></li><li><p>dup</p></li><li><p>invokespecial #3&lt;T.<init>&gt;</init></p><p>这里才会把m设置为8，第1、3步之间就是半初始化状态</p></li><li><p>astore_1</p></li><li><p>return</p></li></ol></blockquote><p><strong>dcl单例(Double Check Lock)到底需不需要volatile问题</strong></p><blockquote><p>上锁前检查一次，上锁后再检查一次，要不要在定义的 时候加个volatile？</p><p>阻止对这块内存的访问指令重排序 。需要，出现的几率很小，但是还是需要</p><p><img src="img/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.assets/image-20200305221218238.png" alt="image-20200305221218238"></p></blockquote><p><strong>对象在内存中的存储布局</strong></p><p><img src="img/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.assets/image-20200305223356714.png" alt="image-20200305223356714"></p><blockquote><p><strong>普通对象 new xx()</strong></p><ul><li>对象头markword </li><li>类型指针classpointer：这个类型是什么类型？指向xx.class</li><li>实例数据instance data  比如说m=1，对象的数据</li><li>对齐padding ，比如最后算出来是30个字节？不是8的倍数怎么办？长成32</li></ul><p><strong>数组</strong> T[] a = new T[5]</p><ul><li>对象头</li><li>类型指针:数组是什么类型？int？T？</li><li>数组长度（length 4字节）</li><li>实例数据</li><li>对齐</li></ul></blockquote><p><strong>对象头具体包括什么</strong></p><blockquote><ul><li>锁的信息</li><li>gc的信息：被回收多少次了</li><li>hashCode</li></ul><p><strong>对象头占用8个字节（64位虚拟机）</strong></p><img src="img/面试准备.assets/image-20200305223705998.png" alt="image-20200305223705998" style="zoom:50%;"><p>什么时候回产生hashcode？当然是调用未重写的hashcode()方法以及System.identityHashCode的时候</p></blockquote><p><strong>对象怎么定位</strong></p><blockquote><img src="img/面试准备.assets/image-20200306114341914.png" alt="image-20200306114341914" style="zoom:50%;"><p>直接指针是hotspot使用的方式</p><p><strong>句柄方式</strong>：</p><p>优点：对象小，垃圾回收时不用频繁改动t</p><p>缺点：两次访问</p><p><strong>直接指针</strong></p></blockquote><p><strong>对象怎么分配（栈上-线程本地-eden-old）</strong></p><blockquote><img src="img/面试准备.assets/image-20200306115136889.png" alt="image-20200306115136889" style="zoom:50%;"></blockquote><p><strong>该代码在内存中占用多少字节</strong></p><blockquote><p>要看压不压缩</p><p>一个object占多少字节？</p><p>16</p><p>new int[]{} 是24</p></blockquote><h1 id="常用框架、技术"><a href="#常用框架、技术" class="headerlink" title="常用框架、技术"></a>常用框架、技术</h1><h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><p>spring框架是一个轻量级的控制反转和面向切面的容器框架</p><p><strong>轻量</strong></p><blockquote><p>从大小到开销来说都是轻量的，spring框架开源字啊一个只有1m大小的jar文件中发布，而且spring所处理的开销也是微不足道的</p></blockquote><p><strong>非侵入式</strong></p><blockquote><p>spring应用中的对象不依赖于spring的特定类</p></blockquote><p><strong>IOC（控制反转）</strong></p><blockquote><p>一个对象依赖的其他对象会通过被动的方式传递进来，而不是这个对象自己创建或者主动查找依赖对象</p></blockquote><p><strong>AOP（面向切面）</strong></p><blockquote><p>只完成业务逻辑，并不负责其他的系统级的关注点</p></blockquote><p><strong>容器</strong></p><blockquote><p>定义了bean是如何创建、配置、管理的</p></blockquote><h3 id="框架模块"><a href="#框架模块" class="headerlink" title="框架模块"></a>框架模块</h3><p>你可以不必将应用完全基于spring，可以自由的挑选适用你的模块，而忽略其余的模块</p><h4 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h4><p>这是spring框架最基础的部分，它提供了<strong>依赖注入</strong>特征来实现容器对bean的管理。这里最基本的概念是BeanFactory，它是任何spring应用的核心。BeanFactory是工厂模式的一个实现，他使用ioc将应用配置和依赖说明从实际的应用代码中分离出来</p><h4 id="应用上下文（context）模块"><a href="#应用上下文（context）模块" class="headerlink" title="应用上下文（context）模块"></a>应用上下文（context）模块</h4><p>核心模块的beanFactory使spring成为了一个容器，而上下文模块使他成为一个框架，这个模块扩展了BeanFactory的概念，增加了对国际化消息、事件传播以及验证的支持</p><p>另外，这个模块提供了许多企业服务，例如电子邮件、JNDI访问、EJB集成、远程以及时序调度（scheduling）服务。也包括了对模版框架例如Velocity和FreeMarker集成的支持。</p><h4 id="AOP模块"><a href="#AOP模块" class="headerlink" title="AOP模块"></a>AOP模块</h4><h4 id="JDBC抽象和DAO模块"><a href="#JDBC抽象和DAO模块" class="headerlink" title="JDBC抽象和DAO模块"></a>JDBC抽象和DAO模块</h4><p>使用jdbc经常导致大量的重复代码：连接、创建于巨，处理结果集，关闭链接。</p><p>这两个模块抽取了这些重复代码，因此可以保持数据库访问代码干净简洁。</p><p>这个模块还使用了<strong>aop模块</strong>为spring应用中的对象提供了事务管理服务</p><h4 id="对象-关系映射集成"><a href="#对象-关系映射集成" class="headerlink" title="对象/关系映射集成"></a>对象/关系映射集成</h4><p>orm模块，spring并不试图实现自己的orm解决方案，而是为集中流行orm框架提供了集成方案。</p><p>spring的事务管理支持这些orm框架中的每一个也包括jdbc。</p><h4 id="WEB-模块"><a href="#WEB-模块" class="headerlink" title="WEB 模块"></a>WEB 模块</h4><p>web上下文模块建立于应用上下文模块之上，提供了一个合适于web应用的上下文。另外，这个模块还提供了一些面向服务支持。例如：实现文件上传的multipart请求，它也提供了spring 和其它web框架的集成，比如Struts、WebWork。</p><h4 id="mvc框架"><a href="#mvc框架" class="headerlink" title="mvc框架"></a>mvc框架</h4><p>spring为构建web应用提供了一个功能全面的mvc框架。虽然spring可以很容易的与其它mvc框架集成，例如struts，但spring的mvc框架使用ioc对控制逻辑和业务对象提供了完全的分离。</p><h2 id="ioc"><a href="#ioc" class="headerlink" title="ioc"></a>ioc</h2><h2 id="使用到的设计模式"><a href="#使用到的设计模式" class="headerlink" title="使用到的设计模式"></a>使用到的设计模式</h2><p><strong>1.简单工厂模式</strong></p><blockquote><p>应用场景：又叫静态工厂，不属于23中设计模式。实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类</p><p>BeanFactory就是简单工程模式的体现，根据传入一个唯一的标识来获取bean对象</p></blockquote><p><strong>2.工厂模式</strong></p><blockquote><p>应用场景：通常由应用程序直接使用new创建新的对象，为了将对象的创建和使用相分离，采用工厂模式，即应用程序将对象的创建及初始化职责交给工厂对象。</p><p>一般情况下，应用程序有自己的工厂对象来创建bena，如果将应用程序自己的工程对象交给spring管理，那么spring管理就不是普通bean，而是工程bean</p></blockquote><p><strong>3.单例模式</strong></p><blockquote><p>应用场景：保证一个类只有一个实例，并提供一个访问它的全局访问点</p><p>spring中的单例模式只完成了后半句，即提供了全局的访问点BeanFactory，但没有从构造器级别去空值单例，这是因为spring管理的是任意的java对象，spring下默认的bean均为单例</p></blockquote><p><strong>4.原型模式-Prototype</strong></p><blockquote><p>应用场景：原型模式就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节</p><p>所谓原型模式，就是java中的克隆技术，以某个对象为原型，复制出新的对象，显然新的对象具备原型对象的特点，效率噶（避免了重新执行构造过程步骤）</p></blockquote><p><strong>5.代理模式–Proxy</strong></p><blockquote><p>应用场景：为其他对象提供一种代理以控制对这个对象的访问。从结构上看和Decorator（装饰器）模式类似，但是proxy是控制，更像是一种对功能的闲置，而Decorator是增加职责。</p><p>spring中代理模式体现在aop中，比如cglibAopProxy，和jdkAopProxy</p></blockquote><p><strong>6.策略模式–Strategy</strong></p><blockquote><p>应用场景：定义一系列的算法，把它们一个个封装起来，并且使他们可互相替换，最终执行结果是固定的，执行过程和执行逻辑不一样</p><p>spring中在实例化对象的时候用到了Strategy模式</p></blockquote><p><strong>7.模板方法模式–TemplateMethod</strong></p><blockquote><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤</p><p>TemplateMethod模式一般是需要继承的。执行流程固定，但是中间实现步骤有细微差别</p><p>springorm数据类型</p></blockquote><p><strong>8.委派模式–Delegate</strong></p><blockquote><p>应用场景：不属于23中设计模式，是面向对象设计模式中常用的一种模式。这种模式的原理为类b和类a是两个没有任何关系的类，b具有和a一模一样的方法和属性；并且调用b中的方法，属性就是调用a中同名的方法和属性，b好像就是一个受a委托授权的终结。第三方的代码不需要指定a的存在，也不需要和a发生直接的联系，通过b就可以直接使用a的功能，这样既能够使用到a的各种功能，又能够很好的将a保护起来，一举两得</p><p>要和代理模式区分开来，持有被委托人的引用，不关心过程，只关心结果</p><p>DIspatcher</p></blockquote><p><strong>9.适配器模式–Adapter</strong></p><blockquote><p>springAOP模块对BeforeAdvice、AfterAdvice、ThrowsAdvice三种通知类型的支持实际上是借助适配器模式来实现的，这样的好处是使得框架允许用户向框架中加入自己想要支持任何一种通知雷丁，这三种通知类型是springAOP模块定义的，他们是AOP联盟定义的Advice的子类型</p></blockquote><p><strong>10.装饰器模式–Decorator</strong></p><blockquote><p>应用场景：比如说项目需要多数据库连接，用户每次访问都会根据需要去访问不同的数据库</p><p>首先想到的是在spring的applicationContext中配置所有的DataSource。这些DataSource可能是各种不同类型的，比如不同的数据库oracle、mysql，也可能是不同的数据源：比如Apache提供的org.apache.commons.dbcp.BasicDataSource、Spring提供的org.springframework.jndi.JndiObjectFactoryBean等。然后SessionFactory根据客户的每次请求，将DataSource属性设置成不同的数据源，以到达切换数据源的目的。</p><p>spring中用的包装器模式在类名上有两种表现：一种是类名中含有Wrapper、另一种是类名中喊有Decorator。基本上都是动态的给一个对象添加一些额外的职责。</p><p>io流包装、数据源包装等</p></blockquote><p><strong>11.观察者模式–Observer</strong></p><blockquote><p>应用场景：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变是，所有依赖于它的对象都得到通知并被自动更新</p><p>Spring中Observer模式常用的地方是Listener的实现。如：ApplicationListener</p><p>一般由两个角色组成：发布者和订阅者（观察者），观察者通常有一个回调，也可以没有，监听器、日志收集</p></blockquote><p>设计模式对比</p><table><thead><tr><th>设计模式</th><th>一句话归纳</th></tr></thead><tbody><tr><td>工厂模式Factory</td><td>只对结果负责，不要三无产品</td></tr><tr><td>单例模式Singleton</td><td>保证独一无二</td></tr><tr><td>适配器模式Adapter</td><td>需要一个转换头（兼容）</td></tr><tr><td>装饰器模式 Decorator</td><td>需要包装，但不改变本质（同宗同源）</td></tr><tr><td>代理模式Proxy</td><td>办事要求人，所以找代理</td></tr><tr><td>观察者模式Observer</td><td>完成时通知我</td></tr><tr><td>策略模式Strategy</td><td>我行我素，达到目的就行</td></tr><tr><td>模板模式Template</td><td>流程标准化，原料自己加</td></tr><tr><td>委派模式Delegate</td><td>干活是你的（普通员工），功劳是我的（项目经理）</td></tr><tr><td>原型模式prototype</td><td>拔一根好，吹出千万个</td></tr></tbody></table><p>编程思想总结</p><table><thead><tr><th>spring思想</th><th>应用场景（特点）</th><th>一句话归纳</th></tr></thead><tbody><tr><td>aop</td><td>面向切面变成，找出多个类中中有一定规律的代码，开发时拆开，运行时再合并，例如aop日志</td><td>解耦，专人做专事</td></tr><tr><td>oop</td><td>面向对象变成，归纳总结生活中的一切事务</td><td>封装、集成、多态</td></tr><tr><td>bop</td><td>面向bean编程，面向bean（普通java类）设计程序</td><td>一切从bean开始</td></tr><tr><td>ioc</td><td>控制翻转，将new对象的动作交给spring管理，并由spring保存已创建的对象（ioc容器）</td><td>转交控制权（控制翻转）</td></tr><tr><td>DI/DL</td><td>依赖注入或者依赖查找，spring不仅保存自己创建的对象，而保存对象与对象之间的关系<br>注入即赋值，主要三种方式：构造方法、set方法、直接赋值</td><td>先理清关系再赋值</td></tr></tbody></table><p>cglib与jdk的区别是：</p><blockquote><p>创建代理的消耗</p><p>cglib不适合频繁创建，适合创建一次，长期使用</p></blockquote><h3 id="spring-bean-的加载、注入过程"><a href="#spring-bean-的加载、注入过程" class="headerlink" title="spring bean 的加载、注入过程"></a>spring bean 的加载、注入过程</h3><blockquote><ol><li>执行该对象的构造方法</li><li>执行set参数注入方法</li><li>执行BeanNameAware的实现方法获取bean的id</li><li>执行BeanFactoryAware的实现方法获取bean的工厂</li><li>执行BeanPostProcessor的postProcessBeforeInitalization处理方法</li><li>执行In</li></ol></blockquote><h3 id="说一下对spring的理解，ioc和aop在项目里怎么用的"><a href="#说一下对spring的理解，ioc和aop在项目里怎么用的" class="headerlink" title="说一下对spring的理解，ioc和aop在项目里怎么用的"></a>说一下对spring的理解，ioc和aop在项目里怎么用的</h3><p>spring 是一个开源框架，处于mvc的控制层，能应对需求的快速变化，主要原因是它有一种面向切面编程（aop）的优势</p><p>其次它提升了系统性能，是因为通过依赖倒置机制（ioc），系统中用到的对象不是在系统加载时就全部实例化，而是在调用到这个类时才会实例化该对象</p><p><strong>优点</strong></p><blockquote><ul><li>降低了组件之间的耦合性，实现了软件各层之间的解耦</li><li>可以使用容易提供的众多服务，事务管理、消息服务、日志记录等</li><li>容器提供了aop，利用它很容易实现如权限拦截、运行期监控等功能</li></ul></blockquote><p>Spring中的aop技术是设计模式中的动态代理模式</p><h2 id="AOP的两种实现方式？哪个效率更高？为什么？"><a href="#AOP的两种实现方式？哪个效率更高？为什么？" class="headerlink" title="AOP的两种实现方式？哪个效率更高？为什么？"></a>AOP的两种实现方式？哪个效率更高？为什么？</h2><p>jdk动态代理、cglib</p><p>JDK<strong>动态代理具体实现原理</strong></p><blockquote><ul><li>通过实现InvocationHandle接口创建自己的调用处理器</li><li>通过Proxy类指定ClassLoader对象和一组interface来创建动态代理</li><li>通过反射机制获取动态代理类的构造函数，其唯一参数类型就是调用处理器接口类型</li><li>通过构造函数创建动态代理实例，构造时调用处理器对象作为参数传入；</li></ul><p>jdk动态代理是面向接口的代理模式，如果被代理目标没有接口那么spring也无能为力，Spring通过java的 反射机制生产被代理接口的新的匿名实现类，重写了其中AOP的增强方法。</p></blockquote><p><strong>CGLib动态代理</strong></p><blockquote><p>强大的、高性能的Code生产类库，可以实现运行期动态扩展java类，Spring在运行期间通过cglib集成要被动态代理的类，重写父类的方法，实现Aop切面变成</p></blockquote><p><strong>两者的对比</strong></p><blockquote><p>jdk是面向接口的</p><p>cglib是通过字节码底层集成要代理类来实现（如果被代理类被final修饰，那么会失败）</p></blockquote><p><strong>性能</strong></p><blockquote><p>主要体现在如下的两个指标中</p><ul><li>cglib所创建的动态搭理对象在实际运行时候的性能要比jdk高，大概10倍</li><li>cglib在创建对象的时候所花费的时间比jdk要高，大概8倍</li></ul><p>因此，对于Singleton的代理对象或者具有实例池的代理，因为无需频繁的创建代理对象，所以比较适合采用cglib动态代理，反之使用jdk</p></blockquote><h3 id="spring事务的传播机制"><a href="#spring事务的传播机制" class="headerlink" title="spring事务的传播机制"></a>spring事务的传播机制</h3><p>有如下几种</p><ul><li><p>PROPAGATION_REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</p></li><li><p>PROPAGATION_SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。</p></li><li><p>PROPAGATION_MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常。</p></li><li><p>PROPAGATION_REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。</p></li><li><p>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p></li><li><p>PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p></li><li><p>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p></li></ul><p>常用的主要由三个：Required、RequresNew、Nested</p><ul><li>Required：简单理解就是事务方法会判断是否存在事务，有事务就用已有的，没有就重新开启一个</li><li>RequiresNew：简单理解就是开启新事务，若当前已有事务，挂起当前事务。新开启的事务和之前的事务无关，拥有自己的锁和隔离级别，可以独立提交和回滚，内层事务执行期间，外层事务挂起。内层事务执行完毕，外层事务恢复执行</li><li>Nested：简单理解就是：嵌套事务，如果外部事务回滚，则嵌套事务也回滚！！外部事务提交的时候，嵌套事务才会被提交。嵌套事务回滚不会影响外部事务</li></ul><p>如果想事务一起执行可以用Required满足大部分场景，如果不想让执行的子事务的结果影响到父事务的提交，可以将子事务设置为RequiresNew</p><h3 id="简单说一下IOC、DI"><a href="#简单说一下IOC、DI" class="headerlink" title="简单说一下IOC、DI"></a>简单说一下IOC、DI</h3><p>Inversion on Control，控制翻转，对象的创建交给外部容器完成，这个就叫做控制翻转</p><p>Dependency injection，依赖注入、处理对象的依赖关系</p><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><ul><li>控制反转，解决对象创建的问题</li><li>依赖注入，在创建完对象后，对象的关系的处理就是依赖注入</li></ul><h2 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h2><ol><li><p>核心配置文件是哪几个？他们的区别是啥？</p><p>applicaion和boostrap配置文件</p><p>application配置文件主要用于springboot项目的自动化配置</p><p>boostrap配置文件主要用于</p><p>​    一些固定的不能被覆盖的属性，一些加密解密的场景</p></li><li><p>配置文件有哪几种格式？有什么区别？</p><p>properties和yml</p><p>区别就是书写格式不同</p><p>另外 yml 格式不支持@propertySource注解导入配置</p></li><li><p>事务是怎么实现的？</p><p>基于@Transactional注解</p><blockquote><p>整体事务控制流程</p><ol><li>当@Transactional注解的方法被外部的代码调用时，spring在运行时为方法所在类生成一个aop代理对象。</li><li>代理对象根据@transactional的属性，决定是否由事务拦截器TransactionInterceptor对此方法进行事务拦截。</li><li>在进行事务拦截时，会先开启事务，然后执行业务代码，根据执行是否出现异常，通过抽象事务管理来进行rollback或者commit。</li></ol></blockquote></li><li><p>数据库引擎是否支持事务？</p><p>mysql的mylsam不支持事务</p><p>如果事务生效，库和表的引擎必须是InnoDB</p><p>当事务方法被本类内部方法调用时，@Transactional 注解并不生效，因为，只有被当前类以外的调用时，才会由spring生成的代理对象来管理</p><p>一定要确保所使用的数据源加载了事务管理器（配置文件写一下就好）</p></li><li><p>springboot的核心注解是哪个？他主要由哪几个注解组成？</p><p>启动类上面的注解是@springbootApplication，它是核心注解，包含了以下三个注解</p><p>@springbootConfiguration：组合了@Configuration注解，实现配置文件的功能</p><p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项</p><p>@ComponentScan：spring组件扫描</p></li><li><p>开启springboot 特性有哪几种方式?</p><ol><li>继承spring-boot-starter-parent项目</li><li>导入spring-boot-dependencies项目依赖</li></ol></li><li><p>springboot需要独立的容器运行吗？</p><p>可以不需要，内置了tomcat/jetty等容器。</p></li><li><p>springboot 配置加载顺序</p><ol><li>properties</li><li>yaml文件</li><li>系统环境变量</li><li>命令行参数</li></ol></li><li><p>springboot可以兼容老spring项目吗？如何做?</p><p>可以兼容，使用@ImportResource注解导入老spring项目配置文件</p></li><li><p>保护springboot应用有哪些方法？</p><ol><li>在生产中使用https</li><li>启用csrf保护</li><li>使用内容安全策略防止xss攻击</li></ol></li></ol><p><strong>private不能事务，基于aop实现的，aspectj可以</strong>？？</p><p><strong>springboot默认的代理是cglib</strong>？？</p><h2 id="spring-cloud"><a href="#spring-cloud" class="headerlink" title="spring cloud"></a>spring cloud</h2><ol><li><p>微服务之间是如何独立通讯的？</p><ol><li>同步：rpc、rest等</li><li>异步：消息队列</li></ol></li><li><p>ribbon和feign的区别？</p><ol><li>都是客户端的负载均衡工具，feign的底层是通过ribbon实现的，是对riboon的封装</li><li>ribbon使用httpclient或者restTemplate模拟http请求，步骤繁琐。</li><li>feign采用接口+注解的方式，将需要调用的其他服务的方法定义成抽象方法即可，不需要自己构建http请求。就像调用自身工程的方法一样调用</li></ol></li><li><p>注册中心用的什么？</p><p>用的nacos= eureka+config</p></li><li><p>nacos优点？</p><ol><li>nacos自带配置中心，且提供了管理界面</li><li>动态刷新，eureka需要配合mq实现配置动态刷新，nacos采用netty保持tcp场链接实时推送</li><li>nacos可用根据业务和环境进行分组管理</li><li>默认提供权重设置功能，调整承载流量压力</li><li>nacos支持由客户端或服务端发起的健康检查，eureka是由客户端发起心跳</li><li>nacos支持对服务在线管理，eureka只是预览服务状态</li></ol></li><li><p>选型建议？</p><p>采用eureka防范的考虑</p><ol><li>想用spring cloud 原生全家桶</li><li>想用本地文件和git作为配置管理的，将配置与服务分开管理</li><li>考虑短期的稳定性</li></ol><p>采用Nacos方案的考虑</p><ol><li>想在线对服务进行上下线和流量管理</li><li>不想采用MQ实现配置中心动态刷新</li><li>不想新增配置中心生产集群</li><li>考虑引入spring cloud alibaba生态</li></ol></li><li><p>eureka 和zookeeper都可以提供服务注册和发现的功能，请说说两个的区别？</p><ol><li><p>zookeeper保证的是cp，Eureka保证的ap</p><p>zookeeper在选举期间注册服务谈话，虽然服务最终会回复，但是选举期间不可用的</p><p>eureka各个节点是平等关系，只要有一台eureka就可以保证服务可以用，查询到的数据并不是最新的</p><blockquote><p>自我保护机制会导致：</p><p>eureka不再从注册列表移除因长时间没有收到心跳而应该过期的服务</p><p>eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点（高可用）</p><p>当网络稳定是，当前实例新的注册信息会被同步到其他节点中（最终一致性）</p><p>eureka可以很好的应对因为网络故障导致部分节点失去联系的情况，而不会像zookeeper一样使得整个注册系统瘫痪</p></blockquote></li><li><p>eureka可以看做是一个工程，而zookeeper只是一个进程</p></li></ol></li><li><p>springcloud是如何实现服务发现和注册的？</p><p>服务在发布时指定对应的服务名（包括了ip地址和端口）将服务注册到注册中心（eureka或者zookeeper或者nacos）</p><p>在main方法添加@enableDiscoveryClient 同一个服务修改端口就可以启动多个实例</p><p>调用方的话：传递服务名称通过注册中心获取所有的可用实例，通过负载均衡策略调用（ribbon和feign）对用的服务</p></li></ol><h2 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h2><h3 id="说一下mybatis与hibernate的区别"><a href="#说一下mybatis与hibernate的区别" class="headerlink" title="说一下mybatis与hibernate的区别"></a>说一下mybatis与hibernate的区别</h3><p><strong>共同点</strong></p><blockquote><p>都是通过orm对象关系映射框架，都是持久层数据框架</p></blockquote><p><strong>不同点</strong></p><ul><li>hibernate重量级框架，Mybatis是轻量级框架</li><li>Hibernate对jdbc的封装比较深，对开发者写sql的要求高，只要通过hql语句操作对象即可完成数据的持久化操作了</li><li>Mybatis也是对jdbc的封装，但是没有H那么深，他的sql语句都在配置里，也可以通过重新配置里sql，来实现数据优化</li><li>处理大数据的时候，建议使用Mybatis，它优化sql更方便</li></ul><h2 id="RocketMq"><a href="#RocketMq" class="headerlink" title="RocketMq"></a>RocketMq</h2><p><strong>核心模块</strong></p><ul><li>rocketmq-broker：接受生产者发来的消息并存储（通过调用rocketmq-stroe），消费者从这里取得消息</li><li>rocketmq-client：提供发送、接收消息的客户端API</li><li>rocketmq-namesrv：NameServer，类似于Zookeeper，这里保存着消息的TopicName，队列运行时的元信息</li><li>rocketmq-common：通用的一些类、方法、数据结构等</li><li>rocketmq-remoting：基于Netty4的client/Server + fastjson序列化 + 自定义二进制协议</li><li>rocketmq-store：消息、索引存储等</li><li>rocketmq-filtersrv：消息过滤器（一般用tag就可以）</li><li>rocketmq-tools：命令行工具</li></ul><p><strong>四大核心</strong>组成部分</p><p>他主要有四大核心：NameServer、Broker、Producer以及Consumer</p><img src="img/面试准备.assets/image-20200309102855022.png" alt="image-20200309102855022" style="zoom:50%;"><p>可以看到，他啥都是可以集群的，这是他吞吐量大，高可用的原因之一</p><p>集群的模式也很花哨，可以支持多master模式、多master多slave异步复制模式、多master多slave同步双写模式</p><p>而且这个模式好像kafka啊，废话，rocketmq 本身就是阿里基于kafka的很多特性研发的</p><h3 id="分别介绍一下各个集群组成部分"><a href="#分别介绍一下各个集群组成部分" class="headerlink" title="分别介绍一下各个集群组成部分"></a>分别介绍一下各个集群组成部分</h3><h4 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h4><blockquote><p>主要负责对数据源的管理，包括了对于topic和路由信息的管理。</p></blockquote><p>类似于Dubbo中zookeeper，但NameServer与Zookeeper相比更轻量。主要是因为每个NameServer节点互相之间是独立的，没有任何信息交互。</p><p>NameServer压力不会太大，平时的开销主要是维持心跳和提供Topic-Broker的关系数据。</p><p>但是有一点需要注意，Brker想NameServer发心跳时，会带上当前自己所负责的所有Topic信息，如果Topic个数太多（万级别），会导致一次心跳中，光Topic的数据就几十m，网络情况差的话，网络传输失败，心跳失败，导致NameServer误认为Broker心跳失败</p><p>NameServer被设计成几乎无状态的，可以横向扩展，节点之间相互之间无通信，通过部署多台机器来标记自己是个伪集群。</p><p>每个Broker在启动的时候都会到NameServer注册， Producer在发送消息前会根据Topic到NameServer获取到Broker的路由信息，Consumer也会定时获取Topic的路由信息。</p><p>所有从功能上看NameServer应该是和Zookeeper差不多，据说RocketMq的早期版本确实使用的Zookeeper，后来改为了自己实现的NameServer</p><h4 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h4><blockquote><p><strong>生产者</strong>，负责产生消息，一般是由业务系统负责产生消息</p></blockquote><ul><li>Producer又用户进行分布式部署，消息由Producer通过多种负责均衡模式发送到Broker集群，发送延时低，支持快速失败。</li><li>RocketMq提供了三种方式发送消息：同步、异步、单向<ul><li><strong>同步发送</strong>：指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包。一般用于重要通知消息，重要通知邮件，营销短信等</li><li><strong>异步发送</strong>：指发送方发出数据后，不等待接收方发回响应，就发送下个数据包，一般用于对响应时间不敏感的业务</li><li><strong>单向发送：</strong>值负责发送消息而不等待服务器的回应且没有回调函数触发，适用于某些耗时非常短但对可靠性要求并不高的场景，例如日志收集</li></ul></li></ul><h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><blockquote><p>消息<strong>中转角色</strong>，负责存储消息，转发消息</p></blockquote><p>Broker是具体提供业务的服务器，单个broker节点与所有的NameServer节点保持长连接及心跳，并会定时将Topic信息注册到NameServer，顺带一提底层的通信和连接都是基于netty实现的</p><p>Broker负责消息存储，以Topic为维度支持轻量级的队列，单机可以支撑上完队列规模，支持消息推拉模型</p><p>官网上说：具有<strong>上亿级消息堆积能力</strong>，同事可严格保证消息的<strong>有序性</strong></p><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><blockquote><p><strong>消费者</strong>，负责消费消息，一般是由后台系统负责异步消费</p></blockquote><p>Consumer也由用户部署，支持push和pull两种消费模式，支持<strong>集群消费</strong>和<strong>广播消费</strong>，提供实时的<strong>消息订阅机制</strong></p><p><strong>Pull：</strong>拉取，主动从消息服务器拉取消息，只要批量拉取到消息，用户应用就会启动消费过程</p><p><strong>Push：</strong>推送，封装了消息的拉取、消费进度和其他的内部维护工作，将消息到达时执行的回调接口留给用户应用程序来实现。所有Push被称为被动消费；从实现上看还是从消费服务器中拉取消息，不同于pull的是 push首先要注册消费监听器，当监听器触发后才开始消费消息。</p><h3 id="一次完成的通讯流程是什么样的？"><a href="#一次完成的通讯流程是什么样的？" class="headerlink" title="一次完成的通讯流程是什么样的？"></a>一次完成的通讯流程是什么样的？</h3><p>Producer 与 NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic陆游信息，并向Topic服务的Broker Master建立长连接，且定时向Broker发送心跳</p><p>Producer 只能将消息发送到Broker master，但是Consumer不一样，它同时和提供Topic的Master 和Slave建立长连接，既可以从Master订阅，也可以从Slave订阅消息</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>单机吞吐量：十万级</li><li>可用性：非常高，分布式架构</li><li>消息可靠性：经过参数优化配置，消息可以做到0丢失</li><li>功能支持：mq功能较为完善，还是分布式的，扩展性好</li><li>支持10亿级别的消息堆积，不会因为堆积导致性能下降</li><li>源码是java，我们可以自己阅读源码，定制自己公司的mq，可以掌控</li><li>天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况</li><li>稳定性更值得信赖，经历了多次双11</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>支持的客户端语言不多，java、c++(不成熟)</li><li>社区活跃度不是特别活跃的那种</li><li>没有在mq核心中去实现<strong>jms</strong>等接口，有些系统要迁移需要修改大量代码</li></ul><p>消息去</p><h1 id="陌陌面试题"><a href="#陌陌面试题" class="headerlink" title="陌陌面试题"></a>陌陌面试题</h1><h3 id="java多线程的实现？"><a href="#java多线程的实现？" class="headerlink" title="java多线程的实现？"></a>java多线程的实现？</h3><h3 id="二叉树后序遍历"><a href="#二叉树后序遍历" class="headerlink" title="二叉树后序遍历"></a>二叉树后序遍历</h3><h3 id="网络io模型"><a href="#网络io模型" class="headerlink" title="网络io模型"></a>网络io模型</h3><h3 id="三次握手每次在干嘛？"><a href="#三次握手每次在干嘛？" class="headerlink" title="三次握手每次在干嘛？"></a>三次握手每次在干嘛？</h3><h3 id="两个有序表的第n-和第n-1-大的数，不要额外空间，时间复杂度优化到nlogn？"><a href="#两个有序表的第n-和第n-1-大的数，不要额外空间，时间复杂度优化到nlogn？" class="headerlink" title="两个有序表的第n 和第n+1 大的数，不要额外空间，时间复杂度优化到nlogn？"></a>两个有序表的第n 和第n+1 大的数，不要额外空间，时间复杂度优化到nlogn？</h3><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><strong>单例模式</strong></h3><p><strong>优点</strong></p><blockquote><ol><li><p>只创建一个实例，节省内存开销 </p></li><li><p>减少了系统的性能开销，创建、回收对象都对性能有影响</p></li><li><p>提供了对唯一实例的受控访问</p></li><li><p>允许可变数目的实例</p></li></ol></blockquote><p><strong>缺点</strong></p><blockquote><ol><li>没有抽象层，因此扩展有很大的困难</li><li>单例类的职责过重，一定程度上违背了“单一职责原则”</li><li>滥用单例将带来一些负面问题：比如实例化的对象长时间不被利用，系统会认为是垃圾而回收</li></ol></blockquote><p><strong>使用场景</strong></p><blockquote><ul><li>web中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来</li><li>要求生产唯一序列号</li><li>创建一个对象需要消耗的资源过多，比如I/O与数据库的连接等</li></ul></blockquote><p><strong>关键代码</strong></p><blockquote><p>构造函数是私有的</p></blockquote><p><strong>注意事项</strong></p><blockquote><p>getInstance()方法中需要使用同步锁synchronized(Singleton.class)防止多线程同事进入造成instance被多次实例化。</p></blockquote><p><strong>懒汉</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类,在调用时才会初始化,因此是懒汉式</span></span><br><span class="line"><span class="comment"> * 看似是饿汉式,但只有调用getLazySingleton时才会初始化,线程安全由ClassLoad保证,不用思考怎么加锁</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 缺点:仍然会被反射和序列化攻击</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingletonHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton lazySingleton = <span class="keyword">new</span> LazySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getLazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazySingletonHolder.lazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>饿汉</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HungrySingleton 对象已经创建完成[在类加载时创建]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton hungrySingleton = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造函数,不能被外部访问</span></span><br><span class="line"><span class="comment">     * 创造对象的行为只能由这个类决定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回单例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getHungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungrySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建线程安全的单例有哪些实现方法？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">双检锁/双重校验锁</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span>==singleton)&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">null</span> == singleton)&#123;</span><br><span class="line">singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登记式/静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>枚举</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">INSTANCE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whatEverMethod</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="6"><li></li></ol></blockquote><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p><strong>ArrayList有用过吗？它是一个什么东西？可以用来做什么</strong>？</p><blockquote><p>就是一个数组列表，主要用来状态数据，如果装在的是基本数据类型（int、long、boolean、short、byte、double、char、float）的时候，只能存储他们对应的包装类,它的主要底层实现是数组</p><p>与它类似是LinkedList、和LinkedList相比，它的查找和访问元素的速度较快，但是增删慢</p><p><strong>小结：</strong>底层是数组实现的存储</p><p><strong>特点：</strong>查询效率高，增删效率低，线程不安全，使用频率高</p></blockquote><p><strong>线程不安全，为啥还使用它呢？</strong></p><blockquote><p>因为正常使用的场景中，都是用来查询，不会涉及太频繁的增删，如果涉及频繁的增删，可以使用LinkedList，如果要线程安全就使用Vector，这就是三者的区别，实际开发中还是ArrayList使用的最多。</p><p>不存在一个集合工具查询效率高，增删效率也高，线程还是安全的。</p><p>做的也都是一些线下的系统，没啥并发</p></blockquote><p><strong>它的底层是数组，数组是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？</strong></p><blockquote><p>ArrayList可以通过构造方法在初始化的时候指定底层数组的大小</p><p>如果是使用无参构造初始化，则赋值底层数据一个默认空数组，只有真正对数据进行添加是，才会分配默认的<strong>初始容量10</strong></p><p>可以看下它的无参构造和有参构造，无参就是默认大小，有参会判断参数</p></blockquote><p><strong>数组是有长度限制的，而ArrayList是可以存放任意数量对象，长度不受限制，那么他是怎么实现的呢？</strong></p><blockquote><p>实现比较简单，他就是通过数组扩容的方式去实现的。</p><p>比如说现在有一个长度为10的数组，需要新增第11个了，发现已经满了，那么会怎么做呢？</p><p>第一步：他会重新定义一个10+10/2的数组也就是一个长度为15的数组</p><p>第二步：把原数组的数据，原封不动的复制到新数组中，这个时候再把指向原数组的地址切换到新地址，ArrayList就这样完成了一次扩容</p></blockquote><p><strong>能具体说下1.7和1.8初始化的时候的区别么？</strong></p><blockquote><p>初始化的时候：1.7以前会调用this(10)的时候才是真正的容量为10，1.7开始就是默认走空数组了，只有第一次add的时候才会变成10</p></blockquote><p><strong>ArrayList的默认数组大小为什么是10？</strong></p><blockquote><p>不清楚。。。</p></blockquote><p><strong>为什么增删慢？</strong></p><blockquote><p>因为他的数组，是连续的内存空间，比如说删除一个的话，需要移动后面所有的</p></blockquote><p><strong>ArrayList（int initialCapacity）会不会初始化数组大小？</strong></p><blockquote><p>会初始化数组大小！但是List没，那size就没变，set下标和size比较的那就报错了。</p></blockquote><p><strong>ArrayList插入删除一定慢么？</strong></p><blockquote><p>取决于你删除的元素离数组末端有多远，ArrayList拿来作为堆栈来用还是挺合适的，push和pop操作完全不涉及数据移动操作。</p></blockquote><p><strong>它的删除是怎么实现的呢？</strong></p><blockquote><p>删除跟新增是一样的，不过叫是叫删除，但是在代码里可以发现，他还是在copy一个数组，举个例子：要删除index5这个位置</p><p><img src="img/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.assets/image-20200221162800968.png" alt="image-20200221162800968"></p><p>那么代码就复制一个index5+1到最后的数组，然后把它放到index开始的位置</p><p><img src="img/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.assets/image-20200221162852100.png" alt="image-20200221162852100"></p><p>index5的位置就被成功“删除了”，起始就是被覆盖了</p></blockquote><p>ArrayList是线程安全的么？</p><blockquote><p>当然不是，线程安全的数组容器是Vector</p><p>Vector的实现很简单，就是把所有的方法统统加上Synchronized就完事了。</p><p>你也可以不使用vector，用Collections.synchronizedList把一个普通的ArrayList包装成一个线程安全版本的数组容器也可以，原理同Vector是一样的，就是给所有的方法套上一层synchronized</p></blockquote><p>ArrayList用来做队列合适么？</p><blockquote><p>队列一般是FIFO（先进先出）的，如果用ArrayList做队列，就需要在数组尾部追加数据，数组头部删除数组，或者反过来。</p><p>但是无论如何总会有一个操作涉及到数组数据的迁移，耗费性能</p><p><strong>结论：</strong>不适合</p></blockquote><p><strong>那数组适合做队列吗？</strong></p><blockquote><p>数组是非常适合的</p><p>比如ArrayBlockingQueue内部实现就是一个环形队列，它是一个定长队列，内部是用一个定长数组来实现的。</p><p>另外著名的Disruptor开源Library也是用环形数组来实现的超高性能队列，具体原理不做解释，比较复杂。</p><p>简单点说就是使用两个偏移量来标记数组的读位置和写位置，如果超过长度就折回到数组开头，前提是它们是定长数组。</p></blockquote><p><strong>ArrayList的遍历和LinkedList遍历性能比较如何？</strong></p><blockquote><p>ArrayList快得多，内存是连续的，cpu的内部缓存结构会缓存连续的内存片段，可以大幅度降低读取内存的性能开销。</p></blockquote><p><strong>总结：</strong></p><blockquote><p>ArrayList就是动态数组，可以看成Array的复杂版本，提供了冬天的增删，实现了ICollection和IList接口，灵活的设置数组的大小等好处</p><p>面试频率不如HashMap和ConcurrentHashMap</p></blockquote><h1 id="秒杀系统设计"><a href="#秒杀系统设计" class="headerlink" title="秒杀系统设计"></a>秒杀系统设计</h1><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>要定点秒杀100件手机</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>高并发</strong></p><blockquote><p>时间短，瞬间用户量大</p></blockquote><p><strong>超卖</strong></p><p><strong>恶意请求</strong></p><blockquote><p>黄牛几十台机器脚本秒杀，模拟个十几万人的请求</p></blockquote><p><strong>链接暴露</strong></p><blockquote><p>前端暴露了地址，或者开发人员自己知道了，猛点</p></blockquote><p><strong>数据库</strong></p><blockquote><p>每秒上万甚至十几万的qps打到数据库，基本gg</p></blockquote><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>服务单一职责</strong></p><blockquote><p>微服务设计思想，再用分布式的部署方式</p><p>给秒单独的服务，单独的库</p><p><strong>好处：</strong>就算挂了， 也不会影响其他服务</p></blockquote><p><strong>秒杀连接加盐</strong></p><blockquote><p>把url动态化，就连写代码的人都不知道，通过md5之类的加密算法随机的字符串去做url，然后通过前端代码获取url后台校验才能通过。</p></blockquote><p>redis<strong>集群</strong></p><blockquote><p>单机redis顶不住，那就多找几个兄弟，秒杀本来就是读多写少</p><p>redis集群、主从同步、读写分离、还可以高点哨兵，开启持久化直接无敌高可用</p></blockquote><p><strong>nginx</strong></p><blockquote><p>高性能的web服务器，并发也是随便几万不是梦，但是tomcat只能顶几百的并发啊。那简单啊负载均衡嘛，一台服务器几百，那就多搞点，在秒杀的时候多租点流量机</p><p>恶意请求拦截也需要用它，一般单个用户请求次数太夸张，不像真人的请求在网关那一层就得拦截掉了</p></blockquote><p><strong>资源静态化</strong></p><blockquote><p>秒杀一般都是特定的商品还有页面模板，现在一般都是前后端分离的，所有页面一般是不会经过后端的，但是前段也要有自己的服务器啊，那就把能提前放到cdn服务器的东西都放进去，反正把能提升效率的步骤都做一下，减少真正秒杀时候服务器的压力</p></blockquote><p><strong>按钮控制</strong></p><blockquote><p>秒杀前按钮<strong>置灰</strong>，到点了才能点</p><p>这是防止在快到秒杀前的时间疯狂请求服务器，这个时候就需要前端的配合，定时去请求你的后端服务器，获取最新的北京时间，到时间点了再给按钮可以用</p><p>点击一次之后也得置灰几秒，防止一直点</p></blockquote><p><strong>限流</strong></p><blockquote><p>前端限流：跟按钮控制类似，防止一直点</p><p>后端限流：秒杀的时候肯定是涉及到了后续的<strong>订单生成</strong>和<strong>支付操作</strong>，一旦秒杀产品卖完了，return一个false，前端直接秒杀结束</p><p>真正的限流还会有限流组件，比如阿里的Sentinel、Hystrix等</p></blockquote><p><strong>库存预热</strong></p><blockquote><p>秒杀的本质，就是对库存的争夺，每个秒杀的用户来你都去数据库查询库存校验库存，然后扣减库存，对开发很不友好，而且数据库顶不住啊</p><p><strong>提前把商品的库存加载到redis中去</strong>，让整个流程都在redis里做，然后等秒杀结束了，再异步的去修改库存就好了</p><p>但是用redis的话就有一个问题了，我们上面说了主从，然后回去读库然后再判断有库存才去减库存，正常情况没问题，但是高并发的情况问题就很大了：比如只剩下一个库存了，高并发，四个服务器一起查询大家发现都还剩一个，都觉得自己抢到了，都去扣库存了，结果变成-3了，这样就发生了超卖</p><p><strong>Lua</strong>：lua脚本类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作，一个脚本=查库存+扣减库存，如果是0 了直接false</p></blockquote><p><strong>削峰填谷</strong></p><blockquote><p>说到这里就知道是说mq了，卖100个东西直接100个请求，我觉得没问题，但万一秒杀一万个，10万个呢，服务器挂了 </p><p>把他放消息队列，然后一点点消费去改库存不就好了嘛</p></blockquote><h1 id="消息队列基础"><a href="#消息队列基础" class="headerlink" title="消息队列基础"></a>消息队列基础</h1><p>经典场景，需要熟烂于心：异步、削峰、解耦</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a><strong>异步</strong></h3><blockquote><p>一个下单流程：本来需要100ms，后来产品说要加上积分，流程中加上积分扣减，200ms了</p><ul><li><p>产品说要加上优惠券，300毫秒了</p></li><li><p>产品说要发短信，400毫秒了</p></li><li><p>再后来。。。</p></li></ul><p>让产品加的这三点可以<strong>异步</strong></p></blockquote><p><strong>面试官：异步，我用线程、线程池去做不一样吗</strong>？</p><blockquote><p>为什么不能用线程去做？</p><p>用线程的话，扣积分、扣优惠券、发短信是不是都需要单独的接口？，每次加一个流程是不是代码都要改动？</p><p>但是用了消息队列，问题迎刃而解啊：</p><p>你下单了，你就把你支付成功的消息告诉别的系统，他们收到了去处理就好了，来多少类似的需求，只需要对应的人员去监听该消息就行了</p></blockquote><p><strong>那你的流程走完了，别人没成功怎么办？</strong></p><blockquote><p>起始不需要考虑，业务系统本身就是自己开发人员维护的，你扣积分失败和我下单有什么关系？</p></blockquote><h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>平时流量低，但是秒杀时流量猛增，你的服务器，redis，mysql各自的承受能力都不一样，全部流量赵丹全收肯定有问题啊，直接就挂了</p><p><strong>怎么办</strong></p><blockquote><p>把请求放到队列里面，每秒消费多少请求，就看自己的服务器处理能力，你能处理5000qps，你就消费这么多人，可能会比正常的慢一点，但是不至于打挂服务器，等流量高峰下去了，你的服务器也就没压力了</p></blockquote><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h2 id="消息去重、重复消费"><a href="#消息去重、重复消费" class="headerlink" title="消息去重、重复消费"></a>消息去重、重复消费</h2><p>原则：使用业务端逻辑保持幂等性</p><p>策略：保证每条消息都要唯一编号（比如唯一流水号），且保证消息处理成功与去重表的日志同时出现。</p><p>建立一个消息表，拿到这个消息做数据库的insert操作。给这个消息做一个唯一主键或约束，就算出现重复消费的情况，也会导致主键冲突，以后就不再处理这条消息了</p><h2 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h2><p><strong>Qos：Quality of Service 服务质量</strong></p><p>消息领域对投递的定义分为：</p><ul><li>最多一次</li><li>至少一次</li><li>仅一次</li></ul><p>几乎所有的mq产品都声称自己做到了  <strong>至少一次</strong></p><p>既然是至少一次，那避免不来消息重复，尤其是在分布式网络环境下</p><h2 id="消息可用性"><a href="#消息可用性" class="headerlink" title="消息可用性"></a>消息可用性</h2><p>当我们选择好了集群模式之后，那么我们需要关系的就是怎么去存储和复制这个数据，RocketMq对消息的刷盘提供了同步和异步的策略来满足我们。</p><p>同步刷盘：如果刷盘超时则会返给FLUSH_DISK_TIMEOUT，如果是异步刷盘不会返回刷盘相关信息，选择同步刷盘可以尽最大程度满足我们的消息不会丢失。</p><p>除了存储有选择之后，我们的主从同步提供了同步和异步两种模式来进行复制，当然选择同步可以提升可用性，但是消息的发送RT时间会下降10%左右。</p><p>RocketMq采用的是混合型的存储结构，即为Broker单个实例下所有的队列公用一个日志数据文件（即为COmmitLog）来存储</p><p>Kafka采用的是独立型的存储结构，每个队列一个文件。</p><p>RocketMq采用混合型存储结构的缺点在于：会存在较多的随机读操作，因此读的效率偏低。同时消费消息需要依赖ConsumeQueue，构建该逻辑消费队列需要一定开销。</p><h2 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h2><p>生产者消费者一般需要保证顺序消费的话，可能就是一个业务场景下的，比如订单的创建、支付、发货、收货。</p><p>那么这些东西是不是一个订单号呢？一个订单的肯定是一个订单号啊</p><p>一个topic下游多个队列，为了保证发送有序，RocketMq提供了MessageQueueSelector队列选择机制，他有三种实现：</p><img src="img/面试准备.assets/image-20200309154910190.png" alt="image-20200309154910190" style="zoom:50%;"><p>我们可以使用<strong>Hash取模法</strong>，让同一个订单发送到同一个队列中，再使用同步发送包，只有同个订单创建消息发送成功，再发送支付消息。这样就保证了<strong>发送有序</strong></p><p>Rokcet的topic内的队列机制，可以保证存储满足FIFO（先进先出），剩下的只需要消费者顺序消费即可</p><h2 id="分布式事务-1"><a href="#分布式事务-1" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="Half-Message-半消息）"><a href="#Half-Message-半消息）" class="headerlink" title="Half Message(半消息）"></a>Half Message(半消息）</h3><p>是指暂时不能倍Consumer消费的消息。Producer已经把消息成功发送到了Broker端，但此消息被标记为<strong>暂不能投递</strong>状态，处于该状态下的消息成为半消息，需要Producer对消息的二次确认后，Consumer才能去消费它。</p><h3 id="消息回查"><a href="#消息回查" class="headerlink" title="消息回查"></a>消息回查</h3><p>由于网络闪断，生产者重启等原因，导致Producer端一直没有对<strong>半消息</strong>进行二次确认，这时Brocker服务器会定时扫描长期处于半消息的消息，会主动询问Producer端，该消息的最终状态（Commit 或者 Rollback），该消息即为消息回查。</p><img src="img/面试准备.assets/image-20200309160441698.png" alt="image-20200309160441698" style="zoom:50%;"><p>A服务先发送个Half Message给Brock端，消息中携带 B服务 即将要+100元的信息。 </p><p>当A服务知道Half Message发送成功后，那么开始第3步执行本地事务。 </p><p>执行本地事务(会有三种情况1、执行成功。2、执行失败。3、网络等原因导致没有响应) </p><p>如果本地事务成功，那么Product像Brock服务器发送Commit,这样B服务就可以消费该message。 </p><p>如果本地事务失败，那么Product像Brock服务器发送Rollback,那么就会直接删除上面这条半消息。</p><p>如果因为网络等原因迟迟没有返回失败还是成功，那么会执行RocketMQ的回调接口,来进行事务的回查。</p><h2 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h2><h3 id="Broker端消息过滤"><a href="#Broker端消息过滤" class="headerlink" title="Broker端消息过滤"></a>Broker<strong>端消息过滤</strong></h3><p>在broker中，按照Consumer 的要求做过滤，优点是减少了对于 Consumer 无用消息的网络传输。缺点是增加了Broker的负担，实现相对复杂。</p><h3 id="Consumer-端消息过滤"><a href="#Consumer-端消息过滤" class="headerlink" title="Consumer 端消息过滤"></a>Consumer 端消息过滤</h3><p>这种过滤完全可由应用完全自定义实现，但是缺点是很多无用的消息要传到Consumer端</p><h2 id="Broker的Buffer问题"><a href="#Broker的Buffer问题" class="headerlink" title="Broker的Buffer问题"></a>Broker的Buffer问题</h2><p>Broker的buffer通常指的是Broker中一个队列的内存Buffer大小，这类Buffer通常大小有限。</p><p>另外，RokcetMq没有内存Buffer概念，RocketMq的队列都是持久化磁盘，数据定时清除。</p><p>RockertMq同其他mq有个非常显著的区别，RocketMq的内存Buffer抽象成一个无线长度的队列，不管有多少数据进来都能装得下，这个无线是有前提的，Broker会定期删除过期的数据。</p><p>例如Broker只保存三天的消息，那么Buffer长度虽然无线，但是3天前的数据会被从队尾删除。</p><h2 id="回溯消费"><a href="#回溯消费" class="headerlink" title="回溯消费"></a>回溯消费</h2><p>回溯消息是只Concumer已经消费成功的消息，由于业务上的需求需要重新消费，要支持此功能，Broker在向Consumer投递消息成功后，消息仍然需要保留。并且重新消费一般是按时间维度。</p><p>RocketMq支持按照时间回溯消费，可以精确到秒，可以向前，向后</p><h2 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h2><p>消息中间件的主要功能就是异步解耦，还有个重要功能是挡住前端的数据洪峰，保证后端系统的稳定性</p><p>消息堆积有两种</p><ul><li>堆积在内存Buffer，一旦超过内存Buffer，可以根据一定的丢弃策略来丢弃消息，这种情况堆积能力主要在于内存Buffer大小，而且消息堆积后，性能下降不大</li><li>堆积在持久化存储系统中，例如db，kv存储，文件记录形式。当消息不能再内存命cache命中时，要不可避免的访问磁盘，会产生大量读io，读io的吞吐量直接决定了消息堆积后的访问能力。</li></ul><p>评估消息堆积能力主要有以下四点：</p><ul><li>消息能堆积多少条，多少字节？即消息的堆积容量</li><li>消息堆积后，发消息的吞吐量大小，是否会受堆积影响？</li><li>正常消费的Consumer是否受影响</li><li>访问堆积在磁盘的消息是，吞吐量有多大？</li></ul><h2 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h2><p>定时消息是指消息发到Broker后，不能立刻被Consumer消费，要到特定的时间点或者等待特定的时间后才能被消费。</p><p>RocketMq支持定时消息，但是不支持任意时间精度，支持特定的level，例如5s,10s,1m等</p><p>如果要支持任意的时间精度，需要在Broker做，必须要做消息排序，再涉及到持久化，那么消息排序要不可避免的产生巨大性能开销</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;redis&quot;&gt;&lt;a href=&quot;#redis&quot; class=&quot;headerlink&quot; title=&quot;redis&quot;&gt;&lt;/a&gt;redis&lt;/h2&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;缓存雪崩-多
      
    
    </summary>
    
    
    
      <category term="面试" scheme="http://iwantjingjing.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java 面试</title>
    <link href="http://iwantjingjing.com/2020/02/01/java-%E9%9D%A2%E8%AF%95/"/>
    <id>http://iwantjingjing.com/2020/02/01/java-面试/</id>
    <published>2020-02-01T15:52:28.000Z</published>
    <updated>2020-03-18T08:21:10.884Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.javanav.com/interview/93b0069472fd479393006c0e73043fc4.html" target="_blank" rel="noopener">摘自</a></p><h1 id="基础与语法"><a href="#基础与语法" class="headerlink" title="基础与语法"></a>基础与语法</h1><h2 id="1-jdk-jre-区别"><a href="#1-jdk-jre-区别" class="headerlink" title="1 jdk jre 区别"></a>1 jdk jre 区别</h2><p>JRE：Java Runtime Environment（ java 运行时环境）。即java程序的运行时环境，包含了 java 虚拟机，java基础类库。</p><p>JDK：Java Development Kit（ java 开发工具包）。即java语言编写的程序所需的开发工具包。JDK 包含了 JRE，同时还包括 java 源码的编译器 javac、监控工具 jconsole、分析工具 jvisualvm等。</p><h2 id="2-和equals的区别是什么"><a href="#2-和equals的区别是什么" class="headerlink" title="2 ==和equals的区别是什么?"></a>2 ==和equals的区别是什么?</h2><p> == 的作用：</p><ul><li><p>基本类型：比较值是否相等</p></li><li><p>引用类型：比较内存地址值是否相等</p><p>equals() 的作用:<br>引用类型：默认情况下比较的是内存地址是否相等。可以按照需求逻辑，重写对象的equals（）方法（重写 equals() 方法，一般须重写 hashCode() 方法）。</p></li></ul><h2 id="3-基本类型和包装类对象使用-和-equals进行比较的结果？"><a href="#3-基本类型和包装类对象使用-和-equals进行比较的结果？" class="headerlink" title="3 基本类型和包装类对象使用 == 和 equals进行比较的结果？"></a>3 基本类型和包装类对象使用 == 和 equals进行比较的结果？</h2><p>1、值不同，使用 ＝＝ 和 equals() 比较都返回 false</p><p>2、值相同</p><p>使用 ＝＝ 比较：</p><ul><li>基本类型 － 基本类型、基本类型 － 包装对象返回 true</li><li>包装对象 － 包装对象返回 false</li><li>缓存中取的包装对象比较返回 true（原因是 JVM 缓存部分基本类型常用的包装类对象，如 Integer -128 ~ 127 是被缓存的）</li></ul><pre><code>Integer i1 = 100;Integer i2 = 100;Integer i3 = 200;Integer i4 = 200;System.out.println(i1==i2); //打印trueSystem.out.println(i3==i4); //打印false </code></pre><p>使用 equals() 比较</p><ul><li>包装对象－基本类型返回 true</li><li>包装对象－包装对象返回 true</li></ul><p>3、不同类型的对象对比，返回 false</p><p>JDK1.8，实验代码</p><pre><code>byte b1 = 127;Byte b2 = new Byte(&quot;127&quot;);Byte b3 = new Byte(&quot;127&quot;);System.out.println(&quot;Byte 基本类型和包装对象使用 == 比较 : &quot; + (b1 == b2));System.out.println(&quot;Byte 基本类型和包装对象使用 equals 比较 : &quot; + b2.equals(b1));System.out.println(&quot;Byte 包装对象和包装对象使用 == 比较 : &quot; + (b2 == b3));System.out.println(&quot;Byte 包装对象和包装对象使用 equals 比较 : &quot; + b2.equals(b3));System.out.println();short s1 = 12;Short s2 = new Short(&quot;12&quot;);Short s3 = new Short(&quot;12&quot;);System.out.println(&quot;Short 基本类型和包装对象使用 == 比较 : &quot; + (s1 == s2));System.out.println(&quot;Short 基本类型和包装对象使用 equals 比较 : &quot; + s2.equals(s1));System.out.println(&quot;Short 包装对象和包装对象使用 == 比较 : &quot; + (s2 == s3));System.out.println(&quot;Short 包装对象和包装对象使用 equals 比较 : &quot; + s2.equals(s3));System.out.println();char c1 = &apos;A&apos;;Character c2 = new Character(&apos;A&apos;);Character c3 = new Character(&apos;A&apos;);System.out.println(&quot;Character 基本类型和包装对象使用 == 比较 : &quot; + (c1 == c2));System.out.println(&quot;Character 基本类型和包装对象使用 equals 比较 : &quot; + c2.equals(c1));System.out.println(&quot;Character 包装对象和包装对象使用 == 比较 : &quot; + (c2 == c3));System.out.println(&quot;Character 包装对象和包装对象使用 equals 比较 : &quot; + c2.equals(c3));System.out.println();int i1 = 10000;Integer i2 = new Integer(10000);Integer i3 = new Integer(10000);System.out.println(&quot;Integer 基本类型和包装对象使用 == 比较 : &quot; + (i1 == i2));System.out.println(&quot;Integer 基本类型和包装对象使用 equals 比较 : &quot; + i2.equals(i1));System.out.println(&quot;Integer 包装对象和包装对象使用 == 比较 : &quot; + (i2 == i3));System.out.println(&quot;Integer 包装对象和包装对象使用 equals 比较 : &quot; + i2.equals(i3));System.out.println();long l1 = 1000000000000000L;Long l2 = new Long(&quot;1000000000000000&quot;);Long l3 = new Long(&quot;1000000000000000&quot;);System.out.println(&quot;Long 基本类型和包装对象使用 == 比较 : &quot; + (l1 == l2));System.out.println(&quot;Long 基本类型和包装对象使用 equals 比较 : &quot; + l2.equals(l1));System.out.println(&quot;Long 包装对象和包装对象使用 == 比较 : &quot; + (l2 == l3));System.out.println(&quot;Long 包装对象和包装对象使用 equals 比较 : &quot; + l2.equals(l3));System.out.println();float f1 = 10000.111F;Float f2 = new Float(&quot;10000.111&quot;);Float f3 = new Float(&quot;10000.111&quot;);System.out.println(&quot;Float 基本类型和包装对象使用 == 比较 : &quot; + (f1 == f2));System.out.println(&quot;Float 基本类型和包装对象使用 equals 比较 : &quot; + f2.equals(f1));System.out.println(&quot;Float 包装对象和包装对象使用 == 比较 : &quot; + (f2 == f3));System.out.println(&quot;Float 包装对象和包装对象使用 equals 比较 : &quot; + f2.equals(f3));System.out.println();double d1 = 10000.111;Double d2 = new Double(&quot;10000.111&quot;);Double d3 = new Double(&quot;10000.111&quot;);System.out.println(&quot;Double 基本类型和包装对象使用 == 比较 : &quot; + (d1 == d2));System.out.println(&quot;Double 基本类型和包装对象使用 equals 比较 : &quot; + d2.equals(d1));System.out.println(&quot;Double 包装对象和包装对象使用 == 比较 : &quot; + (d2 == d3));System.out.println(&quot;Double 包装对象和包装对象使用 equals 比较 : &quot; + d2.equals(d3));System.out.println();boolean bl1 = true;Boolean bl2 = new Boolean(&quot;true&quot;);Boolean bl3 = new Boolean(&quot;true&quot;);System.out.println(&quot;Boolean 基本类型和包装对象使用 == 比较 : &quot; + (bl1 == bl2));System.out.println(&quot;Boolean 基本类型和包装对象使用 equals 比较 : &quot; + bl2.equals(bl1));System.out.println(&quot;Boolean 包装对象和包装对象使用 == 比较 : &quot; + (bl2 == bl3));System.out.println(&quot;Boolean 包装对象和包装对象使用 equals 比较 : &quot; + bl2.equals(bl3));</code></pre><p>运行结果</p><pre><code>Byte 基本类型和包装对象使用 == 比较 : trueByte 基本类型和包装对象使用 equals 比较 : trueByte 包装对象和包装对象使用 == 比较 : falseByte 包装对象和包装对象使用 equals 比较 : trueShort 基本类型和包装对象使用 == 比较 : trueShort 基本类型和包装对象使用 equals 比较 : trueShort 包装对象和包装对象使用 == 比较 : falseShort 包装对象和包装对象使用 equals 比较 : trueCharacter 基本类型和包装对象使用 == 比较 : trueCharacter 基本类型和包装对象使用 equals 比较 : trueCharacter 包装对象和包装对象使用 == 比较 : falseCharacter 包装对象和包装对象使用 equals 比较 : trueInteger 基本类型和包装对象使用 == 比较 : trueInteger 基本类型和包装对象使用 equals 比较 : trueInteger 包装对象和包装对象使用 == 比较 : falseInteger 包装对象和包装对象使用 equals 比较 : trueLong 基本类型和包装对象使用 == 比较 : trueLong 基本类型和包装对象使用 equals 比较 : trueLong 包装对象和包装对象使用 == 比较 : falseLong 包装对象和包装对象使用 equals 比较 : trueFloat 基本类型和包装对象使用 == 比较 : trueFloat 基本类型和包装对象使用 equals 比较 : trueFloat 包装对象和包装对象使用 == 比较 : falseFloat 包装对象和包装对象使用 equals 比较 : trueDouble 基本类型和包装对象使用 == 比较 : trueDouble 基本类型和包装对象使用 equals 比较 : trueDouble 包装对象和包装对象使用 == 比较 : falseDouble 包装对象和包装对象使用 equals 比较 : trueBoolean 基本类型和包装对象使用 == 比较 : trueBoolean 基本类型和包装对象使用 equals 比较 : trueBoolean 包装对象和包装对象使用 == 比较 : falseBoolean 包装对象和包装对象使用 equals 比较 : true</code></pre><p>ps：可以延伸一个问题，基本类型与包装对象的拆/装箱的过程</p><h2 id="4-什么是装箱？什么是拆箱？装箱和拆箱的执行过程？常见问题？"><a href="#4-什么是装箱？什么是拆箱？装箱和拆箱的执行过程？常见问题？" class="headerlink" title="4 什么是装箱？什么是拆箱？装箱和拆箱的执行过程？常见问题？"></a>4 什么是装箱？什么是拆箱？装箱和拆箱的执行过程？常见问题？</h2><p>1、什么是装箱？什么是拆箱？<br>装箱：基本类型转变为包装器类型的过程。<br>拆箱：包装器类型转变为基本类型的过程。</p><pre><code>//JDK1.5之前是不支持自动装箱和自动拆箱的，定义Integer对象，必须Integer i = new Integer(8);//JDK1.5开始，提供了自动装箱的功能，定义Integer对象可以这样Integer i = 8;int n = i;//自动拆箱</code></pre><p>2、装箱和拆箱的执行过程？</p><ul><li>装箱是通过调用包装器类的 valueOf 方法实现的</li><li>拆箱是通过调用包装器类的 xxxValue 方法实现的，xxx代表对应的基本数据类型。</li><li>如int装箱的时候自动调用Integer的valueOf(int)方法；Integer拆箱的时候自动调用Integer的intValue方法。</li></ul><p>3、常见问题？</p><ul><li>整型的包装类 valueOf 方法返回对象时，在常用的取值范围内，会返回缓存对象。</li><li>浮点型的包装类 valueOf 方法返回新的对象。</li><li>布尔型的包装类 valueOf 方法 Boolean类的静态常量 TRUE | FALSE。</li></ul><p>实验代码</p><pre><code>Integer i1 = 100;Integer i2 = 100;Integer i3 = 200;Integer i4 = 200;System.out.println(i1 == i2);//trueSystem.out.println(i3 == i4);//falseDouble d1 = 100.0;Double d2 = 100.0;Double d3 = 200.0;Double d4 = 200.0;System.out.println(d1 == d2);//falseSystem.out.println(d3 == d4);//falseBoolean b1 = false;Boolean b2 = false;Boolean b3 = true;Boolean b4 = true;System.out.println(b1 == b2);//trueSystem.out.println(b3 == b4);//true</code></pre><ul><li>包含算术运算会触发自动拆箱。</li><li>存在大量自动装箱的过程，如果装箱返回的包装对象不是从缓存中获取，会创建很多新的对象，比较消耗内存。</li></ul><pre><code>Integer s1 = 0;long t1 = System.currentTimeMillis();for(int i = 0; i &lt;1000 * 10000; i++){    s1 += i;}long t2 = System.currentTimeMillis();System.out.println(&quot;使用Integer，递增相加耗时：&quot; + (t2 - t1));//使用Integer，递增相加耗时：68int s2 = 0;long t3 = System.currentTimeMillis();for(int i = 0; i &lt;1000 * 10000; i++){    s2 += i;}long t4 = System.currentTimeMillis();System.out.println(&quot;使用int&quot; + (t4 - t3));//使用int，递增相加耗时：6</code></pre><p>ps：可深入研究一下 javap 命令，看下自动拆箱、装箱后的class文件组成。<br>       看一下 JDK 中 Byte、Short、Character、Integer、Long、Boolean、Float、Double的 valueOf 和 xxxValue 方法的源码（xxx代表基本类型如intValue）。     </p><h2 id="hashCode-相同，equals-也一定为true吗？"><a href="#hashCode-相同，equals-也一定为true吗？" class="headerlink" title="hashCode()相同，equals()也一定为true吗？"></a>hashCode()相同，equals()也一定为true吗？</h2><p>首先，答案肯定是不一定。同时反过来 equals() 为true，hashCode() 也不一定相同。</p><ul><li>类的 hashCode() 方法和 equals() 方法都可以重写，返回的值完全在于自己定义。</li><li>hashCode() 返回该对象的哈希码值；equals() 返回两个对象是否相等。</li></ul><p>关于 hashCode() 和 equals() 是方法是有一些 常规协定 ：</p><ul><li><p>1、两个对象用 equals() 比较返回true，那么两个对象的hashCode()方法必须返回相同的结果。</p></li><li><p>2、两个对象用 equals() 比较返回false，不要求hashCode()方法也一定返回不同的值，但是最好返回不同值，以提搞哈希表性能。</p></li><li><p>3、重写 equals() 方法，必须重写 hashCode() 方法，以保证 equals() 方法相等时两个对象 hashcode() 返回相同的值。</p></li></ul><h2 id="final在java中的作用"><a href="#final在java中的作用" class="headerlink" title="final在java中的作用"></a>final在java中的作用</h2><p>final 语义是不可改变的。</p><ul><li>被 final 修饰的类，不能够被继承。</li><li>被 final 修饰的成员变量必须要初始化，赋初值后不能再重新赋值(可以调用对象方法修改属性值)。对基本类型来说是其值不可变；对引用变量来说其引用不可变，即不能再指向其他的对象。</li><li>被 final 修饰的方法代表不能重写。</li></ul><h2 id="final-finally-finalize-区别"><a href="#final-finally-finalize-区别" class="headerlink" title="final finally finalize()区别"></a>final finally finalize()区别</h2><ul><li><p>final 表示最终的、不可改变的。用于修饰类、方法和变量。final 变量必须在声明时给定初值，只能读取，不可修改。final 方法也同样只能使用，不能重写，但能够重载。final 修饰的对象，对象的引用地址不能变，但对象的属性值可以改变</p></li><li><p>finally 异常处理的一部分，它只能用在 try/catch 语句中，表示希望 finally 语句块中的代码最后一定被执行（存在一些情况导致 finally 语句块不会被执行，如 jvm 结束）</p></li><li><p>finalize() 是在 java.lang.Object 里定义的，Object 的 finalize() 方法什么都不做，对象被回收时 finalize() 方法会被调用。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要清理工作，在垃圾收集器删除对象之前被调用的。一般情况下，此方法由JVM调用。特殊情况下，可重写 finalize() 方法，当对象被回收的时候释放一些资源，须调用 super.finalize() 。 </p></li></ul><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="-2"><a href="#-2" class="headerlink" title></a></h2><h2 id="-3"><a href="#-3" class="headerlink" title></a></h2><h2 id="-4"><a href="#-4" class="headerlink" title></a></h2><h2 id="-5"><a href="#-5" class="headerlink" title></a></h2><h2 id="-6"><a href="#-6" class="headerlink" title></a></h2><h2 id="-7"><a href="#-7" class="headerlink" title></a></h2><h2 id="-8"><a href="#-8" class="headerlink" title></a></h2><h2 id="-9"><a href="#-9" class="headerlink" title></a></h2><h2 id="-10"><a href="#-10" class="headerlink" title></a></h2><h2 id="-11"><a href="#-11" class="headerlink" title></a></h2><h2 id="-12"><a href="#-12" class="headerlink" title></a></h2><h2 id="-13"><a href="#-13" class="headerlink" title></a></h2><h2 id="-14"><a href="#-14" class="headerlink" title></a></h2><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h1 id="文件解析与生成"><a href="#文件解析与生成" class="headerlink" title="文件解析与生成"></a>文件解析与生成</h1><h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><h1 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h1><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.javanav.com/interview/93b0069472fd479393006c0e73043fc4.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;摘自&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;基础与语法
      
    
    </summary>
    
    
    
      <category term="面试，Java" scheme="http://iwantjingjing.com/tags/%E9%9D%A2%E8%AF%95%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>读与时间做朋友有感</title>
    <link href="http://iwantjingjing.com/2019/12/22/%E8%AF%BB%E4%B8%8E%E6%97%B6%E9%97%B4%E5%81%9A%E6%9C%8B%E5%8F%8B%E6%9C%89%E6%84%9F/"/>
    <id>http://iwantjingjing.com/2019/12/22/读与时间做朋友有感/</id>
    <published>2019-12-22T13:13:44.000Z</published>
    <updated>2019-12-22T13:55:59.347Z</updated>
    
    <content type="html"><![CDATA[<p>近日读完了李笑来写的《与时间做朋友》收货一下观点</p><ul><li><p>1 20分钟学习命令行下的批处理方法</p></li><li><p>2 Google通配符学习</p></li><li><p>3 概率统计学（买彩票这种行为在学过概率统计的人看来是对自己智商的侮辱）</p></li><li><p>4 千万不要拒绝学习</p></li><li><p>5 《今春的两种感想》对体验、试错、和观察进行补充的就是阅读。</p></li><li><p>6 伯纳姆与杰.费伦著《本能》</p></li><li><p>7 电影《新基督山伯爵》</p></li><li><p>8 达尔文《物种起源》 1859年11月24日</p></li><li><p>9 愚人网</p></li><li><p>10猴子吃香蕉被打（经验主义害猴子被打）</p></li><li><p>11 亚里士多德《论问题》”强光喷嚏反射”</p></li><li><p>12 美国前第一夫人罗莎琳.卡特就观察到了这样一个现象：”优秀的领导，能够把人们带到他们想去的地方，而卓越的领导，能够把人们带到他们应该去但是没想过要去的地方。<br>A leader takes people where they want to go .<br>A grate leader takes people where they don’t necessarily want to go ,but ought to be.</p></li><li><p>13 人在学生时期应该认真阅读至少3本关于科学史和科学方法的书籍</p></li><li><p>14 在人们探索未知、寻求真理的时候，困难几乎都来自于如何正确的理解”与现有经验相悖的知识”</p></li><li><p>15 自学能力的基础是阅读理解能力</p></li><li><p>16 写作能力在自学能力中占据重要位置。（这里提到的”写作能力”不是写小说的能力，不是写诗歌的能力，不是写剧本的能力，也不是写散文的能力，只是写作能力中最基本的一种——写出简洁、有效、准确、朴素、具体的说明性文章的能力。</p></li><li><p>17 对抗选择性输入：把目前无法理解的、支持的、反对的、无所谓的论点和观点记录下来。对无法理解的，写下自己当时的疑惑何在，对支持的，记录下几个理由或者实例；对反对的，同样记录几个理由或者实例；甚至对那些无所谓的，也记录其原因。一个有着这样良好记录习惯的人会获得他人无法拥有的处理信息和知识的能力——反刍chu</p></li><li><p>18 读教科书，要先把所有概念都记下来，暂时不懂的就死记硬背。把概念牢记于心，就可以通过以后的学习和实践反复审视它，并形成透彻理解。</p></li><li><p>19 学习任何一门学科，都最好先去读一下该学科的发展历史，这是最好的起点。</p></li><li><p>20 《围城》钱钟书著</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近日读完了李笑来写的《与时间做朋友》收货一下观点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1 20分钟学习命令行下的批处理方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2 Google通配符学习&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3 概率统计学（买彩票这种行为在学过概率统计的人看来是对自
      
    
    </summary>
    
    
    
      <category term="读后感，李笑来" scheme="http://iwantjingjing.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F%EF%BC%8C%E6%9D%8E%E7%AC%91%E6%9D%A5/"/>
    
  </entry>
  
  <entry>
    <title>DevOps简介</title>
    <link href="http://iwantjingjing.com/2019/12/02/DevOps%E7%AE%80%E4%BB%8B/"/>
    <id>http://iwantjingjing.com/2019/12/02/DevOps简介/</id>
    <published>2019-12-02T08:29:09.000Z</published>
    <updated>2019-12-22T13:13:03.794Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/liufei1983/p/7152013.html" target="_blank" rel="noopener">摘抄自</a></p><h1 id="DevOps简介"><a href="#DevOps简介" class="headerlink" title="DevOps简介"></a>DevOps简介</h1><p>DevOps是一个完整的面向IT运维的工作流，以IT自动化以及持续集成（CI）、持续部署（CD）为基础，来优化开发、测试、系统运维等多有环节。</p><h1 id="DevOps的概念"><a href="#DevOps的概念" class="headerlink" title="DevOps的概念"></a>DevOps的概念</h1><p>DevOps一词的来自于Development和Operations的组合，突出重视软件开发人员和运维人员的沟通合作，通过自动化流程来使得软件构建、测试、发布更加快捷、频繁和可靠。</p><p><img src="devops.png" alt><br>DevOps是为了填补开发端和运维端之间的信息鸿沟，改善团队之间的协作关系。不过需要澄清的一点是，从开发到运维，中间还有测试环节。DevOps其实包含了三个部分：开发、测试和运维。</p><p><img src="dev2.png" alt><br>换句话说，DevOps希望做到的是软件产品交付过程中IT工具链的打通，使得各个团队减少时间损耗，更加高效地协同工作。专家们总结出了下面这个DevOps能力图，良好的闭环可以大大增加整体的产出。<br><img src="dev3.png" alt></p><h1 id="历史变革"><a href="#历史变革" class="headerlink" title="历史变革"></a>历史变革</h1><p>由上所述，相信大家对DevOps有了一定的了解。但是除了触及工具链之外，作为文化和技术的方法论，DevOps还需要公司在组织文化上的变革。回顾软件行业的研发模式，可以发现大致有三个阶段：瀑布式开发、敏捷开发、DevOps。</p><p>DevOps早在九年前就有人提出来，但是，为什么这两年才开始受到越来越多的企业重视和实践呢？因为DevOps的发展是独木不成林的，现在有越来越多的技术支撑。微服务架构理念、容器技术使得DevOps的实施变得更加容易，计算能力提升和云环境的发展使得快速开发的产品可以立刻获得更广泛的使用。</p><p>好处是什么？</p><p>DevOps的一个巨大好处就是可以高效交付，这也正好是它的初衷。Puppet和DevOps Research and Assessment (DORA) 主办了2016年DevOps调查报告，根据全球4600位各IT公司的技术工作者的提交数据统计，得出高效公司平均每年可以完成1460次部署。</p><p>与低效组织相比，高效组织的部署频繁200倍，产品投入使用速度快2555倍，服务恢复速度快24倍。在工作内容的时间分配上，低效者要多花22%的时间用在为规划好或者重复工作上，而高效者却可以多花29%的时间用在新的工作上。所以这里的高效不仅仅指公司产出的效率提高，还指员工的工作质量得到提升。</p><p>DevOps另外一个好处就是会改善公司组织文化、提高员工的参与感。员工们变得更高效，也更有满足和成就感；调查显示高效员工的雇员净推荐值（eNPS:employee Net Promoter Score）更高，即对公司更加认同。</p><p>快速部署同时提高IT稳定性。这难道不矛盾吗？</p><p>快速的部署其实可以帮助更快地发现问题，产品被更快地交付到用户手中，团队可以更快地得到用户的反馈，从而进行更快地响应。而且，DevOps小步快跑的形式带来的变化是比较小的，出现问题的偏差每次都不会太大，修复起来也会相对容易一些。</p><p><img src="dev4.png" alt></p><p>因此，认为速度就意味着危险是一种偏见。此外，滞后软件服务的发布也并不一定会完全地避免问题，在竞争日益激烈的IT行业，这反而可能错失了软件的发布时机</p><h1 id="为什么DevOps会兴起？"><a href="#为什么DevOps会兴起？" class="headerlink" title="为什么DevOps会兴起？"></a>为什么DevOps会兴起？</h1><h2 id="条件成熟：技术配套发展"><a href="#条件成熟：技术配套发展" class="headerlink" title="条件成熟：技术配套发展"></a>条件成熟：技术配套发展</h2><p>技术的发展使得DevOps有了更多的配合。早期时，大家虽然意识到了这个问题的，但是苦于当时没有完善丰富的技术工具，是一种“理想很丰满，但是现实很骨感”的情况。DevOps的实现可以基于新兴的容器技术；也可以在自动化运维工具Puppet、SaltStack、Ansible之后的延伸；还可以构建在传统的Cloud Foundry、OpenShift等PaaS厂商之上。</p><h2 id="来自市场的外部需求：这世界变化太快"><a href="#来自市场的外部需求：这世界变化太快" class="headerlink" title="来自市场的外部需求：这世界变化太快"></a>来自市场的外部需求：这世界变化太快</h2><p>IT行业已经越来越与市场的经济发展紧密挂钩，专家们认为IT将会有支持中心变成利润驱动中心。事实上，这个变化已经开始了，这不仅体现在Google、苹果这些大企业中，而且也发生在传统行业中，比如出租车业务中的Uber、酒店连锁行业中的Airbnb、图书经销商Amazon等等。能否让公司的IT配套方案及时跟上市场需求的步伐，在今天显得至关重要。</p><p>DevOps 2016年度报告给出了一个运维成本的计算公式：<br>停机费用成本 = 部署频率 * 版本迭代失败概率 * 平均修复时间 * 断电的金钱损失</p><p>来自团队的内在动力：工程师也需要</p><p>对于工程师而言，他们也是DevOps的受益者。微软资深工程师Scott Hanselman说过“对于开发者而言，最有力的工具就是自动化工具”（The most powerful tool we have as developers is automation）。</p><p>工具链的打通使得开发者们在交付软件时可以完成生产环境的构建、测试和运行；正如Amazon的VP兼CTO Werner Vogels那句让人印象深刻的话：“谁开发谁运行”。（You build it, you run it）</p><h2 id="实现DevOps需要什么？"><a href="#实现DevOps需要什么？" class="headerlink" title="实现DevOps需要什么？"></a>实现DevOps需要什么？</h2><h2 id="硬性要求：工具上的准备"><a href="#硬性要求：工具上的准备" class="headerlink" title="硬性要求：工具上的准备"></a>硬性要求：工具上的准备</h2><p>上文提到了工具链的打通，那么工具自然就需要做好准备。现将工具类型及对应的不完全列举整理如下：</p><ul><li><p>代码管理（SCM）：GitHub、GitLab、BitBucket、SubVersion</p></li><li><p>构建工具：Ant、Gradle、maven</p></li><li><p>自动部署：Capistrano、CodeDeploy</p></li><li><p>持续集成（CI）：Bamboo、Hudson、Jenkins</p></li><li><p>配置管理：Ansible、Chef、Puppet、SaltStack、ScriptRock GuardRail</p></li><li><p>容器：Docker、LXC、第三方厂商如AWS</p></li><li><p>编排：Kubernetes、Core、Apache Mesos、DC/OS</p></li><li><p>服务注册与发现：Zookeeper、etcd、Consul</p></li><li><p>脚本语言：python、ruby、shell</p></li><li><p>日志管理：ELK、Logentries</p></li><li><p>系统监控：Datadog、Graphite、Icinga、Nagios</p></li><li><p>性能监控：AppDynamics、New Relic、Splunk</p></li><li><p>压力测试：JMeter、Blaze Meter、loader.io</p></li><li><p>预警：PagerDuty、pingdom、厂商自带如AWS SNS</p></li><li><p>HTTP加速器：Varnish</p></li><li><p>消息总线：ActiveMQ、SQS</p></li><li><p>应用服务器：Tomcat、JBoss</p></li><li><p>Web服务器：Apache、Nginx、IIS</p></li><li><p>数据库：MySQL、Oracle、PostgreSQL等关系型数据库；cassandra、mongoDB、redis等NoSQL数据库</p></li><li><p>项目管理（PM）：Jira、Asana、Taiga、Trello、Basecamp、Pivotal Tracker<br>在工具的选择上，需要结合公司业务需求和技术团队情况而定。（注：更多关于工具的详细介绍可以参见此文：51 Best DevOps Tools for #DevOps Engineers）</p></li></ul><h2 id="软性需求：文化和人"><a href="#软性需求：文化和人" class="headerlink" title="软性需求：文化和人"></a>软性需求：文化和人</h2><p>DevOps成功与否，公司组织是否利于协作是关键。开发人员和运维人员可以良好沟通互相学习，从而拥有高生产力。并且协作也存在于业务人员与开发人员之间。</p><p>出席了2016年伦敦企业级DevOps峰会的ITV公司在2012年就开始落地DevOps，其通用平台主管Clark在接受了InfoQ的采访，在谈及成功时表示，业务人员非常清楚他们希望在最小化可行产品中实现什么，工程师们就按需交付，不做多余工作。</p><p>这样，工程师们使用通用的平台（即打通的工具链）得到更好的一致性和更高的质量。此外，DevOps对工程师个人的要求也提高了，很多专家也认为招募到优秀的人才也是一个挑战。</p><h2 id="DevOps的采用现状"><a href="#DevOps的采用现状" class="headerlink" title="DevOps的采用现状"></a>DevOps的采用现状</h2><h3 id="哪些公司在用？"><a href="#哪些公司在用？" class="headerlink" title="哪些公司在用？"></a>哪些公司在用？</h3><p>DevOps正在增长，尤其是在大企业中：调查发现，DevOps的接受度有了显著提高。74%的受访者已经接受了DevOps，而去年这一比例为66%。目前，在81%的大企业开始接受DevOps，中小企业的接受度仅为70%。<br>那么具体而言都有些公司在采用DevOps呢？Adobe、Amazon、Apple、Airbnb、Ebay、Etsy、Facebook、LinkedIn、Netflix、NASA、Starbucks、Target（泛欧实时全额自动清算系统）、Walmart、Sony等等。</p><h3 id="他们怎么实施的？"><a href="#他们怎么实施的？" class="headerlink" title="他们怎么实施的？"></a>他们怎么实施的？</h3><p>首先，大企业正在自下而上接受DevOps，其中业务单位或部门（31%）以及项目和团队（29%）已经实施DevOps。不过，只有21%的大企业在整个公司范围内采用了DevOps。 </p><p>其次，在工具层面上，DevOps工具的用量大幅激增。Chef和Puppet依然是最常用的DevOps工具，使用率均为32%。Docker是年增长率最快的工具，用量增长一倍以上。Ansible的用量也有显著增加，使用率从10%翻倍至20%。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/liufei1983/p/7152013.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;摘抄自&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;DevOps简介&quot;&gt;&lt;a href=&quot;#DevOps
      
    
    </summary>
    
    
      <category term="开发模式" scheme="http://iwantjingjing.com/categories/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="DevOps" scheme="http://iwantjingjing.com/tags/DevOps/"/>
    
      <category term="开发模式，摘抄" scheme="http://iwantjingjing.com/tags/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%91%98%E6%8A%84/"/>
    
  </entry>
  
  <entry>
    <title>读别让自己墙了自己有感</title>
    <link href="http://iwantjingjing.com/2019/12/02/%E8%AF%BB%E5%88%AB%E8%AE%A9%E8%87%AA%E5%B7%B1%E5%A2%99%E4%BA%86%E8%87%AA%E5%B7%B1%E6%9C%89%E6%84%9F/"/>
    <id>http://iwantjingjing.com/2019/12/02/读别让自己墙了自己有感/</id>
    <published>2019-12-02T05:38:44.000Z</published>
    <updated>2019-12-22T13:22:53.914Z</updated>
    
    <content type="html"><![CDATA[<p> <a href="https://coolshell.cn/articles/20276.html/comment-page-2#comments" target="_blank" rel="noopener">文章链接</a></p><h1 id="收获的主题"><a href="#收获的主题" class="headerlink" title="收获的主题"></a>收获的主题</h1><ul><li><p>只专注于一种技术其他都是垃圾（不要将自己的技术栈封闭起来）</p></li><li><p>关注负面的东西不要胜过正面的东西</p></li><li><p>离开Java的世界就基本上做不了架构了</p></li><li><p>把自己最宝贵的时间用在了很烂的项目上，就算能用一些新技术也只能是自娱自乐，在实验室中玩玩罢了</p></li><li><p>把自己的技术栈封闭起来，直接放弃了这个时代最具有工业化的技术Java，对于一个好的程序员来说同时掌握几种语言和技术是完全没有问题的，不要自己封闭了自己的视野</p></li><li><p>视野、环境和舞台对一个人的限制是非常大的。井蛙不知大海，被空间维度所限制；夏虫不知冬天，被时间维度所限制；圈养的动物没有斗志，是被自己意志所限制。</p></li><li><p>偏见和不开放，对一个人限制是真正有毁灭性的。主动让自己成为一个瞎子和聋子，主动把自己能力阉割掉是多么让人痛心的一件事。</p></li><li><p>不限制自己的人会穷举各种方法来解决问题，限制自己的人，会找各式各样的问题或借口。</p></li><li><p>不限制自己的人，会努力改变自己的问题和缺陷，限制自己的人会放任自己。</p></li><li><p>先把软件设计好再写代码。</p><h1 id="技术方向"><a href="#技术方向" class="headerlink" title="技术方向"></a>技术方向</h1></li><li><p>Docker、go、k8s</p></li><li><p>翻找Youtube的各种大会，GitHub的各种issue和pull request</p></li><li><p>成为一个技术牛人的条件：基础知识过硬，细节扎得深，面很广，学习能力强，有英文能力，逻辑思维能力不错，非常的自律，执行力也很强，抓得住重点,最重要的一点：在大公司历练过。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></li><li><p>做高价值的事。所谓高价值，就是：别人愿付高价的，高技术门槛的，有创造力的，颠覆性的……</p></li><li><p>扩大自己的眼界，开放自己的内心。你的英文语言能力对你能不能融入世界是起决定性的作用。你的视野决定了你知不知道要去哪，你的开放决定了你想不想去。</p></li><li><p>站在更高的维度.面的维度会超过点的维度，空间的维度会超过面的维度，在更高维度上思考和学习，你会收货更多。整天在焦虑那些低维度的事（比如自己的薪水、工作的地点、稳不稳定、有没有户口……)，只会让你变得越来越平庸，只要你站在更高的维度（比如：眼界有没有扩大、可能性是不是更多、竞争力是不是更强、能不能解决更大更难的问题、能创造多大的价值……)，时间会让你明白那些低维度的东西全都不是事儿。技术学习上也一样，站在学习编程语法特性的维度和站在学习编程范式、设计模式的维度是两种完全不一样的学习方式。</p></li><li><p>精于计算得失。很多人其实不是很懂计算。绝大多数人都是在计算自己会失去多少，而不会算得到多少。而一般的人也总是在算短期内会失去什么，优秀的则总是会算我投入后未来会有什么样的回报，前者在算计今天，目光短浅，而后者则是舍在今天，得在明天，计算的是未来。精于计算得失的，就懂得什么是投资，不懂的只会投机。对于赚钱，你可以投机，但是对于自己最好还是投资。</p></li><li><p>勇于跳出传统的束缚。做”鸡”的比”二奶”好多了</p></li><li><p>别自己墙了自己，人最可悲的就是自己限制自己，想都不敢想！</p><p>庄子曰过：</p><p> 井蛙不可以语于海者，拘于虚也；//空间局限</p><p> 夏虫不可以语于冰者，笃于时也；//时间局限</p><p> 曲士不可以语于道者，束于教也。//认识局限</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;a href=&quot;https://coolshell.cn/articles/20276.html/comment-page-2#comments&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章链接&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;收获的主题&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="读后感" scheme="http://iwantjingjing.com/categories/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    
      <category term="读后感，左耳" scheme="http://iwantjingjing.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F%EF%BC%8C%E5%B7%A6%E8%80%B3/"/>
    
  </entry>
  
  <entry>
    <title>杀威棍</title>
    <link href="http://iwantjingjing.com/2019/10/06/%E6%9D%80%E5%A8%81%E6%A3%8D/"/>
    <id>http://iwantjingjing.com/2019/10/06/杀威棍/</id>
    <published>2019-10-06T08:06:05.000Z</published>
    <updated>2019-10-06T08:13:39.634Z</updated>
    
    <content type="html"><![CDATA[<p>《说唐》里秦叔宝进牢房时,衙役喊得一句话来解释:<br>“进的牢来先打你一百杀威棍,看你老不老实!”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《说唐》里秦叔宝进牢房时,衙役喊得一句话来解释:&lt;br&gt;“进的牢来先打你一百杀威棍,看你老不老实!”&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="传统文化" scheme="http://iwantjingjing.com/tags/%E4%BC%A0%E7%BB%9F%E6%96%87%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>gpg是什么  </title>
    <link href="http://iwantjingjing.com/2019/09/28/gpg%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://iwantjingjing.com/2019/09/28/gpg是什么/</id>
    <published>2019-09-28T12:41:03.000Z</published>
    <updated>2019-09-28T12:42:35.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GPG简介"><a href="#GPG简介" class="headerlink" title="GPG简介"></a>GPG简介</h1><p>　　GPG是GNU Privacy Guard的缩写，它是一种基于密钥的加密方式，使用了一对密钥对消息进行加密和解密，来保证消息的安全传输。<br>　　GPG有许多用途，主要用于文件加密。yum安装软件包的时候会使用gpg来验证。</p><h2 id="1、大多数的linux发行版都默认包含了gpg"><a href="#1、大多数的linux发行版都默认包含了gpg" class="headerlink" title="1、大多数的linux发行版都默认包含了gpg"></a>1、大多数的linux发行版都默认包含了gpg</h2><pre><code># gpg --version</code></pre><h2 id="2、gpg常用命令"><a href="#2、gpg常用命令" class="headerlink" title="2、gpg常用命令"></a>2、gpg常用命令</h2><pre><code>创建密钥 $ gpg --gen-key查看公钥 $ gpg --list-key查看私钥 $ gpg --list-secret-key公钥删除 $ gpg --delete-keys 标识名私钥删除 $ gpg --delete-secret-keys 标识名公钥导出 $ gpg --export 标识名 &gt; 导出文件名（多以gpg,asc为文件后缀）私钥导出 $ gpg --export-secret-key 标识名 &gt; 导出文件名（多以asc为文件后缀）密钥导入 $ gpg --import 密钥文件加密文件 $ gpg --recipient 标识名 --encrypt 文件名解密文件 $ gpg --output 新文件名 --decrypt 加密文件名修改密钥 $ gpg --edit-key 标识名</code></pre><h2 id="3、gpg加密和ssh加密的区别"><a href="#3、gpg加密和ssh加密的区别" class="headerlink" title="3、gpg加密和ssh加密的区别"></a>3、gpg加密和ssh加密的区别</h2><p>ssh加密是专们为远程登录和其他网络服务，如ftp 提供安全的一个软件<br>gpg是用来加密文件的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GPG简介&quot;&gt;&lt;a href=&quot;#GPG简介&quot; class=&quot;headerlink&quot; title=&quot;GPG简介&quot;&gt;&lt;/a&gt;GPG简介&lt;/h1&gt;&lt;p&gt;　　GPG是GNU Privacy Guard的缩写，它是一种基于密钥的加密方式，使用了一对密钥对消息进行加密和解密
      
    
    </summary>
    
    
      <category term="gpg" scheme="http://iwantjingjing.com/categories/gpg/"/>
    
    
      <category term="gpg" scheme="http://iwantjingjing.com/tags/gpg/"/>
    
  </entry>
  
  <entry>
    <title>论语学习</title>
    <link href="http://iwantjingjing.com/2019/09/28/%E8%AE%BA%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    <id>http://iwantjingjing.com/2019/09/28/论语学习/</id>
    <published>2019-09-28T09:51:05.000Z</published>
    <updated>2019-09-28T12:31:51.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习地址"><a href="#学习地址" class="headerlink" title="学习地址"></a>学习地址</h1><p><a href="https://mooc1.chaoxing.com/ztnodedetailcontroller/visitnodedetail?courseId=201598687&knowledgeId=124210600&_from_=" target="_blank" rel="noopener">超星尔雅</a></p><h1 id="第一讲孔子思想的特色"><a href="#第一讲孔子思想的特色" class="headerlink" title="第一讲孔子思想的特色"></a>第一讲孔子思想的特色</h1><p>温和的理性主义</p><p>深刻的人道情怀</p><p>乐观的人生理想</p><h1 id="第二讲学儿篇"><a href="#第二讲学儿篇" class="headerlink" title="第二讲学儿篇"></a>第二讲学儿篇</h1><p>学而时习之(从学习中发现快乐)</p><p>时:适当的时候</p><p>学了做人处事的道理适当的时候加以练习运用</p><p>人同此心,心同此理</p><p>学习的内容: 五经与六艺</p><p>学习的方法: 学思并用</p><p>学习的目的: 培养德行</p><p>不迁怒 不贰过</p><p>朋友由来<br>同门曰朋<br>同志曰友</p><p>儒家:不反对情绪,但需要做情绪管理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;学习地址&quot;&gt;&lt;a href=&quot;#学习地址&quot; class=&quot;headerlink&quot; title=&quot;学习地址&quot;&gt;&lt;/a&gt;学习地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://mooc1.chaoxing.com/ztnodedetailcontroller/vis
      
    
    </summary>
    
    
      <category term="传统文化" scheme="http://iwantjingjing.com/categories/%E4%BC%A0%E7%BB%9F%E6%96%87%E5%8C%96/"/>
    
    
      <category term="传统文化" scheme="http://iwantjingjing.com/tags/%E4%BC%A0%E7%BB%9F%E6%96%87%E5%8C%96/"/>
    
      <category term="论语" scheme="http://iwantjingjing.com/tags/%E8%AE%BA%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>持续集成服务 Travis CI</title>
    <link href="http://iwantjingjing.com/2019/09/27/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%9C%8D%E5%8A%A1-Travis-CI/"/>
    <id>http://iwantjingjing.com/2019/09/27/持续集成服务-Travis-CI/</id>
    <published>2019-09-27T07:27:00.000Z</published>
    <updated>2019-09-28T12:31:51.431Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.travis-ci.org/dashboard" target="_blank" rel="noopener">官网</a><br><a href="https://liusir.me/2019/09/21/hexo-基于TravisCI实现hexo博客持续继承" target="_blank" rel="noopener">参考</a><br><a href="http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.travis-ci.org/dashboard&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://liusir.me/2019/09/21/hexo-基于Travi
      
    
    </summary>
    
    
      <category term="TravisCI" scheme="http://iwantjingjing.com/categories/TravisCI/"/>
    
    
      <category term="TravisCI" scheme="http://iwantjingjing.com/tags/TravisCI/"/>
    
  </entry>
  
  <entry>
    <title>springmvc在controller方法里面跳转外网的方法  </title>
    <link href="http://iwantjingjing.com/2019/09/27/springmvc%E5%9C%A8controller%E6%96%B9%E6%B3%95%E9%87%8C%E9%9D%A2%E8%B7%B3%E8%BD%AC%E5%A4%96%E7%BD%91%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://iwantjingjing.com/2019/09/27/springmvc在controller方法里面跳转外网的方法/</id>
    <published>2019-09-27T07:17:15.000Z</published>
    <updated>2019-09-28T12:31:51.428Z</updated>
    
    <content type="html"><![CDATA[<p>1.return new ModelAndView(new RedirectView(“<a href="https://www.baidu.com&quot;" target="_blank" rel="noopener">https://www.baidu.com&quot;</a>));</p><p>2.return  “redirect:<a href="https://www.baidu.com/&quot;" target="_blank" rel="noopener">https://www.baidu.com/&quot;</a>;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.return new ModelAndView(new RedirectView(“&lt;a href=&quot;https://www.baidu.com&amp;quot;&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.baidu.com&amp;qu
      
    
    </summary>
    
    
      <category term="spring" scheme="http://iwantjingjing.com/categories/spring/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="spring" scheme="http://iwantjingjing.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>如何培养孩子的逻辑思维</title>
    <link href="http://iwantjingjing.com/2019/09/27/%E5%A6%82%E4%BD%95%E5%9F%B9%E5%85%BB%E5%AD%A9%E5%AD%90%E7%9A%84%E9%80%BB%E8%BE%91%E6%80%9D%E7%BB%B4/"/>
    <id>http://iwantjingjing.com/2019/09/27/如何培养孩子的逻辑思维/</id>
    <published>2019-09-27T03:03:57.000Z</published>
    <updated>2019-09-28T12:31:51.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逻辑思维能力重要吗？"><a href="#逻辑思维能力重要吗？" class="headerlink" title="逻辑思维能力重要吗？"></a>逻辑思维能力重要吗？</h1><p>答案必然是肯定的，因为它不仅是学好数学必须具备的能力，同时也是学好其他学科，处理日常生活问题所必须具备的能力。</p><p>换句话说就是：逻辑思维，其可以成为“做好任何事情”的必要条件.</p><h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p>它是一种人类思维的高级形式，即我们所说的“抽象思维”。而一个人想具备很强的逻辑思维能力，往往需要从小开始培养。</p><h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>肥宅以为:逻辑思维就是智商最重要的方面之一,甚至之一也可以去掉.</p><h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>美国的很多学校，他们从学前班开始就有关于训练孩子逻辑思维能力的数学内容</p><p>但在国内，我们对孩子逻辑思维的培养还存在一定的误区，学校往往喜欢让学生做题，找到考试的捷径，却忽视了对数学本质的讲解。</p><p>所以当我们没有将数学应用在生活中，这些定理和公式也会随着时间的流逝慢慢被淡忘。</p><p>所以将数学应用在生活中也就是锻炼逻辑思维的必要过程</p><h2 id="那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。"><a href="#那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。" class="headerlink" title="那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。"></a>那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。</h2><h3 id="动作思维阶段（0-3岁）"><a href="#动作思维阶段（0-3岁）" class="headerlink" title="动作思维阶段（0-3岁）"></a>动作思维阶段（0-3岁）</h3><p>不到3岁的孩子以动作思维为主，思维在动作中进行。比如桌上放着一个苹果，宝宝矮小够不着，怎么办呢?这时候宝宝发现他旁边有凳子，于是把凳子搬过来，自己爬上去，成功地把苹果拿到手。<br>孩子学会借助别的东西来达到自己的目的，是从不断的操作过程中理解的。 孩子最初的动作往往是杂乱无章、漫无目的的，以后在不断的操作过程中了解了动作与结果之间的关系。</p><h3 id="具体形象思维阶段（3-6岁）"><a href="#具体形象思维阶段（3-6岁）" class="headerlink" title="具体形象思维阶段（3-6岁）"></a>具体形象思维阶段（3-6岁）</h3><p>3-6岁的孩子具体形象思维占优势，他们缺少立体感和空间感。这也是为什么用数字加减，孩子反应不过来，但是用实物举例子，就容易理解。<br>在这个阶段，家长要注意增加孩子的经验，丰富孩子的词汇，多给孩子动手的机会。有些家长和老师片面地、刻板地教孩子多识字、写字、计算等，对孩子的思维发展并没有好处。</p><h3 id="抽象逻辑思维能力（6-11岁）"><a href="#抽象逻辑思维能力（6-11岁）" class="headerlink" title="抽象逻辑思维能力（6-11岁）"></a>抽象逻辑思维能力（6-11岁）</h3><p>6-11岁是培养孩子抽象逻辑思维能力的关键时期。在这一时期要培养孩子正确的思维程序和科学的思维方法。</p><p>比如，一只狗有4条腿，两只狗有8条腿，三只狗有多少条腿?像这些问题，就是属于抽象逻辑思维能力题。家长要注意让孩子学会独立思考，不要给孩子现成的答案。    </p><h2 id="那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。"><a href="#那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。" class="headerlink" title="那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。"></a>那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。</h2><h3 id="一、丰富孩子的词汇，教孩子说话用词达意"><a href="#一、丰富孩子的词汇，教孩子说话用词达意" class="headerlink" title="一、丰富孩子的词汇，教孩子说话用词达意"></a>一、丰富孩子的词汇，教孩子说话用词达意</h3><p>语言是思维的外壳，尽早教孩子准确用词，不但能防止别人曲解、误解他的意思，而且促使他思维活跃、思路清晰。家长对孩子的话要多问几个为什么，对他的表达要多作分析，这可以使孩子用词准确、鲜明、生动。    </p><h3 id="二、有意识地对孩子设疑，给孩子留下思考的时间"><a href="#二、有意识地对孩子设疑，给孩子留下思考的时间" class="headerlink" title="二、有意识地对孩子设疑，给孩子留下思考的时间"></a>二、有意识地对孩子设疑，给孩子留下思考的时间</h3><p>孩子回答问题往往是凭直觉，如果家长满足于孩子的这点“小聪明”，那么，他们会习惯对问题不假思索地做出回答，没有足够的时间让大脑启动思维“程序”。</p><p>所以，当孩子遇到问题的时候，家长最好不要急于让他说答案，而是让他多问几个为什么，多想几种解决的方案，多几次对自己的否定，然后在否定中寻找最佳答案。</p><h3 id="三、利用游戏促进孩子思维能力的发展"><a href="#三、利用游戏促进孩子思维能力的发展" class="headerlink" title="三、利用游戏促进孩子思维能力的发展"></a>三、利用游戏促进孩子思维能力的发展</h3><p>在日常生活中，可以进行分类和归类的游戏。也可以进行比较动、植物或其他事物、训练理解力和创造力的游戏等。</p><p>比如收衣服时，让孩子将不同的袜子分类卷起来；去动物园时，告诉孩子如何通过牙齿区别食草和食肉的动物，并让他分辨；给孩子一些零钱，让孩子去买东西……</p><p>对孩子而言，说过的话，玩过的游戏或许会忘记，但日复一日默默培养起来的逻辑思维能力会伴随他们终身，使他们在生活和工作中表现得更为优秀出色。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;逻辑思维能力重要吗？&quot;&gt;&lt;a href=&quot;#逻辑思维能力重要吗？&quot; class=&quot;headerlink&quot; title=&quot;逻辑思维能力重要吗？&quot;&gt;&lt;/a&gt;逻辑思维能力重要吗？&lt;/h1&gt;&lt;p&gt;答案必然是肯定的，因为它不仅是学好数学必须具备的能力，同时也是学好其他学科，
      
    
    </summary>
    
    
      <category term="育儿" scheme="http://iwantjingjing.com/categories/%E8%82%B2%E5%84%BF/"/>
    
    
      <category term="育儿" scheme="http://iwantjingjing.com/tags/%E8%82%B2%E5%84%BF/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 核心注解</title>
    <link href="http://iwantjingjing.com/2019/09/25/Spring-Boot-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3/"/>
    <id>http://iwantjingjing.com/2019/09/25/Spring-Boot-核心注解/</id>
    <published>2019-09-25T06:00:45.000Z</published>
    <updated>2019-09-28T12:31:51.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p>我看你上面写了熟悉 Spring Boot，那你能讲下为什么我们要用 Spring Boot 吗？</p><h1 id="下面我列几个最常见的三个回答："><a href="#下面我列几个最常见的三个回答：" class="headerlink" title="下面我列几个最常见的三个回答："></a>下面我列几个最常见的三个回答：</h1><h2 id="A：Spring-Boot-最主要是不用-XML-配置，可以用-Java-来配置-bean，省去了许多配置文件。"><a href="#A：Spring-Boot-最主要是不用-XML-配置，可以用-Java-来配置-bean，省去了许多配置文件。" class="headerlink" title="A：Spring Boot 最主要是不用 XML 配置，可以用 Java 来配置 bean，省去了许多配置文件。"></a>A：Spring Boot 最主要是不用 XML 配置，可以用 Java 来配置 bean，省去了许多配置文件。</h2><p>我又问：Spring 本身就可以用 Java 配置代替 XML 配置，和 Spring Boot 有什么关系呢？</p><p>然后对方就吱吱唔唔了……</p><h2 id="B：Spring-Boot-我们用来做-Spring-Cloud-微服务。"><a href="#B：Spring-Boot-我们用来做-Spring-Cloud-微服务。" class="headerlink" title="B：Spring Boot 我们用来做 Spring Cloud 微服务。"></a>B：Spring Boot 我们用来做 Spring Cloud 微服务。</h2><p>我又问：微服务和 Spring Boot 有什么关系？不用 Spring Boot 行不行？</p><p>然后对方就吱吱唔唔了……</p><h2 id="C：Spring-Boot-可以打-jar-包部署，内部集成了Tomcat。"><a href="#C：Spring-Boot-可以打-jar-包部署，内部集成了Tomcat。" class="headerlink" title="C：Spring Boot 可以打 jar 包部署，内部集成了Tomcat。"></a>C：Spring Boot 可以打 jar 包部署，内部集成了Tomcat。</h2><p>这个确实是 Spring Boot 的特色，但是我还是觉得没有答到关键点上。</p><p>然后我继续问，如果不考虑打 jar 包部署呢，然后就没然后了……</p><h1 id="为什么我们要用-Spring-Boot，显然上面三个求职者没有答到关键点上，Spring-Boot-最重要的功能是：自动配置。"><a href="#为什么我们要用-Spring-Boot，显然上面三个求职者没有答到关键点上，Spring-Boot-最重要的功能是：自动配置。" class="headerlink" title="为什么我们要用 Spring Boot，显然上面三个求职者没有答到关键点上，Spring Boot 最重要的功能是：自动配置。"></a>为什么我们要用 Spring Boot，显然上面三个求职者没有答到关键点上，Spring Boot 最重要的功能是：自动配置。</h1><h2 id="为什么说是自动配置？"><a href="#为什么说是自动配置？" class="headerlink" title="为什么说是自动配置？"></a>为什么说是自动配置？</h2><p>Spring Boot 的开启注解是：@SpringBootApplication，其实它就是由下面三个注解组成的：</p><pre><code>@Configuration@ComponentScan@EnableAutoConfiguration</code></pre><p>上面三个注解，前面两个都是 Spring 自带的，和 Spring Boot 无关，所以说上面的回答的不是在点上。</p><p>所以说 Spring Boot 最最核心的就是这个 <strong>@EnableAutoConfiguration</strong> 注解了，它能根据类路径下的 jar 包和配置动态加载配置和注入bean。</p><p>举个例子，比如我在 lib 下放一个 druid 连接池的 jar 包，然后在 application.yml 文件配置 druid 相关的参数，Spring Boot 就能够自动配置所有我们需要的东西，如果我把 jar 包拿掉或者把参数去掉，那 Spring Boot 就不会自动配置。</p><p>这样我们就能把许多功能做成公共的自动配置的启动器（starters），其实 druid 连接池就是这么做的，它提供了针对 Spring Boot 的启动器：druid-spring-boot-starter。</p><p>有了这个自动配置的启动器，我们就能非常简单的使用它，</p><p>先添加 jar 包依赖：</p><pre><code>&lt;dependency&gt;   &lt;groupId&gt;com.alibaba&lt;/groupId&gt;   &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;   &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;    </code></pre><p>再添加相关参数：</p><pre><code>spring.datasource.url= spring.datasource.username=spring.datasource.password=……</code></pre><p>如果是传统的项目，我们要自己手动写一大堆的配置，而且还不灵活，有了这个启动器，我们就可以做到简单集成。具体大家可以看 druid-spring-boot-starter 是怎么实现的。</p><p>所以，这才是 Spring Boot 的核心，这才是我们为什么使用 Spring Boot 的原因。如果答不到这个关键点，那真没有掌握到 Spring Boot 的核心所在。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h1&gt;&lt;p&gt;我看你上面写了熟悉 Spring Boot，那你能讲下为什么我们要用 Spring Boot 吗？&lt;/p&gt;
&lt;h1 id=&quot;下面我列
      
    
    </summary>
    
    
      <category term="Java" scheme="http://iwantjingjing.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="Spring" scheme="http://iwantjingjing.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Javac原理</title>
    <link href="http://iwantjingjing.com/2019/09/25/Javac%E5%8E%9F%E7%90%86/"/>
    <id>http://iwantjingjing.com/2019/09/25/Javac原理/</id>
    <published>2019-09-25T02:57:37.000Z</published>
    <updated>2019-09-28T12:31:51.419Z</updated>
    
    <content type="html"><![CDATA[<p>从Sun Javac的代码来看，编译过程大致可以分为3个过程:</p><ol><li>解析与填充符号表过程。</li><li>插入式注解处理器的注解处理过程。</li><li>分析与字节码生成过程。<br><img src="j.jpg" alt><br>Javac编译动作的入口是com.sun.tools.javac.main.JavaCompiler类，上述3个过程的代码逻辑集中在这个类的compile()和compile2()方法中，整个编译最关键的处理就由图中标注的8个方法来完成，下面我们具体看一下这8个方法实现了什么功能。<br><img src="f.jpg" alt></li></ol><h1 id="解析与填充符号表"><a href="#解析与填充符号表" class="headerlink" title="解析与填充符号表"></a>解析与填充符号表</h1><p>解析步骤由上图中的parseFiles（）方法（过程1.1）完成，解析步骤包括了经典程序编译原理中的词法分析和语法分析两个过程。</p><h2 id="词法、语法分析"><a href="#词法、语法分析" class="headerlink" title="词法、语法分析"></a>词法、语法分析</h2><p>词法分析是<strong>将源代码的字符流转变为标记（Token）集合</strong>，<strong>单个字符</strong>是<strong>程序编写过程</strong>的最小元素，而<strong>标记</strong>则是<strong>编译过程</strong>的最小元素，关键字、变量名、字面量、运算符都可以成为标记，如“int a=b+2”这句代码包含了6个标记，分别是int、a、=、b、+、2，虽然关键字int由3个字符构成，但是它只是一个Token，不可再拆分。在Javac的源码中，词法分析过程由com.sun.tools.javac.parser.Scanner类来实现。</p><p>语法分析是<strong>根据Token序列构造抽象语法树的过程</strong>，抽象语法树（Abstract Syntax Tree,AST）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构（Construct），例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。</p><p>在Javac的源码中，语法分析过程由com.sun.tools.javac.parser.Parser类实现，这个阶段产出的抽象语法树由com.sun.tools.javac.tree.JCTree类表示，<strong>经过这个步骤之后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在抽象语法树之上</strong>。</p><h2 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h2><p>完成了语法分析和词法分析之后，下一步就是填充符号表的过程，也就是enterTrees（）方法（过程1.2）所做的事情。符号表（Symbol Table）<strong>是由一组符号地址和符号信息构成的表格</strong>，可以把它想象成哈希表中K-V值对的形式（实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等）。符号表中所登记的信息在编译的不同阶段都要用到<br>。<strong>在语义分析中，符号表所登记的内容将用于语义检查</strong>（如检查一个名字的使用和原先的说明是否一致）和<strong>产生中间代码</strong>。在目标代码生成阶段，当对符号名进行地址分配时，<strong>符号表是地址分配的依据。</strong></p><p>在Javac源代码中，填充符号表的过程由com.sun.tools.javac.comp.Enter类实现，此过程的出口是一个待处理列表（To Do List），包含了每一个编译单元的抽象语法树的顶级节点，以及package-info.java（如果存在的话）的顶级节点。</p><h1 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h1><p>在Javac源码中，<em>插入</em>式注解处理器的<em>初始化</em>过程是在<br>initPorcessAnnotations（）方法中完成的，而它的<em>执行过程</em>则是在processAnnotations（）方法中完成的，<br>这个方法判断是否还有新的注解处理器需要执行，如果有的话，通过com.sun.tools.javac.processing.JavacProcessingEnvironment类的doProcessing（）方法生成一个新的JavaCompiler对象对编译的后续步骤进行处理。</p><p>在JDK 1.5之后，Java语言提供了对注解（Annotation）的支持，这些注解与普通的Java代码一样，是在运行期间发挥作用的。在JDK 1.6中实现了JSR-269规范JSR-269：Pluggable Annotations Processing API（插入式注解处理API）。提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，我们可以把它看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round，也就是第一张图中的回环过程。 有了编译器注解处理的标准API后，我们的代码才有可能干涉编译器的行为，由于语法树中的任意元素，甚至包括代码注释都可以在插件之中访问到，所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间。只要有足够的创意，程序员可以使用插入式注解处理器来实现许多原本只能在编码中完成的事情。</p><p>我们知道编译器在把Java程序源码编译为字节码的时候，会对Java程序源码做各方面的检查校验。这些校验主要以程序“写得对不对”为出发点，虽然也有各种WARNING的信息，但总体来讲还是较少去校验程序“写得好不好”。有鉴于此，业界出现了许多针对程序“写得好不好”的辅助校验工具，如CheckStyle、FindBug、Klocwork等。这些代码校验工具有一些是基于Java的源码进行校验，还有一些是通过扫描字节码来完成。我们将会使用注解处理器API来编写一款拥有自己编码风格的校验工具：NameCheckProcessor。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>要通过注解处理器API实现一个编译器插件，首先需要了解这组API的一些基本知识。我们实现注解处理器的代码需要继承抽象类javax.annotation.processing.AbstractProcessor，这个抽象类中只有一个必须覆盖的abstract方法：“process（）”，它是Javac编译器在执行注解处理器代码时要调用的过程，我们可以从这个方法的第一个参数“annotations”中获取到此注解处理器所要处理的注解集合，从第二个参数“roundEnv”中访问到当前这个Round中的语法树节点，每个语法树节点在这里表示为一个Element。在JDK 1.6新增的javax.lang.model包中定义了16类Element，包括了Java代码中最常用的元素，如：“包（PACKAGE）、枚举（ENUM）、类（CLASS）、注解（ANNOTATION_TYPE）、接口（INTERFACE）、枚举值（ENUM_CONSTANT）、字段（FIELD）、参数（PARAMETER）、本地变量（LOCAL_VARIABLE）、异常（EXCEPTION_PARAMETER）、方法（METHOD）、构造函数（CONSTRUCTOR）、静态语句块（STATIC_INIT，即static{}块）、实例语句块（INSTANCE_INIT，即{}块）、参数化类型（TYPE_PARAMETER，既泛型尖括号内的类型）和未定义的其他语法树节点（OTHER）”。除了process（）方法的传入参数之外，还有一个很常用的实例变量“processingEnv”，它是AbstractProcessor中的一个protected变量，在注解处理器初始化的时候（init（）方法执行的时候）创建，继承了AbstractProcessor的注解处理器代码可以直接访问到它。它代表了注解处理器框架提供的一个上下文环境，要创建新的代码、向编译器输出信息、获取其他工具类等都需要用到这个实例变量。注解处理器除了process（）方法及其参数之外，还有两个可以配合使用的Annotations：@SupportedAnnotationTypes和@SupportedSourceVersion，前者代表了这个注解处理器对哪些注解感兴趣，可以使用星号“*”作为通配符代表对所有的注解都感兴趣，后者指出这个注解处理器可以处理哪些版本的Java代码。</p><p>每一个注解处理器在运行的时候都是单例的，如果不需要改变或生成语法树的内容，process（）方法就可以返回一个值为false的布尔值，通知编译器这个Round中的代码未发生变化，无须构造新的JavaCompiler实例，在这次实战的注解处理器中只对程序命名进行检查，不需要改变语法树的内容，因此process（）方法的返回值都是false。</p><pre><code>import javax.annotation.processing.*;import javax.lang.model.SourceVersion;import javax.lang.model.element.Element;import javax.lang.model.element.TypeElement;import java.util.Set;//可以用&quot;*&quot;表示支持所有Annotations@SupportedAnnotationTypes(&quot;*&quot;)//只支持JDK 1.6的Java代码@SupportedSourceVersion(SourceVersion.RELEASE_6)public class NameCheckProcessor extends AbstractProcessor {    private NameChecker nameChecker;    /**     * 初始化名称检查插件     */    @Override    public void init(ProcessingEnvironment processingEnv){        super.init(processingEnv);        nameChecker = new NameChecker(processingEnv);    }    /**     * 对输入的语法树的各个节点进行名称检查     */    @Override    public boolean process(Set&lt;? extends TypeElement&gt; annotations,RoundEnvironment roundEnv){        if (!roundEnv.processingOver()) {            for (Element element:roundEnv.getRootElements())            nameChecker.checkNames(element);        }        return false;    }}import javax.annotation.processing.Messager;import javax.annotation.processing.ProcessingEnvironment;import javax.lang.model.element.*;import javax.lang.model.util.ElementScanner6;import javax.tools.Diagnostic;import java.util.EnumSet;public class NameChecker {    private final Messager messager;    NameCheckScanner nameCheckScanner = new NameCheckScanner();    NameChecker(ProcessingEnvironment processsingEnv) {        this.messager = processsingEnv.getMessager();    }    /**     * 对Java程序命名进行检查,根据《Java语言规范(第3版)》第6.8节的要求,Java程序命名应当符合下列格式：     * &lt;p/&gt;     * &lt;ul&gt;     * &lt;li&gt;类或接口：符合驼式命名法,首字母大写。     * &lt;li&gt;方法：符合驼式命名法,首字母小写。     * &lt;li&gt;字段：     * &lt;ul&gt;     * &lt;li&gt;类、实例变量：符合驼式命名法,首字母小写。     * &lt;li&gt;常量：要求全部大写。     * &lt;/ul&gt;     * &lt;/ul&gt;     */    public void checkNames(Element element) {        nameCheckScanner.scan(element);    }    /**     * 名称检查器实现类,继承了JDK 1.6中新提供的ElementScanner6&lt;br&gt;     * 将会以Visitor模式访问抽象语法树中的元素     */    private class NameCheckScanner extends ElementScanner6&lt;Void, Void&gt; {        /**         * 此方法用于检查Java类         */        @Override        public Void visitType(TypeElement e, Void p) {            scan(e.getTypeParameters(), p);            checkCamelCase(e, true);            super.visitType(e, p);            return null;        }        /**         * 检查方法命名是否合法         */        @Override        public Void visitExecutable(ExecutableElement e, Void p) {            if (e.getKind() == ElementKind.METHOD) {                Name name = e.getSimpleName();                if                        (name.contentEquals(e.getEnclosingElement().getSimpleName()))                    messager.printMessage(Diagnostic.Kind.WARNING, &quot;一个普通方法&apos;&quot; + name + &quot;&apos;不应当与类名重复,避免与构造函数产生混淆&quot;, e);                checkCamelCase(e, false);            }            super.visitExecutable(e, p);            return null;        }        /**         * 检查变量命名是否合法         */        @Override        public Void visitVariable(VariableElement e, Void p) {            //如果这个Variable是枚举或常量,则按大写命名检查,否则按照驼式命名法规则检查            if (e.getKind() == ElementKind.ENUM_CONSTANT || e.getConstantValue() != null || heuristicallyConstant(e))                checkAllCaps(e);            else                checkCamelCase(e, false);            return null;        }        /**         * 判断一个变量是否是常量         */        private boolean heuristicallyConstant(VariableElement e) {            if (e.getEnclosingElement().getKind() == ElementKind.INTERFACE)                return true;            else if (e.getKind() == ElementKind.FIELD &amp;&amp; e.getModifiers().containsAll(EnumSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)))                return true;            else {                return false;            }        }        /**         * 检查传入的Element是否符合驼式命名法,如果不符合,则输出警告信息         */        private void checkCamelCase(Element e, boolean initialCaps) {            String name = e.getSimpleName().toString();            boolean previousUpper = false;            boolean conventional = true;            int firstCodePoint = name.codePointAt(0);            if (Character.isUpperCase(firstCodePoint)) {                previousUpper = true;                if (!initialCaps) {                    messager.printMessage(Diagnostic.Kind.WARNING, &quot;名称&apos;&quot; + name + &quot;&apos;应当以小写字母开头&quot;, e);                    return;                }            } else if (Character.isLowerCase(firstCodePoint)) {                if (initialCaps) {                    messager.printMessage(Diagnostic.Kind.WARNING, &quot;名称&apos;&quot; + name + &quot;&apos;应当以大写字母开头&quot;, e);                    return;                }            } else                conventional = false;            if (conventional) {                int cp = firstCodePoint;                for (int i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) {                    cp = name.codePointAt(i);                    if (Character.isUpperCase(cp)) {                        if (previousUpper) {                            conventional = false;                            break;                        }                        previousUpper = true;                    } else                        previousUpper = false;                }            }            if (!conventional)                messager.printMessage(Diagnostic.Kind.WARNING, &quot;名称&apos;&quot; + name + &quot;&apos;应当符合驼式命名法(Camel Case Names)&quot;, e);        }        /**         * 大写命名检查,要求第一个字母必须是大写的英文字母,其余部分可以是下划线或大写字母         */        private void checkAllCaps(Element e) {            String name = e.getSimpleName().toString();            boolean conventional = true;            int firstCodePoint = name.codePointAt(0);            if (!Character.isUpperCase(firstCodePoint))                conventional = false;            else {                boolean previousUnderscore = false;                int cp = firstCodePoint;                for (int i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) {                    cp = name.codePointAt(i);                    if (cp == (int) &apos;_&apos;) {                        if (previousUnderscore) {                            conventional = false;                            break;                        }                        previousUnderscore = true;                    } else {                        previousUnderscore = false;                        if (!Character.isUpperCase(cp) &amp;&amp; !Character.isDigit(cp)) {                            conventional = false;                            break;                        }                    }                }            }            if (!conventional)                messager.printMessage(Diagnostic.Kind.WARNING, &quot;常量&apos;&quot; + name + &quot;&apos;应当全部以大写字母或下划线命名,并且以字母开头&quot;, e);        }    }}</code></pre><p>我们可以通过Javac命令的“-processor”参数来执行编译时需要附带的注解处理器，如果有多个注解处理器的话，用逗号分隔。还可以使用-XprintRounds和-XprintProcessorInfo参数来查看注解处理器运作的详细信息，javac -processor <strong>*.NameCheckProcessor *</strong>/test.java</p><pre><code>test.java：3：警告：名称&quot;test&quot;应当符合驼式命名法（Camel Case Names）public class test{^test.java：5：警告：名称&quot;colors&quot;应当以大写字母开头enum colors{^test.java：6：警告：常量&quot;red&quot;应当全部以大写字母或下划线命名，并且以字母开头red,blue,green；^test.java：6：警告：常量&quot;blue&quot;应当全部以大写字母或下划线命名，并且以字母开头red,blue,green；^test.java：6：警告：常量&quot;green&quot;应当全部以大写字母或下划线命名，并且以字母开头red,blue,green；^test.java：9：警告：常量&quot;_FORTY_TWO&quot;应当全部以大写字母或下划线命名，并且以字母开头static final int_FORTY_TWO=42；^test.java：11：警告：名称&quot;NOT_A_CONSTANT&quot;应当以小写字母开头public static int NOT_A_CONSTANT=_FORTY_TWO；^test.java：13：警告：名称&quot;Test&quot;应当以小写字母开头protected void Test（）{^test.java：17：警告：名称&quot;NOTcamelCASEmethodNAME&quot;应当以小写字母开头public void NOTcamelCASEmethodNAME（）{^</code></pre><p>NameCheckProcessor的例子只演示了JSR-269嵌入式注解处理器API中的一部分功能，基于这组API支持的项目还有用于校验Hibernate标签使用正确性的Hibernate Validator Annotation Processorm自动为字段生成getter和setter方法的Project Lombok.</p><h1 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h1><p>语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。Javac的编译过程中，语义分析过程分为标注检查以及数据及控制流分析两个步骤，分别由上图中所示的attribute（）和flow（）方法（分别对应过程3.1和过程3.2）完成。</p><h2 id="标注检查"><a href="#标注检查" class="headerlink" title="标注检查"></a>标注检查</h2><p>标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。在标注检查步骤中，还有一个重要的动作称为常量折叠，如果我们在代码中写了如下定义：int a=1+2；那么在语法树上仍然能看到字面量“1”、“2”以及操作符“+”，但是在经过常量折叠之后，它们将会被折叠为字面量“3”，由于编译期间进行了常量折叠，所以在代码里面定义“a=1+2”比起直接定义“a=3”，并不会增加程序运行期哪怕仅仅一个CPU指令的运算量。</p><h2 id="数据及控制流分析"><a href="#数据及控制流分析" class="headerlink" title="数据及控制流分析"></a>数据及控制流分析</h2><p>在Javac的源码中，数据及控制流分析的入口是图中的flow（）方法（对应过程3.2），具体操作由com.sun.tools.javac.comp.Flow类来完成。</p><p>数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只有在编译期或运行期才能进行。</p><pre><code>//方法一带有final修饰public void foo（final int arg）{final int var=0；//do something}//方法二没有final修饰public void foo（int arg）{int var=0；//do something}</code></pre><p>在这两个foo（）方法中，第一种方法的参数和局部变量定义使用了final修饰符，而第二种方法则没有，在代码编写时程序肯定会受到final修饰符的影响，不能再改变arg和var变量的值，但是这两段代码编译出来的Class文件是没有任何一点区别的，局部变量与字段（实例变量、类变量）是有区别的，它在常量池中没有CONSTANT_Fieldref_info的符号引用，自然就没有访问标志（Access_Flags）的信息，甚至可能连名称都不会保留下来（取决于编译时的选项），自然在Class文件中不可能知道一个局部变量是不是声明为final了。因此，将局部变量声明为final，对运行期是没有影响的，变量的不变性仅仅由编译器在编译期间保障。</p><h2 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h2><p>在Javac的源码中，解语法糖的过程由desugar（）方法触发，在com.sun.tools.javac.comp.TransTypes类和com.sun.tools.javac.comp.Lower类中完成。</p><p>语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说，使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p><p>Java中最常用的语法糖主要是的泛型擦除（泛型并不一定都是语法糖实现，如C#的泛型就是直接由CLR支持的）、变长参数、自动装箱/拆箱,条件编译等，虚拟机运行时不支持这些语法，它们在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖。</p><h1 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h1><p>字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面由com.sun.tools.javac.jvm.Gen类来完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。</p><p>例如，实例构造器＜init＞（）方法和类构造器＜clinit＞（）方法就是在这个阶段添加到语法树之中的（注意，这里的实例构造器并不是指默认构造函数，如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、访问性（public、protected或private）与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成），这两个构造器的产生过程实际上是一个代码收敛的过程，编译器会把语句块（对于实例构造器而言是“{}”块，对于类构造器而言是“static{}”块）、变量初始化（实例变量和类变量）、调用父类的实例构造器等操作收敛到＜init＞（）和＜clinit＞（）方法之中，并且保证一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行，上面所述的动作由Gen.normalizeDefs（）方法来实现。除了生成构造器以外，还有其他的一些代码替换工作用于优化程序的实现逻辑，如把字符串的加操作替换为StringBuffer或StringBuilder的append（）操作等。</p><p>完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交给com.sun.tools.javac.jvm.ClassWriter类，由这个类的writeClass（）方法输出字节码，生成最终的Class文件，到此为止整个编译过程宣告结束。</p><p><a href="https://www.cnblogs.com/wade-luffy/p/6050331.html" target="_blank" rel="noopener">摘自</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从Sun Javac的代码来看，编译过程大致可以分为3个过程:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解析与填充符号表过程。&lt;/li&gt;
&lt;li&gt;插入式注解处理器的注解处理过程。&lt;/li&gt;
&lt;li&gt;分析与字节码生成过程。&lt;br&gt;&lt;img src=&quot;j.jpg&quot; alt&gt;&lt;br&gt;Javac
      
    
    </summary>
    
    
      <category term="Java" scheme="http://iwantjingjing.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>使用 lombok 简化 Java 代码  </title>
    <link href="http://iwantjingjing.com/2019/09/25/%E4%BD%BF%E7%94%A8-lombok-%E7%AE%80%E5%8C%96-Java-%E4%BB%A3%E7%A0%81/"/>
    <id>http://iwantjingjing.com/2019/09/25/使用-lombok-简化-Java-代码/</id>
    <published>2019-09-25T02:27:07.000Z</published>
    <updated>2019-09-28T12:31:51.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一个典型的-Java-类"><a href="#一个典型的-Java-类" class="headerlink" title="一个典型的 Java 类"></a>一个典型的 Java 类</h1><pre><code>public class A {  private int a;  private String b;  public int getA() {    return a;  }  public String getB() {    return b;  }  public void setA(int a) {    this.a = a;  }  public void setB(String b) {    this.b = b;  }}</code></pre><p>对于这样一个简单的 Java 类，我们通常需要给每个属性写getter和setter，而这种实际上没有什么太大的意义。当然，如果有的公司或团队使用代码行数评估工作量，还是多写几行吧；同时，可以考虑一下我们团队。</p><h1 id="使用-lombok，简化代码"><a href="#使用-lombok，简化代码" class="headerlink" title="使用 lombok，简化代码"></a>使用 lombok，简化代码</h1><p>为了简化getter与setter，lombok 提供了一种机制，帮助我们自动生成这些样板代码。以上的代码，如果使用lombok的话，将变得很简单：</p><pre><code>@lombok.Getter@lombok.Setterpublic class A {    private int a;    private String b;}</code></pre><p>顾名思义，lombok.Getter就是生成getter，lombok.Setter就是生成setter。但是，这样真的就可以了么？编译下，让我们看看生成的二进制代码。(请自行下载lombok.jar)</p><pre><code>命令行&gt; javac -cp lombok.jar A.java命令行&gt; javap -c A.class</code></pre><p>输出结果略。可以看到完全一样。</p><p>更进一步，如果在编译的时候，加入-g:none选项，甚至可以看到生成的文件完全一样。</p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>虽然我们可以在编译的时候，加入classpath，但是，一般来说，在各类IDE中使用，还是需要特殊处理一下。</p><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>加上依赖就好。同时，由于lombok只在编译期才处理，所以并不需要在运行时有这个依赖，可以把scope定义为provided。</p><pre><code>&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;version&gt;1.16.8&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>值得注意的是，maven的maven-compiler-plugin低版本和lombok高版本不兼容，目前已知maven-compiler-plugin的2.3.X与lombok的1.6.X不兼容。这个需要了解lombok的原理才能进一步说明。</p><h2 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h2><p>由于eclipse的默认编译器并不是javac，所以，需要额外安装，基本就是改下引导参数，可以直接运行jar包，或者手动在eclipse.ini里加上参数-Xbootclasspath/a:lombok.jar -javaagent:lombok.jar。</p><h2 id="IDEA-IntelliJ"><a href="#IDEA-IntelliJ" class="headerlink" title="IDEA IntelliJ"></a>IDEA IntelliJ</h2><p>虽然IDEA IntelliJ默认使用javac作为编译器，理论上可以不装插件。可是，跳转等特性也随之没了。所以，还是安装个插件吧，直接去仓库里搜索lombok就成。</p><p>如果项目中使用高级配置，需要额外注意一下。虽然在编译的时候，lombok配置文件可以在任何能找到的目录，但是，lombok-intellij插件默认并不支持在任何目录，如果有配置文件，建议放在java的源代码根目录中。    </p><h1 id="更多-lombok-注解"><a href="#更多-lombok-注解" class="headerlink" title="更多 lombok 注解"></a>更多 lombok 注解</h1><table><thead><tr><th align="left">注解</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">@val</td><td align="left">如果你要定义一个final的变量，并且不想写类型，这个可以帮到你。但是，在实际项目中，完全没有使用到。</td></tr><tr><td align="left">@NonNull</td><td align="left">这个在参数中使用，如果调用时传了null，就直接抛空指针。</td></tr><tr><td align="left">@Data</td><td align="left">@ToString、@EqualsAndHashCode、@Getter、@Setter和@RequiredArgsConstructor注解的集合。</td></tr><tr><td align="left">@Getter与@Setter</td><td align="left">作用于属性和类上，自动生成属性的getXXX()和setXXX()方法。若在类上，则对所有属性有效。并可通过AccessLevel参数控制方法的访问级别。</td></tr><tr><td align="left">@ToString</td><td align="left">作用于类，自动重写类的ToString()方法。常用的参数有exclude（指定方法中不包含的属性）、callSuper（方法中是否包含父类ToString()方法返回的值）</td></tr><tr><td align="left">@EqualsAndHashCode</td><td align="left">作用于类，自动重写类的equals()、hashCode()方法。常用的参数有exclude（指定方法中不包含的属性）、callSuper（方法中是否包含父类ToString()方法返回的值）</td></tr><tr><td align="left">@NoArgsConstructor, @RequiredArgsConstructor和@AllArgsConstructor</td><td align="left">作用于类，@NoArgsConstructor自动生成不带参数的构造方法；@RequiredArgsConstructor自动生成带参数的构造方法，主要针对一些需要特殊处理的属性，比如未初始化的final属性；@AllArgsConstructor自动生成包含所有属性的构造方法。</td></tr><tr><td align="left">@Synchronized</td><td align="left">作用于方法，可锁定指定的对象，如果不指定，则默认创建创建一个对象锁定。</td></tr><tr><td align="left">@Log，或者直接@Slf4j</td><td align="left">作用于类，具体包含@CommonsLog、@Log、@Log4j、@Log4j2、@Slf4j和@XSlf4j，分别对用不同的日志系统。利用此类注解，可为类创建一个log属性。</td></tr></tbody></table><h2 id="sonar源码审查"><a href="#sonar源码审查" class="headerlink" title="sonar源码审查"></a>sonar源码审查</h2><p>sonar是一个源码审查工具。最新版5.X已经支持lombok的全部注解，不再认为是没有使用的变量。但是，旧的4.X还是认为没有使用这些变量。可以后向移植这些包，或者应用单独的补丁。</p><p><a href="https://segmentfault.com/a/1190000005133786" target="_blank" rel="noopener">摘自</a></p><p><a href="https://docs.sonarqube.org/latest/" target="_blank" rel="noopener">sonar</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一个典型的-Java-类&quot;&gt;&lt;a href=&quot;#一个典型的-Java-类&quot; class=&quot;headerlink&quot; title=&quot;一个典型的 Java 类&quot;&gt;&lt;/a&gt;一个典型的 Java 类&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;public class A {

  pr
      
    
    </summary>
    
    
      <category term="Lombok" scheme="http://iwantjingjing.com/categories/Lombok/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="lombok" scheme="http://iwantjingjing.com/tags/lombok/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之Builder模式  </title>
    <link href="http://iwantjingjing.com/2019/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BBuilder%E6%A8%A1%E5%BC%8F/"/>
    <id>http://iwantjingjing.com/2019/09/19/设计模式之Builder模式/</id>
    <published>2019-09-19T10:24:08.000Z</published>
    <updated>2019-09-28T12:31:51.433Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MySQL创建用户与授权  </title>
    <link href="http://iwantjingjing.com/2019/09/12/MySQL%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E4%B8%8E%E6%8E%88%E6%9D%83/"/>
    <id>http://iwantjingjing.com/2019/09/12/MySQL创建用户与授权/</id>
    <published>2019-09-12T08:10:52.000Z</published>
    <updated>2019-09-28T12:31:51.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-创建用户"><a href="#一-创建用户" class="headerlink" title="一. 创建用户"></a>一. 创建用户</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><pre><code>CREATE USER &apos;username&apos;@&apos;host&apos; IDENTIFIED BY &apos;password&apos;;</code></pre><h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><ul><li>username：你将创建的用户名</li><li>host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%</li><li>password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</li></ul><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><pre><code>CREATE USER &apos;dog&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;;CREATE USER &apos;pig&apos;@&apos;192.168.1.101_&apos; IDENDIFIED BY &apos;123456&apos;;CREATE USER &apos;pig&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;CREATE USER &apos;pig&apos;@&apos;%&apos; IDENTIFIED BY &apos;&apos;;CREATE USER &apos;pig&apos;@&apos;%&apos;;</code></pre><h1 id="二-授权"><a href="#二-授权" class="headerlink" title="二. 授权:"></a>二. 授权:</h1><h2 id="命令-1"><a href="#命令-1" class="headerlink" title="命令:"></a>命令:</h2><pre><code>GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos;</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h2><ul><li>privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL</li><li>databasename：数据库名</li><li>tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<em>表示，如</em>.*</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h2><pre><code>GRANT SELECT, INSERT ON test.user TO &apos;pig&apos;@&apos;%&apos;;GRANT ALL ON *.* TO &apos;pig&apos;@&apos;%&apos;;</code></pre><p>注意:<br>用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:</p><pre><code>GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos; WITH GRANT OPTION;</code></pre><h1 id="三-设置与更改用户密码"><a href="#三-设置与更改用户密码" class="headerlink" title="三.设置与更改用户密码"></a>三.设置与更改用户密码</h1><p>   命令:</p><pre><code>SET PASSWORD FOR &apos;username&apos;@&apos;host&apos; = PASSWORD(&apos;newpassword&apos;);</code></pre><p> 如果是当前登陆用户用:</p><pre><code>SET PASSWORD = PASSWORD(&quot;newpassword&quot;);</code></pre><p>例子:</p><pre><code>SET PASSWORD FOR &apos;pig&apos;@&apos;%&apos; = PASSWORD(&quot;123456&quot;);</code></pre><h1 id="四-撤销用户权限"><a href="#四-撤销用户权限" class="headerlink" title="四. 撤销用户权限"></a>四. 撤销用户权限</h1><p>命令:</p><pre><code>REVOKE privilege ON databasename.tablename FROM &apos;username&apos;@&apos;host&apos;;</code></pre><p>说明:<br>privilege, databasename, tablename：同授权部分</p><p>例子:</p><pre><code>REVOKE SELECT ON *.* FROM &apos;pig&apos;@&apos;%&apos;;</code></pre><p>注意:</p><p>假如你在给用户‘pig’@’%’授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO ‘pig’@’%’，则在使用REVOKE SELECT ON <em>.</em> FROM ‘pig’@’%’;命令并不能撤销该用户对test数据库中user表的SELECT 操作。相反，如果授权使用的是GRANT SELECT ON <em>.</em> TO ‘pig’@’%’;则REVOKE SELECT ON test.user FROM ‘pig’@’%’;命令也不能撤销该用户对test数据库中user表的Select权限。</p><p>具体信息可以用命令SHOW GRANTS FOR ‘pig’@’%’; 查看。</p><h1 id="五-删除用户"><a href="#五-删除用户" class="headerlink" title="五.删除用户"></a>五.删除用户</h1><pre><code>DROP USER &apos;username&apos;@&apos;host&apos;;</code></pre><p><a href="https://www.jianshu.com/p/d7b9c468f20d" target="_blank" rel="noopener">摘抄自</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-创建用户&quot;&gt;&lt;a href=&quot;#一-创建用户&quot; class=&quot;headerlink&quot; title=&quot;一. 创建用户&quot;&gt;&lt;/a&gt;一. 创建用户&lt;/h1&gt;&lt;h2 id=&quot;命令&quot;&gt;&lt;a href=&quot;#命令&quot; class=&quot;headerlink&quot; title=&quot;命令&quot;
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://iwantjingjing.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://iwantjingjing.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Lombok 看这篇就够了  </title>
    <link href="http://iwantjingjing.com/2019/09/12/Lombok-%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <id>http://iwantjingjing.com/2019/09/12/Lombok-看这篇就够了/</id>
    <published>2019-09-12T06:41:50.000Z</published>
    <updated>2019-09-28T12:31:51.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p><a href="https://projectlombok.org" target="_blank" rel="noopener">官网</a><br>官网解释:</p><p>Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.<br>Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.</p><h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>减少代码量,省去写geter,setter等</p><h1 id="when"><a href="#when" class="headerlink" title="when"></a>when</h1><h2 id="添加下依赖"><a href="#添加下依赖" class="headerlink" title="添加下依赖:"></a>添加下依赖:</h2><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.16.8&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>那么Lombok是做什么的呢？其实很简单，一个最简单的例子就是它能够实现通过添加注解，能够自动生成一些方法。比如这样的类:</p><pre><code>@Getterclass Test{    private String value;}</code></pre><p>我们用Lombok提供的@Getter来注解这个类，这个类在编译的时候就会变成:</p><pre><code>class Test{    private String value;    public String getValue(){        return this.value;    }}</code></pre><p>当然Lombok也提供了很多其他的注解，这只是其中一个最典型的例子。其他的用法网上的资料已经很多了，这里就不啰嗦。<br>看上去是很方便的一个功能，尤其是在很多项目里有很多bean，每次都要手写或自动生成setter getter方法，搞得代码很长而且没有啥意义，因此这个对简化代码的强迫症们还是很有吸引力的。<br>但是，我们发现这个包跟一般的包有很大区别，绝大多数java包都工作在运行时，比如spring提供的那种注解，通过在运行时用反射来实现业务逻辑。Lombok这个东西工作却在编译期，在运行时是无法通过反射获取到这个注解的。<br>而且由于他相当于是在编译期对代码进行了修改，因此从直观上看，源代码甚至是语法有问题的。<br>一个更直接的体现就是，普通的包在引用之后一般的IDE都能够自动识别语法，但是Lombok的这些注解，一般的IDE都无法自动识别，比如我们上面的Test类，如果我们在其他地方这么调用了一下:</p><pre><code>Test test=new Test();test.getValue();</code></pre><p>IDE的自动语法检查就会报错，说找不到这个getValue方法。因此如果要使用Lombok的话还需要配合安装相应的插件，防止IDE的自动检查报错。<br>因此，可以说这个东西的设计初衷比较美好，但是用起来比较麻烦，而且破坏了代码的完整性，很多项目组(包括我自己)都不高兴用。但是他的实现原理却还是比较好玩的，随便搜了搜发现网上最多也只提到了他修改了抽象语法树，虽说从感性上可以理解，但是还是想自己手敲一敲真正去实现一下。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>翻了翻现有的资料，再加上自己的一些猜想，Lombok的基本流程应该基本是这样：</p><ul><li>定义编译期的注解</li><li>利用JSR269 api(Pluggable Annotation Processing API )创建编译期的注解处理器</li><li>利用tools.jar的javac api处理AST(抽象语法树)</li><li>将功能注册进jar包</li></ul><h2 id="手撸Getter"><a href="#手撸Getter" class="headerlink" title="手撸Getter"></a>手撸Getter</h2><p>由于比较习惯用maven，我这里就用maven构建一下项目，修改下当前的pom.xml文件如下：</p><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.mythsman.test&lt;/groupId&gt;    &lt;artifactId&gt;getter&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;name&gt;test&lt;/name&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.sun&lt;/groupId&gt;            &lt;artifactId&gt;tools&lt;/artifactId&gt;            &lt;version&gt;1.8&lt;/version&gt;            &lt;scope&gt;system&lt;/scope&gt;            &lt;systemPath&gt;${java.home}/../lib/tools.jar&lt;/systemPath&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>主要定义了下项目名，除了默认依赖的junit之外(其实并没有用)，这里添加了tools.jar包。这个包实在jdk的lib下面，因此scope是system，由于${java.home}变量表示的是jre的位置，因此还要根据这个位置找到实际的tools.jar的路径并写在systemPath里。<br>由于防止在写代码的时候用到java8的一些语法，这里配置了下编译插件使其支持java8。</p><h3 id="创建Getter注解"><a href="#创建Getter注解" class="headerlink" title="创建Getter注解"></a>创建Getter注解</h3><p>定义注解Getter.java:</p><pre><code>package com.mythsman.test;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target({ElementType.TYPE})@Retention(RetentionPolicy.SOURCE)public @interface Getter {}</code></pre><p>这里的Target我选择了ElementType.TYPE表示是对类的注解，Retention选择了RententionPolicy.SOURCE，表示这个注解只在编译期起作用，在运行时将不存在。这个比较简单，稍微复杂点的是对这个注解的处理机制。像spring那种注解是通过反射来获得注解对应的元素并实现业务逻辑，但是我们显然不希望在使用Lombok这种功能的时候还要编写其他的调用代码，况且用反射也获取不到编译期才存在的注解。<br>幸运的是Java早已支持了JSR269的规范，允许在编译时指定一个processor类来对编译阶段的注解进行干预，下面就来解决下这个处理器。</p><h3 id="创建Getter注解的处理器"><a href="#创建Getter注解的处理器" class="headerlink" title="创建Getter注解的处理器"></a>创建Getter注解的处理器</h3><p>基本框架</p><p>自定义的处理器需要继承AbstractProcessor这个类，基本的框架大体应当如下:</p><pre><code>package com.mythsman.test;import javax.annotation.processing.*;import javax.lang.model.SourceVersion;import javax.lang.model.element.TypeElement;import java.util.Set;@SupportedAnnotationTypes(&quot;com.mythsman.test.Getter&quot;)@SupportedSourceVersion(SourceVersion.RELEASE_8)public class GetterProcessor extends AbstractProcessor {    @Override    public synchronized void init(ProcessingEnvironment processingEnv) {        super.init(processingEnv);    }    @Override    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {        return true;    }}</code></pre><p>需要定义两个注解，一个表示该处理器需要处理的注解，另外一个表示该处理器支持的源码版本。然后需要着重实现两个方法，init跟process。init的主要用途是通过ProcessingEnvironment来获取编译阶段的一些环境信息;process主要是实现具体逻辑的地方，也就是对AST进行处理的地方。</p><p>具体怎么做呢？</p><p>init方法<br>首先我们要重写下init方法，从环境里提取一些关键的类:</p><pre><code>private Messager messager;private JavacTrees trees;private TreeMaker treeMaker;private Names names;@Overridepublic synchronized void init(ProcessingEnvironment processingEnv) {    super.init(processingEnv);    this.messager = processingEnv.getMessager();    this.trees = JavacTrees.instance(processingEnv);    Context context = ((JavacProcessingEnvironment) processingEnv).getContext();    this.treeMaker = TreeMaker.instance(context);    this.names = Names.instance(context);}</code></pre><p>我们提取了四个主要的类:</p><ul><li>Messager主要是用来在编译期打log用的</li><li>JavacTrees提供了待处理的抽象语法树</li><li>TreeMaker封装了创建AST节点的一些方法</li><li>Names提供了创建标识符的方法</li></ul><p>process方法<br>process方法的逻辑比较简单，但是由于这里的api对于我们来说比较陌生，因此写起来还是费了不少劲的：</p><pre><code>@Overridepublic synchronized boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {    Set&lt;? extends Element&gt; set = roundEnv.getElementsAnnotatedWith(Getter.class);    set.forEach(element -&gt; {        JCTree jcTree = trees.getTree(element);        jcTree.accept(new TreeTranslator() {            @Override            public void visitClassDef(JCTree.JCClassDecl jcClassDecl) {                List&lt;JCTree.JCVariableDecl&gt; jcVariableDeclList = List.nil();                for (JCTree tree : jcClassDecl.defs) {                    if (tree.getKind().equals(Tree.Kind.VARIABLE)) {                        JCTree.JCVariableDecl jcVariableDecl = (JCTree.JCVariableDecl) tree;                        jcVariableDeclList = jcVariableDeclList.append(jcVariableDecl);                    }                }                jcVariableDeclList.forEach(jcVariableDecl -&gt; {                    messager.printMessage(Diagnostic.Kind.NOTE, jcVariableDecl.getName() + &quot; has been processed&quot;);                    jcClassDecl.defs = jcClassDecl.defs.prepend(makeGetterMethodDecl(jcVariableDecl));                });                super.visitClassDef(jcClassDecl);            }        });    });    return true;}</code></pre><p>步骤大概是下面这样：</p><ol><li>利用roundEnv的getElementsAnnotatedWith方法过滤出被Getter这个注解标记的类，并存入set</li><li>遍历这个set里的每一个元素，并生成jCTree这个语法树</li><li>创建一个TreeTranslator，并重写其中的visitClassDef方法，这个方法处理遍历语法树得到的类定义部分jcClassDecl<ul><li>创建一个jcVariableDeclList保存类的成员变量</li><li>遍历jcTree的所有成员(包括成员变量和成员函数和构造函数)，过滤出其中的成员变量，并添加进jcVariableDeclList</li><li>将jcVariableDeclList的所有变量转换成需要添加的getter方法，并添加进jcClassDecl的成员中</li><li>调用默认的遍历方法遍历处理后的jcClassDecl</li></ul></li><li>利用上面的TreeTranslator去处理jcTree</li></ol><p>接下来再实现makeGetterMethodDecl方法:</p><pre><code>private JCTree.JCMethodDecl makeGetterMethodDecl(JCTree.JCVariableDecl jcVariableDecl) {    ListBuffer&lt;JCTree.JCStatement&gt; statements = new ListBuffer&lt;&gt;();    statements.append(treeMaker.Return(treeMaker.Select(treeMaker.Ident(names.fromString(&quot;this&quot;)), jcVariableDecl.getName())));    JCTree.JCBlock body = treeMaker.Block(0, statements.toList());    return treeMaker.MethodDef(treeMaker.Modifiers(Flags.PUBLIC), getNewMethodName(jcVariableDecl.getName()), jcVariableDecl.vartype, List.nil(), List.nil(), List.nil(), body, null);}private Name getNewMethodName(Name name) {    String s = name.toString();    return names.fromString(&quot;get&quot; + s.substring(0, 1).toUpperCase() + s.substring(1, name.length()));}</code></pre><p>逻辑就是读取变量的定义，并创建对应的Getter方法，并试图用驼峰命名法。</p><p>整体上难点还是集中在api的使用上，还有一些细微的注意点:<br>首先，messager的printMessage方法在打印log的时候会自动过滤重复的log信息。<br>其次，这里的list并不是java.util里面的list，而是一个自定义的list，这个list的用法比较坑爹，他采用的是这样的方式:</p><pre><code>package com.sun.tools.javac.util;public class List&lt;A&gt; extends AbstractCollection&lt;A&gt; implements java.util.List&lt;A&gt; {    public A head;    public List&lt;A&gt; tail;    //...    List(A var1, List&lt;A&gt; var2) {        this.tail = var2;        this.head = var1;    }    public List&lt;A&gt; prepend(A var1) {        return new List(var1, this);    }    public static &lt;A&gt; List&lt;A&gt; of(A var0) {        return new List(var0, nil());    }    public List&lt;A&gt; append(A var1) {        return of(var1).prependList(this);    }    public static &lt;A&gt; List&lt;A&gt; nil() {        return EMPTY_LIST;    }    //...}</code></pre><p>挺有趣的，用这种叫cons而不是list的数据结构，添加元素的时候就把自己赋给自己的tail,新来的元素放进head。不过需要注意的是这个东西不支持链式调用，prepend之后还要将新值赋给自己。<br>而且这里在创建getter方法的时候还要把参数写全写对了，尤其是添加this指针的这种用法。</p><p>测试类<br>上面基本就是所有功能代码了，接下来我们要写一个类来测试一下(App.java)：</p><pre><code>package com.mythsman.test;@Getterpublic class App {    private String value;    private String value2;    public App(String value) {        this.value = value;    }    public static void main(String[] args) {        App app = new App(&quot;it works&quot;);        System.out.println(app.getValue());    }}</code></pre><p>不过，先不要急着构建，构建了肯定会失败，因为这原则上应该是两个项目。Getter.java是注解类没问题，但是GetterProcessor.java是处理器，App.java需要在编译期调用这个处理器，因此这两个东西是不能一起编译的，正确的编译方法应该是类似下面这样，写成compile.sh脚本就是：</p><pre><code>#!/usr/bin/env bashif [ -d classes ]; then    rm -rf classes;fimkdir classesjavac -cp $JAVA_HOME/lib/tools.jar com/mythsman/test/Getter* -d classes/javac -cp classes -d classes -processor com.mythsman.test.GetterProcessor com/mythsman/test/App.javajavap -p classes com/mythsman/test/App.classjava -cp classes com.mythsman.test.App</code></pre><p>其实是五个步骤:</p><ol><li>创建保存class文件的文件夹</li><li>导入tools.jar，编译processor并输出</li><li>编译App.java，并使用javac的-processor参数指定编译阶段的处理器GetterProcessor</li><li>用javap显示编译后的App.class文件(非必须，方便看结果)</li><li>执行测试类    </li></ol><p>好了，进入项目的根目录，当前的目录结构应该是这样的:</p><p>.<br>├── pom.xml<br>├── src<br>│   ├── main<br>│   │   ├── java<br>│   │   │   ├── com<br>│   │   │   │   └── mythsman<br>│   │   │   │       └── test<br>│   │   │   │           ├── App.java<br>│   │   │   │           ├── Getter.java<br>│   │   │   │           └── GetterProcessor.java<br>│   │   │   └── compile.sh</p><p>调用compile.sh，输出如下:</p><pre><code>Note: value has been processedNote: value2 has been processedCompiled from &quot;App.java&quot;public class com.mythsman.test.App {  private java.lang.String value;  private java.lang.String value2;  public java.lang.String getValue2();  public java.lang.String getValue();  public com.mythsman.test.App(java.lang.String);  public static void main(java.lang.String[]);}it works</code></pre><p>Note行就是在GetterProcessor类里通过messager打印的log，中间的是javap反编译的结果，最后一行表示测试调用成功。</p><h3 id="Maven构建并打包"><a href="#Maven构建并打包" class="headerlink" title="Maven构建并打包"></a>Maven构建并打包</h3><p>上面的测试部分其实是为了测试而测试，其实这应当是两个项目，一个是processor项目，这个项目应当被打成一个jar包，供调用者使用；另一个项目是app项目，这个项目是专门使用jar包的，他并不希望添加任何额外编译参数，就跟lombok的用法一样。<br>简单来说，就是我们希望把processor打成一个包，并且在使用时不需要添加额外参数。<br>那么如何在调用的时候不用加参数呢，其实我们知道java在编译的时候会去资源文件夹下读一个META-INF文件夹，这个文件夹下面除了MANIFEST.MF文件之外，还可以添加一个services文件夹，我们可以在这个文件夹下创建一个文件，文件名是javax.annotation.processing.Processor，文件内容是com.mythsman.test.GetterProcessor。<br>我们知道maven在编译前会先拷贝资源文件夹，然后当他在编译时候发现了资源文件夹下的META-INF/serivces文件夹时，他就会读取里面的文件，并将文件名所代表的接口用文件内容表示的类来实现。这就相当于做了-processor参数该做的事了。<br>当然这个文件我们并不希望调用者去写，而是希望在processor项目里集成，调用的时候能直接继承META-INF。</p><p>好了，我们先删除App.java和compile.sh，添加下META-INF文件夹，当前目录结构应该是这样的：</p><p>.<br>├── pom.xml<br>├── src<br>│   └── main<br>│       ├── java<br>│       │   └── com<br>│       │       └── mythsman<br>│       │           └── test<br>│       │               ├── Getter.java<br>│       │               └── GetterProcessor.java<br>│       └── resources<br>│           └── META-INF<br>│               └── services<br>│                   └── javax.annotation.processing.Processor</p><p>当然，我们还不能编译，因为processor项目并不需要把自己添加为processor(况且自己还没编译呢怎么调用自己)。。。完了，好像死循环了，自己在编译的时候不能添加services文件夹，但是又需要打的包里有services文件夹，这该怎么搞呢？<br>其实很简单，配置一下maven的插件就行，打开pom.xml,在project/build/标签里添加下面的配置:</p><pre><code>&lt;build&gt;   &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;excludes&gt;                &lt;exclude&gt;META-INF/**/*&lt;/exclude&gt;            &lt;/excludes&gt;        &lt;/resource&gt;    &lt;/resources&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;            &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;            &lt;version&gt;2.6&lt;/version&gt;            &lt;executions&gt;                &lt;execution&gt;                    &lt;id&gt;process-META&lt;/id&gt;                    &lt;phase&gt;prepare-package&lt;/phase&gt;                    &lt;goals&gt;                        &lt;goal&gt;copy-resources&lt;/goal&gt;                    &lt;/goals&gt;                    &lt;configuration&gt;                        &lt;outputDirectory&gt;target/classes&lt;/outputDirectory&gt;                        &lt;resources&gt;                            &lt;resource&gt;                                &lt;directory&gt;${basedir}/src/main/resources/&lt;/directory&gt;                                &lt;includes&gt;                                    &lt;include&gt;**/*&lt;/include&gt;                                &lt;/includes&gt;                            &lt;/resource&gt;                        &lt;/resources&gt;                    &lt;/configuration&gt;                &lt;/execution&gt;            &lt;/executions&gt;        &lt;/plugin&gt;        ...    &lt;/plugins&gt;&lt;/build&gt;</code></pre><p>我们知道maven构建的第一步就是调用maven-resources-plugin插件的resources命令，将resources文件夹复制到target/classes中，那么我们配置一下resources标签，过滤掉META-INF文件夹，这样在编译的时候就不会找到services的配置了。然后我们在打包前(prepare-package生命周期)再利用maven-resources-plugin插件的copy-resources命令把services文件夹重新拷贝过来不就好了么。<br>这样配置好了，就可以直接执行mvn clean install打包提交到本地私服:</p><pre><code>myths@pc:~/Desktop/test$ mvn clean install[INFO] Scanning for projects...[INFO] [INFO] ------------------------------------------------------------------------[INFO] Building test 1.0-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO] [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ getter ---[INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ getter ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] Copying 0 resource[INFO] [INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ getter ---[INFO] Changes detected - recompiling the module![INFO] Compiling 2 source files to /home/myths/Desktop/test/target/classes[INFO] [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ getter ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] skip non existing resourceDirectory /home/myths/Desktop/test/src/test/resources[INFO] [INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ getter ---[INFO] No sources to compile[INFO] [INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ getter ---[INFO] No tests to run.[INFO] [INFO] --- maven-resources-plugin:2.6:copy-resources (process-META) @ getter ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] Copying 1 resource[INFO] [INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ getter ---[INFO] Building jar: /home/myths/Desktop/test/target/getter-1.0-SNAPSHOT.jar[INFO] [INFO] --- maven-install-plugin:2.4:install (default-install) @ getter ---[INFO] Installing /home/myths/Desktop/test/target/getter-1.0-SNAPSHOT.jar to /home/myths/.m2/repository/com/mythsman/test/getter/1.0-SNAPSHOT/getter-1.0-SNAPSHOT.jar[INFO] Installing /home/myths/Desktop/test/pom.xml to /home/myths/.m2/repository/com/mythsman/test/getter/1.0-SNAPSHOT/getter-1.0-SNAPSHOT.pom[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 3.017 s[INFO] Finished at: 2017-12-19T19:57:04+08:00[INFO] Final Memory: 16M/201M[INFO] ------------------------------------------------------------------------</code></pre><p>可以看到这里的process-META作用生效。</p><p>调用jar包测试</p><p>重新创建一个测试项目app：</p><p>.<br>├── pom.xml<br>└── src<br>    └── main<br>        └── java<br>            └── com<br>                └── mythsman<br>                    └── test<br>                        └── App.java</p><p>pom.xml:</p><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.mythsman.test&lt;/groupId&gt;    &lt;artifactId&gt;app&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;name&gt;main&lt;/name&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.mythsman.test&lt;/groupId&gt;            &lt;artifactId&gt;getter&lt;/artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>App.java:</p><pre><code>package com.mythsman.test;@Getterpublic class App {    private String value;    private String value2;    public App(String value) {        this.value = value;    }    public static void main(String[] args) {        App app = new App(&quot;it works&quot;);        System.out.println(app.getValue());    }}</code></pre><p>编译并执行:</p><p>mvn clean compile &amp;&amp; java -cp target/classes com.mythsman.test.App</p><p>最后就会在构建成功后打印”it works”。</p><p><a href="https://zhuanlan.zhihu.com/p/32779910" target="_blank" rel="noopener">参考</a><br><a href="https://yq.aliyun.com/articles/59972" target="_blank" rel="noopener">参考</a><br><a href="https://juejin.im/entry/5a390ba76fb9a0451e3fed7c" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;what&quot;&gt;&lt;a href=&quot;#what&quot; class=&quot;headerlink&quot; title=&quot;what&quot;&gt;&lt;/a&gt;what&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://projectlombok.org&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
    
      <category term="Lombok" scheme="http://iwantjingjing.com/categories/Lombok/"/>
    
    
      <category term="idea" scheme="http://iwantjingjing.com/tags/idea/"/>
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="lombok" scheme="http://iwantjingjing.com/tags/lombok/"/>
    
      <category term="plugin" scheme="http://iwantjingjing.com/tags/plugin/"/>
    
  </entry>
  
  <entry>
    <title>初识Shiro</title>
    <link href="http://iwantjingjing.com/2019/09/12/%E5%88%9D%E8%AF%86Shiro/"/>
    <id>http://iwantjingjing.com/2019/09/12/初识Shiro/</id>
    <published>2019-09-12T05:56:37.000Z</published>
    <updated>2019-09-28T13:54:55.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p><a href="https://shiro.apache.org" target="_blank" rel="noopener">官网</a></p><h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;what&quot;&gt;&lt;a href=&quot;#what&quot; class=&quot;headerlink&quot; title=&quot;what&quot;&gt;&lt;/a&gt;what&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://shiro.apache.org&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
    
      <category term="Shiro" scheme="http://iwantjingjing.com/categories/Shiro/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="Shiro" scheme="http://iwantjingjing.com/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>Mac 下locate命令使用问题WARNING: The locate database (/var/db/locate.database) does not exist</title>
    <link href="http://iwantjingjing.com/2019/09/11/Mac-%E4%B8%8Blocate%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98WARNING-The-locate-database-var-db-locate-database-does-not-exist/"/>
    <id>http://iwantjingjing.com/2019/09/11/Mac-下locate命令使用问题WARNING-The-locate-database-var-db-locate-database-does-not-exist/</id>
    <published>2019-09-11T01:44:23.000Z</published>
    <updated>2019-09-28T12:31:51.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><img src="locate.png" alt></p><p>根据提示使用 </p><p>sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.locate.plist<br> 并没有生效。</p><p>需要执行</p><p>sudo /usr/libexec/locate.updatedb 进行库更新。</p><p><a href="https://www.cnblogs.com/b-ruce/p/5911048.html" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;locate.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;根据提示使用 &lt;/p&gt;
&lt;p&gt;sudo launchctl load -
      
    
    </summary>
    
    
      <category term="Mac" scheme="http://iwantjingjing.com/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://iwantjingjing.com/tags/Mac/"/>
    
      <category term="exception" scheme="http://iwantjingjing.com/tags/exception/"/>
    
  </entry>
  
  <entry>
    <title>mac上解决java.rmi.server.ExportException- Port already in use- 1099; nested exception is- java.net.Bi</title>
    <link href="http://iwantjingjing.com/2019/09/09/mac%E4%B8%8A%E8%A7%A3%E5%86%B3java-rmi-server-ExportException-Port-already-in-use-1099-nested-exception-is-java-net-Bi/"/>
    <id>http://iwantjingjing.com/2019/09/09/mac上解决java-rmi-server-ExportException-Port-already-in-use-1099-nested-exception-is-java-net-Bi/</id>
    <published>2019-09-09T10:39:14.000Z</published>
    <updated>2019-09-28T12:31:51.427Z</updated>
    
    <content type="html"><![CDATA[<p>tomcat启动报如下的错误：</p><p>java.rmi.server.ExportException: Port already in use: 1099; nested exception is: java.net.BindException: Address already in use (Bind failed)</p><p>解决方法有两种</p><h1 id="第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法"><a href="#第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法" class="headerlink" title="第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法"></a>第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法</h1><h1 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h1><p>第一步：使用lsof -i tcp:1099 查看时那个应用占用了此端口</p><p>第二部：使用kill pid 即可，这里的pid是第一步所查询到结果</p><p><a href="https://blog.csdn.net/u010412719/article/details/76724125" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;tomcat启动报如下的错误：&lt;/p&gt;
&lt;p&gt;java.rmi.server.ExportException: Port already in use: 1099; nested exception is: java.net.BindException: Address a
      
    
    </summary>
    
    
      <category term="exception" scheme="http://iwantjingjing.com/categories/exception/"/>
    
    
      <category term="exception" scheme="http://iwantjingjing.com/tags/exception/"/>
    
      <category term="mac" scheme="http://iwantjingjing.com/tags/mac/"/>
    
  </entry>
  
</feed>
