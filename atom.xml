<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>I want jing jing</title>
  
  <subtitle>I want jing jing ,Don&#39;t ask me who is jing jing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://iwantjingjing.com/"/>
  <updated>2021-06-06T11:40:32.215Z</updated>
  <id>http://iwantjingjing.com/</id>
  
  <author>
    <name>给予ππ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java8Base64</title>
    <link href="http://iwantjingjing.com/2021/06/06/java8Base64/"/>
    <id>http://iwantjingjing.com/2021/06/06/java8Base64/</id>
    <published>2021-06-06T11:34:35.000Z</published>
    <updated>2021-06-06T11:40:32.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java8Base64"><a href="#java8Base64" class="headerlink" title="java8Base64"></a>java8Base64</h1><p>在Java 8中，Base64编码已经成为Java类库的标准。</p><p>Java 8 内置了 Base64 编码的编码器和解码器。</p><p>Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：</p><ul><li>基本：输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/。</li><li>URL：输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。</li><li>MIME：输出隐射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割。</li></ul><h2 id="内嵌类"><a href="#内嵌类" class="headerlink" title="内嵌类"></a>内嵌类</h2><p>|—|—|<br>|序号    |内嵌类  &amp; 描述|<br>| 1|    static class Base64.Decoder 该类实现一个解码器用于，使用 Base64 编码来解码字节数据。|<br>|2 |static class Base64.Encoder 该类实现一个编码器，使用 Base64 编码来编码字节数据。|</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>|—|—|<br>|序号    |方法 &amp; 描述|<br>| 1|static Base64.Decoder getDecoder()返回一个 Base64.Decoder ，解码使用基本型 base64 编码方案。|<br>|2 |static Base64.Encoder getEncoder()返回一个 Base64.Encoder ，编码使用基本型 base64 编码方案。|<br>|3 |static Base64.Decoder getMimeDecoder()返回一个 Base64.Decoder ，解码使用 MIME 型 base64 编码方案。|<br>|4 |static Base64.Encoder getMimeEncoder()返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案。|<br>| 5|static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案，可以通过参数指定每行的长度及行的分隔符。|<br>|6 |static Base64.Decoder getUrlDecoder()返回一个 Base64.Decoder ，解码使用 URL 和文件名安全型 base64 编码方案。|<br>|7 |static Base64.Encoder getUrlEncoder()返回一个 Base64.Encoder ，编码使用 URL 和文件名安全型 base64 编码方案。|</p><h2 id="Base64-实例"><a href="#Base64-实例" class="headerlink" title="Base64 实例"></a>Base64 实例</h2><p>以下实例演示了 Base64 的使用:</p><p><code>Java8Tester.java 文件</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Base64;</span><br><span class="line">import java.util.UUID;</span><br><span class="line">import java.io.UnsupportedEncodingException;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        </span><br><span class="line">         &#x2F;&#x2F; 使用基本编码</span><br><span class="line">         String base64encodedString &#x3D; Base64.getEncoder().encodeToString(&quot;runoob?java8&quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">         System.out.println(&quot;Base64 编码字符串 (基本) :&quot; + base64encodedString);</span><br><span class="line">        </span><br><span class="line">         &#x2F;&#x2F; 解码</span><br><span class="line">         byte[] base64decodedBytes &#x3D; Base64.getDecoder().decode(base64encodedString);</span><br><span class="line">        </span><br><span class="line">         System.out.println(&quot;原始字符串: &quot; + new String(base64decodedBytes, &quot;utf-8&quot;));</span><br><span class="line">         base64encodedString &#x3D; Base64.getUrlEncoder().encodeToString(&quot;runoob?java8&quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">         System.out.println(&quot;Base64 编码字符串 (URL) :&quot; + base64encodedString);</span><br><span class="line">        </span><br><span class="line">         StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line">        </span><br><span class="line">         for (int i &#x3D; 0; i &lt; 10; ++i) &#123;</span><br><span class="line">            stringBuilder.append(UUID.randomUUID().toString());</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">         byte[] mimeBytes &#x3D; stringBuilder.toString().getBytes(&quot;utf-8&quot;);</span><br><span class="line">         String mimeEncodedString &#x3D; Base64.getMimeEncoder().encodeToString(mimeBytes);</span><br><span class="line">         System.out.println(&quot;Base64 编码字符串 (MIME) :&quot; + mimeEncodedString);</span><br><span class="line">         </span><br><span class="line">      &#125;catch(UnsupportedEncodingException e)&#123;</span><br><span class="line">         System.out.println(&quot;Error :&quot; + e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上脚本，输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ javac Java8Tester.java </span><br><span class="line">$ java Java8Tester</span><br><span class="line">原始字符串: runoob?java8</span><br><span class="line">Base64 编码字符串 (URL) :VHV0b3JpYWxzUG9pbnQ_amF2YTg&#x3D;</span><br><span class="line">Base64 编码字符串 (MIME) :M2Q4YmUxMTEtYWRkZi00NzBlLTgyZDgtN2MwNjgzOGY2NGFlOTQ3NDYyMWEtZDM4ZS00YWVhLTkz</span><br><span class="line">OTYtY2ZjMzZiMzFhNmZmOGJmOGI2OTYtMzkxZi00OTJiLWEyMTQtMjgwN2RjOGI0MTBmZWUwMGNk</span><br><span class="line">NTktY2ZiZS00MTMxLTgzODctNDRjMjFkYmZmNGM4Njg1NDc3OGItNzNlMC00ZWM4LTgxNzAtNjY3</span><br><span class="line">NTgyMGY3YzVhZWQyMmNiZGItOTIwZi00NGUzLTlkMjAtOTkzZTI1MjUwMDU5ZjdkYjg2M2UtZTJm</span><br><span class="line">YS00Y2Y2LWIwNDYtNWQ2MGRiOWQyZjFiMzJhMzYxOWQtNDE0ZS00MmRiLTk3NDgtNmM4NTczYjMx</span><br><span class="line">ZDIzNGRhOWU4NDAtNTBiMi00ZmE2LWE0M2ItZjU3MWFiNTI2NmQ2NTlmMTFmZjctYjg1NC00NmE1</span><br><span class="line">LWEzMWItYjk3MmEwZTYyNTdk</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java8Base64&quot;&gt;&lt;a href=&quot;#java8Base64&quot; class=&quot;headerlink&quot; title=&quot;java8Base64&quot;&gt;&lt;/a&gt;java8Base64&lt;/h1&gt;&lt;p&gt;在Java 8中，Base64编码已经成为Java类库的标准。&lt;/p
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java8时间日期API</title>
    <link href="http://iwantjingjing.com/2021/06/06/java8%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9FAPI/"/>
    <id>http://iwantjingjing.com/2021/06/06/java8%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9FAPI/</id>
    <published>2021-06-06T11:30:41.000Z</published>
    <updated>2021-06-06T11:33:54.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java8时间日期API"><a href="#java8时间日期API" class="headerlink" title="java8时间日期API"></a>java8时间日期API</h1><p>Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。</p><p>在旧版的 Java 中，日期时间 API 存在诸多问题，其中有：</p><ul><li>非线程安全 − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。</li><li>设计很差 − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。</li><li>时区处理麻烦 − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。</li></ul><p>Java 8 在 java.time 包下提供了很多新的 API。以下为两个比较重要的 API：</p><ul><li>Local(本地) − 简化了日期时间的处理，没有时区的问题。</li><li>Zoned(时区) − 通过制定的时区处理日期时间。<br>新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。</li></ul><h2 id="本地化日期时间-API"><a href="#本地化日期时间-API" class="headerlink" title="本地化日期时间 API"></a>本地化日期时间 API</h2><p>LocalDate/LocalTime 和 LocalDateTime 类可以在处理时区不是必须的情况。代码如下：</p><p><code>Java8Tester.java 文件</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Java8Tester.java 文件</span><br><span class="line">import java.time.LocalDate;</span><br><span class="line">import java.time.LocalTime;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.time.Month;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      Java8Tester java8tester &#x3D; new Java8Tester();</span><br><span class="line">      java8tester.testLocalDateTime();</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   public void testLocalDateTime()&#123;</span><br><span class="line">    </span><br><span class="line">      &#x2F;&#x2F; 获取当前的日期时间</span><br><span class="line">      LocalDateTime currentTime &#x3D; LocalDateTime.now();</span><br><span class="line">      System.out.println(&quot;当前时间: &quot; + currentTime);</span><br><span class="line">        </span><br><span class="line">      LocalDate date1 &#x3D; currentTime.toLocalDate();</span><br><span class="line">      System.out.println(&quot;date1: &quot; + date1);</span><br><span class="line">        </span><br><span class="line">      Month month &#x3D; currentTime.getMonth();</span><br><span class="line">      int day &#x3D; currentTime.getDayOfMonth();</span><br><span class="line">      int seconds &#x3D; currentTime.getSecond();</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;月: &quot; + month +&quot;, 日: &quot; + day +&quot;, 秒: &quot; + seconds);</span><br><span class="line">        </span><br><span class="line">      LocalDateTime date2 &#x3D; currentTime.withDayOfMonth(10).withYear(2012);</span><br><span class="line">      System.out.println(&quot;date2: &quot; + date2);</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F; 12 december 2014</span><br><span class="line">      LocalDate date3 &#x3D; LocalDate.of(2014, Month.DECEMBER, 12);</span><br><span class="line">      System.out.println(&quot;date3: &quot; + date3);</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F; 22 小时 15 分钟</span><br><span class="line">      LocalTime date4 &#x3D; LocalTime.of(22, 15);</span><br><span class="line">      System.out.println(&quot;date4: &quot; + date4);</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F; 解析字符串</span><br><span class="line">      LocalTime date5 &#x3D; LocalTime.parse(&quot;20:15:30&quot;);</span><br><span class="line">      System.out.println(&quot;date5: &quot; + date5);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;&#96;    </span><br><span class="line">执行以上脚本，输出结果为：</span><br></pre></td></tr></table></figure><p>$ javac Java8Tester.java<br>$ java Java8Tester<br>当前时间: 2016-04-15T16:55:48.668<br>date1: 2016-04-15<br>月: APRIL, 日: 15, 秒: 48<br>date2: 2012-04-10T16:55:48.668<br>date3: 2014-12-12<br>date4: 22:15<br>date5: 20:15:30</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 使用时区的日期时间API</span><br><span class="line">如果我们需要考虑到时区，就可以使用时区的日期时间API：</span><br><span class="line"></span><br><span class="line">&#96;Java8Tester.java 文件</span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure><p>Java8Tester.java 文件<br>import java.time.ZonedDateTime;<br>import java.time.ZoneId;</p><p>public class Java8Tester {<br>   public static void main(String args[]){<br>      Java8Tester java8tester = new Java8Tester();<br>      java8tester.testZonedDateTime();<br>   }</p><p>   public void testZonedDateTime(){</p><pre><code>// 获取当前时间日期ZonedDateTime date1 = ZonedDateTime.parse(&quot;2015-12-03T10:15:30+05:30[Asia/Shanghai]&quot;);System.out.println(&quot;date1: &quot; + date1);ZoneId id = ZoneId.of(&quot;Europe/Paris&quot;);System.out.println(&quot;ZoneId: &quot; + id);ZoneId currentZone = ZoneId.systemDefault();System.out.println(&quot;当期时区: &quot; + currentZone);</code></pre><p>   }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行以上脚本，输出结果为：</span><br></pre></td></tr></table></figure><p>$ javac Java8Tester.java<br>$ java Java8Tester<br>date1: 2015-12-03T10:15:30+08:00[Asia/Shanghai]<br>ZoneId: Europe/Paris<br>当期时区: Asia/Shanghai</p><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java8时间日期API&quot;&gt;&lt;a href=&quot;#java8时间日期API&quot; class=&quot;headerlink&quot; title=&quot;java8时间日期API&quot;&gt;&lt;/a&gt;java8时间日期API&lt;/h1&gt;&lt;p&gt;Java 8通过发布新的Date-Time API (JSR
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java8中Nashorn</title>
    <link href="http://iwantjingjing.com/2021/06/06/java8%E4%B8%ADNashorn/"/>
    <id>http://iwantjingjing.com/2021/06/06/java8%E4%B8%ADNashorn/</id>
    <published>2021-06-06T10:08:35.000Z</published>
    <updated>2021-06-06T11:29:39.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-8-Nashorn-JavaScript"><a href="#Java-8-Nashorn-JavaScript" class="headerlink" title="Java 8 Nashorn JavaScript"></a>Java 8 Nashorn JavaScript</h1><p>Nashorn 一个 javascript 引擎。</p><p><span style="color: red; "> Nashorn JavaScript Engine 在 Java 15 已经不可用了。 </span></p><p>这已经在 Java 11 标记为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@deprecated (forRemoval &#x3D; true)</span><br></pre></td></tr></table></figure><p>从 JDK 1.8 开始，Nashorn取代Rhino(JDK 1.6, JDK1.7) 成为 Java 的嵌入式 JavaScript 引擎。Nashorn 完全支持 ECMAScript 5.1 规范以及一些扩展。它使用基于 JSR 292 的新语言特性，其中包含在 JDK 7 中引入的 invokedynamic，将 JavaScript 编译成 Java 字节码。</p><p>与先前的 Rhino 实现相比，这带来了 2 到 10倍的性能提升。</p><h2 id="jjs"><a href="#jjs" class="headerlink" title="jjs"></a>jjs</h2><p>jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。</p><p>例如，我们创建一个具有如下内容的sample.js文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&#39;Hello World!&#39;);</span><br></pre></td></tr></table></figure><p>打开控制台，输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jjs sample.js</span><br></pre></td></tr></table></figure><p>以上程序输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure><h2 id="jjs-交互式编程"><a href="#jjs-交互式编程" class="headerlink" title="jjs 交互式编程"></a>jjs 交互式编程</h2><p>打开控制台，输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ jjs</span><br><span class="line">jjs&gt; print(&quot;Hello, World!&quot;)</span><br><span class="line">Hello, World!</span><br><span class="line">jjs&gt; quit()</span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>打开控制台，输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jjs -- a b c</span><br><span class="line">jjs&gt; print(&#39;字母: &#39; +arguments.join(&quot;, &quot;))</span><br><span class="line">字母: a, b, c</span><br><span class="line">jjs&gt;</span><br></pre></td></tr></table></figure><h2 id="Java-中调用-JavaScript"><a href="#Java-中调用-JavaScript" class="headerlink" title="Java 中调用 JavaScript"></a>Java 中调用 JavaScript</h2><p>使用 ScriptEngineManager, JavaScript 代码可以在 Java 中执行，实例如下：<br><code>Java8Tester.java 文件</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import javax.script.ScriptEngineManager;</span><br><span class="line">import javax.script.ScriptEngine;</span><br><span class="line">import javax.script.ScriptException;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">   </span><br><span class="line">      ScriptEngineManager scriptEngineManager &#x3D; new ScriptEngineManager();</span><br><span class="line">      ScriptEngine nashorn &#x3D; scriptEngineManager.getEngineByName(&quot;nashorn&quot;);</span><br><span class="line">        </span><br><span class="line">      String name &#x3D; &quot;Runoob&quot;;</span><br><span class="line">      Integer result &#x3D; null;</span><br><span class="line">      </span><br><span class="line">      try &#123;</span><br><span class="line">         nashorn.eval(&quot;print(&#39;&quot; + name + &quot;&#39;)&quot;);</span><br><span class="line">         result &#x3D; (Integer) nashorn.eval(&quot;10 + 2&quot;);</span><br><span class="line">         </span><br><span class="line">      &#125;catch(ScriptException e)&#123;</span><br><span class="line">         System.out.println(&quot;执行脚本错误: &quot;+ e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      System.out.println(result.toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上脚本，输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ javac Java8Tester.java </span><br><span class="line">$ java Java8Tester</span><br><span class="line">Runoob</span><br><span class="line">12</span><br></pre></td></tr></table></figure><h2 id="JavaScript-中调用-Java"><a href="#JavaScript-中调用-Java" class="headerlink" title="JavaScript 中调用 Java"></a>JavaScript 中调用 Java</h2><p>以下实例演示了如何在 JavaScript 中引用 Java 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var BigDecimal &#x3D; Java.type(&#39;java.math.BigDecimal&#39;);</span><br><span class="line"></span><br><span class="line">function calculate(amount, percentage) &#123;</span><br><span class="line"></span><br><span class="line">   var result &#x3D; new BigDecimal(amount).multiply(</span><br><span class="line">   new BigDecimal(percentage)).divide(new BigDecimal(&quot;100&quot;), 2, BigDecimal.ROUND_HALF_EVEN);</span><br><span class="line">   </span><br><span class="line">   return result.toPlainString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result &#x3D; calculate(568000000000000000023,13.9);</span><br><span class="line">print(result);</span><br></pre></td></tr></table></figure><p>我们使用 jjs 命令执行以上脚本，输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jjs sample.js</span><br><span class="line">78952000000000002017.94</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-8-Nashorn-JavaScript&quot;&gt;&lt;a href=&quot;#Java-8-Nashorn-JavaScript&quot; class=&quot;headerlink&quot; title=&quot;Java 8 Nashorn JavaScript&quot;&gt;&lt;/a&gt;Java 8 Nash
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java8Optional类</title>
    <link href="http://iwantjingjing.com/2021/06/06/java8Optional%E7%B1%BB/"/>
    <id>http://iwantjingjing.com/2021/06/06/java8Optional%E7%B1%BB/</id>
    <published>2021-06-06T09:58:48.000Z</published>
    <updated>2021-06-06T10:05:27.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java8-Optional类"><a href="#java8-Optional类" class="headerlink" title="java8 Optional类"></a>java8 Optional类</h1><p>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p><p>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p><p>Optional 类的引入很好的解决空指针异常。</p><h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><p>以下是一个 java.util.Optional<T> 类的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final class Optional&lt;T&gt;</span><br><span class="line">extends Object</span><br></pre></td></tr></table></figure><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p>|—|—|<br>|序号    |方法 &amp; 描述|<br>| 1|    static <T> Optional<T> empty() 返回空的 Optional 实例。 |<br>|2 | boolean equals(Object obj)判断其他对象是否等于 Optional。 |<br>|3 | Optional<T> filter(Predicate&lt;? super <T> predicate)如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。|<br>|4 |<U> Optional<U> flatMap(Function&lt;? super T,Optional<U>&gt; mapper)如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional |<br>| 5| T get()如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException|<br>|6 |int hashCode()返回存在值的哈希码，如果值不存在 返回 0。 |<br>|7 |void ifPresent(Consumer&lt;? super T&gt; consumer)如果值存在则使用该值调用 consumer , 否则不做任何事情。 |<br>| 8| boolean isPresent()如果值存在则方法会返回true，否则返回 false。|<br>|9 | <U>Optional<U> map(Function&lt;? super T,? extends U&gt; mapper)如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional。|<br>|10 | static <T> Optional<T> of(T value)返回一个指定非null值的Optional。|<br>|11 | static <T> Optional<T> ofNullable(T value)如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。|<br>|12 | T orElse(T other)如果存在该值，返回值， 否则返回 other。 |<br>|13 | T orElseGet(Supplier&lt;? extends T&gt; other)如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。|<br>|14 |<X extends Throwable> T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常 |<br>|15 |String toString()返回一个Optional的非空字符串，用来调试 |</p><blockquote><p>注意： 这些方法是从 java.lang.Object 类继承来的。</p></blockquote><h2 id="Optional-实例"><a href="#Optional-实例" class="headerlink" title="Optional 实例"></a>Optional 实例</h2><blockquote><p>Java8Tester.java 文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Optional;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">   </span><br><span class="line">      Java8Tester java8Tester &#x3D; new Java8Tester();</span><br><span class="line">      Integer value1 &#x3D; null;</span><br><span class="line">      Integer value2 &#x3D; new Integer(10);</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F; Optional.ofNullable - 允许传递为 null 参数</span><br><span class="line">      Optional&lt;Integer&gt; a &#x3D; Optional.ofNullable(value1);</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F; Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException</span><br><span class="line">      Optional&lt;Integer&gt; b &#x3D; Optional.of(value2);</span><br><span class="line">      System.out.println(java8Tester.sum(a,b));</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   public Integer sum(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b)&#123;</span><br><span class="line">    </span><br><span class="line">      &#x2F;&#x2F; Optional.isPresent - 判断值是否存在</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;第一个参数值存在: &quot; + a.isPresent());</span><br><span class="line">      System.out.println(&quot;第二个参数值存在: &quot; + b.isPresent());</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F; Optional.orElse - 如果值存在，返回它，否则返回默认值</span><br><span class="line">      Integer value1 &#x3D; a.orElse(new Integer(0));</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F;Optional.get - 获取值，值需要存在</span><br><span class="line">      Integer value2 &#x3D; b.get();</span><br><span class="line">      return value1 + value2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上脚本，输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ javac Java8Tester.java </span><br><span class="line">$ java Java8Tester</span><br><span class="line">第一个参数值存在: false</span><br><span class="line">第二个参数值存在: true</span><br><span class="line">10</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java8-Optional类&quot;&gt;&lt;a href=&quot;#java8-Optional类&quot; class=&quot;headerlink&quot; title=&quot;java8 Optional类&quot;&gt;&lt;/a&gt;java8 Optional类&lt;/h1&gt;&lt;p&gt;Optional 类是一个可以为nu
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java8Stream</title>
    <link href="http://iwantjingjing.com/2021/06/06/java8Stream/"/>
    <id>http://iwantjingjing.com/2021/06/06/java8Stream/</id>
    <published>2021-06-06T09:49:10.000Z</published>
    <updated>2021-06-06T09:57:08.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-8-Stream"><a href="#Java-8-Stream" class="headerlink" title="Java 8 Stream"></a>Java 8 Stream</h1><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p><p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p><p>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p><p>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br><span class="line">| stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|</span><br><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br></pre></td></tr></table></figure><p>以上的流程转换为 Java 代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; transactionsIds &#x3D; </span><br><span class="line">widgets.stream()</span><br><span class="line">             .filter(b -&gt; b.getColor() &#x3D;&#x3D; RED)</span><br><span class="line">             .sorted((x,y) -&gt; x.getWeight() - y.getWeight())</span><br><span class="line">             .mapToInt(Widget::getWeight)</span><br><span class="line">             .sum();</span><br></pre></td></tr></table></figure><h2 id="什么是-Stream？"><a href="#什么是-Stream？" class="headerlink" title="什么是 Stream？"></a>什么是 Stream？</h2><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p><ul><li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li><li><strong>数据源</strong> 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li><li><strong>聚合操作</strong> 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li></ul><p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p><ul><li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li><li><strong>内部迭代</strong>： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li></ul><h2 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h2><p>在 Java 8 中, 集合接口有两个方法来生成流：</p><ul><li>stream() − 为集合创建串行流。</li><li>parallelStream() − 为集合创建并行流。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings &#x3D; Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">List&lt;String&gt; filtered &#x3D; strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li></ul><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>Stream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random &#x3D; new Random();</span><br><span class="line">random.ints().limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers &#x3D; Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">&#x2F;&#x2F; 获取对应的平方数</span><br><span class="line">List&lt;Integer&gt; squaresList &#x3D; numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>filter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings &#x3D; Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">&#x2F;&#x2F; 获取空字符串的数量</span><br><span class="line">long count &#x3D; strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure><h2 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h2><p>limit 方法用于获取指定数量的流。 以下代码片段使用 limit 方法打印出 10 条数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random &#x3D; new Random();</span><br><span class="line">random.ints().limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h2><p>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random &#x3D; new Random();</span><br><span class="line">random.ints().limit(10).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="并行（parallel）程序"><a href="#并行（parallel）程序" class="headerlink" title="并行（parallel）程序"></a>并行（parallel）程序</h2><p>parallelStream 是流并行处理程序的代替方法。以下实例我们使用 parallelStream 来输出空字符串的数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings &#x3D; Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">&#x2F;&#x2F; 获取空字符串的数量</span><br><span class="line">long count &#x3D; strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure><p>我们可以很容易的在顺序运行和并行直接切换。</p><h2 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h2><p>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings &#x3D; Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">List&lt;String&gt; filtered &#x3D; strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(&quot;筛选列表: &quot; + filtered);</span><br><span class="line">String mergedString &#x3D; strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br></pre></td></tr></table></figure><h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><p>另外，一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers &#x3D; Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">IntSummaryStatistics stats &#x3D; numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line"> </span><br><span class="line">System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());</span><br><span class="line">System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());</span><br><span class="line">System.out.println(&quot;所有数之和 : &quot; + stats.getSum());</span><br><span class="line">System.out.println(&quot;平均数 : &quot; + stats.getAverage());</span><br></pre></td></tr></table></figure><h2 id="Stream-完整实例"><a href="#Stream-完整实例" class="headerlink" title="Stream 完整实例"></a>Stream 完整实例</h2><p>将以下代码放入 Java8Tester.java 文件中：</p><blockquote><p>Java8Tester.java 文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.IntSummaryStatistics;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line">import java.util.Map;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      System.out.println(&quot;使用 Java 7: &quot;);</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F; 计算空字符串</span><br><span class="line">      List&lt;String&gt; strings &#x3D; Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">      System.out.println(&quot;列表: &quot; +strings);</span><br><span class="line">      long count &#x3D; getCountEmptyStringUsingJava7(strings);</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;空字符数量为: &quot; + count);</span><br><span class="line">      count &#x3D; getCountLength3UsingJava7(strings);</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;字符串长度为 3 的数量为: &quot; + count);</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F; 删除空字符串</span><br><span class="line">      List&lt;String&gt; filtered &#x3D; deleteEmptyStringsUsingJava7(strings);</span><br><span class="line">      System.out.println(&quot;筛选后的列表: &quot; + filtered);</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F; 删除空字符串，并使用逗号把它们合并起来</span><br><span class="line">      String mergedString &#x3D; getMergedStringUsingJava7(strings,&quot;, &quot;);</span><br><span class="line">      System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br><span class="line">      List&lt;Integer&gt; numbers &#x3D; Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F; 获取列表元素平方数</span><br><span class="line">      List&lt;Integer&gt; squaresList &#x3D; getSquares(numbers);</span><br><span class="line">      System.out.println(&quot;平方数列表: &quot; + squaresList);</span><br><span class="line">      List&lt;Integer&gt; integers &#x3D; Arrays.asList(1,2,13,4,15,6,17,8,19);</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;列表: &quot; +integers);</span><br><span class="line">      System.out.println(&quot;列表中最大的数 : &quot; + getMax(integers));</span><br><span class="line">      System.out.println(&quot;列表中最小的数 : &quot; + getMin(integers));</span><br><span class="line">      System.out.println(&quot;所有数之和 : &quot; + getSum(integers));</span><br><span class="line">      System.out.println(&quot;平均数 : &quot; + getAverage(integers));</span><br><span class="line">      System.out.println(&quot;随机数: &quot;);</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F; 输出10个随机数</span><br><span class="line">      Random random &#x3D; new Random();</span><br><span class="line">        </span><br><span class="line">      for(int i&#x3D;0; i &lt; 10; i++)&#123;</span><br><span class="line">         System.out.println(random.nextInt());</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;使用 Java 8: &quot;);</span><br><span class="line">      System.out.println(&quot;列表: &quot; +strings);</span><br><span class="line">        </span><br><span class="line">      count &#x3D; strings.stream().filter(string-&gt;string.isEmpty()).count();</span><br><span class="line">      System.out.println(&quot;空字符串数量为: &quot; + count);</span><br><span class="line">        </span><br><span class="line">      count &#x3D; strings.stream().filter(string -&gt; string.length() &#x3D;&#x3D; 3).count();</span><br><span class="line">      System.out.println(&quot;字符串长度为 3 的数量为: &quot; + count);</span><br><span class="line">        </span><br><span class="line">      filtered &#x3D; strings.stream().filter(string -&gt;!string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">      System.out.println(&quot;筛选后的列表: &quot; + filtered);</span><br><span class="line">        </span><br><span class="line">      mergedString &#x3D; strings.stream().filter(string -&gt;!string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">      System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br><span class="line">        </span><br><span class="line">      squaresList &#x3D; numbers.stream().map( i -&gt;i*i).distinct().collect(Collectors.toList());</span><br><span class="line">      System.out.println(&quot;Squares List: &quot; + squaresList);</span><br><span class="line">      System.out.println(&quot;列表: &quot; +integers);</span><br><span class="line">        </span><br><span class="line">      IntSummaryStatistics stats &#x3D; integers.stream().mapToInt((x) -&gt;x).summaryStatistics();</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());</span><br><span class="line">      System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());</span><br><span class="line">      System.out.println(&quot;所有数之和 : &quot; + stats.getSum());</span><br><span class="line">      System.out.println(&quot;平均数 : &quot; + stats.getAverage());</span><br><span class="line">      System.out.println(&quot;随机数: &quot;);</span><br><span class="line">        </span><br><span class="line">      random.ints().limit(10).sorted().forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F; 并行处理</span><br><span class="line">      count &#x3D; strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br><span class="line">      System.out.println(&quot;空字符串的数量为: &quot; + count);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getCountEmptyStringUsingJava7(List&lt;String&gt; strings)&#123;</span><br><span class="line">      int count &#x3D; 0;</span><br><span class="line">        </span><br><span class="line">      for(String string: strings)&#123;</span><br><span class="line">        </span><br><span class="line">         if(string.isEmpty())&#123;</span><br><span class="line">            count++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return count;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getCountLength3UsingJava7(List&lt;String&gt; strings)&#123;</span><br><span class="line">      int count &#x3D; 0;</span><br><span class="line">        </span><br><span class="line">      for(String string: strings)&#123;</span><br><span class="line">        </span><br><span class="line">         if(string.length() &#x3D;&#x3D; 3)&#123;</span><br><span class="line">            count++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return count;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static List&lt;String&gt; deleteEmptyStringsUsingJava7(List&lt;String&gt; strings)&#123;</span><br><span class="line">      List&lt;String&gt; filteredList &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">      for(String string: strings)&#123;</span><br><span class="line">        </span><br><span class="line">         if(!string.isEmpty())&#123;</span><br><span class="line">             filteredList.add(string);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return filteredList;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static String getMergedStringUsingJava7(List&lt;String&gt; strings, String separator)&#123;</span><br><span class="line">      StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line">        </span><br><span class="line">      for(String string: strings)&#123;</span><br><span class="line">        </span><br><span class="line">         if(!string.isEmpty())&#123;</span><br><span class="line">            stringBuilder.append(string);</span><br><span class="line">            stringBuilder.append(separator);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String mergedString &#x3D; stringBuilder.toString();</span><br><span class="line">      return mergedString.substring(0, mergedString.length()-2);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static List&lt;Integer&gt; getSquares(List&lt;Integer&gt; numbers)&#123;</span><br><span class="line">      List&lt;Integer&gt; squaresList &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">      for(Integer number: numbers)&#123;</span><br><span class="line">         Integer square &#x3D; new Integer(number.intValue() * number.intValue());</span><br><span class="line">            </span><br><span class="line">         if(!squaresList.contains(square))&#123;</span><br><span class="line">            squaresList.add(square);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return squaresList;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getMax(List&lt;Integer&gt; numbers)&#123;</span><br><span class="line">      int max &#x3D; numbers.get(0);</span><br><span class="line">        </span><br><span class="line">      for(int i&#x3D;1;i &lt; numbers.size();i++)&#123;</span><br><span class="line">        </span><br><span class="line">         Integer number &#x3D; numbers.get(i);</span><br><span class="line">            </span><br><span class="line">         if(number.intValue() &gt; max)&#123;</span><br><span class="line">            max &#x3D; number.intValue();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return max;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getMin(List&lt;Integer&gt; numbers)&#123;</span><br><span class="line">      int min &#x3D; numbers.get(0);</span><br><span class="line">        </span><br><span class="line">      for(int i&#x3D;1;i &lt; numbers.size();i++)&#123;</span><br><span class="line">         Integer number &#x3D; numbers.get(i);</span><br><span class="line">        </span><br><span class="line">         if(number.intValue() &lt; min)&#123;</span><br><span class="line">            min &#x3D; number.intValue();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return min;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getSum(List numbers)&#123;</span><br><span class="line">      int sum &#x3D; (int)(numbers.get(0));</span><br><span class="line">        </span><br><span class="line">      for(int i&#x3D;1;i &lt; numbers.size();i++)&#123;</span><br><span class="line">         sum +&#x3D; (int)numbers.get(i);</span><br><span class="line">      &#125;</span><br><span class="line">      return sum;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getAverage(List&lt;Integer&gt; numbers)&#123;</span><br><span class="line">      return getSum(numbers) &#x2F; numbers.size();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上脚本，输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">$ javac Java8Tester.java </span><br><span class="line">$ java Java8Tester</span><br><span class="line">使用 Java 7: </span><br><span class="line">列表: [abc, , bc, efg, abcd, , jkl]</span><br><span class="line">空字符数量为: 2</span><br><span class="line">字符串长度为 3 的数量为: 3</span><br><span class="line">筛选后的列表: [abc, bc, efg, abcd, jkl]</span><br><span class="line">合并字符串: abc, bc, efg, abcd, jkl</span><br><span class="line">平方数列表: [9, 4, 49, 25]</span><br><span class="line">列表: [1, 2, 13, 4, 15, 6, 17, 8, 19]</span><br><span class="line">列表中最大的数 : 19</span><br><span class="line">列表中最小的数 : 1</span><br><span class="line">所有数之和 : 85</span><br><span class="line">平均数 : 9</span><br><span class="line">随机数: </span><br><span class="line">-393170844</span><br><span class="line">-963842252</span><br><span class="line">447036679</span><br><span class="line">-1043163142</span><br><span class="line">-881079698</span><br><span class="line">221586850</span><br><span class="line">-1101570113</span><br><span class="line">576190039</span><br><span class="line">-1045184578</span><br><span class="line">1647841045</span><br><span class="line">使用 Java 8: </span><br><span class="line">列表: [abc, , bc, efg, abcd, , jkl]</span><br><span class="line">空字符串数量为: 2</span><br><span class="line">字符串长度为 3 的数量为: 3</span><br><span class="line">筛选后的列表: [abc, bc, efg, abcd, jkl]</span><br><span class="line">合并字符串: abc, bc, efg, abcd, jkl</span><br><span class="line">Squares List: [9, 4, 49, 25]</span><br><span class="line">列表: [1, 2, 13, 4, 15, 6, 17, 8, 19]</span><br><span class="line">列表中最大的数 : 19</span><br><span class="line">列表中最小的数 : 1</span><br><span class="line">所有数之和 : 85</span><br><span class="line">平均数 : 9.444444444444445</span><br><span class="line">随机数: </span><br><span class="line">-1743813696</span><br><span class="line">-1301974944</span><br><span class="line">-1299484995</span><br><span class="line">-779981186</span><br><span class="line">136544902</span><br><span class="line">555792023</span><br><span class="line">1243315896</span><br><span class="line">1264920849</span><br><span class="line">1472077135</span><br><span class="line">1706423674</span><br><span class="line">空字符串的数量为: 2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-8-Stream&quot;&gt;&lt;a href=&quot;#Java-8-Stream&quot; class=&quot;headerlink&quot; title=&quot;Java 8 Stream&quot;&gt;&lt;/a&gt;Java 8 Stream&lt;/h1&gt;&lt;p&gt;Java 8 API添加了一个新的抽象称为流Stre
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java8默认方法</title>
    <link href="http://iwantjingjing.com/2021/06/06/java8%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/"/>
    <id>http://iwantjingjing.com/2021/06/06/java8%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/</id>
    <published>2021-06-06T09:03:49.000Z</published>
    <updated>2021-06-06T09:46:22.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java8默认方法"><a href="#java8默认方法" class="headerlink" title="java8默认方法"></a>java8默认方法</h1><p>Java 8 新增了接口的默认方法。</p><p>简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。</p><p>我们只需在方法名前面加个 default 关键字即可实现默认方法。</p><blockquote><p>为什么要有这个特性？</p><p>首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的 java 8 之前的集合框架没有 foreach 方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。</p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>默认方法语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Vehicle &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个默认方法</p><p>一个接口有默认方法，考虑这样的情况，一个类实现了多个接口，且这些接口有相同的默认方法，以下实例说明了这种情况的解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface Vehicle &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public interface FourWheeler &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆四轮车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个解决方案是创建自己的默认方法，来覆盖重写接口的默认方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements Vehicle, FourWheeler &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆四轮汽车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种解决方案可以使用 super 来调用指定接口的默认方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements Vehicle, FourWheeler &#123;</span><br><span class="line">   public void print()&#123;</span><br><span class="line">      Vehicle.super.print();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态默认方法"><a href="#静态默认方法" class="headerlink" title="静态默认方法"></a>静态默认方法</h2><p>Java 8 的另一个特性是接口可以声明（并且可以提供实现）静态方法。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Vehicle &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F; 静态方法</span><br><span class="line">   static void blowHorn()&#123;</span><br><span class="line">      System.out.println(&quot;按喇叭!!!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认方法实例"><a href="#默认方法实例" class="headerlink" title="默认方法实例"></a>默认方法实例</h2><p>我们可以通过以下代码来了解关于默认方法的使用，可以将代码放入 Java8Tester.java 文件中：</p><blockquote><p>Java8Tester.java 文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      Vehicle vehicle &#x3D; new Car();</span><br><span class="line">      vehicle.print();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">interface Vehicle &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   static void blowHorn()&#123;</span><br><span class="line">      System.out.println(&quot;按喇叭!!!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">interface FourWheeler &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆四轮车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Car implements Vehicle, FourWheeler &#123;</span><br><span class="line">   public void print()&#123;</span><br><span class="line">      Vehicle.super.print();</span><br><span class="line">      FourWheeler.super.print();</span><br><span class="line">      Vehicle.blowHorn();</span><br><span class="line">      System.out.println(&quot;我是一辆汽车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上脚本，输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ javac Java8Tester.java </span><br><span class="line">$ java Java8Tester</span><br><span class="line">我是一辆车!</span><br><span class="line">我是一辆四轮车!</span><br><span class="line">按喇叭!!!</span><br><span class="line">我是一辆汽车!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java8默认方法&quot;&gt;&lt;a href=&quot;#java8默认方法&quot; class=&quot;headerlink&quot; title=&quot;java8默认方法&quot;&gt;&lt;/a&gt;java8默认方法&lt;/h1&gt;&lt;p&gt;Java 8 新增了接口的默认方法。&lt;/p&gt;
&lt;p&gt;简单说，默认方法就是接口可以有实
      
    
    </summary>
    
    
      <category term="java8" scheme="http://iwantjingjing.com/categories/java8/"/>
    
    
      <category term="java8" scheme="http://iwantjingjing.com/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>Java8函数式接口</title>
    <link href="http://iwantjingjing.com/2021/06/06/Java8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    <id>http://iwantjingjing.com/2021/06/06/Java8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/</id>
    <published>2021-06-06T08:39:38.000Z</published>
    <updated>2021-06-06T09:02:41.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-8-函数式接口"><a href="#Java-8-函数式接口" class="headerlink" title="Java 8 函数式接口"></a>Java 8 函数式接口</h1><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p><p>函数式接口可以被隐式转换为 lambda 表达式。</p><p>Lambda 表达式和方法引用（实际上也可认为是Lambda表达式）上。</p><p>如定义了一个函数式接口如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface GreetingService </span><br><span class="line">&#123;</span><br><span class="line">    void sayMessage(String message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就可以使用Lambda表达式来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GreetingService greetService1 &#x3D; message -&gt; System.out.println(&quot;Hello &quot; + message);</span><br></pre></td></tr></table></figure><p>函数式接口可以对现有的函数友好地支持 lambda。</p><p>JDK 1.8 之前已有的函数式接口:</p><ul><li><p>java.lang.Runnable</p></li><li><p>java.util.concurrent.Callable</p></li><li><p>java.security.PrivilegedAction</p></li><li><p>java.util.Comparator</p></li><li><p>java.io.FileFilter</p></li><li><p>java.nio.file.PathMatcher</p></li><li><p>java.lang.reflect.InvocationHandler</p></li><li><p>java.beans.PropertyChangeListener</p></li><li><p>java.awt.event.ActionListener</p></li><li><p>javax.swing.event.ChangeListener</p></li></ul><p>JDK 1.8 新增加的函数接口：</p><ul><li>java.util.function</li></ul><p>java.util.function 它包含了很多类，用来支持 Java的 函数式编程，该包中的函数式接口有：</p><table><thead><tr><th>序号</th><th>接口 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td>BiConsumer&lt;T,U&gt;代表了一个接受两个输入参数的操作，并且不返回任何结果</td></tr><tr><td>2</td><td>BiFunction&lt;T,U,R&gt;代表了一个接受两个输入参数的方法，并且返回一个结果</td></tr><tr><td>3</td><td>BinaryOperator<T>代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果</td></tr><tr><td>4</td><td>BiPredicate&lt;T,U&gt;代表了一个两个参数的boolean值方法</td></tr><tr><td>5</td><td>BooleanSupplier代表了boolean值结果的提供</td></tr><tr><td>6</td><td>Consumer<T>代表了接受一个输入参数并且无返回的操作</td></tr><tr><td>7</td><td>DoubleBinaryOperator代表了作用于两个double值操作符的操作，并且返回了一个double值的结果。</td></tr><tr><td>8</td><td>DoubleConsumer代表一个接受double值参数的操作，并且不返回结果。</td></tr><tr><td>9</td><td>DoubleFunction<R>代表接受一个double值参数的方法，并且返回结果</td></tr><tr><td>10</td><td>DoublePredicate代表一个拥有double值参数的boolean值方法</td></tr><tr><td>11</td><td>DoubleSupplier代表一个double值结构的提供方</td></tr><tr><td>12</td><td>DoubleToIntFunction接受一个double类型输入，返回一个int类型结果。</td></tr><tr><td>13</td><td>DoubleToLongFunction接受一个double类型输入，返回一个long类型结果</td></tr><tr><td>14</td><td>DoubleUnaryOperator接受一个参数同为类型double,返回值类型也为double 。</td></tr><tr><td>15</td><td>Function&lt;T,R&gt;接受一个输入参数，返回一个结果。</td></tr><tr><td>16</td><td>IntBinaryOperator接受两个参数同为类型int,返回值类型也为int 。</td></tr><tr><td>17</td><td>IntConsumer接受一个int类型的输入参数，无返回值 。</td></tr><tr><td>18</td><td>IntFunction<R>接受一个int类型输入参数，返回一个结果 。</td></tr><tr><td>19</td><td>IntPredicate：接受一个int输入参数，返回一个布尔值的结果。</td></tr><tr><td>20</td><td>IntSupplier无参数，返回一个int类型结果。</td></tr><tr><td>21</td><td>IntToDoubleFunction接受一个int类型输入，返回一个double类型结果 。</td></tr><tr><td>22</td><td>IntToLongFunction接受一个int类型输入，返回一个long类型结果。</td></tr><tr><td>23</td><td>IntUnaryOperator接受一个参数同为类型int,返回值类型也为int 。</td></tr><tr><td>24</td><td>LongBinaryOperator接受两个参数同为类型long,返回值类型也为long。</td></tr><tr><td>25</td><td>LongConsumer接受一个long类型的输入参数，无返回值。</td></tr><tr><td>26</td><td>LongFunction<R>接受一个long类型输入参数，返回一个结果。</td></tr><tr><td>27</td><td>LongPredicateR接受一个long输入参数，返回一个布尔值类型结果。</td></tr><tr><td>28</td><td>LongSupplier无参数，返回一个结果long类型的值。</td></tr><tr><td>29</td><td>LongToDoubleFunction接受一个long类型输入，返回一个double类型结果。</td></tr><tr><td>30</td><td>LongToIntFunction接受一个long类型输入，返回一个int类型结果。</td></tr><tr><td>31</td><td>LongUnaryOperator接受一个参数同为类型long,返回值类型也为long。</td></tr><tr><td>32</td><td>ObjDoubleConsumer<T>接受一个object类型和一个double类型的输入参数，无返回值。</td></tr><tr><td>33</td><td>ObjIntConsumer<T>接受一个object类型和一个int类型的输入参数，无返回值。</td></tr><tr><td>34</td><td>ObjLongConsumer<T>接受一个object类型和一个long类型的输入参数，无返回值。</td></tr><tr><td>35</td><td>Predicate<T>接受一个输入参数，返回一个布尔值结果。</td></tr><tr><td>36</td><td>Supplier<T>无参数，返回一个结果。</td></tr><tr><td>37</td><td>ToDoubleBiFunction&lt;T,U&gt;接受两个输入参数，返回一个double类型结果</td></tr><tr><td>38</td><td>ToDoubleFunction<T>接受一个输入参数，返回一个double类型结果</td></tr><tr><td>39</td><td>ToIntBiFunction&lt;T,U&gt;接受两个输入参数，返回一个int类型结果。</td></tr><tr><td>40</td><td>ToIntFunction<T>接受一个输入参数，返回一个int类型结果。</td></tr><tr><td>41</td><td>ToLongBiFunction&lt;T,U&gt;接受两个输入参数，返回一个long类型结果。</td></tr><tr><td>42</td><td>ToLongFunction<T>接受一个输入参数，返回一个long类型结果。</td></tr><tr><td>43</td><td>UnaryOperator<T>接受一个参数为类型T,返回值类型也为T。</td></tr></tbody></table><h2 id="函数式接口实例"><a href="#函数式接口实例" class="headerlink" title="函数式接口实例"></a>函数式接口实例</h2><p>Predicate <T> 接口是一个函数式接口，它接受一个输入参数 T，返回一个布尔值结果。</p><p>该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。</p><p>该接口用于测试对象是 true 或 false。</p><p>我们可以通过以下实例（Java8Tester.java）来了解函数式接口 Predicate <T> 的使用：</p><p><code>Java8Tester.java 文件</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.function.Predicate;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      List&lt;Integer&gt; list &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F; Predicate&lt;Integer&gt; predicate &#x3D; n -&gt; true</span><br><span class="line">      &#x2F;&#x2F; n 是一个参数传递到 Predicate 接口的 test 方法</span><br><span class="line">      &#x2F;&#x2F; n 如果存在则 test 方法返回 true</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;输出所有数据:&quot;);</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F; 传递参数 n</span><br><span class="line">      eval(list, n-&gt;true);</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F; Predicate&lt;Integer&gt; predicate1 &#x3D; n -&gt; n%2 &#x3D;&#x3D; 0</span><br><span class="line">      &#x2F;&#x2F; n 是一个参数传递到 Predicate 接口的 test 方法</span><br><span class="line">      &#x2F;&#x2F; 如果 n%2 为 0 test 方法返回 true</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;输出所有偶数:&quot;);</span><br><span class="line">      eval(list, n-&gt; n%2 &#x3D;&#x3D; 0 );</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F; Predicate&lt;Integer&gt; predicate2 &#x3D; n -&gt; n &gt; 3</span><br><span class="line">      &#x2F;&#x2F; n 是一个参数传递到 Predicate 接口的 test 方法</span><br><span class="line">      &#x2F;&#x2F; 如果 n 大于 3 test 方法返回 true</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;输出大于 3 的所有数字:&quot;);</span><br><span class="line">      eval(list, n-&gt; n &gt; 3 );</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   public static void eval(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) &#123;</span><br><span class="line">      for(Integer n: list) &#123;</span><br><span class="line">        </span><br><span class="line">         if(predicate.test(n)) &#123;</span><br><span class="line">            System.out.println(n + &quot; &quot;);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上脚本，输出结果为：</p><figure class="highlight plain"><figcaption><span>javac Java8Tester.java </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ java Java8Tester</span><br><span class="line">输出所有数据:</span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">4 </span><br><span class="line">5 </span><br><span class="line">6 </span><br><span class="line">7 </span><br><span class="line">8 </span><br><span class="line">9 </span><br><span class="line">输出所有偶数:</span><br><span class="line">2 </span><br><span class="line">4 </span><br><span class="line">6 </span><br><span class="line">8 </span><br><span class="line">输出大于 3 的所有数字:</span><br><span class="line">4 </span><br><span class="line">5 </span><br><span class="line">6 </span><br><span class="line">7 </span><br><span class="line">8 </span><br><span class="line">9</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-8-函数式接口&quot;&gt;&lt;a href=&quot;#Java-8-函数式接口&quot; class=&quot;headerlink&quot; title=&quot;Java 8 函数式接口&quot;&gt;&lt;/a&gt;Java 8 函数式接口&lt;/h1&gt;&lt;p&gt;函数式接口(Functional Interface)就是一
      
    
    </summary>
    
    
      <category term="java8" scheme="http://iwantjingjing.com/categories/java8/"/>
    
    
      <category term="java8" scheme="http://iwantjingjing.com/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>Java8方法引用</title>
    <link href="http://iwantjingjing.com/2021/06/06/Java8%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
    <id>http://iwantjingjing.com/2021/06/06/Java8%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</id>
    <published>2021-06-06T08:31:50.000Z</published>
    <updated>2021-06-06T08:38:35.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java8方法引用"><a href="#Java8方法引用" class="headerlink" title="Java8方法引用"></a>Java8方法引用</h1><p>方法引用通过方法的名字来指向一个方法。</p><p>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p><p>方法引用使用一对冒号 :: 。</p><p>下面，我们在 Car 类中定义了 4 个方法作为例子来区分 Java 中 4 种不同方法的引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.runoob.main;</span><br><span class="line"></span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface Supplier&lt;T&gt; &#123;</span><br><span class="line">    T get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car &#123;</span><br><span class="line">    &#x2F;&#x2F;Supplier是jdk1.8的接口，这里和lamda一起使用了</span><br><span class="line">    public static Car create(final Supplier&lt;Car&gt; supplier) &#123;</span><br><span class="line">        return supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void collide(final Car car) &#123;</span><br><span class="line">        System.out.println(&quot;Collided &quot; + car.toString());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void follow(final Car another) &#123;</span><br><span class="line">        System.out.println(&quot;Following the &quot; + another.toString());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void repair() &#123;</span><br><span class="line">        System.out.println(&quot;Repaired &quot; + this.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造器引用：它的语法是Class::new，或者更一般的Class&lt; T &gt;::new实例如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final Car car &#x3D; Car.create( Car::new );</span><br><span class="line">final List&lt; Car &gt; cars &#x3D; Arrays.asList( car );</span><br></pre></td></tr></table></figure><ul><li>静态方法引用：它的语法是Class::static_method，实例如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.forEach( Car::collide );</span><br></pre></td></tr></table></figure><ul><li>特定类的任意对象的方法引用：它的语法是Class::method实例如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.forEach( Car::repair );</span><br></pre></td></tr></table></figure></li><li>特定对象的方法引用：它的语法是instance::method实例如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final Car police &#x3D; Car.create( Car::new );</span><br><span class="line">cars.forEach( police::follow );</span><br></pre></td></tr></table></figure><h2 id="方法引用实例"><a href="#方法引用实例" class="headerlink" title="方法引用实例"></a>方法引用实例</h2><p>在 Java8Tester.java 文件输入以下代码：<br><code>Java8Tester.java 文件</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.List;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      List&lt;String&gt; names &#x3D; new ArrayList();</span><br><span class="line">        </span><br><span class="line">      names.add(&quot;Google&quot;);</span><br><span class="line">      names.add(&quot;Runoob&quot;);</span><br><span class="line">      names.add(&quot;Taobao&quot;);</span><br><span class="line">      names.add(&quot;Baidu&quot;);</span><br><span class="line">      names.add(&quot;Sina&quot;);</span><br><span class="line">        </span><br><span class="line">      names.forEach(System.out::println);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例中我们将 System.out::println 方法作为静态方法来引用。<br>执行以上脚本，输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ javac Java8Tester.java </span><br><span class="line">$ java Java8Tester</span><br><span class="line">Google</span><br><span class="line">Runoob</span><br><span class="line">Taobao</span><br><span class="line">Baidu</span><br><span class="line">Sina</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java8方法引用&quot;&gt;&lt;a href=&quot;#Java8方法引用&quot; class=&quot;headerlink&quot; title=&quot;Java8方法引用&quot;&gt;&lt;/a&gt;Java8方法引用&lt;/h1&gt;&lt;p&gt;方法引用通过方法的名字来指向一个方法。&lt;/p&gt;
&lt;p&gt;方法引用可以使语言的构造更紧凑
      
    
    </summary>
    
    
      <category term="java" scheme="http://iwantjingjing.com/categories/java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Lambda表达式</title>
    <link href="http://iwantjingjing.com/2021/06/06/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://iwantjingjing.com/2021/06/06/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-06-06T08:11:18.000Z</published>
    <updated>2021-06-06T08:29:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-Lambda-表达式"><a href="#Java-Lambda-表达式" class="headerlink" title="Java Lambda 表达式"></a>Java Lambda 表达式</h1><ul><li><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</p></li><li><p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p></li><li><p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p></li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>lambda 表达式的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure><p>以下是lambda表达式的重要特征:</p><ul><li><p><strong>可选类型声明</strong>：不需要声明参数类型，编译器可以统一识别参数值。</p></li><li><p><strong>可选的参数圆括号</strong>：一个参数无需定义圆括号，但多个参数需要定义圆括号。</p></li><li><p><strong>可选的大括号</strong>：如果主体包含了一个语句，就不需要使用大括号。</p></li><li><p><strong>可选的返回关键字</strong>：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</p></li></ul><h2 id="Lambda-表达式实例"><a href="#Lambda-表达式实例" class="headerlink" title="Lambda 表达式实例"></a>Lambda 表达式实例</h2><p>Lambda 表达式的简单例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 不需要参数,返回值为 5  </span><br><span class="line">() -&gt; 5  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 2. 接收一个参数(数字类型),返回其2倍的值  </span><br><span class="line">x -&gt; 2 * x  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 3. 接受2个参数(数字),并返回他们的差值  </span><br><span class="line">(x, y) -&gt; x – y  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 4. 接收2个int型整数,返回他们的和  </span><br><span class="line">(int x, int y) -&gt; x + y  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure><p>在 Java8Tester.java 文件输入以下代码：<br><code>Java8Tester.java 文件</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      Java8Tester tester &#x3D; new Java8Tester();</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F; 类型声明</span><br><span class="line">      MathOperation addition &#x3D; (int a, int b) -&gt; a + b;</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F; 不用类型声明</span><br><span class="line">      MathOperation subtraction &#x3D; (a, b) -&gt; a - b;</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F; 大括号中的返回语句</span><br><span class="line">      MathOperation multiplication &#x3D; (int a, int b) -&gt; &#123; return a * b; &#125;;</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F; 没有大括号及返回语句</span><br><span class="line">      MathOperation division &#x3D; (int a, int b) -&gt; a &#x2F; b;</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;10 + 5 &#x3D; &quot; + tester.operate(10, 5, addition));</span><br><span class="line">      System.out.println(&quot;10 - 5 &#x3D; &quot; + tester.operate(10, 5, subtraction));</span><br><span class="line">      System.out.println(&quot;10 x 5 &#x3D; &quot; + tester.operate(10, 5, multiplication));</span><br><span class="line">      System.out.println(&quot;10 &#x2F; 5 &#x3D; &quot; + tester.operate(10, 5, division));</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F; 不用括号</span><br><span class="line">      GreetingService greetService1 &#x3D; message -&gt;</span><br><span class="line">      System.out.println(&quot;Hello &quot; + message);</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F; 用括号</span><br><span class="line">      GreetingService greetService2 &#x3D; (message) -&gt;</span><br><span class="line">      System.out.println(&quot;Hello &quot; + message);</span><br><span class="line">        </span><br><span class="line">      greetService1.sayMessage(&quot;Runoob&quot;);</span><br><span class="line">      greetService2.sayMessage(&quot;Google&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   interface MathOperation &#123;</span><br><span class="line">      int operation(int a, int b);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   interface GreetingService &#123;</span><br><span class="line">      void sayMessage(String message);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private int operate(int a, int b, MathOperation mathOperation)&#123;</span><br><span class="line">      return mathOperation.operation(a, b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上脚本，输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ javac Java8Tester.java </span><br><span class="line">$ java Java8Tester</span><br><span class="line">10 + 5 &#x3D; 15</span><br><span class="line">10 - 5 &#x3D; 5</span><br><span class="line">10 x 5 &#x3D; 50</span><br><span class="line">10 &#x2F; 5 &#x3D; 2</span><br><span class="line">Hello Runoob</span><br><span class="line">Hello Google</span><br></pre></td></tr></table></figure><p>使用 Lambda 表达式需要注意以下两点：</p><ul><li>Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的Lambda表达式来定义MathOperation接口的方法。然后我们定义了sayMessage的执行。</li><li>Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</li></ul><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</p><p>在 Java8Tester.java 文件输入以下代码：<br><code>Java8Tester.java 文件</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Java8Tester &#123;</span><br><span class="line"> </span><br><span class="line">   final static String salutation &#x3D; &quot;Hello! &quot;;</span><br><span class="line">   </span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      GreetingService greetService1 &#x3D; message -&gt; </span><br><span class="line">      System.out.println(salutation + message);</span><br><span class="line">      greetService1.sayMessage(&quot;Runoob&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   interface GreetingService &#123;</span><br><span class="line">      void sayMessage(String message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上脚本，输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ javac Java8Tester.java </span><br><span class="line">$ java Java8Tester</span><br><span class="line">Hello! Runoob</span><br></pre></td></tr></table></figure><p>我们也可以直接在 lambda 表达式中访问外层的局部变量：<br><code>Java8Tester.java 文件</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Java8Tester &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        final int num &#x3D; 1;</span><br><span class="line">        Converter&lt;Integer, String&gt; s &#x3D; (param) -&gt; System.out.println(String.valueOf(param + num));</span><br><span class="line">        s.convert(2);  &#x2F;&#x2F; 输出结果为 3</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public interface Converter&lt;T1, T2&gt; &#123;</span><br><span class="line">        void convert(int i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int num &#x3D; 1;  </span><br><span class="line">Converter&lt;Integer, String&gt; s &#x3D; (param) -&gt; System.out.println(String.valueOf(param + num));</span><br><span class="line">s.convert(2);</span><br><span class="line">num &#x3D; 5;  </span><br><span class="line">&#x2F;&#x2F;报错信息：Local variable num defined in an enclosing scope must be final or effectively </span><br><span class="line"> final</span><br></pre></td></tr></table></figure><p>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String first &#x3D; &quot;&quot;;  </span><br><span class="line">Comparator&lt;String&gt; comparator &#x3D; (first, second) -&gt; Integer.compare(first.length(), second.length());  &#x2F;&#x2F;编译会出错</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-Lambda-表达式&quot;&gt;&lt;a href=&quot;#Java-Lambda-表达式&quot; class=&quot;headerlink&quot; title=&quot;Java Lambda 表达式&quot;&gt;&lt;/a&gt;Java Lambda 表达式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Lambda 表达
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java8新特性</title>
    <link href="http://iwantjingjing.com/2021/06/06/java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://iwantjingjing.com/2021/06/06/java8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2021-06-06T07:56:04.000Z</published>
    <updated>2021-06-06T08:07:20.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java8新特性"><a href="#java8新特性" class="headerlink" title="java8新特性"></a>java8新特性</h1><p>Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。 Oracle 公司于 2014 年 3 月 18 日发布 Java 8 ，它支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的Stream API 等。</p><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><p>Java8 新增了非常多的特性，我们主要讨论以下几个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</span><br><span class="line"></span><br><span class="line">方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</span><br><span class="line"></span><br><span class="line">默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。</span><br><span class="line"></span><br><span class="line">新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</span><br><span class="line"></span><br><span class="line">Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</span><br><span class="line"></span><br><span class="line">Date Time API − 加强对日期与时间的处理。</span><br><span class="line"></span><br><span class="line">Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</span><br><span class="line"></span><br><span class="line">Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</span><br></pre></td></tr></table></figure><p>更多的新特性可以参阅官网：<a href="https://www.oracle.com/cn/java/technologies/javase/8-whats-new.html" target="_blank" rel="noopener">What’s New in JDK 8</a></p><p>在关于 Java 8 文章的实例，我们均使用 jdk 1.8 环境，你可以使用以下命令查看当前 jdk 的版本：</p><pre><code>$ java -versionjava version &quot;1.8.0_31&quot;Java(TM) SE Runtime Environment (build 1.8.0_31-b13)Java HotSpot(TM) 64-Bit Server VM (build 25.31-b07, mixed mode)</code></pre><h2 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h2><p>Java 8 希望有自己的编程风格，并与 Java 7 区别开，以下实例展示了 Java 7 和 Java 8 的编程格式：</p><p><code>Java8Tester.java 文件代码：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">   </span><br><span class="line">      List&lt;String&gt; names1 &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">      names1.add(&quot;Google &quot;);</span><br><span class="line">      names1.add(&quot;Runoob &quot;);</span><br><span class="line">      names1.add(&quot;Taobao &quot;);</span><br><span class="line">      names1.add(&quot;Baidu &quot;);</span><br><span class="line">      names1.add(&quot;Sina &quot;);</span><br><span class="line">        </span><br><span class="line">      List&lt;String&gt; names2 &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">      names2.add(&quot;Google &quot;);</span><br><span class="line">      names2.add(&quot;Runoob &quot;);</span><br><span class="line">      names2.add(&quot;Taobao &quot;);</span><br><span class="line">      names2.add(&quot;Baidu &quot;);</span><br><span class="line">      names2.add(&quot;Sina &quot;);</span><br><span class="line">        </span><br><span class="line">      Java8Tester tester &#x3D; new Java8Tester();</span><br><span class="line">      System.out.println(&quot;使用 Java 7 语法: &quot;);</span><br><span class="line">        </span><br><span class="line">      tester.sortUsingJava7(names1);</span><br><span class="line">      System.out.println(names1);</span><br><span class="line">      System.out.println(&quot;使用 Java 8 语法: &quot;);</span><br><span class="line">        </span><br><span class="line">      tester.sortUsingJava8(names2);</span><br><span class="line">      System.out.println(names2);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 使用 java 7 排序</span><br><span class="line">   private void sortUsingJava7(List&lt;String&gt; names)&#123;   </span><br><span class="line">      Collections.sort(names, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public int compare(String s1, String s2) &#123;</span><br><span class="line">            return s1.compareTo(s2);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 使用 java 8 排序</span><br><span class="line">   private void sortUsingJava8(List&lt;String&gt; names)&#123;</span><br><span class="line">      Collections.sort(names, (s1, s2) -&gt; s1.compareTo(s2));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>执行以上脚本，输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ javac Java8Tester.java</span><br><span class="line">$ java Java8Tester</span><br><span class="line">使用 Java 7 语法: </span><br><span class="line">[Baidu , Google , Runoob , Sina , Taobao ]</span><br><span class="line">使用 Java 8 语法: </span><br><span class="line">[Baidu , Google , Runoob , Sina , Taobao ]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java8新特性&quot;&gt;&lt;a href=&quot;#java8新特性&quot; class=&quot;headerlink&quot; title=&quot;java8新特性&quot;&gt;&lt;/a&gt;java8新特性&lt;/h1&gt;&lt;p&gt;Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。 Oracl
      
    
    </summary>
    
    
      <category term="java" scheme="http://iwantjingjing.com/categories/java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Mac装机必备</title>
    <link href="http://iwantjingjing.com/2021/04/01/Mac%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/"/>
    <id>http://iwantjingjing.com/2021/04/01/Mac%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/</id>
    <published>2021-04-01T02:05:36.000Z</published>
    <updated>2021-04-01T06:25:07.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mac教程"><a href="#Mac教程" class="headerlink" title="Mac教程"></a><a href="https://search.bilibili.com/all?keyword=mac%E6%95%99%E7%A8%8B&from_source=nav_suggest_new" target="_blank" rel="noopener">Mac教程</a></h2><h2 id="如何在Mac上安装软件？"><a href="#如何在Mac上安装软件？" class="headerlink" title="如何在Mac上安装软件？"></a><a href="https://www.imymac.com/zh-CN/mac-uninstaller/how-to-install-software-on-mac.html" target="_blank" rel="noopener">如何在Mac上安装软件？</a></h2><h2 id="在-Mac-上安全地打开-App"><a href="#在-Mac-上安全地打开-App" class="headerlink" title="在 Mac 上安全地打开 App"></a><a href="https://support.apple.com/zh-cn/HT202491" target="_blank" rel="noopener">在 Mac 上安全地打开 App</a></h2><h2 id="装机神器"><a href="#装机神器" class="headerlink" title="装机神器"></a><a href="https://markdowner.net/article/144933455225282560" target="_blank" rel="noopener">装机神器</a></h2><h2 id="程序员用-Mac-都有哪些必备的-app？"><a href="#程序员用-Mac-都有哪些必备的-app？" class="headerlink" title="程序员用 Mac 都有哪些必备的 app？"></a><a href="https://www.zhihu.com/question/20036899/answer/81771318" target="_blank" rel="noopener">程序员用 Mac 都有哪些必备的 app？</a></h2><h2 id="iTerm"><a href="#iTerm" class="headerlink" title="iTerm"></a><a href="https://iterm2.com/downloads.html" target="_blank" rel="noopener">iTerm</a></h2><pre><code>brew search chromebrew install google-chromebrew search toolboxbrew install jetbrains-toolboxbrew search redisbrew install another-redis-desktop-managerbrew search javabrew install the-unarchiverbrew cask install alfred</code></pre><h2 id="强迫症的-Mac-设置指南"><a href="#强迫症的-Mac-设置指南" class="headerlink" title="强迫症的 Mac 设置指南"></a><a href="https://github.com/macdao/ocds-guide-to-setting-up-mac" target="_blank" rel="noopener">强迫症的 Mac 设置指南</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Mac教程&quot;&gt;&lt;a href=&quot;#Mac教程&quot; class=&quot;headerlink&quot; title=&quot;Mac教程&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://search.bilibili.com/all?keyword=mac%E6%95%99%E7%A8%8B&amp;
      
    
    </summary>
    
    
      <category term="mac" scheme="http://iwantjingjing.com/categories/mac/"/>
    
    
      <category term="mac" scheme="http://iwantjingjing.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="http://iwantjingjing.com/2021/02/02/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://iwantjingjing.com/2021/02/02/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-02T03:57:55.000Z</published>
    <updated>2021-02-02T05:29:23.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>在策略模式（Strategy Pattern)中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p><p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的context对象。策略对象改变context对象的执行算法。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图</strong>：定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换。策略模式让算法独立与使用它的客户变换，也称为政策模式（policy）</p><p><strong>主要解决</strong>：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护</p><p><strong>何时使用</strong>：一个系统有许多许多类，而区分它们的只是他们直接的行为。</p><p><strong>如何解决</strong>：将这些算法封装成一个一个的类，任意地替换。</p><p><strong>关键代码</strong>：实现同一个接口。</p><p><strong>应用实例：</strong> </p><p>1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。</p><p>2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 </p><p>3、JAVA AWT 中的 LayoutManager。</p><p><strong>优点：</strong> </p><p>1、算法可以自由切换。</p><p>2、避免使用多重条件判断。</p><p>3、扩展性良好。</p><p><strong>缺点：</strong></p><p>1、策略类会增多。 </p><p>2、所有策略类都需要对外暴露。</p><p><strong>使用场景：</strong></p><p>1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 </p><p>2、一个系统需要动态地在几种算法中选择一种。</p><p>3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p><p><strong>注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</strong></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h1&gt;&lt;p&gt;在策略模式（Strategy Pattern)中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>如何替换if-Else</title>
    <link href="http://iwantjingjing.com/2021/02/02/%E5%A6%82%E4%BD%95%E6%9B%BF%E6%8D%A2if-Else/"/>
    <id>http://iwantjingjing.com/2021/02/02/%E5%A6%82%E4%BD%95%E6%9B%BF%E6%8D%A2if-Else/</id>
    <published>2021-02-02T00:57:54.689Z</published>
    <updated>2021-02-02T03:13:45.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="免责声明：本文并不肯定或者否定哪一种写法，仅仅为大家提供一些其他的编码思路或者一些值得借鉴的点子"><a href="#免责声明：本文并不肯定或者否定哪一种写法，仅仅为大家提供一些其他的编码思路或者一些值得借鉴的点子" class="headerlink" title="免责声明：本文并不肯定或者否定哪一种写法，仅仅为大家提供一些其他的编码思路或者一些值得借鉴的点子"></a>免责声明：本文并不肯定或者否定哪一种写法，仅仅为大家提供一些其他的编码思路或者一些值得借鉴的点子</h2><pre><code>if（condition）{    do stuff} else (otherCondition) {    do something} else {}</code></pre><p>if-Else通常是个糟糕的选择，它导致设计复杂，代码可读性差，重构困难等等。说了这么多如何优化？或者说如何替换if-Else呢？</p><h2 id="五种方式"><a href="#五种方式" class="headerlink" title="五种方式"></a>五种方式</h2><h3 id="完全不必要的Else块"><a href="#完全不必要的Else块" class="headerlink" title="完全不必要的Else块"></a>完全不必要的Else块</h3><pre><code>public void PerformOperation(int input) {    if(intput &gt; 5) {        // do something    } else {        // do something    } }</code></pre><p>只需要删除else块即可简化此过程，如下所示</p><pre><code>public void PerformOperation(int input) {    if(intput &gt; 5) {        // do something        return;    }     // do something}</code></pre><p>仔细体会一下，那种写法更容易理解？其实就一句话：在满足特定条件的情况下执行某些操作并立即返回，适用于异常流先返回，往下执行的都是正常流业务。</p><h3 id="价值分配"><a href="#价值分配" class="headerlink" title="价值分配"></a>价值分配</h3><p>如果你想要根据某些输入为变量分配新值，如下：</p><pre><code>public static string determineGender(int input) {    String gender = String.Empty;    if(input == 0) {        gender = &quot;male&quot;;    } else if(input == 1) {        gender = &quot;woman&quot;;    } else if {        gender = &quot;unknown&quot;;    }    return gender;}</code></pre><p>上述if-Else很容易被开关取代。如下：</p><pre><code>public static string determineGender(int input) {    if(input == 0) {         return &quot;male&quot;;    } else if(input == 1) {         return &quot;woman&quot;;    } else if {         return &quot;unknown&quot;;    }}</code></pre><p>进一步优化，可通过删除else来进一步简化代码</p><pre><code>public static string determineGender(int input) {    if(input == 0) {return &quot;male&quot;; }     if(input == 1) {return &quot;woman&quot;; }      return &quot;unknown&quot;;}</code></pre><p>若不使用else，则我们将剩下干净的可读代码。这么做的好处是可以迅速得到想要的值。试想：如果已经找到正确的值，继续测试下一个值一点意义也没有。</p><h3 id="前提条件检查-用三元运算代替if"><a href="#前提条件检查-用三元运算代替if" class="headerlink" title="前提条件检查(用三元运算代替if)"></a>前提条件检查(用三元运算代替if)</h3><p>通常，我发现，如果方法提供了无效的值，则继续执行是没有意义的。假设有一个方法defineGender方法，要求输入值必须始终为0或者1。</p><pre><code>// Input must be 0 or 1public String defineGender (int input) {    // Continue executing logic}</code></pre><p>在没有参数验证的情况下,执行该方法没有任何意义，或者说太容易出bug了，因此在实际业务之前，我们需要检查一些先决条件。</p><pre><code>// Input must be 0 or 1public String defineGender (int input) {    if(intput &lt; 0) throw new ArgumentException();    if(intput &gt; 0) throw new ArgumentException();    return input == 0 ? &quot;woman&quot; : &quot;man&quot;;}</code></pre><p>因有明确的输入限制，if可以用三元代替，因此不再需要在结尾处写默认返回值。</p><h3 id="将-If-Else转换为字典，完全避免-IF-ELSE"><a href="#将-If-Else转换为字典，完全避免-IF-ELSE" class="headerlink" title="将 If-Else转换为字典，完全避免 IF-ELSE"></a>将 If-Else转换为字典，完全避免 IF-ELSE</h3><p>假设你需要执行一些操作，这些操作将根据某些条件进行选择，我们知道以后必须添加更多条件操作。</p><pre><code>public void performOp(String operationName) {    if(operationName == &quot;Op1&quot;)) {       // something     } else if (operationName == &quot;Op2&quot;) {       // something     } else {       // default path     }}</code></pre><p>有些人倾向于使用久经考验的 If-Else。如果添加新操作，则只需要简单地添加其他内容即可。很简单!但是，就维护而言,这种方法不是一个号的设计。</p><p>知道我们以后需要添加新的操作后，我们可以将If-Else重构为字典。</p><pre><code>public void performOp(String operationName) {    var operations = new Dictionary&lt;String, Action&gt;();    operations[&quot;Op1&quot;] = () =&gt; {// something};    operations[&quot;Op2&quot;] = () =&gt; {// something};    operations[operationName].Invoke();}</code></pre><p>可读性已经大大提高，并且可以轻松地推断出该代码。注意，仅用于说明目的将字典放置在方法内部。你可以在其他地方定义它。</p><h3 id="扩展应用程序，完全避免使用If-Else"><a href="#扩展应用程序，完全避免使用If-Else" class="headerlink" title="扩展应用程序，完全避免使用If-Else"></a>扩展应用程序，完全避免使用If-Else</h3><pre><code>public String printOrder(Order order, String formatType) {    String result = String.Empty;    if(formatType == &quot;Json&quot;) {        result = JsonSerializer.Serialize(order);    } else if (formatType == &quot;PlainText&quot;) {        result = $&quot;Id:{order.Id}\nSum: {order.Sum}&quot;;    } else {        result = &quot;Unknown format&quot;;    }    return result;}</code></pre><p>上述代码我们若有新业务增加，则可通过添加if-else来解决，但它违反了开闭原则，且可读性差。    </p><p>正确的做法为：遵循SOLID原则，我们通过实施动态类型发现过程（本例中为策略模式）来做到这一点。</p><p><strong>重构的过程如下</strong></p><ul><li>使用公共接口将每个分支提取到单独的策略类中。</li><li>动态查找实现通用接口的所有类。</li><li>根据输入决定执行哪种策略。</li></ul><p>重点是类型发现的工作原理。</p><pre><code>private String printOrder(Order order, String formatType) {// Dynamic type discovery process that builds a dictionaryDictionary&lt;String, Type&gt; formatterTypes = Assembly    .GetExecutingAssembly()    .GetExportedTypes()    .Where(type =&gt; type.getInterfaces().Contains(typeof(IOrderOutputStrategy)))    .ToDictionary(type =&gt; type.GetCustomAttribute&lt;OutputFormatterName&gt;().DisplayName);Type choseFormatter = formatterTypes[formatType];// Try instantiate the formatter -- could have utilized a DI framework here insteadIOrderOutputStrategy strategy = Activator.CreateInstance(chosenFormatter) as IOrderOutputStrategy;if ( strategy is null) throw new InvalidOperationException(&quot;No valid formatter selected&quot;);// Execute strategy methodstring result = strategy.ConvertOrderToString(order);return result;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;免责声明：本文并不肯定或者否定哪一种写法，仅仅为大家提供一些其他的编码思路或者一些值得借鉴的点子&quot;&gt;&lt;a href=&quot;#免责声明：本文并不肯定或者否定哪一种写法，仅仅为大家提供一些其他的编码思路或者一些值得借鉴的点子&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>坏代码的味道</title>
    <link href="http://iwantjingjing.com/2021/01/26/%E5%9D%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E5%91%B3%E9%81%93/"/>
    <id>http://iwantjingjing.com/2021/01/26/%E5%9D%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E5%91%B3%E9%81%93/</id>
    <published>2021-01-26T07:02:58.735Z</published>
    <updated>2021-01-26T07:02:58.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="坏代码的味道"><a href="#坏代码的味道" class="headerlink" title="坏代码的味道"></a>坏代码的味道</h1><h2 id="Duplicated-Code-（重复代码）难维护"><a href="#Duplicated-Code-（重复代码）难维护" class="headerlink" title="Duplicated Code （重复代码）难维护"></a>Duplicated Code （重复代码）难维护</h2><ul><li>解决方法：提取公共函数。</li></ul><p>最单纯的Duplicated Code就是［同一个class内的两个方法含有相同表达式(expression)］。这时候你需要做的就是采用Extract Method提炼出重复的代码，然后让这两个地点都调用被提炼出来的那一段代码。    </p><p>另一种常见情况就是[两个互为兄弟(sibling)的subclasses内含有相同表达式]。要避免这种情况，只需要对两个classes都使用 Extract Method，然后再对被提炼出的代码使用Pull Up Method，将它推入superclass内。如果代码之间只是类似，并非完全相同，那么就得运用Extract Method将相似部分和差异部分割开，构成单独一个方法。然后你可能发现或许可以运用Form Template Method获得一个Template Method设计模式。如果有些方法以不同的算法做相同的事，你可以择定其中较清晰的一个，并使用Substitute Algorithm将其它方法的算法替换掉。</p><p>如果两个毫不相关的classes内出现Duplicated Code，你应该考虑对其中一个使用Extract Class，将重复代码提炼到一个独立class中，然后在另一个class内使用这个新class。但是，重复代码所在的方法也可能的确只应该属于某个 class，另一个class只能调用它，抑或这个方法可能属于第三个class，而另两个classes应该引用这第三个class。你必须决定这个方法放在哪儿最合适，并确保它被安置后就不会再在其它任何地方出现。    </p><h2 id="Long-Method-长函数-难理解"><a href="#Long-Method-长函数-难理解" class="headerlink" title="Long Method (长函数)难理解"></a>Long Method (长函数)难理解</h2><ul><li>解决方法：拆分成若干函数。</li></ul><p>拥有短方法(short methods)的对象会活得比较好、比较长。不熟悉面向对象技术的人，常常觉得对象程序中只有无穷无尽的delegation(委托)，根本没有进行任何计算。和此类程序共同生活数年之后，你才会知道，这些小小方法有多大价值。［间接层］所能带来的全部利益——解释能力、共享能力、选择能力——都是由小型方法支持的。</p><p>很久以前程序员就已认识到：程序愈长愈难理解。早期的编程语言中，［子程序调用动作］需要额外开销，这使得做你们不太乐意使用small method，现代OO语言几乎已经完全免除了进程内的[方法调用动作额外开销]。不过代码阅读者还是得多费力气，因为他必须经常转换上下文去看看子程序做了什么。某些开发环境允许用户同时看到两个方法，这可以帮助你省去部分麻烦，但是让small method容易理解的真正关键在于一个好名字。如果你能给方法起个好名字，读者就可以通过名字了解方法的作用，根本不必去看其中写了些什么。</p><p>最终的效果是：你应该更积极进取地分解方法。我们遵循这样一条原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立的方法中，并以其用途(而非实现手法)命名。我们可以对一组或甚至短短一行代码做这件事。哪怕替换后的方法调用动作比方法自身还长，只要方法名称能够解释其用途，我们也该毫不犹豫地那么做。关键不在于方法的长度，而在于方法[做什么]和[如何做]之间的语义距离。</p><p>百分之九十九的场合里，要把方法变小，只需使用Extract Method。找到方法中适合集在一起的部分，将它们提炼出来形成一个新方法。</p><p>如果方法内有大量的参数和临时变量，它们会对你的方法提炼形成阻碍。如果你尝试运用Extract Method，最终就会把许多这些参数和临时变量当作参数，传递给被提炼出来的新方法，导致可读性几乎没有任何提升。啊是的，你可以经常运用 Replace Temp with Query则可以将过长的参数列变得更简洁一些。</p><p>如果你已经这么做，仍然有太多临时变量和参数，那就应该拿出我们的杀手锏：Replace Method with Method Object。</p><p>如何确定该提炼哪一段代码呢？一个很好的技巧是：寻找注释。它们通常是指出[代码用途和实现手法间的语义距离]的信号。如果代码前言有一行注释，就是在提醒你：可以将这段代码替换成一个方法，而且可以在注释的基础上给这个方法命名。就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立的方法去。</p><p>条件式和循环常常也是提炼的信号。你可以使用Decompose Conditional处理条件式。至于循环，你应该将循环和其内的代码提炼到一例独立方法中。</p><h2 id="Large-Class-大类-难理解"><a href="#Large-Class-大类-难理解" class="headerlink" title="Large Class (大类)难理解"></a>Large Class (大类)难理解</h2><ul><li>解决方法：拆分成若干类。</li></ul><p>如果想利用单一class做太多事情，其内往往就会出现太多instance变量。一旦如此，Duplicated Code也就接踵而至了。</p><p>你可以运用Extract Class将数个变量一起提炼到新class内。提炼时应该选择class内彼此相关的变量，将它们放在一起。例如”depositAmount” 和”depositCurrency”可能应该隶属同一个class。通常如果class内的数个变量有着相同的前缀或字尾，这就意味有机会把它们提炼到某个组件内。如果这个组件适合作为一个subclass，你会发现Extract Subclass往往比较简单。</p><p>有时候class并非在所有时刻都使用所有instance变量。果真如此，你或许可以多次使用Extract Class或Extract Subclass。</p><p>和[太多instance变量]一样，class内如果有太多代码，也是[]代码重复、混乱、死亡]的绝佳滋生地点。最简单的解决方案是把赘余的东西消弭于class内部。如果有五个[百行方法]，它们之中很多代码都相同，那么或许你可以把它们变成五个［十行方法］和十个提炼出来的［双行方法］</p><p>和[拥有太多instance变量]一样，一个class如果拥有太多代码，往往也适合使用Extract Class和Extract Subclass。这里有个有用技巧：先确定客户端如何使用它们，然后运用Extract Interface为每一种使用一个接口。这或许可以帮助你看清楚如何分解这个class。</p><p>如果你的Large Class是个GUI class，你可能需要把数据和行为移到一个独立的领域对象去。你可能需要两边各保留一些重复数据，并令这些数据同步。Duplicate Observed Data告诉你该怎么做。这种情况下，特别是如果你使用旧式AWT组件，你可以采用这种方式去掉GUI class并代以Swing组件。</p><h2 id="Long-Parameter-List-参数多-难用，难理解"><a href="#Long-Parameter-List-参数多-难用，难理解" class="headerlink" title="Long Parameter List (参数多) 难用，难理解"></a>Long Parameter List (参数多) 难用，难理解</h2><ul><li>解决方法：将參数封装成结构或者类。</li></ul><p>刚开始学习编程的时候，老师教我们：把方法所需的所有东西都以参数传递进去。这可以理解，因为除此之外就只能选择全局数据，而全局数据是邪恶的东西。对象技术改变了这一情况，因为如果你手上没有你所需要的东西，总可以叫另一个对象给你。因此，有了对象，你就不必把方法需要的所有东西都以参数传递给它了，你只需给它足够的东西、让方法能从中获得自己需要的所有东西就行了。方法需要的东西多半可以在方法的宿主类(host class)中找到。面向对象程序中的方法，其参数列通常比在传统程序中短得多。</p><p>这是好现象，因为太长的参数列难以理解，太多参数会造成前后不一致、不易使用，而且一旦你需要更多数据，就不得不修改它。如果将对象传递给方法，大多数修改都将没有必要，因为你很可能只需(在方法内)增加一两条请求，就能得到更多数据。</p><p>如果[向既有对象发出一条请求]就可以取得原本位于参数列上的一份数据，那么你应该激活重构准则Replace Parameter with Method。上述的既有对象可能是方法所属class内的一个字段，也可能是另一个参数。你还可以运用Preserve Whole Object将来自同一对象的一堆数据收集起来，并以该对象替换它们。如果某些数据缺乏合理的对象归属，可使用Introduce Parameter Object为它们制造出一个[参数对象]。</p><p>此间存在一个重要的例外。有时候你明显不希望造成[被调用之对象]与[较大对象]间的某种依存关系。这时候将数据从对象中拆解出来单独作为参数，也很合情合理。但是请注意其所引发的代价。如果参数列太长或变化太频繁，你就需要重新考虑自己的依存结构了。</p><h2 id="Divergent-Change-发散式改动"><a href="#Divergent-Change-发散式改动" class="headerlink" title="Divergent Change ( 发散式改动)"></a>Divergent Change ( 发散式改动)</h2><ul><li>解决方法：拆，将总是一起变化的东西放在一块儿。</li></ul><p>我们希望软件能够更容易被修改——毕竟软件再怎么说本来就该是[软]的。一旦需要修改，我们希望能够跌到系统的某一点，只在该处做修改。如果不能做到这点，你就嗅出两种紧密相关的刺鼻味道中的一种了。</p><p>如果某个class经常因为不同的原因在不同的方向上发生变化，Divergent Change就出现了。当你看着一个class说：“ 呃，如果新加入一个数据库，我必须修改这三个方法；如果新出现一种金融工具，我必须修改这四个方法”，那么此时也许将这个对象分成两个会更好，这么一来每个对象就可以只因一种变化而需要修改。当然，往往只有在加入新数据库或新金融工具后，你才能发现这一点。针对某一外界变化的所有相应修改，都只应该发生在单一class中，而这个新class内的所有内容都应该反应该外界变化。为此，你应该找出因着某特定原因而造成的所有变化，然后运用Extract Class将它们提炼到另一个class中。</p><h2 id="Shotgun-Surgery-天女散花的逻辑-散弹式改动，改某个需求的时候，要改非常多的类"><a href="#Shotgun-Surgery-天女散花的逻辑-散弹式改动，改某个需求的时候，要改非常多的类" class="headerlink" title="Shotgun Surgery (天女散花的逻辑 ) 散弹式改动，改某个需求的时候，要改非常多的类"></a>Shotgun Surgery (天女散花的逻辑 ) 散弹式改动，改某个需求的时候，要改非常多的类</h2><ul><li>解决方法：将各个改动点，集中起来，抽象成一个新类。</li></ul><p>Shotgun Surgery类似Divergent Change，但恰恰相反。如果每遇到某种变化，你都必须在许多不同的class内做出许多小修改以响应之，你所面临的坏味道就是Shotgun Surgery。如果需要修改的代码散布四处，你不但很难找到它们，也很容易忘记某个重要的修改。</p><p>这种情况下你应该使用Move Method和Move Field把所有需要修改的代码放进同一个class。如果眼下没有合适的class可以安置这些代码，就创造一个。通常你可以运用Inline Class把一系列相关行为放进同一个class。这可能会造成少量Divergent Change，但你可以轻易处理它。</p><p>Divergent Change是指[一个class受多种变化的影响]，Shotgun Surgery则是指[一种变化引发多个classes相应修改]。这两种情况下你都会希望整理代码，取得[外界变化]与[待改类]呈现一对一关系的理想境地。</p><h2 id="Feature-Envy-依恋情结-红杏出墙的函数-使用了大量其他类的成员"><a href="#Feature-Envy-依恋情结-红杏出墙的函数-使用了大量其他类的成员" class="headerlink" title="Feature Envy (依恋情结 红杏出墙的函数)使用了大量其他类的成员"></a>Feature Envy (依恋情结 红杏出墙的函数)使用了大量其他类的成员</h2><ul><li>解决方法：将这个函数挪到那个类里面。</li></ul><p>对象技术的全部要点在于：这是一种[将数据和加诸其上的操作行为包装在一起]的技术。有一种经典气味是：方法对某个class的兴趣高过对自己所处之 host class的兴趣。这种孺慕之情最通常的焦点便是数据。无数次经验里，我们看到某个方法为了计算某值，从另一个对象那儿调用几乎半打的取值方法。疗法显而易见：把这个方法移到另一个地点。你应该使用Move Method把它移到它该去的地方。有时候方法中只有一部分受这种依恋之苦，这时候你应该使用Extract Method把这一部分提炼到独立方法中，再使用Move Method带它去它的梦中家园。</p><p>当然，并非所有情况都这么简单。一个方法往往会用上数个classes特性，那么它究竟该被置于何处呢？我们的原则是：判断哪个class拥有最多[被此方法使用]的数据，然后就把这个方法和那些数据摆在一起。如果先以Extract Method将这个方法分解为整个较小方法并分别置放于不同地点，上述步骤也就比较容易完成了。</p><p>有数个复杂精巧的模式破坏了这个规则。说起这个话题，［四巨头］的Streategy和Visitor立刻跳入我的脑海，Kent Beck的Self Delegation也丰此列。使用这些模式是为了对抗坏味道Divergent Change。最根本的原则是：将总是一起变化的东西放在一块儿。［数据］和[引用这些数据]的行为总是一起变化的，但也有例外。如果例外出现，我们就搬移那些行为，保持[变化只在一起发生]。Strategy和Visitor使你得以轻松修改方法行为，因为它们将少量需要被覆写的行为隔离开来——当然也付出了[多一层间接性]的代价。</p><h2 id="Data-Clumps-数据团-常一起出现的一坨数据"><a href="#Data-Clumps-数据团-常一起出现的一坨数据" class="headerlink" title="Data Clumps (数据团) 常一起出现的一坨数据"></a>Data Clumps (数据团) 常一起出现的一坨数据</h2><ul><li>解决方法:他们那么有基情，就在一起吧，给他们一个新的类。</li></ul><p>数据项就像小孩子：喜欢成群结队地待在一块儿。你常常可以在很多地方看到相同的三或四笔数据项：两个classes内的相同字段、许多方法签名式中的相同参数。这些[总是绑在一起出现的数据]真应该放进属于它们自己的对象中。首先请找出这些数据的字段形式出现点，运用Extract Class将它们提炼到一个独立对象中。然后将注意力转移到方法签名式上头，运用Introduce Parameter Object或Preserve Whole Object为它减肥。这么做的直接好处是可以将很多参数列缩短，简化方法调用动作。是的，不必因为Data Clumps只用上新对象的一部分字段而在意，只要你以新对象取代两个(或更多)字段，你就值回票价了。</p><p>一个好的评断办法是：删掉众多数据中的一笔。其它数据有没有因而失去意义？如果它们不再有问询，这就是个明确信号：你应该为它们产生一个新对象。</p><p>缩短字段个数和参数个数，当然可以支队一些坏味道，但更重要的是：一旦拥有新对象，你就有机会让程序散发出一种芳香。得到新对象后，你就可以着手寻找 Feature Envy，这可以帮你指出[可移到新class]中的种种程序行为。不必太久，所有classes都将在它们的小小社会中充分发挥自己的生产力。</p><h2 id="Primitive-Obsession-偏爱基本类型-热衷于使用int，long，String等基本类型"><a href="#Primitive-Obsession-偏爱基本类型-热衷于使用int，long，String等基本类型" class="headerlink" title="Primitive Obsession (偏爱基本类型) 热衷于使用int，long，String等基本类型"></a>Primitive Obsession (偏爱基本类型) 热衷于使用int，long，String等基本类型</h2><ul><li>解决方法:重复出现的一组參数，有关联的多个数组换成类吧。</li></ul><p>大多数编程环境都有两种数据：结构型别允许你将数据组织成有意义的形式；基本型别则是构成结构型别的积木块。结构总是会带来一定的额外开销。它们有点像数据库中的表格，或是那些得不偿失的东西。</p><p>对象的一个极具价值的东西：它们模糊了横亘于基本数据和体积较大的classes之间的界限。你可以轻松编写出一些与语言内置型别无异的小型 classes。例如Java就以基本型别表示数值，而心class表示字符串和日期——这两个型别在其它许多编程环境中都以基本型别表现。</p><p>对象技术的新手通常在小任务上运用小对象——像是结合数值和币别的money class、含一个起始值和一个结束值的range class、电话号码或邮政编码等等的特殊strings。你可以运用Replace Data Value with Object将原本单独存在的数据值替换为对象，从而走出传统的洞窟，进入炙手可热的对象世界。如果欲替换之数据值是type code，而它并不影响行为，你可以运用Replace Type Code with Class将它换掉。如果你有相依于此type code的条件式，可运用Replace Type Code with Subclass或Replace Type Code with State/Strategy加以处理。</p><p>如果你有一组应该总是被放在一起的字段，可运用Extract Class。如果你在参数列中看到基本型数据，不妨试试Introduce Parameter Object。如果你发现自己正从array中挑选数据，可运用Replace Array with Object。</p><h2 id="Switch-Statements-switch语句"><a href="#Switch-Statements-switch语句" class="headerlink" title="Switch Statements (switch语句)"></a>Switch Statements (switch语句)</h2><ul><li>解决方法:state/strategy 或者仅仅是简单的多态。</li></ul><p>面向对象程序的一个最明显特征就是：少用switch(或case)语句。从本质上说，switch语句的问题在于重复。你常会发现同样的switch语句散布于不同的地点。如果要为它添加一个新的case子句，你必须找到所有switch语句并修改它们。面向的多态概念可为此带来优雅的解决办法。</p><p>大多数时候，一看到switch语句你就应该考虑以多态来替换它。问题是多态该出现在哪儿？switch语句常常根据type code进行选择，你要的是[与该type code相关的方法或class]。所以你应该使用Extract Method将switch语句提炼到一个独立方法中，再以Move Method将它搬移到需要多态性的那个class里头。此时你必须决定是否使用Replace Type Code with Subclasses或Replace Type Code with State/Strategy。一旦这样完成继承结构之后，你就可以运用Replace Conditional with Polymorphism了。</p><p>如果你只是在单一方法中髭选择事例，而你并不想改动它们，那么[多态]就有点杀鸡用牛刀了。这种情况下Replace Parameter with Explicit Methods是个不错的选择。如果你的选择条件之一是null，可以试试Introduce Null Object。</p><h2 id="Parallel-Inheritance-Hierarchies-平行继承-添加A类的子类ax，B类也要对应的添加一个bx"><a href="#Parallel-Inheritance-Hierarchies-平行继承-添加A类的子类ax，B类也要对应的添加一个bx" class="headerlink" title="Parallel Inheritance Hierarchies (平行继承) 添加A类的子类ax，B类也要对应的添加一个bx"></a>Parallel Inheritance Hierarchies (平行继承) 添加A类的子类ax，B类也要对应的添加一个bx</h2><ul><li>解决方法:应该有一个类是能够去掉继承关系的。</li></ul><p>Parallel Inheritance Hierarchies其实是Shotgun Surgery的特殊情况。在这种情况下，每当你为某个class增加一个subclass，必须也为另一个class相应增加一个subclass。如果你发现某个继承体系的class名称前缀和另一个继承体系的class名称前缀完全相同，便是闻到了这种坏味道。</p><p>消除这种重复性的一般策略是：让一个继承体系的实体指涉另一个继承体系的实体。如果再接再厉运用Move Method和Move Field，就可以将指涉端的继承体系消弭于无形。</p><h2 id="Lazy-Class-冗赘类-假设他不干活了，炒掉他吧"><a href="#Lazy-Class-冗赘类-假设他不干活了，炒掉他吧" class="headerlink" title="Lazy Class (冗赘类) 假设他不干活了，炒掉他吧"></a>Lazy Class (冗赘类) 假设他不干活了，炒掉他吧</h2><ul><li>解决方法:把这些不再重要的类里面的逻辑，合并到相关类，删掉旧的。</li></ul><p>你所创建的每一个class，都得有人去理解它、维护它，这些工作都是要花钱的。如果一个class的所得不值其身份，它就应该消失。项目中经常会出现这样的情况：某个class原本对得起自己的身份，但重檐使它身形缩水，不再做那么多工作；或开发者事前规划了某些变化，并添加一个class来就会这些变化，但变化实际上没有发生。不论上述哪一种原因，请让这个class庄严赴义吧。如果某些subclass没有做满足够工作，试试Collapse Hierarchy[合并继承]。对于几乎没用的组件，你应该以Inline Class对付它们。</p><h2 id="Speculative-Generality-（夸夸其谈未来性）"><a href="#Speculative-Generality-（夸夸其谈未来性）" class="headerlink" title="Speculative Generality （夸夸其谈未来性）"></a>Speculative Generality （夸夸其谈未来性）</h2><ul><li>解决方法:删掉</li></ul><p>这个令我们十分敏感的坏味道，命名者是Brian Foote。当有人说“噢，我想我们总有一天需要做这事”并因而企图以各式各样的挂勾和特殊情况来处理一些非必要的事情，这种坏味道就出现了。那么做的结果往往造成系统更难理解和维护。如果所有装置都会被用到，那就值得那么做；如果用不到，就不值得。用不上的装置只会挡你的路，所以，把它搬弄吧。</p><p>如果你的某个abstract class其实没有太大作用，请运用Collapse Hierarchy。非必要之delegation可运用Inline Class除掉。如果方法的某些参数示被用上，可对它实施Rename Method让它现实一些。</p><p>如果方法或class的惟一用户是test cases，这就飘出了坏味道Speculative Generality。如果你发现这样的方法或class，请把它们连同其test cases都删掉。但如果它们的用途是帮助test cases检测正当功能，当然必须刀下留人。</p><h2 id="Temporary-Field-（临时字段）仅在特定环境下使用的变量"><a href="#Temporary-Field-（临时字段）仅在特定环境下使用的变量" class="headerlink" title="Temporary Field （临时字段）仅在特定环境下使用的变量"></a>Temporary Field （临时字段）仅在特定环境下使用的变量</h2><ul><li>解决方法:将这些暂时变量集中到一个新类中管理。</li></ul><p>有时你会看到这样的对象：其内某个instance 变量仅为某种特定情势而设。这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有变量。在变量未被使用的情况下猜测当初其设置目的，会让你发疯。</p><p>请使用Extract Class给这个可怜的孤独创造一个家，然后把所有和这个变量相关的代码都放进这个新家。也许你还可以使用Introduce Null Object在[变量不合法]的情况下创建一个Null对象，从而避免写出[条件式代码]。</p><p>如果class中有一个复杂算法，需要好几个变量，往往就可能导致坏味道Temporary Field的出现。由于实现者不希望传递一长串参数，所以他把这些参数都放进字段中。但是这些字段只在使用该算法时才有效，其它情况下只会让人迷惑。这时候你可以利用Extract Class把这些变量和其相关方法提炼到一个独立class中。提炼后的新对象将是一个method object。</p><h2 id="Message-Chains-（消息链）过度耦合的才是坏的。"><a href="#Message-Chains-（消息链）过度耦合的才是坏的。" class="headerlink" title="Message Chains （消息链）过度耦合的才是坏的。"></a>Message Chains （消息链）过度耦合的才是坏的。</h2><ul><li>解决方法:拆函数或者移动函数。</li></ul><p>如果你看到用户向一个对象索求另一个对象，然后再向后者索求另一个对象，然后再索求另一个对象……这就是Message Chain。实际代码中你看到的可能是一长串getThis()或一长串临时变量。采取这种方式，意味客户将与查找过程中的航行结构紧密耦合。一旦对象间的关系发生任何变化，客户端就不得不做出相应修改。</p><p>这时候你应该使用Hide Delegate。你可以在Message Chain的不同位置进行这种重构手法。理论上你可以重构Message Chain上的任何一个对象，但这么做往往会把所有中介对象都变成Middle Man。通常更好的选择是：先观察Message Chain最终得到的对象是用来干什么的，看看能否以Extract Method把使用该对象的代码提炼到一个独立方法中，再运用Move Method把这个方法推入Message Chain。如果这条链上的某个对象有多位客户打算航行此航线的剩余部分，就加一个方法来做这件事。</p><p>有些人把任何方法链都视为坏东西，我们不这样想。呵呵，我们的总代表镇定是出了名的，起码在这件事情上是这样。</p><h2 id="Middle-Man-中介-大部分都交给中介来处理了"><a href="#Middle-Man-中介-大部分都交给中介来处理了" class="headerlink" title="Middle Man (中介) 大部分都交给中介来处理了"></a>Middle Man (中介) 大部分都交给中介来处理了</h2><ul><li>解决方法:用继承替代托付。<br>对象的基本特征之一就是封装——对外部世界隐藏其内部细节。封装往往伴随delegation。比如说你问主管是否有时间参加一个会议，他就把这个消息委托给他的记事簿，然后才能回答你。很好，你没必要知道这位主管到底使用传统记事簿或电子记事簿抑或秘书来记录自己的约会。</li></ul><p>但是人们可能过度运用delegation。你也许会看到某个class接口有一半的方法都委托给其它class，这样就是过度运用。这里你应该使用 Remove Middle Man，直接和负责对象打交道。如果这样[不干实事]的方法只有少数几个，可以运用Inline Method把它们”inlining”，放进调用端。如果这些Middle Man还有其它行为内销可以运用Replace Delegation with Inheritance把它变成负责对象的subclass，这样你既可以扩展原对象的行为，又不必负担那么多的委托动作。</p><h2 id="Inappropriate-Intimacy-太亲热-两个类都使用对方私有的东西"><a href="#Inappropriate-Intimacy-太亲热-两个类都使用对方私有的东西" class="headerlink" title="Inappropriate Intimacy (太亲热) 两个类都使用对方私有的东西"></a>Inappropriate Intimacy (太亲热) 两个类都使用对方私有的东西</h2><ul><li>解决方法:划清界限拆散，或合并，或改成单项联系。<br>有时候你会看到两个classes过于亲密，花费太多时间去探究彼此的private成分。如果这发生在两个[人]之间，我们不必做卫道之士；但对于 classes，我们希望它们严守清规。</li></ul><p>就像古代恋人一样，过份狎昵的classes必须拆散。你可以采用Move Method和Move Field帮它们划清界线，从而减少狎昵行径。你也可以看看是否运用Change Bidirectional Association to Unidirectional[将双向关联改为单向]让其中一个class对另一个斩断情丝。如果两个classes实在情投意合，可以运用Extract Class把两者共同点提炼到一个安全地点，让它们坦荡地使用这个新class。或者也可以尝试运用Hide Delegate让另一个class来为它们传递相思情。</p><p>继承往往造成过度亲密，因为subclass对superclass的了解总是超过superclass的主观愿望。如果你觉得该让这个孩子独自生活了，请运用Replace Inheritance with Delegation让它离开继承体系。</p><h2 id="Alternative-Classes-with-Different-Interfaces-异曲同工的类"><a href="#Alternative-Classes-with-Different-Interfaces-异曲同工的类" class="headerlink" title="Alternative Classes with Different Interfaces (异曲同工的类)"></a>Alternative Classes with Different Interfaces (异曲同工的类)</h2><ul><li>解决方法:重命名，移动函数，或抽象子类。</li></ul><p>如果两个方法做同一件事，却有着不同的签名式，请运用Rename Method根据它们的用途重新命名。但这往往不够，请反复运用Move Method将某些行为移入classes，直到两者的协议一致为止。如果你必须重复而赘余地移入代码才能完成这些，或许可运用Extract Superclass为自己赎点罪。</p><h2 id="Incomplete-Library-Class-（不完美的程序库类）"><a href="#Incomplete-Library-Class-（不完美的程序库类）" class="headerlink" title="Incomplete Library Class （不完美的程序库类）"></a>Incomplete Library Class （不完美的程序库类）</h2><ul><li>解决方法:包一层函数或包成新的类。</li></ul><p>复用常被视为对象的终极目的。我们认为这实在是过度估计了。但是无可否认，许多编程技术都建立在library classes的基础上，没人敢说是不是我们都把排序算法忘得一干二净了。</p><p>Library classes构筑者没有未卜先知的能力，我们不能因此责怪他们。毕竟我们自己也几乎总是在系统快要构筑完成的时候才能弄清楚它的设计，所以 library构筑者的任务真的很艰巨。麻烦的是library的形式往往不够好，往往不可能让我们修改其中的classes使它完成我们希望完成的工作。这是否意味那些经过实践检验的战术如Move Method等等，如今都派不上用场了？</p><p>幸好我们有两个专门就会这种情况的工具。如果你只想修改library classes内的一两个方法，可以运用Introduce Foreign Method；如果想要添加一大堆额外行为，就得运用Introduce Local Extension。</p><h2 id="Data-Class-纯数据类-类非常简单，仅有公共成员变量，或简单操作函数。"><a href="#Data-Class-纯数据类-类非常简单，仅有公共成员变量，或简单操作函数。" class="headerlink" title="Data Class (纯数据类) 类非常简单，仅有公共成员变量，或简单操作函数。"></a>Data Class (纯数据类) 类非常简单，仅有公共成员变量，或简单操作函数。</h2><ul><li>解决方法:将相关操作封装进去，降低public成员变量。</li></ul><p>所谓Data Class是指：它们拥有一些字段，以及用于访问这些字段的方法，除此之外一无长物。这样的classes只是一种[不会说话的数据容器]，它们几乎一定被其它classes过份细琐地操控着。这些classes早期可能拥有public字段，果真如此你应该在别人注意到它们之前，立刻运用 Encapsulate Field将它们封装起来。如果这些classes内含容器类的字段，你应该检查它们是不是得到了恰当的封装；如果没有，就运用Encapsulate Collection把它们封装起来。对于那些不该被其它classes修改的字段，请运用Remove Setting Method。</p><p>然后，找出这些[取值/设值]方法被其它classes运用的地点。尝试以Move Method把那些调用行为搬移到Data Class来。如果无法搬移整个方法，就运用Extract Method产生一个可被搬移的方法。不久之后你就可以运用Hide Method把这些[取值/设值]方法隐藏起来了。</p><p>Data Class就像小孩子。作为一个起点很好，但若要让它们像[成年]的对象那样参与整个系统的工作，它们就必须承担一定责任。</p><h2 id="Refused-Bequest-继承过多-父类里面方法非常多，子类仅仅用有限几个"><a href="#Refused-Bequest-继承过多-父类里面方法非常多，子类仅仅用有限几个" class="headerlink" title="Refused Bequest (继承过多) 父类里面方法非常多，子类仅仅用有限几个"></a>Refused Bequest (继承过多) 父类里面方法非常多，子类仅仅用有限几个</h2><p>Subclasses应该继承superclass的方法和数据。但如果它们不想或不需要继承，又该怎么办呢？它们得到所有礼物，却只从中挑选几样来玩！</p><p>按传统说法，这就意味继承体系设计错误。你需要为这个subclass新建一个兄弟，再运用Push Down Method和Push Down Field把所有用不到的方法下推给那兄弟。这样一来superclass就只持有所有subclasses共享的东西。常常你会听到这样的建议：所有 superclasses都应该是抽象的。</p><p>既然使用[传统说法]这个略带贬义的词，你就可以猜到，我们不建议你这么做，起码不建议你每次都这么做。我们经常利用subclassing手法来复用一些行为，并发现这可以很好地应用于日常工作。这也是一种坏味道，我们不否认，但气味通常并不强烈。所以我们说：如果Refused Bequest引起困惑和问题，请遵循传统忠告。但不必认为你每次都得那么做。十有八九这种坏味道很淡，不值得理睬。</p><p>如果subclass复用了superclass的行为(实现)，却又不愿意支持superclass的接口，Refused Bequest的坏味道就会变得浓烈。拒绝继承superclass的实现，这一点我们不介意；但如果拒绝继承superclass的接口，我们不以为然。不过即使你不愿意继承接口，也不要胡乱修改继承系，你应该运用Replace Inheritance with Delegation来达到目的。</p><h2 id="Comments-过多的注释"><a href="#Comments-过多的注释" class="headerlink" title="Comments (过多的注释)"></a>Comments (过多的注释)</h2><ul><li>解决方法:F2</li></ul><p>别担心，我们并不是说你不该写注释。从嗅觉上说，Comments不是一种坏味道；事实上它们还是一种香味呢。我们之所以要在这里提到Comments，因为人们常把它当作除臭剂来使用。常常会有这样的情况：你看到一段代码有着长长的注释，然后发现，这些注释之所以存在乃是因为代码很糟糕。这种情况的发生次数之多，实在令人吃惊。</p><p>Comments可以带我们找到本章先前提到的各种坏味道。找到坏味道后，我们首先应该以各种重构手法把坏味道去除。完成之后我们常常会发现：注释已经变得多余了，因为代码已经清楚说明了一切。</p><p>如果你需要注释来解释一块代码做了什么，试试Extract Method;如果你需要注释说明某些系统的需求规格，试试Introduce Assertion。</p><p>如果你不知道该做什么，这才是注释的良好运用时机。除了用来记述将来的打算之外，注释还可以用来标记你并无十足把握的区域。你可以在注释里写下自己[为什么做某某事]。这类信息可以帮助将来的修改者，尤其是那些健忘的家伙。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;坏代码的味道&quot;&gt;&lt;a href=&quot;#坏代码的味道&quot; class=&quot;headerlink&quot; title=&quot;坏代码的味道&quot;&gt;&lt;/a&gt;坏代码的味道&lt;/h1&gt;&lt;h2 id=&quot;Duplicated-Code-（重复代码）难维护&quot;&gt;&lt;a href=&quot;#Duplicated-C
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>技术网站</title>
    <link href="http://iwantjingjing.com/2021/01/16/%E6%8A%80%E6%9C%AF%E7%BD%91%E7%AB%99/"/>
    <id>http://iwantjingjing.com/2021/01/16/%E6%8A%80%E6%9C%AF%E7%BD%91%E7%AB%99/</id>
    <published>2021-01-16T00:47:24.096Z</published>
    <updated>2021-01-16T00:47:24.096Z</updated>
    
    <content type="html"><![CDATA[<p>java程序员学技术的网站</p><p><a href="https://www.bilibili.com/" target="_blank" rel="noopener">哔哩哔哩</a><br><a href="https://www.csdn.net/nav/java" target="_blank" rel="noopener">CSDN</a><br><a href="https://juejin.cn/" target="_blank" rel="noopener">掘金</a><br><a href="https://www.jianshu.com/" target="_blank" rel="noopener">简书</a><br><a href="https://www.cnblogs.com/" target="_blank" rel="noopener">博客园</a><br><a href="https://www.imooc.com/" target="_blank" rel="noopener">慕课网</a><br><a href="http://github.com/" target="_blank" rel="noopener">github</a><br><a href="https://gitee.com/" target="_blank" rel="noopener">码云</a><br><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">力扣</a><br><a href="http://www.runoob.com" target="_blank" rel="noopener">菜鸟教程</a><br><a href="https://www.sojson.com/" target="_blank" rel="noopener">JSON在线</a><br><a href="https://tool.lu/" target="_blank" rel="noopener">程序员工具箱</a><br><a href="https://www.oschina.net" target="_blank" rel="noopener">开源中国</a><br><a href="https://www.processon.com" target="_blank" rel="noopener">Processon</a><br><a href="https://ke.qq.com/" target="_blank" rel="noopener">腾讯课堂</a><br><a href="http://tool.chinaz.com/Tools/unixtime.aspx" target="_blank" rel="noopener">时间戳转换</a><br><a href="https://www.w3school.com.cn/" target="_blank" rel="noopener">w3school</a><br><a href="https://stackoverflow.com/" target="_blank" rel="noopener">Stack Overflow</a><br><a href="https://www.lintcode.com/" target="_blank" rel="noopener">领扣</a><br><a href="https://www.v2ex.com/" target="_blank" rel="noopener">V2EX</a><br><a href="https://www.twle.cn/" target="_blank" rel="noopener">简单教程</a><br><a href="https://segmentfault.com/" target="_blank" rel="noopener">思否</a><br><a href="https://www.nowcoder.com/" target="_blank" rel="noopener">牛客网</a><br><a href="https://www.matools.com/api/java8" target="_blank" rel="noopener">java在线中文API</a><br><a href="https://www.zhihu.com/" target="_blank" rel="noopener">知乎</a><br><a href="http://www.kailing.pub/" target="_blank" rel="noopener">KL</a><br><a href="https://www.ituring.com.cn/" target="_blank" rel="noopener">图灵社区</a><br><a href="https://hutool.cn/docs/#/" target="_blank" rel="noopener">Hutool</a><br><a href="https://www.coolshell.cn/" target="_blank" rel="noopener">左耳朵耗子博客</a><br><a href="https://www.coolshell.cn/" target="_blank" rel="noopener">阮一峰的网络日志</a><br><a href="https://gudaoxuri.gitbook.io/microservices-architecture/" target="_blank" rel="noopener">微服务架构设计</a><br><a href="http://mysql.taobao.org/" target="_blank" rel="noopener">阿里云数据库内核月报</a><br><a href="https://tech.meituan.com/" target="_blank" rel="noopener">美团技术</a><br><a href="https://developer.ibm.com/zh/" target="_blank" rel="noopener">IBM技术</a><br><a href="https://iwantjingjing.com/">我想静静</a><br><a href="https://www.infoq.cn/" target="_blank" rel="noopener">infoQ</a><br><a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java程序员学技术的网站&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;哔哩哔哩&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.csdn.net/nav/jav
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Maven构建流程</title>
    <link href="http://iwantjingjing.com/2021/01/16/Maven%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
    <id>http://iwantjingjing.com/2021/01/16/Maven%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/</id>
    <published>2021-01-16T00:47:24.094Z</published>
    <updated>2021-01-16T00:47:24.094Z</updated>
    
    <content type="html"><![CDATA[<p>#构建流程</p><h2 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h2><p>Maven不但有标准化的项目结构，而且还有一套标准化的构建流程，可以自动化实现编译，打包，发布，等等。</p><h2 id="Lifecycle和Phase"><a href="#Lifecycle和Phase" class="headerlink" title="Lifecycle和Phase"></a>Lifecycle和Phase</h2><p>使用Maven时，我们首先要了解什么是Maven的生命周期（lifecycle)</p><p>Maven的生命周期由一系列阶段（phase）构成，以内置的生命周期default为例，它包含以下phase:</p><ul><li>validate </li><li>initialize</li><li>generate-sources</li><li>process-sources</li><li>generate-resources</li><li>process-resources</li><li>compile</li><li>process-classes</li><li>generate-test-sources</li><li>process-test-sources</li><li>generate-test-resources</li><li>process-test-resources</li><li>test-compile</li><li>process-test-classes</li><li>test</li><li>prepare-package</li><li>package</li><li>pre-integration-test</li><li>integration-test</li><li>post-integration-test</li><li>verify</li><li>install</li><li>deploy</li></ul><p>如果我们运行 mvn package, Maven 就会执行default生命周期，它会从开始一直运行到package这个phase为止：</p><ul><li>validate</li><li>…</li><li>package</li></ul><p>如果我们运行mvn compile,Maven也会执行default生命周期，但这次它只会运行到compile,即已下几个phase:</p><ul><li>validate</li><li>…</li><li>package</li></ul><p>Maven的另一个生命周期是clean，它会执行3个phase:</p><ul><li>pre-clean</li><li>clean(注意这个clean不是lifecycle而是phase)</li><li>post-clean</li></ul><p>所以，我们使用mvn这个命令时，后面的参数是phase，Maven自动根据生命周期运行指定的phase</p><p>更复杂的例子是指定多个phase,例如，运行mvn clean package,Maven先执行clean生命周期并运行到clean这个phase，然后执行default生命周期<br>并运行到package这个phase，实际执行的phase如下：</p><ul><li>pre-clean</li><li>clean(注意这个clean是phase)</li><li>validate</li><li>…</li><li>package</li></ul><p>在实际开发过程中，经常使用的命令有：<br> mvn clean:清理所有生成的class和jar;</p><p> mvn clean compile:先清理，再执行compile；</p><p> mvn clean test:先清理，再执行test，因为执行test前必须执行compile，所以这里不必指定compile；</p><p> mvn clean package:先清理，再执行到package。</p><p> 大多数phase在执行过程中，因为我们通常没有在pom.xml中配置相关的设置，所以这些phase什么事情都不做。</p><p> 经常用到的phase其实只有几个：</p><ul><li>clean：清理</li><li>compile： 编译</li><li>test：运行测试</li><li>package：打包</li></ul><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>执行一个phase又会触发一个或多个goal:<br>|执行的Phase| 对应执行的Goal |<br>|:— |:—|<br>|compile | compiler:compile |<br>|test | compiler:testCompile<br>    surefire:test |</p><p>goal的命名总是abc:xyz这种形式。</p><h2 id="lifeCycle、phase、goal类比"><a href="#lifeCycle、phase、goal类比" class="headerlink" title="lifeCycle、phase、goal类比"></a>lifeCycle、phase、goal类比</h2><ul><li>lifeCycle相当于Java的package，它包含一个或多个phase;</li><li>phase相当于Java的class,它包含一个或多个goal；</li><li>goal相当于class的method，它其实才是真正干活的。</li></ul><p>大多数情况下，我们只要指定phase，就默认执行这些phase默认绑定的goal,只有少数情况，我们可以直接指定运行一个goal，例如：启动Tomcat服务器：</p><pre><code>mvn tomcat:run</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Maven通过lifecycle、phase和goal来提供标准的构建流程。</p><p>最常用的构建名利是指定phase，然后让Maven执行到指定的phase：</p><ul><li><p>mvn clean</p></li><li><p>mvn clean compile</p></li><li><p>mvn clean test</p></li><li><p>mvn clean package</p><p>通常情况,我们总是执行phase默认绑定的goal，因此不必指定goal。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#构建流程&lt;/p&gt;
&lt;h2 id=&quot;构建流程&quot;&gt;&lt;a href=&quot;#构建流程&quot; class=&quot;headerlink&quot; title=&quot;构建流程&quot;&gt;&lt;/a&gt;构建流程&lt;/h2&gt;&lt;p&gt;Maven不但有标准化的项目结构，而且还有一套标准化的构建流程，可以自动化实现编译，打包，发布，等
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>OAuth 2.0</title>
    <link href="http://iwantjingjing.com/2021/01/16/OAuth%202.0/"/>
    <id>http://iwantjingjing.com/2021/01/16/OAuth%202.0/</id>
    <published>2021-01-16T00:47:24.094Z</published>
    <updated>2021-01-16T00:47:24.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a><a href="https://oauth.net/2/" target="_blank" rel="noopener">OAuth 2.0</a></h1><p>OAuth 2.0 is the industry-standard protocol for authorization. OAuth 2.0 focuses on client developer simplicity while providing specific authorization flows for web applications, desktop applications, mobile phones, and living room devices. This specification and its extensions are being developed within the IETF OAuth Working Group.</p><p>OAuth2.0是授权的行业标准协议。OAuth2.0关注于客户机开发人员的简单性，同时为web应用程序、桌面应用程序、移动电话和客厅设备提供特定的授权流。本规范及其扩展正在ietf oauth工作组中开发。    </p><p>Questions, suggestions and protocol changes should be discussed on the mailing list.    </p><p>问题、建议和方案变更应在邮件列表中讨论。</p><h2 id="OAuth-2-0-1"><a href="#OAuth-2-0-1" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h2><ul><li><a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">OAuth 2.0 Framework </a> - RFC 6749<ul><li><a href="https://oauth.net/2/scope/" target="_blank" rel="noopener">OAuth Scope</a></li></ul></li><li><a href="">OAuth Grant Types</a><ul><li><a href="">Authorization Code</a></li><li><a href="">PKCE</a></li><li><a href="">Client Credentials</a></li><li><a href="">Device Code</a></li><li><a href="">Refresh Token</a></li><li>Legacy: <a href="">Implicit Flow</a></li><li>Legacy: <a href="">Password Grant</a></li></ul></li><li><a href="">Client Types - Confidential and Public Applications</a>    </li><li><a href="">Bearer Tokens</a> - RFC 6750    </li><li><a href="">Threat Model and Security Considerations</a> - RFC 6819    </li><li><a href="">OAuth Security Best Current Practice</a>    </li></ul><h3 id="Mobile-and-Other-Devices"><a href="#Mobile-and-Other-Devices" class="headerlink" title="Mobile and Other Devices"></a>Mobile and Other Devices</h3><ul><li><a href="">Native Apps</a> - Recommendations for using OAuth with native apps</li><li><a href="">Browser-Based Apps</a> - Recommendations for using OAuth with browser-based apps (e.g. an SPA)</li><li><a href="">Device Authorization Grant</a> - OAuth for devices with no browser or no keyboard</li></ul><h3 id="Token-and-Token-Management"><a href="#Token-and-Token-Management" class="headerlink" title="Token and Token Management"></a>Token and Token Management</h3><h3 id="Discovery-and-Registration"><a href="#Discovery-and-Registration" class="headerlink" title="Discovery and Registration"></a>Discovery and Registration</h3><h3 id="Experimental-and-Draft-Specs"><a href="#Experimental-and-Draft-Specs" class="headerlink" title="Experimental and Draft Specs"></a>Experimental and Draft Specs</h3><h3 id="Related-Specs-and-Extensions"><a href="#Related-Specs-and-Extensions" class="headerlink" title="Related Specs and Extensions"></a>Related Specs and Extensions</h3><h3 id="Community-Resources"><a href="#Community-Resources" class="headerlink" title="Community Resources"></a>Community Resources</h3><h3 id="Protocols-Built-on-OAuth-2-0"><a href="#Protocols-Built-on-OAuth-2-0" class="headerlink" title="Protocols Built on OAuth 2.0"></a>Protocols Built on OAuth 2.0</h3><h3 id="Code-and-Services"><a href="#Code-and-Services" class="headerlink" title="Code and Services"></a>Code and Services</h3><h3 id="OAuth-2-1"><a href="#OAuth-2-1" class="headerlink" title="OAuth 2.1"></a>OAuth 2.1</h3><h3 id="Legacy"><a href="#Legacy" class="headerlink" title="Legacy"></a>Legacy</h3><p>数组交集</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OAuth-2-0&quot;&gt;&lt;a href=&quot;#OAuth-2-0&quot; class=&quot;headerlink&quot; title=&quot;OAuth 2.0&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://oauth.net/2/&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>springboot项目中使用filter无法注入bean采坑</title>
    <link href="http://iwantjingjing.com/2021/01/16/springboot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8filter%E6%97%A0%E6%B3%95%E6%B3%A8%E5%85%A5bean%E9%87%87%E5%9D%91/"/>
    <id>http://iwantjingjing.com/2021/01/16/springboot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8filter%E6%97%A0%E6%B3%95%E6%B3%A8%E5%85%A5bean%E9%87%87%E5%9D%91/</id>
    <published>2021-01-16T00:47:24.094Z</published>
    <updated>2021-01-16T00:47:24.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springboot项目中使用filter无法注入bean采坑"><a href="#springboot项目中使用filter无法注入bean采坑" class="headerlink" title="springboot项目中使用filter无法注入bean采坑"></a>springboot项目中使用filter无法注入bean采坑</h1><h2 id="原因-web容器加载顺序所致"><a href="#原因-web容器加载顺序所致" class="headerlink" title="原因:web容器加载顺序所致"></a>原因:web容器加载顺序所致</h2><p>加载顺序是 listener —&gt; filter —&gt; servlet,当项目启动时，<br>filter先于servlet初始化，而Spring中默认Bean的初始化是在Servlet后进行的,<br>所以会注入失败。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;springboot项目中使用filter无法注入bean采坑&quot;&gt;&lt;a href=&quot;#springboot项目中使用filter无法注入bean采坑&quot; class=&quot;headerlink&quot; title=&quot;springboot项目中使用filter无法注入bean采
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>代码格式配置及使用</title>
    <link href="http://iwantjingjing.com/2021/01/16/%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://iwantjingjing.com/2021/01/16/%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/</id>
    <published>2021-01-16T00:47:24.094Z</published>
    <updated>2021-01-16T00:47:24.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码格式配置及使用方法"><a href="#代码格式配置及使用方法" class="headerlink" title="代码格式配置及使用方法"></a>代码格式配置及使用方法</h1><h2 id="代码格式配置"><a href="#代码格式配置" class="headerlink" title="代码格式配置"></a>代码格式配置</h2><ul><li>下载代码格式化文件huifan.xml</li></ul><pre><code>地址：https://space.dingtalk.com/s/gwHOApBSNQLOA7lEmwPaACBlYTg5YjA3N2VjZGU0NjUzOWFiNjk3YTY5Y2YxYzJkYQ 密码: uy2D下载过期可在钉钉搜索huifan.xml</code></pre><h2 id="设置代码格式"><a href="#设置代码格式" class="headerlink" title="设置代码格式"></a>设置代码格式</h2><pre><code>File  --&gt; Settings --&gt; Editor --&gt; Code Style --&gt; Scheme --&gt; Import Scheme引入下载的huifan.xml，Apply </code></pre><p><img src="http://49.4.55.138:4999/server/../Public/Uploads/2021-01-07/5ff6805c2de64.png" alt="引入格式" title="引入格式"></p><h2 id="设置格式化代码快捷键"><a href="#设置格式化代码快捷键" class="headerlink" title="设置格式化代码快捷键"></a>设置格式化代码快捷键</h2><pre><code>File  --&gt; Settings --&gt; keymap --&gt; 搜索框输入 --&gt; Reformat 设置格式化代码快捷键(可根据自己喜好设置响应快捷键）默认 Ctrl + alt + l在当前类 按键为格式化当前类，在包按快捷键为格式化包在工程按快捷键为格式化整个工程</code></pre><p><img src="http://49.4.55.138:4999/server/../Public/Uploads/2021-01-07/5ff6808e88f8c.png" alt="设置快捷键" title="设置快捷键">    </p><h2 id="代码注释模板"><a href="#代码注释模板" class="headerlink" title="代码注释模板"></a>代码注释模板</h2><h3 id="类注释（会在新建类时生效）"><a href="#类注释（会在新建类时生效）" class="headerlink" title="类注释（会在新建类时生效）"></a>类注释（会在新建类时生效）</h3><pre><code>File  --&gt; Settings --&gt; Editor --&gt; File and Code Templates --&gt; Class 将下面信息填入输入框，apply File  --&gt; Settings --&gt; Editor --&gt; File and Code Templates --&gt; Interface 将下面信息填入输入框，apply File  --&gt; Settings --&gt; Editor --&gt; File and Code Templates --&gt; Enum将下面信息填入输入框，apply File  --&gt; Settings --&gt; Editor --&gt; File and Code Templates --&gt; Record将下面信息填入输入框，apply File  --&gt; Settings --&gt; Editor --&gt; File and Code Templates --&gt; AnnotationType将下面信息填入输入框，apply    #if (${PACKAGE_NAME} &amp;&amp; ${PACKAGE_NAME} != &quot;&quot;)package ${PACKAGE_NAME};#end   #parse(&quot;File Header.java&quot;)   /**    * &lt;b&gt;功能名：${NAME}&lt;/b&gt;&lt;br&gt;    * &lt;b&gt;说明：&lt;/b&gt;&lt;br&gt;    * &lt;b&gt;著作权：&lt;/b&gt; Copyright (C) 2021 HUIFANEDU  CORPORATION&lt;br&gt;    * &lt;b&gt;修改履历：    *    * @author ${YEAR}-${MONTH}-${DAY} xuxiongzi    */   public class ${NAME} {   }    </code></pre><p><img src="http://49.4.55.138:4999/server/../Public/Uploads/2021-01-07/5ff682f0604ab.png" alt="配置类注释" title="配置类注释"></p><p><strong>注意！修改作者名称为自己</strong> </p><h3 id="配置方法注释"><a href="#配置方法注释" class="headerlink" title="配置方法注释"></a>配置方法注释</h3><pre><code>File  --&gt; Settings --&gt; Editor --&gt; Live Templates --&gt; 点击右上角加号添加 --&gt; Live Template </code></pre><p><img src="http://49.4.55.138:4999/server/../Public/Uploads/2021-01-07/5ff6844029658.png" alt=""></p><p><img src="http://49.4.55.138:4999/server/../Public/Uploads/2021-01-07/5ff685c04b0e7.png" alt=""></p><p><img src="http://49.4.55.138:4999/server/../Public/Uploads/2021-01-07/5ff6864b3efc1.png" alt=""></p><h4 id="Template-text-内容"><a href="#Template-text-内容" class="headerlink" title="Template text 内容"></a>Template text 内容</h4><pre><code>** * &lt;b&gt;方法名: &lt;/b&gt; $name$ &lt;br&gt; * &lt;b&gt;说明: &lt;/b&gt;  &lt;br&gt; *$param$ * @return $return$ * &lt;b&gt;修改履历: &lt;/b&gt; * @author $date$ xuxiongzi */</code></pre><h4 id="param脚本内容"><a href="#param脚本内容" class="headerlink" title="param脚本内容"></a>param脚本内容</h4><pre><code>groovyScript(&quot;def result=&apos;&apos;; def params=\&quot;${_1}\&quot;.replaceAll(&apos;[\\\\[|\\\\]|\\\\s]&apos;, &apos;&apos;).split(&apos;,&apos;).toList(); for(i = 0; i &lt; params.size(); i++) {result+=&apos; * @param &apos; + params[i] + ((i &lt; params.size() - 1) ? &apos;\\n&apos; : &apos;&apos;)}; return result&quot;, methodParameters()) </code></pre><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><pre><code>在相应方法上输入/f回车    </code></pre><h3 id="配置自定类注释（配置方法同配置方法注释）"><a href="#配置自定类注释（配置方法同配置方法注释）" class="headerlink" title="配置自定类注释（配置方法同配置方法注释）"></a>配置自定类注释（配置方法同配置方法注释）</h3><p>类模板</p><pre><code>/** * &lt;b&gt;功能名：&lt;/b&gt;$NAME$&lt;br&gt; * &lt;b&gt;说明：&lt;/b&gt;&lt;br&gt; * &lt;b&gt;著作权：&lt;/b&gt; Copyright (C) 2021 HUIFANEDU  CORPORATION&lt;br&gt; * &lt;b&gt;修改履历：&lt;/br&gt; * * @author $date$ xuxiongzi */</code></pre><h2 id="代码规约如何使用"><a href="#代码规约如何使用" class="headerlink" title="代码规约如何使用"></a>代码规约如何使用</h2><ul><li>随时格式化代码（Ctrl + alt + l)</li><li>写完方法后右键使用阿里规约扫描自己代码（修改不符之处）     </li><li>mvn test 或使用maven插件 Test自己代码 </li><li>重启自己项目没问题方可提交代码</li></ul><p><img src="http://49.4.55.138:4999/server/../Public/Uploads/2021-01-07/5ff6895686397.png" alt=""></p><p><img src="http://49.4.55.138:4999/server/../Public/Uploads/2021-01-07/5ff68986eccd3.png" alt=""></p><p>或执行push.sh (yi用户服务为例)<br><img src="http://49.4.55.138:4999/server/../Public/Uploads/2021-01-07/5ff689eae25ad.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码格式配置及使用方法&quot;&gt;&lt;a href=&quot;#代码格式配置及使用方法&quot; class=&quot;headerlink&quot; title=&quot;代码格式配置及使用方法&quot;&gt;&lt;/a&gt;代码格式配置及使用方法&lt;/h1&gt;&lt;h2 id=&quot;代码格式配置&quot;&gt;&lt;a href=&quot;#代码格式配置&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Code Review</title>
    <link href="http://iwantjingjing.com/2021/01/16/Code%20Review/"/>
    <id>http://iwantjingjing.com/2021/01/16/Code%20Review/</id>
    <published>2021-01-16T00:47:24.093Z</published>
    <updated>2021-01-16T00:47:24.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码审查标准及规范"><a href="#代码审查标准及规范" class="headerlink" title="代码审查标准及规范"></a>代码审查标准及规范</h1><h2 id="git-提交标准"><a href="#git-提交标准" class="headerlink" title="git 提交标准"></a>git 提交标准</h2><ul><li><p>mvn test 通过</p></li><li><p>代码格式化通过 (ctrl + alt + l) </p></li><li><p>阿里规约扫描无警告</p></li></ul><h2 id="git-提交前要做的"><a href="#git-提交前要做的" class="headerlink" title="git 提交前要做的"></a>git 提交前要做的</h2><pre><code>0、 git pull 1、 执行代码格式化快捷键 reformat code 2、 在项目根目录执行 mvn test 3、阿里规约扫描</code></pre><h2 id="git提交参考脚本"><a href="#git提交参考脚本" class="headerlink" title="git提交参考脚本"></a>git提交参考脚本</h2><pre><code>#!bin/bashif [ -z &quot;$1&quot; ]then    echo &quot;提交信息不可为空&quot;    exit;figit add -Agit commit -m &quot;$1&quot;git pull# 测试mvn clean testgit pushgit checkout debugginggit pullgit merge V1.0.0 -m &quot;$1&quot;mvn testgit pushgit checkout V1.0.0</code></pre><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a><a href="http://showdoc.huifanayb.cn:4999/web/#/p/9c0423d7da951ea5923f8f381c63a368" target="_blank" rel="noopener">代码规范</a></h2><h2 id="前后端规约"><a href="#前后端规约" class="headerlink" title="前后端规约"></a><a href="http://showdoc.huifanayb.cn:4999/web/#/p/6a57dc10a462d2a8a5cbac0bf402f777" target="_blank" rel="noopener">前后端规约</a></h2><h2 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a><a href="http://showdoc.huifanayb.cn:4999/web/#/p/5247ce95619e723c005451cf0bfcaf6d" target="_blank" rel="noopener">命名风格</a></h2><h2 id="代码格式配置及使用方法"><a href="#代码格式配置及使用方法" class="headerlink" title="代码格式配置及使用方法"></a><a href="http://showdoc.huifanayb.cn:4999/web/#/p/38fef09fc67bec02f52fdc107cde88d7" target="_blank" rel="noopener">代码格式配置及使用方法</a></h2><h2 id="规范特别提示"><a href="#规范特别提示" class="headerlink" title="规范特别提示"></a>规范特别提示</h2><ul><li><p>idea中不可出现爆红    </p></li><li><p>代码格式需标准统一</p></li><li><p>代码中不可出现无用引用包</p></li><li><p>阿里规约不可扫描出现问题</p></li></ul><h2 id="审查方式"><a href="#审查方式" class="headerlink" title="审查方式"></a>审查方式</h2><p>1、项目技术负责人负责自己所属项目代码审查</p><p>2、代码审查总负责人负责抽查项目</p><p>3、项目总负责人每周汇总每个人的代码不规范之处代码及数量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码审查标准及规范&quot;&gt;&lt;a href=&quot;#代码审查标准及规范&quot; class=&quot;headerlink&quot; title=&quot;代码审查标准及规范&quot;&gt;&lt;/a&gt;代码审查标准及规范&lt;/h1&gt;&lt;h2 id=&quot;git-提交标准&quot;&gt;&lt;a href=&quot;#git-提交标准&quot; class=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
