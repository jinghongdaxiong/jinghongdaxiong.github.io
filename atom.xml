<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>I want jing jing</title>
  
  <subtitle>I want jing jing ,Don&#39;t ask me who is jing jing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://iwantjingjing.com/"/>
  <updated>2019-12-08T04:09:37.718Z</updated>
  <id>http://iwantjingjing.com/</id>
  
  <author>
    <name>给予ππ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DevOps简介</title>
    <link href="http://iwantjingjing.com/2019/12/02/DevOps%E7%AE%80%E4%BB%8B/"/>
    <id>http://iwantjingjing.com/2019/12/02/DevOps简介/</id>
    <published>2019-12-02T08:29:09.000Z</published>
    <updated>2019-12-08T04:09:37.718Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/liufei1983/p/7152013.html" target="_blank" rel="noopener">摘抄自</a></p><h1 id="DevOps简介"><a href="#DevOps简介" class="headerlink" title="DevOps简介"></a>DevOps简介</h1><p>DevOps是一个完整的面向IT运维的工作流，以IT自动化以及持续集成（CI）、持续部署（CD）为基础，来优化开发、测试、系统运维等多有环节。</p><h1 id="DevOps的概念"><a href="#DevOps的概念" class="headerlink" title="DevOps的概念"></a>DevOps的概念</h1><p>DevOps一词的来自于Development和Operations的组合，突出重视软件开发人员和运维人员的沟通合作，通过自动化流程来使得软件构建、测试、发布更加快捷、频繁和可靠。</p><p><img src="devops.png" alt><br>DevOps是为了填补开发端和运维端之间的信息鸿沟，改善团队之间的协作关系。不过需要澄清的一点是，从开发到运维，中间还有测试环节。DevOps其实包含了三个部分：开发、测试和运维。</p><p><img src="dev2.png" alt><br>换句话说，DevOps希望做到的是软件产品交付过程中IT工具链的打通，使得各个团队减少时间损耗，更加高效地协同工作。专家们总结出了下面这个DevOps能力图，良好的闭环可以大大增加整体的产出。<br><img src="dev3.png" alt></p><h1 id="历史变革"><a href="#历史变革" class="headerlink" title="历史变革"></a>历史变革</h1><p>由上所述，相信大家对DevOps有了一定的了解。但是除了触及工具链之外，作为文化和技术的方法论，DevOps还需要公司在组织文化上的变革。回顾软件行业的研发模式，可以发现大致有三个阶段：瀑布式开发、敏捷开发、DevOps。</p><p>DevOps早在九年前就有人提出来，但是，为什么这两年才开始受到越来越多的企业重视和实践呢？因为DevOps的发展是独木不成林的，现在有越来越多的技术支撑。微服务架构理念、容器技术使得DevOps的实施变得更加容易，计算能力提升和云环境的发展使得快速开发的产品可以立刻获得更广泛的使用。</p><p>好处是什么？</p><p>DevOps的一个巨大好处就是可以高效交付，这也正好是它的初衷。Puppet和DevOps Research and Assessment (DORA) 主办了2016年DevOps调查报告，根据全球4600位各IT公司的技术工作者的提交数据统计，得出高效公司平均每年可以完成1460次部署。</p><p>与低效组织相比，高效组织的部署频繁200倍，产品投入使用速度快2555倍，服务恢复速度快24倍。在工作内容的时间分配上，低效者要多花22%的时间用在为规划好或者重复工作上，而高效者却可以多花29%的时间用在新的工作上。所以这里的高效不仅仅指公司产出的效率提高，还指员工的工作质量得到提升。</p><p>DevOps另外一个好处就是会改善公司组织文化、提高员工的参与感。员工们变得更高效，也更有满足和成就感；调查显示高效员工的雇员净推荐值（eNPS:employee Net Promoter Score）更高，即对公司更加认同。</p><p>快速部署同时提高IT稳定性。这难道不矛盾吗？</p><p>快速的部署其实可以帮助更快地发现问题，产品被更快地交付到用户手中，团队可以更快地得到用户的反馈，从而进行更快地响应。而且，DevOps小步快跑的形式带来的变化是比较小的，出现问题的偏差每次都不会太大，修复起来也会相对容易一些。</p><p><img src="dev4.png" alt></p><p>因此，认为速度就意味着危险是一种偏见。此外，滞后软件服务的发布也并不一定会完全地避免问题，在竞争日益激烈的IT行业，这反而可能错失了软件的发布时机</p><h1 id="为什么DevOps会兴起？"><a href="#为什么DevOps会兴起？" class="headerlink" title="为什么DevOps会兴起？"></a>为什么DevOps会兴起？</h1><h2 id="条件成熟：技术配套发展"><a href="#条件成熟：技术配套发展" class="headerlink" title="条件成熟：技术配套发展"></a>条件成熟：技术配套发展</h2><p>技术的发展使得DevOps有了更多的配合。早期时，大家虽然意识到了这个问题的，但是苦于当时没有完善丰富的技术工具，是一种“理想很丰满，但是现实很骨感”的情况。DevOps的实现可以基于新兴的容器技术；也可以在自动化运维工具Puppet、SaltStack、Ansible之后的延伸；还可以构建在传统的Cloud Foundry、OpenShift等PaaS厂商之上。</p><h2 id="来自市场的外部需求：这世界变化太快"><a href="#来自市场的外部需求：这世界变化太快" class="headerlink" title="来自市场的外部需求：这世界变化太快"></a>来自市场的外部需求：这世界变化太快</h2><p>IT行业已经越来越与市场的经济发展紧密挂钩，专家们认为IT将会有支持中心变成利润驱动中心。事实上，这个变化已经开始了，这不仅体现在Google、苹果这些大企业中，而且也发生在传统行业中，比如出租车业务中的Uber、酒店连锁行业中的Airbnb、图书经销商Amazon等等。能否让公司的IT配套方案及时跟上市场需求的步伐，在今天显得至关重要。</p><p>DevOps 2016年度报告给出了一个运维成本的计算公式：<br>停机费用成本 = 部署频率 * 版本迭代失败概率 * 平均修复时间 * 断电的金钱损失</p><p>来自团队的内在动力：工程师也需要</p><p>对于工程师而言，他们也是DevOps的受益者。微软资深工程师Scott Hanselman说过“对于开发者而言，最有力的工具就是自动化工具”（The most powerful tool we have as developers is automation）。</p><p>工具链的打通使得开发者们在交付软件时可以完成生产环境的构建、测试和运行；正如Amazon的VP兼CTO Werner Vogels那句让人印象深刻的话：“谁开发谁运行”。（You build it, you run it）</p><h2 id="实现DevOps需要什么？"><a href="#实现DevOps需要什么？" class="headerlink" title="实现DevOps需要什么？"></a>实现DevOps需要什么？</h2><h2 id="硬性要求：工具上的准备"><a href="#硬性要求：工具上的准备" class="headerlink" title="硬性要求：工具上的准备"></a>硬性要求：工具上的准备</h2><p>上文提到了工具链的打通，那么工具自然就需要做好准备。现将工具类型及对应的不完全列举整理如下：</p><ul><li><p>代码管理（SCM）：GitHub、GitLab、BitBucket、SubVersion</p></li><li><p>构建工具：Ant、Gradle、maven</p></li><li><p>自动部署：Capistrano、CodeDeploy</p></li><li><p>持续集成（CI）：Bamboo、Hudson、Jenkins</p></li><li><p>配置管理：Ansible、Chef、Puppet、SaltStack、ScriptRock GuardRail</p></li><li><p>容器：Docker、LXC、第三方厂商如AWS</p></li><li><p>编排：Kubernetes、Core、Apache Mesos、DC/OS</p></li><li><p>服务注册与发现：Zookeeper、etcd、Consul</p></li><li><p>脚本语言：python、ruby、shell</p></li><li><p>日志管理：ELK、Logentries</p></li><li><p>系统监控：Datadog、Graphite、Icinga、Nagios</p></li><li><p>性能监控：AppDynamics、New Relic、Splunk</p></li><li><p>压力测试：JMeter、Blaze Meter、loader.io</p></li><li><p>预警：PagerDuty、pingdom、厂商自带如AWS SNS</p></li><li><p>HTTP加速器：Varnish</p></li><li><p>消息总线：ActiveMQ、SQS</p></li><li><p>应用服务器：Tomcat、JBoss</p></li><li><p>Web服务器：Apache、Nginx、IIS</p></li><li><p>数据库：MySQL、Oracle、PostgreSQL等关系型数据库；cassandra、mongoDB、redis等NoSQL数据库</p></li><li><p>项目管理（PM）：Jira、Asana、Taiga、Trello、Basecamp、Pivotal Tracker<br>在工具的选择上，需要结合公司业务需求和技术团队情况而定。（注：更多关于工具的详细介绍可以参见此文：51 Best DevOps Tools for #DevOps Engineers）</p></li></ul><h2 id="软性需求：文化和人"><a href="#软性需求：文化和人" class="headerlink" title="软性需求：文化和人"></a>软性需求：文化和人</h2><p>DevOps成功与否，公司组织是否利于协作是关键。开发人员和运维人员可以良好沟通互相学习，从而拥有高生产力。并且协作也存在于业务人员与开发人员之间。</p><p>出席了2016年伦敦企业级DevOps峰会的ITV公司在2012年就开始落地DevOps，其通用平台主管Clark在接受了InfoQ的采访，在谈及成功时表示，业务人员非常清楚他们希望在最小化可行产品中实现什么，工程师们就按需交付，不做多余工作。</p><p>这样，工程师们使用通用的平台（即打通的工具链）得到更好的一致性和更高的质量。此外，DevOps对工程师个人的要求也提高了，很多专家也认为招募到优秀的人才也是一个挑战。</p><h2 id="DevOps的采用现状"><a href="#DevOps的采用现状" class="headerlink" title="DevOps的采用现状"></a>DevOps的采用现状</h2><h3 id="哪些公司在用？"><a href="#哪些公司在用？" class="headerlink" title="哪些公司在用？"></a>哪些公司在用？</h3><p>DevOps正在增长，尤其是在大企业中：调查发现，DevOps的接受度有了显著提高。74%的受访者已经接受了DevOps，而去年这一比例为66%。目前，在81%的大企业开始接受DevOps，中小企业的接受度仅为70%。<br>那么具体而言都有些公司在采用DevOps呢？Adobe、Amazon、Apple、Airbnb、Ebay、Etsy、Facebook、LinkedIn、Netflix、NASA、Starbucks、Target（泛欧实时全额自动清算系统）、Walmart、Sony等等。</p><h3 id="他们怎么实施的？"><a href="#他们怎么实施的？" class="headerlink" title="他们怎么实施的？"></a>他们怎么实施的？</h3><p>首先，大企业正在自下而上接受DevOps，其中业务单位或部门（31%）以及项目和团队（29%）已经实施DevOps。不过，只有21%的大企业在整个公司范围内采用了DevOps。 </p><p>其次，在工具层面上，DevOps工具的用量大幅激增。Chef和Puppet依然是最常用的DevOps工具，使用率均为32%。Docker是年增长率最快的工具，用量增长一倍以上。Ansible的用量也有显著增加，使用率从10%翻倍至20%。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/liufei1983/p/7152013.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;摘抄自&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;DevOps简介&quot;&gt;&lt;a href=&quot;#DevOps
      
    
    </summary>
    
    
      <category term="开发模式" scheme="http://iwantjingjing.com/categories/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="DevOps" scheme="http://iwantjingjing.com/tags/DevOps/"/>
    
      <category term="开发模式，摘抄" scheme="http://iwantjingjing.com/tags/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%91%98%E6%8A%84/"/>
    
  </entry>
  
  <entry>
    <title>读别让自己墙了自己有感</title>
    <link href="http://iwantjingjing.com/2019/12/02/%E8%AF%BB%E5%88%AB%E8%AE%A9%E8%87%AA%E5%B7%B1%E5%A2%99%E4%BA%86%E8%87%AA%E5%B7%B1%E6%9C%89%E6%84%9F/"/>
    <id>http://iwantjingjing.com/2019/12/02/读别让自己墙了自己有感/</id>
    <published>2019-12-02T05:38:44.000Z</published>
    <updated>2019-12-02T06:42:22.836Z</updated>
    
    <content type="html"><![CDATA[<p> <a href="https://coolshell.cn/articles/20276.html/comment-page-2#comments" target="_blank" rel="noopener">文章链接</a></p><h1 id="收获的主题"><a href="#收获的主题" class="headerlink" title="收获的主题"></a>收获的主题</h1><ul><li><p>只专注于一种技术其他都是垃圾（不要将自己的技术栈封闭起来）</p></li><li><p>关注负面的东西不要胜过正面的东西</p></li><li><p>离开Java的世界就基本上做不了架构了</p></li><li><p>把自己最宝贵的时间用在了很烂的项目上，就算能用一些新技术也只能是自娱自乐，在实验室中玩玩罢了</p></li><li><p>把自己的技术栈封闭起来，直接放弃了这个时代最具有工业化的技术Java，对于一个好的程序员来说同时掌握几种语言和技术是完全没有问题的，不要自己封闭了自己的视野</p></li><li><p>视野、环境和舞台对一个人的限制是非常大的。井蛙不知大海，被空间维度所限制；夏虫不知冬天，被时间维度所限制；圈养的动物没有斗志，是被自己意志所限制。</p></li><li><p>偏见和不开放，对一个人限制是真正有毁灭性的。主动让自己成为一个瞎子和聋子，主动把自己能力阉割掉是多么让人痛心的一件事。</p></li><li><p>不限制自己的人会穷举各种方法来解决问题，限制自己的人，会找各式各样的问题或借口。</p></li><li><p>不限制自己的人，会努力改变自己的问题和缺陷，限制自己的人会放任自己。</p></li><li><p>先把软件设计好再写代码。</p><h1 id="技术方向"><a href="#技术方向" class="headerlink" title="技术方向"></a>技术方向</h1></li><li><p>Docker、go、k8s</p></li><li><p>翻找Youtube的各种大会，GitHub的各种issue和pull request</p></li><li><p>成为一个技术牛人的条件：基础知识过硬，细节扎得深，面很广，学习能力强，有英文能力，逻辑思维能力不错，非常的自律，执行力也很强，抓得住重点,最重要的一点：在大公司历练过。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></li><li><p>做高价值的事。所谓高价值，就是：别人愿付高价的，高技术门槛的，有创造力的，颠覆性的……</p></li><li><p>扩大自己的眼界，开放自己的内心。你的英文语言能力对你能不能融入世界是起决定性的作用。你的视野决定了你知不知道要去哪，你的开放决定了你想不想去。</p></li><li><p>站在更高的维度.面的维度会超过点的维度，空间的维度会超过面的维度，在更高维度上思考和学习，你会收货更多。整天在焦虑那些低维度的事（比如自己的薪水、工作的地点、稳不稳定、有没有户口……)，只会让你变得越来越平庸，只要你站在更高的维度（比如：眼界有没有扩大、可能性是不是更多、竞争力是不是更强、能不能解决更大更难的问题、能创造多大的价值……)，时间会让你明白那些低维度的东西全都不是事儿。技术学习上也一样，站在学习编程语法特性的维度和站在学习编程范式、设计模式的维度是两种完全不一样的学习方式。</p></li><li><p>精于计算得失。很多人其实不是很懂计算。绝大多数人都是在计算自己会失去多少，而不会算得到多少。而一般的人也总是在算短期内会失去什么，优秀的则总是会算我投入后未来会有什么样的回报，前者在算计今天，目光短浅，而后者则是舍在今天，得在明天，计算的是未来。精于计算得失的，就懂得什么是投资，不懂的只会投机。对于赚钱，你可以投机，但是对于自己最好还是投资。</p></li><li><p>勇于跳出传统的束缚。做”鸡”的比”二奶”好多了</p></li><li><p>别自己墙了自己，人最可悲的就是自己限制自己，想都不敢想！</p><p>庄子曰过：</p><p> 井蛙不可以语于海者，拘于虚也；//空间局限</p><p> 夏虫不可以语于冰者，笃于时也；//时间局限</p><p> 曲士不可以语于道者，束于教也。//认识局限</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;a href=&quot;https://coolshell.cn/articles/20276.html/comment-page-2#comments&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章链接&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;收获的主题&quot;&gt;&lt;a
      
    
    </summary>
    
    
    
      <category term="读后感，左耳" scheme="http://iwantjingjing.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F%EF%BC%8C%E5%B7%A6%E8%80%B3/"/>
    
  </entry>
  
  <entry>
    <title>杀威棍</title>
    <link href="http://iwantjingjing.com/2019/10/06/%E6%9D%80%E5%A8%81%E6%A3%8D/"/>
    <id>http://iwantjingjing.com/2019/10/06/杀威棍/</id>
    <published>2019-10-06T08:06:05.000Z</published>
    <updated>2019-10-06T08:13:39.634Z</updated>
    
    <content type="html"><![CDATA[<p>《说唐》里秦叔宝进牢房时,衙役喊得一句话来解释:<br>“进的牢来先打你一百杀威棍,看你老不老实!”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《说唐》里秦叔宝进牢房时,衙役喊得一句话来解释:&lt;br&gt;“进的牢来先打你一百杀威棍,看你老不老实!”&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="传统文化" scheme="http://iwantjingjing.com/tags/%E4%BC%A0%E7%BB%9F%E6%96%87%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>gpg是什么  </title>
    <link href="http://iwantjingjing.com/2019/09/28/gpg%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://iwantjingjing.com/2019/09/28/gpg是什么/</id>
    <published>2019-09-28T12:41:03.000Z</published>
    <updated>2019-09-28T12:42:35.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GPG简介"><a href="#GPG简介" class="headerlink" title="GPG简介"></a>GPG简介</h1><p>　　GPG是GNU Privacy Guard的缩写，它是一种基于密钥的加密方式，使用了一对密钥对消息进行加密和解密，来保证消息的安全传输。<br>　　GPG有许多用途，主要用于文件加密。yum安装软件包的时候会使用gpg来验证。</p><h2 id="1、大多数的linux发行版都默认包含了gpg"><a href="#1、大多数的linux发行版都默认包含了gpg" class="headerlink" title="1、大多数的linux发行版都默认包含了gpg"></a>1、大多数的linux发行版都默认包含了gpg</h2><pre><code># gpg --version</code></pre><h2 id="2、gpg常用命令"><a href="#2、gpg常用命令" class="headerlink" title="2、gpg常用命令"></a>2、gpg常用命令</h2><pre><code>创建密钥 $ gpg --gen-key查看公钥 $ gpg --list-key查看私钥 $ gpg --list-secret-key公钥删除 $ gpg --delete-keys 标识名私钥删除 $ gpg --delete-secret-keys 标识名公钥导出 $ gpg --export 标识名 &gt; 导出文件名（多以gpg,asc为文件后缀）私钥导出 $ gpg --export-secret-key 标识名 &gt; 导出文件名（多以asc为文件后缀）密钥导入 $ gpg --import 密钥文件加密文件 $ gpg --recipient 标识名 --encrypt 文件名解密文件 $ gpg --output 新文件名 --decrypt 加密文件名修改密钥 $ gpg --edit-key 标识名</code></pre><h2 id="3、gpg加密和ssh加密的区别"><a href="#3、gpg加密和ssh加密的区别" class="headerlink" title="3、gpg加密和ssh加密的区别"></a>3、gpg加密和ssh加密的区别</h2><p>ssh加密是专们为远程登录和其他网络服务，如ftp 提供安全的一个软件<br>gpg是用来加密文件的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GPG简介&quot;&gt;&lt;a href=&quot;#GPG简介&quot; class=&quot;headerlink&quot; title=&quot;GPG简介&quot;&gt;&lt;/a&gt;GPG简介&lt;/h1&gt;&lt;p&gt;　　GPG是GNU Privacy Guard的缩写，它是一种基于密钥的加密方式，使用了一对密钥对消息进行加密和解密
      
    
    </summary>
    
    
      <category term="gpg" scheme="http://iwantjingjing.com/categories/gpg/"/>
    
    
      <category term="gpg" scheme="http://iwantjingjing.com/tags/gpg/"/>
    
  </entry>
  
  <entry>
    <title>论语学习</title>
    <link href="http://iwantjingjing.com/2019/09/28/%E8%AE%BA%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    <id>http://iwantjingjing.com/2019/09/28/论语学习/</id>
    <published>2019-09-28T09:51:05.000Z</published>
    <updated>2019-09-28T12:31:51.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习地址"><a href="#学习地址" class="headerlink" title="学习地址"></a>学习地址</h1><p><a href="https://mooc1.chaoxing.com/ztnodedetailcontroller/visitnodedetail?courseId=201598687&knowledgeId=124210600&_from_=" target="_blank" rel="noopener">超星尔雅</a></p><h1 id="第一讲孔子思想的特色"><a href="#第一讲孔子思想的特色" class="headerlink" title="第一讲孔子思想的特色"></a>第一讲孔子思想的特色</h1><p>温和的理性主义</p><p>深刻的人道情怀</p><p>乐观的人生理想</p><h1 id="第二讲学儿篇"><a href="#第二讲学儿篇" class="headerlink" title="第二讲学儿篇"></a>第二讲学儿篇</h1><p>学而时习之(从学习中发现快乐)</p><p>时:适当的时候</p><p>学了做人处事的道理适当的时候加以练习运用</p><p>人同此心,心同此理</p><p>学习的内容: 五经与六艺</p><p>学习的方法: 学思并用</p><p>学习的目的: 培养德行</p><p>不迁怒 不贰过</p><p>朋友由来<br>同门曰朋<br>同志曰友</p><p>儒家:不反对情绪,但需要做情绪管理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;学习地址&quot;&gt;&lt;a href=&quot;#学习地址&quot; class=&quot;headerlink&quot; title=&quot;学习地址&quot;&gt;&lt;/a&gt;学习地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://mooc1.chaoxing.com/ztnodedetailcontroller/vis
      
    
    </summary>
    
    
      <category term="传统文化" scheme="http://iwantjingjing.com/categories/%E4%BC%A0%E7%BB%9F%E6%96%87%E5%8C%96/"/>
    
    
      <category term="传统文化" scheme="http://iwantjingjing.com/tags/%E4%BC%A0%E7%BB%9F%E6%96%87%E5%8C%96/"/>
    
      <category term="论语" scheme="http://iwantjingjing.com/tags/%E8%AE%BA%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>持续集成服务 Travis CI</title>
    <link href="http://iwantjingjing.com/2019/09/27/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%9C%8D%E5%8A%A1-Travis-CI/"/>
    <id>http://iwantjingjing.com/2019/09/27/持续集成服务-Travis-CI/</id>
    <published>2019-09-27T07:27:00.000Z</published>
    <updated>2019-09-28T12:31:51.431Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.travis-ci.org/dashboard" target="_blank" rel="noopener">官网</a><br><a href="https://liusir.me/2019/09/21/hexo-基于TravisCI实现hexo博客持续继承" target="_blank" rel="noopener">参考</a><br><a href="http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.travis-ci.org/dashboard&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://liusir.me/2019/09/21/hexo-基于Travi
      
    
    </summary>
    
    
      <category term="TravisCI" scheme="http://iwantjingjing.com/categories/TravisCI/"/>
    
    
      <category term="TravisCI" scheme="http://iwantjingjing.com/tags/TravisCI/"/>
    
  </entry>
  
  <entry>
    <title>springmvc在controller方法里面跳转外网的方法  </title>
    <link href="http://iwantjingjing.com/2019/09/27/springmvc%E5%9C%A8controller%E6%96%B9%E6%B3%95%E9%87%8C%E9%9D%A2%E8%B7%B3%E8%BD%AC%E5%A4%96%E7%BD%91%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://iwantjingjing.com/2019/09/27/springmvc在controller方法里面跳转外网的方法/</id>
    <published>2019-09-27T07:17:15.000Z</published>
    <updated>2019-09-28T12:31:51.428Z</updated>
    
    <content type="html"><![CDATA[<p>1.return new ModelAndView(new RedirectView(“<a href="https://www.baidu.com&quot;" target="_blank" rel="noopener">https://www.baidu.com&quot;</a>));</p><p>2.return  “redirect:<a href="https://www.baidu.com/&quot;" target="_blank" rel="noopener">https://www.baidu.com/&quot;</a>;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.return new ModelAndView(new RedirectView(“&lt;a href=&quot;https://www.baidu.com&amp;quot;&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.baidu.com&amp;qu
      
    
    </summary>
    
    
      <category term="spring" scheme="http://iwantjingjing.com/categories/spring/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="spring" scheme="http://iwantjingjing.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>如何培养孩子的逻辑思维</title>
    <link href="http://iwantjingjing.com/2019/09/27/%E5%A6%82%E4%BD%95%E5%9F%B9%E5%85%BB%E5%AD%A9%E5%AD%90%E7%9A%84%E9%80%BB%E8%BE%91%E6%80%9D%E7%BB%B4/"/>
    <id>http://iwantjingjing.com/2019/09/27/如何培养孩子的逻辑思维/</id>
    <published>2019-09-27T03:03:57.000Z</published>
    <updated>2019-09-28T12:31:51.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逻辑思维能力重要吗？"><a href="#逻辑思维能力重要吗？" class="headerlink" title="逻辑思维能力重要吗？"></a>逻辑思维能力重要吗？</h1><p>答案必然是肯定的，因为它不仅是学好数学必须具备的能力，同时也是学好其他学科，处理日常生活问题所必须具备的能力。</p><p>换句话说就是：逻辑思维，其可以成为“做好任何事情”的必要条件.</p><h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p>它是一种人类思维的高级形式，即我们所说的“抽象思维”。而一个人想具备很强的逻辑思维能力，往往需要从小开始培养。</p><h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>肥宅以为:逻辑思维就是智商最重要的方面之一,甚至之一也可以去掉.</p><h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>美国的很多学校，他们从学前班开始就有关于训练孩子逻辑思维能力的数学内容</p><p>但在国内，我们对孩子逻辑思维的培养还存在一定的误区，学校往往喜欢让学生做题，找到考试的捷径，却忽视了对数学本质的讲解。</p><p>所以当我们没有将数学应用在生活中，这些定理和公式也会随着时间的流逝慢慢被淡忘。</p><p>所以将数学应用在生活中也就是锻炼逻辑思维的必要过程</p><h2 id="那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。"><a href="#那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。" class="headerlink" title="那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。"></a>那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。</h2><h3 id="动作思维阶段（0-3岁）"><a href="#动作思维阶段（0-3岁）" class="headerlink" title="动作思维阶段（0-3岁）"></a>动作思维阶段（0-3岁）</h3><p>不到3岁的孩子以动作思维为主，思维在动作中进行。比如桌上放着一个苹果，宝宝矮小够不着，怎么办呢?这时候宝宝发现他旁边有凳子，于是把凳子搬过来，自己爬上去，成功地把苹果拿到手。<br>孩子学会借助别的东西来达到自己的目的，是从不断的操作过程中理解的。 孩子最初的动作往往是杂乱无章、漫无目的的，以后在不断的操作过程中了解了动作与结果之间的关系。</p><h3 id="具体形象思维阶段（3-6岁）"><a href="#具体形象思维阶段（3-6岁）" class="headerlink" title="具体形象思维阶段（3-6岁）"></a>具体形象思维阶段（3-6岁）</h3><p>3-6岁的孩子具体形象思维占优势，他们缺少立体感和空间感。这也是为什么用数字加减，孩子反应不过来，但是用实物举例子，就容易理解。<br>在这个阶段，家长要注意增加孩子的经验，丰富孩子的词汇，多给孩子动手的机会。有些家长和老师片面地、刻板地教孩子多识字、写字、计算等，对孩子的思维发展并没有好处。</p><h3 id="抽象逻辑思维能力（6-11岁）"><a href="#抽象逻辑思维能力（6-11岁）" class="headerlink" title="抽象逻辑思维能力（6-11岁）"></a>抽象逻辑思维能力（6-11岁）</h3><p>6-11岁是培养孩子抽象逻辑思维能力的关键时期。在这一时期要培养孩子正确的思维程序和科学的思维方法。</p><p>比如，一只狗有4条腿，两只狗有8条腿，三只狗有多少条腿?像这些问题，就是属于抽象逻辑思维能力题。家长要注意让孩子学会独立思考，不要给孩子现成的答案。    </p><h2 id="那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。"><a href="#那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。" class="headerlink" title="那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。"></a>那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。</h2><h3 id="一、丰富孩子的词汇，教孩子说话用词达意"><a href="#一、丰富孩子的词汇，教孩子说话用词达意" class="headerlink" title="一、丰富孩子的词汇，教孩子说话用词达意"></a>一、丰富孩子的词汇，教孩子说话用词达意</h3><p>语言是思维的外壳，尽早教孩子准确用词，不但能防止别人曲解、误解他的意思，而且促使他思维活跃、思路清晰。家长对孩子的话要多问几个为什么，对他的表达要多作分析，这可以使孩子用词准确、鲜明、生动。    </p><h3 id="二、有意识地对孩子设疑，给孩子留下思考的时间"><a href="#二、有意识地对孩子设疑，给孩子留下思考的时间" class="headerlink" title="二、有意识地对孩子设疑，给孩子留下思考的时间"></a>二、有意识地对孩子设疑，给孩子留下思考的时间</h3><p>孩子回答问题往往是凭直觉，如果家长满足于孩子的这点“小聪明”，那么，他们会习惯对问题不假思索地做出回答，没有足够的时间让大脑启动思维“程序”。</p><p>所以，当孩子遇到问题的时候，家长最好不要急于让他说答案，而是让他多问几个为什么，多想几种解决的方案，多几次对自己的否定，然后在否定中寻找最佳答案。</p><h3 id="三、利用游戏促进孩子思维能力的发展"><a href="#三、利用游戏促进孩子思维能力的发展" class="headerlink" title="三、利用游戏促进孩子思维能力的发展"></a>三、利用游戏促进孩子思维能力的发展</h3><p>在日常生活中，可以进行分类和归类的游戏。也可以进行比较动、植物或其他事物、训练理解力和创造力的游戏等。</p><p>比如收衣服时，让孩子将不同的袜子分类卷起来；去动物园时，告诉孩子如何通过牙齿区别食草和食肉的动物，并让他分辨；给孩子一些零钱，让孩子去买东西……</p><p>对孩子而言，说过的话，玩过的游戏或许会忘记，但日复一日默默培养起来的逻辑思维能力会伴随他们终身，使他们在生活和工作中表现得更为优秀出色。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;逻辑思维能力重要吗？&quot;&gt;&lt;a href=&quot;#逻辑思维能力重要吗？&quot; class=&quot;headerlink&quot; title=&quot;逻辑思维能力重要吗？&quot;&gt;&lt;/a&gt;逻辑思维能力重要吗？&lt;/h1&gt;&lt;p&gt;答案必然是肯定的，因为它不仅是学好数学必须具备的能力，同时也是学好其他学科，
      
    
    </summary>
    
    
      <category term="育儿" scheme="http://iwantjingjing.com/categories/%E8%82%B2%E5%84%BF/"/>
    
    
      <category term="育儿" scheme="http://iwantjingjing.com/tags/%E8%82%B2%E5%84%BF/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 核心注解</title>
    <link href="http://iwantjingjing.com/2019/09/25/Spring-Boot-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3/"/>
    <id>http://iwantjingjing.com/2019/09/25/Spring-Boot-核心注解/</id>
    <published>2019-09-25T06:00:45.000Z</published>
    <updated>2019-09-28T12:31:51.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p>我看你上面写了熟悉 Spring Boot，那你能讲下为什么我们要用 Spring Boot 吗？</p><h1 id="下面我列几个最常见的三个回答："><a href="#下面我列几个最常见的三个回答：" class="headerlink" title="下面我列几个最常见的三个回答："></a>下面我列几个最常见的三个回答：</h1><h2 id="A：Spring-Boot-最主要是不用-XML-配置，可以用-Java-来配置-bean，省去了许多配置文件。"><a href="#A：Spring-Boot-最主要是不用-XML-配置，可以用-Java-来配置-bean，省去了许多配置文件。" class="headerlink" title="A：Spring Boot 最主要是不用 XML 配置，可以用 Java 来配置 bean，省去了许多配置文件。"></a>A：Spring Boot 最主要是不用 XML 配置，可以用 Java 来配置 bean，省去了许多配置文件。</h2><p>我又问：Spring 本身就可以用 Java 配置代替 XML 配置，和 Spring Boot 有什么关系呢？</p><p>然后对方就吱吱唔唔了……</p><h2 id="B：Spring-Boot-我们用来做-Spring-Cloud-微服务。"><a href="#B：Spring-Boot-我们用来做-Spring-Cloud-微服务。" class="headerlink" title="B：Spring Boot 我们用来做 Spring Cloud 微服务。"></a>B：Spring Boot 我们用来做 Spring Cloud 微服务。</h2><p>我又问：微服务和 Spring Boot 有什么关系？不用 Spring Boot 行不行？</p><p>然后对方就吱吱唔唔了……</p><h2 id="C：Spring-Boot-可以打-jar-包部署，内部集成了Tomcat。"><a href="#C：Spring-Boot-可以打-jar-包部署，内部集成了Tomcat。" class="headerlink" title="C：Spring Boot 可以打 jar 包部署，内部集成了Tomcat。"></a>C：Spring Boot 可以打 jar 包部署，内部集成了Tomcat。</h2><p>这个确实是 Spring Boot 的特色，但是我还是觉得没有答到关键点上。</p><p>然后我继续问，如果不考虑打 jar 包部署呢，然后就没然后了……</p><h1 id="为什么我们要用-Spring-Boot，显然上面三个求职者没有答到关键点上，Spring-Boot-最重要的功能是：自动配置。"><a href="#为什么我们要用-Spring-Boot，显然上面三个求职者没有答到关键点上，Spring-Boot-最重要的功能是：自动配置。" class="headerlink" title="为什么我们要用 Spring Boot，显然上面三个求职者没有答到关键点上，Spring Boot 最重要的功能是：自动配置。"></a>为什么我们要用 Spring Boot，显然上面三个求职者没有答到关键点上，Spring Boot 最重要的功能是：自动配置。</h1><h2 id="为什么说是自动配置？"><a href="#为什么说是自动配置？" class="headerlink" title="为什么说是自动配置？"></a>为什么说是自动配置？</h2><p>Spring Boot 的开启注解是：@SpringBootApplication，其实它就是由下面三个注解组成的：</p><pre><code>@Configuration@ComponentScan@EnableAutoConfiguration</code></pre><p>上面三个注解，前面两个都是 Spring 自带的，和 Spring Boot 无关，所以说上面的回答的不是在点上。</p><p>所以说 Spring Boot 最最核心的就是这个 <strong>@EnableAutoConfiguration</strong> 注解了，它能根据类路径下的 jar 包和配置动态加载配置和注入bean。</p><p>举个例子，比如我在 lib 下放一个 druid 连接池的 jar 包，然后在 application.yml 文件配置 druid 相关的参数，Spring Boot 就能够自动配置所有我们需要的东西，如果我把 jar 包拿掉或者把参数去掉，那 Spring Boot 就不会自动配置。</p><p>这样我们就能把许多功能做成公共的自动配置的启动器（starters），其实 druid 连接池就是这么做的，它提供了针对 Spring Boot 的启动器：druid-spring-boot-starter。</p><p>有了这个自动配置的启动器，我们就能非常简单的使用它，</p><p>先添加 jar 包依赖：</p><pre><code>&lt;dependency&gt;   &lt;groupId&gt;com.alibaba&lt;/groupId&gt;   &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;   &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;    </code></pre><p>再添加相关参数：</p><pre><code>spring.datasource.url= spring.datasource.username=spring.datasource.password=……</code></pre><p>如果是传统的项目，我们要自己手动写一大堆的配置，而且还不灵活，有了这个启动器，我们就可以做到简单集成。具体大家可以看 druid-spring-boot-starter 是怎么实现的。</p><p>所以，这才是 Spring Boot 的核心，这才是我们为什么使用 Spring Boot 的原因。如果答不到这个关键点，那真没有掌握到 Spring Boot 的核心所在。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h1&gt;&lt;p&gt;我看你上面写了熟悉 Spring Boot，那你能讲下为什么我们要用 Spring Boot 吗？&lt;/p&gt;
&lt;h1 id=&quot;下面我列
      
    
    </summary>
    
    
      <category term="Java" scheme="http://iwantjingjing.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="Spring" scheme="http://iwantjingjing.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Javac原理</title>
    <link href="http://iwantjingjing.com/2019/09/25/Javac%E5%8E%9F%E7%90%86/"/>
    <id>http://iwantjingjing.com/2019/09/25/Javac原理/</id>
    <published>2019-09-25T02:57:37.000Z</published>
    <updated>2019-09-28T12:31:51.419Z</updated>
    
    <content type="html"><![CDATA[<p>从Sun Javac的代码来看，编译过程大致可以分为3个过程:</p><ol><li>解析与填充符号表过程。</li><li>插入式注解处理器的注解处理过程。</li><li>分析与字节码生成过程。<br><img src="j.jpg" alt><br>Javac编译动作的入口是com.sun.tools.javac.main.JavaCompiler类，上述3个过程的代码逻辑集中在这个类的compile()和compile2()方法中，整个编译最关键的处理就由图中标注的8个方法来完成，下面我们具体看一下这8个方法实现了什么功能。<br><img src="f.jpg" alt></li></ol><h1 id="解析与填充符号表"><a href="#解析与填充符号表" class="headerlink" title="解析与填充符号表"></a>解析与填充符号表</h1><p>解析步骤由上图中的parseFiles（）方法（过程1.1）完成，解析步骤包括了经典程序编译原理中的词法分析和语法分析两个过程。</p><h2 id="词法、语法分析"><a href="#词法、语法分析" class="headerlink" title="词法、语法分析"></a>词法、语法分析</h2><p>词法分析是<strong>将源代码的字符流转变为标记（Token）集合</strong>，<strong>单个字符</strong>是<strong>程序编写过程</strong>的最小元素，而<strong>标记</strong>则是<strong>编译过程</strong>的最小元素，关键字、变量名、字面量、运算符都可以成为标记，如“int a=b+2”这句代码包含了6个标记，分别是int、a、=、b、+、2，虽然关键字int由3个字符构成，但是它只是一个Token，不可再拆分。在Javac的源码中，词法分析过程由com.sun.tools.javac.parser.Scanner类来实现。</p><p>语法分析是<strong>根据Token序列构造抽象语法树的过程</strong>，抽象语法树（Abstract Syntax Tree,AST）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构（Construct），例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。</p><p>在Javac的源码中，语法分析过程由com.sun.tools.javac.parser.Parser类实现，这个阶段产出的抽象语法树由com.sun.tools.javac.tree.JCTree类表示，<strong>经过这个步骤之后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在抽象语法树之上</strong>。</p><h2 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h2><p>完成了语法分析和词法分析之后，下一步就是填充符号表的过程，也就是enterTrees（）方法（过程1.2）所做的事情。符号表（Symbol Table）<strong>是由一组符号地址和符号信息构成的表格</strong>，可以把它想象成哈希表中K-V值对的形式（实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等）。符号表中所登记的信息在编译的不同阶段都要用到<br>。<strong>在语义分析中，符号表所登记的内容将用于语义检查</strong>（如检查一个名字的使用和原先的说明是否一致）和<strong>产生中间代码</strong>。在目标代码生成阶段，当对符号名进行地址分配时，<strong>符号表是地址分配的依据。</strong></p><p>在Javac源代码中，填充符号表的过程由com.sun.tools.javac.comp.Enter类实现，此过程的出口是一个待处理列表（To Do List），包含了每一个编译单元的抽象语法树的顶级节点，以及package-info.java（如果存在的话）的顶级节点。</p><h1 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h1><p>在Javac源码中，<em>插入</em>式注解处理器的<em>初始化</em>过程是在<br>initPorcessAnnotations（）方法中完成的，而它的<em>执行过程</em>则是在processAnnotations（）方法中完成的，<br>这个方法判断是否还有新的注解处理器需要执行，如果有的话，通过com.sun.tools.javac.processing.JavacProcessingEnvironment类的doProcessing（）方法生成一个新的JavaCompiler对象对编译的后续步骤进行处理。</p><p>在JDK 1.5之后，Java语言提供了对注解（Annotation）的支持，这些注解与普通的Java代码一样，是在运行期间发挥作用的。在JDK 1.6中实现了JSR-269规范JSR-269：Pluggable Annotations Processing API（插入式注解处理API）。提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，我们可以把它看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round，也就是第一张图中的回环过程。 有了编译器注解处理的标准API后，我们的代码才有可能干涉编译器的行为，由于语法树中的任意元素，甚至包括代码注释都可以在插件之中访问到，所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间。只要有足够的创意，程序员可以使用插入式注解处理器来实现许多原本只能在编码中完成的事情。</p><p>我们知道编译器在把Java程序源码编译为字节码的时候，会对Java程序源码做各方面的检查校验。这些校验主要以程序“写得对不对”为出发点，虽然也有各种WARNING的信息，但总体来讲还是较少去校验程序“写得好不好”。有鉴于此，业界出现了许多针对程序“写得好不好”的辅助校验工具，如CheckStyle、FindBug、Klocwork等。这些代码校验工具有一些是基于Java的源码进行校验，还有一些是通过扫描字节码来完成。我们将会使用注解处理器API来编写一款拥有自己编码风格的校验工具：NameCheckProcessor。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>要通过注解处理器API实现一个编译器插件，首先需要了解这组API的一些基本知识。我们实现注解处理器的代码需要继承抽象类javax.annotation.processing.AbstractProcessor，这个抽象类中只有一个必须覆盖的abstract方法：“process（）”，它是Javac编译器在执行注解处理器代码时要调用的过程，我们可以从这个方法的第一个参数“annotations”中获取到此注解处理器所要处理的注解集合，从第二个参数“roundEnv”中访问到当前这个Round中的语法树节点，每个语法树节点在这里表示为一个Element。在JDK 1.6新增的javax.lang.model包中定义了16类Element，包括了Java代码中最常用的元素，如：“包（PACKAGE）、枚举（ENUM）、类（CLASS）、注解（ANNOTATION_TYPE）、接口（INTERFACE）、枚举值（ENUM_CONSTANT）、字段（FIELD）、参数（PARAMETER）、本地变量（LOCAL_VARIABLE）、异常（EXCEPTION_PARAMETER）、方法（METHOD）、构造函数（CONSTRUCTOR）、静态语句块（STATIC_INIT，即static{}块）、实例语句块（INSTANCE_INIT，即{}块）、参数化类型（TYPE_PARAMETER，既泛型尖括号内的类型）和未定义的其他语法树节点（OTHER）”。除了process（）方法的传入参数之外，还有一个很常用的实例变量“processingEnv”，它是AbstractProcessor中的一个protected变量，在注解处理器初始化的时候（init（）方法执行的时候）创建，继承了AbstractProcessor的注解处理器代码可以直接访问到它。它代表了注解处理器框架提供的一个上下文环境，要创建新的代码、向编译器输出信息、获取其他工具类等都需要用到这个实例变量。注解处理器除了process（）方法及其参数之外，还有两个可以配合使用的Annotations：@SupportedAnnotationTypes和@SupportedSourceVersion，前者代表了这个注解处理器对哪些注解感兴趣，可以使用星号“*”作为通配符代表对所有的注解都感兴趣，后者指出这个注解处理器可以处理哪些版本的Java代码。</p><p>每一个注解处理器在运行的时候都是单例的，如果不需要改变或生成语法树的内容，process（）方法就可以返回一个值为false的布尔值，通知编译器这个Round中的代码未发生变化，无须构造新的JavaCompiler实例，在这次实战的注解处理器中只对程序命名进行检查，不需要改变语法树的内容，因此process（）方法的返回值都是false。</p><pre><code>import javax.annotation.processing.*;import javax.lang.model.SourceVersion;import javax.lang.model.element.Element;import javax.lang.model.element.TypeElement;import java.util.Set;//可以用&quot;*&quot;表示支持所有Annotations@SupportedAnnotationTypes(&quot;*&quot;)//只支持JDK 1.6的Java代码@SupportedSourceVersion(SourceVersion.RELEASE_6)public class NameCheckProcessor extends AbstractProcessor {    private NameChecker nameChecker;    /**     * 初始化名称检查插件     */    @Override    public void init(ProcessingEnvironment processingEnv){        super.init(processingEnv);        nameChecker = new NameChecker(processingEnv);    }    /**     * 对输入的语法树的各个节点进行名称检查     */    @Override    public boolean process(Set&lt;? extends TypeElement&gt; annotations,RoundEnvironment roundEnv){        if (!roundEnv.processingOver()) {            for (Element element:roundEnv.getRootElements())            nameChecker.checkNames(element);        }        return false;    }}import javax.annotation.processing.Messager;import javax.annotation.processing.ProcessingEnvironment;import javax.lang.model.element.*;import javax.lang.model.util.ElementScanner6;import javax.tools.Diagnostic;import java.util.EnumSet;public class NameChecker {    private final Messager messager;    NameCheckScanner nameCheckScanner = new NameCheckScanner();    NameChecker(ProcessingEnvironment processsingEnv) {        this.messager = processsingEnv.getMessager();    }    /**     * 对Java程序命名进行检查,根据《Java语言规范(第3版)》第6.8节的要求,Java程序命名应当符合下列格式：     * &lt;p/&gt;     * &lt;ul&gt;     * &lt;li&gt;类或接口：符合驼式命名法,首字母大写。     * &lt;li&gt;方法：符合驼式命名法,首字母小写。     * &lt;li&gt;字段：     * &lt;ul&gt;     * &lt;li&gt;类、实例变量：符合驼式命名法,首字母小写。     * &lt;li&gt;常量：要求全部大写。     * &lt;/ul&gt;     * &lt;/ul&gt;     */    public void checkNames(Element element) {        nameCheckScanner.scan(element);    }    /**     * 名称检查器实现类,继承了JDK 1.6中新提供的ElementScanner6&lt;br&gt;     * 将会以Visitor模式访问抽象语法树中的元素     */    private class NameCheckScanner extends ElementScanner6&lt;Void, Void&gt; {        /**         * 此方法用于检查Java类         */        @Override        public Void visitType(TypeElement e, Void p) {            scan(e.getTypeParameters(), p);            checkCamelCase(e, true);            super.visitType(e, p);            return null;        }        /**         * 检查方法命名是否合法         */        @Override        public Void visitExecutable(ExecutableElement e, Void p) {            if (e.getKind() == ElementKind.METHOD) {                Name name = e.getSimpleName();                if                        (name.contentEquals(e.getEnclosingElement().getSimpleName()))                    messager.printMessage(Diagnostic.Kind.WARNING, &quot;一个普通方法&apos;&quot; + name + &quot;&apos;不应当与类名重复,避免与构造函数产生混淆&quot;, e);                checkCamelCase(e, false);            }            super.visitExecutable(e, p);            return null;        }        /**         * 检查变量命名是否合法         */        @Override        public Void visitVariable(VariableElement e, Void p) {            //如果这个Variable是枚举或常量,则按大写命名检查,否则按照驼式命名法规则检查            if (e.getKind() == ElementKind.ENUM_CONSTANT || e.getConstantValue() != null || heuristicallyConstant(e))                checkAllCaps(e);            else                checkCamelCase(e, false);            return null;        }        /**         * 判断一个变量是否是常量         */        private boolean heuristicallyConstant(VariableElement e) {            if (e.getEnclosingElement().getKind() == ElementKind.INTERFACE)                return true;            else if (e.getKind() == ElementKind.FIELD &amp;&amp; e.getModifiers().containsAll(EnumSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)))                return true;            else {                return false;            }        }        /**         * 检查传入的Element是否符合驼式命名法,如果不符合,则输出警告信息         */        private void checkCamelCase(Element e, boolean initialCaps) {            String name = e.getSimpleName().toString();            boolean previousUpper = false;            boolean conventional = true;            int firstCodePoint = name.codePointAt(0);            if (Character.isUpperCase(firstCodePoint)) {                previousUpper = true;                if (!initialCaps) {                    messager.printMessage(Diagnostic.Kind.WARNING, &quot;名称&apos;&quot; + name + &quot;&apos;应当以小写字母开头&quot;, e);                    return;                }            } else if (Character.isLowerCase(firstCodePoint)) {                if (initialCaps) {                    messager.printMessage(Diagnostic.Kind.WARNING, &quot;名称&apos;&quot; + name + &quot;&apos;应当以大写字母开头&quot;, e);                    return;                }            } else                conventional = false;            if (conventional) {                int cp = firstCodePoint;                for (int i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) {                    cp = name.codePointAt(i);                    if (Character.isUpperCase(cp)) {                        if (previousUpper) {                            conventional = false;                            break;                        }                        previousUpper = true;                    } else                        previousUpper = false;                }            }            if (!conventional)                messager.printMessage(Diagnostic.Kind.WARNING, &quot;名称&apos;&quot; + name + &quot;&apos;应当符合驼式命名法(Camel Case Names)&quot;, e);        }        /**         * 大写命名检查,要求第一个字母必须是大写的英文字母,其余部分可以是下划线或大写字母         */        private void checkAllCaps(Element e) {            String name = e.getSimpleName().toString();            boolean conventional = true;            int firstCodePoint = name.codePointAt(0);            if (!Character.isUpperCase(firstCodePoint))                conventional = false;            else {                boolean previousUnderscore = false;                int cp = firstCodePoint;                for (int i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) {                    cp = name.codePointAt(i);                    if (cp == (int) &apos;_&apos;) {                        if (previousUnderscore) {                            conventional = false;                            break;                        }                        previousUnderscore = true;                    } else {                        previousUnderscore = false;                        if (!Character.isUpperCase(cp) &amp;&amp; !Character.isDigit(cp)) {                            conventional = false;                            break;                        }                    }                }            }            if (!conventional)                messager.printMessage(Diagnostic.Kind.WARNING, &quot;常量&apos;&quot; + name + &quot;&apos;应当全部以大写字母或下划线命名,并且以字母开头&quot;, e);        }    }}</code></pre><p>我们可以通过Javac命令的“-processor”参数来执行编译时需要附带的注解处理器，如果有多个注解处理器的话，用逗号分隔。还可以使用-XprintRounds和-XprintProcessorInfo参数来查看注解处理器运作的详细信息，javac -processor <strong>*.NameCheckProcessor *</strong>/test.java</p><pre><code>test.java：3：警告：名称&quot;test&quot;应当符合驼式命名法（Camel Case Names）public class test{^test.java：5：警告：名称&quot;colors&quot;应当以大写字母开头enum colors{^test.java：6：警告：常量&quot;red&quot;应当全部以大写字母或下划线命名，并且以字母开头red,blue,green；^test.java：6：警告：常量&quot;blue&quot;应当全部以大写字母或下划线命名，并且以字母开头red,blue,green；^test.java：6：警告：常量&quot;green&quot;应当全部以大写字母或下划线命名，并且以字母开头red,blue,green；^test.java：9：警告：常量&quot;_FORTY_TWO&quot;应当全部以大写字母或下划线命名，并且以字母开头static final int_FORTY_TWO=42；^test.java：11：警告：名称&quot;NOT_A_CONSTANT&quot;应当以小写字母开头public static int NOT_A_CONSTANT=_FORTY_TWO；^test.java：13：警告：名称&quot;Test&quot;应当以小写字母开头protected void Test（）{^test.java：17：警告：名称&quot;NOTcamelCASEmethodNAME&quot;应当以小写字母开头public void NOTcamelCASEmethodNAME（）{^</code></pre><p>NameCheckProcessor的例子只演示了JSR-269嵌入式注解处理器API中的一部分功能，基于这组API支持的项目还有用于校验Hibernate标签使用正确性的Hibernate Validator Annotation Processorm自动为字段生成getter和setter方法的Project Lombok.</p><h1 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h1><p>语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。Javac的编译过程中，语义分析过程分为标注检查以及数据及控制流分析两个步骤，分别由上图中所示的attribute（）和flow（）方法（分别对应过程3.1和过程3.2）完成。</p><h2 id="标注检查"><a href="#标注检查" class="headerlink" title="标注检查"></a>标注检查</h2><p>标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。在标注检查步骤中，还有一个重要的动作称为常量折叠，如果我们在代码中写了如下定义：int a=1+2；那么在语法树上仍然能看到字面量“1”、“2”以及操作符“+”，但是在经过常量折叠之后，它们将会被折叠为字面量“3”，由于编译期间进行了常量折叠，所以在代码里面定义“a=1+2”比起直接定义“a=3”，并不会增加程序运行期哪怕仅仅一个CPU指令的运算量。</p><h2 id="数据及控制流分析"><a href="#数据及控制流分析" class="headerlink" title="数据及控制流分析"></a>数据及控制流分析</h2><p>在Javac的源码中，数据及控制流分析的入口是图中的flow（）方法（对应过程3.2），具体操作由com.sun.tools.javac.comp.Flow类来完成。</p><p>数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只有在编译期或运行期才能进行。</p><pre><code>//方法一带有final修饰public void foo（final int arg）{final int var=0；//do something}//方法二没有final修饰public void foo（int arg）{int var=0；//do something}</code></pre><p>在这两个foo（）方法中，第一种方法的参数和局部变量定义使用了final修饰符，而第二种方法则没有，在代码编写时程序肯定会受到final修饰符的影响，不能再改变arg和var变量的值，但是这两段代码编译出来的Class文件是没有任何一点区别的，局部变量与字段（实例变量、类变量）是有区别的，它在常量池中没有CONSTANT_Fieldref_info的符号引用，自然就没有访问标志（Access_Flags）的信息，甚至可能连名称都不会保留下来（取决于编译时的选项），自然在Class文件中不可能知道一个局部变量是不是声明为final了。因此，将局部变量声明为final，对运行期是没有影响的，变量的不变性仅仅由编译器在编译期间保障。</p><h2 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h2><p>在Javac的源码中，解语法糖的过程由desugar（）方法触发，在com.sun.tools.javac.comp.TransTypes类和com.sun.tools.javac.comp.Lower类中完成。</p><p>语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说，使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p><p>Java中最常用的语法糖主要是的泛型擦除（泛型并不一定都是语法糖实现，如C#的泛型就是直接由CLR支持的）、变长参数、自动装箱/拆箱,条件编译等，虚拟机运行时不支持这些语法，它们在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖。</p><h1 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h1><p>字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面由com.sun.tools.javac.jvm.Gen类来完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。</p><p>例如，实例构造器＜init＞（）方法和类构造器＜clinit＞（）方法就是在这个阶段添加到语法树之中的（注意，这里的实例构造器并不是指默认构造函数，如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、访问性（public、protected或private）与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成），这两个构造器的产生过程实际上是一个代码收敛的过程，编译器会把语句块（对于实例构造器而言是“{}”块，对于类构造器而言是“static{}”块）、变量初始化（实例变量和类变量）、调用父类的实例构造器等操作收敛到＜init＞（）和＜clinit＞（）方法之中，并且保证一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行，上面所述的动作由Gen.normalizeDefs（）方法来实现。除了生成构造器以外，还有其他的一些代码替换工作用于优化程序的实现逻辑，如把字符串的加操作替换为StringBuffer或StringBuilder的append（）操作等。</p><p>完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交给com.sun.tools.javac.jvm.ClassWriter类，由这个类的writeClass（）方法输出字节码，生成最终的Class文件，到此为止整个编译过程宣告结束。</p><p><a href="https://www.cnblogs.com/wade-luffy/p/6050331.html" target="_blank" rel="noopener">摘自</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从Sun Javac的代码来看，编译过程大致可以分为3个过程:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解析与填充符号表过程。&lt;/li&gt;
&lt;li&gt;插入式注解处理器的注解处理过程。&lt;/li&gt;
&lt;li&gt;分析与字节码生成过程。&lt;br&gt;&lt;img src=&quot;j.jpg&quot; alt&gt;&lt;br&gt;Javac
      
    
    </summary>
    
    
      <category term="Java" scheme="http://iwantjingjing.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>使用 lombok 简化 Java 代码  </title>
    <link href="http://iwantjingjing.com/2019/09/25/%E4%BD%BF%E7%94%A8-lombok-%E7%AE%80%E5%8C%96-Java-%E4%BB%A3%E7%A0%81/"/>
    <id>http://iwantjingjing.com/2019/09/25/使用-lombok-简化-Java-代码/</id>
    <published>2019-09-25T02:27:07.000Z</published>
    <updated>2019-09-28T12:31:51.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一个典型的-Java-类"><a href="#一个典型的-Java-类" class="headerlink" title="一个典型的 Java 类"></a>一个典型的 Java 类</h1><pre><code>public class A {  private int a;  private String b;  public int getA() {    return a;  }  public String getB() {    return b;  }  public void setA(int a) {    this.a = a;  }  public void setB(String b) {    this.b = b;  }}</code></pre><p>对于这样一个简单的 Java 类，我们通常需要给每个属性写getter和setter，而这种实际上没有什么太大的意义。当然，如果有的公司或团队使用代码行数评估工作量，还是多写几行吧；同时，可以考虑一下我们团队。</p><h1 id="使用-lombok，简化代码"><a href="#使用-lombok，简化代码" class="headerlink" title="使用 lombok，简化代码"></a>使用 lombok，简化代码</h1><p>为了简化getter与setter，lombok 提供了一种机制，帮助我们自动生成这些样板代码。以上的代码，如果使用lombok的话，将变得很简单：</p><pre><code>@lombok.Getter@lombok.Setterpublic class A {    private int a;    private String b;}</code></pre><p>顾名思义，lombok.Getter就是生成getter，lombok.Setter就是生成setter。但是，这样真的就可以了么？编译下，让我们看看生成的二进制代码。(请自行下载lombok.jar)</p><pre><code>命令行&gt; javac -cp lombok.jar A.java命令行&gt; javap -c A.class</code></pre><p>输出结果略。可以看到完全一样。</p><p>更进一步，如果在编译的时候，加入-g:none选项，甚至可以看到生成的文件完全一样。</p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>虽然我们可以在编译的时候，加入classpath，但是，一般来说，在各类IDE中使用，还是需要特殊处理一下。</p><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>加上依赖就好。同时，由于lombok只在编译期才处理，所以并不需要在运行时有这个依赖，可以把scope定义为provided。</p><pre><code>&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;version&gt;1.16.8&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>值得注意的是，maven的maven-compiler-plugin低版本和lombok高版本不兼容，目前已知maven-compiler-plugin的2.3.X与lombok的1.6.X不兼容。这个需要了解lombok的原理才能进一步说明。</p><h2 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h2><p>由于eclipse的默认编译器并不是javac，所以，需要额外安装，基本就是改下引导参数，可以直接运行jar包，或者手动在eclipse.ini里加上参数-Xbootclasspath/a:lombok.jar -javaagent:lombok.jar。</p><h2 id="IDEA-IntelliJ"><a href="#IDEA-IntelliJ" class="headerlink" title="IDEA IntelliJ"></a>IDEA IntelliJ</h2><p>虽然IDEA IntelliJ默认使用javac作为编译器，理论上可以不装插件。可是，跳转等特性也随之没了。所以，还是安装个插件吧，直接去仓库里搜索lombok就成。</p><p>如果项目中使用高级配置，需要额外注意一下。虽然在编译的时候，lombok配置文件可以在任何能找到的目录，但是，lombok-intellij插件默认并不支持在任何目录，如果有配置文件，建议放在java的源代码根目录中。    </p><h1 id="更多-lombok-注解"><a href="#更多-lombok-注解" class="headerlink" title="更多 lombok 注解"></a>更多 lombok 注解</h1><table><thead><tr><th align="left">注解</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">@val</td><td align="left">如果你要定义一个final的变量，并且不想写类型，这个可以帮到你。但是，在实际项目中，完全没有使用到。</td></tr><tr><td align="left">@NonNull</td><td align="left">这个在参数中使用，如果调用时传了null，就直接抛空指针。</td></tr><tr><td align="left">@Data</td><td align="left">@ToString、@EqualsAndHashCode、@Getter、@Setter和@RequiredArgsConstructor注解的集合。</td></tr><tr><td align="left">@Getter与@Setter</td><td align="left">作用于属性和类上，自动生成属性的getXXX()和setXXX()方法。若在类上，则对所有属性有效。并可通过AccessLevel参数控制方法的访问级别。</td></tr><tr><td align="left">@ToString</td><td align="left">作用于类，自动重写类的ToString()方法。常用的参数有exclude（指定方法中不包含的属性）、callSuper（方法中是否包含父类ToString()方法返回的值）</td></tr><tr><td align="left">@EqualsAndHashCode</td><td align="left">作用于类，自动重写类的equals()、hashCode()方法。常用的参数有exclude（指定方法中不包含的属性）、callSuper（方法中是否包含父类ToString()方法返回的值）</td></tr><tr><td align="left">@NoArgsConstructor, @RequiredArgsConstructor和@AllArgsConstructor</td><td align="left">作用于类，@NoArgsConstructor自动生成不带参数的构造方法；@RequiredArgsConstructor自动生成带参数的构造方法，主要针对一些需要特殊处理的属性，比如未初始化的final属性；@AllArgsConstructor自动生成包含所有属性的构造方法。</td></tr><tr><td align="left">@Synchronized</td><td align="left">作用于方法，可锁定指定的对象，如果不指定，则默认创建创建一个对象锁定。</td></tr><tr><td align="left">@Log，或者直接@Slf4j</td><td align="left">作用于类，具体包含@CommonsLog、@Log、@Log4j、@Log4j2、@Slf4j和@XSlf4j，分别对用不同的日志系统。利用此类注解，可为类创建一个log属性。</td></tr></tbody></table><h2 id="sonar源码审查"><a href="#sonar源码审查" class="headerlink" title="sonar源码审查"></a>sonar源码审查</h2><p>sonar是一个源码审查工具。最新版5.X已经支持lombok的全部注解，不再认为是没有使用的变量。但是，旧的4.X还是认为没有使用这些变量。可以后向移植这些包，或者应用单独的补丁。</p><p><a href="https://segmentfault.com/a/1190000005133786" target="_blank" rel="noopener">摘自</a></p><p><a href="https://docs.sonarqube.org/latest/" target="_blank" rel="noopener">sonar</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一个典型的-Java-类&quot;&gt;&lt;a href=&quot;#一个典型的-Java-类&quot; class=&quot;headerlink&quot; title=&quot;一个典型的 Java 类&quot;&gt;&lt;/a&gt;一个典型的 Java 类&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;public class A {

  pr
      
    
    </summary>
    
    
      <category term="Lombok" scheme="http://iwantjingjing.com/categories/Lombok/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="lombok" scheme="http://iwantjingjing.com/tags/lombok/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之Builder模式  </title>
    <link href="http://iwantjingjing.com/2019/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BBuilder%E6%A8%A1%E5%BC%8F/"/>
    <id>http://iwantjingjing.com/2019/09/19/设计模式之Builder模式/</id>
    <published>2019-09-19T10:24:08.000Z</published>
    <updated>2019-09-28T12:31:51.433Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MySQL创建用户与授权  </title>
    <link href="http://iwantjingjing.com/2019/09/12/MySQL%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E4%B8%8E%E6%8E%88%E6%9D%83/"/>
    <id>http://iwantjingjing.com/2019/09/12/MySQL创建用户与授权/</id>
    <published>2019-09-12T08:10:52.000Z</published>
    <updated>2019-09-28T12:31:51.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-创建用户"><a href="#一-创建用户" class="headerlink" title="一. 创建用户"></a>一. 创建用户</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><pre><code>CREATE USER &apos;username&apos;@&apos;host&apos; IDENTIFIED BY &apos;password&apos;;</code></pre><h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><ul><li>username：你将创建的用户名</li><li>host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%</li><li>password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</li></ul><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><pre><code>CREATE USER &apos;dog&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;;CREATE USER &apos;pig&apos;@&apos;192.168.1.101_&apos; IDENDIFIED BY &apos;123456&apos;;CREATE USER &apos;pig&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;CREATE USER &apos;pig&apos;@&apos;%&apos; IDENTIFIED BY &apos;&apos;;CREATE USER &apos;pig&apos;@&apos;%&apos;;</code></pre><h1 id="二-授权"><a href="#二-授权" class="headerlink" title="二. 授权:"></a>二. 授权:</h1><h2 id="命令-1"><a href="#命令-1" class="headerlink" title="命令:"></a>命令:</h2><pre><code>GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos;</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h2><ul><li>privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL</li><li>databasename：数据库名</li><li>tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<em>表示，如</em>.*</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h2><pre><code>GRANT SELECT, INSERT ON test.user TO &apos;pig&apos;@&apos;%&apos;;GRANT ALL ON *.* TO &apos;pig&apos;@&apos;%&apos;;</code></pre><p>注意:<br>用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:</p><pre><code>GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos; WITH GRANT OPTION;</code></pre><h1 id="三-设置与更改用户密码"><a href="#三-设置与更改用户密码" class="headerlink" title="三.设置与更改用户密码"></a>三.设置与更改用户密码</h1><p>   命令:</p><pre><code>SET PASSWORD FOR &apos;username&apos;@&apos;host&apos; = PASSWORD(&apos;newpassword&apos;);</code></pre><p> 如果是当前登陆用户用:</p><pre><code>SET PASSWORD = PASSWORD(&quot;newpassword&quot;);</code></pre><p>例子:</p><pre><code>SET PASSWORD FOR &apos;pig&apos;@&apos;%&apos; = PASSWORD(&quot;123456&quot;);</code></pre><h1 id="四-撤销用户权限"><a href="#四-撤销用户权限" class="headerlink" title="四. 撤销用户权限"></a>四. 撤销用户权限</h1><p>命令:</p><pre><code>REVOKE privilege ON databasename.tablename FROM &apos;username&apos;@&apos;host&apos;;</code></pre><p>说明:<br>privilege, databasename, tablename：同授权部分</p><p>例子:</p><pre><code>REVOKE SELECT ON *.* FROM &apos;pig&apos;@&apos;%&apos;;</code></pre><p>注意:</p><p>假如你在给用户‘pig’@’%’授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO ‘pig’@’%’，则在使用REVOKE SELECT ON <em>.</em> FROM ‘pig’@’%’;命令并不能撤销该用户对test数据库中user表的SELECT 操作。相反，如果授权使用的是GRANT SELECT ON <em>.</em> TO ‘pig’@’%’;则REVOKE SELECT ON test.user FROM ‘pig’@’%’;命令也不能撤销该用户对test数据库中user表的Select权限。</p><p>具体信息可以用命令SHOW GRANTS FOR ‘pig’@’%’; 查看。</p><h1 id="五-删除用户"><a href="#五-删除用户" class="headerlink" title="五.删除用户"></a>五.删除用户</h1><pre><code>DROP USER &apos;username&apos;@&apos;host&apos;;</code></pre><p><a href="https://www.jianshu.com/p/d7b9c468f20d" target="_blank" rel="noopener">摘抄自</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-创建用户&quot;&gt;&lt;a href=&quot;#一-创建用户&quot; class=&quot;headerlink&quot; title=&quot;一. 创建用户&quot;&gt;&lt;/a&gt;一. 创建用户&lt;/h1&gt;&lt;h2 id=&quot;命令&quot;&gt;&lt;a href=&quot;#命令&quot; class=&quot;headerlink&quot; title=&quot;命令&quot;
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://iwantjingjing.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://iwantjingjing.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Lombok 看这篇就够了  </title>
    <link href="http://iwantjingjing.com/2019/09/12/Lombok-%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <id>http://iwantjingjing.com/2019/09/12/Lombok-看这篇就够了/</id>
    <published>2019-09-12T06:41:50.000Z</published>
    <updated>2019-09-28T12:31:51.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p><a href="https://projectlombok.org" target="_blank" rel="noopener">官网</a><br>官网解释:</p><p>Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.<br>Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.</p><h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>减少代码量,省去写geter,setter等</p><h1 id="when"><a href="#when" class="headerlink" title="when"></a>when</h1><h2 id="添加下依赖"><a href="#添加下依赖" class="headerlink" title="添加下依赖:"></a>添加下依赖:</h2><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.16.8&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>那么Lombok是做什么的呢？其实很简单，一个最简单的例子就是它能够实现通过添加注解，能够自动生成一些方法。比如这样的类:</p><pre><code>@Getterclass Test{    private String value;}</code></pre><p>我们用Lombok提供的@Getter来注解这个类，这个类在编译的时候就会变成:</p><pre><code>class Test{    private String value;    public String getValue(){        return this.value;    }}</code></pre><p>当然Lombok也提供了很多其他的注解，这只是其中一个最典型的例子。其他的用法网上的资料已经很多了，这里就不啰嗦。<br>看上去是很方便的一个功能，尤其是在很多项目里有很多bean，每次都要手写或自动生成setter getter方法，搞得代码很长而且没有啥意义，因此这个对简化代码的强迫症们还是很有吸引力的。<br>但是，我们发现这个包跟一般的包有很大区别，绝大多数java包都工作在运行时，比如spring提供的那种注解，通过在运行时用反射来实现业务逻辑。Lombok这个东西工作却在编译期，在运行时是无法通过反射获取到这个注解的。<br>而且由于他相当于是在编译期对代码进行了修改，因此从直观上看，源代码甚至是语法有问题的。<br>一个更直接的体现就是，普通的包在引用之后一般的IDE都能够自动识别语法，但是Lombok的这些注解，一般的IDE都无法自动识别，比如我们上面的Test类，如果我们在其他地方这么调用了一下:</p><pre><code>Test test=new Test();test.getValue();</code></pre><p>IDE的自动语法检查就会报错，说找不到这个getValue方法。因此如果要使用Lombok的话还需要配合安装相应的插件，防止IDE的自动检查报错。<br>因此，可以说这个东西的设计初衷比较美好，但是用起来比较麻烦，而且破坏了代码的完整性，很多项目组(包括我自己)都不高兴用。但是他的实现原理却还是比较好玩的，随便搜了搜发现网上最多也只提到了他修改了抽象语法树，虽说从感性上可以理解，但是还是想自己手敲一敲真正去实现一下。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>翻了翻现有的资料，再加上自己的一些猜想，Lombok的基本流程应该基本是这样：</p><ul><li>定义编译期的注解</li><li>利用JSR269 api(Pluggable Annotation Processing API )创建编译期的注解处理器</li><li>利用tools.jar的javac api处理AST(抽象语法树)</li><li>将功能注册进jar包</li></ul><h2 id="手撸Getter"><a href="#手撸Getter" class="headerlink" title="手撸Getter"></a>手撸Getter</h2><p>由于比较习惯用maven，我这里就用maven构建一下项目，修改下当前的pom.xml文件如下：</p><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.mythsman.test&lt;/groupId&gt;    &lt;artifactId&gt;getter&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;name&gt;test&lt;/name&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.sun&lt;/groupId&gt;            &lt;artifactId&gt;tools&lt;/artifactId&gt;            &lt;version&gt;1.8&lt;/version&gt;            &lt;scope&gt;system&lt;/scope&gt;            &lt;systemPath&gt;${java.home}/../lib/tools.jar&lt;/systemPath&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>主要定义了下项目名，除了默认依赖的junit之外(其实并没有用)，这里添加了tools.jar包。这个包实在jdk的lib下面，因此scope是system，由于${java.home}变量表示的是jre的位置，因此还要根据这个位置找到实际的tools.jar的路径并写在systemPath里。<br>由于防止在写代码的时候用到java8的一些语法，这里配置了下编译插件使其支持java8。</p><h3 id="创建Getter注解"><a href="#创建Getter注解" class="headerlink" title="创建Getter注解"></a>创建Getter注解</h3><p>定义注解Getter.java:</p><pre><code>package com.mythsman.test;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target({ElementType.TYPE})@Retention(RetentionPolicy.SOURCE)public @interface Getter {}</code></pre><p>这里的Target我选择了ElementType.TYPE表示是对类的注解，Retention选择了RententionPolicy.SOURCE，表示这个注解只在编译期起作用，在运行时将不存在。这个比较简单，稍微复杂点的是对这个注解的处理机制。像spring那种注解是通过反射来获得注解对应的元素并实现业务逻辑，但是我们显然不希望在使用Lombok这种功能的时候还要编写其他的调用代码，况且用反射也获取不到编译期才存在的注解。<br>幸运的是Java早已支持了JSR269的规范，允许在编译时指定一个processor类来对编译阶段的注解进行干预，下面就来解决下这个处理器。</p><h3 id="创建Getter注解的处理器"><a href="#创建Getter注解的处理器" class="headerlink" title="创建Getter注解的处理器"></a>创建Getter注解的处理器</h3><p>基本框架</p><p>自定义的处理器需要继承AbstractProcessor这个类，基本的框架大体应当如下:</p><pre><code>package com.mythsman.test;import javax.annotation.processing.*;import javax.lang.model.SourceVersion;import javax.lang.model.element.TypeElement;import java.util.Set;@SupportedAnnotationTypes(&quot;com.mythsman.test.Getter&quot;)@SupportedSourceVersion(SourceVersion.RELEASE_8)public class GetterProcessor extends AbstractProcessor {    @Override    public synchronized void init(ProcessingEnvironment processingEnv) {        super.init(processingEnv);    }    @Override    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {        return true;    }}</code></pre><p>需要定义两个注解，一个表示该处理器需要处理的注解，另外一个表示该处理器支持的源码版本。然后需要着重实现两个方法，init跟process。init的主要用途是通过ProcessingEnvironment来获取编译阶段的一些环境信息;process主要是实现具体逻辑的地方，也就是对AST进行处理的地方。</p><p>具体怎么做呢？</p><p>init方法<br>首先我们要重写下init方法，从环境里提取一些关键的类:</p><pre><code>private Messager messager;private JavacTrees trees;private TreeMaker treeMaker;private Names names;@Overridepublic synchronized void init(ProcessingEnvironment processingEnv) {    super.init(processingEnv);    this.messager = processingEnv.getMessager();    this.trees = JavacTrees.instance(processingEnv);    Context context = ((JavacProcessingEnvironment) processingEnv).getContext();    this.treeMaker = TreeMaker.instance(context);    this.names = Names.instance(context);}</code></pre><p>我们提取了四个主要的类:</p><ul><li>Messager主要是用来在编译期打log用的</li><li>JavacTrees提供了待处理的抽象语法树</li><li>TreeMaker封装了创建AST节点的一些方法</li><li>Names提供了创建标识符的方法</li></ul><p>process方法<br>process方法的逻辑比较简单，但是由于这里的api对于我们来说比较陌生，因此写起来还是费了不少劲的：</p><pre><code>@Overridepublic synchronized boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {    Set&lt;? extends Element&gt; set = roundEnv.getElementsAnnotatedWith(Getter.class);    set.forEach(element -&gt; {        JCTree jcTree = trees.getTree(element);        jcTree.accept(new TreeTranslator() {            @Override            public void visitClassDef(JCTree.JCClassDecl jcClassDecl) {                List&lt;JCTree.JCVariableDecl&gt; jcVariableDeclList = List.nil();                for (JCTree tree : jcClassDecl.defs) {                    if (tree.getKind().equals(Tree.Kind.VARIABLE)) {                        JCTree.JCVariableDecl jcVariableDecl = (JCTree.JCVariableDecl) tree;                        jcVariableDeclList = jcVariableDeclList.append(jcVariableDecl);                    }                }                jcVariableDeclList.forEach(jcVariableDecl -&gt; {                    messager.printMessage(Diagnostic.Kind.NOTE, jcVariableDecl.getName() + &quot; has been processed&quot;);                    jcClassDecl.defs = jcClassDecl.defs.prepend(makeGetterMethodDecl(jcVariableDecl));                });                super.visitClassDef(jcClassDecl);            }        });    });    return true;}</code></pre><p>步骤大概是下面这样：</p><ol><li>利用roundEnv的getElementsAnnotatedWith方法过滤出被Getter这个注解标记的类，并存入set</li><li>遍历这个set里的每一个元素，并生成jCTree这个语法树</li><li>创建一个TreeTranslator，并重写其中的visitClassDef方法，这个方法处理遍历语法树得到的类定义部分jcClassDecl<ul><li>创建一个jcVariableDeclList保存类的成员变量</li><li>遍历jcTree的所有成员(包括成员变量和成员函数和构造函数)，过滤出其中的成员变量，并添加进jcVariableDeclList</li><li>将jcVariableDeclList的所有变量转换成需要添加的getter方法，并添加进jcClassDecl的成员中</li><li>调用默认的遍历方法遍历处理后的jcClassDecl</li></ul></li><li>利用上面的TreeTranslator去处理jcTree</li></ol><p>接下来再实现makeGetterMethodDecl方法:</p><pre><code>private JCTree.JCMethodDecl makeGetterMethodDecl(JCTree.JCVariableDecl jcVariableDecl) {    ListBuffer&lt;JCTree.JCStatement&gt; statements = new ListBuffer&lt;&gt;();    statements.append(treeMaker.Return(treeMaker.Select(treeMaker.Ident(names.fromString(&quot;this&quot;)), jcVariableDecl.getName())));    JCTree.JCBlock body = treeMaker.Block(0, statements.toList());    return treeMaker.MethodDef(treeMaker.Modifiers(Flags.PUBLIC), getNewMethodName(jcVariableDecl.getName()), jcVariableDecl.vartype, List.nil(), List.nil(), List.nil(), body, null);}private Name getNewMethodName(Name name) {    String s = name.toString();    return names.fromString(&quot;get&quot; + s.substring(0, 1).toUpperCase() + s.substring(1, name.length()));}</code></pre><p>逻辑就是读取变量的定义，并创建对应的Getter方法，并试图用驼峰命名法。</p><p>整体上难点还是集中在api的使用上，还有一些细微的注意点:<br>首先，messager的printMessage方法在打印log的时候会自动过滤重复的log信息。<br>其次，这里的list并不是java.util里面的list，而是一个自定义的list，这个list的用法比较坑爹，他采用的是这样的方式:</p><pre><code>package com.sun.tools.javac.util;public class List&lt;A&gt; extends AbstractCollection&lt;A&gt; implements java.util.List&lt;A&gt; {    public A head;    public List&lt;A&gt; tail;    //...    List(A var1, List&lt;A&gt; var2) {        this.tail = var2;        this.head = var1;    }    public List&lt;A&gt; prepend(A var1) {        return new List(var1, this);    }    public static &lt;A&gt; List&lt;A&gt; of(A var0) {        return new List(var0, nil());    }    public List&lt;A&gt; append(A var1) {        return of(var1).prependList(this);    }    public static &lt;A&gt; List&lt;A&gt; nil() {        return EMPTY_LIST;    }    //...}</code></pre><p>挺有趣的，用这种叫cons而不是list的数据结构，添加元素的时候就把自己赋给自己的tail,新来的元素放进head。不过需要注意的是这个东西不支持链式调用，prepend之后还要将新值赋给自己。<br>而且这里在创建getter方法的时候还要把参数写全写对了，尤其是添加this指针的这种用法。</p><p>测试类<br>上面基本就是所有功能代码了，接下来我们要写一个类来测试一下(App.java)：</p><pre><code>package com.mythsman.test;@Getterpublic class App {    private String value;    private String value2;    public App(String value) {        this.value = value;    }    public static void main(String[] args) {        App app = new App(&quot;it works&quot;);        System.out.println(app.getValue());    }}</code></pre><p>不过，先不要急着构建，构建了肯定会失败，因为这原则上应该是两个项目。Getter.java是注解类没问题，但是GetterProcessor.java是处理器，App.java需要在编译期调用这个处理器，因此这两个东西是不能一起编译的，正确的编译方法应该是类似下面这样，写成compile.sh脚本就是：</p><pre><code>#!/usr/bin/env bashif [ -d classes ]; then    rm -rf classes;fimkdir classesjavac -cp $JAVA_HOME/lib/tools.jar com/mythsman/test/Getter* -d classes/javac -cp classes -d classes -processor com.mythsman.test.GetterProcessor com/mythsman/test/App.javajavap -p classes com/mythsman/test/App.classjava -cp classes com.mythsman.test.App</code></pre><p>其实是五个步骤:</p><ol><li>创建保存class文件的文件夹</li><li>导入tools.jar，编译processor并输出</li><li>编译App.java，并使用javac的-processor参数指定编译阶段的处理器GetterProcessor</li><li>用javap显示编译后的App.class文件(非必须，方便看结果)</li><li>执行测试类    </li></ol><p>好了，进入项目的根目录，当前的目录结构应该是这样的:</p><p>.<br>├── pom.xml<br>├── src<br>│   ├── main<br>│   │   ├── java<br>│   │   │   ├── com<br>│   │   │   │   └── mythsman<br>│   │   │   │       └── test<br>│   │   │   │           ├── App.java<br>│   │   │   │           ├── Getter.java<br>│   │   │   │           └── GetterProcessor.java<br>│   │   │   └── compile.sh</p><p>调用compile.sh，输出如下:</p><pre><code>Note: value has been processedNote: value2 has been processedCompiled from &quot;App.java&quot;public class com.mythsman.test.App {  private java.lang.String value;  private java.lang.String value2;  public java.lang.String getValue2();  public java.lang.String getValue();  public com.mythsman.test.App(java.lang.String);  public static void main(java.lang.String[]);}it works</code></pre><p>Note行就是在GetterProcessor类里通过messager打印的log，中间的是javap反编译的结果，最后一行表示测试调用成功。</p><h3 id="Maven构建并打包"><a href="#Maven构建并打包" class="headerlink" title="Maven构建并打包"></a>Maven构建并打包</h3><p>上面的测试部分其实是为了测试而测试，其实这应当是两个项目，一个是processor项目，这个项目应当被打成一个jar包，供调用者使用；另一个项目是app项目，这个项目是专门使用jar包的，他并不希望添加任何额外编译参数，就跟lombok的用法一样。<br>简单来说，就是我们希望把processor打成一个包，并且在使用时不需要添加额外参数。<br>那么如何在调用的时候不用加参数呢，其实我们知道java在编译的时候会去资源文件夹下读一个META-INF文件夹，这个文件夹下面除了MANIFEST.MF文件之外，还可以添加一个services文件夹，我们可以在这个文件夹下创建一个文件，文件名是javax.annotation.processing.Processor，文件内容是com.mythsman.test.GetterProcessor。<br>我们知道maven在编译前会先拷贝资源文件夹，然后当他在编译时候发现了资源文件夹下的META-INF/serivces文件夹时，他就会读取里面的文件，并将文件名所代表的接口用文件内容表示的类来实现。这就相当于做了-processor参数该做的事了。<br>当然这个文件我们并不希望调用者去写，而是希望在processor项目里集成，调用的时候能直接继承META-INF。</p><p>好了，我们先删除App.java和compile.sh，添加下META-INF文件夹，当前目录结构应该是这样的：</p><p>.<br>├── pom.xml<br>├── src<br>│   └── main<br>│       ├── java<br>│       │   └── com<br>│       │       └── mythsman<br>│       │           └── test<br>│       │               ├── Getter.java<br>│       │               └── GetterProcessor.java<br>│       └── resources<br>│           └── META-INF<br>│               └── services<br>│                   └── javax.annotation.processing.Processor</p><p>当然，我们还不能编译，因为processor项目并不需要把自己添加为processor(况且自己还没编译呢怎么调用自己)。。。完了，好像死循环了，自己在编译的时候不能添加services文件夹，但是又需要打的包里有services文件夹，这该怎么搞呢？<br>其实很简单，配置一下maven的插件就行，打开pom.xml,在project/build/标签里添加下面的配置:</p><pre><code>&lt;build&gt;   &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;excludes&gt;                &lt;exclude&gt;META-INF/**/*&lt;/exclude&gt;            &lt;/excludes&gt;        &lt;/resource&gt;    &lt;/resources&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;            &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;            &lt;version&gt;2.6&lt;/version&gt;            &lt;executions&gt;                &lt;execution&gt;                    &lt;id&gt;process-META&lt;/id&gt;                    &lt;phase&gt;prepare-package&lt;/phase&gt;                    &lt;goals&gt;                        &lt;goal&gt;copy-resources&lt;/goal&gt;                    &lt;/goals&gt;                    &lt;configuration&gt;                        &lt;outputDirectory&gt;target/classes&lt;/outputDirectory&gt;                        &lt;resources&gt;                            &lt;resource&gt;                                &lt;directory&gt;${basedir}/src/main/resources/&lt;/directory&gt;                                &lt;includes&gt;                                    &lt;include&gt;**/*&lt;/include&gt;                                &lt;/includes&gt;                            &lt;/resource&gt;                        &lt;/resources&gt;                    &lt;/configuration&gt;                &lt;/execution&gt;            &lt;/executions&gt;        &lt;/plugin&gt;        ...    &lt;/plugins&gt;&lt;/build&gt;</code></pre><p>我们知道maven构建的第一步就是调用maven-resources-plugin插件的resources命令，将resources文件夹复制到target/classes中，那么我们配置一下resources标签，过滤掉META-INF文件夹，这样在编译的时候就不会找到services的配置了。然后我们在打包前(prepare-package生命周期)再利用maven-resources-plugin插件的copy-resources命令把services文件夹重新拷贝过来不就好了么。<br>这样配置好了，就可以直接执行mvn clean install打包提交到本地私服:</p><pre><code>myths@pc:~/Desktop/test$ mvn clean install[INFO] Scanning for projects...[INFO] [INFO] ------------------------------------------------------------------------[INFO] Building test 1.0-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO] [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ getter ---[INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ getter ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] Copying 0 resource[INFO] [INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ getter ---[INFO] Changes detected - recompiling the module![INFO] Compiling 2 source files to /home/myths/Desktop/test/target/classes[INFO] [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ getter ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] skip non existing resourceDirectory /home/myths/Desktop/test/src/test/resources[INFO] [INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ getter ---[INFO] No sources to compile[INFO] [INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ getter ---[INFO] No tests to run.[INFO] [INFO] --- maven-resources-plugin:2.6:copy-resources (process-META) @ getter ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] Copying 1 resource[INFO] [INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ getter ---[INFO] Building jar: /home/myths/Desktop/test/target/getter-1.0-SNAPSHOT.jar[INFO] [INFO] --- maven-install-plugin:2.4:install (default-install) @ getter ---[INFO] Installing /home/myths/Desktop/test/target/getter-1.0-SNAPSHOT.jar to /home/myths/.m2/repository/com/mythsman/test/getter/1.0-SNAPSHOT/getter-1.0-SNAPSHOT.jar[INFO] Installing /home/myths/Desktop/test/pom.xml to /home/myths/.m2/repository/com/mythsman/test/getter/1.0-SNAPSHOT/getter-1.0-SNAPSHOT.pom[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 3.017 s[INFO] Finished at: 2017-12-19T19:57:04+08:00[INFO] Final Memory: 16M/201M[INFO] ------------------------------------------------------------------------</code></pre><p>可以看到这里的process-META作用生效。</p><p>调用jar包测试</p><p>重新创建一个测试项目app：</p><p>.<br>├── pom.xml<br>└── src<br>    └── main<br>        └── java<br>            └── com<br>                └── mythsman<br>                    └── test<br>                        └── App.java</p><p>pom.xml:</p><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.mythsman.test&lt;/groupId&gt;    &lt;artifactId&gt;app&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;name&gt;main&lt;/name&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.mythsman.test&lt;/groupId&gt;            &lt;artifactId&gt;getter&lt;/artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>App.java:</p><pre><code>package com.mythsman.test;@Getterpublic class App {    private String value;    private String value2;    public App(String value) {        this.value = value;    }    public static void main(String[] args) {        App app = new App(&quot;it works&quot;);        System.out.println(app.getValue());    }}</code></pre><p>编译并执行:</p><p>mvn clean compile &amp;&amp; java -cp target/classes com.mythsman.test.App</p><p>最后就会在构建成功后打印”it works”。</p><p><a href="https://zhuanlan.zhihu.com/p/32779910" target="_blank" rel="noopener">参考</a><br><a href="https://yq.aliyun.com/articles/59972" target="_blank" rel="noopener">参考</a><br><a href="https://juejin.im/entry/5a390ba76fb9a0451e3fed7c" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;what&quot;&gt;&lt;a href=&quot;#what&quot; class=&quot;headerlink&quot; title=&quot;what&quot;&gt;&lt;/a&gt;what&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://projectlombok.org&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
    
      <category term="Lombok" scheme="http://iwantjingjing.com/categories/Lombok/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="idea" scheme="http://iwantjingjing.com/tags/idea/"/>
    
      <category term="lombok" scheme="http://iwantjingjing.com/tags/lombok/"/>
    
      <category term="plugin" scheme="http://iwantjingjing.com/tags/plugin/"/>
    
  </entry>
  
  <entry>
    <title>初识Shiro</title>
    <link href="http://iwantjingjing.com/2019/09/12/%E5%88%9D%E8%AF%86Shiro/"/>
    <id>http://iwantjingjing.com/2019/09/12/初识Shiro/</id>
    <published>2019-09-12T05:56:37.000Z</published>
    <updated>2019-09-28T13:54:55.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p><a href="https://shiro.apache.org" target="_blank" rel="noopener">官网</a></p><h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;what&quot;&gt;&lt;a href=&quot;#what&quot; class=&quot;headerlink&quot; title=&quot;what&quot;&gt;&lt;/a&gt;what&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://shiro.apache.org&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
    
      <category term="Shiro" scheme="http://iwantjingjing.com/categories/Shiro/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="Shiro" scheme="http://iwantjingjing.com/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>Mac 下locate命令使用问题WARNING: The locate database (/var/db/locate.database) does not exist</title>
    <link href="http://iwantjingjing.com/2019/09/11/Mac-%E4%B8%8Blocate%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98WARNING-The-locate-database-var-db-locate-database-does-not-exist/"/>
    <id>http://iwantjingjing.com/2019/09/11/Mac-下locate命令使用问题WARNING-The-locate-database-var-db-locate-database-does-not-exist/</id>
    <published>2019-09-11T01:44:23.000Z</published>
    <updated>2019-09-28T12:31:51.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><img src="locate.png" alt></p><p>根据提示使用 </p><p>sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.locate.plist<br> 并没有生效。</p><p>需要执行</p><p>sudo /usr/libexec/locate.updatedb 进行库更新。</p><p><a href="https://www.cnblogs.com/b-ruce/p/5911048.html" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;locate.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;根据提示使用 &lt;/p&gt;
&lt;p&gt;sudo launchctl load -
      
    
    </summary>
    
    
      <category term="Mac" scheme="http://iwantjingjing.com/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://iwantjingjing.com/tags/Mac/"/>
    
      <category term="exception" scheme="http://iwantjingjing.com/tags/exception/"/>
    
  </entry>
  
  <entry>
    <title>mac上解决java.rmi.server.ExportException- Port already in use- 1099; nested exception is- java.net.Bi</title>
    <link href="http://iwantjingjing.com/2019/09/09/mac%E4%B8%8A%E8%A7%A3%E5%86%B3java-rmi-server-ExportException-Port-already-in-use-1099-nested-exception-is-java-net-Bi/"/>
    <id>http://iwantjingjing.com/2019/09/09/mac上解决java-rmi-server-ExportException-Port-already-in-use-1099-nested-exception-is-java-net-Bi/</id>
    <published>2019-09-09T10:39:14.000Z</published>
    <updated>2019-09-28T12:31:51.427Z</updated>
    
    <content type="html"><![CDATA[<p>tomcat启动报如下的错误：</p><p>java.rmi.server.ExportException: Port already in use: 1099; nested exception is: java.net.BindException: Address already in use (Bind failed)</p><p>解决方法有两种</p><h1 id="第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法"><a href="#第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法" class="headerlink" title="第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法"></a>第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法</h1><h1 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h1><p>第一步：使用lsof -i tcp:1099 查看时那个应用占用了此端口</p><p>第二部：使用kill pid 即可，这里的pid是第一步所查询到结果</p><p><a href="https://blog.csdn.net/u010412719/article/details/76724125" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;tomcat启动报如下的错误：&lt;/p&gt;
&lt;p&gt;java.rmi.server.ExportException: Port already in use: 1099; nested exception is: java.net.BindException: Address a
      
    
    </summary>
    
    
      <category term="exception" scheme="http://iwantjingjing.com/categories/exception/"/>
    
    
      <category term="exception" scheme="http://iwantjingjing.com/tags/exception/"/>
    
      <category term="mac" scheme="http://iwantjingjing.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>关于 getWriter() has already been called for this response 的错误解决办法</title>
    <link href="http://iwantjingjing.com/2019/09/09/%E5%85%B3%E4%BA%8E-getWriter-has-already-been-called-for-this-response-%E7%9A%84%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://iwantjingjing.com/2019/09/09/关于-getWriter-has-already-been-called-for-this-response-的错误解决办法/</id>
    <published>2019-09-09T05:46:37.000Z</published>
    <updated>2019-09-28T12:31:51.430Z</updated>
    
    <content type="html"><![CDATA[<p>上篇Filter、FilterChain、FilterConfig 介绍<br>文中的代码若在多个filter中执行则会报错” getWriter() has already been called for this response “</p><p>解决方案为在doFilter() 之前将流关闭.</p><pre><code>public void doFilter(ServletRequest request, ServletResponse response,                        FilterChain chain) throws IOException, ServletException {       System.out.println(&quot;begin headers-------------------&quot;);       Enumeration&lt;?&gt; headerNames = ((HttpServletRequest)request).getHeaderNames();       while(headerNames.hasMoreElements()) {           String headerName = (String)headerNames.nextElement();           System.out.println(headerName + &quot;: &quot; + ((HttpServletRequest)request).getHeader(headerName));       }       System.out.println(&quot;end headers-------------------&quot;);       //在调用目标前写入响应内容       response.setContentType(&quot;text/html; charset=utf-8&quot;);       PrintWriter out = response.getWriter();       out.println(&quot;IP地址为：&quot; + request.getRemoteHost() + &quot;&lt;br&gt;&quot;);       //在目标返回后写入响应内容       out.println(&quot;&lt;br&gt;名称为encoding的初始化参数的值为：&quot; + paramValue);       out.println(&quot;&lt;br&gt;当前Web程序的真实路径为：&quot; + filterConfig.getServletContext().getRealPath(&quot;/&quot;));       out.close(); // 不关闭则会报错 getWriter() has already been called for this response       chain.doFilter(request, response);   }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上篇Filter、FilterChain、FilterConfig 介绍&lt;br&gt;文中的代码若在多个filter中执行则会报错” getWriter() has already been called for this response “&lt;/p&gt;
&lt;p&gt;解决方案为在doFi
      
    
    </summary>
    
    
      <category term="exception" scheme="http://iwantjingjing.com/categories/exception/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="exception" scheme="http://iwantjingjing.com/tags/exception/"/>
    
  </entry>
  
  <entry>
    <title> java.io.EOFException</title>
    <link href="http://iwantjingjing.com/2019/09/06/java-io-EOFException/"/>
    <id>http://iwantjingjing.com/2019/09/06/java-io-EOFException/</id>
    <published>2019-09-06T02:45:51.000Z</published>
    <updated>2019-09-28T12:31:51.426Z</updated>
    
    <content type="html"><![CDATA[<p>Caused by: java.io.EOFException: Can not read response from server. Expected to read 4 bytes, read 0 bytes before connection was unexpectedly lost.</p><p>启动ssm项目报上述错误,查了一堆答案</p><p>有说改 jdbc配置的,有说改数据库的<br>顺便还改了下数据库</p><pre><code>show variables like  &apos;wait_timeout&apos;;show global variables like  &apos;%wait%&apos;;        set wait_timeout=86400;</code></pre><p>问题都没有解决</p><p>最终解决方案:</p><p>可能是防火墙,翻墙软件等造成的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Caused by: java.io.EOFException: Can not read response from server. Expected to read 4 bytes, read 0 bytes before connection was unexpect
      
    
    </summary>
    
    
      <category term="exception" scheme="http://iwantjingjing.com/categories/exception/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="spring" scheme="http://iwantjingjing.com/tags/spring/"/>
    
      <category term="异常" scheme="http://iwantjingjing.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>hexo插入图片</title>
    <link href="http://iwantjingjing.com/2019/09/06/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    <id>http://iwantjingjing.com/2019/09/06/hexo插入图片/</id>
    <published>2019-09-06T02:26:13.000Z</published>
    <updated>2019-09-28T12:31:51.425Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。</p><p><img src="/images/image.jpg" alt></p></li><li><p>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。</p></li></ul><pre><code>post_asset_folder: true</code></pre><p>将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。</p><pre><code>_posts/post_name/image.jpg1![](image.jpg)</code></pre><p>[参考] (<a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/" target="_blank" rel="noopener">https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/image.jpg&quot; alt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;图片除了可以放在
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://iwantjingjing.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://iwantjingjing.com/tags/hexo/"/>
    
  </entry>
  
</feed>
