---
title: java 内存模型与volatile关键字
date: 2020-04-27 11:56:54
tags: [java]
categories: [java]
---
[摘自](https://xzh20121116.github.io/post/VPO1pZnCC/)
# Java内存模型
## what（是什么）
一种抽象概念，是一种规则，描述了Java线程间通信的访问方式。
规定了主内存，工作内存（线程本地内存）之间通行的规则。
所有线程都可以访问（读取）主内存的资源，然后将主内存的资源拷贝到自己的工作内存，修改时先修改自己的工作内存，然后将工作内存的资源拷贝到主内存，所有线程都不可直接对主内存进行写入。他们只能直接操作自己的工作内存。
    
    1 一个线程加锁前必须将主内存中的值刷新到自己的工作内存
    2 一个线程解锁前必须将自己工作内存中的值刷新到主内存
    3 加解锁必须是同一个锁

## 主内存与工作内存之间的关系8种
    
    1 lock 作用于主内存 即保证资源被一个线程独享
    2 unlock 作用于主内存 释放一个资源
    3 read 作用于主内存 将一个资源从主内存传输到工作内存
    4 load 作用于工作内存 将读取的资源加载到工作内存
    5 use 工作内存 使用资源以用于显示，传递等
    6 assign 工作内存 赋值 将从控制引擎得到的值赋值给工作内存
    7 store 工作内存 将赋值的值写入存储到工作内存
    8 write 主内存 将存储的值 刷新到主内存
## 三大特性
    原子性 一个操作是不可中断的，即多个线程操作时，一个线程的操作也是不可被打断的，直到操作完成。
    可见性 对主内存的修改，其他线程都能第一时间看到,多线程有问题
    有序性 理想状态是一条一条执行的，但因重排序（指令重拍的存在）顾不是有序的

# volatile关键字
## 保证了两大特性
    
    有序性
    可见性
    
## 有序性原理
当操作由volatile修饰的变量时，jvm会向控制器发送一条带有lock前缀的指令，该指令实际上就形成了一个内存屏障，有效隔离了变量前及变量后的操作，防止了指令重排序。从而实现了有序性

## 可见性原理
lock指令保证了工作内存变量值得有效性，即其他工作内存变量值得无效性。

# 脑图
![](java内存模型、volatile的实现原理.png)
    


