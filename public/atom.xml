<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>I want jing jing</title>
  
  <subtitle>I want jing jing ,Don&#39;t ask me who is jing jing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://iwantjingjing.com/"/>
  <updated>2020-05-29T05:10:18.128Z</updated>
  <id>http://iwantjingjing.com/</id>
  
  <author>
    <name>给予ππ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM内存模型</title>
    <link href="http://iwantjingjing.com/2020/05/29/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://iwantjingjing.com/2020/05/29/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-05-29T04:48:34.000Z</published>
    <updated>2020-05-29T05:10:18.128Z</updated>
    
    <content type="html"><![CDATA[<p><img src="JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="千字不如一图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png&quot; alt=&quot;千字不如一图&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="JVM" scheme="http://iwantjingjing.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://iwantjingjing.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>自旋锁、排队自旋锁、MCS锁、CLH锁</title>
    <link href="http://iwantjingjing.com/2020/05/28/%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E6%8E%92%E9%98%9F%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81MCS%E9%94%81%E3%80%81CLH%E9%94%81/"/>
    <id>http://iwantjingjing.com/2020/05/28/%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E6%8E%92%E9%98%9F%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81MCS%E9%94%81%E3%80%81CLH%E9%94%81/</id>
    <published>2020-05-28T12:50:24.000Z</published>
    <updated>2020-05-28T13:53:12.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p>当锁被其他线程占用时，自己不断的循环检测锁是否释放，不改变线程状态<br>（即不挂起线程或睡眠状态），需占用CPU资源，适用于临界区很小的情况。<br>若线程竞争激烈，则会消耗大量CPU资源，不适用于自旋锁。</p><h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>线程的状态改变是很消耗CPU资源的，所以有了不改变线程状态的自旋锁。<br>适用于锁竞争不是很激烈的情况</p><h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><p>talk is cheap show me the code</p><pre><code>import java.util.concurrent.atomic.AtomicReference;public class SpinLock {   private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;Thread&gt;();   public void lock() {       Thread currentThread = Thread.currentThread();              // 如果锁未被占用，则设置当前线程为锁的拥有者       while (!owner.compareAndSet(null, currentThread)) {       }   }   public void unlock() {       Thread currentThread = Thread.currentThread();              // 只有锁的拥有者才能释放锁       owner.compareAndSet(currentThread, null);   }</code></pre><p>SimpleSpinLock里有一个owner属性持有锁当前拥有者的线程的引用，如果该引用为null，则表示锁未被占用，不为null则被占用。</p><p>这里用AtomicReference是为了使用它的原子性的compareAndSet方法（CAS操作），解决了多线程并发操作导致数据不一致的问题，确保其他线程可以看到锁的真实状态。</p><p>缺点<br>CAS操作需要硬件的配合；<br>保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；<br>没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。       </p><h1 id="排队自旋锁（Ticket-Lock）"><a href="#排队自旋锁（Ticket-Lock）" class="headerlink" title="排队自旋锁（Ticket Lock）"></a>排队自旋锁（Ticket Lock）</h1><h1 id="what-1"><a href="#what-1" class="headerlink" title="what"></a>what</h1><h1 id="why-1"><a href="#why-1" class="headerlink" title="why"></a>why</h1><h1 id="how-1"><a href="#how-1" class="headerlink" title="how"></a>how</h1><h1 id="MCS锁"><a href="#MCS锁" class="headerlink" title="MCS锁"></a>MCS锁</h1><h1 id="what-2"><a href="#what-2" class="headerlink" title="what"></a>what</h1><h1 id="why-2"><a href="#why-2" class="headerlink" title="why"></a>why</h1><h1 id="how-2"><a href="#how-2" class="headerlink" title="how"></a>how</h1><h1 id="CLH锁"><a href="#CLH锁" class="headerlink" title="CLH锁"></a>CLH锁</h1><h1 id="what-3"><a href="#what-3" class="headerlink" title="what"></a>what</h1><h1 id="why-3"><a href="#why-3" class="headerlink" title="why"></a>why</h1><h1 id="how-3"><a href="#how-3" class="headerlink" title="how"></a>how</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自旋锁&quot;&gt;&lt;a href=&quot;#自旋锁&quot; class=&quot;headerlink&quot; title=&quot;自旋锁&quot;&gt;&lt;/a&gt;自旋锁&lt;/h1&gt;&lt;h1 id=&quot;what&quot;&gt;&lt;a href=&quot;#what&quot; class=&quot;headerlink&quot; title=&quot;what&quot;&gt;&lt;/a&gt;wha
      
    
    </summary>
    
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="锁" scheme="http://iwantjingjing.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>钝感力</title>
    <link href="http://iwantjingjing.com/2020/05/14/%E9%92%9D%E6%84%9F%E5%8A%9B/"/>
    <id>http://iwantjingjing.com/2020/05/14/%E9%92%9D%E6%84%9F%E5%8A%9B/</id>
    <published>2020-05-14T08:45:35.000Z</published>
    <updated>2020-05-14T09:13:27.431Z</updated>
    
    <content type="html"><![CDATA[<p>14：46分读完了钝感力这本书。有以下收货：</p><ul><li><p>1、我发现自己读pdf文件1小时大概能读1M（本书有3M，我读完大概花了3个小时）</p></li><li><p>2、所谓钝感力感觉还是要让自己看问题大度些：别把什么都看得太执着。</p></li></ul><p>作者是日本人渡边淳一。间接从一个侧面反映了日本的民族性格。想来一个美国人可能写不出这样的书。作者阐释了<br>啥是钝感力，从心理以及生理上。虽然其举的一些例字不敢苟同，但整体读下来还是挺值得一读的。钝感力可能不能让你立马富有或者啥的，但<br>肯定能让你比之前生活的更幸福。钝感力不是让你一味的忍，而是不要太在意，一些可有可无的小矛盾，能忽略就忽略。<br>钝感力可以让你有更好的适应能力。人最牛逼的能力就是在哪儿都能适应的能力。<br>钝感力不是为了别人，而是真的能让自己活的更好，身体上，心理上都是。</p><p>想来我是一个相对敏感的人，钝感力是一种能力，自己还是要努力锻炼这种能力！</p><h1 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h1><p>宽以待人，豁达处事（金刚经讲就是：应无所住而生其心）</p><h1 id="为什么要有钝感力"><a href="#为什么要有钝感力" class="headerlink" title="为什么要有钝感力"></a>为什么要有钝感力</h1><p> 1 人是社会性动物，而人际关系是第一生产力，有利于人际关系，也就是有利于生产力的发展。</p><p> 2 有利于血液循环</p><p> 3 有利于适应能力提高</p><p> 4 有利于身体健康</p><p> 5 有利于睡眠</p><h1 id="怎样做"><a href="#怎样做" class="headerlink" title="怎样做"></a>怎样做</h1><p>别太把别人说的当回事儿，遇事儿别往心里搁，该吃吃，该喝喝。吃好喝好比啥都重要。没事儿看看鬼畜也挺好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;14：46分读完了钝感力这本书。有以下收货：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1、我发现自己读pdf文件1小时大概能读1M（本书有3M，我读完大概花了3个小时）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2、所谓钝感力感觉还是要让自己看问题大度些：别把什么都看得太执着。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="读书" scheme="http://iwantjingjing.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读后感" scheme="http://iwantjingjing.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>如何设计一个秒杀系统</title>
    <link href="http://iwantjingjing.com/2020/05/11/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/"/>
    <id>http://iwantjingjing.com/2020/05/11/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-05-11T15:20:55.000Z</published>
    <updated>2020-05-11T16:02:44.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高并发系统的几大方向"><a href="#高并发系统的几大方向" class="headerlink" title="高并发系统的几大方向"></a>高并发系统的几大方向</h1><p>1.请求数据尽量少，从而减少cpu消耗</p><p>2.访问路径尽量短，减少节点消耗</p><p>3.强依赖尽量少，减少加载时间</p><p>4.不要有单点，要有备份</p><p>5.减少额外请求，减少加载时间</p><pre><code>设计技巧10w级别可能瓶颈就在数据读取上，通过增加缓存一般就能解决100w那么，可能服务端的网络可能都是瓶颈，所以要把大部分的静态数据放到cdn上甚至缓存在浏览器里</code></pre><h1 id="数据的动静分离"><a href="#数据的动静分离" class="headerlink" title="数据的动静分离"></a>数据的动静分离</h1><h2 id="静态数据做缓存"><a href="#静态数据做缓存" class="headerlink" title="静态数据做缓存"></a>静态数据做缓存</h2><pre><code>第一，你应该把静态数据缓存到离用户最近的地方第二，静态化改造就是要直接缓存 HTTP 连接</code></pre><h2 id="5-个方面来分离出动态内容"><a href="#5-个方面来分离出动态内容" class="headerlink" title="5 个方面来分离出动态内容"></a>5 个方面来分离出动态内容</h2><pre><code>URL 唯一化分离浏览者相关的因素分离时间因素异步化地域因素去掉 Cookie</code></pre><h2 id="动态内容的处理通常有两种方案：ESI（Edge-Side-Includes）方案和-CSI（Client-Side-Include）方案。"><a href="#动态内容的处理通常有两种方案：ESI（Edge-Side-Includes）方案和-CSI（Client-Side-Include）方案。" class="headerlink" title="动态内容的处理通常有两种方案：ESI（Edge Side Includes）方案和 CSI（Client Side Include）方案。"></a>动态内容的处理通常有两种方案：ESI（Edge Side Includes）方案和 CSI（Client Side Include）方案。</h2><ul><li><p>ESI 方案（或者 SSI）：即在 Web 代理服务器上做动态内容请求，并将请求插入到静态页面中，当用户拿到页面时已经是一个完整的页面了。这种方式对服务端性能有些影响，但是用户体验较好</p></li><li><p>CSI 方案。即单独发起一个异步 JavaScript 请求，以向服务端获取动态内容。这种方式服务端性能更佳，但是用户端页面可能会延时，体验稍差。</p></li></ul><h2 id="动静分离的几种架构方案"><a href="#动静分离的几种架构方案" class="headerlink" title="动静分离的几种架构方案"></a>动静分离的几种架构方案</h2><pre><code>实体机单机部署；统一 Cache 层；上 CDN。</code></pre><h1 id="有针对性地处理好系统的“热点数据”"><a href="#有针对性地处理好系统的“热点数据”" class="headerlink" title="有针对性地处理好系统的“热点数据”"></a>有针对性地处理好系统的“热点数据”</h1><h2 id="为什么要关注热点"><a href="#为什么要关注热点" class="headerlink" title="为什么要关注热点"></a>为什么要关注热点</h2><pre><code>28定律 </code></pre><h2 id="什么是“热点”"><a href="#什么是“热点”" class="headerlink" title="什么是“热点”"></a>什么是“热点”</h2><ul><li>热点操作</li></ul><pre><code>读请求写请求 优化方法：存储层根据CAP理论做平衡</code></pre><ul><li>热点数据</li></ul><pre><code>静态热点数据能够提前预测的热点数据动态热点数据不能够提前预测的热点数据</code></pre><h2 id="发现热点数据"><a href="#发现热点数据" class="headerlink" title="发现热点数据"></a>发现热点数据</h2><h3 id="发现静态热点数据"><a href="#发现静态热点数据" class="headerlink" title="发现静态热点数据"></a>发现静态热点数据</h3><pre><code>报名技术手段提前预测</code></pre><h3 id="发现动态热点数据"><a href="#发现动态热点数据" class="headerlink" title="发现动态热点数据"></a>发现动态热点数据</h3><pre><code>构建一个异步的系统，它可以收集交易链路上各个环节中的中间件产品的热点 Key，如 Nginx、缓存、RPC 服务框架等这些中间件（一些中间件产品本身已经有热点统计模块）。建立一个热点上报和可以按照需求订阅的热点服务的下发规范，主要目的是通过交易链路上各个系统（包括详情、购物车、交易、优惠、库存、物流等）访问的时间差，把上游已经发现的热点透传给下游系统，提前做好保护。比如，对于大促高峰期，详情系统是最早知道的，在统一接入层上 Nginx 模块统计的热点 URL将上游系统收集的热点数据发送到热点服务台，然后下游系统（如交易系统）就会知道哪些商品会被频繁调用，然后做热点保护。重点(构建一个异步的系统，它可以收集交易链路上各个环节中的中间件产品的热点 Key，如 Nginx、缓存、RPC 服务框架等这些中间件（一些中间件产品本身已经有热点统计模块）。, 建立一个热点上报和可以按照需求订阅的热点服务的下发规范，主要目的是通过交易链路上各个系统（包括详情、购物车、交易、优惠、库存、物流等）访问的时间差，把上游已经发现的热点透传给下游系统，提前做好保护。比如，对于大促高峰期，详情系统是最早知道的，在统一接入层上 Nginx 模块统计的热点 URL, 将上游系统收集的热点数据发送到热点服务台，然后下游系统（如交易系统）就会知道哪些商品会被频繁调用，然后做热点保护。)</code></pre><h2 id="处理热点数据"><a href="#处理热点数据" class="headerlink" title="处理热点数据"></a>处理热点数据</h2><pre><code>一是优化缓存热点数据LRU 淘汰算法二是限制例如对被访问商品的 ID 做一致性 Hash，然后根据 Hash 做分桶，每个分桶设置一个处理队列，这样可以把热点商品限制在一个请求队列里，防止因某些热点商品占用太多的服务器资源，而使其他请求始终得不到服务器的处理资源。三是隔离业务隔离把秒杀做成一种营销活动，卖家要参加秒杀这种营销活动需要单独报名，从技术上来说，卖家报名后对我们来说就有了已知热点，因此可以提前做好预热。系统隔离系统隔离更多的是运行时的隔离，可以通过分组部署的方式和另外 99% 分开。秒杀可以申请单独的域名，目的也是让请求落到不同的集群中。数据隔离秒杀所调用的数据大部分都是热点数据，比如会启用单独的 Cache 集群或者 MySQL 数据库来放热点数据，目的也是不想 0.01% 的数据有机会影响 99.99% 数据隔离的其他办法比如，你可以按照用户来区分，给不同的用户分配不同的 Cookie，在接入层，路由到不同的服务接口中；再比如，你还可以在接入层针对 URL 中的不同 Path 来设置限流策略。服务层调用不同的服务接口，以及数据层通过给数据打标来区分</code></pre><h1 id="流量削峰这事应该怎么做？"><a href="#流量削峰这事应该怎么做？" class="headerlink" title="流量削峰这事应该怎么做？"></a>流量削峰这事应该怎么做？</h1><h2 id="为什么要削峰"><a href="#为什么要削峰" class="headerlink" title="为什么要削峰"></a>为什么要削峰</h2><ul><li><p>平稳</p></li><li><p>节省服务器的资源成本</p></li></ul><h2 id="方式方法？"><a href="#方式方法？" class="headerlink" title="方式方法？"></a>方式方法？</h2><h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h3><pre><code>消息队列来缓冲瞬时流量，把同步的直接调用转换成异步的间接推送，中间通过一个队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去。利用线程池加锁等待也是一种常用的排队方式；先进先出、先进后出等常用的内存排队算法的实现方式；把请求序列化到文件中，然后再顺序地读文件（例如基于 MySQL binlog 的同步机制）来恢复请求等方式。</code></pre><h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a>答题</h3><pre><code>防止部分买家使用秒杀器在参加秒杀时作弊延缓请求题库生成模块题库的推送模块题目的图片生成模块设计思路(题库生成模块, 题库的推送模块, 题目的图片生成模块)</code></pre><h3 id="分层过滤"><a href="#分层过滤" class="headerlink" title="分层过滤"></a>分层过滤</h3><pre><code>在不同的层次尽可能地过滤掉无效请求，让“漏斗”最末端的才是有效请分层校验的基本原则是将动态请求的读数据缓存（Cache）在 Web 端，过滤掉无效的数据读；对读数据不做强一致性校验，减少因为一致性校验产生瓶颈的问题；对写数据进行基于时间的合理分片，过滤掉过期的失效请求；对写请求做限流保护，将超出系统承载能力的请求过滤掉；对写数据进行强一致性校验，只保留最后有效的数据。</code></pre><h3 id="业务手段"><a href="#业务手段" class="headerlink" title="业务手段"></a>业务手段</h3><pre><code>零点开启优惠券抽奖活动</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>一个是通过队列来缓冲请求，即控制请求的发出；一个是通过答题来延长请求发出的时间，在请求发出后承接请求时进行控制，最后再对不符合条件的请求进行过滤；最后一种是对请求进行分层过滤。队列缓冲能起到很好的削峰和缓冲作用。答题更适用于秒杀或者营销活动等应用场景分层过滤非常适合交易性的写请求</code></pre><h1 id="影响性能的因素有哪些？又该如何提高系统的性能？"><a href="#影响性能的因素有哪些？又该如何提高系统的性能？" class="headerlink" title="影响性能的因素有哪些？又该如何提高系统的性能？"></a>影响性能的因素有哪些？又该如何提高系统的性能？</h1><h2 id="影响性能的因素"><a href="#影响性能的因素" class="headerlink" title="影响性能的因素"></a>影响性能的因素</h2><pre><code>QPS（Query Per Second，每秒请求数）响应时间（Response Time，RT）“总 QPS =（1000ms / 响应时间）× 线程数量”，一个是一次响应的服务端耗时，一个是处理请求的线程数。</code></pre><h2 id="响应时间和-QPS-有啥关系"><a href="#响应时间和-QPS-有啥关系" class="headerlink" title="响应时间和 QPS 有啥关系"></a>响应时间和 QPS 有啥关系</h2><pre><code>真正对性能有影响的是 CPU 的执行时间应该致力于减少 CPU 的执行时间</code></pre><h2 id="线程数对-QPS-的影响"><a href="#线程数对-QPS-的影响" class="headerlink" title="线程数对 QPS 的影响"></a>线程数对 QPS 的影响</h2><pre><code>设置什么样的线程数最合理呢“线程数 = 2 * CPU 核数 + 1”线程数 = [(线程等待时间 + 线程 CPU 时间) / 线程 CPU 时间] × CPU 数量当然，最好的办法是通过性能测试来发现最佳的线程数。</code></pre><h2 id="如何发现瓶颈"><a href="#如何发现瓶颈" class="headerlink" title="如何发现瓶颈"></a>如何发现瓶颈</h2><pre><code>缓存系统而言，制约它的是内存对存储型系统来说 I/O 更容易是瓶颈。秒杀，它的瓶颈更多地发生在 CPU 上海量请求涌过来，你的页面又比较大，那么网络就有可能出现瓶颈。</code></pre><h2 id="如何发现CPU瓶颈？使用工具"><a href="#如何发现CPU瓶颈？使用工具" class="headerlink" title="如何发现CPU瓶颈？使用工具"></a>如何发现CPU瓶颈？使用工具</h2><pre><code>JProfilerYourkitjstack 定时地打印调用栈</code></pre><h2 id="怎样简单地判断-CPU-是不是瓶颈呢"><a href="#怎样简单地判断-CPU-是不是瓶颈呢" class="headerlink" title="怎样简单地判断 CPU 是不是瓶颈呢"></a>怎样简单地判断 CPU 是不是瓶颈呢</h2><pre><code>一个办法就是看当 QPS 达到极限时，你的服务器的 CPU 使用率是不是超过了 95%，如果没有超过，那么表示 CPU 还有提升的空间，要么是有锁限制，要么是有过多的本地 I/O 等待发生。</code></pre><h2 id="如何优化系统"><a href="#如何优化系统" class="headerlink" title="如何优化系统"></a>如何优化系统</h2><pre><code>1. 减少编码网页输出是可以直接进行流输出的，即用 resp.getOutputStream() 函数写数据，把一些静态的数据提前转化成字节，等到真正往外写的时候再直接用 OutputStream() 函数写，就可以减少静态数据的编码转换。网页输出是可以直接进行流输出的，即用 resp.getOutputStream() 函数写数据性能提升30% 左右2. 减少序列化避免或者减少 RPC 就可以减少序列化合并部署部署到一台机器上同一个 Tomcat 容器中且不能走本机的 Socket3. Java 极致优化Web 系统做静态化改造，让大部分请求和数据直接在 Nginx 服务器或者 Web 代理服务器（如 Varnish、Squid 等）上直接返回（这样可以减少数据的序列化与反序列化）直接使用 Servlet 处理请求。避免使用传统的 MVC 框架，这样可以绕过一大堆复杂且用处不大的处理逻辑，节省 1ms 时间（具体取决于你对 MVC 框架的依赖程度）。直接输出流数据。使用 resp.getOutputStream() 而不是 resp.getWriter() 函数，可以省掉一些不变字符数据的编码，从而提升性能；数据输出时推荐使用 JSON 而不是模板引擎（一般都是解释执行）来输出页面。4. 并发读优化放到 Tair 缓存里面集中式缓存为了保证命中率一般都会采用一致性 Hash，所以同一个 key 会落到同一台机器上。虽然单台缓存机器也能支撑 30w/s 的请求，但还是远不足以应对像“大秒”这种级别的热点商品答案是采用应用层的 LocalCache，即在秒杀系统的单机上缓存商品相关的数据。像商品中的“标题”和“描述”这些本身不变的数据，会在秒杀开始之前全量推送到秒杀机器上，并一直缓存到秒杀结束；像库存这类动态数据，会采用“被动失效”的方式缓存一定时间（一般是数秒），失效后再去缓存拉取最新的数据。</code></pre><h1 id="秒杀系统“减库存”设计的核心逻辑"><a href="#秒杀系统“减库存”设计的核心逻辑" class="headerlink" title="秒杀系统“减库存”设计的核心逻辑"></a>秒杀系统“减库存”设计的核心逻辑</h1><h2 id="减库存有哪几种方式"><a href="#减库存有哪几种方式" class="headerlink" title="减库存有哪几种方式"></a>减库存有哪几种方式</h2><ul><li>下单减库存</li></ul><p>控制最精确</p><p>不会出现超卖</p><p>有些人下完单可能并不会付款</p><ul><li>付款减库存</li></ul><p>并发比较高，有可能出现买家下单后付不了款的情况，因为可能商品已经被其他人买走了。</p><ul><li>预扣库存</li></ul><p>买家下单后，库存为其保留一定的时间（如 10 分钟），超过这个时间，库存将会自动释放，释放后其他买家就可以继续购买。在买家付款前，系统会校验该订单的库存是否还有保留：如果没有保留，则再次尝试预扣；如果库存不足（也就是预扣失败）则不允许继续付款；如果预扣成功，则完成付款并实际地减去库存</p><h2 id="减库存可能存在的问题"><a href="#减库存可能存在的问题" class="headerlink" title="减库存可能存在的问题"></a>减库存可能存在的问题</h2><ul><li>下单减库存</li></ul><p>恶意下单商品就不能正常售卖</p><ul><li>付款减库存”又会导致另外一个问题：库存超卖。</li></ul><p>下单成功但是付不了款，买家的购物体验自然比较差。</p><ul><li>预扣库存</li></ul><p>一定程度上缓解上面的问题，但无法彻底解决</p><h2 id="解决办法还是要结合安全和反作弊的措施来制止。"><a href="#解决办法还是要结合安全和反作弊的措施来制止。" class="headerlink" title="解决办法还是要结合安全和反作弊的措施来制止。"></a>解决办法还是要结合安全和反作弊的措施来制止。</h2><pre><code>给经常下单不付款的买家进行识别打标（可以在被打标的买家下单时不减库存给某些类目设置最大购买件数（例如，参加活动的商品一人最多只能买 3 件）以及对重复下单不付款的操作进行次数限制等。对普通的商品下单数量超过库存数量的情况，可以通过补货来解决有些卖家完全不允许库存为负数的情况，那只能在买家付款时提示库存不足。</code></pre><h1 id="大型秒杀中如何减库存？"><a href="#大型秒杀中如何减库存？" class="headerlink" title="大型秒杀中如何减库存？"></a>大型秒杀中如何减库存？</h1><pre><code>下单减库存由于参加秒杀的商品，一般都是“抢到就是赚到”，所以成功下单后却不付款的情况比较少，再加上卖家对秒杀商品的库存有严格限制，所以秒杀商品采用“下单减库存”更加合理。另外，理论上由于“下单减库存”比“预扣库存”以及涉及第三方支付的“付款减库存”在逻辑上更为简单，所以性能上更占优势。主要就是保证大并发请求时库存数据不能为负数一种是在应用程序中通过事务来判断，即保证减后库存不能为负数，否则就回滚；另一种办法是直接设置数据库的字段数据为无符号整数，这样减后库存字段值小于零时会直接执行 SQL 语句来报错再有一种就是使用 CASE WHEN 判断语句，例如这样的 SQL 语句：UPDATE item SET inventory = CASE WHEN inventory &gt;= xxx THEN inventory-xxx ELSE inventory END</code></pre><h2 id="秒杀减库存的极致优化"><a href="#秒杀减库存的极致优化" class="headerlink" title="秒杀减库存的极致优化"></a>秒杀减库存的极致优化</h2><pre><code>缓存中减库存秒杀商品的减库存逻辑非常单一，比如没有复杂的 SKU 库存和总库存这种联动关系的话可以在缓存中做数据库中减库存比较复杂的减库存逻辑，或者需要使用事务，你还是必须在数据库中完成减库存。单个热点商品会影响整个数据库的性能进行隔离，把热点商品放到单独的热点库中。但是这无疑会带来维护上的麻烦，比如要做热点数据的动态迁移以及单独的数据库等。由于 MySQL 存储数据的特点，同一数据在数据库里肯定是一行存储（MySQL），因此会有大量线程来竞争 InnoDB 行锁，而并发度越高时等待线程会越多，</code></pre><h2 id="要解决并发锁的问题，有两种办法："><a href="#要解决并发锁的问题，有两种办法：" class="headerlink" title="要解决并发锁的问题，有两种办法："></a>要解决并发锁的问题，有两种办法：</h2><pre><code>应用层做排队。按照商品维度设置队列顺序执行，这样能减少同一台机器对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量，防止热点商品占用太多的数据库连接。数据库层做排队。应用层只能做到单机的排队，但是应用机器数本身很多，这种排队方式控制并发的能力仍然有限，所以如果能在数据库层做全局排队是最理想的。阿里的数据库团队开发了针对这种 MySQL 的 InnoDB 层上的补丁程序（patch），可以在数据库层上对单行记录做到并发排队。</code></pre><h1 id="准备Plan-B：如何设计兜底方案"><a href="#准备Plan-B：如何设计兜底方案" class="headerlink" title="准备Plan B：如何设计兜底方案?"></a>准备Plan B：如何设计兜底方案?</h1><h2 id="高可用建设应该从哪里着手"><a href="#高可用建设应该从哪里着手" class="headerlink" title="高可用建设应该从哪里着手"></a>高可用建设应该从哪里着手</h2><ul><li>架构阶段</li></ul><pre><code>可扩展性容错性避免系统出现单点问题多机房单元化部署，即使某个城市的某个机房出现整体故障，仍然不会影响整体网站的运转</code></pre><ul><li>编码阶段</li></ul><pre><code>健壮性涉及远程调用问题时，要设置合理的超时退出机制，防止被其他系统拖垮也要对调用的返回结果集有预期，防止返回的结果超出程序处理范围，最常见的做法就是对错误异常进行捕获，对无法预料的错误要有默认处理结果</code></pre><ul><li>测试阶段</li></ul><pre><code>保证测试用例的覆盖度，保证最坏情况发生时，我们也有相应的处理流程。</code></pre><ul><li>发布阶段</li></ul><pre><code>要有紧急的回滚机制。</code></pre><ul><li>运行阶段</li></ul><pre><code>运行态最重要的是对系统的监控要准确及时，发现问题能够准确报警并且报警数据要准确详细，以便于排查问题</code></pre><ul><li>故障发生</li></ul><pre><code>最重要的就是及时止损例如由于程序问题导致商品价格错误，那就要及时下架商品或者关闭购买链接，防止造成重大资产损失。然后就是要能够及时恢复服务，并定位原因解决问题。</code></pre><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>所谓“降级”，就是当系统的容量达到一定程度时，限制或者关闭系统的某些非核心功能，从而把有限的资源保留给更核心的业务</p><p>可以通过预案系统和开关系统来实现降级</p><p>当秒杀流量达到 5w/s 时，把成交记录的获取从展示 20 条降级到只展示 5 条。“从 20 改到 5”这个操作由一个开关来实现，也就是设置一个能够从开关系统动态获取的系统参数。</p><p>降级的核心目标是牺牲次要的功能和用户体验来保证核心业务流程的稳定，是一个不得已而为之的举措。</p><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>基于 QPS 和线程数的限流应用最多，最大 QPS 很容易通过压测提前获取，例如我们的系统最高支持 1w QPS 时，可以设置 8000 来进行限流保护。线程数限流在客户端比较有效，例如在远程调用时我们设置连接池的线程数，超出这个并发线程请求，就将线程进行排队或者直接超时丢弃。</p><p>限流无疑会影响用户的正常请求，所以必然会导致一部分用户请求失败，因此在系统处理这种异常时一定要设置超时时间，防止因被限流的请求不能 fast fail（快速失败）而拖垮系统。</p><p>可以是在客户端限流，也可以是在服务端限流</p><p>限流的实现方式既要支持 URL 以及方法级别的限流，也要支持基于 QPS 和线程的限流。</p><p>客户端限流</p><p>好处可以限制请求的发出，通过减少发出无用请求从而减少对系统的消耗。缺点就是当客户端比较分散时，没法设置合理的限流阈值：如果阈值设的太小，会导致服务端没有达到瓶颈时客户端已经被限制；而如果设的太大，则起不到限制的作用。</p><p>服务端限流</p><p>好处是可以根据服务端的性能设置合理的阈值，而缺点就是被限制的请求都是无效的请求，处理这些无效的请求本身也会消耗服务器资源。</p><h2 id="拒绝服务"><a href="#拒绝服务" class="headerlink" title="拒绝服务"></a>拒绝服务</h2><p> CPU 使用率达到 90% 或者系统 load 值达到 2*CPU 核数时，系统直接拒绝所有请求</p><p>在最前端的 Nginx 上设置过载保护，当机器负载达到某个值时直接拒绝 HTTP 请求并返回 503 错误码，在 Java 层同样也可以设计过载保护</p><p>像这种系统过载保护虽然在过载时无法提供服务，但是系统仍然可以运作，当负载下降时又很容易恢复，所以每个系统和每个环节都应该设置这个兜底方案，对系统做最坏情况下的保护。</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>预防</p><p>建立常态的压力体系，例如上线前的单机压测到上线后的全链路压测</p><p>管控</p><p>做好线上运行时的降级、限流和兜底保护</p><p>监控</p><p>建立性能基线来记录性能的变化趋势以及线上机器的负载报警体系，发现问题及时预警</p><p>恢复体系</p><p>遇到故障要及时止损，并提供快速的数据订正工具等</p><p>准</p><p>稳</p><p>快</p><p>提高单次请求的效率</p><p>减少没必要的请求</p><p>秒杀核心<br>(准, 稳, 快)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;高并发系统的几大方向&quot;&gt;&lt;a href=&quot;#高并发系统的几大方向&quot; class=&quot;headerlink&quot; title=&quot;高并发系统的几大方向&quot;&gt;&lt;/a&gt;高并发系统的几大方向&lt;/h1&gt;&lt;p&gt;1.请求数据尽量少，从而减少cpu消耗&lt;/p&gt;
&lt;p&gt;2.访问路径尽量短，减
      
    
    </summary>
    
    
    
      <category term="架构" scheme="http://iwantjingjing.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="秒杀" scheme="http://iwantjingjing.com/tags/%E7%A7%92%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://iwantjingjing.com/2020/04/28/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://iwantjingjing.com/2020/04/28/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-28T07:31:50.000Z</published>
    <updated>2020-04-28T07:45:39.768Z</updated>
    
    <content type="html"><![CDATA[<pre><code>public class Test02 {      /**      * 单例模式，懒汉式，线程安全      */      public static class Singleton {          private final static Singleton INSTANCE = new Singleton();          private Singleton() {          }          public static Singleton getInstance() {              return INSTANCE;          }      }        /**      * 单例模式，饿汉式，线程不安全      */      public static class Singleton2 {          private static Singleton2 instance = null;          private Singleton2() {          }          public static Singleton2 getInstance() {              if (instance == null) {                  instance = new Singleton2();              }              return instance;          }      }      /**      * 单例模式，饿汉式，线程安全，多线程环境下效率不高      */      public static class Singleton3 {          private static Singleton3 instance = null;          private Singleton3() {          }          public static synchronized Singleton3 getInstance() {              if (instance == null) {                  instance = new Singleton3();              }              return instance;          }      }      /**      * 单例模式，懒汉式，变种，线程安全      */      public static class Singleton4 {          private static Singleton4 instance = null;          static {              instance = new Singleton4();          }          private Singleton4() {          }          public static Singleton4 getInstance() {              return instance;          }      }      /**      * 单例模式，使用静态内部类，线程安全【推荐】      */      public static class Singleton5 {          private final static class SingletonHolder {              private static final Singleton5 INSTANCE = new Singleton5();          }          private Singleton5() {          }          public static Singleton5 getInstance() {              return SingletonHolder.INSTANCE;          }      }      /**      * 静态内部类，使用枚举方式，线程安全【推荐】      */      public enum Singleton6 {          INSTANCE;          public void whateverMethod() {          }      }      /**      * 静态内部类，使用双重校验锁，线程安全【推荐】      */      public static class Singleton7 {          private volatile static Singleton7 instance = null;          private Singleton7() {          }          public static Singleton7 getInstance() {              if (instance == null) {                  synchronized (Singleton7.class) {                      if (instance == null) {                          instance = new Singleton7();                      }                  }              }              return instance;          }      }      public static void main(String[] args) {          System.out.println(Singleton.getInstance() == Singleton.getInstance());          System.out.println(Singleton2.getInstance() == Singleton2.getInstance());          System.out.println(Singleton3.getInstance() == Singleton3.getInstance());          System.out.println(Singleton4.getInstance() == Singleton4.getInstance());          System.out.println(Singleton5.getInstance() == Singleton5.getInstance());          System.out.println(Singleton6.INSTANCE == Singleton6.INSTANCE);          System.out.println(Singleton7.getInstance() == Singleton7.getInstance());      }  }  </code></pre><p><a href="https://wiki.jikexueyuan.com/project/for-offer/question-two.html" target="_blank" rel="noopener">参考1</a><br><a href="https://blog.csdn.net/u011595939/article/details/79972371" target="_blank" rel="noopener">参考2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;public class Test02 {  
    /** 
     * 单例模式，懒汉式，线程安全 
     */  
    public static class Singleton {  
        private final stat
      
    
    </summary>
    
    
      <category term="java" scheme="http://iwantjingjing.com/categories/java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="设计模式" scheme="http://iwantjingjing.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>私有构造函数的作用</title>
    <link href="http://iwantjingjing.com/2020/04/28/%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://iwantjingjing.com/2020/04/28/%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8/</id>
    <published>2020-04-28T06:48:41.000Z</published>
    <updated>2020-04-28T06:56:13.781Z</updated>
    
    <content type="html"><![CDATA[<p>1 防止对象被随意创建</p><p>2 用于实现单例</p><p>3 工具类防止实例化（不创建对象，方法设为静态，可通过对象.来调用）</p><p>4 应用于工厂模式的实现</p><pre><code>父类方法调用子类实现1。你可以返回任何的Shape类型，包括Shape的子类。比如你可以把makeShape写成这样：public class Shape {    private Shape() {       /* set something here */    }    public static Shape makeShape(/* arglist */) {           System.out.println(&quot;here is the shape you ordered&quot;);           if (retangle)                 return (new Retangle(/* arglist*/));           if (Circle)                return (new Circle(/* arglist */));        /* you can return as many shapes as you like */        }}    这里假设Retangle 和 Circle 都是shape的子类，并且和Shape类在同一个包內，Shape类可以访问子类的构造函数。这样shape就提供了一个图形工厂。 用户通过一个接口就可以生成不同的图形。事实上，这种用法被称为“工厂模式”。</code></pre><p>5 方便抛出异常</p><pre><code>在构造器中的异常一般会被jvm抛弃    </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1 防止对象被随意创建&lt;/p&gt;
&lt;p&gt;2 用于实现单例&lt;/p&gt;
&lt;p&gt;3 工具类防止实例化（不创建对象，方法设为静态，可通过对象.来调用）&lt;/p&gt;
&lt;p&gt;4 应用于工厂模式的实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;父类方法调用子类实现
1。你可以返回任何的Shape类型，包括S
      
    
    </summary>
    
    
      <category term="java" scheme="http://iwantjingjing.com/categories/java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL · 特性分析 · 到底是谁执行了FTWRL</title>
    <link href="http://iwantjingjing.com/2020/04/28/MySQL-%C2%B7-%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90-%C2%B7-%E5%88%B0%E5%BA%95%E6%98%AF%E8%B0%81%E6%89%A7%E8%A1%8C%E4%BA%86FTWL/"/>
    <id>http://iwantjingjing.com/2020/04/28/MySQL-%C2%B7-%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90-%C2%B7-%E5%88%B0%E5%BA%95%E6%98%AF%E8%B0%81%E6%89%A7%E8%A1%8C%E4%BA%86FTWL/</id>
    <published>2020-04-28T03:35:31.000Z</published>
    <updated>2020-04-28T03:42:53.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><pre><code>FTWRL是flush table with read lock的简称。该命令主要用于保证备份一致性备份 全局读锁(lock_global_read_lock) 会导致所有的更新操作被堵塞全局COMMIT锁(make_global_read_lock_block_commit) 会导致所有的活跃事务无法提交FLUSH TABLES WITH READ LOCK执行后整个系统会一直处于只读状态，直到显示执行UNLOCK TABLES。这点请切记。</code></pre><h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><p><img src="tmp.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;what&quot;&gt;&lt;a href=&quot;#what&quot; class=&quot;headerlink&quot; title=&quot;what&quot;&gt;&lt;/a&gt;what&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;FTWRL是flush table with read lock的简称。
该命令主要用于保证备份一致性备份 
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://iwantjingjing.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://iwantjingjing.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql之锁</title>
    <link href="http://iwantjingjing.com/2020/04/28/mysql%E4%B9%8B%E9%94%81/"/>
    <id>http://iwantjingjing.com/2020/04/28/mysql%E4%B9%8B%E9%94%81/</id>
    <published>2020-04-28T01:03:29.000Z</published>
    <updated>2020-04-28T01:39:11.241Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://xzh20121116.github.io/post/mysql-zhi-suo/" target="_blank" rel="noopener">摘自</a></p><h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><pre><code>加锁 lock tablas ...read/write主动解锁 unlock tables ... 被动解锁 客户端断开连接时被动解锁限制其他线程读写，也会对本线程接下来的操作对象。一般不用，消耗大</code></pre><h2 id="MDL（元数据锁-meta-data-lock）"><a href="#MDL（元数据锁-meta-data-lock）" class="headerlink" title="MDL（元数据锁 meta data lock）"></a>MDL（元数据锁 meta data lock）</h2><pre><code>自动加锁读锁 对表数据的增删改查写锁 对表结构的修改多个事务读锁不互斥多个事务写锁互斥mdl作用保证读写的正确性</code></pre><h1 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h1><p>根据数据引擎来实现的，MyIsam就不支持行锁</p><h2 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h2><pre><code>innodb中有需要时加此锁，但并非不需要时解锁，而是在事务提交之后解锁。若一个事务锁多行，尽可能把并发多的行往后写。</code></pre><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><pre><code>事务a等待事务b释放某行的锁，事务b等待事务a释放某行的锁就造成死锁。例如：事务a update table a ... where line = 1;事务b update table a ... where line = 2;事务a update table a ... where line = 2;事务b update table a ... where line = 1;事务a等待事务b释放line=2的锁，事务b等待事务a释放line=1的锁，由于两阶段锁的存在（即事务只有在commit之后才释放锁）顾造成锁都释放不了，造成死锁。</code></pre><h2 id="mvcc-多版本并发控制"><a href="#mvcc-多版本并发控制" class="headerlink" title="mvcc(多版本并发控制)"></a>mvcc(多版本并发控制)</h2><pre><code>mysql在修改一行数据时，都会记录一行此数据相应的回滚操作，若某行数据被改了n次，则此事务相应的回滚记录也被记录了n次。这种一条数据在系统中有多个版本就是多版本并发控制mvcc.</code></pre><h1 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h1><p> <img src="mysql%E4%B9%8B%E9%94%81.png" alt=""> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://xzh20121116.github.io/post/mysql-zhi-suo/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;摘自&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;表级锁&quot;&gt;&lt;a href=&quot;#表级锁&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://iwantjingjing.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://iwantjingjing.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>java 内存模型与volatile关键字</title>
    <link href="http://iwantjingjing.com/2020/04/27/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8Evolatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://iwantjingjing.com/2020/04/27/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8Evolatile%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-04-27T03:56:54.000Z</published>
    <updated>2020-04-27T04:37:03.720Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://xzh20121116.github.io/post/VPO1pZnCC/" target="_blank" rel="noopener">摘自</a></p><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="what（是什么）"><a href="#what（是什么）" class="headerlink" title="what（是什么）"></a>what（是什么）</h2><p>一种抽象概念，是一种规则，描述了Java线程间通信的访问方式。<br>规定了主内存，工作内存（线程本地内存）之间通行的规则。<br>所有线程都可以访问（读取）主内存的资源，然后将主内存的资源拷贝到自己的工作内存，修改时先修改自己的工作内存，然后将工作内存的资源拷贝到主内存，所有线程都不可直接对主内存进行写入。他们只能直接操作自己的工作内存。</p><pre><code>1 一个线程加锁前必须将主内存中的值刷新到自己的工作内存2 一个线程解锁前必须将自己工作内存中的值刷新到主内存3 加解锁必须是同一个锁</code></pre><h2 id="主内存与工作内存之间的关系8种"><a href="#主内存与工作内存之间的关系8种" class="headerlink" title="主内存与工作内存之间的关系8种"></a>主内存与工作内存之间的关系8种</h2><pre><code>1 lock 作用于主内存 即保证资源被一个线程独享2 unlock 作用于主内存 释放一个资源3 read 作用于主内存 将一个资源从主内存传输到工作内存4 load 作用于工作内存 将读取的资源加载到工作内存5 use 工作内存 使用资源以用于显示，传递等6 assign 工作内存 赋值 将从控制引擎得到的值赋值给工作内存7 store 工作内存 将赋值的值写入存储到工作内存8 write 主内存 将存储的值 刷新到主内存</code></pre><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><pre><code>原子性 一个操作是不可中断的，即多个线程操作时，一个线程的操作也是不可被打断的，直到操作完成。可见性 对主内存的修改，其他线程都能第一时间看到,多线程有问题有序性 理想状态是一条一条执行的，但因重排序（指令重拍的存在）顾不是有序的</code></pre><h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><h2 id="保证了两大特性"><a href="#保证了两大特性" class="headerlink" title="保证了两大特性"></a>保证了两大特性</h2><pre><code>有序性可见性</code></pre><h2 id="有序性原理"><a href="#有序性原理" class="headerlink" title="有序性原理"></a>有序性原理</h2><p>当操作由volatile修饰的变量时，jvm会向控制器发送一条带有lock前缀的指令，该指令实际上就形成了一个内存屏障，有效隔离了变量前及变量后的操作，防止了指令重排序。从而实现了有序性</p><h2 id="可见性原理"><a href="#可见性原理" class="headerlink" title="可见性原理"></a>可见性原理</h2><p>lock指令保证了工作内存变量值得有效性，即其他工作内存变量值得无效性。</p><h1 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h1><p><img src="java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E3%80%81volatile%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://xzh20121116.github.io/post/VPO1pZnCC/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;摘自&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; c
      
    
    </summary>
    
    
      <category term="java" scheme="http://iwantjingjing.com/categories/java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础题</title>
    <link href="http://iwantjingjing.com/2020/04/19/Java%E5%9F%BA%E7%A1%80%E9%A2%98/"/>
    <id>http://iwantjingjing.com/2020/04/19/Java%E5%9F%BA%E7%A1%80%E9%A2%98/</id>
    <published>2020-04-19T08:50:24.000Z</published>
    <updated>2020-04-19T09:20:51.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-以下哪个是finalize-方法的正确形式？"><a href="#1-以下哪个是finalize-方法的正确形式？" class="headerlink" title="1.以下哪个是finalize()方法的正确形式？"></a>1.以下哪个是finalize()方法的正确形式？</h1><pre><code>A.protected void finalize() throws ThrowableB.final finalize()C.public final finalize()D.private boolean finalize()答案：A</code></pre><h1 id="2-如果finalize（）方法抛出一个运行时异常，以下哪个描述正确？"><a href="#2-如果finalize（）方法抛出一个运行时异常，以下哪个描述正确？" class="headerlink" title="2.如果finalize（）方法抛出一个运行时异常，以下哪个描述正确？"></a>2.如果finalize（）方法抛出一个运行时异常，以下哪个描述正确？</h1><pre><code>A.正在运行的应用程序系统崩溃B.此异常被忽略，并且该异常对象被垃圾回收器回收C.此异常被忽略，但是该异常对象未被垃圾回收期回收D.此异常导致JVM崩溃答案：B答案解析：finalize()方法只是用于清除对象，而不是实际的销毁对象，因此对该方法的调用不会引起系统崩溃，该方法抛出的异常也会作为废弃对象被垃圾回收期回收</code></pre><h1 id="3-如何释放掉一个对象占据的内存空间？"><a href="#3-如何释放掉一个对象占据的内存空间？" class="headerlink" title="3.如何释放掉一个对象占据的内存空间？"></a>3.如何释放掉一个对象占据的内存空间？</h1><pre><code>A.调用free()方法B.调用System.gc()方法C.赋值给该对象的引用为nullD.程序员无法明确强制垃圾回收器运行答案：D</code></pre><h1 id="4-给出以下代码："><a href="#4-给出以下代码：" class="headerlink" title="4.给出以下代码："></a>4.给出以下代码：</h1><pre><code>1.public class Example {2. public static void main(String[] args) {3.  String s = &quot;abcd&quot;;4.  Integer x = new Integer(3);5.  String s2 = s + 4;6.  s2 = null;7.  s = null;8. }9.}改程序运行到第几行变量S2引用的对象符合垃圾回收器回收条件？A.第7行B.不存在C.第6行D.直到main线程结束，S2应用的对象才可能被回收答案：C</code></pre><h1 id="5-以下代码运行到关键点处，有多少对象符合垃圾回收的条件？"><a href="#5-以下代码运行到关键点处，有多少对象符合垃圾回收的条件？" class="headerlink" title="5.以下代码运行到关键点处，有多少对象符合垃圾回收的条件？"></a>5.以下代码运行到关键点处，有多少对象符合垃圾回收的条件？</h1><pre><code>public class Example { public static void main(String[] args) {  String name;  String newName = &quot;Nick&quot;;  newName = &quot;Jason&quot;;  name = &quot;Frieda&quot;;  String newestName = name;  name = null;  // 关键点 }}A.0个B.1个C.2个D.3个答案：B</code></pre><h1 id="6-以下哪些是有关垃圾回收器的正确描述？"><a href="#6-以下哪些是有关垃圾回收器的正确描述？" class="headerlink" title="6.以下哪些是有关垃圾回收器的正确描述？"></a>6.以下哪些是有关垃圾回收器的正确描述？</h1><pre><code>A.程序员可以在制定时间调用垃圾回收器释放内存B.垃圾回收器可以保证Java程序不会产生内存溢出C.程序员可以制定垃圾回收器回收对象D.对象的finalize()方法在对象被垃圾回收器回收之前获得调用答案：C、D答案解析：通过通配符*号引入的两个不同包中存在同名的类，当代码中不加包名直接使用时，会产生编译错误，使用时需要提供完整包路径</code></pre><h1 id="7-拥有下列哪些引用类型的对象在虚拟机内存足够的情况下不会被垃圾回收机制回收？"><a href="#7-拥有下列哪些引用类型的对象在虚拟机内存足够的情况下不会被垃圾回收机制回收？" class="headerlink" title="7.拥有下列哪些引用类型的对象在虚拟机内存足够的情况下不会被垃圾回收机制回收？"></a>7.拥有下列哪些引用类型的对象在虚拟机内存足够的情况下不会被垃圾回收机制回收？</h1><pre><code>A.强引用B.软引用C.弱引用D.虚引用答案：A、B</code></pre><h1 id="8-finalize和C-的-destructors有何差异"><a href="#8-finalize和C-的-destructors有何差异" class="headerlink" title="8.finalize和C++ 的 destructors有何差异?"></a>8.finalize和C++ 的 destructors有何差异?</h1><pre><code>答案：Java内部具有“内存使用回收” 的机制， 虽然它也提供了类似 (C++ 的) destructors的 finalize()，每个对象都可以使用这个方法 method，但必须冒著破坏原先回收机制的危险。所以建议尽量避免使用finalize()，不妨考虑多使用引用队列来释出资源会好一些。</code></pre><h1 id="9-Java语言中异常的分类是哪项？"><a href="#9-Java语言中异常的分类是哪项？" class="headerlink" title="9.Java语言中异常的分类是哪项？"></a>9.Java语言中异常的分类是哪项？</h1><pre><code>A.运行时异常和异常B.受检异常和非受检异常C.错误和异常D.错误和运行时异常答案：C</code></pre><h1 id="10-所有异常的父类是哪项？"><a href="#10-所有异常的父类是哪项？" class="headerlink" title="10.所有异常的父类是哪项？"></a>10.所有异常的父类是哪项？</h1><pre><code>A.ThrowableB.ErrorC.RuntimeExceptionD.Exception答案：A</code></pre><h1 id="11-下列属于非受检异常（运行时异常）的是哪项？"><a href="#11-下列属于非受检异常（运行时异常）的是哪项？" class="headerlink" title="11.下列属于非受检异常（运行时异常）的是哪项？"></a>11.下列属于非受检异常（运行时异常）的是哪项？</h1><pre><code>A.SQLExceptionB.IOExceptionC.NullPointerExceptionD.OutOfMemoryError答案：C</code></pre><h1 id="12-假设有自定义异常类ServiceException-那么抛出该异常的语句正确的是哪项？"><a href="#12-假设有自定义异常类ServiceException-那么抛出该异常的语句正确的是哪项？" class="headerlink" title="12.假设有自定义异常类ServiceException,那么抛出该异常的语句正确的是哪项？"></a>12.假设有自定义异常类ServiceException,那么抛出该异常的语句正确的是哪项？</h1><pre><code>A.raise ServiceExceptionB.throw new ServiceException()C.throw ServiceExceptionD.throws ServiceException答案：B</code></pre><h1 id="13-在方法声明中，说明该方法可能会抛出的异常列表时使用哪个关键字？"><a href="#13-在方法声明中，说明该方法可能会抛出的异常列表时使用哪个关键字？" class="headerlink" title="13.在方法声明中，说明该方法可能会抛出的异常列表时使用哪个关键字？"></a>13.在方法声明中，说明该方法可能会抛出的异常列表时使用哪个关键字？</h1><pre><code>A.throw B.catchC.finallyD.throws答案：D</code></pre><h1 id="14-现有代码："><a href="#14-现有代码：" class="headerlink" title="14.现有代码："></a>14.现有代码：</h1><pre><code>public class Example { public static void main(String[] args) {  try {   System.out.print(Integer.parseInt(&quot;forty&quot;));     } catch (RuntimeException e) {   System.out.println(&quot;Runtime&quot;);  }catch (NumberFormatException e) {   System.out.println(&quot;Number&quot;);  } }}执行结果是什么？A.输出NumberB.输出RuntimeC.输出40D.编译失败答案：D答案解析：NumberFormatException是RuntimeException的子类，因此两个catch块位置应该交换才能正确处理异常</code></pre><h1 id="15-现有代码如下："><a href="#15-现有代码如下：" class="headerlink" title="15.现有代码如下："></a>15.现有代码如下：</h1><pre><code>public class Example { void topGo() {  try {   middleGo();  } catch (Exception e) {   System.out.println(&quot;catch&quot;);  } } void middleGo() throws Exception {  go();  System.out.println(&quot;late middle&quot;); } void go() throws Exception {  throw new Exception(); } public static void main(String[] args) {  Example example = new Example();  example.topGo(); }}该代码的执行结果是？A.输出late middleB.输出catchC.输出late middle catchD.输出catch late middle答案：B</code></pre><h1 id="16-如下代码执行后的输出结果是？"><a href="#16-如下代码执行后的输出结果是？" class="headerlink" title="16.如下代码执行后的输出结果是？"></a>16.如下代码执行后的输出结果是？</h1><pre><code>public class Example { public static void main(String[] args) {  try {   throw new Exception();  } catch (Exception e) {   try {    throw new Exception();   } catch (Exception e2) {    System.out.println(&quot;inner&quot;);   }   System.out.println(&quot;middle&quot;);  }  System.out.println(&quot;out&quot;); }}A.inner outerB.middle outerC.inner middle outerD.编译失败答案：C</code></pre><h1 id="17-现有如下代码："><a href="#17-现有如下代码：" class="headerlink" title="17.现有如下代码："></a>17.现有如下代码：</h1><pre><code>public class Example extends Utils{ public static void main(String[] args) {  try {   System.out.println(new Example().getInt(&quot;42&quot;));  } catch (NumberFormatException e) {   System.out.println(&quot;NFExc&quot;);  } }  int getInt(String arg) throws NumberFormatException{  return Integer.parseInt(arg); }}class Utils { int getInt(String arg) {  return 42; }}该代码执行的结果是？A.NFExcB.42.0C.42NFExcD.编译失败答案：B答案解析：Utils中的getInt方法没有抛出异常，而子类Example中的getInt抛出了运行时异常，这是符合方法覆盖的抛出异常特性规范的，因为运行时异常并不会强制要求方法调用代码捕获处理</code></pre><h1 id="18-现有如下代码："><a href="#18-现有如下代码：" class="headerlink" title="18.现有如下代码："></a>18.现有如下代码：</h1><pre><code>public class Example extends Utils{ public static void main(String[] args) {  try {   System.out.println(new Example().getInt(&quot;42&quot;));  } catch (NumberFormatException e) {   System.out.println(&quot;NFExc&quot;);  } }  int getInt(String arg) throws Exception{  return Integer.parseInt(arg); }}class Utils { int getInt(String arg) {  return 42; }}该代码执行的结果是？A.NFExcB.42.0C.42NFExcD.编译失败答案：D答案解析：子类抛出的异常不符合方法覆盖的异常列表要求，因此编译失败（见上题）</code></pre><h1 id="19-现有如下代码："><a href="#19-现有如下代码：" class="headerlink" title="19.现有如下代码："></a>19.现有如下代码：</h1><pre><code>public class Example { public static void main(String[] args) {// a  new Example().topGo(); } void topGo() {// b  middleGo(); } void middleGo() {// c  go();  System.out.println(&quot;late middle&quot;); } void go() {// d  throw new Exception(); }}为了使代码能够编译通过，需要在哪个地方加入声明throws Exception?A.dB.c和dC.b、c和dD.a、b、c和d答案：D</code></pre><h1 id="20-下面代码的执行结果是？"><a href="#20-下面代码的执行结果是？" class="headerlink" title="20.下面代码的执行结果是？"></a>20.下面代码的执行结果是？</h1><pre><code>class Example extends Utils { public static void main(String[] args) {  try {   System.out.print(new Example().getlnt(&quot;42&quot;));  } catch (Exception e) {   System.out.println(&quot;Exc&quot;);  } } int getlnt(String arg) throws Exception {  return Integer.parseInt(arg); }}class Utils { int getlnt() {  return 42; }}A.NFExcB.42.0C.42NFExcD.编译失败答案：B答案解析：本题没有实现方法覆盖</code></pre><h1 id="21-关于异常处理，说法错误的是？"><a href="#21-关于异常处理，说法错误的是？" class="headerlink" title="21.关于异常处理，说法错误的是？"></a>21.关于异常处理，说法错误的是？</h1><pre><code>A.try⋯catch⋯finally结构中，必须有try语句块，catch语句块和finally语句块不是必须的，但至少要两者取其一B.在异常处理中，若try中的代码可能产生多种异常则可以对应多个catch语句，若catch中的参数类型有父类子类关系，此时应该将子类放在后面，父类放在前面C.一个方法可以抛出多个异常，方法的返回值也能够是异常D.Throwable是所有异常的超类答案：B答案解析：若catch中的参数类型有父类子类关系，此时应该将子类放在前面，父类放在后面</code></pre><h1 id="22-以下关于Error和Exception类的描述正确的是？"><a href="#22-以下关于Error和Exception类的描述正确的是？" class="headerlink" title="22.以下关于Error和Exception类的描述正确的是？"></a>22.以下关于Error和Exception类的描述正确的是？</h1><pre><code>A.Error类和Exception类都是Throwable类的子类B.Error类是一个final类，而Exception类是一个非final类C.Exception类是一个final类，而Error类是一个非final类D.Error类和Exception类都实现了Throwable接口答案：A</code></pre><h1 id="23-请问以下哪个是声明一个方法抛出异常的正确形式？"><a href="#23-请问以下哪个是声明一个方法抛出异常的正确形式？" class="headerlink" title="23.请问以下哪个是声明一个方法抛出异常的正确形式？"></a>23.请问以下哪个是声明一个方法抛出异常的正确形式？</h1><pre><code>A.void m() throws IOException{}B.void m() throw IOExceptionC.void m(){} throws IOExceptionD.void m(void) throw IOException{}答案：A</code></pre><h1 id="24-请问以下哪些关于try⋯catch⋯finally结构中的finally语句的描述是正确的？"><a href="#24-请问以下哪些关于try⋯catch⋯finally结构中的finally语句的描述是正确的？" class="headerlink" title="24.请问以下哪些关于try⋯catch⋯finally结构中的finally语句的描述是正确的？"></a>24.请问以下哪些关于try⋯catch⋯finally结构中的finally语句的描述是正确的？</h1><pre><code>A.只有当一个catch语句获得执行后，finally语句才获得执行B.只有当catch语句未获得执行时，finally语句才获得执行C.如果有finally语句，return语句将在finally语句执行完毕后才会返回D.只有当异常抛出时，finally语句才获得执行答案：C</code></pre><h1 id="25-请问以下代码的直接执行结果是？"><a href="#25-请问以下代码的直接执行结果是？" class="headerlink" title="25.请问以下代码的直接执行结果是？"></a>25.请问以下代码的直接执行结果是？</h1><pre><code>class Example{ public static void main(String[] args) {  try {   System.out.println(args[0]);   System.out.println(&quot;I&apos;m nomal&quot;);   if (true)    return;  } catch (Exception ex) {   System.out.println(&quot;I&apos;m exception&quot;);   if (true)    return;  } finally {   System.out.println(&quot;I&apos;m finally.&quot;);  }  System.out.println(&quot;Out of try.&quot;); }｝A.I&apos;m exceptionI&apos;m finally.B.代码不能编译通过，因为最后一条语句位于return后，不可到达C.代码编译通过，但运行时输出异常信息D.I&apos;m nomalI&apos;m finally.答案：A</code></pre><h1 id="26-关于以下代码，说法正确的是？"><a href="#26-关于以下代码，说法正确的是？" class="headerlink" title="26.关于以下代码，说法正确的是？"></a>26.关于以下代码，说法正确的是？</h1><pre><code>class Example{ public static void main(String[] args) throws IOException {  if (args[0] == &quot;hello&quot;) {   throw new IOException();  } }}A.代码编译成功B.代码编译失败，因为main()方法是入口方法，不能抛出异常C.代码编译失败，因为IOException异常是系统异常，不能由应用程序抛出D.代码编译失败，因为字符串应该用equals方法判定一致性答案：A</code></pre><h1 id="27-关于以下代码，说法正确的是？"><a href="#27-关于以下代码，说法正确的是？" class="headerlink" title="27.关于以下代码，说法正确的是？"></a>27.关于以下代码，说法正确的是？</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  System.out.println(&quot;Before Try&quot;);  try {  } catch (java.io.IOException e) {   System.out.println(&quot;Inside Catch&quot;);  }  System.out.println(&quot;At the End&quot;); }}A.代码编译失败，因为无异常抛出B.代码编译失败，因为未导入IOException异常类C.输出Before TryAt the EndD.输出Inside CatchAt the End答案：A</code></pre><h1 id="28-关于以下代码，说法正确的是？"><a href="#28-关于以下代码，说法正确的是？" class="headerlink" title="28.关于以下代码，说法正确的是？"></a>28.关于以下代码，说法正确的是？</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  System.out.println(&quot;Before Try&quot;);  try {  } catch (Throwable e) {   System.out.println(&quot;Inside Catch&quot;);  }  System.out.println(&quot;At the End&quot;); }}A.代码编译失败，因为无异常抛出B.代码编译失败，因为未导入IOException异常类C.输出Before TryAt the EndD.输出Inside CatchAt the End答案：C</code></pre><h1 id="29-给出以下代码："><a href="#29-给出以下代码：" class="headerlink" title="29.给出以下代码："></a>29.给出以下代码：</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  try {   methodA();     } catch (IOException e) {   System.out.println(&quot;caught IOException&quot;);  }catch (Exception e) {   System.out.println(&quot;caught Exception&quot;);  } }}如果methodA()方法抛出一个IOException异常，则该程序的运行结果是什么？A.无内容输出B.代码编译失败C.输出caught IOExceptionD.输出caught Exception答案：C</code></pre><h1 id="30-下列代码的运行结果是？"><a href="#30-下列代码的运行结果是？" class="headerlink" title="30.下列代码的运行结果是？"></a>30.下列代码的运行结果是？</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  try {   return;  } finally{   System.out.println(&quot;Finally&quot;);  } }}A.无内容输出B.输出FinallyC.代码编译失败D.输出异常信息答案：B</code></pre><h1 id="31-给出以下代码，执行结果是？"><a href="#31-给出以下代码，执行结果是？" class="headerlink" title="31.给出以下代码，执行结果是？"></a>31.给出以下代码，执行结果是？</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  aMethod(); } static void aMethod(){  try {   System.out.println(&quot;Try&quot;);   return;  } catch (Exception e) {   System.out.println(&quot;Catch&quot;);  }finally{   System.out.println(&quot;Finally&quot;);  } }}A.代码编译成功，但运行期间抛出异常B.代码便以失败，因为return语句错误C.输出Try和FinallyD.输出Try答案：C</code></pre><h1 id="32-以下代码中，如果test-方法抛出一个NullPointException异常时，打印输出什么内容？"><a href="#32-以下代码中，如果test-方法抛出一个NullPointException异常时，打印输出什么内容？" class="headerlink" title="32.以下代码中，如果test()方法抛出一个NullPointException异常时，打印输出什么内容？"></a>32.以下代码中，如果test()方法抛出一个NullPointException异常时，打印输出什么内容？</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  try {   test();   System.out.println(&quot;Message1&quot;);  } catch (ArrayIndexOutOfBoundsException e) {   System.out.println(&quot;Message2&quot;);  }finally{   System.out.println(&quot;Message3&quot;);  } }}A.打印输出Message1B.打印输出Message2C.打印输出Message3D.以上都不对答案：C</code></pre><h1 id="33-以下代码执行结果是什么？"><a href="#33-以下代码执行结果是什么？" class="headerlink" title="33.以下代码执行结果是什么？"></a>33.以下代码执行结果是什么？</h1><pre><code>class Example { public static String output = &quot;&quot;; public static void foo(int i) {  try {   if (i == 1) {    throw new Exception();   }   output += &quot;1&quot;;  } catch (Exception e) {   output += &quot;2&quot;;   return;  } finally {   output += &quot;3&quot;;  }  output += &quot;4&quot;; } public static void main(String[] args) throws IOException {  foo(0);  foo(1);  System.out.println(output); }}A.无内容输出B.代码编译失败C.输出13423D.输出14323答案：C</code></pre><h1 id="34-以下代码执行结果是？"><a href="#34-以下代码执行结果是？" class="headerlink" title="34.以下代码执行结果是？"></a>34.以下代码执行结果是？</h1><pre><code>public abstract class Example extends Base { public abstract void method();}class Base { public Base() throws IOException {  throw new IOException(); }}A.代码编译失败，因为非抽象类不能被扩展为抽象类B.代码编译失败，因为必须提供一个可以抛出或可以不抛出IOException异常的构造器C.代码编译失败，以in为必须提供一个可以抛出IOException异常或其子类的构造器D.代码编译成功答案：C</code></pre><h1 id="35-关于以下代码正确的说法是："><a href="#35-关于以下代码正确的说法是：" class="headerlink" title="35.关于以下代码正确的说法是："></a>35.关于以下代码正确的说法是：</h1><pre><code>public class Example {int x = 0; public Example(int inVal) throws Exception {if (inVal != this.x) { throw new Exception(&quot;Invalid input&quot;);} }public static void main(String[] args) { Example t = new Example(4); }}A.代码在第1行编译错误B.代码在第4行编译错误C.代码在第6行编译错误D.代码在第11行编译错误答案：D</code></pre><h1 id="36-关于try⋯catch⋯finally结构，描述正确的是些？"><a href="#36-关于try⋯catch⋯finally结构，描述正确的是些？" class="headerlink" title="36.关于try⋯catch⋯finally结构，描述正确的是些？"></a>36.关于try⋯catch⋯finally结构，描述正确的是些？</h1><pre><code>A.可以有多个catchB.只能有一个catchC.可以没有catchD.finally必须有答案：A、C</code></pre><h1 id="37-当fragile-方法抛出一个IllegalArgumentException异常时，下列代码的运行结果是什么？"><a href="#37-当fragile-方法抛出一个IllegalArgumentException异常时，下列代码的运行结果是什么？" class="headerlink" title="37.当fragile()方法抛出一个IllegalArgumentException异常时，下列代码的运行结果是什么？"></a>37.当fragile()方法抛出一个IllegalArgumentException异常时，下列代码的运行结果是什么？</h1><pre><code>public static void main(String[] args) throws IOException {  try {   fragile();  } catch (NullPointerException e) {   System.out.println(&quot;NullPointerException thrown&quot;);  } catch (Exception e) {   System.out.println(&quot;Exception thrown&quot;);  } finally {   System.out.println(&quot;Done with exceptions&quot;);  }  System.out.println(&quot;myMethod is done&quot;); }｝A.输出NullPointerException thrownB.输出Exception thrownC.输出Done with ExceptionD.输出myMethod is done答案：B、C、D</code></pre><h1 id="38-现有如下代码："><a href="#38-现有如下代码：" class="headerlink" title="38.现有如下代码："></a>38.现有如下代码：</h1><pre><code>public class Example {  public static void main(String[] args) {  try {   int x=Integer.parseInt(&quot;42a&quot;);   //插入代码处   System.out.println(&quot;oops&quot;);  } }}在插入代码处插入哪些语句可以在运行后输出oops？A. } catch (IllegalArgumentException e) {B.} catch (IllegalStateException c) {C. } catch (NumbelFormatException n) {D.} catch (ClassCastException c) {答案：A、C</code></pre><h1 id="39-下列代码的执行结果是？"><a href="#39-下列代码的执行结果是？" class="headerlink" title="39.下列代码的执行结果是？"></a>39.下列代码的执行结果是？</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  int i = 1, j = 1;  try {   i++;   j--;   if (i == j) {    j++;   }  } catch (ArithmeticException e) {   System.out.println(0);  } catch (ArrayIndexOutOfBoundsException e) {   System.out.println(1);  } catch (Exception e) {   System.out.println(2);  } finally {   System.out.println(3);  }  System.out.println(4); }}A.输出1B.输出2C.输出3D.输出4答案：C、D</code></pre><h1 id="40-下列代码的执行结果是？"><a href="#40-下列代码的执行结果是？" class="headerlink" title="40.下列代码的执行结果是？"></a>40.下列代码的执行结果是？</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  int i = 1, j = 1;  try {   i++;   j--;   if (i/j &gt; 1) {    j++;   }  } catch (ArithmeticException e) {   System.out.println(0);  } catch (ArrayIndexOutOfBoundsException e) {   System.out.println(1);  } catch (Exception e) {   System.out.println(2);  } finally {   System.out.println(3);  }  System.out.println(4); }}A.输出0B.输出2C.输出3D.输出4答案：A、C、D</code></pre><h1 id="41-现有如下代码："><a href="#41-现有如下代码：" class="headerlink" title="41.现有如下代码："></a>41.现有如下代码：</h1><pre><code>public class Example {  public static void main(String[] args) {  try {   System.out.println(&quot;before&quot;);   doRisyThing();   System.out.println(&quot;after&quot;);  } catch (Exception e) {   System.out.println(&quot;catch&quot;);  }  System.out.println(&quot;done&quot;); } public static void doRisyThing() throws Exception{  //this code returns unless it throws an Exception }}该代码可能的执行结果有哪些？A.before catchB.before after doneC.before catch doneD.before after catch答案：B、C</code></pre><h1 id="42-以下有关java-lang-Exception异常类的正确描述有？"><a href="#42-以下有关java-lang-Exception异常类的正确描述有？" class="headerlink" title="42.以下有关java.lang.Exception异常类的正确描述有？"></a>42.以下有关java.lang.Exception异常类的正确描述有？</h1><pre><code>A.该类是一个公共类B.该类是Throwable类的子类C.该类实现了Throwable接口D.该类可以序列化答案：A、B、D</code></pre><h1 id="43-给出以下代码："><a href="#43-给出以下代码：" class="headerlink" title="43.给出以下代码："></a>43.给出以下代码：</h1><pre><code>1. public void aMethod(){  2.  3.  if(Condition){4.   5.  }6.  7. }当if条件表达式为true时，插入哪些语句可以抛出MyException异常？A.在第4行插入throws new MyException();B.在第4行插入throw new MyException();C.在第6行插入throw new MyException();D.在第1行插入throws MyException答案：B、D</code></pre><h1 id="44-以下哪些是catch语句能够捕获处理的异常？"><a href="#44-以下哪些是catch语句能够捕获处理的异常？" class="headerlink" title="44.以下哪些是catch语句能够捕获处理的异常？"></a>44.以下哪些是catch语句能够捕获处理的异常？</h1><pre><code>A.ThrowableB.ErrorC.ExceptionD.String答案：A、B、CError也是可以被catch捕获的</code></pre><h1 id="45-以下哪些描述是正确的？"><a href="#45-以下哪些描述是正确的？" class="headerlink" title="45.以下哪些描述是正确的？"></a>45.以下哪些描述是正确的？</h1><pre><code>A.try语句块后必须至少存在一个catch语句块B.try语句块后可以存在不限数量的finally语句块C.try语句块后必须至少存在一个catch语句块或finally语句块D.如果catch和finally语句块同时存在，则catch语句块必须位于finally语句块前答案：C、D</code></pre><h1 id="46-下列代码的执行结果是？"><a href="#46-下列代码的执行结果是？" class="headerlink" title="46.下列代码的执行结果是？"></a>46.下列代码的执行结果是？</h1><pre><code>class Example { private void method1() throws Exception {  throw new RuntimeException(); } public void method2() {  try {   method1();  } catch (RuntimeException e) {   System.out.println(&quot;Caught Runtime Exception&quot;);  } catch (Exception e) {   System.out.println(&quot;Caught Exception&quot;);  } } public static void main(String[] args) throws IOException {  Example a = new Example();  a.method2(); }}A.代码编译失败B.输出Caught Runtime ExceptionC.输出Caught ExceptionD.输出Caught Runtime Exception和Caught Exception答案：B</code></pre><h1 id="47-以下代码的输出结果是什么？选择所有的正确答案。"><a href="#47-以下代码的输出结果是什么？选择所有的正确答案。" class="headerlink" title="47.以下代码的输出结果是什么？选择所有的正确答案。"></a>47.以下代码的输出结果是什么？选择所有的正确答案。</h1><pre><code>class Example { public static void main(String[] args) throws IOException {  for (int i = 0; i &lt; 10; i++) {   try {    try {     if (i % 3 == 0)      throw new Exception(&quot;E0&quot;);     System.out.println(i);    } catch (Exception inner) {     i *= 2;     if (i % 3 == 0)      throw new Exception(&quot;E1&quot;);    } finally {     ++i;    }   } catch (Exception outer) {    i += 3;   } finally {    --i;   }  } }}A.4.0B.5.0C.6.0D.7.0答案：A、B</code></pre><h1 id="48-Java中异常的分类"><a href="#48-Java中异常的分类" class="headerlink" title="48.Java中异常的分类"></a>48.Java中异常的分类</h1><pre><code>答案：java.lang.Throwable|-- Error错误：JVM内部的严重问题。无法恢复。程序人员不用处理。|--Exception异常：普通的问题。通过合理的处理，程序还可以回到正常执行流程。要求编程人员要进行处理。|--RuntimeException:也叫非受检异常(unchecked exception).这类异常是编程人员的逻辑问题。应该承担责任。Java编译器不进行强制要求处理。 也就是说，这类异常再程序中，可以进行处理，也可以不处理。|--非RuntimeException:也叫受检异常(checked exception).这类异常是由一些外部的偶然因素所引起的。Java编译器强制要求处理。也就是说，程序必须进行对这类异常进行处理。</code></pre><h1 id="49-给出常见的RuntimeException"><a href="#49-给出常见的RuntimeException" class="headerlink" title="49.给出常见的RuntimeException"></a>49.给出常见的RuntimeException</h1><pre><code>答案：常见的运行时异常有如下这些ArithmeticException, ArrayStoreException, BufferOverflowException, BufferUnderflowException, CannotRedoException, CannotUndoException, ClassCastException, CMMException, ConcurrentModificationException, DOMException, EmptyStackException, IllegalArgumentException, IllegalMonitorStateException, IllegalPathStateException, IllegalStateException, ImagingOpException, IndexOutOfBoundsException, MissingResourceException, NegativeArraySizeException, NoSuchElementException, NullPointerException, ProfileDataException, ProviderException, RasterFormatException, SecurityException, SystemException, UndeclaredThrowableException, UnmodifiableSetException, UnsupportedOperationException</code></pre><h1 id="50-error和exception有什么区别"><a href="#50-error和exception有什么区别" class="headerlink" title="50.error和exception有什么区别"></a>50.error和exception有什么区别</h1><pre><code>答案：error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况</code></pre><h1 id="51-以下代码的执行结果是？"><a href="#51-以下代码的执行结果是？" class="headerlink" title="51.以下代码的执行结果是？"></a>51.以下代码的执行结果是？</h1><pre><code>public static int fun() {  int result = 5;  try {   result = result / 0;   return result;  } catch (Exception e) {   System.out.println(&quot;Exception&quot;);   result = -1;   return result;  } finally {   result = 10;   System.out.println(&quot;i am in finally&quot;);  } } public static void main(String[] args) {  int x=fun();  System.out.println(x); }答案：ExceptionI am in finally-1</code></pre><h1 id="52-以下代码的执行结果是？"><a href="#52-以下代码的执行结果是？" class="headerlink" title="52.以下代码的执行结果是？"></a>52.以下代码的执行结果是？</h1><pre><code>public class Example { public static StringBuffer fun() {  StringBuffer result = new StringBuffer(&quot;Hello&quot;);  Integer i = new Integer(5);  try {   if (true)    throw new RuntimeException();   return result;  } catch (Exception e) {   System.out.println(&quot;Exception&quot;);   result.append(&quot; World&quot;);   return result;  } finally {   result.append(&quot; Java&quot;);   System.out.println(&quot;i am in finally&quot;);  } } public static void main(String[] args) {  StringBuffer x = fun();  System.out.println(x); }答案：Exceptioni am in finallyHello World Java</code></pre><h1 id="53-什么时候用assert"><a href="#53-什么时候用assert" class="headerlink" title="53.什么时候用assert?"></a>53.什么时候用assert?</h1><pre><code>答案：断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为 true。如果表达式计算为 false，那么系统会报告一个 Assertionerror。它用于调试目的：assert(a &gt; 0); // throws anAssertionerror if a &lt;= 0断言可以有两种形式：assert Expression1 ;assert Expression1 :Expression2 ;  Expression1 应该总是产生一个布尔值。  Expression2 可以是得出一个值的任意表达式。这个值用于生成显示更多调试信息的 String 消息。  断言在默认情况下是禁用的。要在编译时启用断言，需要使用 source 1.4 标记：  javac -source 1.4 Test.java  要在运行时启用断言，可使用 -enableassertions 或者 -ea 标记。  要在运行时选择禁用断言，可使用 -da 或者 -disableassertions 标记。  要系统类中启用断言，可使用 -esa 或者 -dsa 标记。还可以在包的基础上启用或者禁用断言。 可以在预计正常情况下不会到达的任何位置上放置断言。断言可以用于验证传递给私有方法的参数。不过，断言不应该用于验证传递给公有方法的参数，因为不管是否启用了断言，公有方法都必须检查其参数。不过，既可以在公有方法中，也可以在非公有方法中利用断言测试后置条件。另外，断言不应该以任何方式改变程序的状态。</code></pre><h1 id="54-给我一个你最常见到的runtime-exception"><a href="#54-给我一个你最常见到的runtime-exception" class="headerlink" title="54.给我一个你最常见到的runtime exception"></a>54.给我一个你最常见到的runtime exception</h1><pre><code>答案：常见的运行时异常有如下这些ArithmeticException, ArrayStoreException, BufferOverflowException, BufferUnderflowException, CannotRedoException, CannotUndoException, ClassCastException, CMMException, ConcurrentModificationException, DOMException, EmptyStackException, IllegalArgumentException, IllegalMonitorStateException, IllegalPathStateException, IllegalStateException, ImagingOpException, IndexOutOfBoundsException, MissingResourceException, NegativeArraySizeException, NoSuchElementException, NullPointerException, ProfileDataException, ProviderException, RasterFormatException, SecurityException, SystemException, UndeclaredThrowableException, UnmodifiableSetException, UnsupportedOperationException</code></pre><h1 id="55-谈谈final-finally-finalize的区别"><a href="#55-谈谈final-finally-finalize的区别" class="headerlink" title="55.谈谈final, finally, finalize的区别"></a>55.谈谈final, finally, finalize的区别</h1><pre><code>答案：final—修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载finally—再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）finalize—方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的</code></pre><h1 id="56-下列说法错误的是？"><a href="#56-下列说法错误的是？" class="headerlink" title="56.下列说法错误的是？"></a>56.下列说法错误的是？</h1><pre><code>A.Object类是所有Java类的顶层类，即类继承树的根。B.如果一个类没有使用extends关键字扩展任何类，则编译器自动将创建的类视为Object类的子类C.Object类中提供了equals()方法来判定本对象和其他对象中的内容是否一致D.Object中提供的clone默认为浅克隆答案：Cequals方法默认和==一致</code></pre><h1 id="57-定义在Object类上的hashCode-方法的返回值类型是什么？"><a href="#57-定义在Object类上的hashCode-方法的返回值类型是什么？" class="headerlink" title="57.定义在Object类上的hashCode()方法的返回值类型是什么？"></a>57.定义在Object类上的hashCode()方法的返回值类型是什么？</h1><pre><code>A.charB.longC.intD.float答案：C</code></pre><h1 id="58-关于集合中对象的equals-和hashCode-规定说法错误的是？"><a href="#58-关于集合中对象的equals-和hashCode-规定说法错误的是？" class="headerlink" title="58.关于集合中对象的equals()和hashCode()规定说法错误的是？"></a>58.关于集合中对象的equals()和hashCode()规定说法错误的是？</h1><pre><code>A.如果两个对象相同，那么他们的hashCode值需要一致B.如果两个对象的hashCode值一致，他们的equals方法不一定返回trueC.equals方法默认和==判定一致D.Java中hashCode就是对象的内存地址答案：DJava中hashCode不是内存地址，但是可以一定程度上代表地址特诊</code></pre><h1 id="59-以下代码执行结果是什么？"><a href="#59-以下代码执行结果是什么？" class="headerlink" title="59.以下代码执行结果是什么？"></a>59.以下代码执行结果是什么？</h1><pre><code>class Person { static void sayHello() {  System.out.println(&quot;HelloWorld!&quot;); }}public class Example { public static void main(String[] args) {  ((Person) null).sayHello(); }}A.编译失败B.编译成功，运行时产生NullPointerExceptionC.输出HelloWorld!D.输出空白字符串答案：Cnull能够被造型撑任何类型，而sayHello方法是静态方法，不依赖实例调用</code></pre><h1 id="60-下列代码执行结果是："><a href="#60-下列代码执行结果是：" class="headerlink" title="60.下列代码执行结果是："></a>60.下列代码执行结果是：</h1><pre><code>class RectObject { public int x; public int y; public RectObject(int x, int y) {  this.x = x;  this.y = y; } @Override public int hashCode() {  final int prime = 31;  int result = 1;  result = prime * result + x;  result = prime * result + y;  return result; } @Override public boolean equals(Object obj) {  if (this == obj)   return true;  if (obj == null)   return false;  if (getClass() != obj.getClass())   return false;  final RectObject other = (RectObject) obj;  if (x != other.x) {   return false;  }  if (y != other.y) {   return false;  }  return true; }}public class Example { public static void main(String[] args) {  HashSet&lt;RectObject&gt; set = new HashSet&lt;RectObject&gt;();  RectObject r1 = new RectObject(3, 3);  RectObject r2 = new RectObject(5, 5);  RectObject r3 = new RectObject(3, 3);  set.add(r1);  set.add(r2);  set.add(r3);  set.add(r1);  System.out.println(&quot;size:&quot; + set.size()); }}A.size:1B.size:2C.size:3D.size:4答案：B因为我们重写了RectObject类的hashCode方法，只要RectObject对象的x,y属性值相等那么他的hashCode值也是相等的，所以先比较hashCode的值，r1和r2对象的x,y属性值不等，所以他们的hashCode不相同的，所以r2对象可以放进去，但是r3对象的x,y属性值和r1对象的属性值相同的，所以hashCode是相等的，这时候在比较r1和r3的equals方法，因为他么两的x,y值是相等的，所以r1,r3对象是相等的，所以r3不能放进去了，同样最后再添加一个r1也是没有没有添加进去的，所以set集合中只有一个r1和r2这两个对象</code></pre><h1 id="61-以下代码的执行结果是？"><a href="#61-以下代码的执行结果是？" class="headerlink" title="61.以下代码的执行结果是？"></a>61.以下代码的执行结果是？</h1><pre><code>class RectObject { public int x; public int y; public RectObject(int x, int y) {  this.x = x;  this.y = y; } @Override public boolean equals(Object obj) {  if (this == obj)   return true;  if (obj == null)   return false;  if (getClass() != obj.getClass())   return false;  final RectObject other = (RectObject) obj;  if (x != other.x) {   return false;  }  if (y != other.y) {   return false;  }  return true; }}public class Example { public static void main(String[] args) {  HashSet&lt;RectObject&gt; set = new HashSet&lt;RectObject&gt;();  RectObject r1 = new RectObject(3, 3);  RectObject r2 = new RectObject(5, 5);  RectObject r3 = new RectObject(3, 3);  set.add(r1);  set.add(r2);  set.add(r3);  set.add(r1);  System.out.println(&quot;size:&quot; + set.size()); }}A.size:1B.size:2C.size:3D.size:4答案：C首先判断r1对象和r2对象的hashCode，因为Object中的hashCode方法返回的是对象本地内存地址的换算结果，不同的实例对象的hashCode是不相同的，同样因为r3和r1的hashCode也是不相等的，但是r1==r1的，所以最后set集合中只有r1,r2,r3这三个对象，所以大小是3</code></pre><h1 id="62-以下代码执行结果是？"><a href="#62-以下代码执行结果是？" class="headerlink" title="62.以下代码执行结果是？"></a>62.以下代码执行结果是？</h1><pre><code>class RectObject { public int x; public int y; public RectObject(int x, int y) {  this.x = x;  this.y = y; } @Override public boolean equals(Object obj) {  return false; }}public class Example { public static void main(String[] args) {  HashSet&lt;RectObject&gt; set = new HashSet&lt;RectObject&gt;();  RectObject r1 = new RectObject(3, 3);  RectObject r2 = new RectObject(5, 5);  RectObject r3 = new RectObject(3, 3);  set.add(r1);  set.add(r2);  set.add(r3);  set.add(r1);  System.out.println(&quot;size:&quot; + set.size()); }}A.size:1B.size:2C.size:3D.size:4答案：C首先是判断hashCode是否相等，不相等的话，直接跳过，相等的话，然后再来比较这两个对象是否相等或者这两个对象的equals方法，因为是进行的或操作，所以只要有一个成立即可，那这里我们就可以解释了，其实上面的那个集合的大小是3,因为最后的一个r1没有放进去，以为r1==r1返回true的，所以没有放进去了。所以集合的大小是3，如果我们将hashCode方法设置成始终返回false的话，这个集合就是4了。</code></pre><h1 id="63-以下代码执行结果是？"><a href="#63-以下代码执行结果是？" class="headerlink" title="63.以下代码执行结果是？"></a>63.以下代码执行结果是？</h1><pre><code>class RectObject { public int x; public int y; public RectObject(int x, int y) {  this.x = x;  this.y = y; } @Override public int hashCode() {  // TODO Auto-generated method stub  return (int)System.nanoTime(); } @Override public boolean equals(Object obj) {  return false; }}public class Example { public static void main(String[] args) {  HashSet&lt;RectObject&gt; set = new HashSet&lt;RectObject&gt;();  RectObject r1 = new RectObject(3, 3);  RectObject r2 = new RectObject(5, 5);  RectObject r3 = new RectObject(3, 3);  set.add(r1);  set.add(r2);  set.add(r3);  set.add(r1);  System.out.println(&quot;size:&quot; + set.size()); }}A.size:1B.size:2C.size:3D.size:4答案：D见上题</code></pre><h1 id="64-下列关于Math类说法错误的是"><a href="#64-下列关于Math类说法错误的是" class="headerlink" title="64.下列关于Math类说法错误的是"></a>64.下列关于Math类说法错误的是</h1><pre><code>A.java.lang.Math类是final类，因此不能被其他类继承B.java.lang.Math类的构造器是私有的，即声明为private，不能实例化一个Math类的对象C.java.lang.Math类上定义的所有常量和方法均是public和static的，因此可以直接通过类名调用D.min()和max()方法的参数之一，如果是NaN值，则方法将返回另一个参数值答案：Dmin()和max()方法的参数之一，如果是NaN值，则方法的返回值就为NaN</code></pre><h1 id="65-以下哪个方法是Math类中定义的？"><a href="#65-以下哪个方法是Math类中定义的？" class="headerlink" title="65.以下哪个方法是Math类中定义的？"></a>65.以下哪个方法是Math类中定义的？</h1><pre><code>A.absolute()B.log()C.cosine()D.sine()答案：B在Math类中对应的正确方法应为abs()\cos()\sin()</code></pre><h1 id="66-定义在Math类上的round-double-d-方法的返回值类型是什么？"><a href="#66-定义在Math类上的round-double-d-方法的返回值类型是什么？" class="headerlink" title="66.定义在Math类上的round(double d)方法的返回值类型是什么？"></a>66.定义在Math类上的round(double d)方法的返回值类型是什么？</h1><pre><code>A.charB.intC.longD.double答案：Cround方法用于获取一个四舍五入的整数</code></pre><h1 id="67-以下哪个方法用于计算平方根？"><a href="#67-以下哪个方法用于计算平方根？" class="headerlink" title="67.以下哪个方法用于计算平方根？"></a>67.以下哪个方法用于计算平方根？</h1><pre><code>A.squareRoot()B.sqrt()C.root()D.sqr()答案：B</code></pre><h1 id="68-调用Math-random-方法最有可能输出以下哪些结果？"><a href="#68-调用Math-random-方法最有可能输出以下哪些结果？" class="headerlink" title="68.调用Math.random()方法最有可能输出以下哪些结果？"></a>68.调用Math.random()方法最有可能输出以下哪些结果？</h1><pre><code>A.-0.12和0.56E3B.0.12和1.1E1C.-23.45和0.0D.0.356和0.03答案：Drandom()方法返回值的取值范围在0.0..1.0之间</code></pre><h1 id="69-以下代码的输出结果是什么？"><a href="#69-以下代码的输出结果是什么？" class="headerlink" title="69.以下代码的输出结果是什么？"></a>69.以下代码的输出结果是什么？</h1><pre><code>public class Example { public static void main(String[] args) {  System.out.println(Math.round(Float.MAX_VALUE)); }}A.输出Integer.MAX_VALUEB.输出一个最接近Float.MAX_VALUE的整数C.编译失败D.运行时输出异常信息答案：AMath.round(Float.MAX_VALUE)的返回值为Integer.MAX_VALUE，Math.round(Double.MAX_VALUE)的返回值为Long.MAX_VALUE（真实计算结果超过返回值范围）</code></pre><h1 id="70-以下代码的运行结果是什么？"><a href="#70-以下代码的运行结果是什么？" class="headerlink" title="70.以下代码的运行结果是什么？"></a>70.以下代码的运行结果是什么？</h1><pre><code>public class Example { public static void main(String[] args) {  System.out.println(Math.min(0.0, -0.0)); }}A.代码编译失败B.输出0.0C.输出-0.0D.代码编译成功，但运行时输出异常信息答案：C浮点数的取值范围内存在正负0.0</code></pre><h1 id="71-以下代码的执行结果是？"><a href="#71-以下代码的执行结果是？" class="headerlink" title="71.以下代码的执行结果是？"></a>71.以下代码的执行结果是？</h1><pre><code>public class Example { public static void main(String[] args) {  System.out.println(Math.min(0.0, -0.0)); }}A.输出4B.输出5C.输出6 D.输出9答案：D比2.3大的最接近整数是3，因此ceil(2.3f)=3.0，因为2.7的四舍五入的值为3.0，所以round(2.7)=3.0，最终打印输出等于9</code></pre><h1 id="72-以下代码的运行结果是什么？"><a href="#72-以下代码的运行结果是什么？" class="headerlink" title="72.以下代码的运行结果是什么？"></a>72.以下代码的运行结果是什么？</h1><pre><code>public class Example { public static void main(String[] args) {  double d1 = -0.5;  System.out.println(&quot;Ceil d1=&quot; + Math.ceil(d1));  System.out.println(&quot;Floor d1=&quot; + Math.floor(d1)); }}A.输出Ceil d1=-0.0 Floor d1=-1.0B.输出Ceil d1=0.0 Floor d1=-1.0C.输出Ceil d1=-0.0 Floor d1=-0.0D.输出Ceil d1=0.0 Floor d1=0.0答案：A</code></pre><h1 id="73-给出以下代码，为了结果输出-12-0，方法method-d-应为以下哪个方法？"><a href="#73-给出以下代码，为了结果输出-12-0，方法method-d-应为以下哪个方法？" class="headerlink" title="73.给出以下代码，为了结果输出-12.0，方法method(d)应为以下哪个方法？"></a>73.给出以下代码，为了结果输出-12.0，方法method(d)应为以下哪个方法？</h1><pre><code>public class Example { public static void main(String[] args) {  double d = -11.1;  double d1 = method(d);  System.out.println(d1); }}A.floor()B.ceil()C.round()D.abs()答案：A</code></pre><h1 id="74-给出以下代码，请问在程序的第6行插入那条语句，改程序可依次打印输出11、10、9？"><a href="#74-给出以下代码，请问在程序的第6行插入那条语句，改程序可依次打印输出11、10、9？" class="headerlink" title="74.给出以下代码，请问在程序的第6行插入那条语句，改程序可依次打印输出11、10、9？"></a>74.给出以下代码，请问在程序的第6行插入那条语句，改程序可依次打印输出11、10、9？</h1><pre><code>1.public class Example {2. public static void main(String[] args) {3.  double x[] = { 10.2, 9.1, 8.7 };4.  int i[] = new int[3];5.  for (int a = 0; a &lt; x.length; a++) {6.7.   System.out.println(i[a]);8.  }9. }10.}A.i[1] = ((int)Math.min(x[a]));B.i[1] = ((int)Math.max(x[a]));C.i[1] = ((int)Math.ceil(x[a]));D.i[1] = ((int)Math.floor(x[a]));答案：C</code></pre><h1 id="75-以下代码执行结果是？"><a href="#75-以下代码执行结果是？" class="headerlink" title="75.以下代码执行结果是？"></a>75.以下代码执行结果是？</h1><pre><code>public class Example { public static void main(String[] args) {  System.out.println(Math.min(Float.NaN, Float.POSITIVE_INFINITY)); }}A.输出NaNB.打印输出InfinityC.运行时异常，因为NaN不是有效的参数D.运行时异常，因为Infinity不是有效的参数答案：Amin()和max()方法的参数之一，如果是NaN值，则方法的返回值就为NaN</code></pre><h1 id="76-以下代码的执行结果是？"><a href="#76-以下代码的执行结果是？" class="headerlink" title="76.以下代码的执行结果是？"></a>76.以下代码的执行结果是？</h1><pre><code>public class Example{  public static void main(String s[]){   String str=”123”;String str_=new String(“123”);String  _str=”123”;   System.out.println(str==_str);System.out.println(str==str_);} }A.输出true trueB.输出false falseC.输出true falseD.输出false true答案：C字符串创建的时候可以使用常量池</code></pre><h1 id="77-public-class-Example"><a href="#77-public-class-Example" class="headerlink" title="77.public class Example {"></a>77.public class Example {</h1><pre><code> public static void main(String[] args) {  Integer i = 100;  Integer j = 100;  System.out.println(i == j);  i = 300;  j = 300;  System.out.println(i == j); }}A.输出true trueB.输出false falseC.输出true falseD.输出false true答案：C128以内的数进行自动包装时使用池操作</code></pre><h1 id="78-以下哪个不是基本类型的包装类？"><a href="#78-以下哪个不是基本类型的包装类？" class="headerlink" title="78.以下哪个不是基本类型的包装类？"></a>78.以下哪个不是基本类型的包装类？</h1><pre><code>A.CharB.IntegerC.BooleanD.float答案：A</code></pre><h1 id="79-以下说法正确的是？"><a href="#79-以下说法正确的是？" class="headerlink" title="79.以下说法正确的是？"></a>79.以下说法正确的是？</h1><pre><code>A.Void类是Class类的子类B.Float类是Double类的子类C.Double类是Wrapper类的子类D.Integer类是Number类的子类答案：D</code></pre><h1 id="80-定义在Integer类上的哪些方法用于将一个Integer对象转换为一个基本数据int类型？"><a href="#80-定义在Integer类上的哪些方法用于将一个Integer对象转换为一个基本数据int类型？" class="headerlink" title="80.定义在Integer类上的哪些方法用于将一个Integer对象转换为一个基本数据int类型？"></a>80.定义在Integer类上的哪些方法用于将一个Integer对象转换为一个基本数据int类型？</h1><pre><code>A.valueOf（）B.intValue（）C.getInt（）D.getInteger（）答案：B</code></pre><h1 id="81-一下代码的执行结果是什么？"><a href="#81-一下代码的执行结果是什么？" class="headerlink" title="81.一下代码的执行结果是什么？"></a>81.一下代码的执行结果是什么？</h1><pre><code>public class Example { public static void main(String[] args) {  String val = null;  int x = Integer.parseInt(val);  System.out.println(x); }}A.输出0B.输出nullC.输出NumberFormatException异常D.无内容输出答案：C</code></pre><h1 id="82-由于Java中存在字符串对象池，因此采用下面方法创建的两个字符串变量，他们指向的是同一个字符串对象：String-str1-”asddsg”-String-str2-”asddsg”"><a href="#82-由于Java中存在字符串对象池，因此采用下面方法创建的两个字符串变量，他们指向的是同一个字符串对象：String-str1-”asddsg”-String-str2-”asddsg”" class="headerlink" title="82.由于Java中存在字符串对象池，因此采用下面方法创建的两个字符串变量，他们指向的是同一个字符串对象：String str1=”asddsg”;String str2=”asddsg”"></a>82.由于Java中存在字符串对象池，因此采用下面方法创建的两个字符串变量，他们指向的是同一个字符串对象：String str1=”asddsg”;String str2=”asddsg”</h1><pre><code>A.调用字符串上定义的改变字符串内容的方法，返回值都是一个新字符串，而原有字符串内容不变B.调用replace（char oldChar,char newChar）方法时，当参数oldChar和newChar一致时，返回一个和源对象内容一致的新字符串C.String的equals方法用于判定两个字符串内容是否一致D.调用toUpperCase()和toLowerCase()方法，当为进行大小写转换时，返回源字符串对象答案：B调用replace（char oldChar,char newChar）方法时，当参数oldChar和newChar一致时，返回源字符串对象</code></pre><h1 id="83-以下说法错误的是？"><a href="#83-以下说法错误的是？" class="headerlink" title="83.以下说法错误的是？"></a>83.以下说法错误的是？</h1><pre><code>A.String中的append方法用于在源字符串后追加内容B.StringBuffer中的append方法用于在源字符串后追加内容C.StringBuffer是一个缓冲区，器内容可变D.String中的concat方法用于字符串串联答案：AString中没有append方法</code></pre><h1 id="84-以下哪些有关通过子类来扩展String类功能的描述是正确的？"><a href="#84-以下哪些有关通过子类来扩展String类功能的描述是正确的？" class="headerlink" title="84.以下哪些有关通过子类来扩展String类功能的描述是正确的？"></a>84.以下哪些有关通过子类来扩展String类功能的描述是正确的？</h1><pre><code>A.无法子类化，因为String类是一个final类B.可以子类化，通过覆盖String类中的方法实现功能扩展C.无法子类化，因为String类是一个抽象类D.可以子类化，但是只能覆盖Object类中声明的方法，因为String类中定义的其他方法否是final的答案：A</code></pre><h1 id="85-嗲用以下哪个方法会导致字符串被改变？"><a href="#85-嗲用以下哪个方法会导致字符串被改变？" class="headerlink" title="85.嗲用以下哪个方法会导致字符串被改变？"></a>85.嗲用以下哪个方法会导致字符串被改变？</h1><pre><code>A.concat()B.toUpperCase()C.replace()D.没有改变字符串的方法可以调用答案：D</code></pre><h1 id="86-如何获取一个String类实例S包含的字符个数？"><a href="#86-如何获取一个String类实例S包含的字符个数？" class="headerlink" title="86.如何获取一个String类实例S包含的字符个数？"></a>86.如何获取一个String类实例S包含的字符个数？</h1><pre><code>A.s.sizeB.s.lengthC.s.size()D.s.length()答案：D</code></pre><h1 id="87-以下代码执行结果是？"><a href="#87-以下代码执行结果是？" class="headerlink" title="87.以下代码执行结果是？"></a>87.以下代码执行结果是？</h1><pre><code>public class Example { public static void main(String[] args) {  System.out.println(&quot;string&quot;.endsWith(&quot;&quot;)); }}A.输出trueB.输出falseC.编译失败D.运行时输出异常信息答案：A</code></pre><h1 id="88-有String-s-“Metallica”-请问以下哪个语句可以打印输出ica？"><a href="#88-有String-s-“Metallica”-请问以下哪个语句可以打印输出ica？" class="headerlink" title="88.有String s = “Metallica”;请问以下哪个语句可以打印输出ica？"></a>88.有String s = “Metallica”;请问以下哪个语句可以打印输出ica？</h1><pre><code>A.System.out.println(s.substring(7));B.System.out.println(s.substring(6));C.System.out.println(s.substring(6，8));D.System.out.println(s.substring(7，9));答案：B</code></pre><h1 id="89-以下那些关于String类的描述是正确的？"><a href="#89-以下那些关于String类的描述是正确的？" class="headerlink" title="89.以下那些关于String类的描述是正确的？"></a>89.以下那些关于String类的描述是正确的？</h1><pre><code>A.该类是一个final类B.该类是一个public类C.该类可以序列化D.该类有一个一StringBuffer实例作为参数的构造器答案：A、B、C、D</code></pre><h1 id="90-以下哪些是String类中定义的方法？"><a href="#90-以下哪些是String类中定义的方法？" class="headerlink" title="90.以下哪些是String类中定义的方法？"></a>90.以下哪些是String类中定义的方法？</h1><pre><code>A.length（）B.toUpper()C.toString()D.equals()答案：A、C、D</code></pre><h1 id="91-以下哪些关于封装类的描述是正确的？"><a href="#91-以下哪些关于封装类的描述是正确的？" class="headerlink" title="91.以下哪些关于封装类的描述是正确的？"></a>91.以下哪些关于封装类的描述是正确的？</h1><pre><code>A.封装类都是public类B.封装类均可序列化C.封装类均是final类D.封装类都是java.lang.Number类的子类答案：A、B、C</code></pre><h1 id="92-请问以下哪些方法是定义在Object类上的，请选择所有正确答案"><a href="#92-请问以下哪些方法是定义在Object类上的，请选择所有正确答案" class="headerlink" title="92.请问以下哪些方法是定义在Object类上的，请选择所有正确答案"></a>92.请问以下哪些方法是定义在Object类上的，请选择所有正确答案</h1><pre><code>A.toString()B.equals(Object o)C.println()D.wait()答案：A、B、D</code></pre><h1 id="93-请问以下哪些描述是正确的？请选择所有正确答案"><a href="#93-请问以下哪些描述是正确的？请选择所有正确答案" class="headerlink" title="93.请问以下哪些描述是正确的？请选择所有正确答案"></a>93.请问以下哪些描述是正确的？请选择所有正确答案</h1><pre><code>A.Class类是Object类的超类B.Object类是一个final类C.Class类可用于装载其他类D.ClassLoader类可用于装载其他类答案：C、D</code></pre><h1 id="94-给出以下代码，请问以下哪些定义在Math类上的方法可以使表达式结果为true"><a href="#94-给出以下代码，请问以下哪些定义在Math类上的方法可以使表达式结果为true" class="headerlink" title="94.给出以下代码，请问以下哪些定义在Math类上的方法可以使表达式结果为true?"></a>94.给出以下代码，请问以下哪些定义在Math类上的方法可以使表达式结果为true?</h1><pre><code>Method(-4.4) == -4A.round()B.trunc()C.floor()D.ceil()答案：A、D</code></pre><h1 id="95-下面这条语句一共创建了多少个对象：String-s-”a”-”b”-”c”-”d”"><a href="#95-下面这条语句一共创建了多少个对象：String-s-”a”-”b”-”c”-”d”" class="headerlink" title="95.下面这条语句一共创建了多少个对象：String s=”a”+”b”+”c”+”d”;"></a>95.下面这条语句一共创建了多少个对象：String s=”a”+”b”+”c”+”d”;</h1><pre><code>一个字符串对象和一个指向这个对象的引用对于如下代码：Strings1 = &quot;a&quot;;Strings2 = s1 + &quot;b&quot;;Strings3 = &quot;a&quot; + &quot;b&quot;;System.out.println(s2== &quot;ab&quot;);System.out.println(s3== &quot;ab&quot;);答案：第一条语句打印的结果为false，第二条语句打印的结果为true，这说明javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串，所以，上面的代码应该只创建了一个String对象和一个指向该对象的饮用。写如下两行代码，               String s = &quot;a&quot; +&quot;b&quot; + &quot;c&quot; + &quot;d&quot;;               System.out.println(s ==&quot;abcd&quot;);  最终打印的结果应该为true。</code></pre><h1 id="96-以下代码的执行结果是？"><a href="#96-以下代码的执行结果是？" class="headerlink" title="96.以下代码的执行结果是？"></a>96.以下代码的执行结果是？</h1><pre><code>class ShadowClone implements Cloneable { private int a; private int[] b; @Override public Object clone() {  ShadowClone sc = null;  try {   sc = (ShadowClone) super.clone();  } catch (CloneNotSupportedException e) {   e.printStackTrace();  }  return sc; } public int getA() {  return a; } public void setA(int a) {  this.a = a; } public int[] getB() {  return b; } public void setB(int[] b) {  this.b = b; }}public class Example { public static void main(String[] args) {  ShadowClone c1 = new ShadowClone();  c1.setA(100);  c1.setB(new int[] { 1000 });  System.out.println(&quot;克隆前c1:  a=&quot; + c1.getA() + &quot; b[0]=&quot; + c1.getB()[0]);  ShadowClone c2 = (ShadowClone) c1.clone();  c2.setA(50);  int[] a = c2.getB();  a[0] = 5;  c2.setB(a);  System.out.println(&quot;克隆后c1:  a=&quot; + c1.getA() + &quot; b[0]=&quot; + c1.getB()[0]);  System.out.println(&quot;克隆后c2:  a=&quot; + c2.getA() + &quot; b[0]=&quot; + c2.getB()[0]); }}答案：克隆前c1:  a=100 b[0]=1000克隆后c1:  a=100 b[0]=5克隆后c2:  a=50 b[0]=5Java中Object类提供的克隆方法默认为浅克隆，因此克隆后的引用属性和原始对象中的引用属性引用了同一对象，对克隆对象中引用数据的变更就直接反映到原始对象中</code></pre><h1 id="97-以下代码的执行结果是？"><a href="#97-以下代码的执行结果是？" class="headerlink" title="97.以下代码的执行结果是？"></a>97.以下代码的执行结果是？</h1><pre><code>class DeepClone implements Cloneable { private int a; private int[] b; @Override public Object clone() {  DeepClone sc = null;  try {   sc = (DeepClone) super.clone();   int[] t = sc.getB();   int[] b1 = new int[t.length];   for (int i = 0; i &lt; b1.length; i++) {    b1[i] = t[i];   }   sc.setB(b1);  } catch (CloneNotSupportedException e) {   e.printStackTrace();  }  return sc; } public int getA() {  return a; } public void setA(int a) {  this.a = a; } public int[] getB() {  return b; } public void setB(int[] b) {  this.b = b; }}public class Example { public static void main(String[] args) {  DeepClone c1 = new DeepClone();  c1.setA(100);  c1.setB(new int[] { 1000 });  System.out.println(&quot;克隆前c1:  a=&quot; + c1.getA() + &quot; b[0]=&quot; + c1.getB()[0]);  DeepClone c2 = (DeepClone) c1.clone();  c2.setA(50);  int[] a = c2.getB();  a[0] = 5;  c2.setB(a);  System.out.println(&quot;克隆后c1:  a=&quot; + c1.getA() + &quot; b[0]=&quot; + c1.getB()[0]);  System.out.println(&quot;克隆后c2:  a=&quot; + c2.getA() + &quot; b[0]=&quot; + c2.getB()[0]); }}答案：克隆前c1:  a=100 b[0]=1000克隆后c1:  a=100 b[0]=1000克隆后c2:  a=50 b[0]=5自定义的深度克隆</code></pre><h1 id="98-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对"><a href="#98-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对" class="headerlink" title="98.两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对"></a>98.两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对</h1><pre><code>答案：不对，有相同的hash code</code></pre><h1 id="99-覆盖equals-方法时需要注意的设计原则有哪些？"><a href="#99-覆盖equals-方法时需要注意的设计原则有哪些？" class="headerlink" title="99.覆盖equals()方法时需要注意的设计原则有哪些？"></a>99.覆盖equals()方法时需要注意的设计原则有哪些？</h1><pre><code>答案：对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。反射性：x.equals(x)必须返回是“true”。类推性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。 </code></pre><h1 id="100-equals方法和-的区别"><a href="#100-equals方法和-的区别" class="headerlink" title="100.equals方法和==的区别"></a>100.equals方法和==的区别</h1><pre><code>答案：1.基本数据类型，也称原始数据类型。byte,short,char,int,long,float,double,boolean  他们之间的比较，应用双等号（==）,比较的是他们的值。2.复合数据类型(类)  当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地 址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。  对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（==）进行比较的，所以比较后的结果跟双等号（==）的结果相同。 </code></pre><h1 id="101-String、StringBuffer、StringBuilder有什么区别？"><a href="#101-String、StringBuffer、StringBuilder有什么区别？" class="headerlink" title="101.String、StringBuffer、StringBuilder有什么区别？"></a>101.String、StringBuffer、StringBuilder有什么区别？</h1><pre><code>答案：String类表示内容不可改变的字符串。而StringBuffer类表示内容可以被修改的字符串。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。另外，String实现了equals方法，new String(“abc”).equals(new String(“abc”)的结果为true,而StringBuffer没有实现equals方法，所以，new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为false。StringBuffer和StringBuilder类都表示内容可以被修改的字符串，StringBuilder是线程不安全的，运行效率高，如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用StringBuilder。如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用StringBuffer。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-以下哪个是finalize-方法的正确形式？&quot;&gt;&lt;a href=&quot;#1-以下哪个是finalize-方法的正确形式？&quot; class=&quot;headerlink&quot; title=&quot;1.以下哪个是finalize()方法的正确形式？&quot;&gt;&lt;/a&gt;1.以下哪个是finali
      
    
    </summary>
    
    
      <category term="java" scheme="http://iwantjingjing.com/categories/java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="面试" scheme="http://iwantjingjing.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql优化</title>
    <link href="http://iwantjingjing.com/2020/04/16/mysql%E4%BC%98%E5%8C%96/"/>
    <id>http://iwantjingjing.com/2020/04/16/mysql%E4%BC%98%E5%8C%96/</id>
    <published>2020-04-16T10:22:32.000Z</published>
    <updated>2020-04-16T10:27:54.017Z</updated>
    
    <content type="html"><![CDATA[<p>所谓超级读书法就是，读一段不会则停下来把之前的内容再读一遍，以此类推<br>                                                            ——费曼<br>孔子曰：温故而知新可以为师已<br>不知谁说的： 读书百遍，其义自见</p><p>mysql优化</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="两个瓶颈"><a href="#两个瓶颈" class="headerlink" title="两个瓶颈"></a>两个瓶颈</h2><pre><code>CPU    CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候。I/O    磁盘I/O瓶颈发生在装入数据远大于内存容量的时候    应用分布在网络上，那么查询量相当大的时候那么平瓶颈就会出现在网络上。</code></pre><h2 id="如何查看系统性能"><a href="#如何查看系统性能" class="headerlink" title="如何查看系统性能"></a>如何查看系统性能</h2><pre><code>mpstatiostatsarvmstat</code></pre><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><pre><code>1 什么是索引    加速查询最好的方法就是索引。    类似于图书的目录2.索引类型     普通索引            是最基本的索引，它没有任何限制。     唯一索引            与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。     组合索引            指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。     主键索引            是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引     全文索引            主要用来查找文本中的关键字，而不是直接与索引中的值相比较            它更像是一个搜索引擎            fulltext索引配合match against操作使用            可以在create table，alter table ，create index使用            目前只有char、varchar，text 列上可以创建全文索引            先插入数据再建索引比建表时先建索引再插入数据效率高3.索引优化    1 只要列中含有NULL值，就最好不要在此例设置索引，复合索引如果有NULL值，此列在使用时也不会使用索引     2 尽量使用短索引，如果可以，应该制定一个前缀长度     3 对于经常在where子句使用的列，最好设置索引，这样会加快查找速度     4 对于有多个列where或者order by子句的，应该建立复合索引     5 对于like语句，以%或者‘-’开头的不会使用索引，以%结尾会使用索引     6 尽量不要在列上进行运算（函数操作和表达式操作）     7 尽量不要使用not in和&lt;&gt;操作</code></pre><h2 id="SQL慢查询的优化"><a href="#SQL慢查询的优化" class="headerlink" title="SQL慢查询的优化"></a>SQL慢查询的优化</h2><pre><code>1.如何捕获低效sql    1）slow_query_log            这个参数设置为ON，可以捕获执行时间超过一定数值的SQL语句。    2）ong_query_time            当SQL语句执行时间超过此数值时，就会被记录到日志中，建议设置为1或者更短。    3）slow_query_log_file            记录日志的文件名。    4）log_queries_not_using_indexes            这个参数设置为ON，可以捕获到所有未使用索引的SQL语句，尽管这个SQL语句有可能执行得挺快。2.慢查询优化的基本步骤    1)先运行看看是否真的很慢，注意设置SQL_NO_CACHE    2）where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高    3)explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）    4)order by limit 形式的sql语句让排序的表优先查    5)了解业务方使用场景    6)加索引时参照建索引的几大原则    7)观察结果，不符合预期继续从1开始分析2.优化原则     1查询时，能不要*就不用*，尽量写全字段名     2 大部分情况连接效率远大于子查询     3 多使用explain和profile分析查询语句     4 查看慢查询日志，找出执行时间长的sql语句优化     5 多表连接时，尽量小表驱动大表，即小表 join 大表    6  在千万级分页时使用limit    7  对于经常使用的查询，可以开启缓存</code></pre><h2 id="数据库表优化"><a href="#数据库表优化" class="headerlink" title="数据库表优化"></a>数据库表优化</h2><pre><code>1 表的字段尽可能用NOT NULL2 字段长度固定的表查询会更快3 把数据库的大表按时间或一些标志分成小表4 将表拆分    水平切分:将记录散列到不同的表中，各表的结构完全相同，每次从分表中查询, 提高效率。    垂直切分:将表中大字段单独拆分到另外一张表, 形成一对一的关系。</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><pre><code>索引的优化  sql语句的优化  表的优化  在高并发网络环境下，除了优化数据库外，还会涉及到分布式缓存，CDN，数据库读写分离等高并发优化技术mysql优化18条  1 只要列中含有NULL值，就最好不要在此例设置索引，复合索引如果有NULL值，此列在使用时也不会使用索引   2 尽量使用短索引，如果可以，应该制定一个前缀长度   3 对于经常在where子句使用的列，最好设置索引，这样会加快查找速度   4 对于有多个列where或者order by子句的，应该建立复合索引   5 对于like语句，以%或者‘-’开头的不会使用索引，以%结尾会使用索引   6 尽量不要在列上进行运算（函数操作和表达式操作）   7 尽量不要使用not in和&lt;&gt;操作   1查询时，能不要*就不用*，尽量写全字段名   2 大部分情况连接效率远大于子查询   3 多使用explain和profile分析查询语句   4 查看慢查询日志，找出执行时间长的sql语句优化   5 多表连接时，尽量小表驱动大表，即小表 join 大表  6  在千万级分页时使用limit  7  对于经常使用的查询，可以开启缓存  1 表的字段尽可能用NOT NULL  2 字段长度固定的表查询会更快  3 把数据库的大表按时间或一些标志分成小表  4 将表拆分    水平切分:将记录散列到不同的表中，各表的结构完全相同，每次从分表中查询, 提高效率。    垂直切分:将表中大字段单独拆分到另外一张表, 形成一对一的关系。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所谓超级读书法就是，读一段不会则停下来把之前的内容再读一遍，以此类推&lt;br&gt;                                                            ——费曼&lt;br&gt;孔子曰：温故而知新可以为师已&lt;br&gt;不知谁说的： 读书百遍，其
      
    
    </summary>
    
    
      <category term="面试" scheme="http://iwantjingjing.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试，mysql" scheme="http://iwantjingjing.com/tags/%E9%9D%A2%E8%AF%95%EF%BC%8Cmysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql面试题</title>
    <link href="http://iwantjingjing.com/2020/04/16/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://iwantjingjing.com/2020/04/16/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-04-16T10:13:26.000Z</published>
    <updated>2020-04-19T09:33:56.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL的复制原理以及流程"><a href="#MySQL的复制原理以及流程" class="headerlink" title="MySQL的复制原理以及流程"></a>MySQL的复制原理以及流程</h1><pre><code>基本原理流程，3个线程以及之间的关联；  主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；  从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；  从：sql执行线程——执行relay log中的语句；</code></pre><h1 id="MySQL中myisam与innodb的区别，至少5点"><a href="#MySQL中myisam与innodb的区别，至少5点" class="headerlink" title="MySQL中myisam与innodb的区别，至少5点"></a>MySQL中myisam与innodb的区别，至少5点</h1><pre><code>5点不同  1&gt;.InnoDB支持事物，而MyISAM不支持事物  2&gt;.InnoDB支持行级锁，而MyISAM支持表级锁  3&gt;.InnoDB支持MVCC, 而MyISAM不支持      MVCC是版本控制？  4&gt;.InnoDB支持外键，而MyISAM不支持  5&gt;.InnoDB不支持全文索引，而MyISAM支持。 innodb引擎的4大特性  插入缓冲（insert buffer)  二次写(double write)  自适应哈希索引(ahi)  预读(read ahead)2者selectcount(*)哪个更快，为什么  myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</code></pre><h1 id="MySQL中varchar与char的区别以及varchar-50-中的50代表的涵义"><a href="#MySQL中varchar与char的区别以及varchar-50-中的50代表的涵义" class="headerlink" title="MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义"></a>MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义</h1><pre><code>(1)、varchar与char的区别  char是一种固定长度的类型  varchar则是一种可变长度的类型(2)、varchar(50)中50的涵义  最多存放50个字符  varchar(50)和(200)存储hello所占空间一样  但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)(3)、int（20）中20的涵义  是指显示字符的长度  要加参数的，最大为255  比如它是记录行数的id,插入10笔资料，它就显示00000000001 ~~~00000000010，当字符的位数超过11,它也只显示11位，如果你没有加那个让它未满11位就前面加0的参数，它不会在前面加0  20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；(4)、mysql为什么这么设计  对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；</code></pre><h1 id="问了innodb的事务与日志的实现方式"><a href="#问了innodb的事务与日志的实现方式" class="headerlink" title="问了innodb的事务与日志的实现方式"></a>问了innodb的事务与日志的实现方式</h1><pre><code>(1)、有多少种日志；  错误日志：记录出错信息，也记录一些警告信息或者正确的信息。  查询日志：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。  慢查询日志：设置一个阈(yu)值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。  二进制日志：记录对数据库执行更改的所有操作。  中继日志：中继日志也是二进制日志，用来给slave 库恢复  事务日志：重做日志redo和回滚日志undo(2)、事物的4种隔离级别  读未提交(RU)        read uncommited ：读到未提交数据  读已提交(RC)        read committed：脏读，不可重复读  可重复读(RR)        repeatable read：可重读  串行        serializable ：串行事物(3)、事务是如何通过日志来实现的，说得越深入越好。  事务日志是通过redo和innodb的存储引擎日志缓冲（Innodb log buffer）来实现的  当开始一个事务的时候，会记录该事务的lsn(log sequence number)号;  当事务执行时，会往InnoDB存储引擎的日志的日志缓存里面插入事务日志；  当事务提交时，必须将存储引擎的日志缓冲写入磁盘（通过innodb_flush_log_at_trx_commit来控制），也就是写数据前，需要先写日志。这种方式称为“预写日志方式”</code></pre><h1 id="MySQL-binlog的几种日志录入格式以及区别"><a href="#MySQL-binlog的几种日志录入格式以及区别" class="headerlink" title="MySQL binlog的几种日志录入格式以及区别"></a>MySQL binlog的几种日志录入格式以及区别</h1><pre><code>Statement：每一条会修改数据的sql都会记录在binlog中。  优点      不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。  缺点      由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的 一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同 的结果。      使用以下函数的语句也有问题：              sleep()函数              last_insert_id()              user-defined functions(udf)              LOAD_FILE()              UUID()              USER()              FOUND_ROWS()              SYSDATE() (除非启动时启用了 --sysdate-is-now 选项)      同时在INSERT …SELECT 会产生比 RBR 更多的行级锁Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改。  优点      binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了      rowlevel的日志内容会非常清楚的记录下 每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题  缺点      可能会产生大量的日志内容Mixedlevel: 是以上两种level的混合使用  一般的语句修改使用statment格式保存binlog  一些函数，statement无法完成主从复制的操作，则 采用row格式保存binlog</code></pre><h1 id="MySQL数据库cpu飙升到500-的话他怎么处理？"><a href="#MySQL数据库cpu飙升到500-的话他怎么处理？" class="headerlink" title="MySQL数据库cpu飙升到500%的话他怎么处理？"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h1><pre><code>1、列出所有进程 show processlist,观察所有进程 ,多秒没有状态变化的(干掉)2、查看超时日志或者错误日志 (做了几年开发,一般会是查询以及大批量的插入会导致cpu与i/o上涨,当然不排除网络状态突然断了,导致一个请求服务器只接受到一半，比如where子句或分页子句没有发送,,当然的一次被坑经历)</code></pre><h1 id="sql优化各种方法"><a href="#sql优化各种方法" class="headerlink" title="sql优化各种方法"></a>sql优化各种方法</h1><pre><code>(1)、explain出来的各种item的意义；  select_type      表示查询中每个select子句的类型  type      表示MySQL在表中找到所需行的方式，又称“访问类型”  possible_keys      指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用  key      显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL  key_len      表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度  ref      表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值  Extra      包含不适合在其他列中显示但十分重要的额外信息(2)、profile的意义以及使用场景；  查询到 SQL 会执行多少时间, 并看出 CPU/Memory 使用量, 执行过程中 Systemlock, Table lock 花多少时间等等</code></pre><h1 id="备份计划，mysqldump以及xtranbackup的实现原理"><a href="#备份计划，mysqldump以及xtranbackup的实现原理" class="headerlink" title="备份计划，mysqldump以及xtranbackup的实现原理"></a>备份计划，mysqldump以及xtranbackup的实现原理</h1><pre><code>(1)、备份计划；  这里每个公司都不一样，您别说那种1小时1全备什么的就行(2)、备份恢复时间；  这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考      20G的2分钟（mysqldump）      80G的30分钟(mysqldump)      111G的30分钟（mysqldump)      288G的3小时（xtra)      3T的4小时（xtra)      逻辑导入时间一般是备份时间的5倍以上(3)、xtrabackup实现原理  在InnoDB内部会维护一个redo日志文件，我们也可以叫做事务日志文件  事务日志会存储每一个InnoDB表数据的记录修改。  当InnoDB启动时，InnoDB会检查数据文件和事务日志，并执行两个步骤：它应用（前滚）已经提交的事务日志到数据文件，并将修改过但没有提交的数据进行回滚操作。</code></pre><h1 id="500台db，在最快时间之内重启"><a href="#500台db，在最快时间之内重启" class="headerlink" title="500台db，在最快时间之内重启"></a>500台db，在最快时间之内重启</h1><pre><code>使用批量 ssh 工具 pssh 来对需要重启的机器执行重启命令。 也可以使用 salt（前提是客户端有安装 salt）或者 ansible（ ansible 只需要 ssh 免登通了就行）等多线程工具同时操作多台服务器</code></pre><h1 id="innodb的读写参数优化"><a href="#innodb的读写参数优化" class="headerlink" title="innodb的读写参数优化"></a>innodb的读写参数优化</h1><pre><code>(1)、读取参数  global buffer pool以及 local buffer；(2)、写入参数；  innodb_flush_log_at_trx_commit  innodb_buffer_pool_size(3)、与IO相关的参数；  innodb_write_io_threads = 8  innodb_read_io_threads = 8  innodb_thread_concurrency = 0(4)、缓存参数以及缓存的适用场景。  query cache/query_cache_type  并不是所有表都适合使用query cache。造成query cache失效的原因主要是相应的table发生了变更  第一个：读操作多的话看看比例，简单来说，如果是用户清单表，或者说是数据比例比较固定，比如说商品列表，是可以打开的，前提是这些库比较集中，数据库中的实务比较小。  第二个：我们“行骗”的时候，比如说我们竞标的时候压测，把query cache打开，还是能收到qps激增的效果，当然前提示前端的连接池什么的都配置一样。大部分情况下如果写入的居多，访问量并不多，那么就不要打开，例如社交网站的，10%的人产生内容，其余的90%都在消费，打开还是效果很好的，但是你如果是qq消息，或者聊天，那就很要命。  第三个：小网站或者没有高并发的无所谓，高并发下，会看到 很多 qcache 锁 等待，所以一般高并发下，不建议打开query cache</code></pre><h1 id="你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？"><a href="#你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？" class="headerlink" title="你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？"></a>你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？</h1><pre><code>监控的工具有很多，例如zabbix，lepus，我这里用的是lepus</code></pre><h1 id="你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？"><a href="#你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？" class="headerlink" title="你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？"></a>你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？</h1><pre><code>主从一致性校验有多种工具 例如checksum、mysqldiff、pt-table-checksum等checksummysqldiffpt-table-checksum</code></pre><h1 id="你们数据库是否支持emoji表情，如果不支持，如何操作？"><a href="#你们数据库是否支持emoji表情，如果不支持，如何操作？" class="headerlink" title="你们数据库是否支持emoji表情，如果不支持，如何操作？"></a>你们数据库是否支持emoji表情，如果不支持，如何操作？</h1><pre><code>如果是utf8字符集的话，需要升级至utf8_mb4方可支持utf8_mb4</code></pre><h1 id="你是如何维护数据库的数据字典的？"><a href="#你是如何维护数据库的数据字典的？" class="headerlink" title="你是如何维护数据库的数据字典的？"></a>你是如何维护数据库的数据字典的？</h1><pre><code>一般是直接在生产库进行注释，利用工具导出成excel方便流通</code></pre><h1 id="表中有大字段X-例如：text类型-，且字段X不会经常更新，以读为为主，请问"><a href="#表中有大字段X-例如：text类型-，且字段X不会经常更新，以读为为主，请问" class="headerlink" title="表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为为主，请问"></a>表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为为主，请问</h1><pre><code>拆带来的问题：连接消耗 + 存储拆分空间不拆可能带来的问题：查询性能；如果能容忍拆分带来的空间问题,拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区) 顺序IO,减少连接消耗,最后这是一个文本列再加上一个全文索引来尽量抵消连接消耗如果能容忍不拆分带来的查询性能损失的话:上面的方案在某个极致条件下肯定会出现问题,那么不拆就是最好的选择</code></pre><h1 id="MySQL中InnoDB引擎的行锁是通过加在什么上完成-或称实现-的？为什么是这样子的？"><a href="#MySQL中InnoDB引擎的行锁是通过加在什么上完成-或称实现-的？为什么是这样子的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？"></a>MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？</h1><pre><code>InnoDB是基于索引来完成行锁例: select * from tab_with_index where id = 1 for update;for update 可以根据条件来完成行锁锁定,并且 id 是有索引键的列,如果 id 不是索引键那么InnoDB将完成表锁,,并发将无从谈起</code></pre><h1 id="开放性问题：据说是腾讯的"><a href="#开放性问题：据说是腾讯的" class="headerlink" title="开放性问题：据说是腾讯的"></a>开放性问题：据说是腾讯的</h1><pre><code>一个6亿的表a，一个3亿的表b，通过外键tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。  1、如果A表TID是自增长,并且是连续的,B表的ID为索引  select * from a,b where a.tid = b.id and a.tid&gt;500000 limit 200;  2、如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。  select * from b , (select tid from a limit 50000,200) a where b.id = a .tid;</code></pre><h1 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a>什么是存储过程？有哪些优缺点？</h1><pre><code>存储过程是一些预编译的SQL语句。1、更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。2、存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全</code></pre><h1 id="索引有哪些数据结构"><a href="#索引有哪些数据结构" class="headerlink" title="索引有哪些数据结构"></a>索引有哪些数据结构</h1><pre><code>Hash、B+去创建索引的时候，可以选择索引的类型</code></pre><h1 id="索引是什么？有什么作用以及优缺点？"><a href="#索引是什么？有什么作用以及优缺点？" class="headerlink" title="索引是什么？有什么作用以及优缺点？"></a>索引是什么？有什么作用以及优缺点？</h1><pre><code>1、索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构2、索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。MySQL数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引  1、索引加快数据库的检索速度  2、索引降低了插入、删除、修改等维护任务的速度  3、唯一索引可以确保每一行数据的唯一性  4、通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能  5、索引需要占物理和数据空间</code></pre><h1 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h1><pre><code>事务（Transaction）是并发控制的基本单位。它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。</code></pre><h1 id="使用索引查询一定能提高查询的性能吗？为什么"><a href="#使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="使用索引查询一定能提高查询的性能吗？为什么"></a>使用索引查询一定能提高查询的性能吗？为什么</h1><pre><code>通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.1、索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况:2、基于一个范围的检索,一般查询返回结果集小于表中记录数的30%3、基于非唯一性索引的检索</code></pre><h1 id="简单说一说drop、delete与truncate的区"><a href="#简单说一说drop、delete与truncate的区" class="headerlink" title="简单说一说drop、delete与truncate的区"></a>简单说一说drop、delete与truncate的区</h1><pre><code>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别1、delete和truncate只删除表的数据不删除表的结构2、速度,一般来说: drop&gt; truncate &gt;delete3、delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;如果有相应的trigger,执行的时候将被触发.4、 truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.</code></pre><h1 id="drop、delete与truncate分别在什么场景之下使用？"><a href="#drop、delete与truncate分别在什么场景之下使用？" class="headerlink" title="drop、delete与truncate分别在什么场景之下使用？"></a>drop、delete与truncate分别在什么场景之下使用？</h1><pre><code>1、不再需要一张表的时候，用drop2、想删除部分数据行时候，用delete，并且带上where子句3、保留表而删除所有数据的时候用truncate</code></pre><h1 id="超键、候选键、主键、外键分别是什么？"><a href="#超键、候选键、主键、外键分别是什么？" class="headerlink" title="超键、候选键、主键、外键分别是什么？"></a>超键、候选键、主键、外键分别是什么？</h1><pre><code>1、超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。2、候选键：是最小超键，即没有冗余元素的超键。3、主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。4、外键：在一个表中存在的另一个表的主键称此表的外键。</code></pre><h1 id="什么是视图？以及视图的使用场景有哪些？"><a href="#什么是视图？以及视图的使用场景有哪些？" class="headerlink" title="什么是视图？以及视图的使用场景有哪些？"></a>什么是视图？以及视图的使用场景有哪些？</h1><pre><code>1、视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。2、只暴露部分字段给访问者，所以就建一个虚表，就是视图。3、查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异</code></pre><h1 id="说一说三个范式。"><a href="#说一说三个范式。" class="headerlink" title="说一说三个范式。"></a>说一说三个范式。</h1><pre><code>第一范式（1NF）：属性唯一  数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。第二范式（2NF）：记录唯一  2:要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情第三范式（3NF）：表唯一  3:表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）</code></pre><h1 id="数据库的乐观锁和悲观锁是什么？"><a href="#数据库的乐观锁和悲观锁是什么？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？"></a>数据库的乐观锁和悲观锁是什么？</h1><pre><code>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</code></pre><h1 id="Mysql中有哪几种锁？"><a href="#Mysql中有哪几种锁？" class="headerlink" title="Mysql中有哪几种锁？"></a>Mysql中有哪几种锁？</h1><pre><code>1.表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。2.行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。3. 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</code></pre><h1 id="mysql有哪些引擎"><a href="#mysql有哪些引擎" class="headerlink" title="mysql有哪些引擎"></a>mysql有哪些引擎</h1><pre><code> MyISAMHeapMergeINNODBISAM</code></pre><h1 id="简述在MySQL数据库中MyISAM和InnoDB的区别"><a href="#简述在MySQL数据库中MyISAM和InnoDB的区别" class="headerlink" title="简述在MySQL数据库中MyISAM和InnoDB的区别"></a>简述在MySQL数据库中MyISAM和InnoDB的区别</h1><pre><code>MyISAM：  不支持事务，但是每次查询都是原子的；  支持表级锁，即每次操作是对整个表加锁；  存储表的总行数；  一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；  采用菲聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。InnoDb  支持ACID的事务，支持事务的四种隔离级别；  支持行级锁及外键约束：因此可以支持写并发；  不存储总行数；  一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制；  主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。</code></pre><h1 id="主键和候选键有什么区别？"><a href="#主键和候选键有什么区别？" class="headerlink" title="主键和候选键有什么区别？"></a>主键和候选键有什么区别？</h1><pre><code>表格的每一行都由主键唯一标识,一个表只有一个主键。主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</code></pre><h1 id="myisamchk是用来做什么的？"><a href="#myisamchk是用来做什么的？" class="headerlink" title="myisamchk是用来做什么的？"></a>myisamchk是用来做什么的？</h1><pre><code>它用来压缩MyISAM表，这减少了磁盘或内存使用。</code></pre><h1 id="MyISAM-Static和MyISAM-Dynamic有什么区别？"><a href="#MyISAM-Static和MyISAM-Dynamic有什么区别？" class="headerlink" title="MyISAM Static和MyISAM Dynamic有什么区别？"></a>MyISAM Static和MyISAM Dynamic有什么区别？</h1><pre><code>在MyISAM Static上的所有字段有固定宽度。动态MyISAM表将具有像TEXT，BLOB等字段，以适应不同长度的数据类型。MyISAM Static在受损情况下更容易恢复。</code></pre><h1 id="如果一个表有一列定义为TIMESTAMP，将发生什么？"><a href="#如果一个表有一列定义为TIMESTAMP，将发生什么？" class="headerlink" title="如果一个表有一列定义为TIMESTAMP，将发生什么？"></a>如果一个表有一列定义为TIMESTAMP，将发生什么？</h1><pre><code>每当行被更改时，时间戳字段将获取当前时间戳。</code></pre><h1 id="列设置为AUTO-INCREMENT时，如果在表中达到最大值，会发生什么情况？"><a href="#列设置为AUTO-INCREMENT时，如果在表中达到最大值，会发生什么情况？" class="headerlink" title="列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？"></a>列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？</h1><pre><code>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</code></pre><h1 id="怎样才能找出最后一次插入时分配了哪个自动增量？"><a href="#怎样才能找出最后一次插入时分配了哪个自动增量？" class="headerlink" title="怎样才能找出最后一次插入时分配了哪个自动增量？"></a>怎样才能找出最后一次插入时分配了哪个自动增量？</h1><pre><code>LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。</code></pre><h1 id="你怎么看到为表格定义的所有索引？"><a href="#你怎么看到为表格定义的所有索引？" class="headerlink" title="你怎么看到为表格定义的所有索引？"></a>你怎么看到为表格定义的所有索引？</h1><pre><code>SHOW INDEX FROM</code></pre><h1 id="LIKE声明中的％和-是什么意思？"><a href="#LIKE声明中的％和-是什么意思？" class="headerlink" title="LIKE声明中的％和_是什么意思？"></a>LIKE声明中的％和_是什么意思？</h1><pre><code>％对应于0个或更多字符，_只是LIKE语句中的一个字符。子主题 2</code></pre><h1 id="如何在Unix和Mysql时间戳之间进行转换？"><a href="#如何在Unix和Mysql时间戳之间进行转换？" class="headerlink" title="如何在Unix和Mysql时间戳之间进行转换？"></a>如何在Unix和Mysql时间戳之间进行转换？</h1><pre><code>UNIX_TIMESTAMP是从Mysql时间戳转换为Unix时间戳的命令FROM_UNIXTIME是从Unix时间戳转换为Mysql时间戳的命令</code></pre><h1 id="列对比运算符是什么？"><a href="#列对比运算符是什么？" class="headerlink" title="列对比运算符是什么？"></a>列对比运算符是什么？</h1><pre><code>在SELECT语句的列比较中使用=，&lt;&gt;，&lt;=，&lt;，&gt; =，&gt;，&lt;&lt;，&gt;&gt;，&lt;=&gt;，AND，OR或LIKE运算符。</code></pre><h1 id="BLOB和TEXT有什么区别？"><a href="#BLOB和TEXT有什么区别？" class="headerlink" title="BLOB和TEXT有什么区别？"></a>BLOB和TEXT有什么区别？</h1><pre><code>BLOB是一个二进制对象，可以容纳可变数量的数据。TEXT是一个不区分大小写的BLOB。BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。</code></pre><h1 id="mysql-fetch-array和mysql-fetch-object的区别是什么？"><a href="#mysql-fetch-array和mysql-fetch-object的区别是什么？" class="headerlink" title="mysql_fetch_array和mysql_fetch_object的区别是什么？"></a>mysql_fetch_array和mysql_fetch_object的区别是什么？</h1><pre><code>mysql_fetch_array（） – 将结果行作为关联数组或来自数据库的常规数组返回。mysql_fetch_object – 从数据库返回结果行作为对象。</code></pre><h1 id="MyISAM表格将在哪里存储，并且还提供其存储格式？"><a href="#MyISAM表格将在哪里存储，并且还提供其存储格式？" class="headerlink" title="MyISAM表格将在哪里存储，并且还提供其存储格式？"></a>MyISAM表格将在哪里存储，并且还提供其存储格式？</h1><pre><code>每个MyISAM表格以三种格式存储在磁盘上：·“.frm”文件存储表定义·数据文件具有“.MYD”（MYData）扩展名索引文件具有“.MYI”（MYIndex）扩展名</code></pre><h1 id="Mysql如何优化DISTINCT？"><a href="#Mysql如何优化DISTINCT？" class="headerlink" title="Mysql如何优化DISTINCT？"></a>Mysql如何优化DISTINCT？</h1><pre><code>DISTINCT在所有列上转换为GROUP BY，并与ORDER BY子句结合使用。</code></pre><h1 id="如何显示前50行？"><a href="#如何显示前50行？" class="headerlink" title="如何显示前50行？"></a>如何显示前50行？</h1><pre><code>SELECT*FROM LIMIT 0,50;</code></pre><h1 id="可以使用多少列创建索引？"><a href="#可以使用多少列创建索引？" class="headerlink" title="可以使用多少列创建索引？"></a>可以使用多少列创建索引？</h1><pre><code>任何标准表最多可以创建16个索引列。</code></pre><h1 id="NOW（）和CURRENT-DATE（）有什么区别？"><a href="#NOW（）和CURRENT-DATE（）有什么区别？" class="headerlink" title="NOW（）和CURRENT_DATE（）有什么区别？"></a>NOW（）和CURRENT_DATE（）有什么区别？</h1><pre><code>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。CURRENT_DATE（）仅显示当前年份，月份和日期。</code></pre><h1 id="什么是非标准字符串类型？"><a href="#什么是非标准字符串类型？" class="headerlink" title="什么是非标准字符串类型？"></a>什么是非标准字符串类型？</h1><pre><code>TINYTEXT TEXT MEDIUMTEXT LONGTEXT</code></pre><h1 id="什么是通用SQL函数？"><a href="#什么是通用SQL函数？" class="headerlink" title="什么是通用SQL函数？"></a>什么是通用SQL函数？</h1><pre><code>CONCAT(A, B) – 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。FORMAT(X, D)- 格式化数字X到D有效数字。CURRDATE(), CURRTIME()- 返回当前日期或时间。NOW（） – 将当前日期和时间作为一个值返回。MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） – 从日期值中提取给定数据。HOUR（），MINUTE（），SECOND（） – 从时间值中提取给定数据。DATEDIFF（A，B） – 确定两个日期之间的差异，通常用于计算年龄SUBTIMES（A，B） – 确定两次之间的差异。FROMDAYS（INT） – 将整数天数转换为日期值。</code></pre><h1 id="MYSQL支持事务吗？"><a href="#MYSQL支持事务吗？" class="headerlink" title="MYSQL支持事务吗？"></a>MYSQL支持事务吗？</h1><pre><code>在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，你的MYSQL就可以使用事务处理,使用SET AUTOCOMMIT=0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。</code></pre><h1 id="mysql里记录货币用什么字段类型好"><a href="#mysql里记录货币用什么字段类型好" class="headerlink" title="mysql里记录货币用什么字段类型好"></a>mysql里记录货币用什么字段类型好</h1><pre><code>NUMERICDECIMAL  salary DECIMAL(9,2)  9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。  因此，在这种情况下，能被存储在salary列中的值的范围是从-9999999.99到9999999.99。</code></pre><h1 id="mysql有关权限的表都有哪几个？"><a href="#mysql有关权限的表都有哪几个？" class="headerlink" title="mysql有关权限的表都有哪几个？"></a>mysql有关权限的表都有哪几个？</h1><pre><code>Mysql服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。userdbtable_privcolumns_privhost</code></pre><h1 id="列的字符串类型可以是什么？"><a href="#列的字符串类型可以是什么？" class="headerlink" title="列的字符串类型可以是什么？"></a>列的字符串类型可以是什么？</h1><pre><code>字符串类型是： SET BLOB ENUM CHAR TEXT</code></pre><h1 id="MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年-怎么优化？"><a href="#MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年-怎么优化？" class="headerlink" title="MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？"></a>MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？</h1><pre><code>a. 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。b. 选择合适的表字段数据类型和存储引擎，适当的添加索引。c. mysql库主从读写分离。d. 找规律分表，减少单表中的数据量提高查询速度。e。添加缓存机制，比如memcached，apc等。f. 不经常改动的页面，生成静态页面。g. 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE.</code></pre><h1 id="锁的优化策略"><a href="#锁的优化策略" class="headerlink" title="锁的优化策略"></a>锁的优化策略</h1><pre><code>1. 读写分离2. 分段加锁3. 减少锁持有的时间4. 多个线程尽量以相同的顺序去获取资源不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁。</code></pre><h1 id="索引的底层实现原理和优化"><a href="#索引的底层实现原理和优化" class="headerlink" title="索引的底层实现原理和优化"></a>索引的底层实现原理和优化</h1><pre><code>B+树，经过优化的B+树主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此InnoDB建议为大部分表使用默认自增的主键作为主索引。</code></pre><h1 id="什么情况下设置了索引但无法使用"><a href="#什么情况下设置了索引但无法使用" class="headerlink" title="什么情况下设置了索引但无法使用"></a>什么情况下设置了索引但无法使用</h1><pre><code>1.以“%”开头的LIKE语句，模糊匹配2. OR语句前后没有同时使用索引3. 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）</code></pre><h1 id="实践中如何优化MySQL"><a href="#实践中如何优化MySQL" class="headerlink" title="实践中如何优化MySQL"></a>实践中如何优化MySQL</h1><pre><code>1.SQL语句及索引的优化2. 数据库表结构的优化3.系统配置的优化4.硬件的优化</code></pre><h1 id="优化数据库的方法"><a href="#优化数据库的方法" class="headerlink" title="优化数据库的方法"></a>优化数据库的方法</h1><pre><code>选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如’省份’、’性别’最好适用ENUM使用连接(JOIN)来代替子查询适用联合(UNION)来代替手动创建的临时表事务处理锁定表、优化事务处理适用外键，优化锁定表建立索引优化查询语句</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL的复制原理以及流程&quot;&gt;&lt;a href=&quot;#MySQL的复制原理以及流程&quot; class=&quot;headerlink&quot; title=&quot;MySQL的复制原理以及流程&quot;&gt;&lt;/a&gt;MySQL的复制原理以及流程&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;基本原理流程，3个线程以及之
      
    
    </summary>
    
    
      <category term="面试" scheme="http://iwantjingjing.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试，mysql" scheme="http://iwantjingjing.com/tags/%E9%9D%A2%E8%AF%95%EF%BC%8Cmysql/"/>
    
  </entry>
  
  <entry>
    <title>redis面试题</title>
    <link href="http://iwantjingjing.com/2020/04/16/redis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://iwantjingjing.com/2020/04/16/redis%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-04-16T10:03:11.000Z</published>
    <updated>2020-04-16T10:12:41.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="双写一致问题"><a href="#双写一致问题" class="headerlink" title="双写一致问题"></a>双写一致问题</h2><pre><code>非原子操作，多线程一定会发生解决方案：延时双删策略    先删Redis，再删数据库，再删Redis知乎答案</code></pre><h2 id="redis与memcached有什么区别？为什么选用redis作为缓存的中间件"><a href="#redis与memcached有什么区别？为什么选用redis作为缓存的中间件" class="headerlink" title="redis与memcached有什么区别？为什么选用redis作为缓存的中间件"></a>redis与memcached有什么区别？为什么选用redis作为缓存的中间件</h2><pre><code>1： Redis支持数据结构多，如果需要缓存支持负责的结构，Redis是不错的选择2： Redis天生支持集群，memcached需要依赖客户端来实现往集群中分片写入数据3： 性能对比    1 Redis单核，所以平均每个核上Redis处理小数据时性能优于memcached    2 memcached多核,处理大于100k数据时优于Redis4.Redis支持数据的备份，即master-slave模式的数据备份。3.Redis可以持久化其数据</code></pre><h2 id="说说redis线程模型"><a href="#说说redis线程模型" class="headerlink" title="说说redis线程模型"></a>说说redis线程模型</h2><pre><code>1 file event handler    内部使用文件事件处理器 file event handler，这个是单线程的，所以redis才叫单线程的模型    结构            1多个socket            2 io多路复用程序            3文件时间分派器            4 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）2 io多路复用机制同时监听多个socket    采用io多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器进行处理。</code></pre><h2 id="Redis有哪些数据结构啊？"><a href="#Redis有哪些数据结构啊？" class="headerlink" title="Redis有哪些数据结构啊？"></a>Redis有哪些数据结构啊？</h2><pre><code>普通青年    1String            二进制安全的字符串，最大512M    2 Hash    3 List            按照添加顺序保持顺序的字符串列表    4 Set            无序的字符串集合，不存在重复的元素。    5 SortedSet(/Zset)            已排序的字符串集合。2B青年    1 HyperLogLog    2 Geo    3 Pub    4 Sub文艺青年    1 Redis Module    2 BloomFilter    3 RedisSearch    4 Redis-ML</code></pre><h2 id="如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h2><pre><code>1 过期时间设置的过于集中，到过期的时候，Redis可能会出现短暂的卡顿现象，2 严重会雪崩3 一般在时间上加一个随机值，使得过期时间分散一些4 示例：如电商的首页</code></pre><h2 id="你使用过Redis分布式锁么，它是怎么回事？"><a href="#你使用过Redis分布式锁么，它是怎么回事？" class="headerlink" title="你使用过Redis分布式锁么，它是怎么回事？"></a>你使用过Redis分布式锁么，它是怎么回事？</h2><pre><code>1 setnx    先拿setnx来争抢锁2 expire    抢到之后，再用Expire给锁加一个过期时间防止锁忘记释放</code></pre><h2 id="如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？"><a href="#如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？" class="headerlink" title="如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？"></a>如果在setnx之后，执行expire之前，进程意外重启维护了，会怎么样？</h2><pre><code>set指令有个非常复杂的参数EX，这个应该是可以同时把setnx和expire合成一条指令来用的</code></pre><h2 id="假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？"><a href="#假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？" class="headerlink" title="假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？"></a>假如redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？</h2><pre><code>使用keys指令可以扫出指定模式的key列表</code></pre><h2 id="继续追问：如果这个redis正在给线上的业务提供服务，那么使用keys指令会有什么问题"><a href="#继续追问：如果这个redis正在给线上的业务提供服务，那么使用keys指令会有什么问题" class="headerlink" title="继续追问：如果这个redis正在给线上的业务提供服务，那么使用keys指令会有什么问题?"></a>继续追问：如果这个redis正在给线上的业务提供服务，那么使用keys指令会有什么问题?</h2><pre><code>1 redis是单线程的，使用keys会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕2 可使用scan指令非阻塞的取出    1 缺点： 有一定重复    2 单体花费时间比keys长</code></pre><h2 id="redis是怎么持久化的？"><a href="#redis是怎么持久化的？" class="headerlink" title="redis是怎么持久化的？"></a>redis是怎么持久化的？</h2><pre><code>1 rdb    1 rdb做镜像全量持久化    2 耗费较长    3不够实时    4导致大量丢失数据    5理解为一整个表全量的数据    6生成指定时间间隔内的 Redis 内存中数据快照，是一个二进制文件 dumpr.rdb2 aof    1 aof做增量持久化    2 每次操作的日志    3记录 Redis 除了查询以外的所有写命令，并在Redis 服务启动时，通过重新执行这些命令来还原数据。3 在redis实例重启时，会使用rdb持久化文件重构内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态4 机制    1 aof持久化开启且存在aof文件时，优先加载aof文件    2 aof关闭或者aof文件不存在时，加载rdb文件    3 加载aof/rdb文件成功后，redis启动成功    4 aof/rdb文件存在错误时，redis启动失败并打印错误信息</code></pre><h2 id="redis服务主从数据是怎么交互的？"><a href="#redis服务主从数据是怎么交互的？" class="headerlink" title="redis服务主从数据是怎么交互的？"></a>redis服务主从数据是怎么交互的？</h2><pre><code>1 slave发送psync命令给master    若这个slave第一次连接到master，他会触发一个全量复制。2 master就会启动一个线程，生成RDB快照，还会把新的写请求都缓存在内存中3 RDB文件生成后，master会将这个RDB发送给slave的4 slave拿到之后做的第一件事情就是写进本地的磁盘，然后加载进内存，5 然后master会把内存里面缓存的那些新命名都发给slave。</code></pre><h2 id="对方追问如果突然机器停电会怎样"><a href="#对方追问如果突然机器停电会怎样" class="headerlink" title="对方追问如果突然机器停电会怎样?"></a>对方追问如果突然机器停电会怎样?</h2><pre><code>1 取决于aof日志sync属性的配置2在每一条写指令时都sync一下磁盘，就不会丢失数据，    在高性能要求下每次都sync是不现实的3一般都使用定时sync，比如1s/1次，这个时候最多就会丢失1s的数据</code></pre><h2 id="对方继续追问rdb的原理是什么？"><a href="#对方继续追问rdb的原理是什么？" class="headerlink" title="对方继续追问rdb的原理是什么？"></a>对方继续追问rdb的原理是什么？</h2><pre><code>1 fork    指redis通过创建子进程来进行rdb操作2 cow    cow指的是copy on write            写时复制机制3 原理    1 Redis 调用 fork() ，同时拥有父进程和子进程。    2 子进程将数据集写入到一个临时 RDB 文件中。    3 当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。4 优点    1保存了 Redis 在某个时间点的数据，这种数据比较适合做备份和用于灾难恢复。    2也可以随时将数据集还原到不同的版本    RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。    在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）5 RDB 的缺点    服务器故障时丢失数据</code></pre><h2 id="AOF创建原理"><a href="#AOF创建原理" class="headerlink" title="AOF创建原理"></a>AOF创建原理</h2><pre><code>1 AOF 重写和 RDB 创建快照一样，都巧妙地利用了写时复制机制。2 Redis 执行 fork() ，现在同时拥有父进程和子进程。3 子进程开始将新 AOF 文件的内容写入到临时文件。4 对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾    优点：即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。5 当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。6 优点    只进行追加操作的日志文件，不产生新文件    AOF文件过大自动优化为恢复当前数据集所需的最小命令集合。    可以设置不同的 fsync 策略7 缺点    文件的体积通常要大于 RDB 文件    根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。    在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）    RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</code></pre><h2 id="Redis的过期策略？"><a href="#Redis的过期策略？" class="headerlink" title="Redis的过期策略？"></a>Redis的过期策略？</h2><pre><code>1定期删除    默认100s就随机抽一些设置了过期时间的key，去检查是否过期，过期了就删了            为啥不扫描全部设置了过期时间的key呢？            线上基本上也都是会设置一定的过期时间的。            全扫描跟你去查数据库不带where条件不走索引全表扫描一样，100s一次，Redis累都累死了。2 惰性删除    见名知意，惰性嘛，我不主动删，我懒，我等你来查询了我看看你过期没，过期就删了还不给你返回，没过期该怎么样就怎么样。</code></pre><h2 id="Redis最后就是如果的如果，定期没删，我也没查询，那可咋整？"><a href="#Redis最后就是如果的如果，定期没删，我也没查询，那可咋整？" class="headerlink" title="Redis最后就是如果的如果，定期没删，我也没查询，那可咋整？"></a>Redis最后就是如果的如果，定期没删，我也没查询，那可咋整？</h2><pre><code>内存淘汰机制！    noeviction            返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）    allkeys-lru             尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。    volatile-lru            尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。    allkeys-random            回收随机的键使得新添加的数据有空间存放。    volatile-random            回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。    volatile-ttl            回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放</code></pre><h2 id="什么是LRU算法"><a href="#什么是LRU算法" class="headerlink" title="什么是LRU算法"></a>什么是LRU算法</h2><pre><code>1 一种缓存淘汰算法2 Least recently used，最近最少使用3 核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”4实现方式    LinkedHashMap</code></pre><h2 id="为什么redis那么快"><a href="#为什么redis那么快" class="headerlink" title="为什么redis那么快"></a>为什么redis那么快</h2><pre><code>先吹个牛逼    Redis采用的是单进程单线程模型的kv数据库，由c编写，官方提供的数据是达到10w的qps（每秒内查询次数）1 基于内存操作    完全基于内存，绝大部分请求是纯粹的内存操作，非常快。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1);2 数据结构优化    数据结构简单，对数据操作也简单，redis中的数据结构是专门进行设计的3 单线程    避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换消耗，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。4 多路I/O复用模型    使用多路i/o复用模型，非阻塞io；5 底层模型不同    redis直接自己构建了vm机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</code></pre><h2 id="我可以问一下啥是上下文切换吗？为啥可能线程不安全？"><a href="#我可以问一下啥是上下文切换吗？为啥可能线程不安全？" class="headerlink" title="我可以问一下啥是上下文切换吗？为啥可能线程不安全？"></a>我可以问一下啥是上下文切换吗？为啥可能线程不安全？</h2><pre><code>好比你看一本英文书，你看到第十页发现有个单词不会，你加了个书签，然后去查字典，过了一会你回来继续从书签那里读，ok目前为止没问题。问题来了，你去查字典的时候，别人过来翻了一下你的书，然后走了，然后你回来了，你再看书的时候发现书不是你看的那一页了。</code></pre><h2 id="那他是单线程，我们服务器都是多核的，那不是浪费吗？"><a href="#那他是单线程，我们服务器都是多核的，那不是浪费吗？" class="headerlink" title="那他是单线程，我们服务器都是多核的，那不是浪费吗？"></a>那他是单线程，我们服务器都是多核的，那不是浪费吗？</h2><pre><code>虽然他是单线程的，但是我们可以单机开多个实例啊</code></pre><h2 id="既然提到了单机会有瓶颈，那你们是怎么解决这个瓶颈的？"><a href="#既然提到了单机会有瓶颈，那你们是怎么解决这个瓶颈的？" class="headerlink" title="既然提到了单机会有瓶颈，那你们是怎么解决这个瓶颈的？"></a>既然提到了单机会有瓶颈，那你们是怎么解决这个瓶颈的？</h2><pre><code>redis cluster主从同步读写分离Redis cluster支撑n个redis mater node，并且每个master node 都可以挂载多个salve node这样整个Redis就可以横向扩容了，如果你要吃成更大数据量的缓存，那就横向扩容更多的master节点，每个master节点就能存放更多的数据了。</code></pre><h2 id="Redis还有其他保证集群高可用的方式吗？"><a href="#Redis还有其他保证集群高可用的方式吗？" class="headerlink" title="Redis还有其他保证集群高可用的方式吗？"></a>Redis还有其他保证集群高可用的方式吗？</h2><pre><code>哨兵集群sentinel（森提nou）哨兵必须用三个实例去保证自己的健壮性，哨兵+主从并不能保证数据不丢失，但是可以保证集群的高可用一个机器挂了，剩下两个机器需要选举出来一个执行故障转移，如果只有两台机器的话，挂了一个就剩下一个了，没有哨兵去允许故障转移了</code></pre><h2 id="Redis的同步机制"><a href="#Redis的同步机制" class="headerlink" title="Redis的同步机制"></a>Redis的同步机制</h2><pre><code>1 主从同步，从从同步2 第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录内存buffer，3 待完成后将rdb文件全量同步到复制节点4 复制节点接受完成后将rdb镜像加载到内存5 加载完成后，通知主节点将期间修改的操作记录同步到点进行重放就完成了同步过程6 后续的增量数据通过aof日志同步即知，有点类似数据库的binlog。</code></pre><h2 id="Redis-并发竞争key问题如何解决"><a href="#Redis-并发竞争key问题如何解决" class="headerlink" title="Redis 并发竞争key问题如何解决?"></a>Redis 并发竞争key问题如何解决?</h2><pre><code>原因：同时有多个客户端去set一个key。场景1： 例如有多个请求一起去对某个商品减库存场景2： 比如有3个请求有序的修改某个key解决方案：    1：乐观锁适用于大家一起抢着改同一个key，对修改顺序没有要求的场景。            watch 命令可以方便的实现乐观锁。            乐观锁适用于大家一起抢着改同一个key，对修改顺序没有要求的场景。            原理：watch 命令会监视给定的每一个key，当 exec 时如果监视的任一个key自从调用watch后发生过变化，则整个事务会回滚，不执行任何动作。            如果你的 redis 使用了数据分片的方式，那么这个方法就不适用了    2： 分布式锁            适合分布式环境，不用关心 redis 是否为分片集群模式。            ZooKeeper            Redis    3 时间戳，适合有序场景    4 消息队列，串行化处理            在并发量很大的情况下，可以通过消息队列进行串行化处理。这在高并发场景中是一种很常见的解决方案。</code></pre><h2 id="是否使用过Redis集群，集群的原理是什么？"><a href="#是否使用过Redis集群，集群的原理是什么？" class="headerlink" title="是否使用过Redis集群，集群的原理是什么？"></a>是否使用过Redis集群，集群的原理是什么？</h2><pre><code>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</code></pre><h2 id="如何使用过Redis做异步队列？"><a href="#如何使用过Redis做异步队列？" class="headerlink" title="如何使用过Redis做异步队列？"></a>如何使用过Redis做异步队列？</h2><pre><code>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。如果不用sleep，list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。如果想要生产一次消费多次，可以使用pub/sub主题订阅者模式，可以实现1:N的消息队列，但在消费者下线后，生产的消息会丢失，想要持久化的话，需要使用消息队列如rabbitmq等。</code></pre><h2 id="Redis如何实现延时队列？"><a href="#Redis如何实现延时队列？" class="headerlink" title="Redis如何实现延时队列？"></a>Redis如何实现延时队列？</h2><pre><code>使用sortedset拿时间戳作为score消息内容作为key调用zadd来生产消息消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。</code></pre><h2 id="Redis单点吞吐量"><a href="#Redis单点吞吐量" class="headerlink" title="Redis单点吞吐量"></a>Redis单点吞吐量</h2><pre><code>单点TPS达到8万/秒QPS达到10万/秒</code></pre><h2 id="什么是TPS"><a href="#什么是TPS" class="headerlink" title="什么是TPS"></a>什么是TPS</h2><pre><code>每秒钟最大能处理的请求数每秒钟处理完的事务次数，一个应用系统1s能完成多少事务处理，一个事务在分布式处理中，可能会对应多个请求，对于衡量单个接口服务的处理能力，用QPS比较合理。</code></pre><h2 id="什么是QPS"><a href="#什么是QPS" class="headerlink" title="什么是QPS"></a>什么是QPS</h2><pre><code>应用系统每秒钟最大能接受的用户访问量每秒钟处理完请求的次数，注意这里是处理完，具体是指发出请求到服务器处理完成功返回结果。可以理解在server中有个counter，每处理一个请求加1，1秒后counter=QPS。</code></pre><h2 id="Redis哈希槽"><a href="#Redis哈希槽" class="headerlink" title="Redis哈希槽"></a>Redis哈希槽</h2><pre><code>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中</code></pre><h2 id="Redis集群最大节点个数是多少？"><a href="#Redis集群最大节点个数是多少？" class="headerlink" title="Redis集群最大节点个数是多少？"></a>Redis集群最大节点个数是多少？</h2><pre><code>Redis集群预分好16384个桶(哈希槽)</code></pre><h2 id="Redis事务是什么？"><a href="#Redis事务是什么？" class="headerlink" title="Redis事务是什么？"></a>Redis事务是什么？</h2><pre><code>Redis事务可以一次执行多个命令，有以下特点：    批量操作在发送 EXEC 命令前被放入队列缓存。    收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。    在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</code></pre><h2 id="Redis线程模型？"><a href="#Redis线程模型？" class="headerlink" title="Redis线程模型？"></a>Redis线程模型？</h2><pre><code>单线程Redis 4.0 之后的版本却抛弃了单线程模型这一设</code></pre><h2 id="Pipeline有什么好处，为什么要用Pipeline？"><a href="#Pipeline有什么好处，为什么要用Pipeline？" class="headerlink" title="Pipeline有什么好处，为什么要用Pipeline？"></a>Pipeline有什么好处，为什么要用Pipeline？</h2><pre><code>可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目</code></pre><h2 id="redis常用命令"><a href="#redis常用命令" class="headerlink" title="redis常用命令"></a>redis常用命令</h2><pre><code>Keys    *表示区配所有，    以bit开头的，    查看Exists key是否存在。Set    设置 key 对应的值为 string 类型的 value。setnx    设置 key 对应的值为 string 类型的 value    如果 key 已经存在，返回 0，nx 是 not exist 的意思。Expire    设置过期时间（单位秒）TTL    查看剩下多少时间    返回负数则key失效，key不存在了Setex    设置 key 对应的值为 string 类型的 value，并指定此键值对应的有效期。Mset    一次设置多个 key 的值，    成功返回 ok 表示所有的值都设置了，失败返回 0 表示没有任何值被设置。Getset    设置 key 的值    并返回 key 的旧值Mget    一次获取多个 key 的值    如果对应 key 不存在，则对应返回 nilIncr    对 key 的值做加加操作,并返回新的值    注意 incr 一个不是 int 的 value 会返回错误    incr 一个不存在的 key，则设置 key 为 1incrby    同 incr 类似，加指定值 ，key 不存在时候会设置 key，并认为原来的 value 是 0Decr    对 key 的值做的是减减操作，decr 一个不存在 key，则设置 key 为-1Decrby    同 decr，减指定值。Append    给指定 key 的字符串值追加 value,返回新字符串值的长度。Strlen    取指定 key 的 value 值的长度。persist xxx(取消过期时间)    选择数据库（0-15库）Select 0 //选择数据库move age 1//把age 移动到1库Randomkey随机返回一个keyRename重命名Type 返回数据类型在bin下的可执行文件    redis-server ：Redis的服务端    redis-cli ：命令行客户端    redis-benchmark ：Redis性能测试工具    redis-check-aof ：AOF文件修复工具    redis-check-dump ：RDB文件检测工具    redis-sentinel : 用于做主备</code></pre><h2 id="Redis启动方式有几种"><a href="#Redis启动方式有几种" class="headerlink" title="Redis启动方式有几种"></a>Redis启动方式有几种</h2><pre><code>不加载配置启动：redis-server加载配置启动：redis-server /etc/redis.conf使用docker启动：run -d --rm -v /root/test/redis.conf:/redis.conf --name redis-test -p 6379:6379 redis:5.0.0</code></pre><h2 id="Redis停止方式有几种"><a href="#Redis停止方式有几种" class="headerlink" title="Redis停止方式有几种"></a>Redis停止方式有几种</h2><pre><code>命令行连上redis以后运行shutdown直接结束redis进程：kill ...停止docker启动的redis：docker stop redis-test</code></pre><h2 id="Redis常见性能问题解决之道"><a href="#Redis常见性能问题解决之道" class="headerlink" title="Redis常见性能问题解决之道"></a>Redis常见性能问题解决之道</h2><pre><code>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内尽量避免在压力很大的主库上增加从库(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…    这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</code></pre><h2 id="redis集群投票机制"><a href="#redis集群投票机制" class="headerlink" title="redis集群投票机制"></a>redis集群投票机制</h2><pre><code>redis集群服务器之间通过互相的ping-pong判断是否节点可以连接上如果有一半以上的节点去ping一个节点的时候没有回应，集群就认为这个节点宕机了。</code></pre><h2 id="Redis主要有哪些功能？"><a href="#Redis主要有哪些功能？" class="headerlink" title="Redis主要有哪些功能？"></a>Redis主要有哪些功能？</h2><pre><code>1.哨兵（Sentinel）和复制（Replication）    Sentinel可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能，    Replication则是负责让一个Redis服务器可以配备多个备份的服务器。    Redis也是利用这两个功能来保证Redis的高可用的2.事务    支持一次性按顺序执行多个命令的能力，并保证其原子性。3.LUA脚本    在事务的基础上，如果我们需要在服务端一次性的执行更复杂的操作（包含一些逻辑判断），则lua就可以排上用场了4.持久化5.集群（Cluster）    Cluster    在Redis官方的分布式方案出来之前，有twemproxy和codis两种方案，这两个方案总体上来说都是依赖proxy来进行分布式的。</code></pre><h2 id="Redis为什么是单线程的？"><a href="#Redis为什么是单线程的？" class="headerlink" title="Redis为什么是单线程的？"></a>Redis为什么是单线程的？</h2><pre><code>多线程处理会涉及到锁，上下文切换，单线程没有这些消耗Redis是单进程单线程的，Redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</code></pre><h2 id="Redis瓶颈可能是"><a href="#Redis瓶颈可能是" class="headerlink" title="Redis瓶颈可能是"></a>Redis瓶颈可能是</h2><pre><code>机器内存或者网络带宽</code></pre><h2 id="其他开源软件采用的模型"><a href="#其他开源软件采用的模型" class="headerlink" title="其他开源软件采用的模型"></a>其他开源软件采用的模型</h2><pre><code>Nginx：多进程单线程模型Memcached：单进程多线程模型</code></pre><h2 id="使用Redis的优势？"><a href="#使用Redis的优势？" class="headerlink" title="使用Redis的优势？"></a>使用Redis的优势？</h2><pre><code>1.速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)2. 支持丰富数据类型，支持string，list，set，sorted set，hash3.支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行4. 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</code></pre><h2 id="Redis集群方案应该怎么做？都有哪些方案？"><a href="#Redis集群方案应该怎么做？都有哪些方案？" class="headerlink" title="Redis集群方案应该怎么做？都有哪些方案？"></a>Redis集群方案应该怎么做？都有哪些方案？</h2><pre><code>1.twemproxy2.codis，目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。3.Redis cluster3.0自带的集，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。</code></pre><h2 id="Redis读写分离模型"><a href="#Redis读写分离模型" class="headerlink" title="Redis读写分离模型"></a>Redis读写分离模型</h2><pre><code>通过增加Slave DB的数量，读的性能可以线性增长。为了避免Master DB的单点故障，集群一般都会采用两台Master DB做双机热备，所以整个集群的读和写的可用性都非常高。读写分离架构的缺陷在于，不管是Master还是Slave，每个节点都必须保存完整的数据，如果在数据量很大的情况下，集群的扩展能力还是受限于单个节点的存储能力，而且对于Write-intensive类型的应用，读写分离架构并不适合。</code></pre><h2 id="Redis数据分片模型"><a href="#Redis数据分片模型" class="headerlink" title="Redis数据分片模型"></a>Redis数据分片模型</h2><pre><code>为了解决读写分离模型的缺陷，可以将数据分片模型应用进来。可以将每个节点看成都是独立的master，然后通过业务实现数据分片。结合上面两种模型，可以将每个master设计成由一个master和多个slave组成的模型。</code></pre><h2 id="Redis支持的Java客户端都有哪些？官方推荐用哪个？"><a href="#Redis支持的Java客户端都有哪些？官方推荐用哪个？" class="headerlink" title="Redis支持的Java客户端都有哪些？官方推荐用哪个？"></a>Redis支持的Java客户端都有哪些？官方推荐用哪个？</h2><pre><code>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</code></pre><h2 id="Redis集群的主从复制模型是怎样的？"><a href="#Redis集群的主从复制模型是怎样的？" class="headerlink" title="Redis集群的主从复制模型是怎样的？"></a>Redis集群的主从复制模型是怎样的？</h2><pre><code>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.</code></pre><h2 id="Redis集群会有写操作丢失吗？为什么？"><a href="#Redis集群会有写操作丢失吗？为什么？" class="headerlink" title="Redis集群会有写操作丢失吗？为什么？"></a>Redis集群会有写操作丢失吗？为什么？</h2><pre><code>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</code></pre><h2 id="Redis集群之间是如何复制的？"><a href="#Redis集群之间是如何复制的？" class="headerlink" title="Redis集群之间是如何复制的？"></a>Redis集群之间是如何复制的？</h2><pre><code>异步复制</code></pre><h2 id="Redis如何做内存优化？"><a href="#Redis如何做内存优化？" class="headerlink" title="Redis如何做内存优化？"></a>Redis如何做内存优化？</h2><pre><code>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面.</code></pre><h2 id="Redis回收进程如何工作的？"><a href="#Redis回收进程如何工作的？" class="headerlink" title="Redis回收进程如何工作的？"></a>Redis回收进程如何工作的？</h2><pre><code>一个客户端运行了新的命令，添加了新的数据。Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。</code></pre><h2 id="Redis回收使用的是什么算法？"><a href="#Redis回收使用的是什么算法？" class="headerlink" title="Redis回收使用的是什么算法？"></a>Redis回收使用的是什么算法？</h2><pre><code>LRU算法</code></pre><h2 id="Redis有哪些适合的场景？"><a href="#Redis有哪些适合的场景？" class="headerlink" title="Redis有哪些适合的场景？"></a>Redis有哪些适合的场景？</h2><pre><code>1）Session共享(单点登录)2）页面缓存3）队列4）排行榜/计数器5）发布/订阅</code></pre><h2 id="Redis持久化数据和缓存怎么做扩容？"><a href="#Redis持久化数据和缓存怎么做扩容？" class="headerlink" title="Redis持久化数据和缓存怎么做扩容？"></a>Redis持久化数据和缓存怎么做扩容？</h2><pre><code>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。如果Redis被当做一个持久化存储使用    必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。    否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</code></pre><h2 id="Redis事务相关的命令有哪几个？"><a href="#Redis事务相关的命令有哪几个？" class="headerlink" title="Redis事务相关的命令有哪几个？"></a>Redis事务相关的命令有哪几个？</h2><pre><code>MULTI、EXEC、DISCARD、WATCH</code></pre><h2 id="Redis-key的过期时间和永久有效分别怎么设置？"><a href="#Redis-key的过期时间和永久有效分别怎么设置？" class="headerlink" title="Redis key的过期时间和永久有效分别怎么设置？"></a>Redis key的过期时间和永久有效分别怎么设置？</h2><pre><code>EXPIRE和PERSIST命令。</code></pre><h2 id="Redis如何做大量数据插入？"><a href="#Redis如何做大量数据插入？" class="headerlink" title="Redis如何做大量数据插入？"></a>Redis如何做大量数据插入？</h2><pre><code>Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。</code></pre><h2 id="Redis和Redisson有什么关系？"><a href="#Redis和Redisson有什么关系？" class="headerlink" title="Redis和Redisson有什么关系？"></a>Redis和Redisson有什么关系？</h2><pre><code>Redisson是一个高级的分布式协调Redis客服端能帮助用户在分布式环境中轻松实现一些Java的对象     (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</code></pre><h2 id="Jedis与Redisson对比有什么优缺点？"><a href="#Jedis与Redisson对比有什么优缺点？" class="headerlink" title="Jedis与Redisson对比有什么优缺点？"></a>Jedis与Redisson对比有什么优缺点？</h2><pre><code>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</code></pre><h2 id="为什么要用-Redis-而不用-map-guava-做缓存"><a href="#为什么要用-Redis-而不用-map-guava-做缓存" class="headerlink" title="为什么要用 Redis 而不用 map/guava 做缓存?"></a>为什么要用 Redis 而不用 map/guava 做缓存?</h2><pre><code>缓存分为本地缓存和分布式缓存使用自带的 map 或者 guava 实现的是本地缓存，    特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，    并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。使用 redis 或 memcached 之类的称为分布式缓存，    在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。    缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。</code></pre><h2 id="你知道有哪些Redis分区实现方案？"><a href="#你知道有哪些Redis分区实现方案？" class="headerlink" title="你知道有哪些Redis分区实现方案？"></a>你知道有哪些Redis分区实现方案？</h2><pre><code>客户端分区    在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。代理分区    意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。    代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。    redis和memcached的一种代理实现就是Twemproxy查询路由(Query routing)    客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点    Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。</code></pre><h2 id="Redis分区有什么缺点"><a href="#Redis分区有什么缺点" class="headerlink" title="Redis分区有什么缺点"></a>Redis分区有什么缺点</h2><pre><code>涉及多个key的操作通常不会被支持。同时操作多个key,则不能使用Redis事务分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件。分区时动态扩容或缩容可能非常复杂。</code></pre><h2 id="什么是-RedLock"><a href="#什么是-RedLock" class="headerlink" title="什么是 RedLock"></a>什么是 RedLock</h2><pre><code>Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 Redlock，此种方式比原先的单节点的方法更安全安全特性：互斥访问，即永远只有一个 client 能拿到锁避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区容错性：只要大部分 Redis 节点存活就可以正常提供服务</code></pre><h2 id="布隆过滤器？"><a href="#布隆过滤器？" class="headerlink" title="布隆过滤器？"></a>布隆过滤器？</h2><pre><code>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力Bitmap：典型的就是哈希表    缺点是，Bitmap对于每个元素只能记录1bit信息它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;双写一致问题&quot;&gt;&lt;a href=&quot;#双写一致问题&quot; class=&quot;headerlink&quot; title=&quot;双写一致问题&quot;&gt;&lt;/a&gt;双写一致问题&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;非原子操作，多线程一定会发生
解决方案：延时双删策略
    先删Redis，再删数据库，再
      
    
    </summary>
    
    
      <category term="面试" scheme="http://iwantjingjing.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试，redis" scheme="http://iwantjingjing.com/tags/%E9%9D%A2%E8%AF%95%EF%BC%8Credis/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="http://iwantjingjing.com/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://iwantjingjing.com/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2020-04-12T05:40:05.000Z</published>
    <updated>2020-04-12T05:46:10.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="1数据结构"><a href="#1数据结构" class="headerlink" title="1数据结构"></a>1数据结构</h2><h3 id="1线性表"><a href="#1线性表" class="headerlink" title="1线性表"></a>1线性表</h3><pre><code>1数组2链表    1单链表    2双向链表    3循环链表    4双向循环链表    5静态链表3栈    1顺序栈    2链式栈4队列    1普通队列    2双端队列    3阻塞队列    4并发队列    5并发阻塞队列</code></pre><h3 id="2散列表"><a href="#2散列表" class="headerlink" title="2散列表"></a>2散列表</h3><pre><code>1散列函数2解决冲突    1链表法    2开发寻址法3动态扩容4位图</code></pre><h3 id="3树"><a href="#3树" class="headerlink" title="3树"></a>3树</h3><pre><code>1二叉树    1平衡二叉树    2二叉查找树    3平衡二叉查找树            1AVL树            2红黑树    4完全二叉树    5满二叉树2多路查找树    1B树    2B+树    3：2-3树    4：2-3-4树3堆    1小顶堆    2大顶堆    3优先级队列    4斐波那契堆    5二项堆4其他    1树状数组    2线段树</code></pre><h3 id="4图"><a href="#4图" class="headerlink" title="4图"></a>4图</h3><pre><code>1图的存储    1邻接矩阵    2邻接表2拓扑排序3最短路径4最小生成树5二分图6最大流</code></pre><h2 id="2算法"><a href="#2算法" class="headerlink" title="2算法"></a>2算法</h2><h3 id="1复杂度分析"><a href="#1复杂度分析" class="headerlink" title="1复杂度分析"></a>1复杂度分析</h3><pre><code>1空间复杂度2时间复杂度    1最好    2最坏    3平均    4分摊</code></pre><h3 id="2算法思想"><a href="#2算法思想" class="headerlink" title="2算法思想"></a>2算法思想</h3><pre><code>1贪心算法2分治算法3动态规划4回溯算法5枚举算法</code></pre><h3 id="3排序"><a href="#3排序" class="headerlink" title="3排序"></a>3排序</h3><pre><code>O(n^2)    1冒泡排序    2插入排序    3选择排序    4希尔排序O(nlogn)    1并归排序    2堆排序    3快速排序O(n)    1计数排序    2基数排序    3桶排序</code></pre><h3 id="4搜索"><a href="#4搜索" class="headerlink" title="4搜索"></a>4搜索</h3><pre><code>1深度优先2广度优先3A*启发式</code></pre><h3 id="5查找"><a href="#5查找" class="headerlink" title="5查找"></a>5查找</h3><pre><code>1线性查找2树查找3散列查找</code></pre><h3 id="6字符串匹配"><a href="#6字符串匹配" class="headerlink" title="6字符串匹配"></a>6字符串匹配</h3><pre><code>1朴素2KMP3Robin-Karp4Boyer-Moore5AC自动机6Tire7后缀数组</code></pre><h3 id="7其他"><a href="#7其他" class="headerlink" title="7其他"></a>7其他</h3><pre><code>1数论2计算几何3概率分析4并查集5拓扑网络6矩阵运算7线性规划</code></pre><h1 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h1><p><img src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.png" alt="">    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构与算法&quot;&gt;&lt;a href=&quot;#数据结构与算法&quot; class=&quot;headerlink&quot; title=&quot;数据结构与算法&quot;&gt;&lt;/a&gt;数据结构与算法&lt;/h1&gt;&lt;h2 id=&quot;1数据结构&quot;&gt;&lt;a href=&quot;#1数据结构&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="脑图" scheme="http://iwantjingjing.com/categories/%E8%84%91%E5%9B%BE/"/>
    
    
      <category term="数据结构，算法，脑图" scheme="http://iwantjingjing.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E7%AE%97%E6%B3%95%EF%BC%8C%E8%84%91%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>后端架构图</title>
    <link href="http://iwantjingjing.com/2020/04/11/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%9B%BE/"/>
    <id>http://iwantjingjing.com/2020/04/11/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%9B%BE/</id>
    <published>2020-04-11T02:23:11.000Z</published>
    <updated>2020-04-11T02:38:33.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="后端架构"><a href="#后端架构" class="headerlink" title="后端架构"></a>后端架构</h1><h2 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h2><pre><code>多线程队列高性能网络层插件压缩加密反射调度特性扩张方法表达式树</code></pre><h2 id="基础监控"><a href="#基础监控" class="headerlink" title="基础监控"></a>基础监控</h2><h3 id="业务监控"><a href="#业务监控" class="headerlink" title="业务监控"></a>业务监控</h3><pre><code>业务操作完成量业务操作完成时间</code></pre><h3 id="用户行为"><a href="#用户行为" class="headerlink" title="用户行为"></a>用户行为</h3><pre><code>访问人数、在线人数访问热点访问轨迹</code></pre><h3 id="软件应用监控"><a href="#软件应用监控" class="headerlink" title="软件应用监控"></a>软件应用监控</h3><pre><code>执行性能，性能趋势报表图    页面级别    方法级别    数据库操作可用性服务、页面使用量开源组件性能监视</code></pre><h3 id="软件系统监控"><a href="#软件系统监控" class="headerlink" title="软件系统监控"></a>软件系统监控</h3><pre><code>磁盘内存CPU网络</code></pre><h3 id="硬件监控"><a href="#硬件监控" class="headerlink" title="硬件监控"></a>硬件监控</h3><pre><code>硬件资源的消耗趋势（容量规划）硬件资源的使用趋势（细化到进程）硬件资源的总体利用率</code></pre><h3 id="通用报警"><a href="#通用报警" class="headerlink" title="通用报警"></a>通用报警</h3><pre><code>基于统计值基于状态事件处理流程短信群发平台集中化配置邮件、短信通道跨平台的客户端分组+权限+自定义间隔信息模板细节报警信息</code></pre><h2 id="页面引擎"><a href="#页面引擎" class="headerlink" title="页面引擎"></a>页面引擎</h2><h3 id="MVC扩展"><a href="#MVC扩展" class="headerlink" title="MVC扩展"></a>MVC扩展</h3><pre><code>基础横切组件封装（ActionFilter等）模板集中存储+后台修改IOC支持执行性能组件全局注册</code></pre><h3 id="轻量级的ashx容器"><a href="#轻量级的ashx容器" class="headerlink" title="轻量级的ashx容器"></a>轻量级的ashx容器</h3><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><pre><code>脚本样式合并分布式会话验证码各种控件</code></pre><h2 id="横切关注"><a href="#横切关注" class="headerlink" title="横切关注"></a>横切关注</h2><h3 id="日志、异常、状态信息"><a href="#日志、异常、状态信息" class="headerlink" title="日志、异常、状态信息"></a>日志、异常、状态信息</h3><pre><code>集中收集    MongoDB后台集中查阅自动附加信息异步队列提交</code></pre><h3 id="通用性能"><a href="#通用性能" class="headerlink" title="通用性能"></a>通用性能</h3><pre><code>只要提供Dictionary&lt;string.long&gt;数据源就可以实现性能监控多级分组通用性能查看后台（highchart+ajax)支持各个粒度的数据聚合数据类型支持TextValue、TotalValue、StateValue、ExpressionValue数据源支持推模式和拉模式</code></pre><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><pre><code>本地缓存远端缓存    基于Redis各种过期模式    平滑过期    绝对时间过期    依赖过期过期回调容量限制</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><pre><code>配置集中化（消除本地配置）支持横向扩容（同步）支持复杂类型（自定义类型）    列表    字典    枚举    继承    抽象类配置后台（考虑多环境同步问题)    考虑实现配置实用率跟踪自动根据默认值初始化    考虑默认值的使用策略全局配配置和私有配置，支持分组更新回调    考虑细化到某个点基于行的版本（同步）控制高性能    缓存+数据库</code></pre><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><pre><code>任意数据的同步支持水平扩容支持拉模式和推模式支持</code></pre><h3 id="NOSQL客户端"><a href="#NOSQL客户端" class="headerlink" title="NOSQL客户端"></a>NOSQL客户端</h3><pre><code>配置集中统一的客户端集群管理</code></pre><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h2 id="分布式数据访问"><a href="#分布式数据访问" class="headerlink" title="分布式数据访问"></a>分布式数据访问</h2><h3 id="ORM特性"><a href="#ORM特性" class="headerlink" title="ORM特性"></a>ORM特性</h3><pre><code>查询表达器缓存（多级）关系延迟加载映射配置代码生成多数据库支持锁支持枚举支持</code></pre><h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><pre><code>监控性能NOSQL集成领域驱动支持</code></pre><h3 id="Shard特性"><a href="#Shard特性" class="headerlink" title="Shard特性"></a>Shard特性</h3><pre><code>分库规则和路由分表规则和路由集群    高可用负载均衡策略    软负载可用性探测读写分离    高性能分布式事物多写迁移辅助基于元数据还是映射的策略跨节点排序分页支持</code></pre><h2 id="服务端组件"><a href="#服务端组件" class="headerlink" title="服务端组件"></a>服务端组件</h2><p>  分布式文件系统<br>  分布式缓存系统<br>  分布式计算<br>  分布式存储系统<br>  分布式队列系统<br>  分布式计数器<br>  分布式锁</p><h2 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h2><h3 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h3><pre><code>同步调用异步调用双向调用    事件回调（软）负载均衡    随机、轮训、最小调用高级QoS均衡    根据性能决定均衡策略失败容错    重试、日志、后台容错调用拦截    增加横切平滑重启优雅升降级分布式事务批量调用    提高性能本地伪装    本地Mock逻辑用于容错隐式传参    客户端和服务端同步上下文服务分组    允许一个接口多种实现客户端代理生成插件    异步调用</code></pre><h3 id="协议集成"><a href="#协议集成" class="headerlink" title="协议集成"></a>协议集成</h3><pre><code>HessionWebServiceProtobuf自定义二进制序列化</code></pre><h3 id="集群监控"><a href="#集群监控" class="headerlink" title="集群监控"></a>集群监控</h3><pre><code>可用性性能版本路径依赖</code></pre><h3 id="动态部署"><a href="#动态部署" class="headerlink" title="动态部署"></a>动态部署</h3><pre><code>服务容器    守护、更新自动部署平滑回滚</code></pre><h3 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h3><pre><code>服务注册发现服务测试服务路由    机房感知、机器、上下文服务安全限制    调用验证    信息加密服务依赖关系服务负责人    信息通知服务文档服务声明周期服务命名空间服务限流    并发、流程</code></pre><h1 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h1><p><img src="%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84.png" alt="">        </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;后端架构&quot;&gt;&lt;a href=&quot;#后端架构&quot; class=&quot;headerlink&quot; title=&quot;后端架构&quot;&gt;&lt;/a&gt;后端架构&lt;/h1&gt;&lt;h2 id=&quot;基础组件&quot;&gt;&lt;a href=&quot;#基础组件&quot; class=&quot;headerlink&quot; title=&quot;基础组件&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="架构" scheme="http://iwantjingjing.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://iwantjingjing.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="脑图" scheme="http://iwantjingjing.com/tags/%E8%84%91%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架</title>
    <link href="http://iwantjingjing.com/2020/04/11/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>http://iwantjingjing.com/2020/04/11/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</id>
    <published>2020-04-11T00:26:51.000Z</published>
    <updated>2020-04-11T00:35:42.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h1><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><pre><code>ArrayList    排列有序，可重复    底层使用数组    速度快，增删慢，getter()和setter()快    线程不安全    当容量不够，ArrayList是当前容量*1.5+1Vector    排列有序，可重复    底层使用数组    速度快，增删慢    线程安全，效率低    当容量不够，默认扩张一倍容量LinkedList    排列有序，可重复    底层使用双向循环链表数据结构    查询速度慢，增删快，add（）和remove（）方法快    线程不安全</code></pre><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><pre><code>HashSet    排列无序，不可重复    底层使用hash表实现    存取速度快    内部是HashMapTreeSet    排列无序，不可重复    底层使用二叉树实现    排序存储    内部是TreeMap的SortedSetLinkedHashSet    采用Hash表存储，并用双向链表记录插入顺序    内部是LinkedHashMap</code></pre><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><pre><code>在两端出入的List，所以也可以用数组或链表来实现</code></pre><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><pre><code>键不可重复，值可重复底层hash表线程不安全允许key值为null，值为null</code></pre><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><pre><code>键不可重复，值可重复底层Hash表线程安全键和值都不可为null</code></pre><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><pre><code>键不可重复，值可重复底层二叉树</code></pre><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java集合框架&quot;&gt;&lt;a href=&quot;#Java集合框架&quot; class=&quot;headerlink&quot; title=&quot;Java集合框架&quot;&gt;&lt;/a&gt;Java集合框架&lt;/h1&gt;&lt;h2 id=&quot;Collection&quot;&gt;&lt;a href=&quot;#Collection&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="java" scheme="http://iwantjingjing.com/categories/java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="集合，面试" scheme="http://iwantjingjing.com/tags/%E9%9B%86%E5%90%88%EF%BC%8C%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring常见问题总结</title>
    <link href="http://iwantjingjing.com/2020/04/10/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://iwantjingjing.com/2020/04/10/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2020-04-10T08:07:49.000Z</published>
    <updated>2020-04-10T09:56:57.267Z</updated>
    
    <content type="html"><![CDATA[<p>Spring常见问题总结</p><p><a href="https://mp.weixin.qq.com/s/wcK2qsZxKDJTLIGqEIyaNg" target="_blank" rel="noopener">引用自</a></p><h1 id="1-什么是-Spring-框架"><a href="#1-什么是-Spring-框架" class="headerlink" title="1 什么是 Spring 框架?"></a>1 什么是 Spring 框架?</h1><p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。</p><h1 id="2-Spring-官网列出的-Spring-的-6-个特征"><a href="#2-Spring-官网列出的-Spring-的-6-个特征" class="headerlink" title="2 Spring 官网列出的 Spring 的 6 个特征:"></a>2 Spring 官网列出的 Spring 的 6 个特征:</h1><p>  核心技术 ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。<br>  测试 ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。<br>  数据访问 ：事务，DAO支持，JDBC，ORM，编组XML。<br>  Web支持 : Spring MVC和Spring WebFlux Web框架。<br>  集成 ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。<br>  语言 ：Kotlin，Groovy，动态语言。</p><h1 id="3-列举一些重要的Spring模块？"><a href="#3-列举一些重要的Spring模块？" class="headerlink" title="3 列举一些重要的Spring模块？"></a>3 列举一些重要的Spring模块？</h1><p>  Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。<br>  Spring Aspects ：该模块为与AspectJ的集成提供支持。<br>  Spring AOP ：提供了面向切面的编程实现。<br>  Spring JDBC : Java数据库连接。<br>  Spring JMS ：Java消息服务。<br>  Spring ORM : 用于支持Hibernate等ORM工具。<br>  Spring Web : 为创建Web应用程序提供支持。<br>  Spring Test : 提供了对 JUnit 和 TestNG 测试的支持。</p><h1 id="4-RestController-vs-Controller"><a href="#4-RestController-vs-Controller" class="headerlink" title="4 @RestController vs @Controller"></a>4 @RestController vs @Controller</h1><p>  Controller 返回一个页面<br>    对应于前后端不分离的情况。<br>    如果你需要在Spring4之前开发 RESTful Web服务的话，你需要使用@Controller 并结合@ResponseBody注解，也就是说@Controller +@ResponseBody= @RestController（Spring 4 之后新加的注解）。<br>  @RestController 返回JSON 或 XML 形式数据<br>    前后端分离</p><h1 id="5-谈谈自己对于-Spring-IoC-和-AOP-的理解"><a href="#5-谈谈自己对于-Spring-IoC-和-AOP-的理解" class="headerlink" title="5 谈谈自己对于 Spring IoC 和 AOP 的理解"></a>5 谈谈自己对于 Spring IoC 和 AOP 的理解</h1><p>  IoC（Inverse of Control:控制反转）是一种设计思想<br>  将原本在程序中手动创建对象的控制权，交由Spring框架来管理<br>  IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。<br>   IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。<br>  AOP(Aspect-Oriented Programming:面向切面编程<br>  事务处理、日志管理、权限控制<br>  减少系统的重复代码，降低模块间的耦合度<br>  Spring AOP就是基于动态代理的<br>    如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib ，这时候Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理</p><h1 id="6-Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#6-Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="6 Spring AOP 和 AspectJ AOP 有什么区别？"></a>6 Spring AOP 和 AspectJ AOP 有什么区别？</h1><p>  Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。<br>  Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。<br>  Spring AOP 已经集成了 AspectJ<br>  AspectJ 相比于 Spring AOP 功能更加强大<br>  Spring AOP 相对来说更简单，<br>  切面比较少，那么两者性能差异不大<br>  当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p><h1 id="7-Spring-中的-bean-的作用域有哪些"><a href="#7-Spring-中的-bean-的作用域有哪些" class="headerlink" title="7 Spring 中的 bean 的作用域有哪些?"></a>7 Spring 中的 bean 的作用域有哪些?</h1><p>  singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。<br>  prototype : 每次请求都会创建一个新的 bean 实例。<br>  request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。<br>  session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。<br>  global-session：全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</p><h1 id="8-Spring-中的单例-bean-的线程安全问题了解吗？"><a href="#8-Spring-中的单例-bean-的线程安全问题了解吗？" class="headerlink" title="8 Spring 中的单例 bean 的线程安全问题了解吗？"></a>8 Spring 中的单例 bean 的线程安全问题了解吗？</h1><p>  当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题<br>  在Bean对象中尽量避免定义可变的成员变量（不太现实）。<br>  在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</p><h1 id="9-Spring-中的-bean-生命周期"><a href="#9-Spring-中的-bean-生命周期" class="headerlink" title="9 Spring 中的 bean 生命周期?"></a>9 Spring 中的 bean 生命周期?</h1><p>  Bean 容器找到配置文件中 Spring Bean 的定义。<br>  Bean 容器利用 Java Reflection API 创建一个Bean的实例。<br>  如果涉及到一些属性值 利用 set()方法设置一些属性值。<br>  如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入Bean的名字。<br>  如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。<br>  如果Bean实现了 BeanFactoryAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoade r对象的实例。<br>  与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。<br>  如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法<br>  如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。<br>  如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。<br>  如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法<br>  当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。<br>  当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</p><h1 id="10-说说自己对于-Spring-MVC-了解"><a href="#10-说说自己对于-Spring-MVC-了解" class="headerlink" title="10 说说自己对于 Spring MVC 了解?"></a>10 说说自己对于 Spring MVC 了解?</h1><p>  Model1 时代<br>    整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作<br>    ①将控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；<br>    ②前端和后端相互依赖，难以进行测试并且开发效率极低；<br>  Model2 时代即JavaWeb MVC<br>    “Java Bean(Model)+ JSP（View,）+Servlet（Controller）<br>    重复造轮子<br>    应运而生比如Struts2但是 Struts2 比较笨重<br>    Spring MVC 使用更加简单和方便<br>    开发效率更高，并且 Spring MVC 运行速度更快。<br>  SpringMVC 工作原理</p><p>  流程说明（重要）：<br>    1：客户端（浏览器）发送请求，直接请求到 DispatcherServlet。<br>    2： DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。<br>    3： 解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。<br>    4：HandlerAdapter 会根据 Handler来调用真正的处理器开处理请求，并处理相应的业务逻辑。<br>    5： 处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。<br>    6： ViewResolver 会根据逻辑 View 查找实际的 View。<br>    7：DispaterServlet 把返回的 Model 传给 View（视图渲染）。<br>    8：把 View 返回给请求者（浏览器）</p><h1 id="11-Spring-框架中用到了哪些设计模式？"><a href="#11-Spring-框架中用到了哪些设计模式？" class="headerlink" title="11 Spring 框架中用到了哪些设计模式？"></a>11 Spring 框架中用到了哪些设计模式？</h1><p>  工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。<br>  代理设计模式 : Spring AOP 功能的实现。<br>  单例设计模式 : Spring 中的 Bean 默认都是单例的。<br>  模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。<br>  包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。<br>  观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。<br>  适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。</p><h1 id="12-Component-和-Bean-的区别是什么？"><a href="#12-Component-和-Bean-的区别是什么？" class="headerlink" title="12 @Component 和 @Bean 的区别是什么？"></a>12 @Component 和 @Bean 的区别是什么？</h1><p>  作用对象不同: @Component 注解作用于类，而@Bean注解作用于方法。<br>  @Component通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了Spring这是某个类的示例，当我需要用它的时候还给我。<br>  @Bean 注解比 Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。</p><h1 id="13-将一个类声明为Spring的-bean-的注解有哪些"><a href="#13-将一个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="13 将一个类声明为Spring的 bean 的注解有哪些?"></a>13 将一个类声明为Spring的 bean 的注解有哪些?</h1><p>  使用 @Autowired 注解自动装配 bean<br>  @Component ：通用的注解，可标注任意类为 Spring 组件。如果一个Bean不知道属于哪个层，可以使用@Component 注解标注。<br>  @Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。<br>  @Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。<br>  @Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</p><h1 id="14-Spring-管理事务的方式有几种？"><a href="#14-Spring-管理事务的方式有几种？" class="headerlink" title="14 Spring 管理事务的方式有几种？"></a>14 Spring 管理事务的方式有几种？</h1><p>  编程式事务，在代码中硬编码。(不推荐使用)<br>  声明式事务，在配置文件中配置（推荐使用）<br>    基于XML的声明式事务<br>    基于注解的声明式事务</p><h1 id="15-Spring-事务中的隔离级别有哪几种"><a href="#15-Spring-事务中的隔离级别有哪几种" class="headerlink" title="15 Spring 事务中的隔离级别有哪几种?"></a>15 Spring 事务中的隔离级别有哪几种?</h1><p>  TransactionDefinition.ISOLATION_DEFAULT<br>    使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.<br>  TransactionDefinition.ISOLATION_READ_UNCOMMITTED<br>    最低的隔离级别，允许读取尚未提交的数据变更<br>    可能会导致脏读、幻读或不可重复读<br>  TransactionDefinition.ISOLATION_READ_COMMITTED<br>    允许读取并发事务已经提交的数据<br>    可以阻止脏读，但是幻读或不可重复读仍有可能发生<br>  TransactionDefinition.ISOLATION_REPEATABLE_READ<br>    对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改<br>    可以阻止脏读和不可重复读，但幻读仍有可能发生。<br>  TransactionDefinition.ISOLATION_SERIALIZABLE<br>    最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，<br>    该级别可以防止脏读、不可重复读以及幻读<br>    严重影响程序的性能。通常情况下也不会用到该级别。</p><h1 id="16-Spring-事务中哪几种事务传播行为"><a href="#16-Spring-事务中哪几种事务传播行为" class="headerlink" title="16 Spring 事务中哪几种事务传播行为?"></a>16 Spring 事务中哪几种事务传播行为?</h1><p>  支持当前事务的情况：<br>    TransactionDefinition.PROPAGATION_REQUIRED<br>        如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。<br>    TransactionDefinition.PROPAGATION_SUPPORTS<br>        如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。<br>    TransactionDefinition.PROPAGATION_MANDATORY<br>        如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）<br>  不支持当前事务的情况：<br>    TransactionDefinition.PROPAGATION_REQUIRES_NEW<br>        创建一个新的事务，如果当前存在事务，则把当前事务挂起。<br>    TransactionDefinition.PROPAGATION_NOT_SUPPORTED<br>         以非事务方式运行，如果当前存在事务，则把当前事务挂起。<br>    TransactionDefinition.PROPAGATION_NEVER<br>        以非事务方式运行，如果当前存在事务，则抛出异常。<br>  其他情况：<br>    TransactionDefinition.PROPAGATION_NESTED<br>        如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</p><h1 id="17-Transactional-rollbackFor-Exception-class-注解了解吗？"><a href="#17-Transactional-rollbackFor-Exception-class-注解了解吗？" class="headerlink" title="17 @Transactional(rollbackFor = Exception.class)注解了解吗？"></a>17 @Transactional(rollbackFor = Exception.class)注解了解吗？</h1><p>  Exception分为运行时异常RuntimeException和非运行时异常<br>  Transactional<br>    如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚<br>    不配置rollbackFor属性，事物只会在遇到RuntimeException的时候才会回滚<br>    加上rollbackFor=Exception.class,可以让事物在遇到非运行时异常时也回滚。</p><h1 id="18-如何使用JPA在数据库中非持久化一个字段？"><a href="#18-如何使用JPA在数据库中非持久化一个字段？" class="headerlink" title="18 如何使用JPA在数据库中非持久化一个字段？"></a>18 如何使用JPA在数据库中非持久化一个字段？</h1><p>  static 修饰<br>  final 修饰<br>  transient 修饰<br>  @Transient 注解修饰</p><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.png" alt="">  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring常见问题总结&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/wcK2qsZxKDJTLIGqEIyaNg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;引用自&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-什么是-
      
    
    </summary>
    
    
      <category term="面试" scheme="http://iwantjingjing.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="面试" scheme="http://iwantjingjing.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Spring" scheme="http://iwantjingjing.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>精细阅读的杀手锏——SQ3R阅读法</title>
    <link href="http://iwantjingjing.com/2020/04/10/%E7%B2%BE%E7%BB%86%E9%98%85%E8%AF%BB%E7%9A%84%E6%9D%80%E6%89%8B%E9%94%8F%E2%80%94%E2%80%94SQ3R%E9%98%85%E8%AF%BB%E6%B3%95/"/>
    <id>http://iwantjingjing.com/2020/04/10/%E7%B2%BE%E7%BB%86%E9%98%85%E8%AF%BB%E7%9A%84%E6%9D%80%E6%89%8B%E9%94%8F%E2%80%94%E2%80%94SQ3R%E9%98%85%E8%AF%BB%E6%B3%95/</id>
    <published>2020-04-10T06:19:39.000Z</published>
    <updated>2020-04-10T06:47:55.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-什么是SQ3R阅读法"><a href="#一-什么是SQ3R阅读法" class="headerlink" title="一. 什么是SQ3R阅读法"></a>一. 什么是SQ3R阅读法</h1><p>  美国俄亥俄州州立大学心理学教授罗宾逊（F. P. Robinson）<br>  1946年在他的著作Effective Study有所提及<br>  综览（Survey）、发问（Question）、阅读（Read）、背诵（Recite）、复习（Review）</p><h1 id="二-SQ3R阅读法的具体实施步骤"><a href="#二-SQ3R阅读法的具体实施步骤" class="headerlink" title="二. SQ3R阅读法的具体实施步骤"></a>二. SQ3R阅读法的具体实施步骤</h1><h2 id="1-Survey阶段"><a href="#1-Survey阶段" class="headerlink" title="1. Survey阶段"></a>1. Survey阶段</h2><ul><li>封面、扉页、前言</li><li>目录</li><li>各级标题</li><li>开头和结尾</li></ul><h2 id="2-Question阶段"><a href="#2-Question阶段" class="headerlink" title="2. Question阶段"></a>2. Question阶段</h2><ul><li>这本书/这篇文章主要说的什么</li><li>掌握了多少？</li><li>提问贯穿于整个阅读过程</li><li>只要有问题，你都可以用笔或借助电子设备将问题记录下来。</li><li>布朗和基利的《学会提问》</li></ul><h2 id="3-Read阶段"><a href="#3-Read阶段" class="headerlink" title="3.Read阶段"></a>3.Read阶段</h2><pre><code>加粗字段、重点图标阅读难度较高的篇章时要放慢速度。遇到不明白的地方，要停下来，再重读一遍。一次只阅读一小段并背诵那一段。阅读辅助说明的图象。          ——Study Guides and Strategies 博客网站</code></pre><h2 id="4-Recite阶段"><a href="#4-Recite阶段" class="headerlink" title="4. Recite阶段"></a>4. Recite阶段</h2><pre><code>非背诵，而是复述，尽可能多和详细听、说、读、写联想记忆法关键词记忆法谐音等记忆法</code></pre><h2 id="5-Review阶段"><a href="#5-Review阶段" class="headerlink" title="5.  Review阶段"></a>5.  Review阶段</h2><ol><li>Recite后半天Review一次；</li><li>一天后再Review一次；</li><li>三天后再Review一次；</li><li>一个星期后再Review一次；</li><li>一个月后再简单地Review一次。</li></ol><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="%E7%B2%BE%E7%BB%86%E9%98%85%E8%AF%BB%E7%9A%84%E6%9D%80%E6%89%8B%E9%94%8F%E2%80%94%E2%80%94SQ3R.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-什么是SQ3R阅读法&quot;&gt;&lt;a href=&quot;#一-什么是SQ3R阅读法&quot; class=&quot;headerlink&quot; title=&quot;一. 什么是SQ3R阅读法&quot;&gt;&lt;/a&gt;一. 什么是SQ3R阅读法&lt;/h1&gt;&lt;p&gt;  美国俄亥俄州州立大学心理学教授罗宾逊（F. P. R
      
    
    </summary>
    
    
    
      <category term="学习方法" scheme="http://iwantjingjing.com/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>运动改造大脑</title>
    <link href="http://iwantjingjing.com/2020/04/07/%E8%BF%90%E5%8A%A8%E6%94%B9%E9%80%A0%E5%A4%A7%E8%84%91/"/>
    <id>http://iwantjingjing.com/2020/04/07/%E8%BF%90%E5%8A%A8%E6%94%B9%E9%80%A0%E5%A4%A7%E8%84%91/</id>
    <published>2020-04-07T08:02:04.000Z</published>
    <updated>2020-04-07T08:04:51.115Z</updated>
    
    <content type="html"><![CDATA[<p><img src="yundong.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;yundong.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="读后感" scheme="http://iwantjingjing.com/categories/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    
      <category term="运动，读后感" scheme="http://iwantjingjing.com/tags/%E8%BF%90%E5%8A%A8%EF%BC%8C%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Java多线程</title>
    <link href="http://iwantjingjing.com/2020/04/03/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJava%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://iwantjingjing.com/2020/04/03/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJava%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-04-03T11:46:41.000Z</published>
    <updated>2020-04-04T05:00:51.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="进程与线程的基本概念"><a href="#进程与线程的基本概念" class="headerlink" title="进程与线程的基本概念"></a>进程与线程的基本概念</h2><h3 id="进程产生的背景"><a href="#进程产生的背景" class="headerlink" title="进程产生的背景"></a>进程产生的背景</h3><p>指令—》指令集（批处理） </p><p>缺点：串行，效率低</p><p><strong>进程：</strong> 应用程序在内存中分配的空间，正在运行的程序。</p><p> 进程优点： 操作系统并发成为可能。</p><p><strong>线程:</strong> 一个线程执行一个子任务，一个进程包含多个线程。</p><p>优点：让进程的内部并发成为了可能。 </p><p> <strong>多进程的方式也可以实现并发，为什么我们要使用多线程？</strong></p><ul><li>进程通信复杂，线程间可共享资源，通信较线程容易;</li><li>进程重量级，线程轻量级，系统开销小。</li></ul><p><strong>进程线程的区别？</strong></p><ul><li>本质区别：能否单独占有内存空间及其他系统资源（如：I/O);</li><li>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行系统调度的基本单位，即CPU时间的分配单位。</li></ul><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p><strong>上下文：</strong> 某一时间点CPU寄存器和程序计数器的内容。</p><p><strong>上下文切换:</strong> CPU从一个进程/线程切换到另一个进程/线程。</p><p><strong>缺点：</strong> 上先文切换是计算密集型的，消耗大量的CPU时间，故线程也不是越多越好。</p><h2 id="java多线程入门类和接口"><a href="#java多线程入门类和接口" class="headerlink" title="java多线程入门类和接口"></a>java多线程入门类和接口</h2><h3 id="Thread类和Runnable接口"><a href="#Thread类和Runnable接口" class="headerlink" title="Thread类和Runnable接口"></a>Thread类和Runnable接口</h3><p><strong>Java如何实现多线程？</strong></p><ul><li>继承Thread类，并重写run()方法。</li><li>实现Runnable接口的run()方法。</li></ul><p><strong>继承Thread类需注意什么？</strong></p><p>thread.start()方法后，该线程才算启动，调用start()后，虚拟机会先为我们创建一个线程，然后等到这个线程第一次得到时间片时，再调用run()方法。start()不可多次调用，否则抛异常。</p><p><strong>Java8函数式编程</strong></p><pre><code>new Thread(()-&gt;{System.out.println(&quot;java8&quot;);}).start();</code></pre><p><strong>Thread类的构造方法</strong></p><pre><code>Thread(Runnable target)Thread(Runnable target, String name)</code></pre><p><strong>Thread类的几个常用方法</strong></p><pre><code>currentThread(); // 静态方法，返回正在执行线程的引用。start(); // 启动线程。yield(); // 让出当前处理器的占用。sleep(); // 静态方法，休眠。join(); // 当前线程等待另一个线程执行完毕后再继续执行。内部调用的Object.wait()。</code></pre><p><strong>Thread类与Runnable比较？</strong></p><ul><li>Java单继承多实现，Runnable比Thread灵活；</li><li>Runnable更符合面向对象，将线程单独进行对象的封装;</li><li>Runnable降低了线程对象和线程任务的耦合性；</li><li>若不用Thread类诸多方法，Runnable更轻量级，适合实现多线程。</li></ul><h3 id="Callable、Future与FutureTask"><a href="#Callable、Future与FutureTask" class="headerlink" title="Callable、Future与FutureTask"></a>Callable、Future与FutureTask</h3><p><strong>为啥用Callable Future FutureTask?</strong><br>因为Runnable和Thread创建的线程没有返回值。当我们希望开启一个线程执行完一个任务后有返回值则用以上方式（异步模型）。</p><p><strong>Callable特点？</strong></p><ul><li>有返回值，支持泛型</li></ul><p><strong>Callable咋用？</strong></p><pre><code>伪代码 ExecutorService.submit(Callable) return一个Future，通过Future的get方法获取结果。</code></pre><p><strong>Future接口注意项</strong></p><ul><li>cancel() 试图取消，并不一定取消成功。</li></ul><p><strong>FutureTask类总结</strong></p><ul><li>Future类的实现类。</li><li>FutureTask实现了RunnableFuture接口，RunnableFuture同时继承了Runnable接口和Future接口。</li></ul><p><strong>为什么要用FutureTask?</strong><br>高并发下，Callable和FutureTask会创建多次。FutureTask能确保任务只执行一次。</p><p><strong>FutureTask有几个状态?分别是？及其转换关系？</strong><br>六个状态分别是：</p><ul><li>NEW = 0 // 新建</li><li>COMPLETING = 1 // 完成 </li><li>NORMAL = 2 // 正常</li><li>EXCEPTIONAL = 3 // 异常</li><li>CANCELLED = 4  // 取消</li><li>INTERRUPTING = 5 // 打断中</li><li>INTERRUPTED = 6 // 打断了的</li></ul><pre><code>转变路径0 -&gt; 1 -&gt; 20 -&gt; 1 -&gt; 30 -&gt; 40 -&gt; 5 -&gt; 6</code></pre><h2 id="线程组和线程优先级"><a href="#线程组和线程优先级" class="headerlink" title="线程组和线程优先级"></a>线程组和线程优先级</h2><h3 id="线程组（ThreadGroup）"><a href="#线程组（ThreadGroup）" class="headerlink" title="线程组（ThreadGroup）"></a>线程组（ThreadGroup）</h3><p><strong>线程组作用？</strong></p><hr><hr><hr><hr><h2 id="java线程的状态和主要转化方法"><a href="#java线程的状态和主要转化方法" class="headerlink" title="java线程的状态和主要转化方法"></a>java线程的状态和主要转化方法</h2><h2 id="Java线程间的通信"><a href="#Java线程间的通信" class="headerlink" title="Java线程间的通信"></a>Java线程间的通信</h2><h1 id="Java内存模型基础知识"><a href="#Java内存模型基础知识" class="headerlink" title="Java内存模型基础知识"></a>Java内存模型基础知识</h1><h2 id="Java内存模型基础知识-1"><a href="#Java内存模型基础知识-1" class="headerlink" title="Java内存模型基础知识"></a>Java内存模型基础知识</h2><h2 id="重排序与happens-before"><a href="#重排序与happens-before" class="headerlink" title="重排序与happens-before"></a>重排序与happens-before</h2><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h2 id="synchronized与锁"><a href="#synchronized与锁" class="headerlink" title="synchronized与锁"></a>synchronized与锁</h2><h2 id="CAS与原子操作"><a href="#CAS与原子操作" class="headerlink" title="CAS与原子操作"></a>CAS与原子操作</h2><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h1 id="JDK工具"><a href="#JDK工具" class="headerlink" title="JDK工具"></a>JDK工具</h1><h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><h2 id="锁接口和类"><a href="#锁接口和类" class="headerlink" title="锁接口和类"></a>锁接口和类</h2><h2 id="并发集合容器简介"><a href="#并发集合容器简介" class="headerlink" title="并发集合容器简介"></a>并发集合容器简介</h2><h2 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h2><h2 id="通信工具类"><a href="#通信工具类" class="headerlink" title="通信工具类"></a>通信工具类</h2><h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h2><h2 id="Java8-Stream并行计算原理"><a href="#Java8-Stream并行计算原理" class="headerlink" title="Java8 Stream并行计算原理"></a>Java8 Stream并行计算原理</h2><h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础篇&quot;&gt;&lt;a href=&quot;#基础篇&quot; class=&quot;headerlink&quot; title=&quot;基础篇&quot;&gt;&lt;/a&gt;基础篇&lt;/h1&gt;&lt;h2 id=&quot;进程与线程的基本概念&quot;&gt;&lt;a href=&quot;#进程与线程的基本概念&quot; class=&quot;headerlink&quot; title=&quot;进
      
    
    </summary>
    
    
      <category term="java" scheme="http://iwantjingjing.com/categories/java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="多线程" scheme="http://iwantjingjing.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
