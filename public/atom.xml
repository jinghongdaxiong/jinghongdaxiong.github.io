<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>I want jing jing</title>
  
  <subtitle>I want jing jing ,Don&#39;t ask me who is jing jing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://iwantjingjing.com/"/>
  <updated>2019-09-27T03:22:51.396Z</updated>
  <id>http://iwantjingjing.com/</id>
  
  <author>
    <name>给予ππ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何培养孩子的逻辑思维</title>
    <link href="http://iwantjingjing.com/2019/09/27/%E5%A6%82%E4%BD%95%E5%9F%B9%E5%85%BB%E5%AD%A9%E5%AD%90%E7%9A%84%E9%80%BB%E8%BE%91%E6%80%9D%E7%BB%B4/"/>
    <id>http://iwantjingjing.com/2019/09/27/如何培养孩子的逻辑思维/</id>
    <published>2019-09-27T03:03:57.000Z</published>
    <updated>2019-09-27T03:22:51.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逻辑思维能力重要吗？"><a href="#逻辑思维能力重要吗？" class="headerlink" title="逻辑思维能力重要吗？"></a>逻辑思维能力重要吗？</h1><p>答案必然是肯定的，因为它不仅是学好数学必须具备的能力，同时也是学好其他学科，处理日常生活问题所必须具备的能力。</p><p>换句话说就是：逻辑思维，其可以成为“做好任何事情”的必要条件.</p><h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p>它是一种人类思维的高级形式，即我们所说的“抽象思维”。而一个人想具备很强的逻辑思维能力，往往需要从小开始培养。</p><h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>肥宅以为:逻辑思维就是智商最重要的方面之一,甚至之一也可以去掉.</p><h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>美国的很多学校，他们从学前班开始就有关于训练孩子逻辑思维能力的数学内容</p><p>但在国内，我们对孩子逻辑思维的培养还存在一定的误区，学校往往喜欢让学生做题，找到考试的捷径，却忽视了对数学本质的讲解。</p><p>所以当我们没有将数学应用在生活中，这些定理和公式也会随着时间的流逝慢慢被淡忘。</p><p>所以将数学应用在生活中也就是锻炼逻辑思维的必要过程</p><h2 id="那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。"><a href="#那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。" class="headerlink" title="那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。"></a>那如何从小正确地培养孩子的逻辑思维能力呢？这就需要先了解一下孩子的逻辑思维的形成过程。</h2><h3 id="动作思维阶段（0-3岁）"><a href="#动作思维阶段（0-3岁）" class="headerlink" title="动作思维阶段（0-3岁）"></a>动作思维阶段（0-3岁）</h3><p>不到3岁的孩子以动作思维为主，思维在动作中进行。比如桌上放着一个苹果，宝宝矮小够不着，怎么办呢?这时候宝宝发现他旁边有凳子，于是把凳子搬过来，自己爬上去，成功地把苹果拿到手。<br>孩子学会借助别的东西来达到自己的目的，是从不断的操作过程中理解的。 孩子最初的动作往往是杂乱无章、漫无目的的，以后在不断的操作过程中了解了动作与结果之间的关系。</p><h3 id="具体形象思维阶段（3-6岁）"><a href="#具体形象思维阶段（3-6岁）" class="headerlink" title="具体形象思维阶段（3-6岁）"></a>具体形象思维阶段（3-6岁）</h3><p>3-6岁的孩子具体形象思维占优势，他们缺少立体感和空间感。这也是为什么用数字加减，孩子反应不过来，但是用实物举例子，就容易理解。<br>在这个阶段，家长要注意增加孩子的经验，丰富孩子的词汇，多给孩子动手的机会。有些家长和老师片面地、刻板地教孩子多识字、写字、计算等，对孩子的思维发展并没有好处。</p><h3 id="抽象逻辑思维能力（6-11岁）"><a href="#抽象逻辑思维能力（6-11岁）" class="headerlink" title="抽象逻辑思维能力（6-11岁）"></a>抽象逻辑思维能力（6-11岁）</h3><p>6-11岁是培养孩子抽象逻辑思维能力的关键时期。在这一时期要培养孩子正确的思维程序和科学的思维方法。</p><p>比如，一只狗有4条腿，两只狗有8条腿，三只狗有多少条腿?像这些问题，就是属于抽象逻辑思维能力题。家长要注意让孩子学会独立思考，不要给孩子现成的答案。    </p><h2 id="那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。"><a href="#那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。" class="headerlink" title="那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。"></a>那家长如何去培养孩子的逻辑思维能力呢？事实上，在日常与孩子相处的细节中，下面这三种方式，效果是最为明显的。</h2><h3 id="一、丰富孩子的词汇，教孩子说话用词达意"><a href="#一、丰富孩子的词汇，教孩子说话用词达意" class="headerlink" title="一、丰富孩子的词汇，教孩子说话用词达意"></a>一、丰富孩子的词汇，教孩子说话用词达意</h3><p>语言是思维的外壳，尽早教孩子准确用词，不但能防止别人曲解、误解他的意思，而且促使他思维活跃、思路清晰。家长对孩子的话要多问几个为什么，对他的表达要多作分析，这可以使孩子用词准确、鲜明、生动。    </p><h3 id="二、有意识地对孩子设疑，给孩子留下思考的时间"><a href="#二、有意识地对孩子设疑，给孩子留下思考的时间" class="headerlink" title="二、有意识地对孩子设疑，给孩子留下思考的时间"></a>二、有意识地对孩子设疑，给孩子留下思考的时间</h3><p>孩子回答问题往往是凭直觉，如果家长满足于孩子的这点“小聪明”，那么，他们会习惯对问题不假思索地做出回答，没有足够的时间让大脑启动思维“程序”。</p><p>所以，当孩子遇到问题的时候，家长最好不要急于让他说答案，而是让他多问几个为什么，多想几种解决的方案，多几次对自己的否定，然后在否定中寻找最佳答案。</p><h3 id="三、利用游戏促进孩子思维能力的发展"><a href="#三、利用游戏促进孩子思维能力的发展" class="headerlink" title="三、利用游戏促进孩子思维能力的发展"></a>三、利用游戏促进孩子思维能力的发展</h3><p>在日常生活中，可以进行分类和归类的游戏。也可以进行比较动、植物或其他事物、训练理解力和创造力的游戏等。</p><p>比如收衣服时，让孩子将不同的袜子分类卷起来；去动物园时，告诉孩子如何通过牙齿区别食草和食肉的动物，并让他分辨；给孩子一些零钱，让孩子去买东西……</p><p>对孩子而言，说过的话，玩过的游戏或许会忘记，但日复一日默默培养起来的逻辑思维能力会伴随他们终身，使他们在生活和工作中表现得更为优秀出色。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;逻辑思维能力重要吗？&quot;&gt;&lt;a href=&quot;#逻辑思维能力重要吗？&quot; class=&quot;headerlink&quot; title=&quot;逻辑思维能力重要吗？&quot;&gt;&lt;/a&gt;逻辑思维能力重要吗？&lt;/h1&gt;&lt;p&gt;答案必然是肯定的，因为它不仅是学好数学必须具备的能力，同时也是学好其他学科，
      
    
    </summary>
    
    
      <category term="育儿" scheme="http://iwantjingjing.com/categories/%E8%82%B2%E5%84%BF/"/>
    
    
      <category term="育儿" scheme="http://iwantjingjing.com/tags/%E8%82%B2%E5%84%BF/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 核心注解</title>
    <link href="http://iwantjingjing.com/2019/09/25/Spring-Boot-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3/"/>
    <id>http://iwantjingjing.com/2019/09/25/Spring-Boot-核心注解/</id>
    <published>2019-09-25T06:00:45.000Z</published>
    <updated>2019-09-25T08:10:42.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p>我看你上面写了熟悉 Spring Boot，那你能讲下为什么我们要用 Spring Boot 吗？</p><h1 id="下面我列几个最常见的三个回答："><a href="#下面我列几个最常见的三个回答：" class="headerlink" title="下面我列几个最常见的三个回答："></a>下面我列几个最常见的三个回答：</h1><h2 id="A：Spring-Boot-最主要是不用-XML-配置，可以用-Java-来配置-bean，省去了许多配置文件。"><a href="#A：Spring-Boot-最主要是不用-XML-配置，可以用-Java-来配置-bean，省去了许多配置文件。" class="headerlink" title="A：Spring Boot 最主要是不用 XML 配置，可以用 Java 来配置 bean，省去了许多配置文件。"></a>A：Spring Boot 最主要是不用 XML 配置，可以用 Java 来配置 bean，省去了许多配置文件。</h2><p>我又问：Spring 本身就可以用 Java 配置代替 XML 配置，和 Spring Boot 有什么关系呢？</p><p>然后对方就吱吱唔唔了……</p><h2 id="B：Spring-Boot-我们用来做-Spring-Cloud-微服务。"><a href="#B：Spring-Boot-我们用来做-Spring-Cloud-微服务。" class="headerlink" title="B：Spring Boot 我们用来做 Spring Cloud 微服务。"></a>B：Spring Boot 我们用来做 Spring Cloud 微服务。</h2><p>我又问：微服务和 Spring Boot 有什么关系？不用 Spring Boot 行不行？</p><p>然后对方就吱吱唔唔了……</p><h2 id="C：Spring-Boot-可以打-jar-包部署，内部集成了Tomcat。"><a href="#C：Spring-Boot-可以打-jar-包部署，内部集成了Tomcat。" class="headerlink" title="C：Spring Boot 可以打 jar 包部署，内部集成了Tomcat。"></a>C：Spring Boot 可以打 jar 包部署，内部集成了Tomcat。</h2><p>这个确实是 Spring Boot 的特色，但是我还是觉得没有答到关键点上。</p><p>然后我继续问，如果不考虑打 jar 包部署呢，然后就没然后了……</p><h1 id="为什么我们要用-Spring-Boot，显然上面三个求职者没有答到关键点上，Spring-Boot-最重要的功能是：自动配置。"><a href="#为什么我们要用-Spring-Boot，显然上面三个求职者没有答到关键点上，Spring-Boot-最重要的功能是：自动配置。" class="headerlink" title="为什么我们要用 Spring Boot，显然上面三个求职者没有答到关键点上，Spring Boot 最重要的功能是：自动配置。"></a>为什么我们要用 Spring Boot，显然上面三个求职者没有答到关键点上，Spring Boot 最重要的功能是：自动配置。</h1><h2 id="为什么说是自动配置？"><a href="#为什么说是自动配置？" class="headerlink" title="为什么说是自动配置？"></a>为什么说是自动配置？</h2><p>Spring Boot 的开启注解是：@SpringBootApplication，其实它就是由下面三个注解组成的：</p><pre><code>@Configuration@ComponentScan@EnableAutoConfiguration</code></pre><p>上面三个注解，前面两个都是 Spring 自带的，和 Spring Boot 无关，所以说上面的回答的不是在点上。</p><p>所以说 Spring Boot 最最核心的就是这个 <strong>@EnableAutoConfiguration</strong> 注解了，它能根据类路径下的 jar 包和配置动态加载配置和注入bean。</p><p>举个例子，比如我在 lib 下放一个 druid 连接池的 jar 包，然后在 application.yml 文件配置 druid 相关的参数，Spring Boot 就能够自动配置所有我们需要的东西，如果我把 jar 包拿掉或者把参数去掉，那 Spring Boot 就不会自动配置。</p><p>这样我们就能把许多功能做成公共的自动配置的启动器（starters），其实 druid 连接池就是这么做的，它提供了针对 Spring Boot 的启动器：druid-spring-boot-starter。</p><p>有了这个自动配置的启动器，我们就能非常简单的使用它，</p><p>先添加 jar 包依赖：</p><pre><code>&lt;dependency&gt;   &lt;groupId&gt;com.alibaba&lt;/groupId&gt;   &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;   &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;    </code></pre><p>再添加相关参数：</p><pre><code>spring.datasource.url= spring.datasource.username=spring.datasource.password=……</code></pre><p>如果是传统的项目，我们要自己手动写一大堆的配置，而且还不灵活，有了这个启动器，我们就可以做到简单集成。具体大家可以看 druid-spring-boot-starter 是怎么实现的。</p><p>所以，这才是 Spring Boot 的核心，这才是我们为什么使用 Spring Boot 的原因。如果答不到这个关键点，那真没有掌握到 Spring Boot 的核心所在。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h1&gt;&lt;p&gt;我看你上面写了熟悉 Spring Boot，那你能讲下为什么我们要用 Spring Boot 吗？&lt;/p&gt;
&lt;h1 id=&quot;下面我列
      
    
    </summary>
    
    
      <category term="Java" scheme="http://iwantjingjing.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="Spring" scheme="http://iwantjingjing.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Javac原理</title>
    <link href="http://iwantjingjing.com/2019/09/25/Javac%E5%8E%9F%E7%90%86/"/>
    <id>http://iwantjingjing.com/2019/09/25/Javac原理/</id>
    <published>2019-09-25T02:57:37.000Z</published>
    <updated>2019-09-25T06:08:41.597Z</updated>
    
    <content type="html"><![CDATA[<p>从Sun Javac的代码来看，编译过程大致可以分为3个过程:</p><ol><li>解析与填充符号表过程。</li><li>插入式注解处理器的注解处理过程。</li><li>分析与字节码生成过程。<br><img src="j.jpg" alt><br>Javac编译动作的入口是com.sun.tools.javac.main.JavaCompiler类，上述3个过程的代码逻辑集中在这个类的compile()和compile2()方法中，整个编译最关键的处理就由图中标注的8个方法来完成，下面我们具体看一下这8个方法实现了什么功能。<br><img src="f.jpg" alt></li></ol><h1 id="解析与填充符号表"><a href="#解析与填充符号表" class="headerlink" title="解析与填充符号表"></a>解析与填充符号表</h1><p>解析步骤由上图中的parseFiles（）方法（过程1.1）完成，解析步骤包括了经典程序编译原理中的词法分析和语法分析两个过程。</p><h2 id="词法、语法分析"><a href="#词法、语法分析" class="headerlink" title="词法、语法分析"></a>词法、语法分析</h2><p>词法分析是<strong>将源代码的字符流转变为标记（Token）集合</strong>，<strong>单个字符</strong>是<strong>程序编写过程</strong>的最小元素，而<strong>标记</strong>则是<strong>编译过程</strong>的最小元素，关键字、变量名、字面量、运算符都可以成为标记，如“int a=b+2”这句代码包含了6个标记，分别是int、a、=、b、+、2，虽然关键字int由3个字符构成，但是它只是一个Token，不可再拆分。在Javac的源码中，词法分析过程由com.sun.tools.javac.parser.Scanner类来实现。</p><p>语法分析是<strong>根据Token序列构造抽象语法树的过程</strong>，抽象语法树（Abstract Syntax Tree,AST）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构（Construct），例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。</p><p>在Javac的源码中，语法分析过程由com.sun.tools.javac.parser.Parser类实现，这个阶段产出的抽象语法树由com.sun.tools.javac.tree.JCTree类表示，<strong>经过这个步骤之后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在抽象语法树之上</strong>。</p><h2 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h2><p>完成了语法分析和词法分析之后，下一步就是填充符号表的过程，也就是enterTrees（）方法（过程1.2）所做的事情。符号表（Symbol Table）<strong>是由一组符号地址和符号信息构成的表格</strong>，可以把它想象成哈希表中K-V值对的形式（实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等）。符号表中所登记的信息在编译的不同阶段都要用到<br>。<strong>在语义分析中，符号表所登记的内容将用于语义检查</strong>（如检查一个名字的使用和原先的说明是否一致）和<strong>产生中间代码</strong>。在目标代码生成阶段，当对符号名进行地址分配时，<strong>符号表是地址分配的依据。</strong></p><p>在Javac源代码中，填充符号表的过程由com.sun.tools.javac.comp.Enter类实现，此过程的出口是一个待处理列表（To Do List），包含了每一个编译单元的抽象语法树的顶级节点，以及package-info.java（如果存在的话）的顶级节点。</p><h1 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h1><p>在Javac源码中，<em>插入</em>式注解处理器的<em>初始化</em>过程是在<br>initPorcessAnnotations（）方法中完成的，而它的<em>执行过程</em>则是在processAnnotations（）方法中完成的，<br>这个方法判断是否还有新的注解处理器需要执行，如果有的话，通过com.sun.tools.javac.processing.JavacProcessingEnvironment类的doProcessing（）方法生成一个新的JavaCompiler对象对编译的后续步骤进行处理。</p><p>在JDK 1.5之后，Java语言提供了对注解（Annotation）的支持，这些注解与普通的Java代码一样，是在运行期间发挥作用的。在JDK 1.6中实现了JSR-269规范JSR-269：Pluggable Annotations Processing API（插入式注解处理API）。提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，我们可以把它看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round，也就是第一张图中的回环过程。 有了编译器注解处理的标准API后，我们的代码才有可能干涉编译器的行为，由于语法树中的任意元素，甚至包括代码注释都可以在插件之中访问到，所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间。只要有足够的创意，程序员可以使用插入式注解处理器来实现许多原本只能在编码中完成的事情。</p><p>我们知道编译器在把Java程序源码编译为字节码的时候，会对Java程序源码做各方面的检查校验。这些校验主要以程序“写得对不对”为出发点，虽然也有各种WARNING的信息，但总体来讲还是较少去校验程序“写得好不好”。有鉴于此，业界出现了许多针对程序“写得好不好”的辅助校验工具，如CheckStyle、FindBug、Klocwork等。这些代码校验工具有一些是基于Java的源码进行校验，还有一些是通过扫描字节码来完成。我们将会使用注解处理器API来编写一款拥有自己编码风格的校验工具：NameCheckProcessor。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>要通过注解处理器API实现一个编译器插件，首先需要了解这组API的一些基本知识。我们实现注解处理器的代码需要继承抽象类javax.annotation.processing.AbstractProcessor，这个抽象类中只有一个必须覆盖的abstract方法：“process（）”，它是Javac编译器在执行注解处理器代码时要调用的过程，我们可以从这个方法的第一个参数“annotations”中获取到此注解处理器所要处理的注解集合，从第二个参数“roundEnv”中访问到当前这个Round中的语法树节点，每个语法树节点在这里表示为一个Element。在JDK 1.6新增的javax.lang.model包中定义了16类Element，包括了Java代码中最常用的元素，如：“包（PACKAGE）、枚举（ENUM）、类（CLASS）、注解（ANNOTATION_TYPE）、接口（INTERFACE）、枚举值（ENUM_CONSTANT）、字段（FIELD）、参数（PARAMETER）、本地变量（LOCAL_VARIABLE）、异常（EXCEPTION_PARAMETER）、方法（METHOD）、构造函数（CONSTRUCTOR）、静态语句块（STATIC_INIT，即static{}块）、实例语句块（INSTANCE_INIT，即{}块）、参数化类型（TYPE_PARAMETER，既泛型尖括号内的类型）和未定义的其他语法树节点（OTHER）”。除了process（）方法的传入参数之外，还有一个很常用的实例变量“processingEnv”，它是AbstractProcessor中的一个protected变量，在注解处理器初始化的时候（init（）方法执行的时候）创建，继承了AbstractProcessor的注解处理器代码可以直接访问到它。它代表了注解处理器框架提供的一个上下文环境，要创建新的代码、向编译器输出信息、获取其他工具类等都需要用到这个实例变量。注解处理器除了process（）方法及其参数之外，还有两个可以配合使用的Annotations：@SupportedAnnotationTypes和@SupportedSourceVersion，前者代表了这个注解处理器对哪些注解感兴趣，可以使用星号“*”作为通配符代表对所有的注解都感兴趣，后者指出这个注解处理器可以处理哪些版本的Java代码。</p><p>每一个注解处理器在运行的时候都是单例的，如果不需要改变或生成语法树的内容，process（）方法就可以返回一个值为false的布尔值，通知编译器这个Round中的代码未发生变化，无须构造新的JavaCompiler实例，在这次实战的注解处理器中只对程序命名进行检查，不需要改变语法树的内容，因此process（）方法的返回值都是false。</p><pre><code>import javax.annotation.processing.*;import javax.lang.model.SourceVersion;import javax.lang.model.element.Element;import javax.lang.model.element.TypeElement;import java.util.Set;//可以用&quot;*&quot;表示支持所有Annotations@SupportedAnnotationTypes(&quot;*&quot;)//只支持JDK 1.6的Java代码@SupportedSourceVersion(SourceVersion.RELEASE_6)public class NameCheckProcessor extends AbstractProcessor {    private NameChecker nameChecker;    /**     * 初始化名称检查插件     */    @Override    public void init(ProcessingEnvironment processingEnv){        super.init(processingEnv);        nameChecker = new NameChecker(processingEnv);    }    /**     * 对输入的语法树的各个节点进行名称检查     */    @Override    public boolean process(Set&lt;? extends TypeElement&gt; annotations,RoundEnvironment roundEnv){        if (!roundEnv.processingOver()) {            for (Element element:roundEnv.getRootElements())            nameChecker.checkNames(element);        }        return false;    }}import javax.annotation.processing.Messager;import javax.annotation.processing.ProcessingEnvironment;import javax.lang.model.element.*;import javax.lang.model.util.ElementScanner6;import javax.tools.Diagnostic;import java.util.EnumSet;public class NameChecker {    private final Messager messager;    NameCheckScanner nameCheckScanner = new NameCheckScanner();    NameChecker(ProcessingEnvironment processsingEnv) {        this.messager = processsingEnv.getMessager();    }    /**     * 对Java程序命名进行检查,根据《Java语言规范(第3版)》第6.8节的要求,Java程序命名应当符合下列格式：     * &lt;p/&gt;     * &lt;ul&gt;     * &lt;li&gt;类或接口：符合驼式命名法,首字母大写。     * &lt;li&gt;方法：符合驼式命名法,首字母小写。     * &lt;li&gt;字段：     * &lt;ul&gt;     * &lt;li&gt;类、实例变量：符合驼式命名法,首字母小写。     * &lt;li&gt;常量：要求全部大写。     * &lt;/ul&gt;     * &lt;/ul&gt;     */    public void checkNames(Element element) {        nameCheckScanner.scan(element);    }    /**     * 名称检查器实现类,继承了JDK 1.6中新提供的ElementScanner6&lt;br&gt;     * 将会以Visitor模式访问抽象语法树中的元素     */    private class NameCheckScanner extends ElementScanner6&lt;Void, Void&gt; {        /**         * 此方法用于检查Java类         */        @Override        public Void visitType(TypeElement e, Void p) {            scan(e.getTypeParameters(), p);            checkCamelCase(e, true);            super.visitType(e, p);            return null;        }        /**         * 检查方法命名是否合法         */        @Override        public Void visitExecutable(ExecutableElement e, Void p) {            if (e.getKind() == ElementKind.METHOD) {                Name name = e.getSimpleName();                if                        (name.contentEquals(e.getEnclosingElement().getSimpleName()))                    messager.printMessage(Diagnostic.Kind.WARNING, &quot;一个普通方法&apos;&quot; + name + &quot;&apos;不应当与类名重复,避免与构造函数产生混淆&quot;, e);                checkCamelCase(e, false);            }            super.visitExecutable(e, p);            return null;        }        /**         * 检查变量命名是否合法         */        @Override        public Void visitVariable(VariableElement e, Void p) {            //如果这个Variable是枚举或常量,则按大写命名检查,否则按照驼式命名法规则检查            if (e.getKind() == ElementKind.ENUM_CONSTANT || e.getConstantValue() != null || heuristicallyConstant(e))                checkAllCaps(e);            else                checkCamelCase(e, false);            return null;        }        /**         * 判断一个变量是否是常量         */        private boolean heuristicallyConstant(VariableElement e) {            if (e.getEnclosingElement().getKind() == ElementKind.INTERFACE)                return true;            else if (e.getKind() == ElementKind.FIELD &amp;&amp; e.getModifiers().containsAll(EnumSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)))                return true;            else {                return false;            }        }        /**         * 检查传入的Element是否符合驼式命名法,如果不符合,则输出警告信息         */        private void checkCamelCase(Element e, boolean initialCaps) {            String name = e.getSimpleName().toString();            boolean previousUpper = false;            boolean conventional = true;            int firstCodePoint = name.codePointAt(0);            if (Character.isUpperCase(firstCodePoint)) {                previousUpper = true;                if (!initialCaps) {                    messager.printMessage(Diagnostic.Kind.WARNING, &quot;名称&apos;&quot; + name + &quot;&apos;应当以小写字母开头&quot;, e);                    return;                }            } else if (Character.isLowerCase(firstCodePoint)) {                if (initialCaps) {                    messager.printMessage(Diagnostic.Kind.WARNING, &quot;名称&apos;&quot; + name + &quot;&apos;应当以大写字母开头&quot;, e);                    return;                }            } else                conventional = false;            if (conventional) {                int cp = firstCodePoint;                for (int i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) {                    cp = name.codePointAt(i);                    if (Character.isUpperCase(cp)) {                        if (previousUpper) {                            conventional = false;                            break;                        }                        previousUpper = true;                    } else                        previousUpper = false;                }            }            if (!conventional)                messager.printMessage(Diagnostic.Kind.WARNING, &quot;名称&apos;&quot; + name + &quot;&apos;应当符合驼式命名法(Camel Case Names)&quot;, e);        }        /**         * 大写命名检查,要求第一个字母必须是大写的英文字母,其余部分可以是下划线或大写字母         */        private void checkAllCaps(Element e) {            String name = e.getSimpleName().toString();            boolean conventional = true;            int firstCodePoint = name.codePointAt(0);            if (!Character.isUpperCase(firstCodePoint))                conventional = false;            else {                boolean previousUnderscore = false;                int cp = firstCodePoint;                for (int i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) {                    cp = name.codePointAt(i);                    if (cp == (int) &apos;_&apos;) {                        if (previousUnderscore) {                            conventional = false;                            break;                        }                        previousUnderscore = true;                    } else {                        previousUnderscore = false;                        if (!Character.isUpperCase(cp) &amp;&amp; !Character.isDigit(cp)) {                            conventional = false;                            break;                        }                    }                }            }            if (!conventional)                messager.printMessage(Diagnostic.Kind.WARNING, &quot;常量&apos;&quot; + name + &quot;&apos;应当全部以大写字母或下划线命名,并且以字母开头&quot;, e);        }    }}</code></pre><p>我们可以通过Javac命令的“-processor”参数来执行编译时需要附带的注解处理器，如果有多个注解处理器的话，用逗号分隔。还可以使用-XprintRounds和-XprintProcessorInfo参数来查看注解处理器运作的详细信息，javac -processor <strong>*.NameCheckProcessor *</strong>/test.java</p><pre><code>test.java：3：警告：名称&quot;test&quot;应当符合驼式命名法（Camel Case Names）public class test{^test.java：5：警告：名称&quot;colors&quot;应当以大写字母开头enum colors{^test.java：6：警告：常量&quot;red&quot;应当全部以大写字母或下划线命名，并且以字母开头red,blue,green；^test.java：6：警告：常量&quot;blue&quot;应当全部以大写字母或下划线命名，并且以字母开头red,blue,green；^test.java：6：警告：常量&quot;green&quot;应当全部以大写字母或下划线命名，并且以字母开头red,blue,green；^test.java：9：警告：常量&quot;_FORTY_TWO&quot;应当全部以大写字母或下划线命名，并且以字母开头static final int_FORTY_TWO=42；^test.java：11：警告：名称&quot;NOT_A_CONSTANT&quot;应当以小写字母开头public static int NOT_A_CONSTANT=_FORTY_TWO；^test.java：13：警告：名称&quot;Test&quot;应当以小写字母开头protected void Test（）{^test.java：17：警告：名称&quot;NOTcamelCASEmethodNAME&quot;应当以小写字母开头public void NOTcamelCASEmethodNAME（）{^</code></pre><p>NameCheckProcessor的例子只演示了JSR-269嵌入式注解处理器API中的一部分功能，基于这组API支持的项目还有用于校验Hibernate标签使用正确性的Hibernate Validator Annotation Processorm自动为字段生成getter和setter方法的Project Lombok.</p><h1 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h1><p>语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。Javac的编译过程中，语义分析过程分为标注检查以及数据及控制流分析两个步骤，分别由上图中所示的attribute（）和flow（）方法（分别对应过程3.1和过程3.2）完成。</p><h2 id="标注检查"><a href="#标注检查" class="headerlink" title="标注检查"></a>标注检查</h2><p>标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。在标注检查步骤中，还有一个重要的动作称为常量折叠，如果我们在代码中写了如下定义：int a=1+2；那么在语法树上仍然能看到字面量“1”、“2”以及操作符“+”，但是在经过常量折叠之后，它们将会被折叠为字面量“3”，由于编译期间进行了常量折叠，所以在代码里面定义“a=1+2”比起直接定义“a=3”，并不会增加程序运行期哪怕仅仅一个CPU指令的运算量。</p><h2 id="数据及控制流分析"><a href="#数据及控制流分析" class="headerlink" title="数据及控制流分析"></a>数据及控制流分析</h2><p>在Javac的源码中，数据及控制流分析的入口是图中的flow（）方法（对应过程3.2），具体操作由com.sun.tools.javac.comp.Flow类来完成。</p><p>数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只有在编译期或运行期才能进行。</p><pre><code>//方法一带有final修饰public void foo（final int arg）{final int var=0；//do something}//方法二没有final修饰public void foo（int arg）{int var=0；//do something}</code></pre><p>在这两个foo（）方法中，第一种方法的参数和局部变量定义使用了final修饰符，而第二种方法则没有，在代码编写时程序肯定会受到final修饰符的影响，不能再改变arg和var变量的值，但是这两段代码编译出来的Class文件是没有任何一点区别的，局部变量与字段（实例变量、类变量）是有区别的，它在常量池中没有CONSTANT_Fieldref_info的符号引用，自然就没有访问标志（Access_Flags）的信息，甚至可能连名称都不会保留下来（取决于编译时的选项），自然在Class文件中不可能知道一个局部变量是不是声明为final了。因此，将局部变量声明为final，对运行期是没有影响的，变量的不变性仅仅由编译器在编译期间保障。</p><h2 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h2><p>在Javac的源码中，解语法糖的过程由desugar（）方法触发，在com.sun.tools.javac.comp.TransTypes类和com.sun.tools.javac.comp.Lower类中完成。</p><p>语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说，使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p><p>Java中最常用的语法糖主要是的泛型擦除（泛型并不一定都是语法糖实现，如C#的泛型就是直接由CLR支持的）、变长参数、自动装箱/拆箱,条件编译等，虚拟机运行时不支持这些语法，它们在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖。</p><h1 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h1><p>字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面由com.sun.tools.javac.jvm.Gen类来完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。</p><p>例如，实例构造器＜init＞（）方法和类构造器＜clinit＞（）方法就是在这个阶段添加到语法树之中的（注意，这里的实例构造器并不是指默认构造函数，如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、访问性（public、protected或private）与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成），这两个构造器的产生过程实际上是一个代码收敛的过程，编译器会把语句块（对于实例构造器而言是“{}”块，对于类构造器而言是“static{}”块）、变量初始化（实例变量和类变量）、调用父类的实例构造器等操作收敛到＜init＞（）和＜clinit＞（）方法之中，并且保证一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行，上面所述的动作由Gen.normalizeDefs（）方法来实现。除了生成构造器以外，还有其他的一些代码替换工作用于优化程序的实现逻辑，如把字符串的加操作替换为StringBuffer或StringBuilder的append（）操作等。</p><p>完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交给com.sun.tools.javac.jvm.ClassWriter类，由这个类的writeClass（）方法输出字节码，生成最终的Class文件，到此为止整个编译过程宣告结束。</p><p><a href="https://www.cnblogs.com/wade-luffy/p/6050331.html" target="_blank" rel="noopener">摘自</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从Sun Javac的代码来看，编译过程大致可以分为3个过程:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解析与填充符号表过程。&lt;/li&gt;
&lt;li&gt;插入式注解处理器的注解处理过程。&lt;/li&gt;
&lt;li&gt;分析与字节码生成过程。&lt;br&gt;&lt;img src=&quot;j.jpg&quot; alt&gt;&lt;br&gt;Javac
      
    
    </summary>
    
    
      <category term="Java" scheme="http://iwantjingjing.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>使用 lombok 简化 Java 代码  </title>
    <link href="http://iwantjingjing.com/2019/09/25/%E4%BD%BF%E7%94%A8-lombok-%E7%AE%80%E5%8C%96-Java-%E4%BB%A3%E7%A0%81/"/>
    <id>http://iwantjingjing.com/2019/09/25/使用-lombok-简化-Java-代码/</id>
    <published>2019-09-25T02:27:07.000Z</published>
    <updated>2019-09-25T02:50:00.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一个典型的-Java-类"><a href="#一个典型的-Java-类" class="headerlink" title="一个典型的 Java 类"></a>一个典型的 Java 类</h1><pre><code>public class A {  private int a;  private String b;  public int getA() {    return a;  }  public String getB() {    return b;  }  public void setA(int a) {    this.a = a;  }  public void setB(String b) {    this.b = b;  }}</code></pre><p>对于这样一个简单的 Java 类，我们通常需要给每个属性写getter和setter，而这种实际上没有什么太大的意义。当然，如果有的公司或团队使用代码行数评估工作量，还是多写几行吧；同时，可以考虑一下我们团队。</p><h1 id="使用-lombok，简化代码"><a href="#使用-lombok，简化代码" class="headerlink" title="使用 lombok，简化代码"></a>使用 lombok，简化代码</h1><p>为了简化getter与setter，lombok 提供了一种机制，帮助我们自动生成这些样板代码。以上的代码，如果使用lombok的话，将变得很简单：</p><pre><code>@lombok.Getter@lombok.Setterpublic class A {    private int a;    private String b;}</code></pre><p>顾名思义，lombok.Getter就是生成getter，lombok.Setter就是生成setter。但是，这样真的就可以了么？编译下，让我们看看生成的二进制代码。(请自行下载lombok.jar)</p><pre><code>命令行&gt; javac -cp lombok.jar A.java命令行&gt; javap -c A.class</code></pre><p>输出结果略。可以看到完全一样。</p><p>更进一步，如果在编译的时候，加入-g:none选项，甚至可以看到生成的文件完全一样。</p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>虽然我们可以在编译的时候，加入classpath，但是，一般来说，在各类IDE中使用，还是需要特殊处理一下。</p><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>加上依赖就好。同时，由于lombok只在编译期才处理，所以并不需要在运行时有这个依赖，可以把scope定义为provided。</p><pre><code>&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;version&gt;1.16.8&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>值得注意的是，maven的maven-compiler-plugin低版本和lombok高版本不兼容，目前已知maven-compiler-plugin的2.3.X与lombok的1.6.X不兼容。这个需要了解lombok的原理才能进一步说明。</p><h2 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h2><p>由于eclipse的默认编译器并不是javac，所以，需要额外安装，基本就是改下引导参数，可以直接运行jar包，或者手动在eclipse.ini里加上参数-Xbootclasspath/a:lombok.jar -javaagent:lombok.jar。</p><h2 id="IDEA-IntelliJ"><a href="#IDEA-IntelliJ" class="headerlink" title="IDEA IntelliJ"></a>IDEA IntelliJ</h2><p>虽然IDEA IntelliJ默认使用javac作为编译器，理论上可以不装插件。可是，跳转等特性也随之没了。所以，还是安装个插件吧，直接去仓库里搜索lombok就成。</p><p>如果项目中使用高级配置，需要额外注意一下。虽然在编译的时候，lombok配置文件可以在任何能找到的目录，但是，lombok-intellij插件默认并不支持在任何目录，如果有配置文件，建议放在java的源代码根目录中。    </p><h1 id="更多-lombok-注解"><a href="#更多-lombok-注解" class="headerlink" title="更多 lombok 注解"></a>更多 lombok 注解</h1><table><thead><tr><th align="left">注解</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">@val</td><td align="left">如果你要定义一个final的变量，并且不想写类型，这个可以帮到你。但是，在实际项目中，完全没有使用到。</td></tr><tr><td align="left">@NonNull</td><td align="left">这个在参数中使用，如果调用时传了null，就直接抛空指针。</td></tr><tr><td align="left">@Data</td><td align="left">@ToString、@EqualsAndHashCode、@Getter、@Setter和@RequiredArgsConstructor注解的集合。</td></tr><tr><td align="left">@Getter与@Setter</td><td align="left">作用于属性和类上，自动生成属性的getXXX()和setXXX()方法。若在类上，则对所有属性有效。并可通过AccessLevel参数控制方法的访问级别。</td></tr><tr><td align="left">@ToString</td><td align="left">作用于类，自动重写类的ToString()方法。常用的参数有exclude（指定方法中不包含的属性）、callSuper（方法中是否包含父类ToString()方法返回的值）</td></tr><tr><td align="left">@EqualsAndHashCode</td><td align="left">作用于类，自动重写类的equals()、hashCode()方法。常用的参数有exclude（指定方法中不包含的属性）、callSuper（方法中是否包含父类ToString()方法返回的值）</td></tr><tr><td align="left">@NoArgsConstructor, @RequiredArgsConstructor和@AllArgsConstructor</td><td align="left">作用于类，@NoArgsConstructor自动生成不带参数的构造方法；@RequiredArgsConstructor自动生成带参数的构造方法，主要针对一些需要特殊处理的属性，比如未初始化的final属性；@AllArgsConstructor自动生成包含所有属性的构造方法。</td></tr><tr><td align="left">@Synchronized</td><td align="left">作用于方法，可锁定指定的对象，如果不指定，则默认创建创建一个对象锁定。</td></tr><tr><td align="left">@Log，或者直接@Slf4j</td><td align="left">作用于类，具体包含@CommonsLog、@Log、@Log4j、@Log4j2、@Slf4j和@XSlf4j，分别对用不同的日志系统。利用此类注解，可为类创建一个log属性。</td></tr></tbody></table><h2 id="sonar源码审查"><a href="#sonar源码审查" class="headerlink" title="sonar源码审查"></a>sonar源码审查</h2><p>sonar是一个源码审查工具。最新版5.X已经支持lombok的全部注解，不再认为是没有使用的变量。但是，旧的4.X还是认为没有使用这些变量。可以后向移植这些包，或者应用单独的补丁。</p><p><a href="https://segmentfault.com/a/1190000005133786" target="_blank" rel="noopener">摘自</a></p><p><a href="https://docs.sonarqube.org/latest/" target="_blank" rel="noopener">sonar</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一个典型的-Java-类&quot;&gt;&lt;a href=&quot;#一个典型的-Java-类&quot; class=&quot;headerlink&quot; title=&quot;一个典型的 Java 类&quot;&gt;&lt;/a&gt;一个典型的 Java 类&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;public class A {

  pr
      
    
    </summary>
    
    
      <category term="Lombok" scheme="http://iwantjingjing.com/categories/Lombok/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="lombok" scheme="http://iwantjingjing.com/tags/lombok/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之Builder模式  </title>
    <link href="http://iwantjingjing.com/2019/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BBuilder%E6%A8%A1%E5%BC%8F/"/>
    <id>http://iwantjingjing.com/2019/09/19/设计模式之Builder模式/</id>
    <published>2019-09-19T10:24:08.000Z</published>
    <updated>2019-09-19T10:24:08.818Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MySQL创建用户与授权  </title>
    <link href="http://iwantjingjing.com/2019/09/12/MySQL%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E4%B8%8E%E6%8E%88%E6%9D%83/"/>
    <id>http://iwantjingjing.com/2019/09/12/MySQL创建用户与授权/</id>
    <published>2019-09-12T08:10:52.000Z</published>
    <updated>2019-09-25T02:50:00.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-创建用户"><a href="#一-创建用户" class="headerlink" title="一. 创建用户"></a>一. 创建用户</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><pre><code>CREATE USER &apos;username&apos;@&apos;host&apos; IDENTIFIED BY &apos;password&apos;;</code></pre><h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><ul><li>username：你将创建的用户名</li><li>host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%</li><li>password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</li></ul><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><pre><code>CREATE USER &apos;dog&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;;CREATE USER &apos;pig&apos;@&apos;192.168.1.101_&apos; IDENDIFIED BY &apos;123456&apos;;CREATE USER &apos;pig&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;CREATE USER &apos;pig&apos;@&apos;%&apos; IDENTIFIED BY &apos;&apos;;CREATE USER &apos;pig&apos;@&apos;%&apos;;</code></pre><h1 id="二-授权"><a href="#二-授权" class="headerlink" title="二. 授权:"></a>二. 授权:</h1><h2 id="命令-1"><a href="#命令-1" class="headerlink" title="命令:"></a>命令:</h2><pre><code>GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos;</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h2><ul><li>privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL</li><li>databasename：数据库名</li><li>tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<em>表示，如</em>.*</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h2><pre><code>GRANT SELECT, INSERT ON test.user TO &apos;pig&apos;@&apos;%&apos;;GRANT ALL ON *.* TO &apos;pig&apos;@&apos;%&apos;;</code></pre><p>注意:<br>用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:</p><pre><code>GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos; WITH GRANT OPTION;</code></pre><h1 id="三-设置与更改用户密码"><a href="#三-设置与更改用户密码" class="headerlink" title="三.设置与更改用户密码"></a>三.设置与更改用户密码</h1><p>   命令:</p><pre><code>SET PASSWORD FOR &apos;username&apos;@&apos;host&apos; = PASSWORD(&apos;newpassword&apos;);</code></pre><p> 如果是当前登陆用户用:</p><pre><code>SET PASSWORD = PASSWORD(&quot;newpassword&quot;);</code></pre><p>例子:</p><pre><code>SET PASSWORD FOR &apos;pig&apos;@&apos;%&apos; = PASSWORD(&quot;123456&quot;);</code></pre><h1 id="四-撤销用户权限"><a href="#四-撤销用户权限" class="headerlink" title="四. 撤销用户权限"></a>四. 撤销用户权限</h1><p>命令:</p><pre><code>REVOKE privilege ON databasename.tablename FROM &apos;username&apos;@&apos;host&apos;;</code></pre><p>说明:<br>privilege, databasename, tablename：同授权部分</p><p>例子:</p><pre><code>REVOKE SELECT ON *.* FROM &apos;pig&apos;@&apos;%&apos;;</code></pre><p>注意:</p><p>假如你在给用户‘pig’@’%’授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO ‘pig’@’%’，则在使用REVOKE SELECT ON <em>.</em> FROM ‘pig’@’%’;命令并不能撤销该用户对test数据库中user表的SELECT 操作。相反，如果授权使用的是GRANT SELECT ON <em>.</em> TO ‘pig’@’%’;则REVOKE SELECT ON test.user FROM ‘pig’@’%’;命令也不能撤销该用户对test数据库中user表的Select权限。</p><p>具体信息可以用命令SHOW GRANTS FOR ‘pig’@’%’; 查看。</p><h1 id="五-删除用户"><a href="#五-删除用户" class="headerlink" title="五.删除用户"></a>五.删除用户</h1><pre><code>DROP USER &apos;username&apos;@&apos;host&apos;;</code></pre><p><a href="https://www.jianshu.com/p/d7b9c468f20d" target="_blank" rel="noopener">摘抄自</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-创建用户&quot;&gt;&lt;a href=&quot;#一-创建用户&quot; class=&quot;headerlink&quot; title=&quot;一. 创建用户&quot;&gt;&lt;/a&gt;一. 创建用户&lt;/h1&gt;&lt;h2 id=&quot;命令&quot;&gt;&lt;a href=&quot;#命令&quot; class=&quot;headerlink&quot; title=&quot;命令&quot;
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://iwantjingjing.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://iwantjingjing.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Lombok 看这篇就够了  </title>
    <link href="http://iwantjingjing.com/2019/09/12/Lombok-%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <id>http://iwantjingjing.com/2019/09/12/Lombok-看这篇就够了/</id>
    <published>2019-09-12T06:41:50.000Z</published>
    <updated>2019-09-25T02:28:15.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p><a href="https://projectlombok.org" target="_blank" rel="noopener">官网</a><br>官网解释:</p><p>Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.<br>Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.</p><h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>减少代码量,省去写geter,setter等</p><h1 id="when"><a href="#when" class="headerlink" title="when"></a>when</h1><h2 id="添加下依赖"><a href="#添加下依赖" class="headerlink" title="添加下依赖:"></a>添加下依赖:</h2><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.16.8&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>那么Lombok是做什么的呢？其实很简单，一个最简单的例子就是它能够实现通过添加注解，能够自动生成一些方法。比如这样的类:</p><pre><code>@Getterclass Test{    private String value;}</code></pre><p>我们用Lombok提供的@Getter来注解这个类，这个类在编译的时候就会变成:</p><pre><code>class Test{    private String value;    public String getValue(){        return this.value;    }}</code></pre><p>当然Lombok也提供了很多其他的注解，这只是其中一个最典型的例子。其他的用法网上的资料已经很多了，这里就不啰嗦。<br>看上去是很方便的一个功能，尤其是在很多项目里有很多bean，每次都要手写或自动生成setter getter方法，搞得代码很长而且没有啥意义，因此这个对简化代码的强迫症们还是很有吸引力的。<br>但是，我们发现这个包跟一般的包有很大区别，绝大多数java包都工作在运行时，比如spring提供的那种注解，通过在运行时用反射来实现业务逻辑。Lombok这个东西工作却在编译期，在运行时是无法通过反射获取到这个注解的。<br>而且由于他相当于是在编译期对代码进行了修改，因此从直观上看，源代码甚至是语法有问题的。<br>一个更直接的体现就是，普通的包在引用之后一般的IDE都能够自动识别语法，但是Lombok的这些注解，一般的IDE都无法自动识别，比如我们上面的Test类，如果我们在其他地方这么调用了一下:</p><pre><code>Test test=new Test();test.getValue();</code></pre><p>IDE的自动语法检查就会报错，说找不到这个getValue方法。因此如果要使用Lombok的话还需要配合安装相应的插件，防止IDE的自动检查报错。<br>因此，可以说这个东西的设计初衷比较美好，但是用起来比较麻烦，而且破坏了代码的完整性，很多项目组(包括我自己)都不高兴用。但是他的实现原理却还是比较好玩的，随便搜了搜发现网上最多也只提到了他修改了抽象语法树，虽说从感性上可以理解，但是还是想自己手敲一敲真正去实现一下。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>翻了翻现有的资料，再加上自己的一些猜想，Lombok的基本流程应该基本是这样：</p><ul><li>定义编译期的注解</li><li>利用JSR269 api(Pluggable Annotation Processing API )创建编译期的注解处理器</li><li>利用tools.jar的javac api处理AST(抽象语法树)</li><li>将功能注册进jar包</li></ul><h2 id="手撸Getter"><a href="#手撸Getter" class="headerlink" title="手撸Getter"></a>手撸Getter</h2><p>由于比较习惯用maven，我这里就用maven构建一下项目，修改下当前的pom.xml文件如下：</p><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.mythsman.test&lt;/groupId&gt;    &lt;artifactId&gt;getter&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;name&gt;test&lt;/name&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.sun&lt;/groupId&gt;            &lt;artifactId&gt;tools&lt;/artifactId&gt;            &lt;version&gt;1.8&lt;/version&gt;            &lt;scope&gt;system&lt;/scope&gt;            &lt;systemPath&gt;${java.home}/../lib/tools.jar&lt;/systemPath&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>主要定义了下项目名，除了默认依赖的junit之外(其实并没有用)，这里添加了tools.jar包。这个包实在jdk的lib下面，因此scope是system，由于${java.home}变量表示的是jre的位置，因此还要根据这个位置找到实际的tools.jar的路径并写在systemPath里。<br>由于防止在写代码的时候用到java8的一些语法，这里配置了下编译插件使其支持java8。</p><h3 id="创建Getter注解"><a href="#创建Getter注解" class="headerlink" title="创建Getter注解"></a>创建Getter注解</h3><p>定义注解Getter.java:</p><pre><code>package com.mythsman.test;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target({ElementType.TYPE})@Retention(RetentionPolicy.SOURCE)public @interface Getter {}</code></pre><p>这里的Target我选择了ElementType.TYPE表示是对类的注解，Retention选择了RententionPolicy.SOURCE，表示这个注解只在编译期起作用，在运行时将不存在。这个比较简单，稍微复杂点的是对这个注解的处理机制。像spring那种注解是通过反射来获得注解对应的元素并实现业务逻辑，但是我们显然不希望在使用Lombok这种功能的时候还要编写其他的调用代码，况且用反射也获取不到编译期才存在的注解。<br>幸运的是Java早已支持了JSR269的规范，允许在编译时指定一个processor类来对编译阶段的注解进行干预，下面就来解决下这个处理器。</p><h3 id="创建Getter注解的处理器"><a href="#创建Getter注解的处理器" class="headerlink" title="创建Getter注解的处理器"></a>创建Getter注解的处理器</h3><p>基本框架</p><p>自定义的处理器需要继承AbstractProcessor这个类，基本的框架大体应当如下:</p><pre><code>package com.mythsman.test;import javax.annotation.processing.*;import javax.lang.model.SourceVersion;import javax.lang.model.element.TypeElement;import java.util.Set;@SupportedAnnotationTypes(&quot;com.mythsman.test.Getter&quot;)@SupportedSourceVersion(SourceVersion.RELEASE_8)public class GetterProcessor extends AbstractProcessor {    @Override    public synchronized void init(ProcessingEnvironment processingEnv) {        super.init(processingEnv);    }    @Override    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {        return true;    }}</code></pre><p>需要定义两个注解，一个表示该处理器需要处理的注解，另外一个表示该处理器支持的源码版本。然后需要着重实现两个方法，init跟process。init的主要用途是通过ProcessingEnvironment来获取编译阶段的一些环境信息;process主要是实现具体逻辑的地方，也就是对AST进行处理的地方。</p><p>具体怎么做呢？</p><p>init方法<br>首先我们要重写下init方法，从环境里提取一些关键的类:</p><pre><code>private Messager messager;private JavacTrees trees;private TreeMaker treeMaker;private Names names;@Overridepublic synchronized void init(ProcessingEnvironment processingEnv) {    super.init(processingEnv);    this.messager = processingEnv.getMessager();    this.trees = JavacTrees.instance(processingEnv);    Context context = ((JavacProcessingEnvironment) processingEnv).getContext();    this.treeMaker = TreeMaker.instance(context);    this.names = Names.instance(context);}</code></pre><p>我们提取了四个主要的类:</p><ul><li>Messager主要是用来在编译期打log用的</li><li>JavacTrees提供了待处理的抽象语法树</li><li>TreeMaker封装了创建AST节点的一些方法</li><li>Names提供了创建标识符的方法</li></ul><p>process方法<br>process方法的逻辑比较简单，但是由于这里的api对于我们来说比较陌生，因此写起来还是费了不少劲的：</p><pre><code>@Overridepublic synchronized boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {    Set&lt;? extends Element&gt; set = roundEnv.getElementsAnnotatedWith(Getter.class);    set.forEach(element -&gt; {        JCTree jcTree = trees.getTree(element);        jcTree.accept(new TreeTranslator() {            @Override            public void visitClassDef(JCTree.JCClassDecl jcClassDecl) {                List&lt;JCTree.JCVariableDecl&gt; jcVariableDeclList = List.nil();                for (JCTree tree : jcClassDecl.defs) {                    if (tree.getKind().equals(Tree.Kind.VARIABLE)) {                        JCTree.JCVariableDecl jcVariableDecl = (JCTree.JCVariableDecl) tree;                        jcVariableDeclList = jcVariableDeclList.append(jcVariableDecl);                    }                }                jcVariableDeclList.forEach(jcVariableDecl -&gt; {                    messager.printMessage(Diagnostic.Kind.NOTE, jcVariableDecl.getName() + &quot; has been processed&quot;);                    jcClassDecl.defs = jcClassDecl.defs.prepend(makeGetterMethodDecl(jcVariableDecl));                });                super.visitClassDef(jcClassDecl);            }        });    });    return true;}</code></pre><p>步骤大概是下面这样：</p><ol><li>利用roundEnv的getElementsAnnotatedWith方法过滤出被Getter这个注解标记的类，并存入set</li><li>遍历这个set里的每一个元素，并生成jCTree这个语法树</li><li>创建一个TreeTranslator，并重写其中的visitClassDef方法，这个方法处理遍历语法树得到的类定义部分jcClassDecl<ul><li>创建一个jcVariableDeclList保存类的成员变量</li><li>遍历jcTree的所有成员(包括成员变量和成员函数和构造函数)，过滤出其中的成员变量，并添加进jcVariableDeclList</li><li>将jcVariableDeclList的所有变量转换成需要添加的getter方法，并添加进jcClassDecl的成员中</li><li>调用默认的遍历方法遍历处理后的jcClassDecl</li></ul></li><li>利用上面的TreeTranslator去处理jcTree</li></ol><p>接下来再实现makeGetterMethodDecl方法:</p><pre><code>private JCTree.JCMethodDecl makeGetterMethodDecl(JCTree.JCVariableDecl jcVariableDecl) {    ListBuffer&lt;JCTree.JCStatement&gt; statements = new ListBuffer&lt;&gt;();    statements.append(treeMaker.Return(treeMaker.Select(treeMaker.Ident(names.fromString(&quot;this&quot;)), jcVariableDecl.getName())));    JCTree.JCBlock body = treeMaker.Block(0, statements.toList());    return treeMaker.MethodDef(treeMaker.Modifiers(Flags.PUBLIC), getNewMethodName(jcVariableDecl.getName()), jcVariableDecl.vartype, List.nil(), List.nil(), List.nil(), body, null);}private Name getNewMethodName(Name name) {    String s = name.toString();    return names.fromString(&quot;get&quot; + s.substring(0, 1).toUpperCase() + s.substring(1, name.length()));}</code></pre><p>逻辑就是读取变量的定义，并创建对应的Getter方法，并试图用驼峰命名法。</p><p>整体上难点还是集中在api的使用上，还有一些细微的注意点:<br>首先，messager的printMessage方法在打印log的时候会自动过滤重复的log信息。<br>其次，这里的list并不是java.util里面的list，而是一个自定义的list，这个list的用法比较坑爹，他采用的是这样的方式:</p><pre><code>package com.sun.tools.javac.util;public class List&lt;A&gt; extends AbstractCollection&lt;A&gt; implements java.util.List&lt;A&gt; {    public A head;    public List&lt;A&gt; tail;    //...    List(A var1, List&lt;A&gt; var2) {        this.tail = var2;        this.head = var1;    }    public List&lt;A&gt; prepend(A var1) {        return new List(var1, this);    }    public static &lt;A&gt; List&lt;A&gt; of(A var0) {        return new List(var0, nil());    }    public List&lt;A&gt; append(A var1) {        return of(var1).prependList(this);    }    public static &lt;A&gt; List&lt;A&gt; nil() {        return EMPTY_LIST;    }    //...}</code></pre><p>挺有趣的，用这种叫cons而不是list的数据结构，添加元素的时候就把自己赋给自己的tail,新来的元素放进head。不过需要注意的是这个东西不支持链式调用，prepend之后还要将新值赋给自己。<br>而且这里在创建getter方法的时候还要把参数写全写对了，尤其是添加this指针的这种用法。</p><p>测试类<br>上面基本就是所有功能代码了，接下来我们要写一个类来测试一下(App.java)：</p><pre><code>package com.mythsman.test;@Getterpublic class App {    private String value;    private String value2;    public App(String value) {        this.value = value;    }    public static void main(String[] args) {        App app = new App(&quot;it works&quot;);        System.out.println(app.getValue());    }}</code></pre><p>不过，先不要急着构建，构建了肯定会失败，因为这原则上应该是两个项目。Getter.java是注解类没问题，但是GetterProcessor.java是处理器，App.java需要在编译期调用这个处理器，因此这两个东西是不能一起编译的，正确的编译方法应该是类似下面这样，写成compile.sh脚本就是：</p><pre><code>#!/usr/bin/env bashif [ -d classes ]; then    rm -rf classes;fimkdir classesjavac -cp $JAVA_HOME/lib/tools.jar com/mythsman/test/Getter* -d classes/javac -cp classes -d classes -processor com.mythsman.test.GetterProcessor com/mythsman/test/App.javajavap -p classes com/mythsman/test/App.classjava -cp classes com.mythsman.test.App</code></pre><p>其实是五个步骤:</p><ol><li>创建保存class文件的文件夹</li><li>导入tools.jar，编译processor并输出</li><li>编译App.java，并使用javac的-processor参数指定编译阶段的处理器GetterProcessor</li><li>用javap显示编译后的App.class文件(非必须，方便看结果)</li><li>执行测试类    </li></ol><p>好了，进入项目的根目录，当前的目录结构应该是这样的:</p><p>.<br>├── pom.xml<br>├── src<br>│   ├── main<br>│   │   ├── java<br>│   │   │   ├── com<br>│   │   │   │   └── mythsman<br>│   │   │   │       └── test<br>│   │   │   │           ├── App.java<br>│   │   │   │           ├── Getter.java<br>│   │   │   │           └── GetterProcessor.java<br>│   │   │   └── compile.sh</p><p>调用compile.sh，输出如下:</p><pre><code>Note: value has been processedNote: value2 has been processedCompiled from &quot;App.java&quot;public class com.mythsman.test.App {  private java.lang.String value;  private java.lang.String value2;  public java.lang.String getValue2();  public java.lang.String getValue();  public com.mythsman.test.App(java.lang.String);  public static void main(java.lang.String[]);}it works</code></pre><p>Note行就是在GetterProcessor类里通过messager打印的log，中间的是javap反编译的结果，最后一行表示测试调用成功。</p><h3 id="Maven构建并打包"><a href="#Maven构建并打包" class="headerlink" title="Maven构建并打包"></a>Maven构建并打包</h3><p>上面的测试部分其实是为了测试而测试，其实这应当是两个项目，一个是processor项目，这个项目应当被打成一个jar包，供调用者使用；另一个项目是app项目，这个项目是专门使用jar包的，他并不希望添加任何额外编译参数，就跟lombok的用法一样。<br>简单来说，就是我们希望把processor打成一个包，并且在使用时不需要添加额外参数。<br>那么如何在调用的时候不用加参数呢，其实我们知道java在编译的时候会去资源文件夹下读一个META-INF文件夹，这个文件夹下面除了MANIFEST.MF文件之外，还可以添加一个services文件夹，我们可以在这个文件夹下创建一个文件，文件名是javax.annotation.processing.Processor，文件内容是com.mythsman.test.GetterProcessor。<br>我们知道maven在编译前会先拷贝资源文件夹，然后当他在编译时候发现了资源文件夹下的META-INF/serivces文件夹时，他就会读取里面的文件，并将文件名所代表的接口用文件内容表示的类来实现。这就相当于做了-processor参数该做的事了。<br>当然这个文件我们并不希望调用者去写，而是希望在processor项目里集成，调用的时候能直接继承META-INF。</p><p>好了，我们先删除App.java和compile.sh，添加下META-INF文件夹，当前目录结构应该是这样的：</p><p>.<br>├── pom.xml<br>├── src<br>│   └── main<br>│       ├── java<br>│       │   └── com<br>│       │       └── mythsman<br>│       │           └── test<br>│       │               ├── Getter.java<br>│       │               └── GetterProcessor.java<br>│       └── resources<br>│           └── META-INF<br>│               └── services<br>│                   └── javax.annotation.processing.Processor</p><p>当然，我们还不能编译，因为processor项目并不需要把自己添加为processor(况且自己还没编译呢怎么调用自己)。。。完了，好像死循环了，自己在编译的时候不能添加services文件夹，但是又需要打的包里有services文件夹，这该怎么搞呢？<br>其实很简单，配置一下maven的插件就行，打开pom.xml,在project/build/标签里添加下面的配置:</p><pre><code>&lt;build&gt;   &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;excludes&gt;                &lt;exclude&gt;META-INF/**/*&lt;/exclude&gt;            &lt;/excludes&gt;        &lt;/resource&gt;    &lt;/resources&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;            &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;            &lt;version&gt;2.6&lt;/version&gt;            &lt;executions&gt;                &lt;execution&gt;                    &lt;id&gt;process-META&lt;/id&gt;                    &lt;phase&gt;prepare-package&lt;/phase&gt;                    &lt;goals&gt;                        &lt;goal&gt;copy-resources&lt;/goal&gt;                    &lt;/goals&gt;                    &lt;configuration&gt;                        &lt;outputDirectory&gt;target/classes&lt;/outputDirectory&gt;                        &lt;resources&gt;                            &lt;resource&gt;                                &lt;directory&gt;${basedir}/src/main/resources/&lt;/directory&gt;                                &lt;includes&gt;                                    &lt;include&gt;**/*&lt;/include&gt;                                &lt;/includes&gt;                            &lt;/resource&gt;                        &lt;/resources&gt;                    &lt;/configuration&gt;                &lt;/execution&gt;            &lt;/executions&gt;        &lt;/plugin&gt;        ...    &lt;/plugins&gt;&lt;/build&gt;</code></pre><p>我们知道maven构建的第一步就是调用maven-resources-plugin插件的resources命令，将resources文件夹复制到target/classes中，那么我们配置一下resources标签，过滤掉META-INF文件夹，这样在编译的时候就不会找到services的配置了。然后我们在打包前(prepare-package生命周期)再利用maven-resources-plugin插件的copy-resources命令把services文件夹重新拷贝过来不就好了么。<br>这样配置好了，就可以直接执行mvn clean install打包提交到本地私服:</p><pre><code>myths@pc:~/Desktop/test$ mvn clean install[INFO] Scanning for projects...[INFO] [INFO] ------------------------------------------------------------------------[INFO] Building test 1.0-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO] [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ getter ---[INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ getter ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] Copying 0 resource[INFO] [INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ getter ---[INFO] Changes detected - recompiling the module![INFO] Compiling 2 source files to /home/myths/Desktop/test/target/classes[INFO] [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ getter ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] skip non existing resourceDirectory /home/myths/Desktop/test/src/test/resources[INFO] [INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ getter ---[INFO] No sources to compile[INFO] [INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ getter ---[INFO] No tests to run.[INFO] [INFO] --- maven-resources-plugin:2.6:copy-resources (process-META) @ getter ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] Copying 1 resource[INFO] [INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ getter ---[INFO] Building jar: /home/myths/Desktop/test/target/getter-1.0-SNAPSHOT.jar[INFO] [INFO] --- maven-install-plugin:2.4:install (default-install) @ getter ---[INFO] Installing /home/myths/Desktop/test/target/getter-1.0-SNAPSHOT.jar to /home/myths/.m2/repository/com/mythsman/test/getter/1.0-SNAPSHOT/getter-1.0-SNAPSHOT.jar[INFO] Installing /home/myths/Desktop/test/pom.xml to /home/myths/.m2/repository/com/mythsman/test/getter/1.0-SNAPSHOT/getter-1.0-SNAPSHOT.pom[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 3.017 s[INFO] Finished at: 2017-12-19T19:57:04+08:00[INFO] Final Memory: 16M/201M[INFO] ------------------------------------------------------------------------</code></pre><p>可以看到这里的process-META作用生效。</p><p>调用jar包测试</p><p>重新创建一个测试项目app：</p><p>.<br>├── pom.xml<br>└── src<br>    └── main<br>        └── java<br>            └── com<br>                └── mythsman<br>                    └── test<br>                        └── App.java</p><p>pom.xml:</p><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.mythsman.test&lt;/groupId&gt;    &lt;artifactId&gt;app&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;name&gt;main&lt;/name&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.mythsman.test&lt;/groupId&gt;            &lt;artifactId&gt;getter&lt;/artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>App.java:</p><pre><code>package com.mythsman.test;@Getterpublic class App {    private String value;    private String value2;    public App(String value) {        this.value = value;    }    public static void main(String[] args) {        App app = new App(&quot;it works&quot;);        System.out.println(app.getValue());    }}</code></pre><p>编译并执行:</p><p>mvn clean compile &amp;&amp; java -cp target/classes com.mythsman.test.App</p><p>最后就会在构建成功后打印”it works”。</p><p><a href="https://zhuanlan.zhihu.com/p/32779910" target="_blank" rel="noopener">参考</a><br><a href="https://yq.aliyun.com/articles/59972" target="_blank" rel="noopener">参考</a><br><a href="https://juejin.im/entry/5a390ba76fb9a0451e3fed7c" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;what&quot;&gt;&lt;a href=&quot;#what&quot; class=&quot;headerlink&quot; title=&quot;what&quot;&gt;&lt;/a&gt;what&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://projectlombok.org&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
    
      <category term="Lombok" scheme="http://iwantjingjing.com/categories/Lombok/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="idea" scheme="http://iwantjingjing.com/tags/idea/"/>
    
      <category term="lombok" scheme="http://iwantjingjing.com/tags/lombok/"/>
    
      <category term="plugin" scheme="http://iwantjingjing.com/tags/plugin/"/>
    
  </entry>
  
  <entry>
    <title>初识Shiro</title>
    <link href="http://iwantjingjing.com/2019/09/12/%E5%88%9D%E8%AF%86Shiro/"/>
    <id>http://iwantjingjing.com/2019/09/12/初识Shiro/</id>
    <published>2019-09-12T05:56:37.000Z</published>
    <updated>2019-09-12T06:41:02.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><h1 id="when"><a href="#when" class="headerlink" title="when"></a>when</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;what&quot;&gt;&lt;a href=&quot;#what&quot; class=&quot;headerlink&quot; title=&quot;what&quot;&gt;&lt;/a&gt;what&lt;/h1&gt;&lt;h1 id=&quot;why&quot;&gt;&lt;a href=&quot;#why&quot; class=&quot;headerlink&quot; title=&quot;why&quot;&gt;&lt;/a&gt;wh
      
    
    </summary>
    
    
      <category term="Shiro" scheme="http://iwantjingjing.com/categories/Shiro/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="Shiro" scheme="http://iwantjingjing.com/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>Mac 下locate命令使用问题WARNING: The locate database (/var/db/locate.database) does not exist</title>
    <link href="http://iwantjingjing.com/2019/09/11/Mac-%E4%B8%8Blocate%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98WARNING-The-locate-database-var-db-locate-database-does-not-exist/"/>
    <id>http://iwantjingjing.com/2019/09/11/Mac-下locate命令使用问题WARNING-The-locate-database-var-db-locate-database-does-not-exist/</id>
    <published>2019-09-11T01:44:23.000Z</published>
    <updated>2019-09-11T01:48:29.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><img src="locate.png" alt></p><p>根据提示使用 </p><p>sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.locate.plist<br> 并没有生效。</p><p>需要执行</p><p>sudo /usr/libexec/locate.updatedb 进行库更新。</p><p><a href="https://www.cnblogs.com/b-ruce/p/5911048.html" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;locate.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;根据提示使用 &lt;/p&gt;
&lt;p&gt;sudo launchctl load -
      
    
    </summary>
    
    
      <category term="Mac" scheme="http://iwantjingjing.com/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://iwantjingjing.com/tags/Mac/"/>
    
      <category term="exception" scheme="http://iwantjingjing.com/tags/exception/"/>
    
  </entry>
  
  <entry>
    <title>mac上解决java.rmi.server.ExportException- Port already in use- 1099; nested exception is- java.net.Bi</title>
    <link href="http://iwantjingjing.com/2019/09/09/mac%E4%B8%8A%E8%A7%A3%E5%86%B3java-rmi-server-ExportException-Port-already-in-use-1099-nested-exception-is-java-net-Bi/"/>
    <id>http://iwantjingjing.com/2019/09/09/mac上解决java-rmi-server-ExportException-Port-already-in-use-1099-nested-exception-is-java-net-Bi/</id>
    <published>2019-09-09T10:39:14.000Z</published>
    <updated>2019-09-09T10:41:47.314Z</updated>
    
    <content type="html"><![CDATA[<p>tomcat启动报如下的错误：</p><p>java.rmi.server.ExportException: Port already in use: 1099; nested exception is: java.net.BindException: Address already in use (Bind failed)</p><p>解决方法有两种</p><h1 id="第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法"><a href="#第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法" class="headerlink" title="第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法"></a>第一种：换其他的端口再次启动，例如：换1098端口，如果你不想换其他端口，则见第二种方法</h1><h1 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h1><p>第一步：使用lsof -i tcp:1099 查看时那个应用占用了此端口</p><p>第二部：使用kill pid 即可，这里的pid是第一步所查询到结果</p><p><a href="https://blog.csdn.net/u010412719/article/details/76724125" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;tomcat启动报如下的错误：&lt;/p&gt;
&lt;p&gt;java.rmi.server.ExportException: Port already in use: 1099; nested exception is: java.net.BindException: Address a
      
    
    </summary>
    
    
      <category term="exception" scheme="http://iwantjingjing.com/categories/exception/"/>
    
    
      <category term="exception" scheme="http://iwantjingjing.com/tags/exception/"/>
    
      <category term="mac" scheme="http://iwantjingjing.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>关于 getWriter() has already been called for this response 的错误解决办法</title>
    <link href="http://iwantjingjing.com/2019/09/09/%E5%85%B3%E4%BA%8E-getWriter-has-already-been-called-for-this-response-%E7%9A%84%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://iwantjingjing.com/2019/09/09/关于-getWriter-has-already-been-called-for-this-response-的错误解决办法/</id>
    <published>2019-09-09T05:46:37.000Z</published>
    <updated>2019-09-09T05:51:21.206Z</updated>
    
    <content type="html"><![CDATA[<p>上篇Filter、FilterChain、FilterConfig 介绍<br>文中的代码若在多个filter中执行则会报错” getWriter() has already been called for this response “</p><p>解决方案为在doFilter() 之前将流关闭.</p><pre><code>public void doFilter(ServletRequest request, ServletResponse response,                        FilterChain chain) throws IOException, ServletException {       System.out.println(&quot;begin headers-------------------&quot;);       Enumeration&lt;?&gt; headerNames = ((HttpServletRequest)request).getHeaderNames();       while(headerNames.hasMoreElements()) {           String headerName = (String)headerNames.nextElement();           System.out.println(headerName + &quot;: &quot; + ((HttpServletRequest)request).getHeader(headerName));       }       System.out.println(&quot;end headers-------------------&quot;);       //在调用目标前写入响应内容       response.setContentType(&quot;text/html; charset=utf-8&quot;);       PrintWriter out = response.getWriter();       out.println(&quot;IP地址为：&quot; + request.getRemoteHost() + &quot;&lt;br&gt;&quot;);       //在目标返回后写入响应内容       out.println(&quot;&lt;br&gt;名称为encoding的初始化参数的值为：&quot; + paramValue);       out.println(&quot;&lt;br&gt;当前Web程序的真实路径为：&quot; + filterConfig.getServletContext().getRealPath(&quot;/&quot;));       out.close(); // 不关闭则会报错 getWriter() has already been called for this response       chain.doFilter(request, response);   }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上篇Filter、FilterChain、FilterConfig 介绍&lt;br&gt;文中的代码若在多个filter中执行则会报错” getWriter() has already been called for this response “&lt;/p&gt;
&lt;p&gt;解决方案为在doFi
      
    
    </summary>
    
    
      <category term="exception" scheme="http://iwantjingjing.com/categories/exception/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="exception" scheme="http://iwantjingjing.com/tags/exception/"/>
    
  </entry>
  
  <entry>
    <title> java.io.EOFException</title>
    <link href="http://iwantjingjing.com/2019/09/06/java-io-EOFException/"/>
    <id>http://iwantjingjing.com/2019/09/06/java-io-EOFException/</id>
    <published>2019-09-06T02:45:51.000Z</published>
    <updated>2019-09-06T03:01:19.702Z</updated>
    
    <content type="html"><![CDATA[<p>Caused by: java.io.EOFException: Can not read response from server. Expected to read 4 bytes, read 0 bytes before connection was unexpectedly lost.</p><p>启动ssm项目报上述错误,查了一堆答案</p><p>有说改 jdbc配置的,有说改数据库的<br>顺便还改了下数据库</p><pre><code>show variables like  &apos;wait_timeout&apos;;show global variables like  &apos;%wait%&apos;;        set wait_timeout=86400;</code></pre><p>问题都没有解决</p><p>最终解决方案:</p><p>可能是防火墙,翻墙软件等造成的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Caused by: java.io.EOFException: Can not read response from server. Expected to read 4 bytes, read 0 bytes before connection was unexpect
      
    
    </summary>
    
    
      <category term="exception" scheme="http://iwantjingjing.com/categories/exception/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="spring" scheme="http://iwantjingjing.com/tags/spring/"/>
    
      <category term="异常" scheme="http://iwantjingjing.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>hexo插入图片</title>
    <link href="http://iwantjingjing.com/2019/09/06/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    <id>http://iwantjingjing.com/2019/09/06/hexo插入图片/</id>
    <published>2019-09-06T02:26:13.000Z</published>
    <updated>2019-09-06T02:29:39.522Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。</p><p><img src="/images/image.jpg" alt></p></li><li><p>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。</p></li></ul><pre><code>post_asset_folder: true</code></pre><p>将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。</p><pre><code>_posts/post_name/image.jpg1![](image.jpg)</code></pre><p>[参考] (<a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/" target="_blank" rel="noopener">https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/image.jpg&quot; alt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;图片除了可以放在
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://iwantjingjing.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://iwantjingjing.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>读《活着》有感</title>
    <link href="http://iwantjingjing.com/2019/09/06/%E8%AF%BB-%E6%B4%BB%E7%9D%80-%E6%9C%89%E6%84%9F/"/>
    <id>http://iwantjingjing.com/2019/09/06/读-活着-有感/</id>
    <published>2019-09-06T02:05:22.000Z</published>
    <updated>2019-09-06T02:25:05.480Z</updated>
    
    <content type="html"><![CDATA[<p><img src="%E4%B8%8B%E8%BD%BD.jpeg" alt></p><ul><li><p>余华文笔真好,很有代入感</p></li><li><p>富贵就是那个时代的缩影</p></li><li><p>选择比努力重要</p></li><li><p>人首先要尊重自己!</p></li><li><p>凡事多替自己想想,富贵儿子死的真冤!</p></li><li><p>珍惜今天吧    </p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;%E4%B8%8B%E8%BD%BD.jpeg&quot; alt&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;余华文笔真好,很有代入感&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;富贵就是那个时代的缩影&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;选择比努力重要&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="读书" scheme="http://iwantjingjing.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读后感" scheme="http://iwantjingjing.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>Filter、FilterChain、FilterConfig 介绍</title>
    <link href="http://iwantjingjing.com/2019/09/06/Filter%E3%80%81FilterChain%E3%80%81FilterConfig-%E4%BB%8B%E7%BB%8D/"/>
    <id>http://iwantjingjing.com/2019/09/06/Filter、FilterChain、FilterConfig-介绍/</id>
    <published>2019-09-06T01:52:26.000Z</published>
    <updated>2019-09-09T07:29:19.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Filter-的基本工作原理"><a href="#一、Filter-的基本工作原理" class="headerlink" title="一、Filter 的基本工作原理"></a>一、Filter 的基本工作原理</h1><ul><li><p>1、Filter 程序是一个实现了特殊接口的 Java 类，与 Servlet 类似，也是由 Servlet 容器进行调用和执行的。</p></li><li><p>2、当在 web.xml 注册了一个 Filter 来对某个 Servlet 程序进行拦截处理时，它可以决定是否将请求继续传递给 Servlet 程序，以及对请求和响应消息是否进行修改。</p></li><li><p>3、当 Servlet 容器开始调用某个 Servlet 程序时，如果发现已经注册了一个 Filter 程序来对该 Servlet 进行拦截，那么容器不再直接调用 Servlet 的 service 方法，而是调用 Filter 的 doFilter 方法，再由 doFilter 方法决定是否去激活 service 方法。</p></li><li><p>4、但在 Filter.doFilter 方法中不能直接调用 Servlet 的 service 方法，而是调用 FilterChain.doFilter 方法来激活目标 Servlet 的 service 方法，FilterChain 对象是通过 Filter.doFilter 方法的参数传递进来的。</p></li><li><p>5、只要在 Filter.doFilter 方法中调用 FilterChain.doFilter 方法的语句前后增加某些程序代码，这样就可以在 Servlet 进行响应前后实现某些特殊功能。</p></li><li><p>6、如果在 Filter.doFilter 方法中没有调用 FilterChain.doFilter 方法，则目标 Servlet 的 service 方法不会被执行，这样通过 Filter 就可以阻止某些非法的访问请求。<br><img src="/images/Filter%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt></p><h1 id="二、Filter-链"><a href="#二、Filter-链" class="headerlink" title="二、Filter 链"></a>二、Filter 链</h1></li><li><p>1、在一个 Web 应用程序中可以注册多个 Filter 程序，每个 Filter 程序都可以对一个或一组 Servlet 程序进行拦截。如果有多个 Filter 程序都可以对某个 Servlet 程序的访问过程进行拦截，当针对该 Servlet 的访问请求到达时，Web 容器将把这多个 Filter 程序组合成一个 Filter 链（也叫过滤器链）。</p></li><li><p>2、Filter 链中的各个 Filter 的拦截顺序与它们在 web.xml 文件中的映射顺序一致，上一个 Filter.doFilter 方法中调用 FilterChain.doFilter 方法将激活下一个 Filter的doFilter 方法，最后一个 Filter.doFilter 方法中调用的 FilterChain.doFilter 方法将激活目标 Servlet的service 方法。</p></li><li><p>3、只要 Filter 链中任意一个 Filter 没有调用 FilterChain.doFilter 方法，则目标 Servlet 的 service 方法都不会被执行。</p></li></ul><h1 id="三、Filter-接口"><a href="#三、Filter-接口" class="headerlink" title="三、Filter 接口"></a>三、Filter 接口</h1><p>一个 Filter 程序就是一个 Java 类，这个类必须实现 Filter 接口。javax.servlet.Filter 接口中定义了三个方法：init、doFilter、destory。</p><h2 id="1、init-方法"><a href="#1、init-方法" class="headerlink" title="1、init 方法"></a>1、init 方法</h2><ul><li><p>在 Web 应用程序启动时，Web 服务器（Web 容器）将根据其 web.xml 文件的配置信息来创建每个注册的 Filter 的实例对象，并将其保存在内存中。</p></li><li><p>Web 容器创建 Filter 的实例对象后，将立即调用该 Filter 对象的 init 方法。init 方法在 Filter 生命周期中仅被执行一次，Web 容器在调用 init 方法时，会传递一个包含 Filter 的配置和运行环境信息的 FilterConfig 对象。</p></li></ul><pre><code>public voic init(FilterConfig filterConfig) throws ServletException</code></pre><ul><li>开发人员可以在 init 方法中完成与构造方法类似的初始化功能，要注意的是：如果初始化代码要使用到 FilterConfig 对象，这些代码只能在 init 方法中编写，而不能在构造方法中编写（尚未调用 init 方法，即并没有创建 FilterConfig 对象，要使用它则必然出错）。</li></ul><h2 id="2、doFilter-方法"><a href="#2、doFilter-方法" class="headerlink" title="2、doFilter 方法"></a>2、doFilter 方法</h2><p>当一个 Filter 对象能够拦截访问请求时，Servlet 容器将调用 Filter 对象的 doFilter 方法。</p><pre><code>public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws java.io.IOException.ServletException</code></pre><p>其中，参数 request 和 response 为 Web 容器或 Filter 链中上一个 Filter 传递过来的请求和响应对象；参数 chain 为代表当前 Filter 链的对象。</p><h2 id="3、destroy-方法"><a href="#3、destroy-方法" class="headerlink" title="3、destroy 方法"></a>3、destroy 方法</h2><p>该方法在 Web 容器卸载 Filter 对象之前被调用，也仅执行一次。可以完成与 init 方法相反的功能，释放被该 Filter 对象打开的资源，例如：关闭数据库连接和 IO 流。</p><h1 id="四、FilterChain-接口"><a href="#四、FilterChain-接口" class="headerlink" title="四、FilterChain 接口"></a>四、FilterChain 接口</h1><p>该接口用于定义一个 Filter 链的对象应该对外提供的方法，这个接口只定义了一个 doFilter 方法。</p><p>public void doFilter(ServletRequest request, ServletResponse response) throws java.io.IOException.ServletException</p><p>FilterChain 接口的 doFilter 方法用于通知 Web 容器把请求交给 Filter 链中的下一个 Filter 去处理，如果当前调用此方法的 Filter 对象是Filter 链中的最后一个 Filter，那么将把请求交给目标 Servlet 程序去处理。</p><h1 id="五、FilterConfig-接口"><a href="#五、FilterConfig-接口" class="headerlink" title="五、FilterConfig 接口"></a>五、FilterConfig 接口</h1><h2 id="1、与普通的-Servlet-程序一样，Filter-程序也很可能需要访问-Servlet-容器。Servlet-规范将代表-ServletContext-对象和-Filter-的配置参数信息都封装到一个称为-FilterConfig-的对象中。"><a href="#1、与普通的-Servlet-程序一样，Filter-程序也很可能需要访问-Servlet-容器。Servlet-规范将代表-ServletContext-对象和-Filter-的配置参数信息都封装到一个称为-FilterConfig-的对象中。" class="headerlink" title="1、与普通的 Servlet 程序一样，Filter 程序也很可能需要访问 Servlet 容器。Servlet 规范将代表 ServletContext 对象和 Filter 的配置参数信息都封装到一个称为 FilterConfig 的对象中。"></a>1、与普通的 Servlet 程序一样，Filter 程序也很可能需要访问 Servlet 容器。Servlet 规范将代表 ServletContext 对象和 Filter 的配置参数信息都封装到一个称为 FilterConfig 的对象中。</h2><h2 id="2、FilterConfig-接口则用于定义-FilterConfig-对象应该对外提供的方法，以便在-Filter-程序中可以调用这些方法来获取-ServletContext-对象，以及获取在-web-xml-文件中为-Filter-设置的友好名称和初始化参数。"><a href="#2、FilterConfig-接口则用于定义-FilterConfig-对象应该对外提供的方法，以便在-Filter-程序中可以调用这些方法来获取-ServletContext-对象，以及获取在-web-xml-文件中为-Filter-设置的友好名称和初始化参数。" class="headerlink" title="2、FilterConfig 接口则用于定义 FilterConfig 对象应该对外提供的方法，以便在 Filter 程序中可以调用这些方法来获取 ServletContext 对象，以及获取在 web.xml 文件中为 Filter 设置的友好名称和初始化参数。"></a>2、FilterConfig 接口则用于定义 FilterConfig 对象应该对外提供的方法，以便在 Filter 程序中可以调用这些方法来获取 ServletContext 对象，以及获取在 web.xml 文件中为 Filter 设置的友好名称和初始化参数。</h2><h2 id="3、FilterConfig接口定义的各个方法："><a href="#3、FilterConfig接口定义的各个方法：" class="headerlink" title="3、FilterConfig接口定义的各个方法："></a>3、FilterConfig接口定义的各个方法：</h2><ul><li><p>getFilterName 方法，返回 <filter-name> 元素的设置值。</filter-name></p></li><li><p>getServletContext 方法，返回 FilterConfig 对象中所包装的 ServletContext 对象的引用。</p></li><li><p>getInitParameter 方法，用于返回在 web.xml 文件中为 Filter 所设置的某个名称的初始化的参数值。</p></li><li><p>getInitParameterNames 方法，返回一个 Enumeration 集合对象。</p></li></ul><h1 id="六、Filter-的注册与映射"><a href="#六、Filter-的注册与映射" class="headerlink" title="六、Filter 的注册与映射"></a>六、Filter 的注册与映射</h1><h2 id="1、注册-Filter"><a href="#1、注册-Filter" class="headerlink" title="1、注册 Filter"></a>1、注册 Filter</h2><p>一个 <filter> 元素用于注册一个 Filter。其中，<filter-name> 元素是必需的，<filter-class> 元素也是必需的，<init-param> 元素是可选的，可以有多个 &lt; init-param&gt; 元素。</init-param></filter-class></filter-name></filter></p><pre><code>&lt;filter&gt;    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;    &lt;filter-class&gt;FirstFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;GB2312&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;</code></pre><h2 id="2、映射-Filter"><a href="#2、映射-Filter" class="headerlink" title="2、映射 Filter"></a>2、映射 Filter</h2><pre><code>&lt;filter-mapping&gt; 元素用于设置一个 Filter 所负责拦截的资源。一个 Filter 拦截的资源可以通过两种方式来指定：资源的访问请求路径和 Servlet 名称。</code></pre><h3 id="第一种：指定资源的访问路径"><a href="#第一种：指定资源的访问路径" class="headerlink" title="第一种：指定资源的访问路径"></a>第一种：指定资源的访问路径</h3><pre><code>&lt;filter-mapping&gt;    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><p><url-pattern> 元素中的访问路径的设置方式遵循 Servlet 的 URL 映射规范。</url-pattern></p><ul><li><p>/*：表示拦截所有的访问请求。</p></li><li><p>/filter/*：表示拦截 filter 目录下的所有访问请求，如：<a href="http://localhost:8888/testFilter_001/filter/xxxxxx" target="_blank" rel="noopener">http://localhost:8888/testFilter_001/filter/xxxxxx</a> 。</p></li><li><p>/test.html：表示拦截根目录下以 test.html 为资源名的访问请求，访问链接只会是：<a href="http://localhost:8888/test.html。" target="_blank" rel="noopener">http://localhost:8888/test.html。</a></p></li></ul><h3 id="第二种：指定-Servlet-的名称"><a href="#第二种：指定-Servlet-的名称" class="headerlink" title="第二种：指定 Servlet 的名称"></a>第二种：指定 Servlet 的名称</h3><pre><code>&lt;filter-mapping&gt;    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;    &lt;servlet-name&gt;default&gt;&lt;/servlet-name&gt;    &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;    &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;&lt;/filter-mapping&gt;</code></pre><p>（1）、<servlet-name> 元素与 <url-pattern> 元素是二选一的关系，其值是某个 Servlet 在 web.xml 文件中的注册名称。<br>（2）、<dispatcher> 元素的设置值有 4 种：REQUEST、INCLUDE、FORWARD、ERROR，分别对应 Servlet 容器调用资源的 4 种方式：</dispatcher></url-pattern></servlet-name></p><ul><li>通过正常的访问请求调用；</li><li>通过 RequestDispatcher.include 方法调用；</li><li>通过 RequestDispatcher.forward 方法调用；</li><li>作为错误响应资源调用。<br>如果没有设置 <dispatcher> 子元素，则等效于 REQUEST 的情况。也可以设置多个 <dispatcher> 子元素，用于指定 Filter 对资源的多种调用方式都进行拦截。</dispatcher></dispatcher></li></ul><h1 id="七、Filter-程序示例"><a href="#七、Filter-程序示例" class="headerlink" title="七、Filter 程序示例"></a>七、Filter 程序示例</h1><p>FitstFilter.java</p><pre><code>import java.io.IOException;import java.io.PrintWriter;import java.util.Enumeration;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;public class FirstFilter implements Filter {    private FilterConfig filterConfig = null;    String paramValue = null;    @Override    public void init(FilterConfig filterConfig) throws ServletException {        this.filterConfig = filterConfig;        paramValue = filterConfig.getInitParameter(&quot;encoding&quot;);    }    @Override    public void doFilter(ServletRequest request, ServletResponse response,            FilterChain chain) throws IOException, ServletException {        System.out.println(&quot;begin headers-------------------&quot;);        Enumeration&lt;?&gt; headerNames = ((HttpServletRequest)request).getHeaderNames();        while(headerNames.hasMoreElements()) {            String headerName = (String)headerNames.nextElement();            System.out.println(headerName + &quot;: &quot; + ((HttpServletRequest)request).getHeader(headerName));        }        System.out.println(&quot;end headers-------------------&quot;);        //在调用目标前写入响应内容        response.setContentType(&quot;text/html; charset=gb2312&quot;);        PrintWriter out = response.getWriter();        out.println(&quot;IP地址为：&quot; + request.getRemoteHost() + &quot;&lt;br&gt;&quot;);        chain.doFilter(request, response);        //在目标返回后写入响应内容        out.println(&quot;&lt;br&gt;名称为encoding的初始化参数的值为：&quot; + paramValue);        out.println(&quot;&lt;br&gt;当前Web程序的真实路径为：&quot; + filterConfig.getServletContext().getRealPath(&quot;/&quot;));        //out.println(&quot;&lt;br&gt;修改了test.html文件！&quot;);    }    @Override    public void destroy() {        this.filterConfig = null;    }}</code></pre><p>web.xml</p><pre><code>&lt;filter&gt;    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;    &lt;filter-class&gt;FirstFilter&lt;/filter-class&gt;    &lt;init-param&gt;    &lt;param-name&gt;encoding&lt;/param-name&gt;    &lt;param-value&gt;GB2312&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;FirstFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><p>test.html（位于WebContent路径的filter目录中）</p><pre><code>&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;这就是test.html页面的原始内容！&lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="https://my.oschina.net/u/1171518/blog/265467" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、Filter-的基本工作原理&quot;&gt;&lt;a href=&quot;#一、Filter-的基本工作原理&quot; class=&quot;headerlink&quot; title=&quot;一、Filter 的基本工作原理&quot;&gt;&lt;/a&gt;一、Filter 的基本工作原理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1、Fil
      
    
    </summary>
    
    
      <category term="java" scheme="http://iwantjingjing.com/categories/java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="filter" scheme="http://iwantjingjing.com/tags/filter/"/>
    
  </entry>
  
  <entry>
    <title>一个bug的旅程</title>
    <link href="http://iwantjingjing.com/2019/09/04/%E4%B8%80%E4%B8%AAbug%E7%9A%84%E6%97%85%E7%A8%8B/"/>
    <id>http://iwantjingjing.com/2019/09/04/一个bug的旅程/</id>
    <published>2019-09-04T10:15:09.000Z</published>
    <updated>2019-09-04T10:35:00.761Z</updated>
    
    <content type="html"><![CDATA[<p>大家好我叫bug,我爸叫后台,我妈叫大前端(H5,安卓,IOS)<br>听说有一个叫天堂的地方特美,我的目标就是天堂.</p><p>一天我懒洋洋的躺在海边,沐浴着和煦得阳光.吃着习惯,吹着<br>海风.意淫着隔壁的漂亮妹子……</p><p>突然一个叫测试的家伙发现了我!追着我就跑,非说要超度<br>我到天堂!</p><p>天堂有个规矩:不收无名之辈</p><p>两条路摆在了我面前</p><pre><code>1: 测试拿问题页面 -&gt; 前端 -&gt; 前端提供接口名 参数 返回值 -&gt; 后台2: 测试拿问题页面 -&gt; 后端 -&gt; 前端 -&gt; 前端提供接口名 参数 返回值 -&gt; 后台</code></pre><p>好吧测试是个傻子一会儿走路线1 一会儿走路线2</p><p>我走路线1,很快到了天堂,天堂有好多妹子……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家好我叫bug,我爸叫后台,我妈叫大前端(H5,安卓,IOS)&lt;br&gt;听说有一个叫天堂的地方特美,我的目标就是天堂.&lt;/p&gt;
&lt;p&gt;一天我懒洋洋的躺在海边,沐浴着和煦得阳光.吃着习惯,吹着&lt;br&gt;海风.意淫着隔壁的漂亮妹子……&lt;/p&gt;
&lt;p&gt;突然一个叫测试的家伙发现了我!
      
    
    </summary>
    
    
      <category term="生活" scheme="http://iwantjingjing.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://iwantjingjing.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="bug" scheme="http://iwantjingjing.com/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>JSP与JavaScript</title>
    <link href="http://iwantjingjing.com/2019/09/04/JSP%E4%B8%8EJavaScript/"/>
    <id>http://iwantjingjing.com/2019/09/04/JSP与JavaScript/</id>
    <published>2019-09-04T09:50:42.000Z</published>
    <updated>2019-09-04T10:10:26.558Z</updated>
    
    <content type="html"><![CDATA[<p>某日在洗手间偶遇某大牛,聊起JSP,大牛曰:”JSP 哦知道,JavaScript”<br>我竟无言以对!在此记录一下JSP与JavaScript的区别</p><h1 id="首先下结论-雷锋与雷锋塔的区别"><a href="#首先下结论-雷锋与雷锋塔的区别" class="headerlink" title="首先下结论 雷锋与雷锋塔的区别"></a>首先下结论 雷锋与雷锋塔的区别</h1><h2 id="JSP是什么"><a href="#JSP是什么" class="headerlink" title="JSP是什么"></a>JSP是什么</h2><p>SUN首先发展出SERVLET，其功能比较强劲，体系设计也很先进，只是，它输出HTML语句还是采用了老的CGI方式，是一句一句输出，所以，编写和修改HTML非常不方便。 后来SUN推出了类似于ASP的镶嵌型的JSP，把JSP TAG镶嵌到HTML语句中，这样，就大大简化和方便了网页的设计和修改。</p><p>JSP全名为Java Server Pages，其根本是一个简化的Servlet设计，他实现了Html语法中的java扩张（以 &lt;%, %&gt;形式）。JSP与Servlet一样，是在服务器端执行的。通常返回给客户端的就是一个HTML文本，因此客户端只要有浏览器就能浏览。Web服务器在遇到访问JSP网页的请求时，首先执行其中的程序段，然后将执行结果连同JSP文件中的HTML代码一起返回给客户端。插入的Java程序段可以操作数据库、重新定向网页等，以实现建立动态网页所需要的功能。</p><p>JSP页面由HTML代码和嵌入其中的Java代码所组成。服务器在页面被客户端请求以后对这些Java代码进行处理，然后将生成的HTML页面返回给客户端的浏览器。Java Servlet是JSP的技术基础，而且大型的Web应用程序的开发需要Java Servlet和JSP配合才能完成。JSP具备了Java技术的简单易用，完全的面向对象，具有平台无关性且安全可靠，主要面向因特网的所有特点。</p><p>jsp 要先翻译，注意是翻译成servlet才能执行：<br>比如 test.jsp 要变成 test_jsp.java 然后编译成 test_jsp.class<br>而 test_jsp.java 本身就是一个servlet.<br>所以 jsp只是servlet的一个变种，方便书写html内容才出现的。</p><pre><code>servlet的运行机制和Applet类似，只不过它运行在服务器端。一个servlet是javax.servlet包中HttpServlet类的子类，由支持servlet的服务器完成该子类的对象，即servlet的初始化。扩展阅读0：jsp转化为servlet的过程：http://www.w3cschool.cc/jsp/jsp-architecture.html扩展阅读1：servlet版的Helloworld（需要装tomcat,我通常使用XAMPP集成的tomcat）http://blog.163.com/adoom_2010/blog/static/1820326362011710102719527/扩展阅读2：servlet程序中的各部分的作用、调用顺序http://wenku.baidu.com/link?url=U2B6Gx_C1X702ppIFJdXR23MyY85lZzJeneIDZSFCuA3bZ-ynwDFx9oYm4pNcpa4ZjmlUPnkrtwkHg0skxdo3mqOY-IAvXzzYqaCOc7DVmW</code></pre><h2 id="JavaScript是什么"><a href="#JavaScript是什么" class="headerlink" title="JavaScript是什么"></a>JavaScript是什么</h2><p>Java Script 是一种基于对象的客户端脚本语言。主要目的是为了解决服务器端语言，比如Perl，遗留的速度问题，为客户提供更流畅的浏览效果。JS可以直接嵌入到html代码中进行解析执行，非常简单易学，可以产生很多动态的效果。</p><h2 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h2><p>简单地说——JS是在客户端执行的，需要浏览器支持Javascript。JSP是在服务器端执行的，需要服务器上部署支持Servlet的服务器程序。JS代码是能够直接从服务器上download得到，对外是可见的，jsp(和翻译后的servlet)代码是对外不可见的。</p><p>JS与JavaScript相比：虽然JavaScript可以在客户端动态生成HTML，但是很难与服务器交互，因此不能提供复杂的服务，比如访问数据库和图像处理等等。JSP在HTML中用&lt;%%&gt;里面实现。JS在html中用<script></script>实现</p><p><a href="https://zh.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">参考1</a><br><a href="https://zh.wikipedia.org/wiki/JSP" target="_blank" rel="noopener">参考2</a><br><a href="https://blog.csdn.net/a2806005024/article/details/28265503" target="_blank" rel="noopener">参考3</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;某日在洗手间偶遇某大牛,聊起JSP,大牛曰:”JSP 哦知道,JavaScript”&lt;br&gt;我竟无言以对!在此记录一下JSP与JavaScript的区别&lt;/p&gt;
&lt;h1 id=&quot;首先下结论-雷锋与雷锋塔的区别&quot;&gt;&lt;a href=&quot;#首先下结论-雷锋与雷锋塔的区别&quot; clas
      
    
    </summary>
    
    
      <category term="笑话" scheme="http://iwantjingjing.com/categories/%E7%AC%91%E8%AF%9D/"/>
    
    
      <category term="JSP" scheme="http://iwantjingjing.com/tags/JSP/"/>
    
      <category term="JavaScript" scheme="http://iwantjingjing.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>idea将普通Java项目改为Maven项目</title>
    <link href="http://iwantjingjing.com/2019/09/04/idea%E5%B0%86%E6%99%AE%E9%80%9AJava%E9%A1%B9%E7%9B%AE%E6%94%B9%E4%B8%BAMaven%E9%A1%B9%E7%9B%AE/"/>
    <id>http://iwantjingjing.com/2019/09/04/idea将普通Java项目改为Maven项目/</id>
    <published>2019-09-04T02:05:05.000Z</published>
    <updated>2019-09-04T02:14:05.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方式-1"><a href="#方式-1" class="headerlink" title="方式 1"></a>方式 1</h1><p>1 在项目右键 Add Framework Support</p><p>2 选择maven</p><h1 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h1><p>1.右键工程文件，新建文件pom.xml，并填写好内容。</p><p>2.在pom.xml 文件上右键 Add as Maven Project。</p><p>3.idea自己导入maven。</p><h1 id="怎么在pom-xml中添加项目中libs下的jar呢，而不是从本地仓库中添加？"><a href="#怎么在pom-xml中添加项目中libs下的jar呢，而不是从本地仓库中添加？" class="headerlink" title="怎么在pom.xml中添加项目中libs下的jar呢，而不是从本地仓库中添加？"></a>怎么在pom.xml中添加项目中libs下的jar呢，而不是从本地仓库中添加？</h1><p>1、首先将要添加的jar包复制到项目中的libs文件夹下</p><p>2、然后在pom.xml中添加如下代码：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;htmlunit&lt;/groupId&gt;    &lt;artifactId&gt;htmlunit&lt;/artifactId&gt;    &lt;version&gt;2.21-OSGi&lt;/version&gt;    &lt;scope&gt;system&lt;/scope&gt;    &lt;systemPath&gt;${project.basedir}/libs/htmlunit-2.21-OSGi.jar&lt;/systemPath&gt;&lt;/dependency&gt;</code></pre><p>注意scope元素和systemPath元素，其中systemPath元素指定的就是jar包在项目中的路径。<br>注意libs文件夹下的这个jar包不需要Add to Build Path</p><p><a href="https://blog.csdn.net/zhengxiangwen/article/details/50734565" target="_blank" rel="noopener">参考1</a><br><a href="https://blog.csdn.net/lcgoing/article/details/86928738" target="_blank" rel="noopener">参考2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;方式-1&quot;&gt;&lt;a href=&quot;#方式-1&quot; class=&quot;headerlink&quot; title=&quot;方式 1&quot;&gt;&lt;/a&gt;方式 1&lt;/h1&gt;&lt;p&gt;1 在项目右键 Add Framework Support&lt;/p&gt;
&lt;p&gt;2 选择maven&lt;/p&gt;
&lt;h1 id=&quot;方式2
      
    
    </summary>
    
    
      <category term="java" scheme="http://iwantjingjing.com/categories/java/"/>
    
    
      <category term="java" scheme="http://iwantjingjing.com/tags/java/"/>
    
      <category term="idea" scheme="http://iwantjingjing.com/tags/idea/"/>
    
      <category term="maven" scheme="http://iwantjingjing.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>idea突然有些字母不显示</title>
    <link href="http://iwantjingjing.com/2019/09/03/idea%E7%AA%81%E7%84%B6%E6%9C%89%E4%BA%9B%E5%AD%97%E6%AF%8D%E4%B8%8D%E6%98%BE%E7%A4%BA/"/>
    <id>http://iwantjingjing.com/2019/09/03/idea突然有些字母不显示/</id>
    <published>2019-09-03T10:24:49.000Z</published>
    <updated>2019-09-03T10:30:45.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="https://img-blog.csdn.net/20171031204114987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUGV0ZXJzaHVzaGVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>解决方案：更换idea字体，点击apply按钮即可正常显示<br><img src="https://liuyanzhao.com/wp-content/uploads/2018/10/WX20181011-211337@2x.png" alt></p><p><a href="https://blog.csdn.net/Petershusheng/article/details/78407839" target="_blank" rel="noopener">参考1</a></p><p><a href="https://liuyanzhao.com/8867.html" target="_blank" rel="noopener">参考2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20171031204114987?watermark/2/text
      
    
    </summary>
    
    
      <category term="idea" scheme="http://iwantjingjing.com/categories/idea/"/>
    
    
      <category term="idea" scheme="http://iwantjingjing.com/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>spring mvc 控制台输出乱码</title>
    <link href="http://iwantjingjing.com/2019/09/03/spring-mvc-%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E4%B9%B1%E7%A0%81/"/>
    <id>http://iwantjingjing.com/2019/09/03/spring-mvc-控制台输出乱码/</id>
    <published>2019-09-03T10:18:19.000Z</published>
    <updated>2019-09-09T07:43:39.494Z</updated>
    
    <content type="html"><![CDATA[<p>1、运行环境：<br>操作系统系统：Mac OS X10.12.6，语言：英文<br>开发工具：IntelliJ IDEA 2017.2.2，默认编码：UTF-8<br>Tomcat:9.0.0.M26<br>2、问题：运行Web项目时，控制台输出乱码。<br>3、解决方法：<br>设置Servlet的VM options(虚拟机选项)为：-Dfile.encoding=UTF-8<br><img src="/images/vmset.png" alt></p><p><a href="https://www.cnblogs.com/gdwkong/p/7457181.html" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、运行环境：&lt;br&gt;操作系统系统：Mac OS X10.12.6，语言：英文&lt;br&gt;开发工具：IntelliJ IDEA 2017.2.2，默认编码：UTF-8&lt;br&gt;Tomcat:9.0.0.M26&lt;br&gt;2、问题：运行Web项目时，控制台输出乱码。&lt;br&gt;3、解决方法
      
    
    </summary>
    
    
      <category term="Tomcat" scheme="http://iwantjingjing.com/categories/Tomcat/"/>
    
    
      <category term="Spring" scheme="http://iwantjingjing.com/tags/Spring/"/>
    
      <category term="Tomcat" scheme="http://iwantjingjing.com/tags/Tomcat/"/>
    
  </entry>
  
</feed>
